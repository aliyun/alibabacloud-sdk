/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'dms-enterprise';
  @version = '2018-11-01';
  @endpointRule = 'central';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AddLogicTableRouteConfigRequest {
  regionId?: string(name='RegionId', position='Host'),
  routeExpr: string(name='RouteExpr', position='Query'),
  routeKey: string(name='RouteKey', position='Query'),
  tableId: long(name='TableId', position='Query'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model AddLogicTableRouteConfigResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddLogicTableRouteConfigResponse = {
  headers: map[string]string(name='headers'),
  body: AddLogicTableRouteConfigResponseBody(name='body'),
}

async function addLogicTableRouteConfig(request: AddLogicTableRouteConfigRequest): AddLogicTableRouteConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddLogicTableRouteConfig', 'POST', '/', 'json', false, 'json', request);
}

model ApproveOrderRequest {
  approvalType: string(name='ApprovalType', position='Query'),
  comment?: string(name='Comment', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', position='Query'),
  workflowInstanceId: long(name='WorkflowInstanceId', minimum=1, position='Query'),
}

model ApproveOrderResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ApproveOrderResponse = {
  headers: map[string]string(name='headers'),
  body: ApproveOrderResponseBody(name='body'),
}

async function approveOrder(request: ApproveOrderRequest): ApproveOrderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ApproveOrder', 'POST', '/', 'json', false, 'json', request);
}

model ChangeColumnSecLevelRequest {
  columnName: string(name='ColumnName', position='Query'),
  dbId: long(name='DbId', position='Query'),
  isLogic: boolean(name='IsLogic', position='Query'),
  newLevel: string(name='NewLevel', description='新的敏感等级', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  schemaName: string(name='SchemaName', position='Query'),
  tableName: string(name='TableName', position='Query'),
  tid?: long(name='Tid', position='Query'),
}

model ChangeColumnSecLevelResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ChangeColumnSecLevelResponse = {
  headers: map[string]string(name='headers'),
  body: ChangeColumnSecLevelResponseBody(name='body'),
}

async function changeColumnSecLevel(request: ChangeColumnSecLevelRequest): ChangeColumnSecLevelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ChangeColumnSecLevel', 'POST', '/', 'json', false, 'json', request);
}

model CloseOrderRequest {
  closeReason: string(name='CloseReason', position='Query'),
  orderId: long(name='OrderId', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', position='Query'),
}

model CloseOrderResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CloseOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CloseOrderResponseBody(name='body'),
}

async function closeOrder(request: CloseOrderRequest): CloseOrderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CloseOrder', 'POST', '/', 'json', false, 'json', request);
}

model CreateDataCorrectOrderRequest {
  attachmentKey?: string(name='AttachmentKey', position='Query'),
  comment: string(name='Comment', position='Query'),
  param: {
    attachmentName?: string(name='AttachmentName'),
    classify?: string(name='Classify'),
    dbItemList: [ 
      {
        dbId: long(name='DbId'),
        logic: boolean(name='Logic'),
      }
    ](name='DbItemList'),
    estimateAffectRows: long(name='EstimateAffectRows'),
    execSQL?: string(name='ExecSQL'),
    rollbackAttachmentName?: string(name='RollbackAttachmentName'),
    rollbackSQL?: string(name='RollbackSQL'),
    rollbackSqlType?: string(name='RollbackSqlType'),
    sqlType: string(name='SqlType'),
  }(name='Param', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  relatedUserList?: [ long ](name='RelatedUserList', position='Query'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model CreateDataCorrectOrderResponseBody = {
  createOrderResult?: [ long ](name='CreateOrderResult'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model CreateDataCorrectOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDataCorrectOrderResponseBody(name='body'),
}

async function createDataCorrectOrder(request: CreateDataCorrectOrderRequest): CreateDataCorrectOrderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDataCorrectOrder', 'POST', '/', 'json', false, 'json', request);
}

model CreateDataCronClearOrderRequest {
  attachmentKey?: string(name='AttachmentKey', position='Query'),
  comment: string(name='Comment', position='Query'),
  param: {
    classify?: string(name='Classify'),
    cronClearItemList: [ 
      {
        columnName: string(name='ColumnName'),
        filterSQL?: string(name='FilterSQL'),
        remainDays: long(name='RemainDays'),
        tableName: string(name='TableName'),
        timeUnit?: string(name='TimeUnit'),
      }
    ](name='CronClearItemList'),
    cronFormat: string(name='CronFormat'),
    dbItemList: [ 
      {
        dbId: long(name='DbId'),
        logic: boolean(name='Logic'),
      }
    ](name='DbItemList'),
    durationHour?: long(name='DurationHour'),
    specifyDuration: boolean(name='specifyDuration'),
  }(name='Param', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  relatedUserList?: [ long ](name='RelatedUserList', position='Query'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model CreateDataCronClearOrderResponseBody = {
  createOrderResult?: [ long ](name='CreateOrderResult'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model CreateDataCronClearOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDataCronClearOrderResponseBody(name='body'),
}

async function createDataCronClearOrder(request: CreateDataCronClearOrderRequest): CreateDataCronClearOrderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDataCronClearOrder', 'POST', '/', 'json', false, 'json', request);
}

model CreateDataImportOrderRequest {
  attachmentKey?: string(name='AttachmentKey', position='Query'),
  comment: string(name='Comment', position='Query'),
  param: {
    attachmentName: string(name='AttachmentName'),
    classify?: string(name='Classify'),
    csvFirstRowIsColumnDef?: boolean(name='CsvFirstRowIsColumnDef'),
    dbItemList: [ 
      {
        dbId: long(name='DbId'),
        logic: boolean(name='Logic'),
      }
    ](name='DbItemList'),
    fileEncoding?: string(name='FileEncoding'),
    fileType: string(name='FileType'),
    ignoreError?: boolean(name='IgnoreError'),
    importMode?: string(name='ImportMode'),
    insertType?: string(name='InsertType'),
    rollbackAttachmentName?: string(name='RollbackAttachmentName'),
    rollbackSQL?: string(name='RollbackSQL'),
    rollbackSqlType?: string(name='RollbackSqlType'),
    tableName?: string(name='TableName'),
  }(name='Param', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  relatedUserList?: [ long ](name='RelatedUserList', position='Query'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model CreateDataImportOrderResponseBody = {
  createOrderResult?: [ long ](name='CreateOrderResult'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model CreateDataImportOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDataImportOrderResponseBody(name='body'),
}

async function createDataImportOrder(request: CreateDataImportOrderRequest): CreateDataImportOrderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDataImportOrder', 'POST', '/', 'json', false, 'json', request);
}

model CreateFreeLockCorrectOrderRequest {
  attachmentKey?: string(name='AttachmentKey', position='Query'),
  comment: string(name='Comment', position='Query'),
  param: {
    attachmentName?: string(name='AttachmentName'),
    classify?: string(name='Classify'),
    dbItemList: [ 
      {
        dbId: long(name='DbId'),
        logic: boolean(name='Logic'),
      }
    ](name='DbItemList'),
    execSQL: string(name='ExecSQL'),
    rollbackAttachmentName?: string(name='RollbackAttachmentName'),
    rollbackSQL?: string(name='RollbackSQL'),
    rollbackSqlType?: string(name='RollbackSqlType'),
    sqlType: string(name='SqlType'),
  }(name='Param', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  relatedUserList?: [ long ](name='RelatedUserList', position='Query'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model CreateFreeLockCorrectOrderResponseBody = {
  createOrderResult?: [ long ](name='CreateOrderResult'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model CreateFreeLockCorrectOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFreeLockCorrectOrderResponseBody(name='body'),
}

async function createFreeLockCorrectOrder(request: CreateFreeLockCorrectOrderRequest): CreateFreeLockCorrectOrderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateFreeLockCorrectOrder', 'POST', '/', 'json', false, 'json', request);
}

model CreateLogicDatabaseRequest {
  alias: string(name='Alias', position='Query'),
  databaseIds: [ long ](name='DatabaseIds', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model CreateLogicDatabaseResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  logicDbId?: long(name='LogicDbId'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model CreateLogicDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLogicDatabaseResponseBody(name='body'),
}

async function createLogicDatabase(request: CreateLogicDatabaseRequest): CreateLogicDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLogicDatabase', 'POST', '/', 'json', false, 'json', request);
}

model CreateOrderRequest {
  attachmentKey?: string(name='AttachmentKey', position='Query'),
  comment: string(name='Comment', position='Query'),
  pluginParam: map[string]any(name='PluginParam', position='Body'),
  pluginType: string(name='PluginType', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  relatedUserList?: string(name='RelatedUserList', position='Query'),
  tid?: long(name='Tid', position='Query'),
}

model CreateOrderResponseBody = {
  createOrderResult?: {
    orderIds?: [ long ](name='OrderIds')
  }(name='CreateOrderResult'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CreateOrderResponseBody(name='body'),
}

async function createOrder(request: CreateOrderRequest): CreateOrderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateOrder', 'POST', '/', 'json', true, 'form', request);
}

model CreateProxyRequest {
  instanceId: long(name='InstanceId', position='Query'),
  password: string(name='Password', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
  username: string(name='Username', position='Query'),
}

model CreateProxyResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  proxyId?: long(name='ProxyId'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model CreateProxyResponse = {
  headers: map[string]string(name='headers'),
  body: CreateProxyResponseBody(name='body'),
}

async function createProxy(request: CreateProxyRequest): CreateProxyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateProxy', 'POST', '/', 'json', false, 'json', request);
}

model CreateProxyAccessRequest {
  indepAccount?: string(name='IndepAccount', position='Query'),
  indepPassword?: string(name='IndepPassword', position='Query'),
  proxyId: long(name='ProxyId', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
  userId: long(name='UserId', position='Query'),
}

model CreateProxyAccessResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  proxyAccessId?: long(name='ProxyAccessId'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model CreateProxyAccessResponse = {
  headers: map[string]string(name='headers'),
  body: CreateProxyAccessResponseBody(name='body'),
}

async function createProxyAccess(request: CreateProxyAccessRequest): CreateProxyAccessResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateProxyAccess', 'POST', '/', 'json', false, 'json', request);
}

model CreatePublishGroupTaskRequest {
  dbId: int32(name='DbId', position='Query'),
  logic: boolean(name='Logic', position='Query'),
  orderId: long(name='OrderId', position='Query'),
  planTime?: string(name='PlanTime', position='Query'),
  publishStrategy: string(name='PublishStrategy', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', position='Query'),
}

model CreatePublishGroupTaskResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: long(name='TaskId'),
}

model CreatePublishGroupTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePublishGroupTaskResponseBody(name='body'),
}

async function createPublishGroupTask(request: CreatePublishGroupTaskRequest): CreatePublishGroupTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreatePublishGroupTask', 'POST', '/', 'json', false, 'json', request);
}

model CreateSQLReviewOrderRequest {
  comment: string(name='Comment', position='Query'),
  param: {
    attachmentKeyList: [ string ](name='AttachmentKeyList'),
    dbId: long(name='DbId'),
    projectName: string(name='ProjectName'),
  }(name='Param', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  relatedUserList?: [ long ](name='RelatedUserList', position='Query'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model CreateSQLReviewOrderResponseBody = {
  createOrderResult?: [ long ](name='CreateOrderResult'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model CreateSQLReviewOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSQLReviewOrderResponseBody(name='body'),
}

async function createSQLReviewOrder(request: CreateSQLReviewOrderRequest): CreateSQLReviewOrderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSQLReviewOrder', 'POST', '/', 'json', false, 'json', request);
}

model CreateStructSyncOrderRequest {
  attachmentKey?: string(name='AttachmentKey', position='Query'),
  comment: string(name='Comment', position='Query'),
  param: {
    ignoreError?: boolean(name='IgnoreError'),
    source: {
      dbId: long(name='DbId'),
      dbSearchName: string(name='DbSearchName'),
      logic?: boolean(name='Logic'),
      versionId?: string(name='VersionId'),
    }(name='Source'),
    tableInfoList?: [ 
      {
        sourceTableName?: string(name='SourceTableName'),
        targetTableName?: string(name='TargetTableName'),
      }
    ](name='TableInfoList'),
    target: {
      dbId: long(name='DbId'),
      dbSearchName: string(name='DbSearchName'),
      logic?: boolean(name='Logic'),
      versionId?: string(name='VersionId'),
    }(name='Target'),
  }(name='Param', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  relatedUserList?: [ long ](name='RelatedUserList', position='Query'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model CreateStructSyncOrderResponseBody = {
  createOrderResult?: [ long ](name='CreateOrderResult'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model CreateStructSyncOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CreateStructSyncOrderResponseBody(name='body'),
}

async function createStructSyncOrder(request: CreateStructSyncOrderRequest): CreateStructSyncOrderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateStructSyncOrder', 'POST', '/', 'json', false, 'json', request);
}

model CreateUploadFileJobRequest {
  fileName: string(name='FileName', position='Query'),
  fileSource: string(name='FileSource', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
  uploadURL: string(name='UploadURL', position='Query'),
}

model CreateUploadFileJobResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  jobKey?: string(name='JobKey'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model CreateUploadFileJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateUploadFileJobResponseBody(name='body'),
}

async function createUploadFileJob(request: CreateUploadFileJobRequest): CreateUploadFileJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateUploadFileJob', 'POST', '/', 'json', false, 'json', request);
}

model CreateUploadOSSFileJobRequest {
  fileName: string(name='FileName', position='Query'),
  fileSource: string(name='FileSource', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
  uploadTarget: {
    bucketName: string(name='BucketName'),
    endpoint: string(name='Endpoint'),
    objectName: string(name='ObjectName'),
  }(name='UploadTarget', position='Query'),
}

model CreateUploadOSSFileJobResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  jobKey?: string(name='JobKey'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model CreateUploadOSSFileJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateUploadOSSFileJobResponseBody(name='body'),
}

async function createUploadOSSFileJob(request: CreateUploadOSSFileJobRequest): CreateUploadOSSFileJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateUploadOSSFileJob', 'POST', '/', 'json', false, 'json', request);
}

model DeleteInstanceRequest {
  host: string(name='Host', position='Query'),
  port: int32(name='Port', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  sid?: string(name='Sid', position='Query'),
  tid?: long(name='Tid', position='Query'),
}

model DeleteInstanceResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteInstanceResponseBody(name='body'),
}

async function deleteInstance(request: DeleteInstanceRequest): DeleteInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteInstance', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLogicDatabaseRequest {
  logicDbId: long(name='LogicDbId', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model DeleteLogicDatabaseResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model DeleteLogicDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLogicDatabaseResponseBody(name='body'),
}

async function deleteLogicDatabase(request: DeleteLogicDatabaseRequest): DeleteLogicDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLogicDatabase', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLogicTableRouteConfigRequest {
  regionId?: string(name='RegionId', position='Host'),
  routeKey: string(name='RouteKey', position='Query'),
  tableId: long(name='TableId', position='Query'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model DeleteLogicTableRouteConfigResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteLogicTableRouteConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLogicTableRouteConfigResponseBody(name='body'),
}

async function deleteLogicTableRouteConfig(request: DeleteLogicTableRouteConfigRequest): DeleteLogicTableRouteConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLogicTableRouteConfig', 'POST', '/', 'json', false, 'json', request);
}

model DeleteProxyRequest {
  proxyId: long(name='ProxyId', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model DeleteProxyResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model DeleteProxyResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteProxyResponseBody(name='body'),
}

async function deleteProxy(request: DeleteProxyRequest): DeleteProxyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteProxy', 'POST', '/', 'json', false, 'json', request);
}

model DeleteProxyAccessRequest {
  proxyAccessId: long(name='ProxyAccessId', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model DeleteProxyAccessResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model DeleteProxyAccessResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteProxyAccessResponseBody(name='body'),
}

async function deleteProxyAccess(request: DeleteProxyAccessRequest): DeleteProxyAccessResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteProxyAccess', 'POST', '/', 'json', false, 'json', request);
}

model DeleteUserRequest {
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', position='Query'),
  uid: string(name='Uid', position='Query'),
}

model DeleteUserResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteUserResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserResponseBody(name='body'),
}

async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteUser', 'POST', '/', 'json', false, 'json', request);
}

model DisableUserRequest {
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', position='Query'),
  uid: string(name='Uid', position='Query'),
}

model DisableUserResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableUserResponse = {
  headers: map[string]string(name='headers'),
  body: DisableUserResponseBody(name='body'),
}

async function disableUser(request: DisableUserRequest): DisableUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableUser', 'POST', '/', 'json', false, 'json', request);
}

model EditLogicDatabaseRequest {
  alias: string(name='Alias', position='Query'),
  databaseIds: [ long ](name='DatabaseIds', position='Query'),
  logicDbId: long(name='LogicDbId', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model EditLogicDatabaseResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model EditLogicDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: EditLogicDatabaseResponseBody(name='body'),
}

async function editLogicDatabase(request: EditLogicDatabaseRequest): EditLogicDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EditLogicDatabase', 'POST', '/', 'json', false, 'json', request);
}

model EnableUserRequest {
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', position='Query'),
  uid: string(name='Uid', position='Query'),
}

model EnableUserResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableUserResponse = {
  headers: map[string]string(name='headers'),
  body: EnableUserResponseBody(name='body'),
}

async function enableUser(request: EnableUserRequest): EnableUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableUser', 'POST', '/', 'json', false, 'json', request);
}

model ExecuteDataCorrectRequest {
  actionDetail?: map[string]any(name='ActionDetail', position='Query'),
  orderId: long(name='OrderId', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: string(name='Tid', position='Query'),
}

model ExecuteDataCorrectResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ExecuteDataCorrectResponse = {
  headers: map[string]string(name='headers'),
  body: ExecuteDataCorrectResponseBody(name='body'),
}

async function executeDataCorrect(request: ExecuteDataCorrectRequest): ExecuteDataCorrectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExecuteDataCorrect', 'POST', '/', 'json', false, 'json', request);
}

model ExecuteDataExportRequest {
  actionDetail?: map[string]any(name='ActionDetail', position='Query'),
  orderId: long(name='OrderId', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', position='Query'),
}

model ExecuteDataExportResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ExecuteDataExportResponse = {
  headers: map[string]string(name='headers'),
  body: ExecuteDataExportResponseBody(name='body'),
}

async function executeDataExport(request: ExecuteDataExportRequest): ExecuteDataExportResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExecuteDataExport', 'POST', '/', 'json', false, 'json', request);
}

model ExecuteScriptRequest {
  dbId: int32(name='DbId', minimum=1, position='Query'),
  logic: boolean(name='Logic', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  script: string(name='Script', position='Query'),
  tid?: long(name='Tid', position='Query'),
}

model ExecuteScriptResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  results?: [ 
    {
      columnNames?: [ string ](name='ColumnNames'),
      message?: string(name='Message'),
      rowCount?: long(name='RowCount'),
      rows?: [  map[string]any ](name='Rows'),
      success?: boolean(name='Success'),
    }
  ](name='Results'),
  success?: boolean(name='Success'),
}

model ExecuteScriptResponse = {
  headers: map[string]string(name='headers'),
  body: ExecuteScriptResponseBody(name='body'),
}

async function executeScript(request: ExecuteScriptRequest): ExecuteScriptResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExecuteScript', 'POST', '/', 'json', false, 'json', request);
}

model ExecuteStructSyncRequest {
  orderId: long(name='OrderId', minimum=1, maximum=9223372036854775807, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model ExecuteStructSyncResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ExecuteStructSyncResponse = {
  headers: map[string]string(name='headers'),
  body: ExecuteStructSyncResponseBody(name='body'),
}

async function executeStructSync(request: ExecuteStructSyncRequest): ExecuteStructSyncResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExecuteStructSync', 'POST', '/', 'json', false, 'json', request);
}

model GetApprovalDetailRequest {
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', position='Query'),
  workflowInstanceId: long(name='WorkflowInstanceId', position='Query'),
}

model GetApprovalDetailResponseBody = {
  approvalDetail?: {
    auditId?: long(name='AuditId'),
    createTime?: string(name='CreateTime'),
    currentHandlers?: {
      currentHandler?: [ 
      {
        id?: long(name='Id'),
        nickName?: string(name='NickName'),
      }
    ](name='CurrentHandler')
    }(name='CurrentHandlers'),
    description?: string(name='Description'),
    orderId?: long(name='OrderId'),
    orderType?: string(name='OrderType'),
    reasonList?: {
      reasons?: [ string ](name='Reasons')
    }(name='ReasonList'),
    title?: string(name='Title'),
    workflowInsCode?: string(name='WorkflowInsCode'),
    workflowNodes?: {
      workflowNode?: [ 
      {
        auditUserIdList?: {
          auditUserIds?: [ string ](name='AuditUserIds')
        }(name='AuditUserIdList'),
        nodeName?: string(name='NodeName'),
        operateComment?: string(name='OperateComment'),
        operateTime?: string(name='OperateTime'),
        operatorId?: long(name='OperatorId'),
        workflowInsCode?: string(name='WorkflowInsCode'),
      }
    ](name='WorkflowNode')
    }(name='WorkflowNodes'),
  }(name='ApprovalDetail'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetApprovalDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetApprovalDetailResponseBody(name='body'),
}

async function getApprovalDetail(request: GetApprovalDetailRequest): GetApprovalDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetApprovalDetail', 'POST', '/', 'json', false, 'json', request);
}

model GetDBTaskSQLJobLogRequest {
  jobId: long(name='JobId', minimum=1, maximum=9223372036854775807, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetDBTaskSQLJobLogResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  log?: string(name='Log'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetDBTaskSQLJobLogResponse = {
  headers: map[string]string(name='headers'),
  body: GetDBTaskSQLJobLogResponseBody(name='body'),
}

async function getDBTaskSQLJobLog(request: GetDBTaskSQLJobLogRequest): GetDBTaskSQLJobLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDBTaskSQLJobLog', 'POST', '/', 'json', false, 'json', request);
}

model GetDBTopologyRequest {
  logicDbId: long(name='LogicDbId', minimum=1, maximum=9223372036854775807, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetDBTopologyResponseBody = {
  DBTopology?: {
    alias?: string(name='Alias'),
    DBTopologyInfoList?: [ 
      {
        catalogName?: string(name='CatalogName'),
        dbId?: long(name='DbId'),
        dbType?: string(name='DbType'),
        envType?: string(name='EnvType'),
        instanceId?: long(name='InstanceId'),
        instanceResourceId?: string(name='InstanceResourceId'),
        instanceSource?: string(name='InstanceSource'),
        regionId?: string(name='RegionId'),
        schemaName?: string(name='SchemaName'),
        searchName?: string(name='SearchName'),
      }
    ](name='DBTopologyInfoList'),
    dbType?: string(name='DbType'),
    envType?: string(name='EnvType'),
    logicDbId?: long(name='LogicDbId'),
    logicDbName?: string(name='LogicDbName'),
    searchName?: string(name='SearchName'),
  }(name='DBTopology'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetDBTopologyResponse = {
  headers: map[string]string(name='headers'),
  body: GetDBTopologyResponseBody(name='body'),
}

async function getDBTopology(request: GetDBTopologyRequest): GetDBTopologyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDBTopology', 'POST', '/', 'json', false, 'json', request);
}

model GetDataCorrectBackupFilesRequest {
  actionDetail?: map[string]any(name='ActionDetail', position='Query'),
  orderId: long(name='OrderId', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', position='Query'),
}

model GetDataCorrectBackupFilesResponseBody = {
  dataCorrectBackupFiles?: {
    fileUrl?: [ string ](name='FileUrl')
  }(name='DataCorrectBackupFiles'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDataCorrectBackupFilesResponse = {
  headers: map[string]string(name='headers'),
  body: GetDataCorrectBackupFilesResponseBody(name='body'),
}

async function getDataCorrectBackupFiles(request: GetDataCorrectBackupFilesRequest): GetDataCorrectBackupFilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDataCorrectBackupFiles', 'POST', '/', 'json', false, 'json', request);
}

model GetDataCorrectOrderDetailRequest {
  orderId: long(name='OrderId', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', position='Query'),
}

model GetDataCorrectOrderDetailResponseBody = {
  dataCorrectOrderDetail?: {
    databaseList?: {
      database?: [ 
      {
        dbId?: int32(name='DbId'),
        dbType?: string(name='DbType'),
        envType?: string(name='EnvType'),
        logic?: boolean(name='Logic'),
        searchName?: string(name='SearchName'),
      }
    ](name='Database')
    }(name='DatabaseList'),
    orderDetail?: {
      actualAffectRows?: long(name='ActualAffectRows'),
      attachmentName?: string(name='AttachmentName'),
      classify?: string(name='Classify'),
      estimateAffectRows?: long(name='EstimateAffectRows'),
      exeSQL?: string(name='ExeSQL'),
      ignoreAffectRows?: boolean(name='IgnoreAffectRows'),
      ignoreAffectRowsReason?: string(name='IgnoreAffectRowsReason'),
      rbAttachmentName?: string(name='RbAttachmentName'),
      rbSQL?: string(name='RbSQL'),
      rbSQLType?: string(name='RbSQLType'),
      sqlType?: string(name='SqlType'),
    }(name='OrderDetail'),
    preCheckDetail?: {
      taskCheckDO?: [ 
      {
        checkStatus?: string(name='CheckStatus'),
        checkStep?: string(name='CheckStep'),
        userTip?: string(name='UserTip'),
      }
    ](name='TaskCheckDO')
    }(name='PreCheckDetail'),
    status?: string(name='Status'),
  }(name='DataCorrectOrderDetail'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDataCorrectOrderDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetDataCorrectOrderDetailResponseBody(name='body'),
}

async function getDataCorrectOrderDetail(request: GetDataCorrectOrderDetailRequest): GetDataCorrectOrderDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDataCorrectOrderDetail', 'POST', '/', 'json', false, 'json', request);
}

model GetDataCorrectSQLFileRequest {
  orderId: long(name='OrderId', minimum=1, maximum=9223372036854775807, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetDataCorrectSQLFileResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  fileUrl?: string(name='FileUrl'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetDataCorrectSQLFileResponse = {
  headers: map[string]string(name='headers'),
  body: GetDataCorrectSQLFileResponseBody(name='body'),
}

async function getDataCorrectSQLFile(request: GetDataCorrectSQLFileRequest): GetDataCorrectSQLFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDataCorrectSQLFile', 'POST', '/', 'json', false, 'json', request);
}

model GetDataCorrectTaskDetailRequest {
  orderId: long(name='OrderId', minimum=1, maximum=9223372036854775807, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetDataCorrectTaskDetailResponseBody = {
  dataCorrectTaskDetail?: {
    actualAffectRows?: long(name='ActualAffectRows'),
    createTime?: string(name='CreateTime'),
    DBTaskGroupId?: long(name='DBTaskGroupId'),
    jobStatus?: string(name='jobStatus'),
  }(name='DataCorrectTaskDetail'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetDataCorrectTaskDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetDataCorrectTaskDetailResponseBody(name='body'),
}

async function getDataCorrectTaskDetail(request: GetDataCorrectTaskDetailRequest): GetDataCorrectTaskDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDataCorrectTaskDetail', 'POST', '/', 'json', false, 'json', request);
}

model GetDataCronClearTaskDetailListRequest {
  orderId: long(name='OrderId', minimum=1, maximum=9223372036854775807, position='Query'),
  pageNumber?: long(name='PageNumber', minimum=1, maximum=9223372036854775807, position='Query'),
  pageSize?: long(name='PageSize', minimum=1, maximum=200, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetDataCronClearTaskDetailListResponseBody = {
  dataCronClearTaskDetailList?: [ 
    {
      actualAffectRows?: long(name='ActualAffectRows'),
      createTime?: string(name='CreateTime'),
      DBTaskGroupId?: long(name='DBTaskGroupId'),
      jobStatus?: string(name='jobStatus'),
    }
  ](name='DataCronClearTaskDetailList'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model GetDataCronClearTaskDetailListResponse = {
  headers: map[string]string(name='headers'),
  body: GetDataCronClearTaskDetailListResponseBody(name='body'),
}

async function getDataCronClearTaskDetailList(request: GetDataCronClearTaskDetailListRequest): GetDataCronClearTaskDetailListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDataCronClearTaskDetailList', 'POST', '/', 'json', false, 'json', request);
}

model GetDataExportDownloadURLRequest {
  orderId: long(name='OrderId', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', position='Query'),
}

model GetDataExportDownloadURLResponseBody = {
  downloadURLResult?: {
    hasResult?: boolean(name='HasResult'),
    tipMessage?: string(name='TipMessage'),
    URL?: string(name='URL'),
  }(name='DownloadURLResult'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDataExportDownloadURLResponse = {
  headers: map[string]string(name='headers'),
  body: GetDataExportDownloadURLResponseBody(name='body'),
}

async function getDataExportDownloadURL(request: GetDataExportDownloadURLRequest): GetDataExportDownloadURLResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDataExportDownloadURL', 'POST', '/', 'json', false, 'json', request);
}

model GetDataExportOrderDetailRequest {
  orderId: long(name='OrderId', position='Body'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', position='Query'),
}

model GetDataExportOrderDetailResponseBody = {
  dataExportOrderDetail?: {
    keyInfo?: {
      jobStatus?: string(name='JobStatus'),
      preCheckId?: long(name='PreCheckId'),
    }(name='KeyInfo'),
    orderDetail?: {
      actualAffectRows?: long(name='ActualAffectRows'),
      classify?: string(name='Classify'),
      database?: string(name='Database'),
      dbId?: int32(name='DbId'),
      envType?: string(name='EnvType'),
      exeSQL?: string(name='ExeSQL'),
      ignoreAffectRows?: boolean(name='IgnoreAffectRows'),
      ignoreAffectRowsReason?: string(name='IgnoreAffectRowsReason'),
      logic?: boolean(name='Logic'),
    }(name='OrderDetail'),
  }(name='DataExportOrderDetail'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDataExportOrderDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetDataExportOrderDetailResponseBody(name='body'),
}

async function getDataExportOrderDetail(request: GetDataExportOrderDetailRequest): GetDataExportOrderDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDataExportOrderDetail', 'POST', '/', 'json', true, 'form', request);
}

model GetDatabaseRequest {
  host: string(name='Host', position='Query'),
  port: int32(name='Port', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  schemaName: string(name='SchemaName', position='Query'),
  sid?: string(name='Sid', position='Query'),
  tid?: long(name='Tid', position='Query'),
}

model GetDatabaseResponseBody = {
  database?: {
    catalogName?: string(name='CatalogName'),
    databaseId?: string(name='DatabaseId'),
    dbType?: string(name='DbType'),
    dbaId?: string(name='DbaId'),
    dbaName?: string(name='DbaName'),
    encoding?: string(name='Encoding'),
    envType?: string(name='EnvType'),
    host?: string(name='Host'),
    instanceId?: string(name='InstanceId'),
    ownerIdList?: {
      ownerIds?: [ string ](name='OwnerIds')
    }(name='OwnerIdList'),
    ownerNameList?: {
      ownerNames?: [ string ](name='OwnerNames')
    }(name='OwnerNameList'),
    port?: int32(name='Port'),
    schemaName?: string(name='SchemaName'),
    searchName?: string(name='SearchName'),
    sid?: string(name='Sid'),
    state?: string(name='State'),
  }(name='Database'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: GetDatabaseResponseBody(name='body'),
}

async function getDatabase(request: GetDatabaseRequest): GetDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDatabase', 'POST', '/', 'json', false, 'json', request);
}

model GetInstanceRequest {
  host: string(name='Host', position='Query'),
  port: int32(name='Port', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  sid?: string(name='Sid', position='Query'),
  tid?: long(name='Tid', position='Query'),
}

model GetInstanceResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  instance?: {
    dataLinkName?: string(name='DataLinkName'),
    databasePassword?: string(name='DatabasePassword'),
    databaseUser?: string(name='DatabaseUser'),
    dbaId?: string(name='DbaId'),
    dbaNickName?: string(name='DbaNickName'),
    ddlOnline?: int32(name='DdlOnline'),
    ecsInstanceId?: string(name='EcsInstanceId'),
    ecsRegion?: string(name='EcsRegion'),
    envType?: string(name='EnvType'),
    exportTimeout?: int32(name='ExportTimeout'),
    host?: string(name='Host'),
    instanceAlias?: string(name='InstanceAlias'),
    instanceId?: string(name='InstanceId'),
    instanceSource?: string(name='InstanceSource'),
    instanceType?: string(name='InstanceType'),
    ownerIdList?: {
      ownerIds?: [ string ](name='OwnerIds')
    }(name='OwnerIdList'),
    ownerNameList?: {
      ownerNames?: [ string ](name='OwnerNames')
    }(name='OwnerNameList'),
    port?: int32(name='Port'),
    queryTimeout?: int32(name='QueryTimeout'),
    safeRuleId?: string(name='SafeRuleId'),
    sid?: string(name='Sid'),
    standardGroup?: {
      groupMode?: string(name='GroupMode'),
      groupName?: string(name='GroupName'),
    }(name='StandardGroup'),
    state?: string(name='State'),
    useDsql?: int32(name='UseDsql'),
    vpcId?: string(name='VpcId'),
  }(name='Instance'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceResponseBody(name='body'),
}

async function getInstance(request: GetInstanceRequest): GetInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetInstance', 'POST', '/', 'json', false, 'json', request);
}

model GetLogicDatabaseRequest {
  dbId: string(name='DbId', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', position='Query'),
}

model GetLogicDatabaseResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  logicDatabase?: {
    alias?: string(name='Alias'),
    databaseId?: string(name='DatabaseId'),
    dbType?: string(name='DbType'),
    envType?: string(name='EnvType'),
    logic?: boolean(name='Logic'),
    ownerIdList?: {
      ownerIds?: [ string ](name='OwnerIds')
    }(name='OwnerIdList'),
    ownerNameList?: {
      ownerNames?: [ string ](name='OwnerNames')
    }(name='OwnerNameList'),
    schemaName?: string(name='SchemaName'),
    searchName?: string(name='SearchName'),
  }(name='LogicDatabase'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetLogicDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: GetLogicDatabaseResponseBody(name='body'),
}

async function getLogicDatabase(request: GetLogicDatabaseRequest): GetLogicDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetLogicDatabase', 'POST', '/', 'json', false, 'json', request);
}

model GetMetaTableColumnRequest {
  regionId?: string(name='RegionId', position='Host'),
  tableGuid: string(name='TableGuid', position='Query'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetMetaTableColumnResponseBody = {
  columnList?: [ 
    {
      autoIncrement?: boolean(name='AutoIncrement'),
      columnId?: string(name='ColumnId'),
      columnName?: string(name='ColumnName'),
      columnType?: string(name='ColumnType'),
      dataLength?: long(name='DataLength'),
      dataPrecision?: int32(name='DataPrecision'),
      dataScale?: int32(name='DataScale'),
      description?: string(name='Description'),
      nullable?: boolean(name='Nullable'),
      position?: int32(name='Position'),
      primaryKey?: string(name='PrimaryKey'),
      securityLevel?: string(name='SecurityLevel'),
    }
  ](name='ColumnList'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMetaTableColumnResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaTableColumnResponseBody(name='body'),
}

async function getMetaTableColumn(request: GetMetaTableColumnRequest): GetMetaTableColumnResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMetaTableColumn', 'POST', '/', 'json', false, 'json', request);
}

model GetMetaTableDetailInfoRequest {
  regionId?: string(name='RegionId', position='Host'),
  tableGuid: string(name='TableGuid', position='Query'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetMetaTableDetailInfoResponseBody = {
  detailInfo?: {
    columnList?: [ 
      {
        autoIncrement?: boolean(name='AutoIncrement'),
        columnId?: string(name='ColumnId'),
        columnName?: string(name='ColumnName'),
        columnType?: string(name='ColumnType'),
        dataLength?: long(name='DataLength'),
        dataPrecision?: int32(name='DataPrecision'),
        dataScale?: int32(name='DataScale'),
        description?: string(name='Description'),
        nullable?: boolean(name='Nullable'),
        position?: string(name='Position'),
      }
    ](name='ColumnList'),
    indexList?: [ 
      {
        indexColumns?: [ string ](name='IndexColumns'),
        indexId?: string(name='IndexId'),
        indexName?: string(name='IndexName'),
        indexType?: string(name='IndexType'),
        unique?: boolean(name='Unique'),
      }
    ](name='IndexList'),
  }(name='DetailInfo'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMetaTableDetailInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaTableDetailInfoResponseBody(name='body'),
}

async function getMetaTableDetailInfo(request: GetMetaTableDetailInfoRequest): GetMetaTableDetailInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMetaTableDetailInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetOpLogRequest {
  endTime: string(name='EndTime', position='Query'),
  module?: string(name='Module', position='Query'),
  pageNumber: int32(name='PageNumber', position='Query'),
  pageSize: int32(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  startTime: string(name='StartTime', position='Query'),
  tid?: long(name='Tid', position='Query'),
}

model GetOpLogResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  opLogDetails?: {
    opLogDetail?: [ 
    {
      database?: string(name='Database'),
      module?: string(name='Module'),
      opContent?: string(name='OpContent'),
      opTime?: string(name='OpTime'),
      opUserId?: long(name='OpUserId'),
      orderId?: long(name='OrderId'),
      userId?: string(name='UserId'),
      userNick?: string(name='UserNick'),
    }
  ](name='OpLogDetail')
  }(name='OpLogDetails'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model GetOpLogResponse = {
  headers: map[string]string(name='headers'),
  body: GetOpLogResponseBody(name='body'),
}

async function getOpLog(request: GetOpLogRequest): GetOpLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetOpLog', 'POST', '/', 'json', false, 'json', request);
}

model GetOrderBaseInfoRequest {
  orderId: long(name='OrderId', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', position='Query'),
}

model GetOrderBaseInfoResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  orderBaseInfo?: {
    comment?: string(name='Comment'),
    committer?: string(name='Committer'),
    committerId?: long(name='CommitterId'),
    createTime?: string(name='CreateTime'),
    lastModifyTime?: string(name='LastModifyTime'),
    orderId?: long(name='OrderId'),
    pluginType?: string(name='PluginType'),
    relatedUserList?: {
      userIds?: [ string ](name='UserIds')
    }(name='RelatedUserList'),
    relatedUserNickList?: {
      userNicks?: [ string ](name='UserNicks')
    }(name='RelatedUserNickList'),
    statusCode?: string(name='StatusCode'),
    statusDesc?: string(name='StatusDesc'),
    workflowInstanceId?: long(name='WorkflowInstanceId'),
    workflowStatusDesc?: string(name='WorkflowStatusDesc'),
  }(name='OrderBaseInfo'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetOrderBaseInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetOrderBaseInfoResponseBody(name='body'),
}

async function getOrderBaseInfo(request: GetOrderBaseInfoRequest): GetOrderBaseInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetOrderBaseInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetOwnerApplyOrderDetailRequest {
  orderId: long(name='OrderId', minimum=1, maximum=9223372036854775807, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetOwnerApplyOrderDetailResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  ownerApplyOrderDetail?: {
    applyType?: string(name='ApplyType'),
    resources?: [ 
      {
        logic?: boolean(name='Logic'),
        resourceDetail?: {
          dbType?: string(name='DbType'),
          envType?: string(name='EnvType'),
          ownerIds?: [ long ](name='OwnerIds'),
          ownerNickNames?: [ string ](name='OwnerNickNames'),
          searchName?: string(name='SearchName'),
          tableName?: string(name='TableName'),
        }(name='ResourceDetail'),
        targetId?: string(name='TargetId'),
      }
    ](name='Resources'),
  }(name='OwnerApplyOrderDetail'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetOwnerApplyOrderDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetOwnerApplyOrderDetailResponseBody(name='body'),
}

async function getOwnerApplyOrderDetail(request: GetOwnerApplyOrderDetailRequest): GetOwnerApplyOrderDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetOwnerApplyOrderDetail', 'POST', '/', 'json', false, 'json', request);
}

model GetPermApplyOrderDetailRequest {
  orderId: long(name='OrderId', minimum=1, maximum=9223372036854775807, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetPermApplyOrderDetailResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  permApplyOrderDetail?: {
    applyType?: string(name='ApplyType'),
    permType?: long(name='PermType'),
    resources?: [ 
      {
        columnInfo?: {
          columnName?: string(name='ColumnName'),
          tableName?: string(name='TableName'),
        }(name='ColumnInfo'),
        databaseInfo?: {
          dbId?: long(name='DbId'),
          dbType?: string(name='DbType'),
          envType?: string(name='EnvType'),
          logic?: boolean(name='Logic'),
          ownerIds?: [ long ](name='OwnerIds'),
          ownerNickNames?: [ string ](name='OwnerNickNames'),
          searchName?: string(name='SearchName'),
        }(name='DatabaseInfo'),
        instanceInfo?: {
          dbType?: string(name='DbType'),
          dbaId?: long(name='DbaId'),
          dbaNickName?: string(name='DbaNickName'),
          envType?: string(name='EnvType'),
          host?: string(name='Host'),
          instanceId?: string(name='InstanceId'),
          ownerIds?: [ long ](name='OwnerIds'),
          ownerNickName?: [ string ](name='OwnerNickName'),
          port?: long(name='Port'),
          searchName?: string(name='SearchName'),
        }(name='InstanceInfo'),
        tableInfo?: {
          tableName?: string(name='TableName'),
        }(name='TableInfo'),
      }
    ](name='Resources'),
    seconds?: long(name='Seconds'),
  }(name='PermApplyOrderDetail'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetPermApplyOrderDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetPermApplyOrderDetailResponseBody(name='body'),
}

async function getPermApplyOrderDetail(request: GetPermApplyOrderDetailRequest): GetPermApplyOrderDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetPermApplyOrderDetail', 'POST', '/', 'json', false, 'json', request);
}

model GetPhysicalDatabaseRequest {
  dbId: long(name='DbId', minimum=1, maximum=9223372036854775807, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetPhysicalDatabaseResponseBody = {
  database?: {
    catalogName?: string(name='CatalogName'),
    databaseId?: string(name='DatabaseId'),
    dbType?: string(name='DbType'),
    dbaId?: string(name='DbaId'),
    dbaName?: string(name='DbaName'),
    encoding?: string(name='Encoding'),
    envType?: string(name='EnvType'),
    host?: string(name='Host'),
    instanceId?: string(name='InstanceId'),
    ownerIdList?: {
      ownerIds?: [ string ](name='OwnerIds')
    }(name='OwnerIdList'),
    ownerNameList?: {
      ownerNames?: [ string ](name='OwnerNames')
    }(name='OwnerNameList'),
    port?: int32(name='Port'),
    schemaName?: string(name='SchemaName'),
    searchName?: string(name='SearchName'),
    sid?: string(name='Sid'),
    state?: string(name='State'),
  }(name='Database'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetPhysicalDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: GetPhysicalDatabaseResponseBody(name='body'),
}

async function getPhysicalDatabase(request: GetPhysicalDatabaseRequest): GetPhysicalDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetPhysicalDatabase', 'POST', '/', 'json', false, 'json', request);
}

model GetProxyRequest {
  instanceId?: long(name='InstanceId', position='Query'),
  proxyId?: long(name='ProxyId', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetProxyResponseBody = {
  creatorId?: long(name='CreatorId'),
  creatorName?: string(name='CreatorName'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpsPort?: int32(name='HttpsPort'),
  instanceId?: long(name='InstanceId'),
  mysqlPort?: int32(name='MysqlPort'),
  privateEnable?: boolean(name='PrivateEnable'),
  privateHost?: string(name='PrivateHost'),
  proxyId?: long(name='ProxyId'),
  publicEnable?: boolean(name='PublicEnable'),
  publicHost?: string(name='PublicHost'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetProxyResponse = {
  headers: map[string]string(name='headers'),
  body: GetProxyResponseBody(name='body'),
}

async function getProxy(request: GetProxyRequest): GetProxyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetProxy', 'POST', '/', 'json', false, 'json', request);
}

model GetSQLReviewCheckResultStatusRequest {
  orderId: long(name='OrderId', minimum=1, maximum=9223372036854775807, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetSQLReviewCheckResultStatusResponseBody = {
  checkResultStatus?: {
    checkStatusResult?: {
      checkNotPass?: long(name='CheckNotPass'),
      checkPass?: long(name='CheckPass'),
      forceNotPass?: long(name='ForceNotPass'),
      forcePass?: long(name='ForcePass'),
      new?: long(name='New'),
      unknown?: long(name='Unknown'),
    }(name='CheckStatusResult'),
    checkedCount?: long(name='CheckedCount'),
    SQLReviewResult?: {
      mustImprove?: long(name='MustImprove'),
      potentialIssue?: long(name='PotentialIssue'),
      suggestImprove?: long(name='SuggestImprove'),
      tableIndexSuggest?: long(name='TableIndexSuggest'),
      useDmsDmlUnlock?: long(name='UseDmsDmlUnlock'),
      useDmsToolkit?: long(name='UseDmsToolkit'),
    }(name='SQLReviewResult'),
    totalSQLCount?: long(name='TotalSQLCount'),
  }(name='CheckResultStatus'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSQLReviewCheckResultStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetSQLReviewCheckResultStatusResponseBody(name='body'),
}

async function getSQLReviewCheckResultStatus(request: GetSQLReviewCheckResultStatusRequest): GetSQLReviewCheckResultStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSQLReviewCheckResultStatus', 'POST', '/', 'json', false, 'json', request);
}

model GetSQLReviewOptimizeDetailRequest {
  regionId?: string(name='RegionId', position='Host'),
  SQLReviewQueryKey: string(name='SQLReviewQueryKey', position='Query'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetSQLReviewOptimizeDetailResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  optimizeDetail?: {
    dbId?: int32(name='DbId'),
    instanceId?: int32(name='InstanceId'),
    qualityResult?: {
      errorMessage?: string(name='ErrorMessage'),
      occurError?: boolean(name='OccurError'),
      results?: [ 
        {
          comments?: string(name='Comments'),
          feedback?: string(name='Feedback'),
          messages?: [ string ](name='Messages'),
          ruleName?: string(name='RuleName'),
          ruleType?: string(name='RuleType'),
          scripts?: [ 
            {
              content?: string(name='Content'),
              opType?: string(name='OpType'),
              tableName?: string(name='TableName'),
            }
          ](name='Scripts'),
        }
      ](name='Results'),
    }(name='QualityResult'),
    queryKey?: string(name='QueryKey'),
    sqlType?: string(name='SqlType'),
  }(name='OptimizeDetail'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSQLReviewOptimizeDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetSQLReviewOptimizeDetailResponseBody(name='body'),
}

async function getSQLReviewOptimizeDetail(request: GetSQLReviewOptimizeDetailRequest): GetSQLReviewOptimizeDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSQLReviewOptimizeDetail', 'POST', '/', 'json', false, 'json', request);
}

model GetSparkJobDetailRequest {
  jobId: long(name='JobId', minimum=0, maximum=9223372036854775807, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetSparkJobDetailResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  jobDetail?: {
    arguments?: string(name='Arguments'),
    beginTime?: string(name='BeginTime'),
    configuration?: string(name='Configuration'),
    endTime?: string(name='EndTime'),
    jobId?: string(name='JobId'),
    mainClass?: string(name='MainClass'),
    mainFile?: string(name='MainFile'),
    name?: string(name='Name'),
    status?: string(name='Status'),
    submitTime?: string(name='SubmitTime'),
  }(name='JobDetail', description='Details of the spark job'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetSparkJobDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetSparkJobDetailResponseBody(name='body'),
}

async function getSparkJobDetail(request: GetSparkJobDetailRequest): GetSparkJobDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSparkJobDetail', 'POST', '/', 'json', false, 'json', request);
}

model GetSparkJobDriverLogRequest {
  jobId: long(name='JobId', minimum=0, maximum=9223372036854775807, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetSparkJobDriverLogResponseBody = {
  driverLog?: string(name='DriverLog', description='driver log of the spark job'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetSparkJobDriverLogResponse = {
  headers: map[string]string(name='headers'),
  body: GetSparkJobDriverLogResponseBody(name='body'),
}

async function getSparkJobDriverLog(request: GetSparkJobDriverLogRequest): GetSparkJobDriverLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSparkJobDriverLog', 'POST', '/', 'json', false, 'json', request);
}

model GetSparkJobExecutorLogsRequest {
  jobId: long(name='JobId', minimum=0, maximum=9223372036854775807, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetSparkJobExecutorLogsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  executorLogs?: {
    executorLogs?: [ string ](name='executorLogs')
  }(name='ExecutorLogs', description='log of the spark job'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetSparkJobExecutorLogsResponse = {
  headers: map[string]string(name='headers'),
  body: GetSparkJobExecutorLogsResponseBody(name='body'),
}

async function getSparkJobExecutorLogs(request: GetSparkJobExecutorLogsRequest): GetSparkJobExecutorLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSparkJobExecutorLogs', 'POST', '/', 'json', false, 'json', request);
}

model GetSparkJobLogRequest {
  jobId: long(name='JobId', minimum=0, maximum=9223372036854775807, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetSparkJobLogResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  log?: string(name='Log', description='log of the spark job'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetSparkJobLogResponse = {
  headers: map[string]string(name='headers'),
  body: GetSparkJobLogResponseBody(name='body'),
}

async function getSparkJobLog(request: GetSparkJobLogRequest): GetSparkJobLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSparkJobLog', 'POST', '/', 'json', false, 'json', request);
}

model GetStructSyncExecSqlDetailRequest {
  orderId: long(name='OrderId', minimum=1, maximum=9223372036854775807, position='Query'),
  pageNumber?: long(name='PageNumber', minimum=1, maximum=9223372036854775807, position='Query'),
  pageSize?: long(name='PageSize', minimum=1, maximum=200, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetStructSyncExecSqlDetailResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  structSyncExecSqlDetail?: {
    execSql?: string(name='ExecSql'),
    totalSqlCount?: long(name='TotalSqlCount'),
  }(name='StructSyncExecSqlDetail'),
  success?: boolean(name='Success'),
}

model GetStructSyncExecSqlDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetStructSyncExecSqlDetailResponseBody(name='body'),
}

async function getStructSyncExecSqlDetail(request: GetStructSyncExecSqlDetailRequest): GetStructSyncExecSqlDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetStructSyncExecSqlDetail', 'POST', '/', 'json', false, 'json', request);
}

model GetStructSyncJobAnalyzeResultRequest {
  compareType?: string(name='CompareType', position='Query'),
  orderId: long(name='OrderId', minimum=1, maximum=9223372036854775807, position='Query'),
  pageNumber?: long(name='PageNumber', minimum=1, maximum=9223372036854775807, position='Query'),
  pageSize?: long(name='PageSize', minimum=1, maximum=200, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetStructSyncJobAnalyzeResultResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  structSyncJobAnalyzeResult?: {
    resultList?: [ 
      {
        script?: string(name='Script'),
        sourceTableName?: string(name='SourceTableName'),
        targetTableName?: string(name='TargetTableName'),
      }
    ](name='ResultList'),
    summaryList?: [ 
      {
        compareType?: string(name='CompareType'),
        count?: long(name='Count'),
      }
    ](name='SummaryList'),
  }(name='StructSyncJobAnalyzeResult'),
  success?: boolean(name='Success'),
}

model GetStructSyncJobAnalyzeResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetStructSyncJobAnalyzeResultResponseBody(name='body'),
}

async function getStructSyncJobAnalyzeResult(request: GetStructSyncJobAnalyzeResultRequest): GetStructSyncJobAnalyzeResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetStructSyncJobAnalyzeResult', 'POST', '/', 'json', false, 'json', request);
}

model GetStructSyncJobDetailRequest {
  orderId: long(name='OrderId', minimum=1, maximum=9223372036854775807, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetStructSyncJobDetailResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  structSyncJobDetail?: {
    DBTaskGroupId?: long(name='DBTaskGroupId'),
    executeCount?: long(name='ExecuteCount'),
    jobStatus?: string(name='JobStatus'),
    message?: string(name='Message'),
    securityRule?: string(name='SecurityRule'),
    sqlCount?: long(name='SqlCount'),
    tableAnalyzed?: long(name='TableAnalyzed'),
    tableCount?: long(name='TableCount'),
  }(name='StructSyncJobDetail'),
  success?: boolean(name='Success'),
}

model GetStructSyncJobDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetStructSyncJobDetailResponseBody(name='body'),
}

async function getStructSyncJobDetail(request: GetStructSyncJobDetailRequest): GetStructSyncJobDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetStructSyncJobDetail', 'POST', '/', 'json', false, 'json', request);
}

model GetStructSyncOrderDetailRequest {
  orderId?: long(name='OrderId', minimum=1, maximum=9223372036854775807, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetStructSyncOrderDetailResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  structSyncOrderDetail?: {
    ignoreError?: boolean(name='IgnoreError'),
    sourceDatabaseInfo?: {
      dbId?: long(name='DbId'),
      dbType?: string(name='DbType'),
      envType?: string(name='EnvType'),
      logic?: boolean(name='Logic'),
      searchName?: string(name='SearchName'),
    }(name='SourceDatabaseInfo'),
    sourceType?: string(name='SourceType'),
    sourceVersionInfo?: {
      versionId?: string(name='VersionId'),
    }(name='SourceVersionInfo'),
    tableInfoList?: [ 
      {
        sourceTableName?: string(name='SourceTableName'),
        targetTableName?: string(name='TargetTableName'),
      }
    ](name='TableInfoList'),
    targetDatabaseInfo?: {
      dbId?: long(name='DbId'),
      dbType?: string(name='DbType'),
      envType?: string(name='EnvType'),
      logic?: boolean(name='Logic'),
      searchName?: string(name='SearchName'),
    }(name='TargetDatabaseInfo'),
    targetType?: string(name='TargetType'),
    targetVersionInfo?: {
      versionId?: string(name='VersionId'),
    }(name='TargetVersionInfo'),
  }(name='StructSyncOrderDetail'),
  success?: boolean(name='Success'),
}

model GetStructSyncOrderDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetStructSyncOrderDetailResponseBody(name='body'),
}

async function getStructSyncOrderDetail(request: GetStructSyncOrderDetailRequest): GetStructSyncOrderDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetStructSyncOrderDetail', 'POST', '/', 'json', false, 'json', request);
}

model GetTableDBTopologyRequest {
  regionId?: string(name='RegionId', position='Host'),
  tableGuid: string(name='TableGuid', position='Query'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetTableDBTopologyResponseBody = {
  DBTopology?: {
    dataSourceList?: [ 
      {
        databaseList?: [ 
          {
            dbId?: string(name='DbId'),
            dbName?: string(name='DbName'),
            dbType?: string(name='DbType'),
            envType?: string(name='EnvType'),
            tableList?: [ 
              {
                tableId?: string(name='TableId'),
                tableName?: string(name='TableName'),
                tableType?: string(name='TableType'),
              }
            ](name='TableList'),
          }
        ](name='DatabaseList'),
        dbType?: string(name='DbType'),
        host?: string(name='Host'),
        port?: int32(name='Port'),
        sid?: string(name='Sid'),
      }
    ](name='DataSourceList'),
    tableGuid?: string(name='TableGuid'),
    tableName?: string(name='TableName'),
  }(name='DBTopology'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetTableDBTopologyResponse = {
  headers: map[string]string(name='headers'),
  body: GetTableDBTopologyResponseBody(name='body'),
}

async function getTableDBTopology(request: GetTableDBTopologyRequest): GetTableDBTopologyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTableDBTopology', 'POST', '/', 'json', false, 'json', request);
}

model GetTableTopologyRequest {
  regionId?: string(name='RegionId', position='Host'),
  tableGuid: string(name='TableGuid', position='Query'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetTableTopologyResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
  tableTopology?: {
    logic?: boolean(name='Logic'),
    tableGuid?: string(name='TableGuid'),
    tableName?: string(name='TableName'),
    tableTopologyInfoList?: [ 
      {
        dbId?: long(name='DbId'),
        dbName?: string(name='DbName'),
        dbSearchName?: string(name='DbSearchName'),
        dbType?: string(name='DbType'),
        instanceId?: long(name='InstanceId'),
        instanceResourceId?: string(name='InstanceResourceId'),
        instanceSource?: string(name='InstanceSource'),
        regionId?: string(name='RegionId'),
        tableCount?: long(name='TableCount'),
        tableNameExpr?: string(name='TableNameExpr'),
        tableNameList?: string(name='TableNameList'),
      }
    ](name='TableTopologyInfoList'),
  }(name='TableTopology'),
}

model GetTableTopologyResponse = {
  headers: map[string]string(name='headers'),
  body: GetTableTopologyResponseBody(name='body'),
}

async function getTableTopology(request: GetTableTopologyRequest): GetTableTopologyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTableTopology', 'POST', '/', 'json', false, 'json', request);
}

model GetUserRequest {
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', position='Query'),
  uid?: string(name='Uid', position='Query'),
  userId?: string(name='UserId', position='Query'),
}

model GetUserResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  user?: {
    curExecuteCount?: long(name='CurExecuteCount'),
    curResultCount?: long(name='CurResultCount'),
    dingRobot?: string(name='DingRobot'),
    email?: string(name='Email'),
    lastLoginTime?: string(name='LastLoginTime'),
    maxExecuteCount?: long(name='MaxExecuteCount'),
    maxResultCount?: long(name='MaxResultCount'),
    mobile?: string(name='Mobile'),
    nickName?: string(name='NickName'),
    notificationMode?: string(name='NotificationMode'),
    parentUid?: long(name='ParentUid'),
    roleIdList?: {
      roleIds?: [ int32 ](name='RoleIds')
    }(name='RoleIdList'),
    roleNameList?: {
      roleNames?: [ string ](name='RoleNames')
    }(name='RoleNameList'),
    signatureMethod?: string(name='SignatureMethod'),
    state?: string(name='State'),
    uid?: string(name='Uid'),
    userId?: string(name='UserId'),
    webhook?: string(name='Webhook'),
  }(name='User'),
}

model GetUserResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserResponseBody(name='body'),
}

async function getUser(request: GetUserRequest): GetUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUser', 'POST', '/', 'json', false, 'json', request);
}

model GetUserActiveTenantRequest {
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetUserActiveTenantResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tenant?: {
    status?: string(name='Status'),
    tenantName?: string(name='TenantName'),
    tid?: long(name='Tid'),
  }(name='Tenant'),
}

model GetUserActiveTenantResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserActiveTenantResponseBody(name='body'),
}

async function getUserActiveTenant(request: GetUserActiveTenantRequest): GetUserActiveTenantResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUserActiveTenant', 'POST', '/', 'json', false, 'json', request);
}

model GetUserUploadFileJobRequest {
  jobKey: string(name='JobKey', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model GetUserUploadFileJobResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
  uploadFileJobDetail?: {
    attachmentKey?: string(name='AttachmentKey'),
    fileName?: string(name='FileName'),
    fileSize?: long(name='FileSize'),
    fileSource?: string(name='FileSource'),
    jobKey?: string(name='JobKey'),
    jobStatus?: string(name='JobStatus'),
    jobStatusDesc?: string(name='JobStatusDesc'),
    uploadOSSParam?: {
      bucketName?: string(name='BucketName'),
      endpoint?: string(name='Endpoint'),
      objectName?: string(name='ObjectName'),
    }(name='UploadOSSParam'),
    uploadType?: string(name='UploadType'),
    uploadURL?: string(name='UploadURL'),
    uploadedSize?: long(name='UploadedSize'),
  }(name='UploadFileJobDetail'),
}

model GetUserUploadFileJobResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserUploadFileJobResponseBody(name='body'),
}

async function getUserUploadFileJob(request: GetUserUploadFileJobRequest): GetUserUploadFileJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUserUploadFileJob', 'POST', '/', 'json', false, 'json', request);
}

model GrantUserPermissionRequest {
  dbId?: string(name='DbId', position='Query'),
  dsType: string(name='DsType', position='Query'),
  expireDate: string(name='ExpireDate', position='Query'),
  instanceId?: long(name='InstanceId', position='Query'),
  logic?: boolean(name='Logic', position='Query'),
  permTypes: string(name='PermTypes', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tableId?: string(name='TableId', position='Query'),
  tableName?: string(name='TableName', position='Query'),
  tid?: long(name='Tid', position='Query'),
  userId: string(name='UserId', position='Query'),
}

model GrantUserPermissionResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GrantUserPermissionResponse = {
  headers: map[string]string(name='headers'),
  body: GrantUserPermissionResponseBody(name='body'),
}

async function grantUserPermission(request: GrantUserPermissionRequest): GrantUserPermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GrantUserPermission', 'POST', '/', 'json', false, 'json', request);
}

model InspectProxyAccessSecretRequest {
  proxyAccessId: long(name='ProxyAccessId', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model InspectProxyAccessSecretResponseBody = {
  accessSecret?: string(name='AccessSecret'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model InspectProxyAccessSecretResponse = {
  headers: map[string]string(name='headers'),
  body: InspectProxyAccessSecretResponseBody(name='body'),
}

async function inspectProxyAccessSecret(request: InspectProxyAccessSecretRequest): InspectProxyAccessSecretResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'InspectProxyAccessSecret', 'POST', '/', 'json', false, 'json', request);
}

model KillSparkJobRequest {
  jobId: long(name='JobId', minimum=0, maximum=9223372036854775807, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model KillSparkJobResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success', description='Killing status'),
}

model KillSparkJobResponse = {
  headers: map[string]string(name='headers'),
  body: KillSparkJobResponseBody(name='body'),
}

async function killSparkJob(request: KillSparkJobRequest): KillSparkJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'KillSparkJob', 'POST', '/', 'json', false, 'json', request);
}

model ListColumnsRequest {
  logic?: boolean(name='Logic', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tableId: string(name='TableId', position='Query'),
  tid?: long(name='Tid', position='Query'),
}

model ListColumnsResponseBody = {
  columnList?: {
    column?: [ 
    {
      autoIncrement?: boolean(name='AutoIncrement'),
      columnId?: string(name='ColumnId'),
      columnName?: string(name='ColumnName'),
      columnType?: string(name='ColumnType'),
      dataLength?: long(name='DataLength'),
      dataPrecision?: int32(name='DataPrecision'),
      dataScale?: int32(name='DataScale'),
      defaultValue?: string(name='DefaultValue'),
      description?: string(name='Description'),
      functionType?: string(name='FunctionType'),
      nullable?: boolean(name='Nullable'),
      securityLevel?: string(name='SecurityLevel'),
      sensitive?: boolean(name='Sensitive'),
    }
  ](name='Column')
  }(name='ColumnList'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListColumnsResponse = {
  headers: map[string]string(name='headers'),
  body: ListColumnsResponseBody(name='body'),
}

async function listColumns(request: ListColumnsRequest): ListColumnsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListColumns', 'POST', '/', 'json', false, 'json', request);
}

model ListDBTaskSQLJobRequest {
  DBTaskGroupId: long(name='DBTaskGroupId', minimum=1, maximum=9223372036854775807, position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model ListDBTaskSQLJobResponseBody = {
  DBTaskSQLJobList?: [ 
    {
      comment?: string(name='Comment'),
      createTime?: string(name='CreateTime'),
      dbId?: long(name='DbId'),
      dbSearchName?: string(name='DbSearchName'),
      dbTaskGroupId?: long(name='DbTaskGroupId'),
      jobId?: long(name='JobId'),
      jobType?: string(name='JobType'),
      lastExecTime?: string(name='LastExecTime'),
      logic?: boolean(name='Logic'),
      status?: string(name='Status'),
      transactional?: boolean(name='Transactional'),
    }
  ](name='DBTaskSQLJobList'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListDBTaskSQLJobResponse = {
  headers: map[string]string(name='headers'),
  body: ListDBTaskSQLJobResponseBody(name='body'),
}

async function listDBTaskSQLJob(request: ListDBTaskSQLJobRequest): ListDBTaskSQLJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDBTaskSQLJob', 'POST', '/', 'json', false, 'json', request);
}

model ListDBTaskSQLJobDetailRequest {
  jobId: long(name='JobId', minimum=1, maximum=9223372036854775807, position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model ListDBTaskSQLJobDetailResponseBody = {
  DBTaskSQLJobDetailList?: [ 
    {
      affectRows?: long(name='AffectRows'),
      currentSql?: string(name='CurrentSql'),
      dbId?: long(name='DbId'),
      endTime?: string(name='EndTime'),
      executeCount?: long(name='ExecuteCount'),
      jobDetailId?: long(name='JobDetailId'),
      jobId?: long(name='JobId'),
      log?: string(name='Log'),
      logic?: boolean(name='Logic'),
      skip?: boolean(name='Skip'),
      sqlType?: string(name='SqlType'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
      timeDelay?: long(name='TimeDelay'),
    }
  ](name='DBTaskSQLJobDetailList'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListDBTaskSQLJobDetailResponse = {
  headers: map[string]string(name='headers'),
  body: ListDBTaskSQLJobDetailResponseBody(name='body'),
}

async function listDBTaskSQLJobDetail(request: ListDBTaskSQLJobDetailRequest): ListDBTaskSQLJobDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDBTaskSQLJobDetail', 'POST', '/', 'json', false, 'json', request);
}

model ListDDLPublishRecordsRequest {
  orderId: long(name='OrderId', minimum=1, maximum=9223372036854775807, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model ListDDLPublishRecordsResponseBody = {
  DDLPublishRecordList?: [ 
    {
      auditExpireTime?: string(name='AuditExpireTime'),
      auditStatus?: string(name='AuditStatus'),
      creatorId?: long(name='CreatorId'),
      finality?: boolean(name='Finality'),
      finalityReason?: string(name='FinalityReason'),
      publishStatus?: string(name='PublishStatus'),
      publishTaskInfoList?: [ 
        {
          dbId?: long(name='DbId'),
          logic?: boolean(name='Logic'),
          planTime?: string(name='PlanTime'),
          publishJobList?: [ 
            {
              DBTaskGroupId?: long(name='DBTaskGroupId'),
              executeCount?: long(name='ExecuteCount'),
              scripts?: string(name='Scripts'),
              statusDesc?: string(name='StatusDesc'),
              tableName?: string(name='TableName'),
              taskJobStatus?: string(name='TaskJobStatus'),
            }
          ](name='PublishJobList'),
          publishStrategy?: string(name='PublishStrategy'),
          statusDesc?: string(name='StatusDesc'),
          taskJobStatus?: string(name='TaskJobStatus'),
        }
      ](name='PublishTaskInfoList'),
      riskLevel?: string(name='RiskLevel'),
      statusDesc?: string(name='StatusDesc'),
      workflowInstanceId?: long(name='WorkflowInstanceId'),
    }
  ](name='DDLPublishRecordList'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListDDLPublishRecordsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDDLPublishRecordsResponseBody(name='body'),
}

async function listDDLPublishRecords(request: ListDDLPublishRecordsRequest): ListDDLPublishRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDDLPublishRecords', 'POST', '/', 'json', false, 'json', request);
}

model ListDataCorrectPreCheckDBRequest {
  orderId: long(name='OrderId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model ListDataCorrectPreCheckDBResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  preCheckDBList?: [ 
    {
      dbId?: long(name='DbId'),
      searchName?: string(name='SearchName'),
      sqlNum?: long(name='SqlNum'),
    }
  ](name='PreCheckDBList'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListDataCorrectPreCheckDBResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataCorrectPreCheckDBResponseBody(name='body'),
}

async function listDataCorrectPreCheckDB(request: ListDataCorrectPreCheckDBRequest): ListDataCorrectPreCheckDBResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDataCorrectPreCheckDB', 'POST', '/', 'json', false, 'json', request);
}

model ListDataCorrectPreCheckSQLRequest {
  dbId?: long(name='DbId', position='Query'),
  orderId: long(name='OrderId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model ListDataCorrectPreCheckSQLResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  preCheckSQLList?: [ 
    {
      affectRows?: long(name='AffectRows'),
      checkSQL?: string(name='CheckSQL'),
      dbId?: long(name='DbId'),
      SQLReviewQueryKey?: string(name='SQLReviewQueryKey'),
      sqlReviewStatus?: string(name='SqlReviewStatus'),
      sqlType?: string(name='SqlType'),
      tableNames?: string(name='TableNames'),
    }
  ](name='PreCheckSQLList'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListDataCorrectPreCheckSQLResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataCorrectPreCheckSQLResponseBody(name='body'),
}

async function listDataCorrectPreCheckSQL(request: ListDataCorrectPreCheckSQLRequest): ListDataCorrectPreCheckSQLResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDataCorrectPreCheckSQL', 'POST', '/', 'json', false, 'json', request);
}

model ListDatabaseUserPermssionsRequest {
  dbId: string(name='DbId', position='Query'),
  logic?: boolean(name='Logic', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  permType: string(name='PermType', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', position='Query'),
  userName?: string(name='UserName', position='Query'),
}

model ListDatabaseUserPermssionsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
  userPermissions?: {
    userPermission?: [ 
    {
      alias?: string(name='Alias'),
      columnName?: string(name='ColumnName'),
      dbId?: string(name='DbId'),
      dbType?: string(name='DbType'),
      dsType?: string(name='DsType'),
      envType?: string(name='EnvType'),
      instanceId?: string(name='InstanceId'),
      logic?: boolean(name='Logic'),
      permDetails?: {
        permDetail?: [ 
        {
          createDate?: string(name='CreateDate'),
          expireDate?: string(name='ExpireDate'),
          extraData?: string(name='ExtraData'),
          originFrom?: string(name='OriginFrom'),
          permType?: string(name='PermType'),
          userAccessId?: string(name='UserAccessId'),
        }
      ](name='PermDetail')
      }(name='PermDetails'),
      schemaName?: string(name='SchemaName'),
      searchName?: string(name='SearchName'),
      tableId?: string(name='TableId'),
      tableName?: string(name='TableName'),
      userId?: string(name='UserId'),
      userNickName?: string(name='UserNickName'),
    }
  ](name='UserPermission')
  }(name='UserPermissions'),
}

model ListDatabaseUserPermssionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDatabaseUserPermssionsResponseBody(name='body'),
}

async function listDatabaseUserPermssions(request: ListDatabaseUserPermssionsRequest): ListDatabaseUserPermssionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDatabaseUserPermssions', 'POST', '/', 'json', false, 'json', request);
}

model ListDatabasesRequest {
  instanceId: string(name='InstanceId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', position='Query'),
}

model ListDatabasesResponseBody = {
  databaseList?: {
    database?: [ 
    {
      catalogName?: string(name='CatalogName'),
      databaseId?: string(name='DatabaseId'),
      dbType?: string(name='DbType'),
      dbaId?: string(name='DbaId'),
      dbaName?: string(name='DbaName'),
      encoding?: string(name='Encoding'),
      envType?: string(name='EnvType'),
      host?: string(name='Host'),
      instanceId?: string(name='InstanceId'),
      ownerIdList?: {
        ownerIds?: [ string ](name='OwnerIds')
      }(name='OwnerIdList'),
      ownerNameList?: {
        ownerNames?: [ string ](name='OwnerNames')
      }(name='OwnerNameList'),
      port?: int32(name='Port'),
      schemaName?: string(name='SchemaName'),
      searchName?: string(name='SearchName'),
      sid?: string(name='Sid'),
      state?: string(name='State'),
    }
  ](name='Database')
  }(name='DatabaseList'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListDatabasesResponse = {
  headers: map[string]string(name='headers'),
  body: ListDatabasesResponseBody(name='body'),
}

async function listDatabases(request: ListDatabasesRequest): ListDatabasesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDatabases', 'POST', '/', 'json', false, 'json', request);
}

model ListIndexesRequest {
  logic?: boolean(name='Logic', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tableId: string(name='TableId', position='Query'),
  tid?: long(name='Tid', position='Query'),
}

model ListIndexesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  indexList?: {
    index?: [ 
    {
      indexComment?: string(name='IndexComment'),
      indexId?: string(name='IndexId'),
      indexName?: string(name='IndexName'),
      indexType?: string(name='IndexType'),
      tableId?: string(name='TableId'),
    }
  ](name='Index')
  }(name='IndexList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListIndexesResponse = {
  headers: map[string]string(name='headers'),
  body: ListIndexesResponseBody(name='body'),
}

async function listIndexes(request: ListIndexesRequest): ListIndexesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListIndexes', 'POST', '/', 'json', false, 'json', request);
}

model ListInstanceLoginAuditLogRequest {
  endTime: string(name='EndTime', position='Query'),
  opUserName?: string(name='OpUserName', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  searchName?: string(name='SearchName', position='Query'),
  startTime: string(name='StartTime', position='Query'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model ListInstanceLoginAuditLogResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  instanceLoginAuditLogList?: {
    instanceLoginAuditLog?: [ 
    {
      dbUser?: string(name='DbUser'),
      instanceId?: long(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      opTime?: string(name='OpTime'),
      requestIp?: string(name='RequestIp'),
      userId?: long(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='InstanceLoginAuditLog')
  }(name='InstanceLoginAuditLogList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListInstanceLoginAuditLogResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstanceLoginAuditLogResponseBody(name='body'),
}

async function listInstanceLoginAuditLog(request: ListInstanceLoginAuditLogRequest): ListInstanceLoginAuditLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListInstanceLoginAuditLog', 'POST', '/', 'json', false, 'json', request);
}

model ListInstanceUserPermissionsRequest {
  instanceId: string(name='InstanceId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', position='Query'),
  userName?: string(name='UserName', position='Query'),
}

model ListInstanceUserPermissionsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
  userPermissions?: {
    userPermission?: [ 
    {
      instanceId?: string(name='InstanceId'),
      permDetails?: {
        permDetail?: [ 
        {
          createDate?: string(name='CreateDate'),
          expireDate?: string(name='ExpireDate'),
          extraData?: string(name='ExtraData'),
          originFrom?: string(name='OriginFrom'),
          permType?: string(name='PermType'),
          userAccessId?: string(name='UserAccessId'),
        }
      ](name='PermDetail')
      }(name='PermDetails'),
      userId?: string(name='UserId'),
      userNickName?: string(name='UserNickName'),
    }
  ](name='UserPermission')
  }(name='UserPermissions'),
}

model ListInstanceUserPermissionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstanceUserPermissionsResponseBody(name='body'),
}

async function listInstanceUserPermissions(request: ListInstanceUserPermissionsRequest): ListInstanceUserPermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListInstanceUserPermissions', 'POST', '/', 'json', false, 'json', request);
}

model ListInstancesRequest {
  dbType?: string(name='DbType', position='Query'),
  envType?: string(name='EnvType', position='Query'),
  instanceSource?: string(name='InstanceSource', position='Query'),
  instanceState?: string(name='InstanceState', position='Query'),
  netType?: string(name='NetType', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  searchKey?: string(name='SearchKey', position='Query'),
  tid?: long(name='Tid', position='Query'),
}

model ListInstancesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  instanceList?: {
    instance?: [ 
    {
      dataLinkName?: string(name='DataLinkName'),
      databasePassword?: string(name='DatabasePassword'),
      databaseUser?: string(name='DatabaseUser'),
      dbaId?: string(name='DbaId'),
      dbaNickName?: string(name='DbaNickName'),
      ddlOnline?: int32(name='DdlOnline'),
      ecsInstanceId?: string(name='EcsInstanceId'),
      ecsRegion?: string(name='EcsRegion'),
      envType?: string(name='EnvType'),
      exportTimeout?: int32(name='ExportTimeout'),
      host?: string(name='Host'),
      instanceAlias?: string(name='InstanceAlias'),
      instanceId?: string(name='InstanceId'),
      instanceSource?: string(name='InstanceSource'),
      instanceType?: string(name='InstanceType'),
      ownerIdList?: {
        ownerIds?: [ string ](name='OwnerIds')
      }(name='OwnerIdList'),
      ownerNameList?: {
        ownerNames?: [ string ](name='OwnerNames')
      }(name='OwnerNameList'),
      port?: int32(name='Port'),
      queryTimeout?: int32(name='QueryTimeout'),
      safeRuleId?: string(name='SafeRuleId'),
      sid?: string(name='Sid'),
      standardGroup?: {
        groupMode?: string(name='GroupMode'),
        groupName?: string(name='GroupName'),
      }(name='StandardGroup'),
      state?: string(name='State'),
      useDsql?: int32(name='UseDsql'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Instance')
  }(name='InstanceList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstancesResponseBody(name='body'),
}

async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListInstances', 'POST', '/', 'json', false, 'json', request);
}

model ListLogicDatabasesRequest {
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', position='Query'),
}

model ListLogicDatabasesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  logicDatabaseList?: {
    logicDatabase?: [ 
    {
      alias?: string(name='Alias'),
      databaseId?: string(name='DatabaseId'),
      dbType?: string(name='DbType'),
      envType?: string(name='EnvType'),
      logic?: boolean(name='Logic'),
      ownerIdList?: {
        ownerIds?: [ string ](name='OwnerIds')
      }(name='OwnerIdList'),
      ownerNameList?: {
        ownerNames?: [ string ](name='OwnerNames')
      }(name='OwnerNameList'),
      schemaName?: string(name='SchemaName'),
      searchName?: string(name='SearchName'),
    }
  ](name='LogicDatabase')
  }(name='LogicDatabaseList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListLogicDatabasesResponse = {
  headers: map[string]string(name='headers'),
  body: ListLogicDatabasesResponseBody(name='body'),
}

async function listLogicDatabases(request: ListLogicDatabasesRequest): ListLogicDatabasesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListLogicDatabases', 'POST', '/', 'json', false, 'json', request);
}

model ListLogicTableRouteConfigRequest {
  regionId?: string(name='RegionId', position='Host'),
  tableId: long(name='TableId', position='Query'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model ListLogicTableRouteConfigResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  logicTableRouteConfigList?: {
    logicTableRouteConfig?: [ 
    {
      routeExpr?: string(name='RouteExpr'),
      routeKey?: string(name='RouteKey'),
      tableId?: long(name='TableId'),
    }
  ](name='LogicTableRouteConfig')
  }(name='LogicTableRouteConfigList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListLogicTableRouteConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ListLogicTableRouteConfigResponseBody(name='body'),
}

async function listLogicTableRouteConfig(request: ListLogicTableRouteConfigRequest): ListLogicTableRouteConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListLogicTableRouteConfig', 'POST', '/', 'json', false, 'json', request);
}

model ListLogicTablesRequest {
  databaseId: string(name='DatabaseId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  returnGuid?: boolean(name='ReturnGuid', position='Query'),
  searchName?: string(name='SearchName', position='Query'),
  tid?: long(name='Tid', position='Query'),
}

model ListLogicTablesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  logicTableList?: {
    logicTable?: [ 
    {
      databaseId?: string(name='DatabaseId'),
      logic?: boolean(name='Logic'),
      ownerIdList?: {
        ownerIds?: [ string ](name='OwnerIds')
      }(name='OwnerIdList'),
      ownerNameList?: {
        ownerNames?: [ string ](name='OwnerNames')
      }(name='OwnerNameList'),
      schemaName?: string(name='SchemaName'),
      tableCount?: string(name='TableCount'),
      tableExpr?: string(name='TableExpr'),
      tableGuid?: string(name='TableGuid'),
      tableId?: string(name='TableId'),
      tableName?: string(name='TableName'),
    }
  ](name='LogicTable')
  }(name='LogicTableList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListLogicTablesResponse = {
  headers: map[string]string(name='headers'),
  body: ListLogicTablesResponseBody(name='body'),
}

async function listLogicTables(request: ListLogicTablesRequest): ListLogicTablesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListLogicTables', 'POST', '/', 'json', false, 'json', request);
}

model ListOrdersRequest {
  endTime?: string(name='EndTime', position='Query'),
  orderResultType?: string(name='OrderResultType', position='Query'),
  orderStatus?: string(name='OrderStatus', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  pluginType?: string(name='PluginType', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  searchContent?: string(name='SearchContent', position='Query'),
  searchDateType?: string(name='SearchDateType', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  tid?: long(name='Tid', position='Query'),
}

model ListOrdersResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  orders?: {
    order?: [ 
    {
      comment?: string(name='Comment'),
      committer?: string(name='Committer'),
      committerId?: long(name='CommitterId'),
      createTime?: string(name='CreateTime'),
      lastModifyTime?: string(name='LastModifyTime'),
      orderId?: long(name='OrderId'),
      pluginType?: string(name='PluginType'),
      statusCode?: string(name='StatusCode'),
      statusDesc?: string(name='StatusDesc'),
    }
  ](name='Order')
  }(name='Orders'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListOrdersResponse = {
  headers: map[string]string(name='headers'),
  body: ListOrdersResponseBody(name='body'),
}

async function listOrders(request: ListOrdersRequest): ListOrdersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListOrders', 'POST', '/', 'json', false, 'json', request);
}

model ListProxiesRequest {
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model ListProxiesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  proxyList?: [ 
    {
      creatorId?: long(name='CreatorId'),
      creatorName?: string(name='CreatorName'),
      httpsPort?: int32(name='HttpsPort'),
      instanceId?: long(name='InstanceId'),
      mysqlPort?: int32(name='MysqlPort'),
      privateEnable?: boolean(name='PrivateEnable'),
      privateHost?: string(name='PrivateHost'),
      proxyId?: long(name='ProxyId'),
      publicEnable?: boolean(name='PublicEnable'),
      publicHost?: string(name='PublicHost'),
    }
  ](name='ProxyList'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListProxiesResponse = {
  headers: map[string]string(name='headers'),
  body: ListProxiesResponseBody(name='body'),
}

async function listProxies(request: ListProxiesRequest): ListProxiesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListProxies', 'POST', '/', 'json', false, 'json', request);
}

model ListProxyAccessesRequest {
  proxyId: long(name='ProxyId', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model ListProxyAccessesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  proxyAccessList?: [ 
    {
      accessId?: string(name='AccessId'),
      gmtCreate?: string(name='GmtCreate'),
      indepAccount?: string(name='IndepAccount'),
      instanceId?: long(name='InstanceId'),
      originInfo?: string(name='OriginInfo'),
      proxyAccessId?: long(name='ProxyAccessId'),
      proxyId?: long(name='ProxyId'),
      userId?: long(name='UserId'),
      userName?: string(name='UserName'),
      userUid?: string(name='UserUid'),
    }
  ](name='ProxyAccessList'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListProxyAccessesResponse = {
  headers: map[string]string(name='headers'),
  body: ListProxyAccessesResponseBody(name='body'),
}

async function listProxyAccesses(request: ListProxyAccessesRequest): ListProxyAccessesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListProxyAccesses', 'POST', '/', 'json', false, 'json', request);
}

model ListProxySQLExecAuditLogRequest {
  endTime: long(name='EndTime', position='Query'),
  execState?: string(name='ExecState', position='Query'),
  opUserName?: string(name='OpUserName', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  SQLType?: string(name='SQLType', position='Query'),
  searchName?: string(name='SearchName', position='Query'),
  startTime: long(name='StartTime', position='Query'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model ListProxySQLExecAuditLogResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  proxySQLExecAuditLogList?: {
    proxySQLExecAuditLog?: [ 
    {
      affectRows?: long(name='AffectRows'),
      elapsedTime?: long(name='ElapsedTime'),
      execState?: string(name='ExecState'),
      instanceId?: long(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      opTime?: string(name='OpTime'),
      remark?: string(name='Remark'),
      SQL?: string(name='SQL'),
      SQLType?: string(name='SQLType'),
      schemaName?: string(name='SchemaName'),
      userId?: long(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='ProxySQLExecAuditLog')
  }(name='ProxySQLExecAuditLogList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListProxySQLExecAuditLogResponse = {
  headers: map[string]string(name='headers'),
  body: ListProxySQLExecAuditLogResponseBody(name='body'),
}

async function listProxySQLExecAuditLog(request: ListProxySQLExecAuditLogRequest): ListProxySQLExecAuditLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListProxySQLExecAuditLog', 'POST', '/', 'json', false, 'json', request);
}

model ListSQLExecAuditLogRequest {
  endTime: string(name='EndTime', position='Query'),
  execState?: string(name='ExecState', position='Query'),
  opUserName?: string(name='OpUserName', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  searchName?: string(name='SearchName', position='Query'),
  sqlType?: string(name='SqlType', position='Query'),
  startTime: string(name='StartTime', position='Query'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model ListSQLExecAuditLogResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  SQLExecAuditLogList?: {
    SQLExecAuditLog?: [ 
    {
      affectRows?: long(name='AffectRows'),
      dbId?: long(name='DbId'),
      elapsedTime?: long(name='ElapsedTime'),
      execState?: string(name='ExecState'),
      instanceId?: long(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      logic?: boolean(name='Logic'),
      opTime?: string(name='OpTime'),
      remark?: string(name='Remark'),
      SQL?: string(name='SQL'),
      SQLType?: string(name='SQLType'),
      schemaName?: string(name='SchemaName'),
      userId?: long(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='SQLExecAuditLog')
  }(name='SQLExecAuditLogList'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListSQLExecAuditLogResponse = {
  headers: map[string]string(name='headers'),
  body: ListSQLExecAuditLogResponseBody(name='body'),
}

async function listSQLExecAuditLog(request: ListSQLExecAuditLogRequest): ListSQLExecAuditLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSQLExecAuditLog', 'POST', '/', 'json', false, 'json', request);
}

model ListSQLReviewOriginSQLRequest {
  orderActionDetail?: {
    checkStatusResult?: string(name='CheckStatusResult'),
    fileId?: long(name='FileId'),
    page?: {
      pageNumber?: int32(name='PageNumber'),
      pageSize?: int32(name='PageSize', maximum=500),
    }(name='Page'),
    SQLReviewResult?: string(name='SQLReviewResult'),
  }(name='OrderActionDetail', position='Query'),
  orderId: long(name='OrderId', minimum=1, maximum=9223372036854775807, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model ListSQLReviewOriginSQLResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  originSQLList?: [ 
    {
      checkStatus?: string(name='CheckStatus'),
      checkedTime?: string(name='CheckedTime'),
      fileId?: long(name='FileId'),
      fileName?: string(name='FileName'),
      reviewSummary?: string(name='ReviewSummary'),
      SQLContent?: string(name='SQLContent'),
      SQLId?: long(name='SQLId'),
      SQLReviewQueryKey?: string(name='SQLReviewQueryKey'),
      sqlHash?: string(name='SqlHash'),
      statusDesc?: string(name='StatusDesc'),
    }
  ](name='OriginSQLList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListSQLReviewOriginSQLResponse = {
  headers: map[string]string(name='headers'),
  body: ListSQLReviewOriginSQLResponseBody(name='body'),
}

async function listSQLReviewOriginSQL(request: ListSQLReviewOriginSQLRequest): ListSQLReviewOriginSQLResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSQLReviewOriginSQL', 'POST', '/', 'json', false, 'json', request);
}

model ListSensitiveColumnsRequest {
  columnName?: string(name='ColumnName', position='Query'),
  dbId?: long(name='DbId', position='Query'),
  logic?: boolean(name='Logic', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  schemaName?: string(name='SchemaName', position='Query'),
  securityLevel?: string(name='SecurityLevel', position='Query'),
  tableName?: string(name='TableName', position='Query'),
  tid?: long(name='Tid', position='Query'),
}

model ListSensitiveColumnsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  sensitiveColumnList?: {
    sensitiveColumn?: [ 
    {
      columnCount?: long(name='ColumnCount'),
      columnName?: string(name='ColumnName'),
      functionType?: string(name='FunctionType'),
      schemaName?: string(name='SchemaName'),
      securityLevel?: string(name='SecurityLevel'),
      tableName?: string(name='TableName'),
    }
  ](name='SensitiveColumn')
  }(name='SensitiveColumnList'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListSensitiveColumnsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSensitiveColumnsResponseBody(name='body'),
}

async function listSensitiveColumns(request: ListSensitiveColumnsRequest): ListSensitiveColumnsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSensitiveColumns', 'POST', '/', 'json', false, 'json', request);
}

model ListSensitiveColumnsDetailRequest {
  columnName: string(name='ColumnName', position='Query'),
  dbId?: long(name='DbId', position='Query'),
  logic?: boolean(name='Logic', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  schemaName: string(name='SchemaName', position='Query'),
  tableName: string(name='TableName', position='Query'),
  tid?: long(name='Tid', position='Query'),
}

model ListSensitiveColumnsDetailResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  sensitiveColumnsDetailList?: {
    sensitiveColumnsDetail?: [ 
    {
      columnDescription?: string(name='ColumnDescription'),
      columnName?: string(name='ColumnName'),
      columnType?: string(name='ColumnType'),
      dbId?: long(name='DbId'),
      dbType?: string(name='DbType'),
      envType?: string(name='EnvType'),
      logic?: boolean(name='Logic'),
      schemaName?: string(name='SchemaName'),
      searchName?: string(name='SearchName'),
      tableName?: string(name='TableName'),
    }
  ](name='SensitiveColumnsDetail')
  }(name='SensitiveColumnsDetailList'),
  success?: boolean(name='Success'),
}

model ListSensitiveColumnsDetailResponse = {
  headers: map[string]string(name='headers'),
  body: ListSensitiveColumnsDetailResponseBody(name='body'),
}

async function listSensitiveColumnsDetail(request: ListSensitiveColumnsDetailRequest): ListSensitiveColumnsDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSensitiveColumnsDetail', 'POST', '/', 'json', false, 'json', request);
}

model ListTablesRequest {
  databaseId: string(name='DatabaseId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  returnGuid?: boolean(name='ReturnGuid', position='Query'),
  searchName?: string(name='SearchName', position='Query'),
  tid?: long(name='Tid', position='Query'),
}

model ListTablesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tableList?: {
    table?: [ 
    {
      databaseId?: string(name='DatabaseId'),
      description?: string(name='Description'),
      encoding?: string(name='Encoding'),
      engine?: string(name='Engine'),
      numRows?: long(name='NumRows'),
      ownerIdList?: {
        ownerIds?: [ string ](name='OwnerIds')
      }(name='OwnerIdList'),
      ownerNameList?: {
        ownerNames?: [ string ](name='OwnerNames')
      }(name='OwnerNameList'),
      storeCapacity?: long(name='StoreCapacity'),
      tableGuid?: string(name='TableGuid'),
      tableId?: string(name='TableId'),
      tableName?: string(name='TableName'),
      tableSchemaName?: string(name='TableSchemaName'),
      tableType?: string(name='TableType'),
    }
  ](name='Table')
  }(name='TableList'),
  totalCount?: long(name='TotalCount'),
}

model ListTablesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTablesResponseBody(name='body'),
}

async function listTables(request: ListTablesRequest): ListTablesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTables', 'POST', '/', 'json', false, 'json', request);
}

model ListUserPermissionsRequest {
  databaseName?: string(name='DatabaseName', position='Query'),
  dbType?: string(name='DbType', position='Query'),
  envType?: string(name='EnvType', position='Query'),
  logic?: boolean(name='Logic', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  permType: string(name='PermType', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  searchKey?: string(name='SearchKey', position='Query'),
  tid?: long(name='Tid', position='Query'),
  userId: string(name='UserId', position='Query'),
}

model ListUserPermissionsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
  userPermissions?: {
    userPermission?: [ 
    {
      alias?: string(name='Alias'),
      columnName?: string(name='ColumnName'),
      dbId?: string(name='DbId'),
      dbType?: string(name='DbType'),
      dsType?: string(name='DsType'),
      envType?: string(name='EnvType'),
      host?: string(name='Host'),
      instanceId?: string(name='InstanceId'),
      logic?: boolean(name='Logic'),
      permDetails?: {
        permDetail?: [ 
        {
          createDate?: string(name='CreateDate'),
          expireDate?: string(name='ExpireDate'),
          extraData?: string(name='ExtraData'),
          originFrom?: string(name='OriginFrom'),
          permType?: string(name='PermType'),
          userAccessId?: string(name='UserAccessId'),
        }
      ](name='PermDetail')
      }(name='PermDetails'),
      port?: long(name='Port'),
      schemaName?: string(name='SchemaName'),
      searchName?: string(name='SearchName'),
      tableId?: string(name='TableId'),
      tableName?: string(name='TableName'),
      userId?: string(name='UserId'),
      userNickName?: string(name='UserNickName'),
    }
  ](name='UserPermission')
  }(name='UserPermissions'),
}

model ListUserPermissionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListUserPermissionsResponseBody(name='body'),
}

async function listUserPermissions(request: ListUserPermissionsRequest): ListUserPermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUserPermissions', 'POST', '/', 'json', false, 'json', request);
}

model ListUserTenantsRequest {
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model ListUserTenantsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tenantList?: [ 
    {
      status?: string(name='Status'),
      tenantName?: string(name='TenantName'),
      tid?: long(name='Tid'),
    }
  ](name='TenantList'),
}

model ListUserTenantsResponse = {
  headers: map[string]string(name='headers'),
  body: ListUserTenantsResponseBody(name='body'),
}

async function listUserTenants(request: ListUserTenantsRequest): ListUserTenantsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUserTenants', 'POST', '/', 'json', false, 'json', request);
}

model ListUsersRequest {
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  role?: string(name='Role', position='Query'),
  searchKey?: string(name='SearchKey', position='Query'),
  tid?: long(name='Tid', position='Query'),
  userState?: string(name='UserState', position='Query'),
}

model ListUsersResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
  userList?: {
    user?: [ 
    {
      curExecuteCount?: long(name='CurExecuteCount'),
      curResultCount?: long(name='CurResultCount'),
      dingRobot?: string(name='DingRobot'),
      email?: string(name='Email'),
      lastLoginTime?: string(name='LastLoginTime'),
      maxExecuteCount?: long(name='MaxExecuteCount'),
      maxResultCount?: long(name='MaxResultCount'),
      mobile?: string(name='Mobile'),
      nickName?: string(name='NickName'),
      notificationMode?: string(name='NotificationMode'),
      parentUid?: string(name='ParentUid'),
      roleIdList?: {
        roleIds?: [ int32 ](name='RoleIds')
      }(name='RoleIdList'),
      roleNameList?: {
        roleNames?: [ string ](name='RoleNames')
      }(name='RoleNameList'),
      signatureMethod?: string(name='SignatureMethod'),
      state?: string(name='State'),
      uid?: string(name='Uid'),
      userId?: string(name='UserId'),
      webhook?: string(name='Webhook'),
    }
  ](name='User')
  }(name='UserList'),
}

model ListUsersResponse = {
  headers: map[string]string(name='headers'),
  body: ListUsersResponseBody(name='body'),
}

async function listUsers(request: ListUsersRequest): ListUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUsers', 'POST', '/', 'json', false, 'json', request);
}

model ListWorkFlowNodesRequest {
  regionId?: string(name='RegionId', position='Host'),
  searchName?: string(name='SearchName', position='Query'),
  tid?: long(name='Tid', position='Query'),
}

model ListWorkFlowNodesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  workflowNodes?: {
    workflowNode?: [ 
    {
      auditUsers?: {
        auditUser?: [ 
        {
          nickName?: string(name='NickName'),
          realName?: string(name='RealName'),
          userId?: long(name='UserId'),
        }
      ](name='AuditUser')
      }(name='AuditUsers'),
      comment?: string(name='Comment'),
      createUserId?: long(name='CreateUserId'),
      createUserNickName?: string(name='CreateUserNickName'),
      nodeId?: long(name='NodeId'),
      nodeName?: string(name='NodeName'),
      nodeType?: string(name='NodeType'),
    }
  ](name='WorkflowNode')
  }(name='WorkflowNodes'),
}

model ListWorkFlowNodesResponse = {
  headers: map[string]string(name='headers'),
  body: ListWorkFlowNodesResponseBody(name='body'),
}

async function listWorkFlowNodes(request: ListWorkFlowNodesRequest): ListWorkFlowNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListWorkFlowNodes', 'POST', '/', 'json', false, 'json', request);
}

model ListWorkFlowTemplatesRequest {
  regionId?: string(name='RegionId', position='Host'),
  searchName?: string(name='SearchName', position='Query'),
  tid?: long(name='Tid', position='Query'),
}

model ListWorkFlowTemplatesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  workFlowTemplates?: {
    workFlowTemplate?: [ 
    {
      comment?: string(name='Comment'),
      createUserId?: long(name='CreateUserId'),
      enabled?: string(name='Enabled'),
      isSystem?: int32(name='IsSystem'),
      templateId?: long(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      workflowNodes?: {
        workflowNode?: [ 
        {
          comment?: string(name='Comment'),
          createUserId?: long(name='CreateUserId'),
          nodeId?: long(name='NodeId'),
          nodeName?: string(name='NodeName'),
          nodeType?: string(name='NodeType'),
          position?: int32(name='Position'),
          templateId?: long(name='TemplateId'),
        }
      ](name='WorkflowNode')
      }(name='WorkflowNodes'),
    }
  ](name='WorkFlowTemplate')
  }(name='WorkFlowTemplates'),
}

model ListWorkFlowTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListWorkFlowTemplatesResponseBody(name='body'),
}

async function listWorkFlowTemplates(request: ListWorkFlowTemplatesRequest): ListWorkFlowTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListWorkFlowTemplates', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDataCorrectExecSQLRequest {
  execSQL: string(name='ExecSQL', position='Query'),
  orderId: long(name='OrderId', minimum=1, maximum=9223372036854775807, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model ModifyDataCorrectExecSQLResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ModifyDataCorrectExecSQLResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDataCorrectExecSQLResponseBody(name='body'),
}

async function modifyDataCorrectExecSQL(request: ModifyDataCorrectExecSQLRequest): ModifyDataCorrectExecSQLResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDataCorrectExecSQL', 'POST', '/', 'json', false, 'json', request);
}

model PauseDataCorrectSQLJobRequest {
  jobId?: long(name='JobId', position='Query'),
  orderId: long(name='OrderId', minimum=1, maximum=9223372036854775807, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
  type: string(name='Type', position='Query'),
}

model PauseDataCorrectSQLJobResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model PauseDataCorrectSQLJobResponse = {
  headers: map[string]string(name='headers'),
  body: PauseDataCorrectSQLJobResponseBody(name='body'),
}

async function pauseDataCorrectSQLJob(request: PauseDataCorrectSQLJobRequest): PauseDataCorrectSQLJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PauseDataCorrectSQLJob', 'POST', '/', 'json', false, 'json', request);
}

model RegisterInstanceRequest {
  dataLinkName?: string(name='DataLinkName', position='Query'),
  databasePassword: string(name='DatabasePassword', position='Query'),
  databaseUser: string(name='DatabaseUser', position='Query'),
  dbaUid: long(name='DbaUid', position='Query'),
  ddlOnline?: int32(name='DdlOnline', position='Query'),
  ecsInstanceId?: string(name='EcsInstanceId', position='Query'),
  ecsRegion?: string(name='EcsRegion', position='Query'),
  envType: string(name='EnvType', position='Query'),
  exportTimeout: int32(name='ExportTimeout', position='Query'),
  host: string(name='Host', position='Query'),
  instanceAlias: string(name='InstanceAlias', position='Query'),
  instanceSource: string(name='InstanceSource', position='Query'),
  instanceType: string(name='InstanceType', position='Query'),
  networkType: string(name='NetworkType', position='Query'),
  port: int32(name='Port', position='Query'),
  queryTimeout: int32(name='QueryTimeout', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  safeRule: string(name='SafeRule', position='Query'),
  sid?: string(name='Sid', position='Query'),
  skipTest?: boolean(name='SkipTest', position='Query'),
  tid?: long(name='Tid', position='Query'),
  useDsql?: int32(name='UseDsql', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model RegisterInstanceResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RegisterInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RegisterInstanceResponseBody(name='body'),
}

async function registerInstance(request: RegisterInstanceRequest): RegisterInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RegisterInstance', 'POST', '/', 'json', false, 'json', request);
}

model RegisterUserRequest {
  mobile?: string(name='Mobile', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  roleNames?: string(name='RoleNames', position='Query'),
  tid?: long(name='Tid', position='Query'),
  uid: string(name='Uid', position='Query'),
  userNick?: string(name='UserNick', position='Query'),
}

model RegisterUserResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RegisterUserResponse = {
  headers: map[string]string(name='headers'),
  body: RegisterUserResponseBody(name='body'),
}

async function registerUser(request: RegisterUserRequest): RegisterUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RegisterUser', 'POST', '/', 'json', false, 'json', request);
}

model RestartDataCorrectSQLJobRequest {
  jobId?: long(name='JobId', position='Query'),
  orderId: long(name='OrderId', minimum=1, maximum=9223372036854775807, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
  type: string(name='Type', position='Query'),
}

model RestartDataCorrectSQLJobResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model RestartDataCorrectSQLJobResponse = {
  headers: map[string]string(name='headers'),
  body: RestartDataCorrectSQLJobResponseBody(name='body'),
}

async function restartDataCorrectSQLJob(request: RestartDataCorrectSQLJobRequest): RestartDataCorrectSQLJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RestartDataCorrectSQLJob', 'POST', '/', 'json', false, 'json', request);
}

model RetryDataCorrectPreCheckRequest {
  orderId: long(name='OrderId', minimum=1, maximum=9223372036854775807, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model RetryDataCorrectPreCheckResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model RetryDataCorrectPreCheckResponse = {
  headers: map[string]string(name='headers'),
  body: RetryDataCorrectPreCheckResponseBody(name='body'),
}

async function retryDataCorrectPreCheck(request: RetryDataCorrectPreCheckRequest): RetryDataCorrectPreCheckResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RetryDataCorrectPreCheck', 'POST', '/', 'json', false, 'json', request);
}

model RevokeUserPermissionRequest {
  dbId?: string(name='DbId', position='Query'),
  dsType: string(name='DsType', position='Query'),
  instanceId?: long(name='InstanceId', position='Query'),
  logic?: boolean(name='Logic', position='Query'),
  permTypes: string(name='PermTypes', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tableId?: string(name='TableId', position='Query'),
  tableName?: string(name='TableName', position='Query'),
  tid?: long(name='Tid', position='Query'),
  userAccessId: string(name='UserAccessId', position='Query'),
  userId: string(name='UserId', position='Query'),
}

model RevokeUserPermissionResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RevokeUserPermissionResponse = {
  headers: map[string]string(name='headers'),
  body: RevokeUserPermissionResponseBody(name='body'),
}

async function revokeUserPermission(request: RevokeUserPermissionRequest): RevokeUserPermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RevokeUserPermission', 'POST', '/', 'json', false, 'json', request);
}

model SearchDatabaseRequest {
  dbType?: string(name='DbType', position='Query'),
  envType?: string(name='EnvType', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  searchKey?: string(name='SearchKey', position='Query'),
  searchRange?: string(name='SearchRange', position='Query'),
  searchTarget?: string(name='SearchTarget', position='Query'),
  tid?: long(name='Tid', position='Query'),
}

model SearchDatabaseResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  searchDatabaseList?: {
    searchDatabase?: [ 
    {
      alias?: string(name='Alias'),
      databaseId?: string(name='DatabaseId'),
      datalinkName?: string(name='DatalinkName'),
      dbType?: string(name='DbType'),
      dbaId?: string(name='DbaId'),
      encoding?: string(name='Encoding'),
      envType?: string(name='EnvType'),
      host?: string(name='Host'),
      logic?: boolean(name='Logic'),
      ownerIdList?: {
        ownerIds?: [ string ](name='OwnerIds')
      }(name='OwnerIdList'),
      ownerNameList?: {
        ownerNames?: [ string ](name='OwnerNames')
      }(name='OwnerNameList'),
      port?: int32(name='Port'),
      schemaName?: string(name='SchemaName'),
      searchName?: string(name='SearchName'),
      sid?: string(name='Sid'),
    }
  ](name='SearchDatabase')
  }(name='SearchDatabaseList'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model SearchDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: SearchDatabaseResponseBody(name='body'),
}

async function searchDatabase(request: SearchDatabaseRequest): SearchDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchDatabase', 'POST', '/', 'json', false, 'json', request);
}

model SearchTableRequest {
  dbType?: string(name='DbType', position='Query'),
  envType?: string(name='EnvType', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  returnGuid?: boolean(name='ReturnGuid', position='Query'),
  searchKey?: string(name='SearchKey', position='Query'),
  searchRange?: string(name='SearchRange', position='Query'),
  searchTarget?: string(name='SearchTarget', position='Query'),
  tid?: long(name='Tid', position='Query'),
}

model SearchTableResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  searchTableList?: {
    searchTable?: [ 
    {
      DBSearchName?: string(name='DBSearchName'),
      databaseId?: string(name='DatabaseId'),
      dbName?: string(name='DbName'),
      dbType?: string(name='DbType'),
      description?: string(name='Description'),
      encoding?: string(name='Encoding'),
      engine?: string(name='Engine'),
      envType?: string(name='EnvType'),
      logic?: boolean(name='Logic'),
      ownerIdList?: {
        ownerIds?: [ string ](name='OwnerIds')
      }(name='OwnerIdList'),
      ownerNameList?: {
        ownerNames?: [ string ](name='OwnerNames')
      }(name='OwnerNameList'),
      tableGuid?: string(name='TableGuid'),
      tableId?: string(name='TableId'),
      tableName?: string(name='TableName'),
      tableSchemaName?: string(name='TableSchemaName'),
    }
  ](name='SearchTable')
  }(name='SearchTableList'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model SearchTableResponse = {
  headers: map[string]string(name='headers'),
  body: SearchTableResponseBody(name='body'),
}

async function searchTable(request: SearchTableRequest): SearchTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchTable', 'POST', '/', 'json', false, 'json', request);
}

model SetOwnersRequest {
  ownerIds: string(name='OwnerIds', position='Query'),
  ownerType: string(name='OwnerType', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  resourceId: string(name='ResourceId', position='Query'),
  tid?: long(name='Tid', position='Query'),
}

model SetOwnersResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SetOwnersResponse = {
  headers: map[string]string(name='headers'),
  body: SetOwnersResponseBody(name='body'),
}

async function setOwners(request: SetOwnersRequest): SetOwnersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetOwners', 'POST', '/', 'json', false, 'json', request);
}

model SubmitOrderApprovalRequest {
  orderId: long(name='OrderId', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', position='Query'),
}

model SubmitOrderApprovalResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SubmitOrderApprovalResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitOrderApprovalResponseBody(name='body'),
}

async function submitOrderApproval(request: SubmitOrderApprovalRequest): SubmitOrderApprovalResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitOrderApproval', 'POST', '/', 'json', false, 'json', request);
}

model SubmitSparkJobRequest {
  appCode: string(name='AppCode', position='Body'),
  arguments?: [ string ](name='Arguments', position='Body'),
  configuration?: map[string]any(name='Configuration', position='Body'),
  files?: [ string ](name='Files', position='Body'),
  mainClass: string(name='MainClass', position='Body'),
  mainFile: string(name='MainFile', position='Body'),
  name: string(name='Name', position='Body'),
  ossInfo?: {
    accessKeyId?: string(name='AccessKeyId'),
    accessKeySecret?: string(name='AccessKeySecret'),
    endpoint?: string(name='Endpoint'),
  }(name='OssInfo', position='Body'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model SubmitSparkJobResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  jobId?: long(name='JobId', description='Id of the spark job'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model SubmitSparkJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitSparkJobResponseBody(name='body'),
}

async function submitSparkJob(request: SubmitSparkJobRequest): SubmitSparkJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitSparkJob', 'POST', '/', 'json', true, 'form', request);
}

model SubmitStructSyncOrderApprovalRequest {
  orderId: long(name='OrderId', minimum=1, maximum=9223372036854775807, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', minimum=1, maximum=9223372036854775807, position='Query'),
}

model SubmitStructSyncOrderApprovalResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
  workflowInstanceId?: long(name='WorkflowInstanceId'),
}

model SubmitStructSyncOrderApprovalResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitStructSyncOrderApprovalResponseBody(name='body'),
}

async function submitStructSyncOrderApproval(request: SubmitStructSyncOrderApprovalRequest): SubmitStructSyncOrderApprovalResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitStructSyncOrderApproval', 'POST', '/', 'json', false, 'json', request);
}

model SyncDatabaseMetaRequest {
  dbId: string(name='DbId', position='Query'),
  logic?: boolean(name='Logic', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', position='Query'),
}

model SyncDatabaseMetaResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SyncDatabaseMetaResponse = {
  headers: map[string]string(name='headers'),
  body: SyncDatabaseMetaResponseBody(name='body'),
}

async function syncDatabaseMeta(request: SyncDatabaseMetaRequest): SyncDatabaseMetaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SyncDatabaseMeta', 'POST', '/', 'json', false, 'json', request);
}

model SyncInstanceMetaRequest {
  ignoreTable?: boolean(name='IgnoreTable', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  tid?: long(name='Tid', position='Query'),
}

model SyncInstanceMetaResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SyncInstanceMetaResponse = {
  headers: map[string]string(name='headers'),
  body: SyncInstanceMetaResponseBody(name='body'),
}

async function syncInstanceMeta(request: SyncInstanceMetaRequest): SyncInstanceMetaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SyncInstanceMeta', 'POST', '/', 'json', false, 'json', request);
}

model UpdateInstanceRequest {
  dataLinkName?: string(name='DataLinkName', position='Query'),
  databasePassword: string(name='DatabasePassword', position='Query'),
  databaseUser: string(name='DatabaseUser', position='Query'),
  dbaId: string(name='DbaId', position='Query'),
  ddlOnline?: int32(name='DdlOnline', position='Query'),
  ecsInstanceId?: string(name='EcsInstanceId', position='Query'),
  ecsRegion?: string(name='EcsRegion', position='Query'),
  envType: string(name='EnvType', position='Query'),
  exportTimeout: int32(name='ExportTimeout', position='Query'),
  host: string(name='Host', position='Query'),
  instanceAlias: string(name='InstanceAlias', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  instanceSource: string(name='InstanceSource', position='Query'),
  instanceType: string(name='InstanceType', position='Query'),
  port: int32(name='Port', position='Query'),
  queryTimeout: int32(name='QueryTimeout', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  safeRuleId: string(name='SafeRuleId', position='Query'),
  sid?: string(name='Sid', position='Query'),
  skipTest?: boolean(name='SkipTest', position='Query'),
  tid?: long(name='Tid', position='Query'),
  useDsql?: int32(name='UseDsql', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model UpdateInstanceResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateInstanceResponseBody(name='body'),
}

async function updateInstance(request: UpdateInstanceRequest): UpdateInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateInstance', 'POST', '/', 'json', false, 'json', request);
}

model UpdateUserRequest {
  maxExecuteCount?: long(name='MaxExecuteCount', position='Query'),
  maxResultCount?: long(name='MaxResultCount', position='Query'),
  mobile?: string(name='Mobile', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  roleNames?: string(name='RoleNames', position='Query'),
  tid?: long(name='Tid', position='Query'),
  uid: long(name='Uid', position='Query'),
  userNick?: string(name='UserNick', position='Query'),
}

model UpdateUserResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateUserResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateUserResponseBody(name='body'),
}

async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateUser', 'POST', '/', 'json', false, 'json', request);
}

