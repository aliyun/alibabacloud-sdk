/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Ecs';
  @version = '2014-05-26';
  @endpointRule = 'regional';
  @endpointMap = {
    cn-hangzhou = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-shanghai-finance-1 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-shenzhen-finance-1 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-north-2-gov-1 = 'ecs.aliyuncs.com',
    ap-northeast-2-pop = 'ecs.aliyuncs.com',
    cn-beijing-finance-pop = 'ecs.aliyuncs.com',
    cn-beijing-gov-1 = 'ecs.aliyuncs.com',
    cn-beijing-nu16-b01 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-edge-1 = 'ecs.cn-qingdao-nebula.aliyuncs.com',
    cn-fujian = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-haidian-cm12-c01 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-hangzhou-finance = 'ecs.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-hangzhou-test-306 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-hongkong-finance-pop = 'ecs.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'ecs.cn-qingdao-nebula.aliyuncs.com',
    cn-shanghai-et15-b01 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-shanghai-et2-b01 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-shanghai-inner = 'ecs.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-shenzhen-inner = 'ecs.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-wuhan = 'ecs.aliyuncs.com',
    cn-yushanfang = 'ecs.aliyuncs.com',
    cn-zhangbei = 'ecs.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'ecs.cn-zhangjiakou.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'ecs.cn-qingdao-nebula.aliyuncs.com',
    eu-west-1-oxs = 'ecs.cn-shenzhen-cloudstone.aliyuncs.com',
    rus-west-1-pop = 'ecs.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model AcceptInquiredSystemEventRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  choice?: string(name='Choice', position='Query'),
  eventId: string(name='EventId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AcceptInquiredSystemEventResponseBody = {
  requestId?: string(name='RequestId'),
}

model AcceptInquiredSystemEventResponse = {
  headers: map[string]string(name='headers'),
  body: AcceptInquiredSystemEventResponseBody(name='body'),
}

async function acceptInquiredSystemEvent(request: AcceptInquiredSystemEventRequest): AcceptInquiredSystemEventResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AcceptInquiredSystemEvent', 'POST', '/', 'json', false, 'json', request);
}

model ActivateRouterInterfaceRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routerInterfaceId: string(name='RouterInterfaceId', position='Query'),
}

model ActivateRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ActivateRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: ActivateRouterInterfaceResponseBody(name='body'),
}

async function activateRouterInterface(request: ActivateRouterInterfaceRequest): ActivateRouterInterfaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ActivateRouterInterface', 'POST', '/', 'json', false, 'json', request);
}

model AddBandwidthPackageIpsRequest {
  bandwidthPackageId: string(name='BandwidthPackageId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ipCount: string(name='IpCount', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AddBandwidthPackageIpsResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddBandwidthPackageIpsResponse = {
  headers: map[string]string(name='headers'),
  body: AddBandwidthPackageIpsResponseBody(name='body'),
}

async function addBandwidthPackageIps(request: AddBandwidthPackageIpsRequest): AddBandwidthPackageIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddBandwidthPackageIps', 'POST', '/', 'json', false, 'json', request);
}

model AddTagsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId: string(name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model AddTagsResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddTagsResponse = {
  headers: map[string]string(name='headers'),
  body: AddTagsResponseBody(name='body'),
}

async function addTags(request: AddTagsRequest): AddTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddTags', 'POST', '/', 'json', false, 'json', request);
}

model AllocateDedicatedHostsRequest {
  networkAttributes?: {
    slbUdpTimeout?: int32(name='SlbUdpTimeout'),
    udpTimeout?: int32(name='UdpTimeout'),
  }(name='NetworkAttributes', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  actionOnMaintenance?: string(name='ActionOnMaintenance', position='Query'),
  autoPlacement?: string(name='AutoPlacement', position='Query'),
  autoReleaseTime?: string(name='AutoReleaseTime', position='Query'),
  autoRenew?: boolean(name='AutoRenew', position='Query'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod', position='Query'),
  chargeType?: string(name='ChargeType', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  cpuOverCommitRatio?: float(name='CpuOverCommitRatio', position='Query'),
  dedicatedHostClusterId?: string(name='DedicatedHostClusterId', position='Query'),
  dedicatedHostName?: string(name='DedicatedHostName', position='Query'),
  dedicatedHostType: string(name='DedicatedHostType', position='Query'),
  description?: string(name='Description', position='Query'),
  minQuantity?: int32(name='MinQuantity', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  quantity?: int32(name='Quantity', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model AllocateDedicatedHostsResponseBody = {
  dedicatedHostIdSets?: {
    dedicatedHostId?: [ string ](name='DedicatedHostId')
  }(name='DedicatedHostIdSets'),
  requestId?: string(name='RequestId'),
}

model AllocateDedicatedHostsResponse = {
  headers: map[string]string(name='headers'),
  body: AllocateDedicatedHostsResponseBody(name='body'),
}

async function allocateDedicatedHosts(request: AllocateDedicatedHostsRequest): AllocateDedicatedHostsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AllocateDedicatedHosts', 'POST', '/', 'json', false, 'json', request);
}

model AllocateEipAddressRequest {
  activityId?: long(name='ActivityId', position='Query'),
  bandwidth?: string(name='Bandwidth', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ISP?: string(name='ISP', position='Query'),
  internetChargeType?: string(name='InternetChargeType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AllocateEipAddressResponseBody = {
  allocationId?: string(name='AllocationId'),
  eipAddress?: string(name='EipAddress'),
  requestId?: string(name='RequestId'),
}

model AllocateEipAddressResponse = {
  headers: map[string]string(name='headers'),
  body: AllocateEipAddressResponseBody(name='body'),
}

async function allocateEipAddress(request: AllocateEipAddressRequest): AllocateEipAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AllocateEipAddress', 'POST', '/', 'json', false, 'json', request);
}

model AllocatePublicIpAddressRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId: string(name='InstanceId', position='Query'),
  ipAddress?: string(name='IpAddress', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vlanId?: string(name='VlanId', position='Query'),
}

model AllocatePublicIpAddressResponseBody = {
  ipAddress?: string(name='IpAddress'),
  requestId?: string(name='RequestId'),
}

model AllocatePublicIpAddressResponse = {
  headers: map[string]string(name='headers'),
  body: AllocatePublicIpAddressResponseBody(name='body'),
}

async function allocatePublicIpAddress(request: AllocatePublicIpAddressRequest): AllocatePublicIpAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AllocatePublicIpAddress', 'POST', '/', 'json', false, 'json', request);
}

model ApplyAutoSnapshotPolicyRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  autoSnapshotPolicyId: string(name='autoSnapshotPolicyId', position='Query'),
  diskIds: string(name='diskIds', position='Query'),
  regionId: string(name='regionId', position='Query'),
}

model ApplyAutoSnapshotPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ApplyAutoSnapshotPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: ApplyAutoSnapshotPolicyResponseBody(name='body'),
}

async function applyAutoSnapshotPolicy(request: ApplyAutoSnapshotPolicyRequest): ApplyAutoSnapshotPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ApplyAutoSnapshotPolicy', 'POST', '/', 'json', false, 'json', request);
}

model AssignIpv6AddressesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ipv6Address?: [ string ](name='Ipv6Address', position='Query'),
  ipv6AddressCount?: int32(name='Ipv6AddressCount', position='Query'),
  networkInterfaceId: string(name='NetworkInterfaceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AssignIpv6AddressesResponseBody = {
  ipv6Sets?: {
    ipv6Address?: [ string ](name='Ipv6Address')
  }(name='Ipv6Sets'),
  networkInterfaceId?: string(name='NetworkInterfaceId'),
  requestId?: string(name='RequestId'),
}

model AssignIpv6AddressesResponse = {
  headers: map[string]string(name='headers'),
  body: AssignIpv6AddressesResponseBody(name='body'),
}

async function assignIpv6Addresses(request: AssignIpv6AddressesRequest): AssignIpv6AddressesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssignIpv6Addresses', 'POST', '/', 'json', false, 'json', request);
}

model AssignPrivateIpAddressesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  networkInterfaceId: string(name='NetworkInterfaceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  privateIpAddress?: [ string ](name='PrivateIpAddress', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  secondaryPrivateIpAddressCount?: int32(name='SecondaryPrivateIpAddressCount', minimum=1, position='Query'),
}

model AssignPrivateIpAddressesResponseBody = {
  assignedPrivateIpAddressesSet?: {
    networkInterfaceId?: string(name='NetworkInterfaceId'),
    privateIpSet?: {
      privateIpAddress?: [ string ](name='PrivateIpAddress')
    }(name='PrivateIpSet'),
  }(name='AssignedPrivateIpAddressesSet'),
  requestId?: string(name='RequestId'),
}

model AssignPrivateIpAddressesResponse = {
  headers: map[string]string(name='headers'),
  body: AssignPrivateIpAddressesResponseBody(name='body'),
}

async function assignPrivateIpAddresses(request: AssignPrivateIpAddressesRequest): AssignPrivateIpAddressesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssignPrivateIpAddresses', 'POST', '/', 'json', false, 'json', request);
}

model AssociateEipAddressRequest {
  allocationId: string(name='AllocationId', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AssociateEipAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateEipAddressResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateEipAddressResponseBody(name='body'),
}

async function associateEipAddress(request: AssociateEipAddressRequest): AssociateEipAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssociateEipAddress', 'POST', '/', 'json', false, 'json', request);
}

model AssociateHaVipRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  haVipId: string(name='HaVipId', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AssociateHaVipResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateHaVipResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateHaVipResponseBody(name='body'),
}

async function associateHaVip(request: AssociateHaVipRequest): AssociateHaVipResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssociateHaVip', 'POST', '/', 'json', false, 'json', request);
}

model AttachClassicLinkVpcRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
}

model AttachClassicLinkVpcResponseBody = {
  requestId?: string(name='RequestId'),
}

model AttachClassicLinkVpcResponse = {
  headers: map[string]string(name='headers'),
  body: AttachClassicLinkVpcResponseBody(name='body'),
}

async function attachClassicLinkVpc(request: AttachClassicLinkVpcRequest): AttachClassicLinkVpcResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AttachClassicLinkVpc', 'POST', '/', 'json', false, 'json', request);
}

model AttachDiskRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  bootable?: boolean(name='Bootable', position='Query'),
  deleteWithInstance?: boolean(name='DeleteWithInstance', position='Query'),
  device?: string(name='Device', position='Query'),
  diskId: string(name='DiskId', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  keyPairName?: string(name='KeyPairName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  password?: string(name='Password', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AttachDiskResponseBody = {
  requestId?: string(name='RequestId'),
}

model AttachDiskResponse = {
  headers: map[string]string(name='headers'),
  body: AttachDiskResponseBody(name='body'),
}

async function attachDisk(request: AttachDiskRequest): AttachDiskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AttachDisk', 'POST', '/', 'json', false, 'json', request);
}

model AttachInstanceRamRoleRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceIds: string(name='InstanceIds', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  policy?: string(name='Policy', position='Query'),
  ramRoleName: string(name='RamRoleName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AttachInstanceRamRoleResponseBody = {
  attachInstanceRamRoleResults?: {
    attachInstanceRamRoleResult?: [ 
    {
      code?: string(name='Code'),
      instanceId?: string(name='InstanceId'),
      message?: string(name='Message'),
      success?: boolean(name='Success'),
    }
  ](name='AttachInstanceRamRoleResult')
  }(name='AttachInstanceRamRoleResults'),
  failCount?: int32(name='FailCount'),
  ramRoleName?: string(name='RamRoleName'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model AttachInstanceRamRoleResponse = {
  headers: map[string]string(name='headers'),
  body: AttachInstanceRamRoleResponseBody(name='body'),
}

async function attachInstanceRamRole(request: AttachInstanceRamRoleRequest): AttachInstanceRamRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AttachInstanceRamRole', 'POST', '/', 'json', false, 'json', request);
}

model AttachKeyPairRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceIds: string(name='InstanceIds', position='Query'),
  keyPairName: string(name='KeyPairName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AttachKeyPairResponseBody = {
  failCount?: string(name='FailCount'),
  keyPairName?: string(name='KeyPairName'),
  requestId?: string(name='RequestId'),
  results?: {
    result?: [ 
    {
      code?: string(name='Code'),
      instanceId?: string(name='InstanceId'),
      message?: string(name='Message'),
      success?: string(name='Success'),
    }
  ](name='Result')
  }(name='Results'),
  totalCount?: string(name='TotalCount'),
}

model AttachKeyPairResponse = {
  headers: map[string]string(name='headers'),
  body: AttachKeyPairResponseBody(name='body'),
}

async function attachKeyPair(request: AttachKeyPairRequest): AttachKeyPairResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AttachKeyPair', 'POST', '/', 'json', false, 'json', request);
}

model AttachNetworkInterfaceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId: string(name='InstanceId', position='Query'),
  networkInterfaceId: string(name='NetworkInterfaceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  trunkNetworkInstanceId?: string(name='TrunkNetworkInstanceId', position='Query'),
  waitForNetworkConfigurationReady?: boolean(name='WaitForNetworkConfigurationReady', position='Query'),
}

model AttachNetworkInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model AttachNetworkInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: AttachNetworkInterfaceResponseBody(name='body'),
}

async function attachNetworkInterface(request: AttachNetworkInterfaceRequest): AttachNetworkInterfaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AttachNetworkInterface', 'POST', '/', 'json', false, 'json', request);
}

model AuthorizeSecurityGroupRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  destCidrIp?: string(name='DestCidrIp', position='Query'),
  ipProtocol?: string(name='IpProtocol', position='Query'),
  ipv6DestCidrIp?: string(name='Ipv6DestCidrIp', position='Query'),
  ipv6SourceCidrIp?: string(name='Ipv6SourceCidrIp', position='Query'),
  nicType?: string(name='NicType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  permissions?: [ 
    {
      description?: string(name='Description'),
      destCidrIp?: string(name='DestCidrIp'),
      ipProtocol?: string(name='IpProtocol'),
      ipv6DestCidrIp?: string(name='Ipv6DestCidrIp'),
      ipv6SourceCidrIp?: string(name='Ipv6SourceCidrIp'),
      nicType?: string(name='NicType'),
      policy?: string(name='Policy'),
      portRange?: string(name='PortRange'),
      priority?: string(name='Priority'),
      sourceCidrIp?: string(name='SourceCidrIp'),
      sourceGroupId?: string(name='SourceGroupId'),
      sourceGroupOwnerAccount?: string(name='SourceGroupOwnerAccount'),
      sourceGroupOwnerId?: long(name='SourceGroupOwnerId'),
      sourcePortRange?: string(name='SourcePortRange'),
      sourcePrefixListId?: string(name='SourcePrefixListId'),
    }
  ](name='Permissions', position='Query'),
  policy?: string(name='Policy', position='Query'),
  portRange?: string(name='PortRange', position='Query'),
  priority?: string(name='Priority', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId: string(name='SecurityGroupId', position='Query'),
  sourceCidrIp?: string(name='SourceCidrIp', position='Query'),
  sourceGroupId?: string(name='SourceGroupId', position='Query'),
  sourceGroupOwnerAccount?: string(name='SourceGroupOwnerAccount', position='Query'),
  sourceGroupOwnerId?: long(name='SourceGroupOwnerId', position='Query'),
  sourcePortRange?: string(name='SourcePortRange', position='Query'),
  sourcePrefixListId?: string(name='SourcePrefixListId', position='Query'),
}

model AuthorizeSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model AuthorizeSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AuthorizeSecurityGroupResponseBody(name='body'),
}

async function authorizeSecurityGroup(request: AuthorizeSecurityGroupRequest): AuthorizeSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AuthorizeSecurityGroup', 'POST', '/', 'json', false, 'json', request);
}

model AuthorizeSecurityGroupEgressRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  destCidrIp?: string(name='DestCidrIp', position='Query'),
  destGroupId?: string(name='DestGroupId', position='Query'),
  destGroupOwnerAccount?: string(name='DestGroupOwnerAccount', position='Query'),
  destGroupOwnerId?: long(name='DestGroupOwnerId', position='Query'),
  destPrefixListId?: string(name='DestPrefixListId', position='Query'),
  ipProtocol?: string(name='IpProtocol', position='Query'),
  ipv6DestCidrIp?: string(name='Ipv6DestCidrIp', position='Query'),
  ipv6SourceCidrIp?: string(name='Ipv6SourceCidrIp', position='Query'),
  nicType?: string(name='NicType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  permissions?: [ 
    {
      description?: string(name='Description'),
      destCidrIp?: string(name='DestCidrIp'),
      destGroupId?: string(name='DestGroupId'),
      destGroupOwnerAccount?: string(name='DestGroupOwnerAccount'),
      destGroupOwnerId?: long(name='DestGroupOwnerId'),
      destPrefixListId?: string(name='DestPrefixListId'),
      ipProtocol?: string(name='IpProtocol'),
      ipv6DestCidrIp?: string(name='Ipv6DestCidrIp'),
      ipv6SourceCidrIp?: string(name='Ipv6SourceCidrIp'),
      nicType?: string(name='NicType'),
      policy?: string(name='Policy'),
      portRange?: string(name='PortRange'),
      priority?: string(name='Priority'),
      sourceCidrIp?: string(name='SourceCidrIp'),
      sourcePortRange?: string(name='SourcePortRange'),
    }
  ](name='Permissions', position='Query'),
  policy?: string(name='Policy', position='Query'),
  portRange?: string(name='PortRange', position='Query'),
  priority?: string(name='Priority', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId: string(name='SecurityGroupId', position='Query'),
  sourceCidrIp?: string(name='SourceCidrIp', position='Query'),
  sourcePortRange?: string(name='SourcePortRange', position='Query'),
}

model AuthorizeSecurityGroupEgressResponseBody = {
  requestId?: string(name='RequestId'),
}

model AuthorizeSecurityGroupEgressResponse = {
  headers: map[string]string(name='headers'),
  body: AuthorizeSecurityGroupEgressResponseBody(name='body'),
}

async function authorizeSecurityGroupEgress(request: AuthorizeSecurityGroupEgressRequest): AuthorizeSecurityGroupEgressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AuthorizeSecurityGroupEgress', 'POST', '/', 'json', false, 'json', request);
}

model CancelAutoSnapshotPolicyRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  diskIds: string(name='diskIds', position='Query'),
  regionId: string(name='regionId', position='Query'),
}

model CancelAutoSnapshotPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelAutoSnapshotPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: CancelAutoSnapshotPolicyResponseBody(name='body'),
}

async function cancelAutoSnapshotPolicy(request: CancelAutoSnapshotPolicyRequest): CancelAutoSnapshotPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelAutoSnapshotPolicy', 'POST', '/', 'json', false, 'json', request);
}

model CancelCopyImageRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  imageId: string(name='ImageId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CancelCopyImageResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelCopyImageResponse = {
  headers: map[string]string(name='headers'),
  body: CancelCopyImageResponseBody(name='body'),
}

async function cancelCopyImage(request: CancelCopyImageRequest): CancelCopyImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelCopyImage', 'POST', '/', 'json', false, 'json', request);
}

model CancelImagePipelineExecutionRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  executionId: string(name='ExecutionId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  templateTag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='TemplateTag', position='Query'),
}

model CancelImagePipelineExecutionResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelImagePipelineExecutionResponse = {
  headers: map[string]string(name='headers'),
  body: CancelImagePipelineExecutionResponseBody(name='body'),
}

async function cancelImagePipelineExecution(request: CancelImagePipelineExecutionRequest): CancelImagePipelineExecutionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelImagePipelineExecution', 'POST', '/', 'json', false, 'json', request);
}

model CancelPhysicalConnectionRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  physicalConnectionId: string(name='PhysicalConnectionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
}

model CancelPhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: CancelPhysicalConnectionResponseBody(name='body'),
}

async function cancelPhysicalConnection(request: CancelPhysicalConnectionRequest): CancelPhysicalConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelPhysicalConnection', 'POST', '/', 'json', false, 'json', request);
}

model CancelSimulatedSystemEventsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  eventId: [ string ](name='EventId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CancelSimulatedSystemEventsResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelSimulatedSystemEventsResponse = {
  headers: map[string]string(name='headers'),
  body: CancelSimulatedSystemEventsResponseBody(name='body'),
}

async function cancelSimulatedSystemEvents(request: CancelSimulatedSystemEventsRequest): CancelSimulatedSystemEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelSimulatedSystemEvents', 'POST', '/', 'json', false, 'json', request);
}

model CancelTaskRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  taskId: string(name='TaskId', position='Query'),
}

model CancelTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CancelTaskResponseBody(name='body'),
}

async function cancelTask(request: CancelTaskRequest): CancelTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelTask', 'POST', '/', 'json', false, 'json', request);
}

model ConnectRouterInterfaceRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routerInterfaceId: string(name='RouterInterfaceId', position='Query'),
}

model ConnectRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConnectRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: ConnectRouterInterfaceResponseBody(name='body'),
}

async function connectRouterInterface(request: ConnectRouterInterfaceRequest): ConnectRouterInterfaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConnectRouterInterface', 'POST', '/', 'json', false, 'json', request);
}

model ConvertNatPublicIpToEipRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ConvertNatPublicIpToEipResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConvertNatPublicIpToEipResponse = {
  headers: map[string]string(name='headers'),
  body: ConvertNatPublicIpToEipResponseBody(name='body'),
}

async function convertNatPublicIpToEip(request: ConvertNatPublicIpToEipRequest): ConvertNatPublicIpToEipResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConvertNatPublicIpToEip', 'POST', '/', 'json', false, 'json', request);
}

model CopyImageRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  destinationDescription?: string(name='DestinationDescription', position='Query'),
  destinationImageName?: string(name='DestinationImageName', position='Query'),
  destinationRegionId?: string(name='DestinationRegionId', position='Query'),
  encryptAlgorithm?: string(name='EncryptAlgorithm', position='Query'),
  encrypted?: boolean(name='Encrypted', position='Query'),
  imageId: string(name='ImageId', position='Query'),
  KMSKeyId?: string(name='KMSKeyId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model CopyImageResponseBody = {
  imageId?: string(name='ImageId'),
  requestId?: string(name='RequestId'),
}

model CopyImageResponse = {
  headers: map[string]string(name='headers'),
  body: CopyImageResponseBody(name='body'),
}

async function copyImage(request: CopyImageRequest): CopyImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CopyImage', 'POST', '/', 'json', false, 'json', request);
}

model CopySnapshotRequest {
  destinationRegionId: string(name='DestinationRegionId', position='Query'),
  destinationSnapshotDescription: string(name='DestinationSnapshotDescription', position='Query'),
  destinationSnapshotName: string(name='DestinationSnapshotName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  retentionDays?: int32(name='RetentionDays', position='Query'),
  snapshotId: string(name='SnapshotId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model CopySnapshotResponseBody = {
  requestId?: string(name='RequestId'),
  snapshotId?: string(name='SnapshotId'),
}

model CopySnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: CopySnapshotResponseBody(name='body'),
}

async function copySnapshot(request: CopySnapshotRequest): CopySnapshotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CopySnapshot', 'POST', '/', 'json', false, 'json', request);
}

model CreateActivationRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  description?: string(name='Description', position='Query'),
  instanceCount?: int32(name='InstanceCount', position='Query'),
  instanceName?: string(name='InstanceName', position='Query'),
  ipAddressRange?: string(name='IpAddressRange', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  timeToLiveInHours?: long(name='TimeToLiveInHours', position='Query'),
}

model CreateActivationResponseBody = {
  activationCode?: string(name='ActivationCode'),
  activationId?: string(name='ActivationId'),
  requestId?: string(name='RequestId'),
}

model CreateActivationResponse = {
  headers: map[string]string(name='headers'),
  body: CreateActivationResponseBody(name='body'),
}

async function createActivation(request: CreateActivationRequest): CreateActivationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateActivation', 'POST', '/', 'json', false, 'json', request);
}

model CreateAutoProvisioningGroupRequest {
  launchConfiguration?: {
    arn?: [ 
      {
        assumeRoleFor?: long(name='AssumeRoleFor'),
        roleType?: string(name='RoleType'),
        rolearn?: string(name='Rolearn'),
      }
    ](name='Arn'),
    creditSpecification?: string(name='CreditSpecification'),
    dataDisk?: [ 
      {
        category?: string(name='Category'),
        deleteWithInstance?: boolean(name='DeleteWithInstance'),
        description?: string(name='Description'),
        device?: string(name='Device'),
        diskName?: string(name='DiskName'),
        encrypted?: boolean(name='Encrypted'),
        kmsKeyId?: string(name='KmsKeyId'),
        performanceLevel?: string(name='PerformanceLevel'),
        size?: int32(name='Size'),
        snapshotId?: string(name='SnapshotId'),
      }
    ](name='DataDisk'),
    deploymentSetId?: string(name='DeploymentSetId'),
    hostName?: string(name='HostName'),
    hostNames?: [ string ](name='HostNames'),
    imageId?: string(name='ImageId'),
    instanceDescription?: string(name='InstanceDescription'),
    instanceName?: string(name='InstanceName'),
    internetChargeType?: string(name='InternetChargeType'),
    internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn'),
    internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut'),
    ioOptimized?: string(name='IoOptimized'),
    keyPairName?: string(name='KeyPairName'),
    password?: string(name='Password'),
    passwordInherit?: boolean(name='PasswordInherit'),
    ramRoleName?: string(name='RamRoleName'),
    resourceGroupId?: string(name='ResourceGroupId'),
    securityEnhancementStrategy?: string(name='SecurityEnhancementStrategy'),
    securityGroupId?: string(name='SecurityGroupId'),
    securityGroupIds?: [ string ](name='SecurityGroupIds'),
    systemDisk?: {
      encryptAlgorithm?: string(name='EncryptAlgorithm'),
      encrypted?: string(name='Encrypted'),
      KMSKeyId?: string(name='KMSKeyId'),
    }(name='SystemDisk'),
    systemDiskCategory?: string(name='SystemDiskCategory'),
    systemDiskDescription?: string(name='SystemDiskDescription'),
    systemDiskName?: string(name='SystemDiskName'),
    systemDiskPerformanceLevel?: string(name='SystemDiskPerformanceLevel'),
    systemDiskSize?: int32(name='SystemDiskSize'),
    tag?: [ 
      {
        key?: string(name='Key'),
        value?: string(name='Value'),
      }
    ](name='Tag'),
    userData?: string(name='UserData'),
  }(name='LaunchConfiguration', position='Query'),
  autoProvisioningGroupName?: string(name='AutoProvisioningGroupName', position='Query'),
  autoProvisioningGroupType?: string(name='AutoProvisioningGroupType', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dataDiskConfig?: [ 
    {
      diskCategory?: string(name='DiskCategory'),
    }
  ](name='DataDiskConfig', position='Query'),
  defaultTargetCapacityType?: string(name='DefaultTargetCapacityType', position='Query'),
  description?: string(name='Description', position='Query'),
  excessCapacityTerminationPolicy?: string(name='ExcessCapacityTerminationPolicy', position='Query'),
  hibernationOptionsConfigured?: boolean(name='HibernationOptionsConfigured', position='Query'),
  launchTemplateConfig?: [ 
    {
      instanceType?: string(name='InstanceType'),
      maxPrice?: double(name='MaxPrice'),
      priority?: int32(name='Priority'),
      vSwitchId?: string(name='VSwitchId'),
      weightedCapacity?: double(name='WeightedCapacity'),
    }
  ](name='LaunchTemplateConfig', position='Query'),
  launchTemplateId?: string(name='LaunchTemplateId', position='Query'),
  launchTemplateVersion?: string(name='LaunchTemplateVersion', position='Query'),
  maxSpotPrice?: float(name='MaxSpotPrice', position='Query'),
  minTargetCapacity?: string(name='MinTargetCapacity', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  payAsYouGoAllocationStrategy?: string(name='PayAsYouGoAllocationStrategy', position='Query'),
  payAsYouGoTargetCapacity?: string(name='PayAsYouGoTargetCapacity', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  spotAllocationStrategy?: string(name='SpotAllocationStrategy', position='Query'),
  spotInstanceInterruptionBehavior?: string(name='SpotInstanceInterruptionBehavior', position='Query'),
  spotInstancePoolsToUseCount?: int32(name='SpotInstancePoolsToUseCount', position='Query'),
  spotTargetCapacity?: string(name='SpotTargetCapacity', position='Query'),
  systemDiskConfig?: [ 
    {
      diskCategory?: string(name='DiskCategory'),
    }
  ](name='SystemDiskConfig', position='Query'),
  terminateInstances?: boolean(name='TerminateInstances', position='Query'),
  terminateInstancesWithExpiration?: boolean(name='TerminateInstancesWithExpiration', position='Query'),
  totalTargetCapacity: string(name='TotalTargetCapacity', position='Query'),
  validFrom?: string(name='ValidFrom', position='Query'),
  validUntil?: string(name='ValidUntil', position='Query'),
}

model CreateAutoProvisioningGroupResponseBody = {
  autoProvisioningGroupId?: string(name='AutoProvisioningGroupId'),
  launchResults?: {
    launchResult?: [ 
    {
      errorCode?: string(name='ErrorCode'),
      errorMsg?: string(name='ErrorMsg'),
      instanceIds?: {
        instanceId?: [ string ](name='InstanceId')
      }(name='InstanceIds'),
      instanceType?: string(name='InstanceType'),
      spotStrategy?: string(name='SpotStrategy'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='LaunchResult')
  }(name='LaunchResults'),
  requestId?: string(name='RequestId'),
}

model CreateAutoProvisioningGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAutoProvisioningGroupResponseBody(name='body'),
}

async function createAutoProvisioningGroup(request: CreateAutoProvisioningGroupRequest): CreateAutoProvisioningGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAutoProvisioningGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateAutoSnapshotPolicyRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  copiedSnapshotsRetentionDays?: int32(name='CopiedSnapshotsRetentionDays', position='Query'),
  enableCrossRegionCopy?: boolean(name='EnableCrossRegionCopy', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  targetCopyRegions?: string(name='TargetCopyRegions', position='Query'),
  autoSnapshotPolicyName?: string(name='autoSnapshotPolicyName', position='Query'),
  regionId: string(name='regionId', position='Query'),
  repeatWeekdays: string(name='repeatWeekdays', position='Query'),
  retentionDays: int32(name='retentionDays', position='Query'),
  timePoints: string(name='timePoints', position='Query'),
}

model CreateAutoSnapshotPolicyResponseBody = {
  autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId'),
  requestId?: string(name='RequestId'),
}

model CreateAutoSnapshotPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAutoSnapshotPolicyResponseBody(name='body'),
}

async function createAutoSnapshotPolicy(request: CreateAutoSnapshotPolicyRequest): CreateAutoSnapshotPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAutoSnapshotPolicy', 'POST', '/', 'json', false, 'json', request);
}

model CreateCapacityReservationRequest {
  privatePoolOptions?: {
    matchCriteria?: string(name='MatchCriteria'),
    name?: string(name='Name'),
  }(name='PrivatePoolOptions', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  endTimeType?: string(name='EndTimeType', position='Query'),
  instanceAmount: int32(name='InstanceAmount', minimum=1, position='Query'),
  instanceType: string(name='InstanceType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  platform?: string(name='Platform', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  zoneId: [ string ](name='ZoneId', position='Query'),
}

model CreateCapacityReservationResponseBody = {
  privatePoolOptionsId?: string(name='PrivatePoolOptionsId'),
  requestId?: string(name='RequestId'),
}

model CreateCapacityReservationResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCapacityReservationResponseBody(name='body'),
}

async function createCapacityReservation(request: CreateCapacityReservationRequest): CreateCapacityReservationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCapacityReservation', 'POST', '/', 'json', false, 'json', request);
}

model CreateCommandRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  commandContent: string(name='CommandContent', position='Query'),
  contentEncoding?: string(name='ContentEncoding', position='Query'),
  description?: string(name='Description', position='Query'),
  enableParameter?: boolean(name='EnableParameter', position='Query'),
  name: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  timeout?: long(name='Timeout', position='Query'),
  type: string(name='Type', position='Query'),
  workingDir?: string(name='WorkingDir', position='Query'),
}

model CreateCommandResponseBody = {
  commandId?: string(name='CommandId'),
  requestId?: string(name='RequestId'),
}

model CreateCommandResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCommandResponseBody(name='body'),
}

async function createCommand(request: CreateCommandRequest): CreateCommandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCommand', 'POST', '/', 'json', false, 'json', request);
}

model CreateDedicatedBlockStorageClusterRequest {
  capacity: int32(name='Capacity', minimum=60, maximum=2304, position='Query'),
  category: string(name='Category', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dedicatedBlockStorageClusterName?: string(name='DedicatedBlockStorageClusterName', position='Query'),
  description?: string(name='Description', position='Query'),
  fromApp?: string(name='FromApp', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  type?: string(name='Type', position='Query'),
  zoneId: string(name='ZoneId', position='Query'),
}

model CreateDedicatedBlockStorageClusterResponseBody = {
  dedicatedBlockStorageClusterId?: string(name='DedicatedBlockStorageClusterId'),
  dedicatedBlockStorageClusterOrderId?: string(name='DedicatedBlockStorageClusterOrderId'),
  requestId?: string(name='RequestId'),
}

model CreateDedicatedBlockStorageClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDedicatedBlockStorageClusterResponseBody(name='body'),
}

async function createDedicatedBlockStorageCluster(request: CreateDedicatedBlockStorageClusterRequest): CreateDedicatedBlockStorageClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDedicatedBlockStorageCluster', 'POST', '/', 'json', false, 'json', request);
}

model CreateDedicatedHostClusterRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  dedicatedHostClusterName?: string(name='DedicatedHostClusterName', position='Query'),
  description?: string(name='Description', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model CreateDedicatedHostClusterResponseBody = {
  dedicatedHostClusterId?: string(name='DedicatedHostClusterId'),
  requestId?: string(name='RequestId'),
}

model CreateDedicatedHostClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDedicatedHostClusterResponseBody(name='body'),
}

async function createDedicatedHostCluster(request: CreateDedicatedHostClusterRequest): CreateDedicatedHostClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDedicatedHostCluster', 'POST', '/', 'json', false, 'json', request);
}

model CreateDemandRequest {
  amount: int32(name='Amount', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  demandDescription?: string(name='DemandDescription', position='Query'),
  demandName?: string(name='DemandName', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  instanceType: string(name='InstanceType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period: int32(name='Period', position='Query'),
  periodUnit: string(name='PeriodUnit', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
  zoneId: string(name='ZoneId', position='Query'),
}

model CreateDemandResponseBody = {
  demandId?: string(name='DemandId'),
  requestId?: string(name='RequestId'),
}

model CreateDemandResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDemandResponseBody(name='body'),
}

async function createDemand(request: CreateDemandRequest): CreateDemandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDemand', 'POST', '/', 'json', false, 'json', request);
}

model CreateDeploymentSetRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  deploymentSetName?: string(name='DeploymentSetName', position='Query'),
  description?: string(name='Description', position='Query'),
  domain?: string(name='Domain', position='Query'),
  granularity?: string(name='Granularity', position='Query'),
  groupCount?: long(name='GroupCount', position='Query'),
  onUnableToRedeployFailedInstance?: string(name='OnUnableToRedeployFailedInstance', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  strategy?: string(name='Strategy', position='Query'),
}

model CreateDeploymentSetResponseBody = {
  deploymentSetId?: string(name='DeploymentSetId'),
  requestId?: string(name='RequestId'),
}

model CreateDeploymentSetResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDeploymentSetResponseBody(name='body'),
}

async function createDeploymentSet(request: CreateDeploymentSetRequest): CreateDeploymentSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDeploymentSet', 'POST', '/', 'json', false, 'json', request);
}

model CreateDiagnosticMetricSetRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  description?: string(name='Description', maxLength=255, position='Query'),
  metricIds: [ string ](name='MetricIds', position='Query'),
  metricSetName?: string(name='MetricSetName', maxLength=128, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
}

model CreateDiagnosticMetricSetResponseBody = {
  metricSetId?: string(name='MetricSetId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateDiagnosticMetricSetResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDiagnosticMetricSetResponseBody(name='body'),
}

async function createDiagnosticMetricSet(request: CreateDiagnosticMetricSetRequest): CreateDiagnosticMetricSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDiagnosticMetricSet', 'POST', '/', 'json', false, 'json', request);
}

model CreateDiagnosticReportRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  endTime?: string(name='EndTime', description='GuestOS', position='Query'),
  metricSetId?: string(name='MetricSetId', description='IDEcsInstance', position='Query'),
  regionId: string(name='RegionId', description='', position='Query'),
  resourceId: string(name='ResourceId', description='IDi-bp1io7xxxutup5l2y4vt', position='Query'),
  startTime?: string(name='StartTime', description='GuestOS', position='Query'),
}

model CreateDiagnosticReportResponseBody = {
  reportId?: string(name='ReportId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateDiagnosticReportResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDiagnosticReportResponseBody(name='body'),
}

async function createDiagnosticReport(request: CreateDiagnosticReportRequest): CreateDiagnosticReportResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDiagnosticReport', 'POST', '/', 'json', false, 'json', request);
}

model CreateDiskRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  advancedFeatures?: string(name='AdvancedFeatures', position='Query'),
  arn?: [ 
    {
      assumeRoleFor?: long(name='AssumeRoleFor'),
      roleType?: string(name='RoleType'),
      rolearn?: string(name='Rolearn'),
    }
  ](name='Arn', position='Query'),
  burstingEnabled?: boolean(name='BurstingEnabled', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  diskCategory?: string(name='DiskCategory', position='Query'),
  diskName?: string(name='DiskName', position='Query'),
  encryptAlgorithm?: string(name='EncryptAlgorithm', position='Query'),
  encrypted?: boolean(name='Encrypted', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  KMSKeyId?: string(name='KMSKeyId', position='Query'),
  multiAttach?: string(name='MultiAttach', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  performanceLevel?: string(name='PerformanceLevel', position='Query'),
  provisionedIops?: long(name='ProvisionedIops', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  size?: int32(name='Size', minimum=5, maximum=32768, position='Query'),
  snapshotId?: string(name='SnapshotId', position='Query'),
  storageClusterId?: string(name='StorageClusterId', position='Query'),
  storageSetId?: string(name='StorageSetId', position='Query'),
  storageSetPartitionNumber?: int32(name='StorageSetPartitionNumber', minimum=1, position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model CreateDiskResponseBody = {
  diskId?: string(name='DiskId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateDiskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDiskResponseBody(name='body'),
}

async function createDisk(request: CreateDiskRequest): CreateDiskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDisk', 'POST', '/', 'json', false, 'json', request);
}

model CreateElasticityAssuranceRequest {
  privatePoolOptions?: {
    matchCriteria?: string(name='MatchCriteria'),
    name?: string(name='Name'),
  }(name='PrivatePoolOptions', position='Query'),
  assuranceTimes?: string(name='AssuranceTimes', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  instanceAmount?: int32(name='InstanceAmount', minimum=1, position='Query'),
  instanceCpuCoreCount?: int32(name='InstanceCpuCoreCount', minimum=1, position='Query'),
  instanceType: [ string ](name='InstanceType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  zoneId: [ string ](name='ZoneId', position='Query'),
}

model CreateElasticityAssuranceResponseBody = {
  orderId?: string(name='OrderId'),
  privatePoolOptionsId?: string(name='PrivatePoolOptionsId'),
  requestId?: string(name='RequestId'),
}

model CreateElasticityAssuranceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateElasticityAssuranceResponseBody(name='body'),
}

async function createElasticityAssurance(request: CreateElasticityAssuranceRequest): CreateElasticityAssuranceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateElasticityAssurance', 'POST', '/', 'json', false, 'json', request);
}

model CreateForwardEntryRequest {
  externalIp: string(name='ExternalIp', position='Query'),
  externalPort: string(name='ExternalPort', position='Query'),
  forwardTableId: string(name='ForwardTableId', position='Query'),
  internalIp: string(name='InternalIp', position='Query'),
  internalPort: string(name='InternalPort', position='Query'),
  ipProtocol: string(name='IpProtocol', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateForwardEntryResponseBody = {
  forwardEntryId?: string(name='ForwardEntryId'),
  requestId?: string(name='RequestId'),
}

model CreateForwardEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateForwardEntryResponseBody(name='body'),
}

async function createForwardEntry(request: CreateForwardEntryRequest): CreateForwardEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateForwardEntry', 'POST', '/', 'json', false, 'json', request);
}

model CreateHaVipRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  ipAddress?: string(name='IpAddress', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vSwitchId: string(name='VSwitchId', position='Query'),
}

model CreateHaVipResponseBody = {
  haVipId?: string(name='HaVipId'),
  requestId?: string(name='RequestId'),
}

model CreateHaVipResponse = {
  headers: map[string]string(name='headers'),
  body: CreateHaVipResponseBody(name='body'),
}

async function createHaVip(request: CreateHaVipRequest): CreateHaVipResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateHaVip', 'POST', '/', 'json', false, 'json', request);
}

model CreateHpcClusterRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  name: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateHpcClusterResponseBody = {
  hpcClusterId?: string(name='HpcClusterId'),
  requestId?: string(name='RequestId'),
}

model CreateHpcClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateHpcClusterResponseBody(name='body'),
}

async function createHpcCluster(request: CreateHpcClusterRequest): CreateHpcClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateHpcCluster', 'POST', '/', 'json', false, 'json', request);
}

model CreateImageRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  architecture?: string(name='Architecture', position='Query'),
  bootMode?: string(name='BootMode', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  diskDeviceMapping?: [ 
    {
      device?: string(name='Device'),
      diskType?: string(name='DiskType'),
      size?: int32(name='Size'),
      snapshotId?: string(name='SnapshotId'),
    }
  ](name='DiskDeviceMapping', position='Query'),
  imageFamily?: string(name='ImageFamily', position='Query'),
  imageName?: string(name='ImageName', position='Query'),
  imageVersion?: string(name='ImageVersion', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  platform?: string(name='Platform', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  snapshotId?: string(name='SnapshotId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model CreateImageResponseBody = {
  imageId?: string(name='ImageId'),
  requestId?: string(name='RequestId'),
}

model CreateImageResponse = {
  headers: map[string]string(name='headers'),
  body: CreateImageResponseBody(name='body'),
}

async function createImage(request: CreateImageRequest): CreateImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateImage', 'POST', '/', 'json', false, 'json', request);
}

model CreateImageComponentRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  componentType?: string(name='ComponentType', position='Query'),
  content?: string(name='Content', position='Query'),
  description?: string(name='Description', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  systemType?: string(name='SystemType', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model CreateImageComponentResponseBody = {
  imageComponentId?: string(name='ImageComponentId'),
  requestId?: string(name='RequestId'),
}

model CreateImageComponentResponse = {
  headers: map[string]string(name='headers'),
  body: CreateImageComponentResponseBody(name='body'),
}

async function createImageComponent(request: CreateImageComponentRequest): CreateImageComponentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateImageComponent', 'POST', '/', 'json', false, 'json', request);
}

model CreateImagePipelineRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  addAccount?: [ long ](name='AddAccount', position='Query'),
  baseImage: string(name='BaseImage', position='Query'),
  baseImageType: string(name='BaseImageType', position='Query'),
  buildContent?: string(name='BuildContent', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  deleteInstanceOnFailure?: boolean(name='DeleteInstanceOnFailure', position='Query'),
  description?: string(name='Description', position='Query'),
  imageName?: string(name='ImageName', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  systemDiskSize?: int32(name='SystemDiskSize', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  toRegionId?: [ string ](name='ToRegionId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
}

model CreateImagePipelineResponseBody = {
  imagePipelineId?: string(name='ImagePipelineId'),
  requestId?: string(name='RequestId'),
}

model CreateImagePipelineResponse = {
  headers: map[string]string(name='headers'),
  body: CreateImagePipelineResponseBody(name='body'),
}

async function createImagePipeline(request: CreateImagePipelineRequest): CreateImagePipelineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateImagePipeline', 'POST', '/', 'json', false, 'json', request);
}

model CreateInstanceRequest {
  hibernationOptions?: {
    configured?: boolean(name='Configured'),
  }(name='HibernationOptions', position='Query'),
  privatePoolOptions?: {
    id?: string(name='Id'),
    matchCriteria?: string(name='MatchCriteria'),
  }(name='PrivatePoolOptions', position='Query'),
  systemDisk?: {
    category?: string(name='Category'),
    description?: string(name='Description'),
    diskName?: string(name='DiskName'),
    performanceLevel?: string(name='PerformanceLevel'),
    size?: int32(name='Size'),
    storageClusterId?: string(name='StorageClusterId'),
  }(name='SystemDisk', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  affinity?: string(name='Affinity', position='Query'),
  arn?: [ 
    {
      assumeRoleFor?: long(name='AssumeRoleFor'),
      roleType?: string(name='RoleType'),
      rolearn?: string(name='Rolearn'),
    }
  ](name='Arn', position='Query'),
  autoRenew?: boolean(name='AutoRenew', position='Query'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  creditSpecification?: string(name='CreditSpecification', position='Query'),
  dataDisk?: [ 
    {
      category?: string(name='Category'),
      deleteWithInstance?: boolean(name='DeleteWithInstance'),
      description?: string(name='Description'),
      device?: string(name='Device'),
      diskName?: string(name='DiskName'),
      encryptAlgorithm?: string(name='EncryptAlgorithm'),
      encrypted?: boolean(name='Encrypted'),
      KMSKeyId?: string(name='KMSKeyId'),
      performanceLevel?: string(name='PerformanceLevel'),
      size?: int32(name='Size'),
      snapshotId?: string(name='SnapshotId'),
      storageClusterId?: string(name='StorageClusterId'),
    }
  ](name='DataDisk', position='Query'),
  dedicatedHostId?: string(name='DedicatedHostId', position='Query'),
  deletionProtection?: boolean(name='DeletionProtection', position='Query'),
  deploymentSetGroupNo?: int32(name='DeploymentSetGroupNo', position='Query'),
  deploymentSetId?: string(name='DeploymentSetId', position='Query'),
  description?: string(name='Description', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  hostName?: string(name='HostName', position='Query'),
  hpcClusterId?: string(name='HpcClusterId', position='Query'),
  httpEndpoint?: string(name='HttpEndpoint', position='Query'),
  httpPutResponseHopLimit?: int32(name='HttpPutResponseHopLimit', position='Query'),
  httpTokens?: string(name='HttpTokens', position='Query'),
  imageFamily?: string(name='ImageFamily', position='Query'),
  imageId?: string(name='ImageId', position='Query'),
  innerIpAddress?: string(name='InnerIpAddress', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  instanceName?: string(name='InstanceName', position='Query'),
  instanceType: string(name='InstanceType', position='Query'),
  internetChargeType?: string(name='InternetChargeType', position='Query'),
  internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn', minimum=1, maximum=200, position='Query'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', position='Query'),
  ioOptimized?: string(name='IoOptimized', position='Query'),
  keyPairName?: string(name='KeyPairName', position='Query'),
  nodeControllerId?: string(name='NodeControllerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  password?: string(name='Password', position='Query'),
  passwordInherit?: boolean(name='PasswordInherit', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', position='Query'),
  ramRoleName?: string(name='RamRoleName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityEnhancementStrategy?: string(name='SecurityEnhancementStrategy', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', position='Query'),
  spotDuration?: int32(name='SpotDuration', minimum=0, maximum=6, position='Query'),
  spotInterruptionBehavior?: string(name='SpotInterruptionBehavior', position='Query'),
  spotPriceLimit?: float(name='SpotPriceLimit', position='Query'),
  spotStrategy?: string(name='SpotStrategy', position='Query'),
  storageSetId?: string(name='StorageSetId', position='Query'),
  storageSetPartitionNumber?: int32(name='StorageSetPartitionNumber', minimum=1, position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  tenancy?: string(name='Tenancy', position='Query'),
  useAdditionalService?: boolean(name='UseAdditionalService', position='Query'),
  userData?: string(name='UserData', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vlanId?: string(name='VlanId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model CreateInstanceResponseBody = {
  instanceId?: string(name='InstanceId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
  tradePrice?: float(name='TradePrice'),
}

model CreateInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateInstanceResponseBody(name='body'),
}

async function createInstance(request: CreateInstanceRequest): CreateInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateInstance', 'POST', '/', 'json', false, 'json', request);
}

model CreateKeyPairRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  keyPairName: string(name='KeyPairName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model CreateKeyPairResponseBody = {
  keyPairFingerPrint?: string(name='KeyPairFingerPrint'),
  keyPairId?: string(name='KeyPairId'),
  keyPairName?: string(name='KeyPairName'),
  privateKeyBody?: string(name='PrivateKeyBody'),
  requestId?: string(name='RequestId'),
}

model CreateKeyPairResponse = {
  headers: map[string]string(name='headers'),
  body: CreateKeyPairResponseBody(name='body'),
}

async function createKeyPair(request: CreateKeyPairRequest): CreateKeyPairResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateKeyPair', 'POST', '/', 'json', false, 'json', request);
}

model CreateLaunchTemplateRequest {
  systemDisk?: {
    autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId'),
    burstingEnabled?: boolean(name='BurstingEnabled'),
    category?: string(name='Category'),
    deleteWithInstance?: boolean(name='DeleteWithInstance'),
    description?: string(name='Description'),
    diskName?: string(name='DiskName'),
    iops?: int32(name='Iops'),
    performanceLevel?: string(name='PerformanceLevel'),
    provisionedIops?: long(name='ProvisionedIops'),
    size?: int32(name='Size'),
  }(name='SystemDisk', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  autoReleaseTime?: string(name='AutoReleaseTime', position='Query'),
  dataDisk?: [ 
    {
      autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId'),
      burstingEnabled?: boolean(name='BurstingEnabled'),
      category?: string(name='Category'),
      deleteWithInstance?: boolean(name='DeleteWithInstance'),
      description?: string(name='Description'),
      device?: string(name='Device'),
      diskName?: string(name='DiskName'),
      encrypted?: string(name='Encrypted'),
      performanceLevel?: string(name='PerformanceLevel'),
      provisionedIops?: long(name='ProvisionedIops'),
      size?: int32(name='Size'),
      snapshotId?: string(name='SnapshotId'),
    }
  ](name='DataDisk', position='Query'),
  deploymentSetId?: string(name='DeploymentSetId', position='Query'),
  description?: string(name='Description', position='Query'),
  enableVmOsConfig?: boolean(name='EnableVmOsConfig', position='Query'),
  hostName?: string(name='HostName', position='Query'),
  imageId?: string(name='ImageId', position='Query'),
  imageOwnerAlias?: string(name='ImageOwnerAlias', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  instanceName?: string(name='InstanceName', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  internetChargeType?: string(name='InternetChargeType', position='Query'),
  internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn', position='Query'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', position='Query'),
  ioOptimized?: string(name='IoOptimized', position='Query'),
  ipv6AddressCount?: int32(name='Ipv6AddressCount', position='Query'),
  keyPairName?: string(name='KeyPairName', position='Query'),
  launchTemplateName: string(name='LaunchTemplateName', position='Query'),
  networkInterface?: [ 
    {
      description?: string(name='Description'),
      instanceType?: string(name='InstanceType'),
      networkInterfaceName?: string(name='NetworkInterfaceName'),
      networkInterfaceTrafficMode?: string(name='NetworkInterfaceTrafficMode'),
      primaryIpAddress?: string(name='PrimaryIpAddress'),
      securityGroupId?: string(name='SecurityGroupId'),
      securityGroupIds?: [ string ](name='SecurityGroupIds'),
      vSwitchId?: string(name='VSwitchId'),
    }
  ](name='NetworkInterface', position='Query'),
  networkType?: string(name='NetworkType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  passwordInherit?: boolean(name='PasswordInherit', position='Query'),
  period?: int32(name='Period', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', position='Query'),
  ramRoleName?: string(name='RamRoleName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityEnhancementStrategy?: string(name='SecurityEnhancementStrategy', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', position='Query'),
  securityGroupIds?: [ string ](name='SecurityGroupIds', position='Query'),
  spotDuration?: int32(name='SpotDuration', position='Query'),
  spotPriceLimit?: float(name='SpotPriceLimit', minimum=0, maximum=999999, position='Query'),
  spotStrategy?: string(name='SpotStrategy', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  templateResourceGroupId?: string(name='TemplateResourceGroupId', position='Query'),
  templateTag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='TemplateTag', position='Query'),
  userData?: string(name='UserData', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  versionDescription?: string(name='VersionDescription', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model CreateLaunchTemplateResponseBody = {
  launchTemplateId?: string(name='LaunchTemplateId'),
  requestId?: string(name='RequestId'),
}

model CreateLaunchTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLaunchTemplateResponseBody(name='body'),
}

async function createLaunchTemplate(request: CreateLaunchTemplateRequest): CreateLaunchTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLaunchTemplate', 'POST', '/', 'json', false, 'json', request);
}

model CreateLaunchTemplateVersionRequest {
  systemDisk?: {
    autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId'),
    burstingEnabled?: boolean(name='BurstingEnabled'),
    category?: string(name='Category'),
    deleteWithInstance?: boolean(name='DeleteWithInstance'),
    description?: string(name='Description'),
    diskName?: string(name='DiskName'),
    iops?: int32(name='Iops'),
    performanceLevel?: string(name='PerformanceLevel'),
    provisionedIops?: long(name='ProvisionedIops'),
    size?: int32(name='Size'),
  }(name='SystemDisk', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  autoReleaseTime?: string(name='AutoReleaseTime', position='Query'),
  dataDisk?: [ 
    {
      autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId'),
      burstingEnabled?: boolean(name='BurstingEnabled'),
      category?: string(name='Category'),
      deleteWithInstance?: boolean(name='DeleteWithInstance'),
      description?: string(name='Description'),
      device?: string(name='Device'),
      diskName?: string(name='DiskName'),
      encrypted?: string(name='Encrypted'),
      performanceLevel?: string(name='PerformanceLevel'),
      provisionedIops?: long(name='ProvisionedIops'),
      size?: int32(name='Size'),
      snapshotId?: string(name='SnapshotId'),
    }
  ](name='DataDisk', position='Query'),
  deploymentSetId?: string(name='DeploymentSetId', position='Query'),
  description?: string(name='Description', position='Query'),
  enableVmOsConfig?: boolean(name='EnableVmOsConfig', position='Query'),
  hostName?: string(name='HostName', position='Query'),
  imageId?: string(name='ImageId', position='Query'),
  imageOwnerAlias?: string(name='ImageOwnerAlias', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  instanceName?: string(name='InstanceName', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  internetChargeType?: string(name='InternetChargeType', position='Query'),
  internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn', position='Query'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', position='Query'),
  ioOptimized?: string(name='IoOptimized', position='Query'),
  ipv6AddressCount?: int32(name='Ipv6AddressCount', position='Query'),
  keyPairName?: string(name='KeyPairName', position='Query'),
  launchTemplateId?: string(name='LaunchTemplateId', position='Query'),
  launchTemplateName?: string(name='LaunchTemplateName', position='Query'),
  networkInterface?: [ 
    {
      description?: string(name='Description'),
      instanceType?: string(name='InstanceType'),
      networkInterfaceName?: string(name='NetworkInterfaceName'),
      networkInterfaceTrafficMode?: string(name='NetworkInterfaceTrafficMode'),
      primaryIpAddress?: string(name='PrimaryIpAddress'),
      securityGroupId?: string(name='SecurityGroupId'),
      securityGroupIds?: [ string ](name='SecurityGroupIds'),
      vSwitchId?: string(name='VSwitchId'),
    }
  ](name='NetworkInterface', position='Query'),
  networkType?: string(name='NetworkType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  passwordInherit?: boolean(name='PasswordInherit', position='Query'),
  period?: int32(name='Period', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', position='Query'),
  ramRoleName?: string(name='RamRoleName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityEnhancementStrategy?: string(name='SecurityEnhancementStrategy', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', position='Query'),
  securityGroupIds?: [ string ](name='SecurityGroupIds', position='Query'),
  spotDuration?: int32(name='SpotDuration', position='Query'),
  spotPriceLimit?: float(name='SpotPriceLimit', minimum=0, maximum=999999, position='Query'),
  spotStrategy?: string(name='SpotStrategy', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  userData?: string(name='UserData', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  versionDescription?: string(name='VersionDescription', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model CreateLaunchTemplateVersionResponseBody = {
  launchTemplateVersionNumber?: long(name='LaunchTemplateVersionNumber'),
  requestId?: string(name='RequestId'),
}

model CreateLaunchTemplateVersionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLaunchTemplateVersionResponseBody(name='body'),
}

async function createLaunchTemplateVersion(request: CreateLaunchTemplateVersionRequest): CreateLaunchTemplateVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLaunchTemplateVersion', 'POST', '/', 'json', false, 'json', request);
}

model CreateNatGatewayRequest {
  bandwidthPackage: [ 
    {
      bandwidth?: int32(name='Bandwidth'),
      ipCount?: int32(name='IpCount'),
      zone?: string(name='Zone'),
    }
  ](name='BandwidthPackage', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
}

model CreateNatGatewayResponseBody = {
  bandwidthPackageIds?: {
    bandwidthPackageId?: [ string ](name='BandwidthPackageId')
  }(name='BandwidthPackageIds'),
  forwardTableIds?: {
    forwardTableId?: [ string ](name='ForwardTableId')
  }(name='ForwardTableIds'),
  natGatewayId?: string(name='NatGatewayId'),
  requestId?: string(name='RequestId'),
}

model CreateNatGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNatGatewayResponseBody(name='body'),
}

async function createNatGateway(request: CreateNatGatewayRequest): CreateNatGatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateNatGateway', 'POST', '/', 'json', false, 'json', request);
}

model CreateNetworkInterfaceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  businessType?: string(name='BusinessType', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  ipv6Address?: [ string ](name='Ipv6Address', position='Query'),
  ipv6AddressCount?: int32(name='Ipv6AddressCount', minimum=1, position='Query'),
  networkInterfaceName?: string(name='NetworkInterfaceName', position='Query'),
  networkInterfaceTrafficMode?: string(name='NetworkInterfaceTrafficMode', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  primaryIpAddress?: string(name='PrimaryIpAddress', position='Query'),
  privateIpAddress?: [ string ](name='PrivateIpAddress', position='Query'),
  queueNumber?: int32(name='QueueNumber', minimum=1, position='Query'),
  queuePairNumber?: int32(name='QueuePairNumber', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  secondaryPrivateIpAddressCount?: int32(name='SecondaryPrivateIpAddressCount', minimum=1, position='Query'),
  securityGroupId?: string(name='SecurityGroupId', position='Query'),
  securityGroupIds?: [ string ](name='SecurityGroupIds', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  vSwitchId: string(name='VSwitchId', position='Query'),
  visible?: boolean(name='Visible', position='Query'),
}

model CreateNetworkInterfaceResponseBody = {
  description?: string(name='Description'),
  ipv6Sets?: {
    ipv6Set?: [ 
    {
      ipv6Address?: string(name='Ipv6Address'),
    }
  ](name='Ipv6Set')
  }(name='Ipv6Sets'),
  macAddress?: string(name='MacAddress'),
  networkInterfaceId?: string(name='NetworkInterfaceId'),
  networkInterfaceName?: string(name='NetworkInterfaceName'),
  ownerId?: string(name='OwnerId'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  privateIpSets?: {
    privateIpSet?: [ 
    {
      primary?: boolean(name='Primary'),
      privateIpAddress?: string(name='PrivateIpAddress'),
    }
  ](name='PrivateIpSet')
  }(name='PrivateIpSets'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  securityGroupIds?: {
    securityGroupId?: [ string ](name='SecurityGroupId')
  }(name='SecurityGroupIds'),
  serviceID?: long(name='ServiceID'),
  serviceManaged?: boolean(name='ServiceManaged'),
  status?: string(name='Status'),
  tags?: {
    tag?: [ 
    {
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='Tag')
  }(name='Tags'),
  type?: string(name='Type'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model CreateNetworkInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNetworkInterfaceResponseBody(name='body'),
}

async function createNetworkInterface(request: CreateNetworkInterfaceRequest): CreateNetworkInterfaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateNetworkInterface', 'POST', '/', 'json', false, 'json', request);
}

model CreateNetworkInterfacePermissionRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  accountId: long(name='AccountId', position='Query'),
  networkInterfaceId: string(name='NetworkInterfaceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  permission: string(name='Permission', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateNetworkInterfacePermissionResponseBody = {
  networkInterfacePermission?: {
    accountId?: long(name='AccountId'),
    networkInterfaceId?: string(name='NetworkInterfaceId'),
    networkInterfacePermissionId?: string(name='NetworkInterfacePermissionId'),
    permission?: string(name='Permission'),
    permissionState?: string(name='PermissionState'),
    serviceName?: string(name='ServiceName'),
  }(name='NetworkInterfacePermission'),
  requestId?: string(name='RequestId'),
}

model CreateNetworkInterfacePermissionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNetworkInterfacePermissionResponseBody(name='body'),
}

async function createNetworkInterfacePermission(request: CreateNetworkInterfacePermissionRequest): CreateNetworkInterfacePermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateNetworkInterfacePermission', 'POST', '/', 'json', false, 'json', request);
}

model CreatePhysicalConnectionRequest {
  accessPointId: string(name='AccessPointId', position='Query'),
  circuitCode?: string(name='CircuitCode', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  lineOperator: string(name='LineOperator', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  peerLocation: string(name='PeerLocation', position='Query'),
  portType?: string(name='PortType', position='Query'),
  redundantPhysicalConnectionId?: string(name='RedundantPhysicalConnectionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  type?: string(name='Type', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
  bandwidth?: int32(name='bandwidth', position='Query'),
}

model CreatePhysicalConnectionResponseBody = {
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  requestId?: string(name='RequestId'),
}

model CreatePhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePhysicalConnectionResponseBody(name='body'),
}

async function createPhysicalConnection(request: CreatePhysicalConnectionRequest): CreatePhysicalConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreatePhysicalConnection', 'POST', '/', 'json', false, 'json', request);
}

model CreatePrefixListRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  addressFamily: string(name='AddressFamily', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  entry?: [ 
    {
      cidr: string(name='Cidr'),
      description?: string(name='Description'),
    }
  ](name='Entry', position='Query'),
  maxEntries: int32(name='MaxEntries', minimum=1, maximum=200, position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  prefixListName: string(name='PrefixListName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreatePrefixListResponseBody = {
  prefixListId?: string(name='PrefixListId'),
  requestId?: string(name='RequestId'),
}

model CreatePrefixListResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePrefixListResponseBody(name='body'),
}

async function createPrefixList(request: CreatePrefixListRequest): CreatePrefixListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreatePrefixList', 'POST', '/', 'json', false, 'json', request);
}

model CreateRouteEntryRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  destinationCidrBlock: string(name='DestinationCidrBlock', position='Query'),
  nextHopId?: string(name='NextHopId', position='Query'),
  nextHopList?: [ 
    {
      nextHopId?: string(name='NextHopId'),
      nextHopType?: string(name='NextHopType'),
    }
  ](name='NextHopList', position='Query'),
  nextHopType?: string(name='NextHopType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeTableId: string(name='RouteTableId', position='Query'),
}

model CreateRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRouteEntryResponseBody(name='body'),
}

async function createRouteEntry(request: CreateRouteEntryRequest): CreateRouteEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRouteEntry', 'POST', '/', 'json', false, 'json', request);
}

model CreateRouterInterfaceRequest {
  accessPointId?: string(name='AccessPointId', position='Query'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  healthCheckSourceIp?: string(name='HealthCheckSourceIp', position='Query'),
  healthCheckTargetIp?: string(name='HealthCheckTargetIp', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  name?: string(name='Name', position='Query'),
  oppositeAccessPointId?: string(name='OppositeAccessPointId', position='Query'),
  oppositeInterfaceId?: string(name='OppositeInterfaceId', position='Query'),
  oppositeInterfaceOwnerId?: string(name='OppositeInterfaceOwnerId', position='Query'),
  oppositeRegionId: string(name='OppositeRegionId', position='Query'),
  oppositeRouterId?: string(name='OppositeRouterId', position='Query'),
  oppositeRouterType?: string(name='OppositeRouterType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  pricingCycle?: string(name='PricingCycle', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  role: string(name='Role', position='Query'),
  routerId: string(name='RouterId', position='Query'),
  routerType: string(name='RouterType', position='Query'),
  spec: string(name='Spec', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
}

model CreateRouterInterfaceResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
}

model CreateRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRouterInterfaceResponseBody(name='body'),
}

async function createRouterInterface(request: CreateRouterInterfaceRequest): CreateRouterInterfaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRouterInterface', 'POST', '/', 'json', false, 'json', request);
}

model CreateSecurityGroupRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupName?: string(name='SecurityGroupName', position='Query'),
  securityGroupType?: string(name='SecurityGroupType', position='Query'),
  serviceManaged?: boolean(name='ServiceManaged', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model CreateSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
  securityGroupId?: string(name='SecurityGroupId'),
}

model CreateSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSecurityGroupResponseBody(name='body'),
}

async function createSecurityGroup(request: CreateSecurityGroupRequest): CreateSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSecurityGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateSimulatedSystemEventsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  eventType: string(name='EventType', position='Query'),
  instanceId: [ string ](name='InstanceId', position='Query'),
  notBefore: string(name='NotBefore', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateSimulatedSystemEventsResponseBody = {
  eventIdSet?: {
    eventId?: [ string ](name='EventId')
  }(name='EventIdSet'),
  requestId?: string(name='RequestId'),
}

model CreateSimulatedSystemEventsResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSimulatedSystemEventsResponseBody(name='body'),
}

async function createSimulatedSystemEvents(request: CreateSimulatedSystemEventsRequest): CreateSimulatedSystemEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSimulatedSystemEvents', 'POST', '/', 'json', false, 'json', request);
}

model CreateSnapshotRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  category?: string(name='Category', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  diskId: string(name='DiskId', position='Query'),
  instantAccess?: boolean(name='InstantAccess', position='Query'),
  instantAccessRetentionDays?: int32(name='InstantAccessRetentionDays', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  retentionDays?: int32(name='RetentionDays', position='Query'),
  snapshotName?: string(name='SnapshotName', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model CreateSnapshotResponseBody = {
  requestId?: string(name='RequestId'),
  snapshotId?: string(name='SnapshotId'),
}

model CreateSnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSnapshotResponseBody(name='body'),
}

async function createSnapshot(request: CreateSnapshotRequest): CreateSnapshotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSnapshot', 'POST', '/', 'json', false, 'json', request);
}

model CreateSnapshotGroupRequest {
  description?: string(name='Description', position='Query'),
  diskId?: [ string ](name='DiskId', position='Query'),
  excludeDiskId?: [ string ](name='ExcludeDiskId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  instantAccess?: boolean(name='InstantAccess', position='Query'),
  instantAccessRetentionDays?: int32(name='InstantAccessRetentionDays', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model CreateSnapshotGroupResponseBody = {
  requestId?: string(name='RequestId'),
  snapshotGroupId?: string(name='SnapshotGroupId'),
}

model CreateSnapshotGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSnapshotGroupResponseBody(name='body'),
}

async function createSnapshotGroup(request: CreateSnapshotGroupRequest): CreateSnapshotGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSnapshotGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateStorageSetRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  maxPartitionNumber?: int32(name='MaxPartitionNumber', minimum=2, position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  storageSetName?: string(name='StorageSetName', position='Query'),
  zoneId: string(name='ZoneId', position='Query'),
}

model CreateStorageSetResponseBody = {
  requestId?: string(name='RequestId'),
  storageSetId?: string(name='StorageSetId'),
}

model CreateStorageSetResponse = {
  headers: map[string]string(name='headers'),
  body: CreateStorageSetResponseBody(name='body'),
}

async function createStorageSet(request: CreateStorageSetRequest): CreateStorageSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateStorageSet', 'POST', '/', 'json', false, 'json', request);
}

model CreateVSwitchRequest {
  cidrBlock: string(name='CidrBlock', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vSwitchName?: string(name='VSwitchName', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
  zoneId: string(name='ZoneId', position='Query'),
}

model CreateVSwitchResponseBody = {
  requestId?: string(name='RequestId'),
  vSwitchId?: string(name='VSwitchId'),
}

model CreateVSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVSwitchResponseBody(name='body'),
}

async function createVSwitch(request: CreateVSwitchRequest): CreateVSwitchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVSwitch', 'POST', '/', 'json', false, 'json', request);
}

model CreateVirtualBorderRouterRequest {
  circuitCode?: string(name='CircuitCode', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  localGatewayIp?: string(name='LocalGatewayIp', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  peerGatewayIp?: string(name='PeerGatewayIp', position='Query'),
  peeringSubnetMask?: string(name='PeeringSubnetMask', position='Query'),
  physicalConnectionId: string(name='PhysicalConnectionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
  vbrOwnerId?: long(name='VbrOwnerId', position='Query'),
  vlanId: int32(name='VlanId', position='Query'),
}

model CreateVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
  vbrId?: string(name='VbrId'),
}

model CreateVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVirtualBorderRouterResponseBody(name='body'),
}

async function createVirtualBorderRouter(request: CreateVirtualBorderRouterRequest): CreateVirtualBorderRouterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVirtualBorderRouter', 'POST', '/', 'json', false, 'json', request);
}

model CreateVpcRequest {
  cidrBlock?: string(name='CidrBlock', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
  vpcName?: string(name='VpcName', position='Query'),
}

model CreateVpcResponseBody = {
  requestId?: string(name='RequestId'),
  routeTableId?: string(name='RouteTableId'),
  vRouterId?: string(name='VRouterId'),
  vpcId?: string(name='VpcId'),
}

model CreateVpcResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpcResponseBody(name='body'),
}

async function createVpc(request: CreateVpcRequest): CreateVpcResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVpc', 'POST', '/', 'json', false, 'json', request);
}

model DeactivateRouterInterfaceRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routerInterfaceId: string(name='RouterInterfaceId', position='Query'),
}

model DeactivateRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeactivateRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeactivateRouterInterfaceResponseBody(name='body'),
}

async function deactivateRouterInterface(request: DeactivateRouterInterfaceRequest): DeactivateRouterInterfaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeactivateRouterInterface', 'POST', '/', 'json', false, 'json', request);
}

model DeleteActivationRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  activationId: string(name='ActivationId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteActivationResponseBody = {
  activation?: {
    activationId?: string(name='ActivationId'),
    creationTime?: string(name='CreationTime'),
    deregisteredCount?: int32(name='DeregisteredCount'),
    description?: string(name='Description'),
    instanceCount?: int32(name='InstanceCount'),
    instanceName?: string(name='InstanceName'),
    ipAddressRange?: string(name='IpAddressRange'),
    registeredCount?: int32(name='RegisteredCount'),
    timeToLiveInHours?: long(name='TimeToLiveInHours'),
  }(name='Activation'),
  requestId?: string(name='RequestId'),
}

model DeleteActivationResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteActivationResponseBody(name='body'),
}

async function deleteActivation(request: DeleteActivationRequest): DeleteActivationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteActivation', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAutoProvisioningGroupRequest {
  autoProvisioningGroupId: string(name='AutoProvisioningGroupId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  terminateInstances: boolean(name='TerminateInstances', position='Query'),
}

model DeleteAutoProvisioningGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAutoProvisioningGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAutoProvisioningGroupResponseBody(name='body'),
}

async function deleteAutoProvisioningGroup(request: DeleteAutoProvisioningGroupRequest): DeleteAutoProvisioningGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAutoProvisioningGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAutoSnapshotPolicyRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  autoSnapshotPolicyId: string(name='autoSnapshotPolicyId', position='Query'),
  regionId: string(name='regionId', position='Query'),
}

model DeleteAutoSnapshotPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAutoSnapshotPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAutoSnapshotPolicyResponseBody(name='body'),
}

async function deleteAutoSnapshotPolicy(request: DeleteAutoSnapshotPolicyRequest): DeleteAutoSnapshotPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAutoSnapshotPolicy', 'POST', '/', 'json', false, 'json', request);
}

model DeleteBandwidthPackageRequest {
  bandwidthPackageId: string(name='BandwidthPackageId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteBandwidthPackageResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBandwidthPackageResponseBody(name='body'),
}

async function deleteBandwidthPackage(request: DeleteBandwidthPackageRequest): DeleteBandwidthPackageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteBandwidthPackage', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCommandRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  commandId: string(name='CommandId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteCommandResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCommandResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCommandResponseBody(name='body'),
}

async function deleteCommand(request: DeleteCommandRequest): DeleteCommandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCommand', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDedicatedHostClusterRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  dedicatedHostClusterId: string(name='DedicatedHostClusterId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteDedicatedHostClusterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDedicatedHostClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDedicatedHostClusterResponseBody(name='body'),
}

async function deleteDedicatedHostCluster(request: DeleteDedicatedHostClusterRequest): DeleteDedicatedHostClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDedicatedHostCluster', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDemandRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  demandId: string(name='DemandId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  reason?: string(name='Reason', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteDemandResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDemandResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDemandResponseBody(name='body'),
}

async function deleteDemand(request: DeleteDemandRequest): DeleteDemandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDemand', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDeploymentSetRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  deploymentSetId: string(name='DeploymentSetId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteDeploymentSetResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDeploymentSetResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDeploymentSetResponseBody(name='body'),
}

async function deleteDeploymentSet(request: DeleteDeploymentSetRequest): DeleteDeploymentSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDeploymentSet', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDiagnosticMetricSetsRequest {
  metricSetIds: [ string ](name='MetricSetIds', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteDiagnosticMetricSetsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteDiagnosticMetricSetsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDiagnosticMetricSetsResponseBody(name='body'),
}

async function deleteDiagnosticMetricSets(request: DeleteDiagnosticMetricSetsRequest): DeleteDiagnosticMetricSetsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDiagnosticMetricSets', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDiagnosticReportsRequest {
  resourceOwnerId?: long(name='ResourceOwnerId', position='Host'),
  regionId: string(name='RegionId', position='Query'),
  reportIds: [ string ](name='ReportIds', position='Query'),
}

model DeleteDiagnosticReportsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteDiagnosticReportsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDiagnosticReportsResponseBody(name='body'),
}

async function deleteDiagnosticReports(request: DeleteDiagnosticReportsRequest): DeleteDiagnosticReportsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDiagnosticReports', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDiskRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  diskId: string(name='DiskId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteDiskResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDiskResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDiskResponseBody(name='body'),
}

async function deleteDisk(request: DeleteDiskRequest): DeleteDiskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDisk', 'POST', '/', 'json', false, 'json', request);
}

model DeleteForwardEntryRequest {
  forwardEntryId: string(name='ForwardEntryId', position='Query'),
  forwardTableId: string(name='ForwardTableId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteForwardEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteForwardEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteForwardEntryResponseBody(name='body'),
}

async function deleteForwardEntry(request: DeleteForwardEntryRequest): DeleteForwardEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteForwardEntry', 'POST', '/', 'json', false, 'json', request);
}

model DeleteHaVipRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  haVipId: string(name='HaVipId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteHaVipResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteHaVipResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteHaVipResponseBody(name='body'),
}

async function deleteHaVip(request: DeleteHaVipRequest): DeleteHaVipResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteHaVip', 'POST', '/', 'json', false, 'json', request);
}

model DeleteHpcClusterRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  hpcClusterId: string(name='HpcClusterId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteHpcClusterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteHpcClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteHpcClusterResponseBody(name='body'),
}

async function deleteHpcCluster(request: DeleteHpcClusterRequest): DeleteHpcClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteHpcCluster', 'POST', '/', 'json', false, 'json', request);
}

model DeleteImageRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  force?: boolean(name='Force', position='Query'),
  imageId: string(name='ImageId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteImageResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteImageResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteImageResponseBody(name='body'),
}

async function deleteImage(request: DeleteImageRequest): DeleteImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteImage', 'POST', '/', 'json', false, 'json', request);
}

model DeleteImageComponentRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  imageComponentId: string(name='ImageComponentId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteImageComponentResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteImageComponentResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteImageComponentResponseBody(name='body'),
}

async function deleteImageComponent(request: DeleteImageComponentRequest): DeleteImageComponentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteImageComponent', 'POST', '/', 'json', false, 'json', request);
}

model DeleteImagePipelineRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  imagePipelineId: string(name='ImagePipelineId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteImagePipelineResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteImagePipelineResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteImagePipelineResponseBody(name='body'),
}

async function deleteImagePipeline(request: DeleteImagePipelineRequest): DeleteImagePipelineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteImagePipeline', 'POST', '/', 'json', false, 'json', request);
}

model DeleteInstanceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  force?: boolean(name='Force', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  terminateSubscription?: boolean(name='TerminateSubscription', position='Query'),
}

model DeleteInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteInstanceResponseBody(name='body'),
}

async function deleteInstance(request: DeleteInstanceRequest): DeleteInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteInstance', 'POST', '/', 'json', false, 'json', request);
}

model DeleteInstancesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  force?: boolean(name='Force', position='Query'),
  instanceId: [ string ](name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  terminateSubscription?: boolean(name='TerminateSubscription', position='Query'),
}

model DeleteInstancesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteInstancesResponseBody(name='body'),
}

async function deleteInstances(request: DeleteInstancesRequest): DeleteInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteInstances', 'POST', '/', 'json', false, 'json', request);
}

model DeleteKeyPairsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  keyPairNames: string(name='KeyPairNames', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteKeyPairsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteKeyPairsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteKeyPairsResponseBody(name='body'),
}

async function deleteKeyPairs(request: DeleteKeyPairsRequest): DeleteKeyPairsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteKeyPairs', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLaunchTemplateRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  launchTemplateId?: string(name='LaunchTemplateId', position='Query'),
  launchTemplateName?: string(name='LaunchTemplateName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteLaunchTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteLaunchTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLaunchTemplateResponseBody(name='body'),
}

async function deleteLaunchTemplate(request: DeleteLaunchTemplateRequest): DeleteLaunchTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLaunchTemplate', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLaunchTemplateVersionRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  deleteVersion: [ long ](name='DeleteVersion', position='Query'),
  launchTemplateId?: string(name='LaunchTemplateId', position='Query'),
  launchTemplateName?: string(name='LaunchTemplateName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteLaunchTemplateVersionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteLaunchTemplateVersionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLaunchTemplateVersionResponseBody(name='body'),
}

async function deleteLaunchTemplateVersion(request: DeleteLaunchTemplateVersionRequest): DeleteLaunchTemplateVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLaunchTemplateVersion', 'POST', '/', 'json', false, 'json', request);
}

model DeleteNatGatewayRequest {
  natGatewayId: string(name='NatGatewayId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteNatGatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNatGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNatGatewayResponseBody(name='body'),
}

async function deleteNatGateway(request: DeleteNatGatewayRequest): DeleteNatGatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteNatGateway', 'POST', '/', 'json', false, 'json', request);
}

model DeleteNetworkInterfaceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  networkInterfaceId: string(name='NetworkInterfaceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteNetworkInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNetworkInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNetworkInterfaceResponseBody(name='body'),
}

async function deleteNetworkInterface(request: DeleteNetworkInterfaceRequest): DeleteNetworkInterfaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteNetworkInterface', 'POST', '/', 'json', false, 'json', request);
}

model DeleteNetworkInterfacePermissionRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  force?: boolean(name='Force', position='Query'),
  networkInterfacePermissionId: string(name='NetworkInterfacePermissionId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteNetworkInterfacePermissionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNetworkInterfacePermissionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNetworkInterfacePermissionResponseBody(name='body'),
}

async function deleteNetworkInterfacePermission(request: DeleteNetworkInterfacePermissionRequest): DeleteNetworkInterfacePermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteNetworkInterfacePermission', 'POST', '/', 'json', false, 'json', request);
}

model DeletePhysicalConnectionRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  physicalConnectionId: string(name='PhysicalConnectionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeletePhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePhysicalConnectionResponseBody(name='body'),
}

async function deletePhysicalConnection(request: DeletePhysicalConnectionRequest): DeletePhysicalConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeletePhysicalConnection', 'POST', '/', 'json', false, 'json', request);
}

model DeletePrefixListRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  prefixListId: string(name='PrefixListId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeletePrefixListResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePrefixListResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePrefixListResponseBody(name='body'),
}

async function deletePrefixList(request: DeletePrefixListRequest): DeletePrefixListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeletePrefixList', 'POST', '/', 'json', false, 'json', request);
}

model DeleteRouteEntryRequest {
  destinationCidrBlock: string(name='DestinationCidrBlock', position='Query'),
  nextHopId?: string(name='NextHopId', position='Query'),
  nextHopList?: [ 
    {
      nextHopId?: string(name='NextHopId'),
      nextHopType?: string(name='NextHopType'),
    }
  ](name='NextHopList', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeTableId: string(name='RouteTableId', position='Query'),
}

model DeleteRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRouteEntryResponseBody(name='body'),
}

async function deleteRouteEntry(request: DeleteRouteEntryRequest): DeleteRouteEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteRouteEntry', 'POST', '/', 'json', false, 'json', request);
}

model DeleteRouterInterfaceRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routerInterfaceId: string(name='RouterInterfaceId', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
}

model DeleteRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRouterInterfaceResponseBody(name='body'),
}

async function deleteRouterInterface(request: DeleteRouterInterfaceRequest): DeleteRouterInterfaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteRouterInterface', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSecurityGroupRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId: string(name='SecurityGroupId', position='Query'),
}

model DeleteSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSecurityGroupResponseBody(name='body'),
}

async function deleteSecurityGroup(request: DeleteSecurityGroupRequest): DeleteSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSecurityGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSnapshotRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  force?: boolean(name='Force', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  snapshotId: string(name='SnapshotId', position='Query'),
}

model DeleteSnapshotResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSnapshotResponseBody(name='body'),
}

async function deleteSnapshot(request: DeleteSnapshotRequest): DeleteSnapshotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSnapshot', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSnapshotGroupRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  snapshotGroupId: string(name='SnapshotGroupId', position='Query'),
}

model DeleteSnapshotGroupResponseBody = {
  operationProgressSet?: {
    operationProgress?: [ 
    {
      errorCode?: string(name='ErrorCode'),
      errorMsg?: string(name='ErrorMsg'),
      operationStatus?: string(name='OperationStatus'),
      relatedItemSet?: {
        relatedItem?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='RelatedItem')
      }(name='RelatedItemSet'),
    }
  ](name='OperationProgress')
  }(name='OperationProgressSet'),
  requestId?: string(name='RequestId'),
}

model DeleteSnapshotGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSnapshotGroupResponseBody(name='body'),
}

async function deleteSnapshotGroup(request: DeleteSnapshotGroupRequest): DeleteSnapshotGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSnapshotGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteStorageSetRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  storageSetId: string(name='StorageSetId', position='Query'),
}

model DeleteStorageSetResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteStorageSetResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteStorageSetResponseBody(name='body'),
}

async function deleteStorageSet(request: DeleteStorageSetRequest): DeleteStorageSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteStorageSet', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVSwitchRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vSwitchId: string(name='VSwitchId', position='Query'),
}

model DeleteVSwitchResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVSwitchResponseBody(name='body'),
}

async function deleteVSwitch(request: DeleteVSwitchRequest): DeleteVSwitchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVSwitch', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVirtualBorderRouterRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
  vbrId: string(name='VbrId', position='Query'),
}

model DeleteVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVirtualBorderRouterResponseBody(name='body'),
}

async function deleteVirtualBorderRouter(request: DeleteVirtualBorderRouterRequest): DeleteVirtualBorderRouterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVirtualBorderRouter', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVpcRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
}

model DeleteVpcResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpcResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpcResponseBody(name='body'),
}

async function deleteVpc(request: DeleteVpcRequest): DeleteVpcResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVpc', 'POST', '/', 'json', false, 'json', request);
}

model DeregisterManagedInstanceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeregisterManagedInstanceResponseBody = {
  instance?: {
    activationId?: string(name='ActivationId'),
    agentVersion?: string(name='AgentVersion'),
    hostname?: string(name='Hostname'),
    instanceId?: string(name='InstanceId'),
    instanceName?: string(name='InstanceName'),
    internetIp?: string(name='InternetIp'),
    intranetIp?: string(name='IntranetIp'),
    invocationCount?: long(name='InvocationCount'),
    lastInvokedTime?: string(name='LastInvokedTime'),
    machineId?: string(name='MachineId'),
    osType?: string(name='OsType'),
    osVersion?: string(name='OsVersion'),
    registrationTime?: string(name='RegistrationTime'),
  }(name='Instance'),
  requestId?: string(name='RequestId'),
}

model DeregisterManagedInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeregisterManagedInstanceResponseBody(name='body'),
}

async function deregisterManagedInstance(request: DeregisterManagedInstanceRequest): DeregisterManagedInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeregisterManagedInstance', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAccessPointsRequest {
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  type?: string(name='Type', position='Query'),
}

model DescribeAccessPointsResponseBody = {
  accessPointSet?: {
    accessPointType?: [ 
    {
      accessPointId?: string(name='AccessPointId'),
      attachedRegionNo?: string(name='AttachedRegionNo'),
      description?: string(name='Description'),
      hostOperator?: string(name='HostOperator'),
      location?: string(name='Location'),
      name?: string(name='Name'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='AccessPointType')
  }(name='AccessPointSet'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeAccessPointsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAccessPointsResponseBody(name='body'),
}

async function describeAccessPoints(request: DescribeAccessPointsRequest): DescribeAccessPointsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAccessPoints', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAccountAttributesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  attributeName?: [ string ](name='AttributeName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeAccountAttributesResponseBody = {
  accountAttributeItems?: {
    accountAttributeItem?: [ 
    {
      attributeName?: string(name='AttributeName'),
      attributeValues?: {
        valueItem?: [ 
        {
          count?: int32(name='Count'),
          diskCategory?: string(name='DiskCategory'),
          expiredTime?: string(name='ExpiredTime'),
          instanceChargeType?: string(name='InstanceChargeType'),
          instanceType?: string(name='InstanceType'),
          value?: string(name='Value'),
          zoneId?: string(name='ZoneId'),
        }
      ](name='ValueItem')
      }(name='AttributeValues'),
    }
  ](name='AccountAttributeItem')
  }(name='AccountAttributeItems'),
  requestId?: string(name='RequestId'),
}

model DescribeAccountAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAccountAttributesResponseBody(name='body'),
}

async function describeAccountAttributes(request: DescribeAccountAttributesRequest): DescribeAccountAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAccountAttributes', 'POST', '/', 'json', false, 'json', request);
}

model DescribeActivationsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  activationId?: string(name='ActivationId', position='Query'),
  instanceName?: string(name='InstanceName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeActivationsResponseBody = {
  activationList?: [ 
    {
      activationId?: string(name='ActivationId'),
      creationTime?: string(name='CreationTime'),
      deregisteredCount?: int32(name='DeregisteredCount'),
      description?: string(name='Description'),
      disabled?: boolean(name='Disabled'),
      instanceCount?: int32(name='InstanceCount'),
      instanceName?: string(name='InstanceName'),
      ipAddressRange?: string(name='IpAddressRange'),
      registeredCount?: int32(name='RegisteredCount'),
      timeToLiveInHours?: long(name='TimeToLiveInHours'),
    }
  ](name='ActivationList'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeActivationsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeActivationsResponseBody(name='body'),
}

async function describeActivations(request: DescribeActivationsRequest): DescribeActivationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeActivations', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAutoProvisioningGroupHistoryRequest {
  autoProvisioningGroupId: string(name='AutoProvisioningGroupId', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model DescribeAutoProvisioningGroupHistoryResponseBody = {
  autoProvisioningGroupHistories?: {
    autoProvisioningGroupHistory?: [ 
    {
      activityDetails?: {
        activityDetail?: [ 
        {
          detail?: string(name='Detail'),
          status?: string(name='Status'),
        }
      ](name='ActivityDetail')
      }(name='ActivityDetails'),
      lastEventTime?: string(name='LastEventTime'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
      taskId?: string(name='TaskId'),
    }
  ](name='AutoProvisioningGroupHistory')
  }(name='AutoProvisioningGroupHistories'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeAutoProvisioningGroupHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAutoProvisioningGroupHistoryResponseBody(name='body'),
}

async function describeAutoProvisioningGroupHistory(request: DescribeAutoProvisioningGroupHistoryRequest): DescribeAutoProvisioningGroupHistoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAutoProvisioningGroupHistory', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAutoProvisioningGroupInstancesRequest {
  autoProvisioningGroupId: string(name='AutoProvisioningGroupId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeAutoProvisioningGroupInstancesResponseBody = {
  instances?: {
    instance?: [ 
    {
      CPU?: int32(name='CPU'),
      creationTime?: string(name='CreationTime'),
      instanceId?: string(name='InstanceId'),
      instanceType?: string(name='InstanceType'),
      ioOptimized?: boolean(name='IoOptimized'),
      isSpot?: boolean(name='IsSpot'),
      memory?: int32(name='Memory'),
      networkType?: string(name='NetworkType'),
      osType?: string(name='OsType'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Instance')
  }(name='Instances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeAutoProvisioningGroupInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAutoProvisioningGroupInstancesResponseBody(name='body'),
}

async function describeAutoProvisioningGroupInstances(request: DescribeAutoProvisioningGroupInstancesRequest): DescribeAutoProvisioningGroupInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAutoProvisioningGroupInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAutoProvisioningGroupsRequest {
  autoProvisioningGroupId?: [ string ](name='AutoProvisioningGroupId', position='Query'),
  autoProvisioningGroupName?: string(name='AutoProvisioningGroupName', position='Query'),
  autoProvisioningGroupStatus?: [ string ](name='AutoProvisioningGroupStatus', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeAutoProvisioningGroupsResponseBody = {
  autoProvisioningGroups?: {
    autoProvisioningGroup?: [ 
    {
      autoProvisioningGroupId?: string(name='AutoProvisioningGroupId'),
      autoProvisioningGroupName?: string(name='AutoProvisioningGroupName'),
      autoProvisioningGroupType?: string(name='AutoProvisioningGroupType'),
      creationTime?: string(name='CreationTime'),
      excessCapacityTerminationPolicy?: string(name='ExcessCapacityTerminationPolicy'),
      launchTemplateConfigs?: {
        launchTemplateConfig?: [ 
        {
          instanceType?: string(name='InstanceType'),
          maxPrice?: float(name='MaxPrice'),
          priority?: float(name='Priority'),
          vSwitchId?: string(name='VSwitchId'),
          weightedCapacity?: float(name='WeightedCapacity'),
        }
      ](name='LaunchTemplateConfig')
      }(name='LaunchTemplateConfigs'),
      launchTemplateId?: string(name='LaunchTemplateId'),
      launchTemplateVersion?: string(name='LaunchTemplateVersion'),
      maxSpotPrice?: float(name='MaxSpotPrice'),
      payAsYouGoOptions?: {
        allocationStrategy?: string(name='AllocationStrategy'),
      }(name='PayAsYouGoOptions'),
      regionId?: string(name='RegionId'),
      spotOptions?: {
        allocationStrategy?: string(name='AllocationStrategy'),
        instanceInterruptionBehavior?: string(name='InstanceInterruptionBehavior'),
        instancePoolsToUseCount?: int32(name='InstancePoolsToUseCount'),
      }(name='SpotOptions'),
      state?: string(name='State'),
      status?: string(name='Status'),
      targetCapacitySpecification?: {
        defaultTargetCapacityType?: string(name='DefaultTargetCapacityType'),
        payAsYouGoTargetCapacity?: float(name='PayAsYouGoTargetCapacity'),
        spotTargetCapacity?: float(name='SpotTargetCapacity'),
        totalTargetCapacity?: float(name='TotalTargetCapacity'),
      }(name='TargetCapacitySpecification'),
      terminateInstances?: boolean(name='TerminateInstances'),
      terminateInstancesWithExpiration?: boolean(name='TerminateInstancesWithExpiration'),
      validFrom?: string(name='ValidFrom'),
      validUntil?: string(name='ValidUntil'),
    }
  ](name='AutoProvisioningGroup')
  }(name='AutoProvisioningGroups'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeAutoProvisioningGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAutoProvisioningGroupsResponseBody(name='body'),
}

async function describeAutoProvisioningGroups(request: DescribeAutoProvisioningGroupsRequest): DescribeAutoProvisioningGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAutoProvisioningGroups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAutoSnapshotPolicyExRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', position='Query'),
  autoSnapshotPolicyName?: string(name='AutoSnapshotPolicyName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model DescribeAutoSnapshotPolicyExResponseBody = {
  autoSnapshotPolicies?: {
    autoSnapshotPolicy?: [ 
    {
      autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId'),
      autoSnapshotPolicyName?: string(name='AutoSnapshotPolicyName'),
      copiedSnapshotsRetentionDays?: int32(name='CopiedSnapshotsRetentionDays'),
      creationTime?: string(name='CreationTime'),
      diskNums?: int32(name='DiskNums'),
      enableCrossRegionCopy?: boolean(name='EnableCrossRegionCopy'),
      regionId?: string(name='RegionId'),
      repeatWeekdays?: string(name='RepeatWeekdays'),
      resourceGroupId?: string(name='ResourceGroupId'),
      retentionDays?: int32(name='RetentionDays'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
      targetCopyRegions?: string(name='TargetCopyRegions'),
      timePoints?: string(name='TimePoints'),
      volumeNums?: int32(name='VolumeNums'),
    }
  ](name='AutoSnapshotPolicy')
  }(name='AutoSnapshotPolicies'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeAutoSnapshotPolicyExResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAutoSnapshotPolicyExResponseBody(name='body'),
}

async function describeAutoSnapshotPolicyEx(request: DescribeAutoSnapshotPolicyExRequest): DescribeAutoSnapshotPolicyExResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAutoSnapshotPolicyEx', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAvailableResourceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  cores?: int32(name='Cores', position='Query'),
  dataDiskCategory?: string(name='DataDiskCategory', position='Query'),
  dedicatedHostId?: string(name='DedicatedHostId', position='Query'),
  destinationResource: string(name='DestinationResource', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  ioOptimized?: string(name='IoOptimized', position='Query'),
  memory?: float(name='Memory', position='Query'),
  networkCategory?: string(name='NetworkCategory', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
  scope?: string(name='Scope', position='Query'),
  spotDuration?: int32(name='SpotDuration', minimum=2, maximum=6, position='Query'),
  spotStrategy?: string(name='SpotStrategy', position='Query'),
  systemDiskCategory?: string(name='SystemDiskCategory', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeAvailableResourceResponseBody = {
  availableZones?: {
    availableZone?: [ 
    {
      availableResources?: {
        availableResource?: [ 
        {
          supportedResources?: {
            supportedResource?: [ 
            {
              max?: int32(name='Max'),
              min?: int32(name='Min'),
              status?: string(name='Status'),
              statusCategory?: string(name='StatusCategory'),
              unit?: string(name='Unit'),
              value?: string(name='Value'),
            }
          ](name='SupportedResource')
          }(name='SupportedResources'),
          type?: string(name='Type'),
        }
      ](name='AvailableResource')
      }(name='AvailableResources'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      statusCategory?: string(name='StatusCategory'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='AvailableZone')
  }(name='AvailableZones'),
  requestId?: string(name='RequestId'),
}

model DescribeAvailableResourceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAvailableResourceResponseBody(name='body'),
}

async function describeAvailableResource(request: DescribeAvailableResourceRequest): DescribeAvailableResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAvailableResource', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBandwidthLimitationRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  operationType?: string(name='OperationType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId?: string(name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  spotStrategy?: string(name='SpotStrategy', position='Query'),
}

model DescribeBandwidthLimitationResponseBody = {
  bandwidths?: {
    bandwidth?: [ 
    {
      internetChargeType?: string(name='InternetChargeType'),
      max?: int32(name='Max'),
      min?: int32(name='Min'),
      unit?: string(name='Unit'),
    }
  ](name='Bandwidth')
  }(name='Bandwidths'),
  requestId?: string(name='RequestId'),
}

model DescribeBandwidthLimitationResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBandwidthLimitationResponseBody(name='body'),
}

async function describeBandwidthLimitation(request: DescribeBandwidthLimitationRequest): DescribeBandwidthLimitationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBandwidthLimitation', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBandwidthPackagesRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId', position='Query'),
  natGatewayId?: string(name='NatGatewayId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeBandwidthPackagesResponseBody = {
  bandwidthPackages?: {
    bandwidthPackage?: [ 
    {
      bandwidth?: string(name='Bandwidth'),
      bandwidthPackageId?: string(name='BandwidthPackageId'),
      businessStatus?: string(name='BusinessStatus'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      ISP?: string(name='ISP'),
      instanceChargeType?: string(name='InstanceChargeType'),
      internetChargeType?: string(name='InternetChargeType'),
      ipCount?: string(name='IpCount'),
      name?: string(name='Name'),
      natGatewayId?: string(name='NatGatewayId'),
      publicIpAddresses?: {
        publicIpAddresse?: [ 
        {
          allocationId?: string(name='AllocationId'),
          ipAddress?: string(name='IpAddress'),
        }
      ](name='PublicIpAddresse')
      }(name='PublicIpAddresses'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='BandwidthPackage')
  }(name='BandwidthPackages'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeBandwidthPackagesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBandwidthPackagesResponseBody(name='body'),
}

async function describeBandwidthPackages(request: DescribeBandwidthPackagesRequest): DescribeBandwidthPackagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBandwidthPackages', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCapacityReservationInstancesRequest {
  privatePoolOptions?: {
    id: string(name='Id'),
  }(name='PrivatePoolOptions', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeCapacityReservationInstancesResponseBody = {
  capacityReservationItem?: {
    instanceIdSet?: [ 
    {
      instanceId?: string(name='InstanceId'),
    }
  ](name='InstanceIdSet')
  }(name='CapacityReservationItem'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeCapacityReservationInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCapacityReservationInstancesResponseBody(name='body'),
}

async function describeCapacityReservationInstances(request: DescribeCapacityReservationInstancesRequest): DescribeCapacityReservationInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCapacityReservationInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCapacityReservationsRequest {
  privatePoolOptions?: {
    ids?: string(name='Ids'),
  }(name='PrivatePoolOptions', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  platform?: string(name='Platform', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: string(name='Status', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeCapacityReservationsResponseBody = {
  capacityReservationSet?: {
    capacityReservationItem?: [ 
    {
      allocatedResources?: {
        allocatedResource?: [ 
        {
          instanceType?: string(name='InstanceType'),
          totalAmount?: int32(name='TotalAmount'),
          usedAmount?: int32(name='UsedAmount'),
          zoneId?: string(name='zoneId'),
        }
      ](name='AllocatedResource')
      }(name='AllocatedResources'),
      description?: string(name='Description'),
      endTime?: string(name='EndTime'),
      endTimeType?: string(name='EndTimeType'),
      instanceChargeType?: string(name='InstanceChargeType'),
      platform?: string(name='Platform'),
      privatePoolOptionsId?: string(name='PrivatePoolOptionsId'),
      privatePoolOptionsMatchCriteria?: string(name='PrivatePoolOptionsMatchCriteria'),
      privatePoolOptionsName?: string(name='PrivatePoolOptionsName'),
      regionId?: string(name='RegionId'),
      reservedInstanceId?: string(name='ReservedInstanceId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      savingPlanId?: string(name='SavingPlanId'),
      startTime?: string(name='StartTime'),
      startTimeType?: string(name='StartTimeType'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
      timeSlot?: string(name='TimeSlot'),
    }
  ](name='CapacityReservationItem')
  }(name='CapacityReservationSet'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeCapacityReservationsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCapacityReservationsResponseBody(name='body'),
}

async function describeCapacityReservations(request: DescribeCapacityReservationsRequest): DescribeCapacityReservationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCapacityReservations', 'POST', '/', 'json', false, 'json', request);
}

model DescribeClassicLinkInstancesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId?: string(name='InstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: string(name='PageNumber', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model DescribeClassicLinkInstancesResponseBody = {
  links?: {
    link?: [ 
    {
      instanceId?: string(name='InstanceId'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Link')
  }(name='Links'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeClassicLinkInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClassicLinkInstancesResponseBody(name='body'),
}

async function describeClassicLinkInstances(request: DescribeClassicLinkInstancesRequest): DescribeClassicLinkInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClassicLinkInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCloudAssistantStatusRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId?: [ string ](name='InstanceId', position='Query'),
  OSType?: string(name='OSType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeCloudAssistantStatusResponseBody = {
  instanceCloudAssistantStatusSet?: {
    instanceCloudAssistantStatus?: [ 
    {
      activeTaskCount?: long(name='ActiveTaskCount'),
      cloudAssistantStatus?: string(name='CloudAssistantStatus'),
      cloudAssistantVersion?: string(name='CloudAssistantVersion'),
      instanceId?: string(name='InstanceId'),
      invocationCount?: long(name='InvocationCount'),
      lastHeartbeatTime?: string(name='LastHeartbeatTime'),
      lastInvokedTime?: string(name='LastInvokedTime'),
      OSType?: string(name='OSType'),
      supportSessionManager?: boolean(name='SupportSessionManager'),
    }
  ](name='InstanceCloudAssistantStatus')
  }(name='InstanceCloudAssistantStatusSet'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeCloudAssistantStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCloudAssistantStatusResponseBody(name='body'),
}

async function describeCloudAssistantStatus(request: DescribeCloudAssistantStatusRequest): DescribeCloudAssistantStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCloudAssistantStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeClustersRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeClustersResponseBody = {
  clusters?: {
    cluster?: [ 
    {
      clusterId?: string(name='ClusterId'),
    }
  ](name='Cluster')
  }(name='Clusters'),
  requestId?: string(name='RequestId'),
}

model DescribeClustersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClustersResponseBody(name='body'),
}

async function describeClusters(request: DescribeClustersRequest): DescribeClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClusters', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCommandsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  commandId?: string(name='CommandId', position='Query'),
  contentEncoding?: string(name='ContentEncoding', position='Query'),
  description?: string(name='Description', position='Query'),
  latest?: boolean(name='Latest', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  provider?: string(name='Provider', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  type?: string(name='Type', position='Query'),
}

model DescribeCommandsResponseBody = {
  commands?: {
    command?: [ 
    {
      category?: string(name='Category'),
      commandContent?: string(name='CommandContent'),
      commandId?: string(name='CommandId'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      enableParameter?: boolean(name='EnableParameter'),
      invokeTimes?: int32(name='InvokeTimes'),
      latest?: boolean(name='Latest'),
      name?: string(name='Name'),
      parameterDefinitions?: {
        parameterDefinition?: [ 
        {
          defaultValue?: string(name='DefaultValue'),
          description?: string(name='Description'),
          parameterName?: string(name='ParameterName'),
          possibleValues?: {
            possibleValue?: [ string ](name='PossibleValue')
          }(name='PossibleValues'),
          required?: boolean(name='Required'),
        }
      ](name='ParameterDefinition')
      }(name='ParameterDefinitions'),
      parameterNames?: {
        parameterName?: [ string ](name='ParameterName')
      }(name='ParameterNames'),
      provider?: string(name='Provider'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
      timeout?: long(name='Timeout'),
      type?: string(name='Type'),
      version?: int32(name='Version'),
      workingDir?: string(name='WorkingDir'),
    }
  ](name='Command')
  }(name='Commands'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeCommandsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCommandsResponseBody(name='body'),
}

async function describeCommands(request: DescribeCommandsRequest): DescribeCommandsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCommands', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDedicatedBlockStorageClustersRequest {
  category?: string(name='Category', position='Query'),
  dedicatedBlockStorageClusterId?: [ string ](name='DedicatedBlockStorageClusterId', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=500, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: [ string ](name='Status', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeDedicatedBlockStorageClustersResponseBody = {
  dedicatedBlockStorageClusters?: {
    dedicatedBlockStorageCluster?: [ 
    {
      category?: string(name='Category'),
      createTime?: string(name='CreateTime'),
      dedicatedBlockStorageClusterCapacity?: {
        availableCapacity?: long(name='AvailableCapacity'),
        totalCapacity?: long(name='TotalCapacity'),
      }(name='DedicatedBlockStorageClusterCapacity'),
      dedicatedBlockStorageClusterId?: string(name='DedicatedBlockStorageClusterId'),
      dedicatedBlockStorageClusterName?: string(name='DedicatedBlockStorageClusterName'),
      description?: string(name='Description'),
      expiredTime?: string(name='ExpiredTime'),
      status?: string(name='Status'),
      type?: string(name='Type'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='DedicatedBlockStorageCluster')
  }(name='DedicatedBlockStorageClusters'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeDedicatedBlockStorageClustersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDedicatedBlockStorageClustersResponseBody(name='body'),
}

async function describeDedicatedBlockStorageClusters(request: DescribeDedicatedBlockStorageClustersRequest): DescribeDedicatedBlockStorageClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDedicatedBlockStorageClusters', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDedicatedHostAutoRenewRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  dedicatedHostIds: string(name='DedicatedHostIds', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDedicatedHostAutoRenewResponseBody = {
  dedicatedHostRenewAttributes?: {
    dedicatedHostRenewAttribute?: [ 
    {
      autoRenewEnabled?: boolean(name='AutoRenewEnabled'),
      autoRenewWithEcs?: string(name='AutoRenewWithEcs'),
      dedicatedHostId?: string(name='DedicatedHostId'),
      duration?: int32(name='Duration'),
      periodUnit?: string(name='PeriodUnit'),
      renewalStatus?: string(name='RenewalStatus'),
    }
  ](name='DedicatedHostRenewAttribute')
  }(name='DedicatedHostRenewAttributes'),
  requestId?: string(name='RequestId'),
}

model DescribeDedicatedHostAutoRenewResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDedicatedHostAutoRenewResponseBody(name='body'),
}

async function describeDedicatedHostAutoRenew(request: DescribeDedicatedHostAutoRenewRequest): DescribeDedicatedHostAutoRenewResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDedicatedHostAutoRenew', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDedicatedHostClustersRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  dedicatedHostClusterIds?: string(name='DedicatedHostClusterIds', position='Query'),
  dedicatedHostClusterName?: string(name='DedicatedHostClusterName', position='Query'),
  lockReason?: string(name='LockReason', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: string(name='Status', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeDedicatedHostClustersResponseBody = {
  dedicatedHostClusters?: {
    dedicatedHostCluster?: [ 
    {
      dedicatedHostClusterCapacity?: {
        availableInstanceTypes?: {
          availableInstanceType?: [ 
          {
            availableInstanceCapacity?: int32(name='AvailableInstanceCapacity'),
            instanceType?: string(name='InstanceType'),
          }
        ](name='AvailableInstanceType')
        }(name='AvailableInstanceTypes'),
        availableMemory?: int32(name='AvailableMemory'),
        availableVcpus?: int32(name='AvailableVcpus'),
        localStorageCapacities?: {
          localStorageCapacity?: [ 
          {
            availableDisk?: int32(name='AvailableDisk'),
            dataDiskCategory?: string(name='DataDiskCategory'),
            totalDisk?: int32(name='TotalDisk'),
          }
        ](name='LocalStorageCapacity')
        }(name='LocalStorageCapacities'),
        totalMemory?: int32(name='TotalMemory'),
        totalVcpus?: int32(name='TotalVcpus'),
      }(name='DedicatedHostClusterCapacity'),
      dedicatedHostClusterId?: string(name='DedicatedHostClusterId'),
      dedicatedHostClusterName?: string(name='DedicatedHostClusterName'),
      dedicatedHostIds?: {
        dedicatedHostId?: [ string ](name='DedicatedHostId')
      }(name='DedicatedHostIds'),
      description?: string(name='Description'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='DedicatedHostCluster')
  }(name='DedicatedHostClusters'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeDedicatedHostClustersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDedicatedHostClustersResponseBody(name='body'),
}

async function describeDedicatedHostClusters(request: DescribeDedicatedHostClustersRequest): DescribeDedicatedHostClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDedicatedHostClusters', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDedicatedHostTypesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  dedicatedHostType?: string(name='DedicatedHostType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  supportedInstanceTypeFamily?: string(name='SupportedInstanceTypeFamily', position='Query'),
}

model DescribeDedicatedHostTypesResponseBody = {
  dedicatedHostTypes?: {
    dedicatedHostType?: [ 
    {
      cores?: int32(name='Cores'),
      cpuOverCommitRatioRange?: string(name='CpuOverCommitRatioRange'),
      dedicatedHostType?: string(name='DedicatedHostType'),
      GPUSpec?: string(name='GPUSpec'),
      localStorageAmount?: int32(name='LocalStorageAmount'),
      localStorageCapacity?: long(name='LocalStorageCapacity'),
      localStorageCategory?: string(name='LocalStorageCategory'),
      memorySize?: float(name='MemorySize'),
      physicalGpus?: int32(name='PhysicalGpus'),
      sockets?: int32(name='Sockets'),
      supportCpuOverCommitRatio?: boolean(name='SupportCpuOverCommitRatio'),
      supportedInstanceTypeFamilies?: {
        supportedInstanceTypeFamily?: [ string ](name='SupportedInstanceTypeFamily')
      }(name='SupportedInstanceTypeFamilies'),
      supportedInstanceTypesList?: {
        supportedInstanceTypesList?: [ string ](name='SupportedInstanceTypesList')
      }(name='SupportedInstanceTypesList'),
      totalVcpus?: int32(name='TotalVcpus'),
      totalVgpus?: int32(name='TotalVgpus'),
    }
  ](name='DedicatedHostType')
  }(name='DedicatedHostTypes'),
  requestId?: string(name='RequestId'),
}

model DescribeDedicatedHostTypesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDedicatedHostTypesResponseBody(name='body'),
}

async function describeDedicatedHostTypes(request: DescribeDedicatedHostTypesRequest): DescribeDedicatedHostTypesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDedicatedHostTypes', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDedicatedHostsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  dedicatedHostClusterId?: string(name='DedicatedHostClusterId', position='Query'),
  dedicatedHostIds?: string(name='DedicatedHostIds', position='Query'),
  dedicatedHostName?: string(name='DedicatedHostName', position='Query'),
  dedicatedHostType?: string(name='DedicatedHostType', position='Query'),
  lockReason?: string(name='LockReason', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: string(name='Status', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeDedicatedHostsResponseBody = {
  dedicatedHosts?: {
    dedicatedHost?: [ 
    {
      actionOnMaintenance?: string(name='ActionOnMaintenance'),
      autoPlacement?: string(name='AutoPlacement'),
      autoReleaseTime?: string(name='AutoReleaseTime'),
      capacity?: {
        availableLocalStorage?: int32(name='AvailableLocalStorage'),
        availableMemory?: float(name='AvailableMemory'),
        availableVcpus?: int32(name='AvailableVcpus'),
        availableVgpus?: int32(name='AvailableVgpus'),
        localStorageCategory?: string(name='LocalStorageCategory'),
        totalLocalStorage?: int32(name='TotalLocalStorage'),
        totalMemory?: float(name='TotalMemory'),
        totalVcpus?: int32(name='TotalVcpus'),
        totalVgpus?: int32(name='TotalVgpus'),
      }(name='Capacity'),
      chargeType?: string(name='ChargeType'),
      cores?: int32(name='Cores'),
      cpuOverCommitRatio?: float(name='CpuOverCommitRatio'),
      creationTime?: string(name='CreationTime'),
      dedicatedHostClusterId?: string(name='DedicatedHostClusterId'),
      dedicatedHostId?: string(name='DedicatedHostId'),
      dedicatedHostName?: string(name='DedicatedHostName'),
      dedicatedHostType?: string(name='DedicatedHostType'),
      description?: string(name='Description'),
      expiredTime?: string(name='ExpiredTime'),
      GPUSpec?: string(name='GPUSpec'),
      hostDetailInfo?: {
        serialNumber?: string(name='SerialNumber'),
      }(name='HostDetailInfo'),
      instances?: {
        instance?: [ 
        {
          instanceId?: string(name='InstanceId'),
          instanceType?: string(name='InstanceType'),
        }
      ](name='Instance')
      }(name='Instances'),
      machineId?: string(name='MachineId'),
      networkAttributes?: {
        slbUdpTimeout?: int32(name='SlbUdpTimeout'),
        udpTimeout?: int32(name='UdpTimeout'),
      }(name='NetworkAttributes'),
      operationLocks?: {
        operationLock?: [ 
        {
          lockReason?: string(name='LockReason'),
        }
      ](name='OperationLock')
      }(name='OperationLocks'),
      physicalGpus?: int32(name='PhysicalGpus'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      saleCycle?: string(name='SaleCycle'),
      schedulerOptions_managedPrivateSpaceId?: string(name='SchedulerOptions.ManagedPrivateSpaceId'),
      sockets?: int32(name='Sockets'),
      status?: string(name='Status'),
      supportedCustomInstanceTypeFamilies?: {
        supportedCustomInstanceTypeFamily?: [ string ](name='SupportedCustomInstanceTypeFamily')
      }(name='SupportedCustomInstanceTypeFamilies'),
      supportedInstanceTypeFamilies?: {
        supportedInstanceTypeFamily?: [ string ](name='SupportedInstanceTypeFamily')
      }(name='SupportedInstanceTypeFamilies'),
      supportedInstanceTypesList?: {
        supportedInstanceTypesList?: [ string ](name='SupportedInstanceTypesList')
      }(name='SupportedInstanceTypesList'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='DedicatedHost')
  }(name='DedicatedHosts'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeDedicatedHostsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDedicatedHostsResponseBody(name='body'),
}

async function describeDedicatedHosts(request: DescribeDedicatedHostsRequest): DescribeDedicatedHostsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDedicatedHosts', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDemandsRequest {
  demandId?: string(name='DemandId', position='Query'),
  demandStatus?: [ string ](name='DemandStatus', position='Query'),
  demandType?: string(name='DemandType', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  instanceTypeFamily?: string(name='InstanceTypeFamily', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeDemandsResponseBody = {
  demands?: {
    demand?: [ 
    {
      availableAmount?: int32(name='AvailableAmount'),
      comment?: string(name='Comment'),
      deliveringAmount?: int32(name='DeliveringAmount'),
      demandDescription?: string(name='DemandDescription'),
      demandId?: string(name='DemandId'),
      demandName?: string(name='DemandName'),
      demandStatus?: string(name='DemandStatus'),
      demandTime?: string(name='DemandTime'),
      endTime?: string(name='EndTime'),
      instanceChargeType?: string(name='InstanceChargeType'),
      instanceType?: string(name='InstanceType'),
      instanceTypeFamily?: string(name='InstanceTypeFamily'),
      period?: int32(name='Period'),
      periodUnit?: string(name='PeriodUnit'),
      startTime?: string(name='StartTime'),
      supplyInfos?: {
        supplyInfo?: [ 
        {
          amount?: int32(name='Amount'),
          supplyEndTime?: string(name='SupplyEndTime'),
          supplyStartTime?: string(name='SupplyStartTime'),
          supplyStatus?: string(name='SupplyStatus'),
        }
      ](name='SupplyInfo')
      }(name='SupplyInfos'),
      totalAmount?: int32(name='TotalAmount'),
      usedAmount?: int32(name='UsedAmount'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Demand')
  }(name='Demands'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeDemandsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDemandsResponseBody(name='body'),
}

async function describeDemands(request: DescribeDemandsRequest): DescribeDemandsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDemands', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDeploymentSetSupportedInstanceTypeFamilyRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDeploymentSetSupportedInstanceTypeFamilyResponseBody = {
  instanceTypeFamilies?: string(name='InstanceTypeFamilies'),
  requestId?: string(name='RequestId'),
}

model DescribeDeploymentSetSupportedInstanceTypeFamilyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDeploymentSetSupportedInstanceTypeFamilyResponseBody(name='body'),
}

async function describeDeploymentSetSupportedInstanceTypeFamily(request: DescribeDeploymentSetSupportedInstanceTypeFamilyRequest): DescribeDeploymentSetSupportedInstanceTypeFamilyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDeploymentSetSupportedInstanceTypeFamily', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDeploymentSetsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  deploymentSetIds?: string(name='DeploymentSetIds', position='Query'),
  deploymentSetName?: string(name='DeploymentSetName', position='Query'),
  domain?: string(name='Domain', position='Query'),
  granularity?: string(name='Granularity', position='Query'),
  networkType?: string(name='NetworkType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  strategy?: string(name='Strategy', position='Query'),
}

model DescribeDeploymentSetsResponseBody = {
  deploymentSets?: {
    deploymentSet?: [ 
    {
      capacities?: {
        capacity?: [ 
        {
          availableAmount?: int32(name='AvailableAmount'),
          usedAmount?: int32(name='UsedAmount'),
          zoneId?: string(name='ZoneId'),
        }
      ](name='Capacity')
      }(name='Capacities'),
      creationTime?: string(name='CreationTime'),
      deploymentSetDescription?: string(name='DeploymentSetDescription'),
      deploymentSetId?: string(name='DeploymentSetId'),
      deploymentSetName?: string(name='DeploymentSetName'),
      deploymentStrategy?: string(name='DeploymentStrategy'),
      domain?: string(name='Domain'),
      granularity?: string(name='Granularity'),
      groupCount?: int32(name='GroupCount'),
      instanceAmount?: int32(name='InstanceAmount'),
      instanceIds?: {
        instanceId?: [ string ](name='InstanceId')
      }(name='InstanceIds'),
      strategy?: string(name='Strategy'),
    }
  ](name='DeploymentSet')
  }(name='DeploymentSets'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeDeploymentSetsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDeploymentSetsResponseBody(name='body'),
}

async function describeDeploymentSets(request: DescribeDeploymentSetsRequest): DescribeDeploymentSetsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDeploymentSets', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDiagnosticMetricSetsRequest {
  maxResults?: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  metricSetIds?: [ string ](name='MetricSetIds', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
  type?: string(name='Type', position='Query'),
}

model DescribeDiagnosticMetricSetsResponseBody = {
  metricSets?: [ 
    {
      description?: string(name='Description'),
      metricIds?: [ string ](name='MetricIds'),
      metricSetId?: string(name='MetricSetId'),
      metricSetName?: string(name='MetricSetName'),
      resourceType?: string(name='ResourceType'),
      type?: string(name='Type'),
    }
  ](name='MetricSets'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DescribeDiagnosticMetricSetsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDiagnosticMetricSetsResponseBody(name='body'),
}

async function describeDiagnosticMetricSets(request: DescribeDiagnosticMetricSetsRequest): DescribeDiagnosticMetricSetsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDiagnosticMetricSets', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDiagnosticMetricsRequest {
  body?: string(name='body', position='Host'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  metricIds?: [ string ](name='MetricIds', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
}

model DescribeDiagnosticMetricsResponseBody = {
  metrics?: [ 
    {
      description?: string(name='Description'),
      guestMetric?: boolean(name='GuestMetric'),
      metricCategory?: string(name='MetricCategory'),
      metricId?: string(name='MetricId'),
      metricName?: string(name='MetricName'),
      resourceType?: string(name='ResourceType'),
      supportedOperatingSystem?: string(name='SupportedOperatingSystem'),
    }
  ](name='Metrics'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DescribeDiagnosticMetricsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDiagnosticMetricsResponseBody(name='body'),
}

async function describeDiagnosticMetrics(request: DescribeDiagnosticMetricsRequest): DescribeDiagnosticMetricsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDiagnosticMetrics', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDiagnosticReportsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', description='TokenNextToken', position='Query'),
  regionId: string(name='RegionId', description='', position='Query'),
  reportIds?: [ string ](name='ReportIds', position='Query'),
  resourceIds?: [ string ](name='ResourceIds', position='Query'),
  severity?: string(name='Severity', description='
- Info
- Warn
- Critical', position='Query'),
  status?: string(name='Status', description='', position='Query'),
}

model DescribeDiagnosticReportsResponseBody = {
  nextToken?: string(name='NextToken'),
  reports?: [ 
    {
      creationTime?: string(name='CreationTime'),
      endTime?: string(name='EndTime'),
      finishedTime?: string(name='FinishedTime'),
      issues?: [ 
        {
          issueId?: string(name='IssueId'),
          metricCategory?: string(name='MetricCategory'),
          metricId?: string(name='MetricId'),
          severity?: string(name='Severity'),
        }
      ](name='Issues'),
      metricSetId?: string(name='MetricSetId'),
      reportId?: string(name='ReportId'),
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      severity?: string(name='Severity'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
    }
  ](name='Reports'),
  requestId?: string(name='RequestId', description='ID'),
}

model DescribeDiagnosticReportsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDiagnosticReportsResponseBody(name='body'),
}

async function describeDiagnosticReports(request: DescribeDiagnosticReportsRequest): DescribeDiagnosticReportsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDiagnosticReports', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDiskMonitorDataRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  diskId: string(name='DiskId', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeDiskMonitorDataResponseBody = {
  monitorData?: {
    diskMonitorData?: [ 
    {
      BPSRead?: int32(name='BPSRead'),
      BPSTotal?: int32(name='BPSTotal'),
      BPSWrite?: int32(name='BPSWrite'),
      diskId?: string(name='DiskId'),
      IOPSRead?: int32(name='IOPSRead'),
      IOPSTotal?: int32(name='IOPSTotal'),
      IOPSWrite?: int32(name='IOPSWrite'),
      latencyRead?: int32(name='LatencyRead'),
      latencyWrite?: int32(name='LatencyWrite'),
      timeStamp?: string(name='TimeStamp'),
    }
  ](name='DiskMonitorData')
  }(name='MonitorData'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeDiskMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDiskMonitorDataResponseBody(name='body'),
}

async function describeDiskMonitorData(request: DescribeDiskMonitorDataRequest): DescribeDiskMonitorDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDiskMonitorData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDisksRequest {
  filter?: [
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filter', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  additionalAttributes?: [ string ](name='AdditionalAttributes', position='Query'),
  autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', position='Query'),
  category?: string(name='Category', position='Query'),
  deleteAutoSnapshot?: boolean(name='DeleteAutoSnapshot', position='Query'),
  deleteWithInstance?: boolean(name='DeleteWithInstance', position='Query'),
  diskChargeType?: string(name='DiskChargeType', position='Query'),
  diskIds?: string(name='DiskIds', position='Query'),
  diskName?: string(name='DiskName', position='Query'),
  diskType?: string(name='DiskType', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  enableAutoSnapshot?: boolean(name='EnableAutoSnapshot', position='Query'),
  enableAutomatedSnapshotPolicy?: boolean(name='EnableAutomatedSnapshotPolicy', position='Query'),
  enableShared?: boolean(name='EnableShared', position='Query'),
  encrypted?: boolean(name='Encrypted', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  KMSKeyId?: string(name='KMSKeyId', position='Query'),
  lockReason?: string(name='LockReason', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=500, position='Query'),
  multiAttach?: string(name='MultiAttach', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  portable?: boolean(name='Portable', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  snapshotId?: string(name='SnapshotId', position='Query'),
  status?: string(name='Status', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeDisksResponseBody = {
  disks?: {
    disk?: [ 
    {
      attachedTime?: string(name='AttachedTime'),
      attachments?: {
        attachment?: [ 
        {
          attachedTime?: string(name='AttachedTime'),
          device?: string(name='Device'),
          instanceId?: string(name='InstanceId'),
        }
      ](name='Attachment')
      }(name='Attachments'),
      autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId'),
      bdfId?: string(name='BdfId'),
      burstingEnabled?: boolean(name='BurstingEnabled'),
      category?: string(name='Category'),
      creationTime?: string(name='CreationTime'),
      deleteAutoSnapshot?: boolean(name='DeleteAutoSnapshot'),
      deleteWithInstance?: boolean(name='DeleteWithInstance'),
      description?: string(name='Description'),
      detachedTime?: string(name='DetachedTime'),
      device?: string(name='Device'),
      diskChargeType?: string(name='DiskChargeType'),
      diskId?: string(name='DiskId'),
      diskName?: string(name='DiskName'),
      enableAutoSnapshot?: boolean(name='EnableAutoSnapshot'),
      enableAutomatedSnapshotPolicy?: boolean(name='EnableAutomatedSnapshotPolicy'),
      encrypted?: boolean(name='Encrypted'),
      expiredTime?: string(name='ExpiredTime'),
      IOPS?: int32(name='IOPS'),
      IOPSRead?: int32(name='IOPSRead'),
      IOPSWrite?: int32(name='IOPSWrite'),
      imageId?: string(name='ImageId'),
      instanceId?: string(name='InstanceId'),
      KMSKeyId?: string(name='KMSKeyId'),
      mountInstanceNum?: int32(name='MountInstanceNum'),
      mountInstances?: {
        mountInstance?: [ 
        {
          attachedTime?: string(name='AttachedTime'),
          device?: string(name='Device'),
          instanceId?: string(name='InstanceId'),
        }
      ](name='MountInstance')
      }(name='MountInstances'),
      multiAttach?: string(name='MultiAttach'),
      operationLocks?: {
        operationLock?: [ 
        {
          lockReason?: string(name='LockReason'),
        }
      ](name='OperationLock')
      }(name='OperationLocks'),
      performanceLevel?: string(name='PerformanceLevel'),
      portable?: boolean(name='Portable'),
      productCode?: string(name='ProductCode'),
      provisionedIops?: long(name='ProvisionedIops'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      serialNumber?: string(name='SerialNumber'),
      size?: int32(name='Size'),
      sourceSnapshotId?: string(name='SourceSnapshotId'),
      status?: string(name='Status'),
      storageClusterId?: string(name='StorageClusterId'),
      storageSetId?: string(name='StorageSetId'),
      storageSetPartitionNumber?: int32(name='StorageSetPartitionNumber'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
      throughput?: int32(name='Throughput'),
      type?: string(name='Type'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Disk')
  }(name='Disks'),
  nextToken?: string(name='NextToken'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeDisksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDisksResponseBody(name='body'),
}

async function describeDisks(request: DescribeDisksRequest): DescribeDisksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDisks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDisksFullStatusRequest {
  eventTime?: {
    end?: string(name='End'),
    start?: string(name='Start'),
  }(name='EventTime', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  diskId?: [ string ](name='DiskId', position='Query'),
  eventId?: [ string ](name='EventId', position='Query'),
  eventType?: string(name='EventType', position='Query'),
  healthStatus?: string(name='HealthStatus', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: string(name='Status', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model DescribeDisksFullStatusResponseBody = {
  diskFullStatusSet?: {
    diskFullStatusType?: [ 
    {
      device?: string(name='Device'),
      diskEventSet?: {
        diskEventType?: [ 
        {
          eventEndTime?: string(name='EventEndTime'),
          eventId?: string(name='EventId'),
          eventTime?: string(name='EventTime'),
          eventType?: {
            code?: int32(name='Code'),
            name?: string(name='Name'),
          }(name='EventType'),
          impactLevel?: string(name='ImpactLevel'),
        }
      ](name='DiskEventType')
      }(name='DiskEventSet'),
      diskId?: string(name='DiskId'),
      healthStatus?: {
        code?: int32(name='Code'),
        name?: string(name='Name'),
      }(name='HealthStatus'),
      instanceId?: string(name='InstanceId'),
      status?: {
        code?: int32(name='Code'),
        name?: string(name='Name'),
      }(name='Status'),
    }
  ](name='DiskFullStatusType')
  }(name='DiskFullStatusSet'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeDisksFullStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDisksFullStatusResponseBody(name='body'),
}

async function describeDisksFullStatus(request: DescribeDisksFullStatusRequest): DescribeDisksFullStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDisksFullStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeEipAddressesRequest {
  filter?: [
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filter', position='Query'),
  allocationId?: string(name='AllocationId', position='Query'),
  associatedInstanceId?: string(name='AssociatedInstanceId', position='Query'),
  associatedInstanceType?: string(name='AssociatedInstanceType', position='Query'),
  chargeType?: string(name='ChargeType', position='Query'),
  eipAddress?: string(name='EipAddress', position='Query'),
  ISP?: string(name='ISP', position='Query'),
  lockReason?: string(name='LockReason', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: string(name='Status', position='Query'),
}

model DescribeEipAddressesResponseBody = {
  eipAddresses?: {
    eipAddress?: [ 
    {
      allocationId?: string(name='AllocationId'),
      allocationTime?: string(name='AllocationTime'),
      bandwidth?: string(name='Bandwidth'),
      chargeType?: string(name='ChargeType'),
      eipBandwidth?: string(name='EipBandwidth'),
      expiredTime?: string(name='ExpiredTime'),
      instanceId?: string(name='InstanceId'),
      instanceType?: string(name='InstanceType'),
      internetChargeType?: string(name='InternetChargeType'),
      ipAddress?: string(name='IpAddress'),
      operationLocks?: {
        lockReason?: [ 
        {
          lockReason?: string(name='LockReason'),
        }
      ](name='LockReason')
      }(name='OperationLocks'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
    }
  ](name='EipAddress')
  }(name='EipAddresses'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeEipAddressesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEipAddressesResponseBody(name='body'),
}

async function describeEipAddresses(request: DescribeEipAddressesRequest): DescribeEipAddressesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEipAddresses', 'POST', '/', 'json', false, 'json', request);
}

model DescribeEipMonitorDataRequest {
  allocationId: string(name='AllocationId', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeEipMonitorDataResponseBody = {
  eipMonitorDatas?: {
    eipMonitorData?: [ 
    {
      eipBandwidth?: int32(name='EipBandwidth'),
      eipFlow?: int32(name='EipFlow'),
      eipPackets?: int32(name='EipPackets'),
      eipRX?: int32(name='EipRX'),
      eipTX?: int32(name='EipTX'),
      timeStamp?: string(name='TimeStamp'),
    }
  ](name='EipMonitorData')
  }(name='EipMonitorDatas'),
  requestId?: string(name='RequestId'),
}

model DescribeEipMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEipMonitorDataResponseBody(name='body'),
}

async function describeEipMonitorData(request: DescribeEipMonitorDataRequest): DescribeEipMonitorDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEipMonitorData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeElasticityAssuranceInstancesRequest {
  privatePoolOptions?: {
    id: string(name='Id'),
  }(name='PrivatePoolOptions', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeElasticityAssuranceInstancesResponseBody = {
  elasticityAssuranceItem?: {
    instanceIdSet?: [ 
    {
      instanceId?: string(name='InstanceId'),
    }
  ](name='InstanceIdSet')
  }(name='ElasticityAssuranceItem'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeElasticityAssuranceInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeElasticityAssuranceInstancesResponseBody(name='body'),
}

async function describeElasticityAssuranceInstances(request: DescribeElasticityAssuranceInstancesRequest): DescribeElasticityAssuranceInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeElasticityAssuranceInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeElasticityAssurancesRequest {
  privatePoolOptions?: {
    ids?: string(name='Ids'),
  }(name='PrivatePoolOptions', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  platform?: string(name='Platform', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: string(name='Status', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeElasticityAssurancesResponseBody = {
  elasticityAssuranceSet?: {
    elasticityAssuranceItem?: [ 
    {
      allocatedResources?: {
        allocatedResource?: [ 
        {
          instanceType?: string(name='InstanceType'),
          totalAmount?: int32(name='TotalAmount'),
          usedAmount?: int32(name='UsedAmount'),
          zoneId?: string(name='zoneId'),
        }
      ](name='AllocatedResource')
      }(name='AllocatedResources'),
      description?: string(name='Description'),
      endTime?: string(name='EndTime'),
      instanceChargeType?: string(name='InstanceChargeType'),
      latestStartTime?: string(name='LatestStartTime'),
      privatePoolOptionsId?: string(name='PrivatePoolOptionsId'),
      privatePoolOptionsMatchCriteria?: string(name='PrivatePoolOptionsMatchCriteria'),
      privatePoolOptionsName?: string(name='PrivatePoolOptionsName'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      startTime?: string(name='StartTime'),
      startTimeType?: string(name='StartTimeType'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
      totalAssuranceTimes?: string(name='TotalAssuranceTimes'),
      usedAssuranceTimes?: int32(name='UsedAssuranceTimes'),
    }
  ](name='ElasticityAssuranceItem')
  }(name='ElasticityAssuranceSet'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeElasticityAssurancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeElasticityAssurancesResponseBody(name='body'),
}

async function describeElasticityAssurances(request: DescribeElasticityAssurancesRequest): DescribeElasticityAssurancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeElasticityAssurances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeEniMonitorDataRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  endTime: string(name='EndTime', position='Query'),
  eniId?: string(name='EniId', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeEniMonitorDataResponseBody = {
  monitorData?: {
    eniMonitorData?: [ 
    {
      dropPacketRx?: string(name='DropPacketRx'),
      dropPacketTx?: string(name='DropPacketTx'),
      eniId?: string(name='EniId'),
      intranetRx?: string(name='IntranetRx'),
      intranetTx?: string(name='IntranetTx'),
      packetRx?: string(name='PacketRx'),
      packetTx?: string(name='PacketTx'),
      timeStamp?: string(name='TimeStamp'),
    }
  ](name='EniMonitorData')
  }(name='MonitorData'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeEniMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEniMonitorDataResponseBody(name='body'),
}

async function describeEniMonitorData(request: DescribeEniMonitorDataRequest): DescribeEniMonitorDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEniMonitorData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeForwardTableEntriesRequest {
  forwardEntryId?: string(name='ForwardEntryId', position='Query'),
  forwardTableId: string(name='ForwardTableId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeForwardTableEntriesResponseBody = {
  forwardTableEntries?: {
    forwardTableEntry?: [ 
    {
      externalIp?: string(name='ExternalIp'),
      externalPort?: string(name='ExternalPort'),
      forwardEntryId?: string(name='ForwardEntryId'),
      forwardTableId?: string(name='ForwardTableId'),
      internalIp?: string(name='InternalIp'),
      internalPort?: string(name='InternalPort'),
      ipProtocol?: string(name='IpProtocol'),
      status?: string(name='Status'),
    }
  ](name='ForwardTableEntry')
  }(name='ForwardTableEntries'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeForwardTableEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeForwardTableEntriesResponseBody(name='body'),
}

async function describeForwardTableEntries(request: DescribeForwardTableEntriesRequest): DescribeForwardTableEntriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeForwardTableEntries', 'POST', '/', 'json', false, 'json', request);
}

model DescribeHaVipsRequest {
  filter: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeHaVipsResponseBody = {
  haVips?: {
    haVip?: [ 
    {
      associatedEipAddresses?: {
        associatedEipAddresse?: [ string ](name='associatedEipAddresse')
      }(name='AssociatedEipAddresses'),
      associatedInstances?: {
        associatedInstance?: [ string ](name='associatedInstance')
      }(name='AssociatedInstances'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      haVipId?: string(name='HaVipId'),
      ipAddress?: string(name='IpAddress'),
      masterInstanceId?: string(name='MasterInstanceId'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      vSwitchId?: string(name='VSwitchId'),
      vpcId?: string(name='VpcId'),
    }
  ](name='HaVip')
  }(name='HaVips'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeHaVipsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHaVipsResponseBody(name='body'),
}

async function describeHaVips(request: DescribeHaVipsRequest): DescribeHaVipsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeHaVips', 'POST', '/', 'json', false, 'json', request);
}

model DescribeHpcClustersRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  hpcClusterIds?: string(name='HpcClusterIds', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeHpcClustersResponseBody = {
  hpcClusters?: {
    hpcCluster?: [ 
    {
      description?: string(name='Description'),
      hpcClusterId?: string(name='HpcClusterId'),
      name?: string(name='Name'),
    }
  ](name='HpcCluster')
  }(name='HpcClusters'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeHpcClustersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHpcClustersResponseBody(name='body'),
}

async function describeHpcClusters(request: DescribeHpcClustersRequest): DescribeHpcClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeHpcClusters', 'POST', '/', 'json', false, 'json', request);
}

model DescribeImageComponentsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  imageComponentId?: [ string ](name='ImageComponentId', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=500, position='Query'),
  name?: string(name='Name', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  owner?: string(name='Owner', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model DescribeImageComponentsResponseBody = {
  imageComponent?: {
    imageComponentSet?: [ 
    {
      componentType?: string(name='ComponentType'),
      content?: string(name='Content'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      imageComponentId?: string(name='ImageComponentId'),
      name?: string(name='Name'),
      owner?: string(name='Owner'),
      resourceGroupId?: string(name='ResourceGroupId'),
      systemType?: string(name='SystemType'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
    }
  ](name='ImageComponentSet')
  }(name='ImageComponent'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeImageComponentsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImageComponentsResponseBody(name='body'),
}

async function describeImageComponents(request: DescribeImageComponentsRequest): DescribeImageComponentsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImageComponents', 'POST', '/', 'json', false, 'json', request);
}

model DescribeImageFromFamilyRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  imageFamily: string(name='ImageFamily', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeImageFromFamilyResponseBody = {
  image?: {
    architecture?: string(name='Architecture'),
    creationTime?: string(name='CreationTime'),
    description?: string(name='Description'),
    diskDeviceMappings?: {
      diskDeviceMapping?: [ 
      {
        device?: string(name='Device'),
        format?: string(name='Format'),
        importOSSBucket?: string(name='ImportOSSBucket'),
        importOSSObject?: string(name='ImportOSSObject'),
        size?: string(name='Size'),
        snapshotId?: string(name='SnapshotId'),
        type?: string(name='Type'),
      }
    ](name='DiskDeviceMapping')
    }(name='DiskDeviceMappings'),
    imageFamily?: string(name='ImageFamily'),
    imageId?: string(name='ImageId'),
    imageName?: string(name='ImageName'),
    imageOwnerAlias?: string(name='ImageOwnerAlias'),
    imageVersion?: string(name='ImageVersion'),
    isCopied?: boolean(name='IsCopied'),
    isSelfShared?: string(name='IsSelfShared'),
    isSubscribed?: boolean(name='IsSubscribed'),
    isSupportCloudinit?: boolean(name='IsSupportCloudinit'),
    isSupportIoOptimized?: boolean(name='IsSupportIoOptimized'),
    OSName?: string(name='OSName'),
    OSType?: string(name='OSType'),
    platform?: string(name='Platform'),
    productCode?: string(name='ProductCode'),
    progress?: string(name='Progress'),
    size?: int32(name='Size'),
    status?: string(name='Status'),
    tags?: {
      tag?: [ 
      {
        tagKey?: string(name='TagKey'),
        tagValue?: string(name='TagValue'),
      }
    ](name='Tag')
    }(name='Tags'),
    usage?: string(name='Usage'),
  }(name='Image'),
  requestId?: string(name='RequestId'),
}

model DescribeImageFromFamilyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImageFromFamilyResponseBody(name='body'),
}

async function describeImageFromFamily(request: DescribeImageFromFamilyRequest): DescribeImageFromFamilyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImageFromFamily', 'POST', '/', 'json', false, 'json', request);
}

model DescribeImagePipelineExecutionsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  executionId?: string(name='ExecutionId', position='Query'),
  imagePipelineId?: string(name='ImagePipelineId', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=500, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: string(name='Status', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model DescribeImagePipelineExecutionsResponseBody = {
  imagePipelineExecution?: {
    imagePipelineExecutionSet?: [ 
    {
      creationTime?: string(name='CreationTime'),
      executionId?: string(name='ExecutionId'),
      imageId?: string(name='ImageId'),
      imagePipelineId?: string(name='ImagePipelineId'),
      message?: string(name='Message'),
      modifiedTime?: string(name='ModifiedTime'),
      resourceGroupId?: string(name='ResourceGroupId'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
    }
  ](name='ImagePipelineExecutionSet')
  }(name='ImagePipelineExecution'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeImagePipelineExecutionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImagePipelineExecutionsResponseBody(name='body'),
}

async function describeImagePipelineExecutions(request: DescribeImagePipelineExecutionsRequest): DescribeImagePipelineExecutionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImagePipelineExecutions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeImagePipelinesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  imagePipelineId?: [ string ](name='ImagePipelineId', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=500, position='Query'),
  name?: string(name='Name', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model DescribeImagePipelinesResponseBody = {
  imagePipeline?: {
    imagePipelineSet?: [ 
    {
      addAccounts?: {
        addAccount?: [ string ](name='AddAccount')
      }(name='AddAccounts'),
      baseImage?: string(name='BaseImage'),
      baseImageType?: string(name='BaseImageType'),
      buildContent?: string(name='BuildContent'),
      creationTime?: string(name='CreationTime'),
      deleteInstanceOnFailure?: boolean(name='DeleteInstanceOnFailure'),
      description?: string(name='Description'),
      imageName?: string(name='ImageName'),
      imagePipelineId?: string(name='ImagePipelineId'),
      instanceType?: string(name='InstanceType'),
      internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut'),
      name?: string(name='Name'),
      resourceGroupId?: string(name='ResourceGroupId'),
      systemDiskSize?: int32(name='SystemDiskSize'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
      toRegionIds?: {
        toRegionId?: [ string ](name='ToRegionId')
      }(name='ToRegionIds'),
      vSwitchId?: string(name='VSwitchId'),
    }
  ](name='ImagePipelineSet')
  }(name='ImagePipeline'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeImagePipelinesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImagePipelinesResponseBody(name='body'),
}

async function describeImagePipelines(request: DescribeImagePipelinesRequest): DescribeImagePipelinesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImagePipelines', 'POST', '/', 'json', false, 'json', request);
}

model DescribeImageSharePermissionRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  imageId: string(name='ImageId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeImageSharePermissionResponseBody = {
  accounts?: {
    account?: [ 
    {
      aliyunId?: string(name='AliyunId'),
    }
  ](name='Account')
  }(name='Accounts'),
  imageId?: string(name='ImageId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  shareGroups?: {
    shareGroup?: [ 
    {
      group?: string(name='Group'),
    }
  ](name='ShareGroup')
  }(name='ShareGroups'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeImageSharePermissionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImageSharePermissionResponseBody(name='body'),
}

async function describeImageSharePermission(request: DescribeImageSharePermissionRequest): DescribeImageSharePermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImageSharePermission', 'POST', '/', 'json', false, 'json', request);
}

model DescribeImageSupportInstanceTypesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  actionType?: string(name='ActionType', position='Query'),
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filter', position='Query'),
  imageId?: string(name='ImageId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeImageSupportInstanceTypesResponseBody = {
  imageId?: string(name='ImageId'),
  instanceTypes?: {
    instanceType?: [ 
    {
      cpuCoreCount?: int32(name='CpuCoreCount'),
      instanceTypeFamily?: string(name='InstanceTypeFamily'),
      instanceTypeId?: string(name='InstanceTypeId'),
      memorySize?: float(name='MemorySize'),
    }
  ](name='InstanceType')
  }(name='InstanceTypes'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
}

model DescribeImageSupportInstanceTypesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImageSupportInstanceTypesResponseBody(name='body'),
}

async function describeImageSupportInstanceTypes(request: DescribeImageSupportInstanceTypesRequest): DescribeImageSupportInstanceTypesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImageSupportInstanceTypes', 'POST', '/', 'json', false, 'json', request);
}

model DescribeImagesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  actionType?: string(name='ActionType', position='Query'),
  architecture?: string(name='Architecture', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filter', position='Query'),
  imageFamily?: string(name='ImageFamily', position='Query'),
  imageId?: string(name='ImageId', position='Query'),
  imageName?: string(name='ImageName', position='Query'),
  imageOwnerAlias?: string(name='ImageOwnerAlias', position='Query'),
  imageOwnerId?: long(name='ImageOwnerId', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  isPublic?: boolean(name='IsPublic', position='Query'),
  isSupportCloudinit?: boolean(name='IsSupportCloudinit', position='Query'),
  isSupportIoOptimized?: boolean(name='IsSupportIoOptimized', position='Query'),
  OSType?: string(name='OSType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  showExpired?: boolean(name='ShowExpired', position='Query'),
  snapshotId?: string(name='SnapshotId', position='Query'),
  status?: string(name='Status', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  usage?: string(name='Usage', position='Query'),
}

model DescribeImagesResponseBody = {
  images?: {
    image?: [ 
    {
      architecture?: string(name='Architecture'),
      bootMode?: string(name='BootMode'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      detectionOptions?: {
        items?: {
          item?: [ 
          {
            name?: string(name='Name'),
            riskCode?: string(name='RiskCode'),
            riskLevel?: string(name='RiskLevel'),
            value?: string(name='Value'),
          }
        ](name='Item')
        }(name='Items'),
        status?: string(name='Status'),
      }(name='DetectionOptions'),
      diskDeviceMappings?: {
        diskDeviceMapping?: [ 
        {
          device?: string(name='Device'),
          format?: string(name='Format'),
          importOSSBucket?: string(name='ImportOSSBucket'),
          importOSSObject?: string(name='ImportOSSObject'),
          progress?: string(name='Progress'),
          remainTime?: int32(name='RemainTime'),
          size?: string(name='Size'),
          snapshotId?: string(name='SnapshotId'),
          type?: string(name='Type'),
        }
      ](name='DiskDeviceMapping')
      }(name='DiskDeviceMappings'),
      features?: {
        nvmeSupport?: string(name='NvmeSupport'),
      }(name='Features'),
      imageFamily?: string(name='ImageFamily'),
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
      imageOwnerAlias?: string(name='ImageOwnerAlias'),
      imageOwnerId?: long(name='ImageOwnerId'),
      imageVersion?: string(name='ImageVersion'),
      isCopied?: boolean(name='IsCopied'),
      isPublic?: boolean(name='IsPublic'),
      isSelfShared?: string(name='IsSelfShared'),
      isSubscribed?: boolean(name='IsSubscribed'),
      isSupportCloudinit?: boolean(name='IsSupportCloudinit'),
      isSupportIoOptimized?: boolean(name='IsSupportIoOptimized'),
      loginAsNonRootSupported?: boolean(name='LoginAsNonRootSupported'),
      OSName?: string(name='OSName'),
      OSNameEn?: string(name='OSNameEn'),
      OSType?: string(name='OSType'),
      platform?: string(name='Platform'),
      productCode?: string(name='ProductCode'),
      progress?: string(name='Progress'),
      resourceGroupId?: string(name='ResourceGroupId'),
      size?: int32(name='Size'),
      status?: string(name='Status'),
      supplierName?: string(name='SupplierName'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
      usage?: string(name='Usage'),
    }
  ](name='Image')
  }(name='Images'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeImagesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImagesResponseBody(name='body'),
}

async function describeImages(request: DescribeImagesRequest): DescribeImagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImages', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceAttachmentAttributesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceIds: string(name='InstanceIds', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeInstanceAttachmentAttributesResponseBody = {
  instances?: {
    instance?: [ 
    {
      instanceId?: string(name='InstanceId'),
      privatePoolOptionsId?: string(name='PrivatePoolOptionsId'),
      privatePoolOptionsMatchCriteria?: string(name='PrivatePoolOptionsMatchCriteria'),
    }
  ](name='Instance')
  }(name='Instances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeInstanceAttachmentAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceAttachmentAttributesResponseBody(name='body'),
}

async function describeInstanceAttachmentAttributes(request: DescribeInstanceAttachmentAttributesRequest): DescribeInstanceAttachmentAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceAttachmentAttributes', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeInstanceAttributeResponseBody = {
  clusterId?: string(name='ClusterId'),
  cpu?: int32(name='Cpu'),
  creationTime?: string(name='CreationTime'),
  creditSpecification?: string(name='CreditSpecification'),
  dedicatedHostAttribute?: {
    dedicatedHostId?: string(name='DedicatedHostId'),
    dedicatedHostName?: string(name='DedicatedHostName'),
  }(name='DedicatedHostAttribute'),
  description?: string(name='Description'),
  eipAddress?: {
    allocationId?: string(name='AllocationId'),
    bandwidth?: int32(name='Bandwidth'),
    internetChargeType?: string(name='InternetChargeType'),
    ipAddress?: string(name='IpAddress'),
  }(name='EipAddress'),
  expiredTime?: string(name='ExpiredTime'),
  hostName?: string(name='HostName'),
  imageId?: string(name='ImageId'),
  innerIpAddress?: {
    ipAddress?: [ string ](name='IpAddress')
  }(name='InnerIpAddress'),
  instanceChargeType?: string(name='InstanceChargeType'),
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  instanceType?: string(name='InstanceType'),
  internetChargeType?: string(name='InternetChargeType'),
  internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut'),
  ioOptimized?: string(name='IoOptimized'),
  memory?: int32(name='Memory'),
  operationLocks?: {
    lockReason?: [ 
    {
      lockReason?: string(name='LockReason'),
    }
  ](name='LockReason')
  }(name='OperationLocks'),
  publicIpAddress?: {
    ipAddress?: [ string ](name='IpAddress')
  }(name='PublicIpAddress'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  securityGroupIds?: {
    securityGroupId?: [ string ](name='SecurityGroupId')
  }(name='SecurityGroupIds'),
  serialNumber?: string(name='SerialNumber'),
  status?: string(name='Status'),
  stoppedMode?: string(name='StoppedMode'),
  vlanId?: string(name='VlanId'),
  vpcAttributes?: {
    natIpAddress?: string(name='NatIpAddress'),
    privateIpAddress?: {
      ipAddress?: [ string ](name='IpAddress')
    }(name='PrivateIpAddress'),
    vSwitchId?: string(name='VSwitchId'),
    vpcId?: string(name='VpcId'),
  }(name='VpcAttributes'),
  zoneId?: string(name='ZoneId'),
}

model DescribeInstanceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceAttributeResponseBody(name='body'),
}

async function describeInstanceAttribute(request: DescribeInstanceAttributeRequest): DescribeInstanceAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceAutoRenewAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId?: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: string(name='PageNumber', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  renewalStatus?: string(name='RenewalStatus', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeInstanceAutoRenewAttributeResponseBody = {
  instanceRenewAttributes?: {
    instanceRenewAttribute?: [ 
    {
      autoRenewEnabled?: boolean(name='AutoRenewEnabled'),
      duration?: int32(name='Duration'),
      instanceId?: string(name='InstanceId'),
      periodUnit?: string(name='PeriodUnit'),
      renewalStatus?: string(name='RenewalStatus'),
    }
  ](name='InstanceRenewAttribute')
  }(name='InstanceRenewAttributes'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeInstanceAutoRenewAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceAutoRenewAttributeResponseBody(name='body'),
}

async function describeInstanceAutoRenewAttribute(request: DescribeInstanceAutoRenewAttributeRequest): DescribeInstanceAutoRenewAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceAutoRenewAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceHistoryEventsRequest {
  eventPublishTime?: {
    end?: string(name='End'),
    start?: string(name='Start'),
  }(name='EventPublishTime', position='Query'),
  notBefore?: {
    end?: string(name='End'),
    start?: string(name='Start'),
  }(name='NotBefore', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  eventCycleStatus?: string(name='EventCycleStatus', position='Query'),
  eventId?: [ string ](name='EventId', position='Query'),
  eventType?: string(name='EventType', position='Query'),
  impactLevel?: string(name='ImpactLevel', position='Query'),
  instanceEventCycleStatus?: [ string ](name='InstanceEventCycleStatus', position='Query'),
  instanceEventType?: [ string ](name='InstanceEventType', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceId?: [ string ](name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model DescribeInstanceHistoryEventsResponseBody = {
  instanceSystemEventSet?: {
    instanceSystemEventType?: [ 
    {
      eventCycleStatus?: {
        code?: int32(name='Code'),
        name?: string(name='Name'),
      }(name='EventCycleStatus'),
      eventFinishTime?: string(name='EventFinishTime'),
      eventId?: string(name='EventId'),
      eventPublishTime?: string(name='EventPublishTime'),
      eventType?: {
        code?: int32(name='Code'),
        name?: string(name='Name'),
      }(name='EventType'),
      extendedAttribute?: {
        device?: string(name='Device'),
        diskId?: string(name='DiskId'),
        hostId?: string(name='HostId'),
        hostType?: string(name='HostType'),
        inactiveDisks?: {
          inactiveDisk?: [ 
          {
            creationTime?: string(name='CreationTime'),
            deviceCategory?: string(name='DeviceCategory'),
            deviceSize?: string(name='DeviceSize'),
            deviceType?: string(name='DeviceType'),
            releaseTime?: string(name='ReleaseTime'),
          }
        ](name='InactiveDisk')
        }(name='InactiveDisks'),
        migrationOptions?: {
          migrationOption?: [ string ](name='MigrationOption')
        }(name='MigrationOptions'),
        onlineRepairPolicy?: string(name='OnlineRepairPolicy'),
        rack?: string(name='Rack'),
      }(name='ExtendedAttribute'),
      impactLevel?: string(name='ImpactLevel'),
      instanceId?: string(name='InstanceId'),
      notBefore?: string(name='NotBefore'),
      reason?: string(name='Reason'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='InstanceSystemEventType')
  }(name='InstanceSystemEventSet'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeInstanceHistoryEventsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceHistoryEventsResponseBody(name='body'),
}

async function describeInstanceHistoryEvents(request: DescribeInstanceHistoryEventsRequest): DescribeInstanceHistoryEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceHistoryEvents', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceMaintenanceAttributesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId?: [ string ](name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeInstanceMaintenanceAttributesResponseBody = {
  maintenanceAttributes?: {
    maintenanceAttribute?: [ 
    {
      actionOnMaintenance?: {
        defaultValue?: string(name='DefaultValue'),
        supportedValues?: {
          supportedValue?: [ string ](name='SupportedValue')
        }(name='SupportedValues'),
        value?: string(name='Value'),
      }(name='ActionOnMaintenance'),
      instanceId?: string(name='InstanceId'),
      maintenanceWindows?: {
        maintenanceWindow?: [ 
        {
          endTime?: string(name='EndTime'),
          startTime?: string(name='StartTime'),
        }
      ](name='MaintenanceWindow')
      }(name='MaintenanceWindows'),
      notifyOnMaintenance?: boolean(name='NotifyOnMaintenance'),
    }
  ](name='MaintenanceAttribute')
  }(name='MaintenanceAttributes'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeInstanceMaintenanceAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceMaintenanceAttributesResponseBody(name='body'),
}

async function describeInstanceMaintenanceAttributes(request: DescribeInstanceMaintenanceAttributesRequest): DescribeInstanceMaintenanceAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceMaintenanceAttributes', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceModificationPriceRequest {
  systemDisk?: {
    category?: string(name='Category'),
  }(name='SystemDisk', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  dataDisk?: [ 
    {
      category?: string(name='Category'),
      performanceLevel?: string(name='PerformanceLevel'),
      size?: int32(name='Size'),
    }
  ](name='DataDisk', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeInstanceModificationPriceResponseBody = {
  priceInfo?: {
    price?: {
      currency?: string(name='Currency'),
      discountPrice?: float(name='DiscountPrice'),
      originalPrice?: float(name='OriginalPrice'),
      tradePrice?: float(name='TradePrice'),
    }(name='Price'),
    rules?: {
      rule?: [ 
      {
        description?: string(name='Description'),
        ruleId?: long(name='RuleId'),
      }
    ](name='Rule')
    }(name='Rules'),
  }(name='PriceInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceModificationPriceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceModificationPriceResponseBody(name='body'),
}

async function describeInstanceModificationPrice(request: DescribeInstanceModificationPriceRequest): DescribeInstanceModificationPriceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceModificationPrice', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceMonitorDataRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  endTime: string(name='EndTime', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeInstanceMonitorDataResponseBody = {
  monitorData?: {
    instanceMonitorData?: [ 
    {
      BPSRead?: int32(name='BPSRead'),
      BPSWrite?: int32(name='BPSWrite'),
      CPU?: int32(name='CPU'),
      CPUAdvanceCreditBalance?: float(name='CPUAdvanceCreditBalance'),
      CPUCreditBalance?: float(name='CPUCreditBalance'),
      CPUCreditUsage?: float(name='CPUCreditUsage'),
      CPUNotpaidSurplusCreditUsage?: float(name='CPUNotpaidSurplusCreditUsage'),
      IOPSRead?: int32(name='IOPSRead'),
      IOPSWrite?: int32(name='IOPSWrite'),
      instanceId?: string(name='InstanceId'),
      internetBandwidth?: int32(name='InternetBandwidth'),
      internetRX?: int32(name='InternetRX'),
      internetTX?: int32(name='InternetTX'),
      intranetBandwidth?: int32(name='IntranetBandwidth'),
      intranetRX?: int32(name='IntranetRX'),
      intranetTX?: int32(name='IntranetTX'),
      timeStamp?: string(name='TimeStamp'),
    }
  ](name='InstanceMonitorData')
  }(name='MonitorData'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceMonitorDataResponseBody(name='body'),
}

async function describeInstanceMonitorData(request: DescribeInstanceMonitorDataRequest): DescribeInstanceMonitorDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceMonitorData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceRamRoleRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceIds?: string(name='InstanceIds', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  ramRoleName?: string(name='RamRoleName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeInstanceRamRoleResponseBody = {
  instanceRamRoleSets?: {
    instanceRamRoleSet?: [ 
    {
      instanceId?: string(name='InstanceId'),
      ramRoleName?: string(name='RamRoleName'),
    }
  ](name='InstanceRamRoleSet')
  }(name='InstanceRamRoleSets'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeInstanceRamRoleResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceRamRoleResponseBody(name='body'),
}

async function describeInstanceRamRole(request: DescribeInstanceRamRoleRequest): DescribeInstanceRamRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceRamRole', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceStatusRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  clusterId?: string(name='ClusterId', position='Query'),
  instanceId?: [ string ](name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeInstanceStatusResponseBody = {
  instanceStatuses?: {
    instanceStatus?: [ 
    {
      instanceId?: string(name='InstanceId'),
      status?: string(name='Status'),
    }
  ](name='InstanceStatus')
  }(name='InstanceStatuses'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeInstanceStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceStatusResponseBody(name='body'),
}

async function describeInstanceStatus(request: DescribeInstanceStatusRequest): DescribeInstanceStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceTopologyRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceIds?: string(name='InstanceIds', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeInstanceTopologyResponseBody = {
  requestId?: string(name='RequestId'),
  topologys?: {
    topology?: [ 
    {
      hostId?: string(name='HostId'),
      instanceId?: string(name='InstanceId'),
    }
  ](name='Topology')
  }(name='Topologys'),
}

model DescribeInstanceTopologyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceTopologyResponseBody(name='body'),
}

async function describeInstanceTopology(request: DescribeInstanceTopologyRequest): DescribeInstanceTopologyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceTopology', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceTypeFamiliesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  generation?: string(name='Generation', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeInstanceTypeFamiliesResponseBody = {
  instanceTypeFamilies?: {
    instanceTypeFamily?: [ 
    {
      generation?: string(name='Generation'),
      instanceTypeFamilyId?: string(name='InstanceTypeFamilyId'),
    }
  ](name='InstanceTypeFamily')
  }(name='InstanceTypeFamilies'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceTypeFamiliesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceTypeFamiliesResponseBody(name='body'),
}

async function describeInstanceTypeFamilies(request: DescribeInstanceTypeFamiliesRequest): DescribeInstanceTypeFamiliesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceTypeFamilies', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceTypesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  cpuArchitecture?: string(name='CpuArchitecture', position='Query'),
  GPUSpec?: string(name='GPUSpec', position='Query'),
  instanceCategory?: string(name='InstanceCategory', position='Query'),
  instanceFamilyLevel?: string(name='InstanceFamilyLevel', position='Query'),
  instanceTypeFamily?: string(name='InstanceTypeFamily', position='Query'),
  instanceTypes?: [ string ](name='InstanceTypes', position='Query'),
  localStorageCategory?: string(name='LocalStorageCategory', position='Query'),
  maxResults?: long(name='MaxResults', minimum=1, maximum=1600, position='Query'),
  maximumCpuCoreCount?: int32(name='MaximumCpuCoreCount', position='Query'),
  maximumCpuSpeedFrequency?: float(name='MaximumCpuSpeedFrequency', position='Query'),
  maximumCpuTurboFrequency?: float(name='MaximumCpuTurboFrequency', position='Query'),
  maximumGPUAmount?: int32(name='MaximumGPUAmount', position='Query'),
  maximumMemorySize?: float(name='MaximumMemorySize', position='Query'),
  minimumBaselineCredit?: int32(name='MinimumBaselineCredit', position='Query'),
  minimumCpuCoreCount?: int32(name='MinimumCpuCoreCount', position='Query'),
  minimumCpuSpeedFrequency?: float(name='MinimumCpuSpeedFrequency', position='Query'),
  minimumCpuTurboFrequency?: float(name='MinimumCpuTurboFrequency', position='Query'),
  minimumDiskQuantity?: int32(name='MinimumDiskQuantity', position='Query'),
  minimumEniIpv6AddressQuantity?: int32(name='MinimumEniIpv6AddressQuantity', position='Query'),
  minimumEniPrivateIpAddressQuantity?: int32(name='MinimumEniPrivateIpAddressQuantity', position='Query'),
  minimumEniQuantity?: int32(name='MinimumEniQuantity', position='Query'),
  minimumEriQuantity?: int32(name='MinimumEriQuantity', position='Query'),
  minimumGPUAmount?: int32(name='MinimumGPUAmount', position='Query'),
  minimumInitialCredit?: int32(name='MinimumInitialCredit', position='Query'),
  minimumInstanceBandwidthRx?: int32(name='MinimumInstanceBandwidthRx', position='Query'),
  minimumInstanceBandwidthTx?: int32(name='MinimumInstanceBandwidthTx', position='Query'),
  minimumInstancePpsRx?: long(name='MinimumInstancePpsRx', position='Query'),
  minimumInstancePpsTx?: long(name='MinimumInstancePpsTx', position='Query'),
  minimumLocalStorageAmount?: int32(name='MinimumLocalStorageAmount', position='Query'),
  minimumLocalStorageCapacity?: long(name='MinimumLocalStorageCapacity', position='Query'),
  minimumMemorySize?: float(name='MinimumMemorySize', position='Query'),
  minimumPrimaryEniQueueNumber?: int32(name='MinimumPrimaryEniQueueNumber', position='Query'),
  minimumQueuePairNumber?: int32(name='MinimumQueuePairNumber', position='Query'),
  minimumSecondaryEniQueueNumber?: int32(name='MinimumSecondaryEniQueueNumber', position='Query'),
  nextToken?: string(name='NextToken', maxLength=50, position='Query'),
  nvmeSupport?: string(name='NvmeSupport', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  physicalProcessorModel?: string(name='PhysicalProcessorModel', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeInstanceTypesResponseBody = {
  instanceTypes?: {
    instanceType?: [ 
    {
      baselineCredit?: int32(name='BaselineCredit'),
      cpuArchitecture?: string(name='CpuArchitecture'),
      cpuCoreCount?: int32(name='CpuCoreCount'),
      cpuSpeedFrequency?: float(name='CpuSpeedFrequency'),
      cpuTurboFrequency?: float(name='CpuTurboFrequency'),
      diskQuantity?: int32(name='DiskQuantity'),
      eniIpv6AddressQuantity?: int32(name='EniIpv6AddressQuantity'),
      eniPrivateIpAddressQuantity?: int32(name='EniPrivateIpAddressQuantity'),
      eniQuantity?: int32(name='EniQuantity'),
      eniTotalQuantity?: int32(name='EniTotalQuantity'),
      eniTrunkSupported?: boolean(name='EniTrunkSupported'),
      eriQuantity?: int32(name='EriQuantity'),
      GPUAmount?: int32(name='GPUAmount'),
      GPUSpec?: string(name='GPUSpec'),
      initialCredit?: int32(name='InitialCredit'),
      instanceBandwidthRx?: int32(name='InstanceBandwidthRx'),
      instanceBandwidthTx?: int32(name='InstanceBandwidthTx'),
      instanceCategory?: string(name='InstanceCategory'),
      instanceFamilyLevel?: string(name='InstanceFamilyLevel'),
      instancePpsRx?: long(name='InstancePpsRx'),
      instancePpsTx?: long(name='InstancePpsTx'),
      instanceTypeFamily?: string(name='InstanceTypeFamily'),
      instanceTypeId?: string(name='InstanceTypeId'),
      localStorageAmount?: int32(name='LocalStorageAmount'),
      localStorageCapacity?: long(name='LocalStorageCapacity'),
      localStorageCategory?: string(name='LocalStorageCategory'),
      maximumQueueNumberPerEni?: int32(name='MaximumQueueNumberPerEni'),
      memorySize?: float(name='MemorySize'),
      networkEncryptionSupport?: boolean(name='NetworkEncryptionSupport'),
      nvmeSupport?: string(name='NvmeSupport'),
      physicalProcessorModel?: string(name='PhysicalProcessorModel'),
      primaryEniQueueNumber?: int32(name='PrimaryEniQueueNumber'),
      queuePairNumber?: int32(name='QueuePairNumber'),
      secondaryEniQueueNumber?: int32(name='SecondaryEniQueueNumber'),
      totalEniQueueQuantity?: int32(name='TotalEniQueueQuantity'),
    }
  ](name='InstanceType')
  }(name='InstanceTypes'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceTypesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceTypesResponseBody(name='body'),
}

async function describeInstanceTypes(request: DescribeInstanceTypesRequest): DescribeInstanceTypesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceTypes', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceVncPasswdRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeInstanceVncPasswdResponseBody = {
  requestId?: string(name='RequestId'),
  vncPasswd?: string(name='VncPasswd'),
}

model DescribeInstanceVncPasswdResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceVncPasswdResponseBody(name='body'),
}

async function describeInstanceVncPasswd(request: DescribeInstanceVncPasswdRequest): DescribeInstanceVncPasswdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceVncPasswd', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceVncUrlRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeInstanceVncUrlResponseBody = {
  requestId?: string(name='RequestId'),
  vncUrl?: string(name='VncUrl'),
}

model DescribeInstanceVncUrlResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceVncUrlResponseBody(name='body'),
}

async function describeInstanceVncUrl(request: DescribeInstanceVncUrlRequest): DescribeInstanceVncUrlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceVncUrl', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstancesRequest {
  filter?: [
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filter', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  additionalAttributes?: [ string ](name='AdditionalAttributes', position='Query'),
  deviceAvailable?: boolean(name='DeviceAvailable', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  eipAddresses?: string(name='EipAddresses', position='Query'),
  hpcClusterId?: string(name='HpcClusterId', position='Query'),
  httpEndpoint?: string(name='HttpEndpoint', position='Query'),
  httpPutResponseHopLimit?: int32(name='HttpPutResponseHopLimit', position='Query'),
  httpTokens?: string(name='HttpTokens', position='Query'),
  imageId?: string(name='ImageId', position='Query'),
  innerIpAddresses?: string(name='InnerIpAddresses', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  instanceIds?: string(name='InstanceIds', position='Query'),
  instanceName?: string(name='InstanceName', position='Query'),
  instanceNetworkType?: string(name='InstanceNetworkType', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  instanceTypeFamily?: string(name='InstanceTypeFamily', position='Query'),
  internetChargeType?: string(name='InternetChargeType', position='Query'),
  ioOptimized?: boolean(name='IoOptimized', position='Query'),
  ipv6Address?: [ string ](name='Ipv6Address', position='Query'),
  keyPairName?: string(name='KeyPairName', position='Query'),
  lockReason?: string(name='LockReason', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  needSaleCycle?: boolean(name='NeedSaleCycle', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  privateIpAddresses?: string(name='PrivateIpAddresses', position='Query'),
  publicIpAddresses?: string(name='PublicIpAddresses', position='Query'),
  rdmaIpAddresses?: string(name='RdmaIpAddresses', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', position='Query'),
  status?: string(name='Status', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeInstancesResponseBody = {
  instances?: {
    instance?: [ 
    {
      autoReleaseTime?: string(name='AutoReleaseTime'),
      clusterId?: string(name='ClusterId'),
      cpu?: int32(name='Cpu'),
      cpuOptions?: {
        coreCount?: int32(name='CoreCount'),
        numa?: string(name='Numa'),
        threadsPerCore?: int32(name='ThreadsPerCore'),
      }(name='CpuOptions'),
      creationTime?: string(name='CreationTime'),
      creditSpecification?: string(name='CreditSpecification'),
      dedicatedHostAttribute?: {
        dedicatedHostClusterId?: string(name='DedicatedHostClusterId'),
        dedicatedHostId?: string(name='DedicatedHostId'),
        dedicatedHostName?: string(name='DedicatedHostName'),
      }(name='DedicatedHostAttribute'),
      dedicatedInstanceAttribute?: {
        affinity?: string(name='Affinity'),
        tenancy?: string(name='Tenancy'),
      }(name='DedicatedInstanceAttribute'),
      deletionProtection?: boolean(name='DeletionProtection'),
      deploymentSetGroupNo?: int32(name='DeploymentSetGroupNo'),
      deploymentSetId?: string(name='DeploymentSetId'),
      description?: string(name='Description'),
      deviceAvailable?: boolean(name='DeviceAvailable'),
      ecsCapacityReservationAttr?: {
        capacityReservationId?: string(name='CapacityReservationId'),
        capacityReservationPreference?: string(name='CapacityReservationPreference'),
      }(name='EcsCapacityReservationAttr'),
      eipAddress?: {
        allocationId?: string(name='AllocationId'),
        bandwidth?: int32(name='Bandwidth'),
        internetChargeType?: string(name='InternetChargeType'),
        ipAddress?: string(name='IpAddress'),
        isSupportUnassociate?: boolean(name='IsSupportUnassociate'),
      }(name='EipAddress'),
      expiredTime?: string(name='ExpiredTime'),
      GPUAmount?: int32(name='GPUAmount'),
      GPUSpec?: string(name='GPUSpec'),
      hibernationOptions?: {
        configured?: boolean(name='Configured'),
      }(name='HibernationOptions'),
      hostName?: string(name='HostName'),
      hpcClusterId?: string(name='HpcClusterId'),
      ISP?: string(name='ISP'),
      imageId?: string(name='ImageId'),
      imageOptions?: {
        loginAsNonRoot?: boolean(name='LoginAsNonRoot'),
      }(name='ImageOptions'),
      innerIpAddress?: {
        ipAddress?: [ string ](name='IpAddress')
      }(name='InnerIpAddress'),
      instanceChargeType?: string(name='InstanceChargeType'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      instanceNetworkType?: string(name='InstanceNetworkType'),
      instanceType?: string(name='InstanceType'),
      instanceTypeFamily?: string(name='InstanceTypeFamily'),
      internetChargeType?: string(name='InternetChargeType'),
      internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn'),
      internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut'),
      ioOptimized?: boolean(name='IoOptimized'),
      keyPairName?: string(name='KeyPairName'),
      localStorageAmount?: int32(name='LocalStorageAmount'),
      localStorageCapacity?: long(name='LocalStorageCapacity'),
      memory?: int32(name='Memory'),
      metadataOptions?: {
        httpEndpoint?: string(name='HttpEndpoint'),
        httpPutResponseHopLimit?: int32(name='HttpPutResponseHopLimit'),
        httpTokens?: string(name='HttpTokens'),
      }(name='MetadataOptions'),
      networkInterfaces?: {
        networkInterface?: [ 
        {
          ipv6Sets?: {
            ipv6Set?: [ 
            {
              ipv6Address?: string(name='Ipv6Address'),
            }
          ](name='Ipv6Set')
          }(name='Ipv6Sets'),
          macAddress?: string(name='MacAddress'),
          networkInterfaceId?: string(name='NetworkInterfaceId'),
          primaryIpAddress?: string(name='PrimaryIpAddress'),
          privateIpSets?: {
            privateIpSet?: [ 
            {
              primary?: boolean(name='Primary'),
              privateIpAddress?: string(name='PrivateIpAddress'),
            }
          ](name='PrivateIpSet')
          }(name='PrivateIpSets'),
          type?: string(name='Type'),
        }
      ](name='NetworkInterface')
      }(name='NetworkInterfaces'),
      OSName?: string(name='OSName'),
      OSNameEn?: string(name='OSNameEn'),
      OSType?: string(name='OSType'),
      operationLocks?: {
        lockReason?: [ 
        {
          lockMsg?: string(name='LockMsg'),
          lockReason?: string(name='LockReason'),
        }
      ](name='LockReason')
      }(name='OperationLocks'),
      publicIpAddress?: {
        ipAddress?: [ string ](name='IpAddress')
      }(name='PublicIpAddress'),
      rdmaIpAddress?: {
        ipAddress?: [ string ](name='IpAddress')
      }(name='RdmaIpAddress'),
      recyclable?: boolean(name='Recyclable'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      saleCycle?: string(name='SaleCycle'),
      securityGroupIds?: {
        securityGroupId?: [ string ](name='SecurityGroupId')
      }(name='SecurityGroupIds'),
      serialNumber?: string(name='SerialNumber'),
      spotDuration?: int32(name='SpotDuration'),
      spotPriceLimit?: float(name='SpotPriceLimit'),
      spotStrategy?: string(name='SpotStrategy'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
      stoppedMode?: string(name='StoppedMode'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
      vlanId?: string(name='VlanId'),
      vpcAttributes?: {
        natIpAddress?: string(name='NatIpAddress'),
        privateIpAddress?: {
          ipAddress?: [ string ](name='IpAddress')
        }(name='PrivateIpAddress'),
        vSwitchId?: string(name='VSwitchId'),
        vpcId?: string(name='VpcId'),
      }(name='VpcAttributes'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Instance')
  }(name='Instances'),
  nextToken?: string(name='NextToken'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstancesResponseBody(name='body'),
}

async function describeInstances(request: DescribeInstancesRequest): DescribeInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstancesFullStatusRequest {
  eventPublishTime?: {
    end?: string(name='End'),
    start?: string(name='Start'),
  }(name='EventPublishTime', position='Query'),
  notBefore?: {
    end?: string(name='End'),
    start?: string(name='Start'),
  }(name='NotBefore', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  eventId?: [ string ](name='EventId', position='Query'),
  eventType?: string(name='EventType', position='Query'),
  healthStatus?: string(name='HealthStatus', position='Query'),
  instanceEventType?: [ string ](name='InstanceEventType', position='Query'),
  instanceId?: [ string ](name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: string(name='Status', position='Query'),
}

model DescribeInstancesFullStatusResponseBody = {
  instanceFullStatusSet?: {
    instanceFullStatusType?: [ 
    {
      healthStatus?: {
        code?: int32(name='Code'),
        name?: string(name='Name'),
      }(name='HealthStatus'),
      instanceId?: string(name='InstanceId'),
      scheduledSystemEventSet?: {
        scheduledSystemEventType?: [ 
        {
          eventCycleStatus?: {
            code?: int32(name='Code'),
            name?: string(name='Name'),
          }(name='EventCycleStatus'),
          eventId?: string(name='EventId'),
          eventPublishTime?: string(name='EventPublishTime'),
          eventType?: {
            code?: int32(name='Code'),
            name?: string(name='Name'),
          }(name='EventType'),
          extendedAttribute?: {
            device?: string(name='Device'),
            diskId?: string(name='DiskId'),
            inactiveDisks?: {
              inactiveDisk?: [ 
              {
                creationTime?: string(name='CreationTime'),
                deviceCategory?: string(name='DeviceCategory'),
                deviceSize?: string(name='DeviceSize'),
                deviceType?: string(name='DeviceType'),
                releaseTime?: string(name='ReleaseTime'),
              }
            ](name='InactiveDisk')
            }(name='InactiveDisks'),
          }(name='ExtendedAttribute'),
          impactLevel?: string(name='ImpactLevel'),
          notBefore?: string(name='NotBefore'),
          reason?: string(name='Reason'),
        }
      ](name='ScheduledSystemEventType')
      }(name='ScheduledSystemEventSet'),
      status?: {
        code?: int32(name='Code'),
        name?: string(name='Name'),
      }(name='Status'),
    }
  ](name='InstanceFullStatusType')
  }(name='InstanceFullStatusSet'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeInstancesFullStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstancesFullStatusResponseBody(name='body'),
}

async function describeInstancesFullStatus(request: DescribeInstancesFullStatusRequest): DescribeInstancesFullStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstancesFullStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInvocationResultsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  commandId?: string(name='CommandId', position='Query'),
  contentEncoding?: string(name='ContentEncoding', position='Query'),
  includeHistory?: boolean(name='IncludeHistory', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  invokeId?: string(name='InvokeId', position='Query'),
  invokeRecordStatus?: string(name='InvokeRecordStatus', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model DescribeInvocationResultsResponseBody = {
  invocation?: {
    invocationResults?: {
      invocationResult?: [ 
      {
        commandId?: string(name='CommandId'),
        containerId?: string(name='ContainerId'),
        containerName?: string(name='ContainerName'),
        dropped?: int32(name='Dropped'),
        errorCode?: string(name='ErrorCode'),
        errorInfo?: string(name='ErrorInfo'),
        exitCode?: long(name='ExitCode'),
        finishedTime?: string(name='FinishedTime'),
        instanceId?: string(name='InstanceId'),
        invocationStatus?: string(name='InvocationStatus'),
        invokeId?: string(name='InvokeId'),
        invokeRecordStatus?: string(name='InvokeRecordStatus'),
        output?: string(name='Output'),
        repeats?: int32(name='Repeats'),
        startTime?: string(name='StartTime'),
        stopTime?: string(name='StopTime'),
        tags?: {
          tag?: [ 
          {
            tagKey?: string(name='TagKey'),
            tagValue?: string(name='TagValue'),
          }
        ](name='Tag')
        }(name='Tags'),
        username?: string(name='Username'),
      }
    ](name='InvocationResult')
    }(name='InvocationResults'),
    pageNumber?: long(name='PageNumber'),
    pageSize?: long(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='Invocation'),
  requestId?: string(name='RequestId'),
}

model DescribeInvocationResultsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInvocationResultsResponseBody(name='body'),
}

async function describeInvocationResults(request: DescribeInvocationResultsRequest): DescribeInvocationResultsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInvocationResults', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInvocationsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  commandId?: string(name='CommandId', position='Query'),
  commandName?: string(name='CommandName', position='Query'),
  commandType?: string(name='CommandType', position='Query'),
  contentEncoding?: string(name='ContentEncoding', position='Query'),
  includeOutput?: boolean(name='IncludeOutput', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  invokeId?: string(name='InvokeId', position='Query'),
  invokeStatus?: string(name='InvokeStatus', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  repeatMode?: string(name='RepeatMode', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  timed?: boolean(name='Timed', position='Query'),
}

model DescribeInvocationsResponseBody = {
  invocations?: {
    invocation?: [ 
    {
      commandContent?: string(name='CommandContent'),
      commandDescription?: string(name='CommandDescription'),
      commandId?: string(name='CommandId'),
      commandName?: string(name='CommandName'),
      commandType?: string(name='CommandType'),
      containerId?: string(name='ContainerId'),
      containerName?: string(name='ContainerName'),
      creationTime?: string(name='CreationTime'),
      frequency?: string(name='Frequency'),
      invocationStatus?: string(name='InvocationStatus'),
      invokeId?: string(name='InvokeId'),
      invokeInstances?: {
        invokeInstance?: [ 
        {
          creationTime?: string(name='CreationTime'),
          dropped?: int32(name='Dropped'),
          errorCode?: string(name='ErrorCode'),
          errorInfo?: string(name='ErrorInfo'),
          exitCode?: long(name='ExitCode'),
          finishTime?: string(name='FinishTime'),
          instanceId?: string(name='InstanceId'),
          instanceInvokeStatus?: string(name='InstanceInvokeStatus'),
          invocationStatus?: string(name='InvocationStatus'),
          output?: string(name='Output'),
          repeats?: int32(name='Repeats'),
          startTime?: string(name='StartTime'),
          stopTime?: string(name='StopTime'),
          timed?: boolean(name='Timed'),
          updateTime?: string(name='UpdateTime'),
        }
      ](name='InvokeInstance')
      }(name='InvokeInstances'),
      invokeStatus?: string(name='InvokeStatus'),
      parameters?: string(name='Parameters'),
      repeatMode?: string(name='RepeatMode'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
      timed?: boolean(name='Timed'),
      timeout?: long(name='Timeout'),
      username?: string(name='Username'),
      workingDir?: string(name='WorkingDir'),
    }
  ](name='Invocation')
  }(name='Invocations'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeInvocationsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInvocationsResponseBody(name='body'),
}

async function describeInvocations(request: DescribeInvocationsRequest): DescribeInvocationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInvocations', 'POST', '/', 'json', false, 'json', request);
}

model DescribeKeyPairsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  keyPairFingerPrint?: string(name='KeyPairFingerPrint', position='Query'),
  keyPairName?: string(name='KeyPairName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model DescribeKeyPairsResponseBody = {
  keyPairs?: {
    keyPair?: [ 
    {
      creationTime?: string(name='CreationTime'),
      keyPairFingerPrint?: string(name='KeyPairFingerPrint'),
      keyPairName?: string(name='KeyPairName'),
      resourceGroupId?: string(name='ResourceGroupId'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
    }
  ](name='KeyPair')
  }(name='KeyPairs'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeKeyPairsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeKeyPairsResponseBody(name='body'),
}

async function describeKeyPairs(request: DescribeKeyPairsRequest): DescribeKeyPairsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeKeyPairs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLaunchTemplateVersionsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  defaultVersion?: boolean(name='DefaultVersion', position='Query'),
  detailFlag?: boolean(name='DetailFlag', position='Query'),
  launchTemplateId?: string(name='LaunchTemplateId', position='Query'),
  launchTemplateName?: string(name='LaunchTemplateName', position='Query'),
  launchTemplateVersion?: [ long ](name='LaunchTemplateVersion', position='Query'),
  maxVersion?: long(name='MaxVersion', position='Query'),
  minVersion?: long(name='MinVersion', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeLaunchTemplateVersionsResponseBody = {
  launchTemplateVersionSets?: {
    launchTemplateVersionSet?: [ 
    {
      createTime?: string(name='CreateTime'),
      createdBy?: string(name='CreatedBy'),
      defaultVersion?: boolean(name='DefaultVersion'),
      launchTemplateData?: {
        autoReleaseTime?: string(name='AutoReleaseTime'),
        dataDisks?: {
          dataDisk?: [ 
          {
            autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId'),
            burstingEnabled?: boolean(name='BurstingEnabled'),
            category?: string(name='Category'),
            deleteWithInstance?: boolean(name='DeleteWithInstance'),
            description?: string(name='Description'),
            device?: string(name='Device'),
            diskName?: string(name='DiskName'),
            encrypted?: string(name='Encrypted'),
            performanceLevel?: string(name='PerformanceLevel'),
            provisionedIops?: long(name='ProvisionedIops'),
            size?: int32(name='Size'),
            snapshotId?: string(name='SnapshotId'),
          }
        ](name='DataDisk')
        }(name='DataDisks'),
        deploymentSetId?: string(name='DeploymentSetId'),
        description?: string(name='Description'),
        enableVmOsConfig?: boolean(name='EnableVmOsConfig'),
        hostName?: string(name='HostName'),
        imageId?: string(name='ImageId'),
        imageOwnerAlias?: string(name='ImageOwnerAlias'),
        instanceChargeType?: string(name='InstanceChargeType'),
        instanceName?: string(name='InstanceName'),
        instanceType?: string(name='InstanceType'),
        internetChargeType?: string(name='InternetChargeType'),
        internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn'),
        internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut'),
        ioOptimized?: string(name='IoOptimized'),
        ipv6AddressCount?: int32(name='Ipv6AddressCount'),
        keyPairName?: string(name='KeyPairName'),
        networkInterfaces?: {
          networkInterface?: [ 
          {
            description?: string(name='Description'),
            instanceType?: string(name='InstanceType'),
            networkInterfaceName?: string(name='NetworkInterfaceName'),
            networkInterfaceTrafficMode?: string(name='NetworkInterfaceTrafficMode'),
            primaryIpAddress?: string(name='PrimaryIpAddress'),
            securityGroupId?: string(name='SecurityGroupId'),
            securityGroupIds?: {
              securityGroupId?: [ string ](name='SecurityGroupId')
            }(name='SecurityGroupIds'),
            vSwitchId?: string(name='VSwitchId'),
          }
        ](name='NetworkInterface')
        }(name='NetworkInterfaces'),
        networkType?: string(name='NetworkType'),
        passwordInherit?: boolean(name='PasswordInherit'),
        period?: int32(name='Period'),
        privateIpAddress?: string(name='PrivateIpAddress'),
        ramRoleName?: string(name='RamRoleName'),
        resourceGroupId?: string(name='ResourceGroupId'),
        securityEnhancementStrategy?: string(name='SecurityEnhancementStrategy'),
        securityGroupId?: string(name='SecurityGroupId'),
        securityGroupIds?: {
          securityGroupId?: [ string ](name='SecurityGroupId')
        }(name='SecurityGroupIds'),
        spotDuration?: int32(name='SpotDuration'),
        spotPriceLimit?: float(name='SpotPriceLimit'),
        spotStrategy?: string(name='SpotStrategy'),
        systemDisk_autoSnapshotPolicyId?: string(name='SystemDisk.AutoSnapshotPolicyId'),
        systemDisk_burstingEnabled?: boolean(name='SystemDisk.BurstingEnabled'),
        systemDisk_category?: string(name='SystemDisk.Category'),
        systemDisk_deleteWithInstance?: boolean(name='SystemDisk.DeleteWithInstance'),
        systemDisk_description?: string(name='SystemDisk.Description'),
        systemDisk_diskName?: string(name='SystemDisk.DiskName'),
        systemDisk_iops?: int32(name='SystemDisk.Iops'),
        systemDisk_performanceLevel?: string(name='SystemDisk.PerformanceLevel'),
        systemDisk_provisionedIops?: long(name='SystemDisk.ProvisionedIops'),
        systemDisk_size?: int32(name='SystemDisk.Size'),
        tags?: {
          instanceTag?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='InstanceTag')
        }(name='Tags'),
        userData?: string(name='UserData'),
        vSwitchId?: string(name='VSwitchId'),
        vpcId?: string(name='VpcId'),
        zoneId?: string(name='ZoneId'),
      }(name='LaunchTemplateData'),
      launchTemplateId?: string(name='LaunchTemplateId'),
      launchTemplateName?: string(name='LaunchTemplateName'),
      modifiedTime?: string(name='ModifiedTime'),
      versionDescription?: string(name='VersionDescription'),
      versionNumber?: long(name='VersionNumber'),
    }
  ](name='LaunchTemplateVersionSet')
  }(name='LaunchTemplateVersionSets'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeLaunchTemplateVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLaunchTemplateVersionsResponseBody(name='body'),
}

async function describeLaunchTemplateVersions(request: DescribeLaunchTemplateVersionsRequest): DescribeLaunchTemplateVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLaunchTemplateVersions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLaunchTemplatesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  launchTemplateId?: [ string ](name='LaunchTemplateId', position='Query'),
  launchTemplateName?: [ string ](name='LaunchTemplateName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  templateResourceGroupId?: string(name='TemplateResourceGroupId', position='Query'),
  templateTag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='TemplateTag', position='Query'),
}

model DescribeLaunchTemplatesResponseBody = {
  launchTemplateSets?: {
    launchTemplateSet?: [ 
    {
      createTime?: string(name='CreateTime'),
      createdBy?: string(name='CreatedBy'),
      defaultVersionNumber?: long(name='DefaultVersionNumber'),
      latestVersionNumber?: long(name='LatestVersionNumber'),
      launchTemplateId?: string(name='LaunchTemplateId'),
      launchTemplateName?: string(name='LaunchTemplateName'),
      modifiedTime?: string(name='ModifiedTime'),
      resourceGroupId?: string(name='ResourceGroupId'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
    }
  ](name='LaunchTemplateSet')
  }(name='LaunchTemplateSets'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeLaunchTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLaunchTemplatesResponseBody(name='body'),
}

async function describeLaunchTemplates(request: DescribeLaunchTemplatesRequest): DescribeLaunchTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLaunchTemplates', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLimitationRequest {
  limitation: string(name='Limitation', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeLimitationResponseBody = {
  limitation?: string(name='Limitation'),
  requestId?: string(name='RequestId'),
  value?: string(name='Value'),
}

model DescribeLimitationResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLimitationResponseBody(name='body'),
}

async function describeLimitation(request: DescribeLimitationRequest): DescribeLimitationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLimitation', 'POST', '/', 'json', false, 'json', request);
}

model DescribeManagedInstancesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  activationId?: string(name='ActivationId', position='Query'),
  instanceId?: [ string ](name='InstanceId', position='Query'),
  instanceIp?: string(name='InstanceIp', position='Query'),
  instanceName?: string(name='InstanceName', position='Query'),
  osType?: string(name='OsType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeManagedInstancesResponseBody = {
  instances?: [ 
    {
      activationId?: string(name='ActivationId'),
      agentVersion?: string(name='AgentVersion'),
      connected?: boolean(name='Connected'),
      hostname?: string(name='Hostname'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      invocationCount?: long(name='InvocationCount'),
      lastInvokedTime?: string(name='LastInvokedTime'),
      machineId?: string(name='MachineId'),
      osType?: string(name='OsType'),
      osVersion?: string(name='OsVersion'),
      registrationTime?: string(name='RegistrationTime'),
    }
  ](name='Instances'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeManagedInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeManagedInstancesResponseBody(name='body'),
}

async function describeManagedInstances(request: DescribeManagedInstancesRequest): DescribeManagedInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeManagedInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeNatGatewaysRequest {
  natGatewayId?: string(name='NatGatewayId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model DescribeNatGatewaysResponseBody = {
  natGateways?: {
    natGateway?: [ 
    {
      bandwidthPackageIds?: {
        bandwidthPackageId?: [ string ](name='BandwidthPackageId')
      }(name='BandwidthPackageIds'),
      businessStatus?: string(name='BusinessStatus'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      forwardTableIds?: {
        forwardTableId?: [ string ](name='ForwardTableId')
      }(name='ForwardTableIds'),
      instanceChargeType?: string(name='InstanceChargeType'),
      name?: string(name='Name'),
      natGatewayId?: string(name='NatGatewayId'),
      regionId?: string(name='RegionId'),
      spec?: string(name='Spec'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
    }
  ](name='NatGateway')
  }(name='NatGateways'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeNatGatewaysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNatGatewaysResponseBody(name='body'),
}

async function describeNatGateways(request: DescribeNatGatewaysRequest): DescribeNatGatewaysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNatGateways', 'POST', '/', 'json', false, 'json', request);
}

model DescribeNetworkInterfaceAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  attribute?: string(name='Attribute', position='Query'),
  networkInterfaceId: string(name='NetworkInterfaceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model DescribeNetworkInterfaceAttributeResponseBody = {
  associatedPublicIp?: {
    allocationId?: string(name='AllocationId'),
    publicIpAddress?: string(name='PublicIpAddress'),
  }(name='AssociatedPublicIp'),
  attachment?: {
    deviceIndex?: int32(name='DeviceIndex'),
    instanceId?: string(name='InstanceId'),
    memberNetworkInterfaceIds?: {
      memberNetworkInterfaceId?: [ string ](name='MemberNetworkInterfaceId')
    }(name='MemberNetworkInterfaceIds'),
    trunkNetworkInterfaceId?: string(name='TrunkNetworkInterfaceId'),
  }(name='Attachment'),
  bondInterfaceSpecification?: {
    bondMode?: string(name='BondMode'),
    slaveInterfaceSpecification?: {
      slaveInterfaceSpecificationSet?: [ 
      {
        bondNetworkInterfaceId?: string(name='BondNetworkInterfaceId'),
        slaveNetworkInterfaceId?: string(name='SlaveNetworkInterfaceId'),
        workState?: string(name='WorkState'),
      }
    ](name='SlaveInterfaceSpecificationSet')
    }(name='SlaveInterfaceSpecification'),
  }(name='BondInterfaceSpecification'),
  creationTime?: string(name='CreationTime'),
  description?: string(name='Description'),
  instanceId?: string(name='InstanceId'),
  ipv6Sets?: {
    ipv6Set?: [ 
    {
      ipv6Address?: string(name='Ipv6Address'),
    }
  ](name='Ipv6Set')
  }(name='Ipv6Sets'),
  macAddress?: string(name='MacAddress'),
  networkInterfaceId?: string(name='NetworkInterfaceId'),
  networkInterfaceName?: string(name='NetworkInterfaceName'),
  networkInterfaceTrafficMode?: string(name='NetworkInterfaceTrafficMode'),
  ownerId?: string(name='OwnerId'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  privateIpSets?: {
    privateIpSet?: [ 
    {
      associatedPublicIp?: {
        allocationId?: string(name='AllocationId'),
        publicIpAddress?: string(name='PublicIpAddress'),
      }(name='AssociatedPublicIp'),
      primary?: boolean(name='Primary'),
      privateIpAddress?: string(name='PrivateIpAddress'),
    }
  ](name='PrivateIpSet')
  }(name='PrivateIpSets'),
  queueNumber?: int32(name='QueueNumber'),
  queuePairNumber?: int32(name='QueuePairNumber'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  securityGroupIds?: {
    securityGroupId?: [ string ](name='SecurityGroupId')
  }(name='SecurityGroupIds'),
  serviceID?: long(name='ServiceID'),
  serviceManaged?: boolean(name='ServiceManaged'),
  slaveInterfaceSpecification?: {
    bondNetworkInterfaceId?: string(name='BondNetworkInterfaceId'),
    slaveNetworkInterfaceId?: string(name='SlaveNetworkInterfaceId'),
    workState?: string(name='WorkState'),
  }(name='SlaveInterfaceSpecification'),
  status?: string(name='Status'),
  tags?: {
    tag?: [ 
    {
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='Tag')
  }(name='Tags'),
  type?: string(name='Type'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeNetworkInterfaceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNetworkInterfaceAttributeResponseBody(name='body'),
}

async function describeNetworkInterfaceAttribute(request: DescribeNetworkInterfaceAttributeRequest): DescribeNetworkInterfaceAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNetworkInterfaceAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeNetworkInterfacePermissionsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  networkInterfaceId?: string(name='NetworkInterfaceId', position='Query'),
  networkInterfacePermissionId?: [ string ](name='NetworkInterfacePermissionId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeNetworkInterfacePermissionsResponseBody = {
  networkInterfacePermissions?: {
    networkInterfacePermission?: [ 
    {
      accountId?: long(name='AccountId'),
      networkInterfaceId?: string(name='NetworkInterfaceId'),
      networkInterfacePermissionId?: string(name='NetworkInterfacePermissionId'),
      permission?: string(name='Permission'),
      permissionState?: string(name='PermissionState'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='NetworkInterfacePermission')
  }(name='NetworkInterfacePermissions'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeNetworkInterfacePermissionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNetworkInterfacePermissionsResponseBody(name='body'),
}

async function describeNetworkInterfacePermissions(request: DescribeNetworkInterfacePermissionsRequest): DescribeNetworkInterfacePermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNetworkInterfacePermissions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeNetworkInterfacesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId?: string(name='InstanceId', position='Query'),
  ipv6Address?: [ string ](name='Ipv6Address', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  networkInterfaceId?: [ string ](name='NetworkInterfaceId', position='Query'),
  networkInterfaceName?: string(name='NetworkInterfaceName', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  primaryIpAddress?: string(name='PrimaryIpAddress', position='Query'),
  privateIpAddress?: [ string ](name='PrivateIpAddress', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', position='Query'),
  serviceManaged?: boolean(name='ServiceManaged', position='Query'),
  status?: string(name='Status', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  type?: string(name='Type', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model DescribeNetworkInterfacesResponseBody = {
  networkInterfaceSets?: {
    networkInterfaceSet?: [ 
    {
      associatedPublicIp?: {
        allocationId?: string(name='AllocationId'),
        publicIpAddress?: string(name='PublicIpAddress'),
      }(name='AssociatedPublicIp'),
      attachment?: {
        deviceIndex?: int32(name='DeviceIndex'),
        instanceId?: string(name='InstanceId'),
        trunkNetworkInterfaceId?: string(name='TrunkNetworkInterfaceId'),
      }(name='Attachment'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      instanceId?: string(name='InstanceId'),
      ipv6Sets?: {
        ipv6Set?: [ 
        {
          ipv6Address?: string(name='Ipv6Address'),
        }
      ](name='Ipv6Set')
      }(name='Ipv6Sets'),
      macAddress?: string(name='MacAddress'),
      networkInterfaceId?: string(name='NetworkInterfaceId'),
      networkInterfaceName?: string(name='NetworkInterfaceName'),
      networkInterfaceTrafficMode?: string(name='NetworkInterfaceTrafficMode'),
      ownerId?: string(name='OwnerId'),
      privateIpAddress?: string(name='PrivateIpAddress'),
      privateIpSets?: {
        privateIpSet?: [ 
        {
          associatedPublicIp?: {
            allocationId?: string(name='AllocationId'),
            publicIpAddress?: string(name='PublicIpAddress'),
          }(name='AssociatedPublicIp'),
          primary?: boolean(name='Primary'),
          privateIpAddress?: string(name='PrivateIpAddress'),
        }
      ](name='PrivateIpSet')
      }(name='PrivateIpSets'),
      queueNumber?: int32(name='QueueNumber'),
      queuePairNumber?: int32(name='QueuePairNumber'),
      resourceGroupId?: string(name='ResourceGroupId'),
      securityGroupIds?: {
        securityGroupId?: [ string ](name='SecurityGroupId')
      }(name='SecurityGroupIds'),
      serviceID?: long(name='ServiceID'),
      serviceManaged?: boolean(name='ServiceManaged'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
      type?: string(name='Type'),
      vSwitchId?: string(name='VSwitchId'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='NetworkInterfaceSet')
  }(name='NetworkInterfaceSets'),
  nextToken?: string(name='NextToken'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeNetworkInterfacesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNetworkInterfacesResponseBody(name='body'),
}

async function describeNetworkInterfaces(request: DescribeNetworkInterfacesRequest): DescribeNetworkInterfacesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNetworkInterfaces', 'POST', '/', 'json', false, 'json', request);
}

model DescribeNewProjectEipMonitorDataRequest {
  allocationId: string(name='AllocationId', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeNewProjectEipMonitorDataResponseBody = {
  eipMonitorDatas?: {
    eipMonitorData?: [ 
    {
      eipBandwidth?: int32(name='EipBandwidth'),
      eipFlow?: int32(name='EipFlow'),
      eipPackets?: int32(name='EipPackets'),
      eipRX?: int32(name='EipRX'),
      eipTX?: int32(name='EipTX'),
      timeStamp?: string(name='TimeStamp'),
    }
  ](name='EipMonitorData')
  }(name='EipMonitorDatas'),
  requestId?: string(name='RequestId'),
}

model DescribeNewProjectEipMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNewProjectEipMonitorDataResponseBody(name='body'),
}

async function describeNewProjectEipMonitorData(request: DescribeNewProjectEipMonitorDataRequest): DescribeNewProjectEipMonitorDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNewProjectEipMonitorData', 'POST', '/', 'json', false, 'json', request);
}

model DescribePhysicalConnectionsRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
}

model DescribePhysicalConnectionsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  physicalConnectionSet?: {
    physicalConnectionType?: [ 
    {
      accessPointId?: string(name='AccessPointId'),
      adLocation?: string(name='AdLocation'),
      bandwidth?: long(name='Bandwidth'),
      businessStatus?: string(name='BusinessStatus'),
      circuitCode?: string(name='CircuitCode'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      enabledTime?: string(name='EnabledTime'),
      lineOperator?: string(name='LineOperator'),
      name?: string(name='Name'),
      peerLocation?: string(name='PeerLocation'),
      physicalConnectionId?: string(name='PhysicalConnectionId'),
      portNumber?: string(name='PortNumber'),
      portType?: string(name='PortType'),
      redundantPhysicalConnectionId?: string(name='RedundantPhysicalConnectionId'),
      spec?: string(name='Spec'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='PhysicalConnectionType')
  }(name='PhysicalConnectionSet'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribePhysicalConnectionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePhysicalConnectionsResponseBody(name='body'),
}

async function describePhysicalConnections(request: DescribePhysicalConnectionsRequest): DescribePhysicalConnectionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePhysicalConnections', 'POST', '/', 'json', false, 'json', request);
}

model DescribePrefixListAssociationsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  prefixListId: string(name='PrefixListId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribePrefixListAssociationsResponseBody = {
  nextToken?: string(name='NextToken'),
  prefixListAssociations?: {
    prefixListAssociation?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='PrefixListAssociation')
  }(name='PrefixListAssociations'),
  requestId?: string(name='RequestId'),
}

model DescribePrefixListAssociationsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePrefixListAssociationsResponseBody(name='body'),
}

async function describePrefixListAssociations(request: DescribePrefixListAssociationsRequest): DescribePrefixListAssociationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePrefixListAssociations', 'POST', '/', 'json', false, 'json', request);
}

model DescribePrefixListAttributesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  prefixListId: string(name='PrefixListId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribePrefixListAttributesResponseBody = {
  addressFamily?: string(name='AddressFamily'),
  creationTime?: string(name='CreationTime'),
  description?: string(name='Description'),
  entries?: {
    entry?: [ 
    {
      cidr?: string(name='Cidr'),
      description?: string(name='Description'),
    }
  ](name='Entry')
  }(name='Entries'),
  maxEntries?: int32(name='MaxEntries'),
  prefixListId?: string(name='PrefixListId'),
  prefixListName?: string(name='PrefixListName'),
  requestId?: string(name='RequestId'),
}

model DescribePrefixListAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePrefixListAttributesResponseBody(name='body'),
}

async function describePrefixListAttributes(request: DescribePrefixListAttributesRequest): DescribePrefixListAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePrefixListAttributes', 'POST', '/', 'json', false, 'json', request);
}

model DescribePrefixListsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  addressFamily?: string(name='AddressFamily', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  prefixListId?: [ string ](name='PrefixListId', position='Query'),
  prefixListName?: string(name='PrefixListName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribePrefixListsResponseBody = {
  nextToken?: string(name='NextToken'),
  prefixLists?: {
    prefixList?: [ 
    {
      addressFamily?: string(name='AddressFamily'),
      associationCount?: int32(name='AssociationCount'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      maxEntries?: int32(name='MaxEntries'),
      prefixListId?: string(name='PrefixListId'),
      prefixListName?: string(name='PrefixListName'),
    }
  ](name='PrefixList')
  }(name='PrefixLists'),
  requestId?: string(name='RequestId'),
}

model DescribePrefixListsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePrefixListsResponseBody(name='body'),
}

async function describePrefixLists(request: DescribePrefixListsRequest): DescribePrefixListsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePrefixLists', 'POST', '/', 'json', false, 'json', request);
}

model DescribePriceRequest {
  dataDisk?: [
    {
      category?: string(name='Category'),
      performanceLevel?: string(name='PerformanceLevel'),
      size?: long(name='Size'),
    }
  ](name='DataDisk', position='Query'),
  systemDisk?: {
    category?: string(name='Category'),
    performanceLevel?: string(name='PerformanceLevel'),
    size?: int32(name='Size'),
  }(name='SystemDisk', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  amount?: int32(name='Amount', position='Query'),
  assuranceTimes?: string(name='AssuranceTimes', position='Query'),
  capacity?: int32(name='Capacity', position='Query'),
  dedicatedHostType?: string(name='DedicatedHostType', position='Query'),
  imageId?: string(name='ImageId', position='Query'),
  instanceAmount?: int32(name='InstanceAmount', position='Query'),
  instanceCpuCoreCount?: int32(name='InstanceCpuCoreCount', position='Query'),
  instanceNetworkType?: string(name='InstanceNetworkType', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  instanceTypeList?: [ string ](name='InstanceTypeList', position='Query'),
  internetChargeType?: string(name='InternetChargeType', position='Query'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', position='Query'),
  ioOptimized?: string(name='IoOptimized', position='Query'),
  isp?: string(name='Isp', position='Query'),
  offeringType?: string(name='OfferingType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  platform?: string(name='Platform', position='Query'),
  priceUnit?: string(name='PriceUnit', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
  scope?: string(name='Scope', position='Query'),
  spotDuration?: int32(name='SpotDuration', position='Query'),
  spotStrategy?: string(name='SpotStrategy', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribePriceResponseBody = {
  priceInfo?: {
    price?: {
      currency?: string(name='Currency'),
      detailInfos?: {
        resourcePriceModel?: [ 
        {
          discountPrice?: float(name='DiscountPrice'),
          originalPrice?: float(name='OriginalPrice'),
          resource?: string(name='Resource'),
          subRules?: {
            rule?: [ 
            {
              description?: string(name='Description'),
              ruleId?: long(name='RuleId'),
            }
          ](name='Rule')
          }(name='SubRules'),
          tradePrice?: float(name='TradePrice'),
        }
      ](name='ResourcePriceModel')
      }(name='DetailInfos'),
      discountPrice?: float(name='DiscountPrice'),
      originalPrice?: float(name='OriginalPrice'),
      reservedInstanceHourPrice?: float(name='ReservedInstanceHourPrice'),
      tradePrice?: float(name='TradePrice'),
    }(name='Price'),
    rules?: {
      rule?: [ 
      {
        description?: string(name='Description'),
        ruleId?: long(name='RuleId'),
      }
    ](name='Rule')
    }(name='Rules'),
  }(name='PriceInfo'),
  requestId?: string(name='RequestId'),
}

model DescribePriceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePriceResponseBody(name='body'),
}

async function describePrice(request: DescribePriceRequest): DescribePriceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePrice', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRecommendInstanceTypeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  cores?: int32(name='Cores', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  instanceFamilyLevel?: string(name='InstanceFamilyLevel', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  instanceTypeFamily?: [ string ](name='InstanceTypeFamily', position='Query'),
  ioOptimized?: string(name='IoOptimized', position='Query'),
  maxPrice?: float(name='MaxPrice', position='Query'),
  memory?: float(name='Memory', position='Query'),
  networkType: string(name='NetworkType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  priorityStrategy?: string(name='PriorityStrategy', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scene?: string(name='Scene', position='Query'),
  spotStrategy?: string(name='SpotStrategy', position='Query'),
  systemDiskCategory?: string(name='SystemDiskCategory', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
  zoneMatchMode?: string(name='ZoneMatchMode', position='Query'),
}

model DescribeRecommendInstanceTypeResponseBody = {
  data?: {
    recommendInstanceType?: [ 
    {
      commodityCode?: string(name='CommodityCode'),
      instanceChargeType?: string(name='InstanceChargeType'),
      instanceType?: {
        cores?: int32(name='Cores'),
        generation?: string(name='Generation'),
        instanceType?: string(name='InstanceType'),
        instanceTypeFamily?: string(name='InstanceTypeFamily'),
        memory?: int32(name='Memory'),
        supportIoOptimized?: string(name='SupportIoOptimized'),
      }(name='InstanceType'),
      networkType?: string(name='NetworkType'),
      priority?: int32(name='Priority'),
      regionId?: string(name='RegionId'),
      scene?: string(name='Scene'),
      spotStrategy?: string(name='SpotStrategy'),
      zoneId?: string(name='ZoneId'),
      zones?: {
        zone?: [ 
        {
          networkTypes?: {
            networkType?: [ string ](name='NetworkType')
          }(name='NetworkTypes'),
          zoneNo?: string(name='ZoneNo'),
        }
      ](name='zone')
      }(name='Zones'),
    }
  ](name='RecommendInstanceType')
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeRecommendInstanceTypeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRecommendInstanceTypeResponseBody(name='body'),
}

async function describeRecommendInstanceType(request: DescribeRecommendInstanceTypeRequest): DescribeRecommendInstanceTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRecommendInstanceType', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
}

model DescribeRegionsResponseBody = {
  regions?: {
    region?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
    }
  ](name='Region')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRegions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRenewalPriceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  expectedRenewDay?: int32(name='ExpectedRenewDay', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  priceUnit?: string(name='PriceUnit', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId: string(name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
}

model DescribeRenewalPriceResponseBody = {
  priceInfo?: {
    price?: {
      currency?: string(name='Currency'),
      detailInfos?: {
        resourcePriceModel?: [ 
        {
          discountPrice?: float(name='DiscountPrice'),
          originalPrice?: float(name='OriginalPrice'),
          resource?: string(name='Resource'),
          subRules?: {
            rule?: [ 
            {
              description?: string(name='Description'),
              ruleId?: long(name='RuleId'),
            }
          ](name='Rule')
          }(name='SubRules'),
          tradePrice?: float(name='TradePrice'),
        }
      ](name='ResourcePriceModel')
      }(name='DetailInfos'),
      discountPrice?: float(name='DiscountPrice'),
      originalPrice?: float(name='OriginalPrice'),
      tradePrice?: float(name='TradePrice'),
    }(name='Price'),
    rules?: {
      rule?: [ 
      {
        description?: string(name='Description'),
        ruleId?: long(name='RuleId'),
      }
    ](name='Rule')
    }(name='Rules'),
  }(name='PriceInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeRenewalPriceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRenewalPriceResponseBody(name='body'),
}

async function describeRenewalPrice(request: DescribeRenewalPriceRequest): DescribeRenewalPriceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRenewalPrice', 'POST', '/', 'json', false, 'json', request);
}

model DescribeReservedInstancesRequest {
  allocationType?: string(name='AllocationType', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  instanceTypeFamily?: string(name='InstanceTypeFamily', position='Query'),
  lockReason?: string(name='LockReason', position='Query'),
  offeringType?: string(name='OfferingType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  reservedInstanceId?: [ string ](name='ReservedInstanceId', position='Query'),
  reservedInstanceName?: string(name='ReservedInstanceName', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scope?: string(name='Scope', position='Query'),
  status?: [ string ](name='Status', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeReservedInstancesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  reservedInstances?: {
    reservedInstance?: [ 
    {
      allocationStatus?: string(name='AllocationStatus'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      expiredTime?: string(name='ExpiredTime'),
      instanceAmount?: int32(name='InstanceAmount'),
      instanceType?: string(name='InstanceType'),
      offeringType?: string(name='OfferingType'),
      operationLocks?: {
        operationLock?: [ 
        {
          lockReason?: string(name='LockReason'),
        }
      ](name='OperationLock')
      }(name='OperationLocks'),
      platform?: string(name='Platform'),
      regionId?: string(name='RegionId'),
      reservedInstanceId?: string(name='ReservedInstanceId'),
      reservedInstanceName?: string(name='ReservedInstanceName'),
      resourceGroupId?: string(name='ResourceGroupId'),
      scope?: string(name='Scope'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='ReservedInstance')
  }(name='ReservedInstances'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeReservedInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeReservedInstancesResponseBody(name='body'),
}

async function describeReservedInstances(request: DescribeReservedInstancesRequest): DescribeReservedInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeReservedInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeResourceByTagsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model DescribeResourceByTagsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  resources?: {
    resource?: [ 
    {
      regionId?: string(name='RegionId'),
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='Resource')
  }(name='Resources'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeResourceByTagsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeResourceByTagsResponseBody(name='body'),
}

async function describeResourceByTags(request: DescribeResourceByTagsRequest): DescribeResourceByTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeResourceByTags', 'POST', '/', 'json', false, 'json', request);
}

model DescribeResourcesModificationRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  cores?: int32(name='Cores', position='Query'),
  destinationResource: string(name='DestinationResource', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  memory?: float(name='Memory', position='Query'),
  migrateAcrossZone?: boolean(name='MigrateAcrossZone', position='Query'),
  operationType?: string(name='OperationType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId: string(name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeResourcesModificationResponseBody = {
  availableZones?: {
    availableZone?: [ 
    {
      availableResources?: {
        availableResource?: [ 
        {
          supportedResources?: {
            supportedResource?: [ 
            {
              max?: int32(name='Max'),
              min?: int32(name='Min'),
              status?: string(name='Status'),
              statusCategory?: string(name='StatusCategory'),
              unit?: string(name='Unit'),
              value?: string(name='Value'),
            }
          ](name='SupportedResource')
          }(name='SupportedResources'),
          type?: string(name='Type'),
        }
      ](name='AvailableResource')
      }(name='AvailableResources'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      statusCategory?: string(name='StatusCategory'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='AvailableZone')
  }(name='AvailableZones'),
  requestId?: string(name='RequestId'),
}

model DescribeResourcesModificationResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeResourcesModificationResponseBody(name='body'),
}

async function describeResourcesModification(request: DescribeResourcesModificationRequest): DescribeResourcesModificationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeResourcesModification', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRouteTablesRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeTableId?: string(name='RouteTableId', position='Query'),
  routeTableName?: string(name='RouteTableName', position='Query'),
  routerId?: string(name='RouterId', position='Query'),
  routerType?: string(name='RouterType', position='Query'),
  vRouterId?: string(name='VRouterId', position='Query'),
}

model DescribeRouteTablesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  routeTables?: {
    routeTable?: [ 
    {
      creationTime?: string(name='CreationTime'),
      resourceGroupId?: string(name='ResourceGroupId'),
      routeEntrys?: {
        routeEntry?: [ 
        {
          destinationCidrBlock?: string(name='DestinationCidrBlock'),
          instanceId?: string(name='InstanceId'),
          nextHopType?: string(name='NextHopType'),
          nextHops?: {
            nextHop?: [ 
            {
              enabled?: int32(name='Enabled'),
              nextHopId?: string(name='NextHopId'),
              nextHopType?: string(name='NextHopType'),
              weight?: int32(name='Weight'),
            }
          ](name='NextHop')
          }(name='NextHops'),
          routeTableId?: string(name='RouteTableId'),
          status?: string(name='Status'),
          type?: string(name='Type'),
        }
      ](name='RouteEntry')
      }(name='RouteEntrys'),
      routeTableId?: string(name='RouteTableId'),
      routeTableType?: string(name='RouteTableType'),
      vRouterId?: string(name='VRouterId'),
    }
  ](name='RouteTable')
  }(name='RouteTables'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeRouteTablesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRouteTablesResponseBody(name='body'),
}

async function describeRouteTables(request: DescribeRouteTablesRequest): DescribeRouteTablesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRouteTables', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRouterInterfacesRequest {
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeRouterInterfacesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  routerInterfaceSet?: {
    routerInterfaceType?: [ 
    {
      accessPointId?: string(name='AccessPointId'),
      businessStatus?: string(name='BusinessStatus'),
      chargeType?: string(name='ChargeType'),
      connectedTime?: string(name='ConnectedTime'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      endTime?: string(name='EndTime'),
      healthCheckSourceIp?: string(name='HealthCheckSourceIp'),
      healthCheckTargetIp?: string(name='HealthCheckTargetIp'),
      name?: string(name='Name'),
      oppositeAccessPointId?: string(name='OppositeAccessPointId'),
      oppositeInterfaceBusinessStatus?: string(name='OppositeInterfaceBusinessStatus'),
      oppositeInterfaceId?: string(name='OppositeInterfaceId'),
      oppositeInterfaceOwnerId?: string(name='OppositeInterfaceOwnerId'),
      oppositeInterfaceSpec?: string(name='OppositeInterfaceSpec'),
      oppositeInterfaceStatus?: string(name='OppositeInterfaceStatus'),
      oppositeRegionId?: string(name='OppositeRegionId'),
      oppositeRouterId?: string(name='OppositeRouterId'),
      oppositeRouterType?: string(name='OppositeRouterType'),
      role?: string(name='Role'),
      routerId?: string(name='RouterId'),
      routerInterfaceId?: string(name='RouterInterfaceId'),
      routerType?: string(name='RouterType'),
      spec?: string(name='Spec'),
      status?: string(name='Status'),
    }
  ](name='RouterInterfaceType')
  }(name='RouterInterfaceSet'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeRouterInterfacesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRouterInterfacesResponseBody(name='body'),
}

async function describeRouterInterfaces(request: DescribeRouterInterfacesRequest): DescribeRouterInterfacesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRouterInterfaces', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSecurityGroupAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  direction?: string(name='Direction', position='Query'),
  nicType?: string(name='NicType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId: string(name='SecurityGroupId', position='Query'),
}

model DescribeSecurityGroupAttributeResponseBody = {
  description?: string(name='Description'),
  innerAccessPolicy?: string(name='InnerAccessPolicy'),
  permissions?: {
    permission?: [ 
    {
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      destCidrIp?: string(name='DestCidrIp'),
      destGroupId?: string(name='DestGroupId'),
      destGroupName?: string(name='DestGroupName'),
      destGroupOwnerAccount?: string(name='DestGroupOwnerAccount'),
      destPrefixListId?: string(name='DestPrefixListId'),
      destPrefixListName?: string(name='DestPrefixListName'),
      direction?: string(name='Direction'),
      ipProtocol?: string(name='IpProtocol'),
      ipv6DestCidrIp?: string(name='Ipv6DestCidrIp'),
      ipv6SourceCidrIp?: string(name='Ipv6SourceCidrIp'),
      nicType?: string(name='NicType'),
      policy?: string(name='Policy'),
      portRange?: string(name='PortRange'),
      priority?: string(name='Priority'),
      sourceCidrIp?: string(name='SourceCidrIp'),
      sourceGroupId?: string(name='SourceGroupId'),
      sourceGroupName?: string(name='SourceGroupName'),
      sourceGroupOwnerAccount?: string(name='SourceGroupOwnerAccount'),
      sourcePortRange?: string(name='SourcePortRange'),
      sourcePrefixListId?: string(name='SourcePrefixListId'),
      sourcePrefixListName?: string(name='SourcePrefixListName'),
    }
  ](name='Permission')
  }(name='Permissions'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  securityGroupId?: string(name='SecurityGroupId'),
  securityGroupName?: string(name='SecurityGroupName'),
  vpcId?: string(name='VpcId'),
}

model DescribeSecurityGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSecurityGroupAttributeResponseBody(name='body'),
}

async function describeSecurityGroupAttribute(request: DescribeSecurityGroupAttributeRequest): DescribeSecurityGroupAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSecurityGroupAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSecurityGroupReferencesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId: [ string ](name='SecurityGroupId', position='Query'),
}

model DescribeSecurityGroupReferencesResponseBody = {
  requestId?: string(name='RequestId'),
  securityGroupReferences?: {
    securityGroupReference?: [ 
    {
      referencingSecurityGroups?: {
        referencingSecurityGroup?: [ 
        {
          aliUid?: string(name='AliUid'),
          securityGroupId?: string(name='SecurityGroupId'),
        }
      ](name='ReferencingSecurityGroup')
      }(name='ReferencingSecurityGroups'),
      securityGroupId?: string(name='SecurityGroupId'),
    }
  ](name='SecurityGroupReference')
  }(name='SecurityGroupReferences'),
}

model DescribeSecurityGroupReferencesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSecurityGroupReferencesResponseBody(name='body'),
}

async function describeSecurityGroupReferences(request: DescribeSecurityGroupReferencesRequest): DescribeSecurityGroupReferencesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSecurityGroupReferences', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSecurityGroupsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  dryRun?: boolean(name='DryRun', position='Query'),
  fuzzyQuery?: boolean(name='FuzzyQuery', position='Query'),
  isQueryEcsCount?: boolean(name='IsQueryEcsCount', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  networkType?: string(name='NetworkType', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', position='Query'),
  securityGroupIds?: string(name='SecurityGroupIds', position='Query'),
  securityGroupName?: string(name='SecurityGroupName', position='Query'),
  securityGroupType?: string(name='SecurityGroupType', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model DescribeSecurityGroupsResponseBody = {
  nextToken?: string(name='NextToken'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  securityGroups?: {
    securityGroup?: [ 
    {
      availableInstanceAmount?: int32(name='AvailableInstanceAmount'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      ecsCount?: int32(name='EcsCount'),
      resourceGroupId?: string(name='ResourceGroupId'),
      securityGroupId?: string(name='SecurityGroupId'),
      securityGroupName?: string(name='SecurityGroupName'),
      securityGroupType?: string(name='SecurityGroupType'),
      serviceID?: long(name='ServiceID'),
      serviceManaged?: boolean(name='ServiceManaged'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
      vpcId?: string(name='VpcId'),
    }
  ](name='SecurityGroup')
  }(name='SecurityGroups'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSecurityGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSecurityGroupsResponseBody(name='body'),
}

async function describeSecurityGroups(request: DescribeSecurityGroupsRequest): DescribeSecurityGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSecurityGroups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSendFileResultsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId?: string(name='InstanceId', position='Query'),
  invokeId?: string(name='InvokeId', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeSendFileResultsResponseBody = {
  invocations?: {
    invocation?: [ 
    {
      content?: string(name='Content'),
      contentType?: string(name='ContentType'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      fileGroup?: string(name='FileGroup'),
      fileMode?: string(name='FileMode'),
      fileOwner?: string(name='FileOwner'),
      invocationStatus?: string(name='InvocationStatus'),
      invokeId?: string(name='InvokeId'),
      invokeInstances?: {
        invokeInstance?: [ 
        {
          creationTime?: string(name='CreationTime'),
          errorCode?: string(name='ErrorCode'),
          errorInfo?: string(name='ErrorInfo'),
          finishTime?: string(name='FinishTime'),
          instanceId?: string(name='InstanceId'),
          invocationStatus?: string(name='InvocationStatus'),
          startTime?: string(name='StartTime'),
          updateTime?: string(name='UpdateTime'),
        }
      ](name='InvokeInstance')
      }(name='InvokeInstances'),
      name?: string(name='Name'),
      overwrite?: string(name='Overwrite'),
      targetDir?: string(name='TargetDir'),
      vmCount?: int32(name='VmCount'),
    }
  ](name='Invocation')
  }(name='Invocations'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeSendFileResultsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSendFileResultsResponseBody(name='body'),
}

async function describeSendFileResults(request: DescribeSendFileResultsRequest): DescribeSendFileResultsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSendFileResults', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSnapshotGroupsRequest {
  additionalAttributes?: [ string ](name='AdditionalAttributes', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=500, position='Query'),
  name?: string(name='Name', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  snapshotGroupId?: [ string ](name='SnapshotGroupId', position='Query'),
  status?: [ string ](name='Status', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model DescribeSnapshotGroupsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  snapshotGroups?: {
    snapshotGroup?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      instanceId?: string(name='InstanceId'),
      name?: string(name='Name'),
      progressStatus?: string(name='ProgressStatus'),
      resourceGroupId?: string(name='ResourceGroupId'),
      snapshotGroupId?: string(name='SnapshotGroupId'),
      snapshots?: {
        snapshot?: [ 
        {
          instantAccess?: boolean(name='InstantAccess'),
          instantAccessRetentionDays?: int32(name='InstantAccessRetentionDays'),
          progress?: string(name='Progress'),
          snapshotId?: string(name='SnapshotId'),
          sourceDiskId?: string(name='SourceDiskId'),
          sourceDiskType?: string(name='SourceDiskType'),
          tags?: {
            tag?: [ 
            {
              key?: string(name='Key'),
              value?: string(name='Value'),
            }
          ](name='Tag')
          }(name='Tags'),
        }
      ](name='Snapshot')
      }(name='Snapshots'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
    }
  ](name='SnapshotGroup')
  }(name='SnapshotGroups'),
}

model DescribeSnapshotGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSnapshotGroupsResponseBody(name='body'),
}

async function describeSnapshotGroups(request: DescribeSnapshotGroupsRequest): DescribeSnapshotGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSnapshotGroups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSnapshotLinksRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  diskIds?: string(name='DiskIds', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  snapshotLinkIds?: string(name='SnapshotLinkIds', position='Query'),
}

model DescribeSnapshotLinksResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  snapshotLinks?: {
    snapshotLink?: [ 
    {
      category?: string(name='Category'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      instantAccess?: boolean(name='InstantAccess'),
      regionId?: string(name='RegionId'),
      snapshotLinkId?: string(name='SnapshotLinkId'),
      sourceDiskId?: string(name='SourceDiskId'),
      sourceDiskName?: string(name='SourceDiskName'),
      sourceDiskSize?: int32(name='SourceDiskSize'),
      sourceDiskType?: string(name='SourceDiskType'),
      totalCount?: int32(name='TotalCount'),
      totalSize?: long(name='TotalSize'),
    }
  ](name='SnapshotLink')
  }(name='SnapshotLinks'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSnapshotLinksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSnapshotLinksResponseBody(name='body'),
}

async function describeSnapshotLinks(request: DescribeSnapshotLinksRequest): DescribeSnapshotLinksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSnapshotLinks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSnapshotMonitorDataRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  category?: string(name='Category', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeSnapshotMonitorDataResponseBody = {
  monitorData?: {
    dataPoint?: [ 
    {
      size?: long(name='Size'),
      timeStamp?: string(name='TimeStamp'),
    }
  ](name='DataPoint')
  }(name='MonitorData'),
  requestId?: string(name='RequestId'),
}

model DescribeSnapshotMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSnapshotMonitorDataResponseBody(name='body'),
}

async function describeSnapshotMonitorData(request: DescribeSnapshotMonitorDataRequest): DescribeSnapshotMonitorDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSnapshotMonitorData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSnapshotPackageRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeSnapshotPackageResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  snapshotPackages?: {
    snapshotPackage?: [ 
    {
      displayName?: string(name='DisplayName'),
      endTime?: string(name='EndTime'),
      initCapacity?: long(name='InitCapacity'),
      startTime?: string(name='StartTime'),
    }
  ](name='SnapshotPackage')
  }(name='SnapshotPackages'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSnapshotPackageResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSnapshotPackageResponseBody(name='body'),
}

async function describeSnapshotPackage(request: DescribeSnapshotPackageRequest): DescribeSnapshotPackageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSnapshotPackage', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSnapshotsRequest {
  filter?: [
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filter', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  category?: string(name='Category', position='Query'),
  diskId?: string(name='DiskId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  encrypted?: boolean(name='Encrypted', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  KMSKeyId?: string(name='KMSKeyId', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  snapshotIds?: string(name='SnapshotIds', position='Query'),
  snapshotLinkId?: string(name='SnapshotLinkId', position='Query'),
  snapshotName?: string(name='SnapshotName', position='Query'),
  snapshotType?: string(name='SnapshotType', position='Query'),
  sourceDiskType?: string(name='SourceDiskType', position='Query'),
  status?: string(name='Status', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  usage?: string(name='Usage', position='Query'),
}

model DescribeSnapshotsResponseBody = {
  nextToken?: string(name='NextToken'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  snapshots?: {
    snapshot?: [ 
    {
      category?: string(name='Category'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      encrypted?: boolean(name='Encrypted'),
      instantAccess?: boolean(name='InstantAccess'),
      instantAccessRetentionDays?: int32(name='InstantAccessRetentionDays'),
      KMSKeyId?: string(name='KMSKeyId'),
      lastModifiedTime?: string(name='LastModifiedTime'),
      productCode?: string(name='ProductCode'),
      progress?: string(name='Progress'),
      remainTime?: int32(name='RemainTime'),
      resourceGroupId?: string(name='ResourceGroupId'),
      retentionDays?: int32(name='RetentionDays'),
      snapshotId?: string(name='SnapshotId'),
      snapshotName?: string(name='SnapshotName'),
      snapshotSN?: string(name='SnapshotSN'),
      snapshotType?: string(name='SnapshotType'),
      sourceDiskId?: string(name='SourceDiskId'),
      sourceDiskSize?: string(name='SourceDiskSize'),
      sourceDiskType?: string(name='SourceDiskType'),
      sourceRegionId?: string(name='SourceRegionId', description=''),
      sourceSnapshotId?: string(name='SourceSnapshotId', description=''),
      sourceStorageType?: string(name='SourceStorageType'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
      usage?: string(name='Usage'),
    }
  ](name='Snapshot')
  }(name='Snapshots'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSnapshotsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSnapshotsResponseBody(name='body'),
}

async function describeSnapshots(request: DescribeSnapshotsRequest): DescribeSnapshotsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSnapshots', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSnapshotsUsageRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeSnapshotsUsageResponseBody = {
  requestId?: string(name='RequestId'),
  snapshotCount?: int32(name='SnapshotCount'),
  snapshotSize?: long(name='SnapshotSize'),
}

model DescribeSnapshotsUsageResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSnapshotsUsageResponseBody(name='body'),
}

async function describeSnapshotsUsage(request: DescribeSnapshotsUsageRequest): DescribeSnapshotsUsageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSnapshotsUsage', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSpotAdviceRequest {
  cores?: int32(name='Cores', position='Query'),
  gpuAmount?: int32(name='GpuAmount', position='Query'),
  gpuSpec?: string(name='GpuSpec', position='Query'),
  instanceFamilyLevel?: string(name='InstanceFamilyLevel', position='Query'),
  instanceTypeFamily?: string(name='InstanceTypeFamily', position='Query'),
  instanceTypes?: [ string ](name='InstanceTypes', position='Query'),
  memory?: float(name='Memory', position='Query'),
  minCores?: int32(name='MinCores', position='Query'),
  minMemory?: float(name='MinMemory', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeSpotAdviceResponseBody = {
  availableSpotZones?: {
    availableSpotZone?: [ 
    {
      availableSpotResources?: {
        availableSpotResource?: [ 
        {
          averageSpotDiscount?: int32(name='AverageSpotDiscount'),
          instanceType?: string(name='InstanceType'),
          interruptRateDesc?: string(name='InterruptRateDesc'),
          interruptionRate?: float(name='InterruptionRate'),
        }
      ](name='AvailableSpotResource')
      }(name='AvailableSpotResources'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='AvailableSpotZone')
  }(name='AvailableSpotZones'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
}

model DescribeSpotAdviceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSpotAdviceResponseBody(name='body'),
}

async function describeSpotAdvice(request: DescribeSpotAdviceRequest): DescribeSpotAdviceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSpotAdvice', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSpotPriceHistoryRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  endTime?: string(name='EndTime', position='Query'),
  instanceType: string(name='InstanceType', position='Query'),
  ioOptimized?: string(name='IoOptimized', position='Query'),
  networkType: string(name='NetworkType', position='Query'),
  OSType?: string(name='OSType', position='Query'),
  offset?: int32(name='Offset', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  spotDuration?: int32(name='SpotDuration', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeSpotPriceHistoryResponseBody = {
  currency?: string(name='Currency'),
  nextOffset?: int32(name='NextOffset'),
  requestId?: string(name='RequestId'),
  spotPrices?: {
    spotPriceType?: [ 
    {
      instanceType?: string(name='InstanceType'),
      ioOptimized?: string(name='IoOptimized'),
      networkType?: string(name='NetworkType'),
      originPrice?: float(name='OriginPrice'),
      spotPrice?: float(name='SpotPrice'),
      timestamp?: string(name='Timestamp'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='SpotPriceType')
  }(name='SpotPrices'),
}

model DescribeSpotPriceHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSpotPriceHistoryResponseBody(name='body'),
}

async function describeSpotPriceHistory(request: DescribeSpotPriceHistoryRequest): DescribeSpotPriceHistoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSpotPriceHistory', 'POST', '/', 'json', false, 'json', request);
}

model DescribeStorageCapacityUnitsRequest {
  allocationType?: string(name='AllocationType', position='Query'),
  capacity?: int32(name='Capacity', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: [ string ](name='Status', position='Query'),
  storageCapacityUnitId?: [ string ](name='StorageCapacityUnitId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model DescribeStorageCapacityUnitsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  storageCapacityUnits?: {
    storageCapacityUnit?: [ 
    {
      allocationStatus?: string(name='AllocationStatus'),
      capacity?: int32(name='Capacity'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      expiredTime?: string(name='ExpiredTime'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
      storageCapacityUnitId?: string(name='StorageCapacityUnitId'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
    }
  ](name='StorageCapacityUnit')
  }(name='StorageCapacityUnits'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeStorageCapacityUnitsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeStorageCapacityUnitsResponseBody(name='body'),
}

async function describeStorageCapacityUnits(request: DescribeStorageCapacityUnitsRequest): DescribeStorageCapacityUnitsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeStorageCapacityUnits', 'POST', '/', 'json', false, 'json', request);
}

model DescribeStorageSetDetailsRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  diskIds?: string(name='DiskIds', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=1000, position='Query'),
  pageSize?: int32(name='PageSize', minimum=10, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  storageSetId: string(name='StorageSetId', position='Query'),
  storageSetPartitionNumber?: int32(name='StorageSetPartitionNumber', minimum=2, position='Query'),
}

model DescribeStorageSetDetailsResponseBody = {
  disks?: {
    disk?: [ 
    {
      category?: string(name='Category'),
      creationTime?: string(name='CreationTime'),
      diskId?: string(name='DiskId'),
      diskName?: string(name='DiskName'),
      regionId?: string(name='RegionId'),
      storageSetId?: string(name='StorageSetId'),
      storageSetPartitionNumber?: int32(name='StorageSetPartitionNumber'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Disk')
  }(name='Disks'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeStorageSetDetailsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeStorageSetDetailsResponseBody(name='body'),
}

async function describeStorageSetDetails(request: DescribeStorageSetDetailsRequest): DescribeStorageSetDetailsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeStorageSetDetails', 'POST', '/', 'json', false, 'json', request);
}

model DescribeStorageSetsRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=1000, position='Query'),
  pageSize?: int32(name='PageSize', minimum=10, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  storageSetIds?: string(name='StorageSetIds', position='Query'),
  storageSetName?: string(name='StorageSetName', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeStorageSetsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  storageSets?: {
    storageSet?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      regionId?: string(name='RegionId'),
      storageSetId?: string(name='StorageSetId'),
      storageSetName?: string(name='StorageSetName'),
      storageSetPartitionNumber?: int32(name='StorageSetPartitionNumber'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='StorageSet')
  }(name='StorageSets'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeStorageSetsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeStorageSetsResponseBody(name='body'),
}

async function describeStorageSets(request: DescribeStorageSetsRequest): DescribeStorageSetsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeStorageSets', 'POST', '/', 'json', false, 'json', request);
}

model DescribeTagsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  category?: string(name='Category', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId?: string(name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model DescribeTagsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  tags?: {
    tag?: [ 
    {
      resourceTypeCount?: {
        ddh?: int32(name='Ddh'),
        disk?: int32(name='Disk'),
        eni?: int32(name='Eni'),
        image?: int32(name='Image'),
        instance?: int32(name='Instance'),
        keyPair?: int32(name='KeyPair'),
        launchTemplate?: int32(name='LaunchTemplate'),
        reservedInstance?: int32(name='ReservedInstance'),
        securitygroup?: int32(name='Securitygroup'),
        snapshot?: int32(name='Snapshot'),
        snapshotPolicy?: int32(name='SnapshotPolicy'),
        volume?: int32(name='Volume'),
      }(name='ResourceTypeCount'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='Tag')
  }(name='Tags'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeTagsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTagsResponseBody(name='body'),
}

async function describeTags(request: DescribeTagsRequest): DescribeTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTags', 'POST', '/', 'json', false, 'json', request);
}

model DescribeTaskAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  taskId: string(name='TaskId', position='Query'),
}

model DescribeTaskAttributeResponseBody = {
  creationTime?: string(name='CreationTime'),
  failedCount?: int32(name='FailedCount'),
  finishedTime?: string(name='FinishedTime'),
  operationProgressSet?: {
    operationProgress?: [ 
    {
      errorCode?: string(name='ErrorCode'),
      errorMsg?: string(name='ErrorMsg'),
      operationStatus?: string(name='OperationStatus'),
      relatedItemSet?: {
        relatedItem?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='RelatedItem')
      }(name='RelatedItemSet'),
    }
  ](name='OperationProgress')
  }(name='OperationProgressSet'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  successCount?: int32(name='SuccessCount'),
  supportCancel?: string(name='SupportCancel'),
  taskAction?: string(name='TaskAction'),
  taskId?: string(name='TaskId'),
  taskProcess?: string(name='TaskProcess'),
  taskStatus?: string(name='TaskStatus'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeTaskAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTaskAttributeResponseBody(name='body'),
}

async function describeTaskAttribute(request: DescribeTaskAttributeRequest): DescribeTaskAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTaskAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeTasksRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  endTime?: string(name='EndTime', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  taskAction?: string(name='TaskAction', position='Query'),
  taskIds?: string(name='TaskIds', position='Query'),
  taskStatus?: string(name='TaskStatus', position='Query'),
}

model DescribeTasksResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  taskSet?: {
    task?: [ 
    {
      creationTime?: string(name='CreationTime'),
      finishedTime?: string(name='FinishedTime'),
      supportCancel?: string(name='SupportCancel'),
      taskAction?: string(name='TaskAction'),
      taskId?: string(name='TaskId'),
      taskStatus?: string(name='TaskStatus'),
    }
  ](name='Task')
  }(name='TaskSet'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeTasksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTasksResponseBody(name='body'),
}

async function describeTasks(request: DescribeTasksRequest): DescribeTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTasks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeUserBusinessBehaviorRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  statusKey: string(name='statusKey', position='Query'),
}

model DescribeUserBusinessBehaviorResponseBody = {
  requestId?: string(name='RequestId'),
  statusValue?: string(name='StatusValue'),
}

model DescribeUserBusinessBehaviorResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUserBusinessBehaviorResponseBody(name='body'),
}

async function describeUserBusinessBehavior(request: DescribeUserBusinessBehaviorRequest): DescribeUserBusinessBehaviorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUserBusinessBehavior', 'POST', '/', 'json', false, 'json', request);
}

model DescribeUserDataRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeUserDataResponseBody = {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  userData?: string(name='UserData'),
}

model DescribeUserDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUserDataResponseBody(name='body'),
}

async function describeUserData(request: DescribeUserDataRequest): DescribeUserDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUserData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVRoutersRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vRouterId?: string(name='VRouterId', position='Query'),
}

model DescribeVRoutersResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vRouters?: {
    vRouter?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      regionId?: string(name='RegionId'),
      routeTableIds?: {
        routeTableId?: [ string ](name='RouteTableId')
      }(name='RouteTableIds'),
      vRouterId?: string(name='VRouterId'),
      vRouterName?: string(name='VRouterName'),
      vpcId?: string(name='VpcId'),
    }
  ](name='VRouter')
  }(name='VRouters'),
}

model DescribeVRoutersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVRoutersResponseBody(name='body'),
}

async function describeVRouters(request: DescribeVRoutersRequest): DescribeVRoutersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVRouters', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVSwitchesRequest {
  isDefault?: boolean(name='IsDefault', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeVSwitchesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vSwitches?: {
    vSwitch?: [ 
    {
      availableIpAddressCount?: long(name='AvailableIpAddressCount'),
      cidrBlock?: string(name='CidrBlock'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      isDefault?: boolean(name='IsDefault'),
      resourceGroupId?: string(name='ResourceGroupId'),
      status?: string(name='Status'),
      vSwitchId?: string(name='VSwitchId'),
      vSwitchName?: string(name='VSwitchName'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='VSwitch')
  }(name='VSwitches'),
}

model DescribeVSwitchesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVSwitchesResponseBody(name='body'),
}

async function describeVSwitches(request: DescribeVSwitchesRequest): DescribeVSwitchesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVSwitches', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVirtualBorderRoutersRequest {
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeVirtualBorderRoutersResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  virtualBorderRouterSet?: {
    virtualBorderRouterType?: [ 
    {
      accessPointId?: string(name='AccessPointId'),
      activationTime?: string(name='ActivationTime'),
      circuitCode?: string(name='CircuitCode'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      localGatewayIp?: string(name='LocalGatewayIp'),
      name?: string(name='Name'),
      peerGatewayIp?: string(name='PeerGatewayIp'),
      peeringSubnetMask?: string(name='PeeringSubnetMask'),
      physicalConnectionBusinessStatus?: string(name='PhysicalConnectionBusinessStatus'),
      physicalConnectionId?: string(name='PhysicalConnectionId'),
      physicalConnectionOwnerUid?: string(name='PhysicalConnectionOwnerUid'),
      physicalConnectionStatus?: string(name='PhysicalConnectionStatus'),
      recoveryTime?: string(name='RecoveryTime'),
      routeTableId?: string(name='RouteTableId'),
      status?: string(name='Status'),
      terminationTime?: string(name='TerminationTime'),
      vbrId?: string(name='VbrId'),
      vlanId?: int32(name='VlanId'),
      vlanInterfaceId?: string(name='VlanInterfaceId'),
    }
  ](name='VirtualBorderRouterType')
  }(name='VirtualBorderRouterSet'),
}

model DescribeVirtualBorderRoutersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVirtualBorderRoutersResponseBody(name='body'),
}

async function describeVirtualBorderRouters(request: DescribeVirtualBorderRoutersRequest): DescribeVirtualBorderRoutersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVirtualBorderRouters', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVirtualBorderRoutersForPhysicalConnectionRequest {
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  physicalConnectionId: string(name='PhysicalConnectionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  virtualBorderRouterForPhysicalConnectionSet?: {
    virtualBorderRouterForPhysicalConnectionType?: [ 
    {
      activationTime?: string(name='ActivationTime'),
      circuitCode?: string(name='CircuitCode'),
      creationTime?: string(name='CreationTime'),
      recoveryTime?: string(name='RecoveryTime'),
      terminationTime?: string(name='TerminationTime'),
      vbrId?: string(name='VbrId'),
      vbrOwnerUid?: long(name='VbrOwnerUid'),
      vlanId?: int32(name='VlanId'),
    }
  ](name='VirtualBorderRouterForPhysicalConnectionType')
  }(name='VirtualBorderRouterForPhysicalConnectionSet'),
}

model DescribeVirtualBorderRoutersForPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody(name='body'),
}

async function describeVirtualBorderRoutersForPhysicalConnection(request: DescribeVirtualBorderRoutersForPhysicalConnectionRequest): DescribeVirtualBorderRoutersForPhysicalConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVirtualBorderRoutersForPhysicalConnection', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVpcsRequest {
  isDefault?: boolean(name='IsDefault', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model DescribeVpcsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vpcs?: {
    vpc?: [ 
    {
      cidrBlock?: string(name='CidrBlock'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      isDefault?: boolean(name='IsDefault'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      userCidrs?: {
        userCidr?: [ string ](name='UserCidr')
      }(name='UserCidrs'),
      vRouterId?: string(name='VRouterId'),
      vSwitchIds?: {
        vSwitchId?: [ string ](name='VSwitchId')
      }(name='VSwitchIds'),
      vpcId?: string(name='VpcId'),
      vpcName?: string(name='VpcName'),
    }
  ](name='Vpc')
  }(name='Vpcs'),
}

model DescribeVpcsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpcsResponseBody(name='body'),
}

async function describeVpcs(request: DescribeVpcsRequest): DescribeVpcsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVpcs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeZonesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  spotStrategy?: string(name='SpotStrategy', position='Query'),
  verbose?: boolean(name='Verbose', position='Query'),
}

model DescribeZonesResponseBody = {
  requestId?: string(name='RequestId'),
  zones?: {
    zone?: [ 
    {
      availableDedicatedHostTypes?: {
        dedicatedHostType?: [ string ](name='DedicatedHostType')
      }(name='AvailableDedicatedHostTypes'),
      availableDiskCategories?: {
        diskCategories?: [ string ](name='DiskCategories')
      }(name='AvailableDiskCategories'),
      availableInstanceTypes?: {
        instanceTypes?: [ string ](name='InstanceTypes')
      }(name='AvailableInstanceTypes'),
      availableResourceCreation?: {
        resourceTypes?: [ string ](name='ResourceTypes')
      }(name='AvailableResourceCreation'),
      availableResources?: {
        resourcesInfo?: [ 
        {
          dataDiskCategories?: {
            supportedDataDiskCategory?: [ string ](name='supportedDataDiskCategory')
          }(name='DataDiskCategories'),
          instanceGenerations?: {
            supportedInstanceGeneration?: [ string ](name='supportedInstanceGeneration')
          }(name='InstanceGenerations'),
          instanceTypeFamilies?: {
            supportedInstanceTypeFamily?: [ string ](name='supportedInstanceTypeFamily')
          }(name='InstanceTypeFamilies'),
          instanceTypes?: {
            supportedInstanceType?: [ string ](name='supportedInstanceType')
          }(name='InstanceTypes'),
          ioOptimized?: boolean(name='IoOptimized'),
          networkTypes?: {
            supportedNetworkCategory?: [ string ](name='supportedNetworkCategory')
          }(name='NetworkTypes'),
          systemDiskCategories?: {
            supportedSystemDiskCategory?: [ string ](name='supportedSystemDiskCategory')
          }(name='SystemDiskCategories'),
        }
      ](name='ResourcesInfo')
      }(name='AvailableResources'),
      availableVolumeCategories?: {
        volumeCategories?: [ string ](name='VolumeCategories')
      }(name='AvailableVolumeCategories'),
      dedicatedHostGenerations?: {
        dedicatedHostGeneration?: [ string ](name='DedicatedHostGeneration')
      }(name='DedicatedHostGenerations'),
      localName?: string(name='LocalName'),
      zoneId?: string(name='ZoneId'),
      zoneType?: string(name='ZoneType'),
    }
  ](name='Zone')
  }(name='Zones'),
}

model DescribeZonesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeZonesResponseBody(name='body'),
}

async function describeZones(request: DescribeZonesRequest): DescribeZonesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeZones', 'POST', '/', 'json', false, 'json', request);
}

model DetachClassicLinkVpcRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
}

model DetachClassicLinkVpcResponseBody = {
  requestId?: string(name='RequestId'),
}

model DetachClassicLinkVpcResponse = {
  headers: map[string]string(name='headers'),
  body: DetachClassicLinkVpcResponseBody(name='body'),
}

async function detachClassicLinkVpc(request: DetachClassicLinkVpcRequest): DetachClassicLinkVpcResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetachClassicLinkVpc', 'POST', '/', 'json', false, 'json', request);
}

model DetachDiskRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  deleteWithInstance?: boolean(name='DeleteWithInstance', position='Query'),
  diskId: string(name='DiskId', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DetachDiskResponseBody = {
  requestId?: string(name='RequestId'),
}

model DetachDiskResponse = {
  headers: map[string]string(name='headers'),
  body: DetachDiskResponseBody(name='body'),
}

async function detachDisk(request: DetachDiskRequest): DetachDiskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetachDisk', 'POST', '/', 'json', false, 'json', request);
}

model DetachInstanceRamRoleRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceIds: string(name='InstanceIds', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  ramRoleName?: string(name='RamRoleName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DetachInstanceRamRoleResponseBody = {
  detachInstanceRamRoleResults?: {
    detachInstanceRamRoleResult?: [ 
    {
      code?: string(name='Code'),
      instanceId?: string(name='InstanceId'),
      instanceRamRoleSets?: {
        instanceRamRoleSet?: [ 
        {
          instanceId?: string(name='InstanceId'),
          ramRoleName?: string(name='RamRoleName'),
        }
      ](name='InstanceRamRoleSet')
      }(name='InstanceRamRoleSets'),
      message?: string(name='Message'),
      success?: boolean(name='Success'),
    }
  ](name='DetachInstanceRamRoleResult')
  }(name='DetachInstanceRamRoleResults'),
  failCount?: int32(name='FailCount'),
  ramRoleName?: string(name='RamRoleName'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DetachInstanceRamRoleResponse = {
  headers: map[string]string(name='headers'),
  body: DetachInstanceRamRoleResponseBody(name='body'),
}

async function detachInstanceRamRole(request: DetachInstanceRamRoleRequest): DetachInstanceRamRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetachInstanceRamRole', 'POST', '/', 'json', false, 'json', request);
}

model DetachKeyPairRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceIds: string(name='InstanceIds', position='Query'),
  keyPairName: string(name='KeyPairName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DetachKeyPairResponseBody = {
  failCount?: string(name='FailCount'),
  keyPairName?: string(name='KeyPairName'),
  requestId?: string(name='RequestId'),
  results?: {
    result?: [ 
    {
      code?: string(name='Code'),
      instanceId?: string(name='InstanceId'),
      message?: string(name='Message'),
      success?: string(name='Success'),
    }
  ](name='Result')
  }(name='Results'),
  totalCount?: string(name='TotalCount'),
}

model DetachKeyPairResponse = {
  headers: map[string]string(name='headers'),
  body: DetachKeyPairResponseBody(name='body'),
}

async function detachKeyPair(request: DetachKeyPairRequest): DetachKeyPairResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetachKeyPair', 'POST', '/', 'json', false, 'json', request);
}

model DetachNetworkInterfaceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId: string(name='InstanceId', position='Query'),
  networkInterfaceId: string(name='NetworkInterfaceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  trunkNetworkInstanceId?: string(name='TrunkNetworkInstanceId', position='Query'),
}

model DetachNetworkInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DetachNetworkInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: DetachNetworkInterfaceResponseBody(name='body'),
}

async function detachNetworkInterface(request: DetachNetworkInterfaceRequest): DetachNetworkInterfaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetachNetworkInterface', 'POST', '/', 'json', false, 'json', request);
}

model DisableActivationRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  activationId: string(name='ActivationId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DisableActivationResponseBody = {
  activation?: {
    activationId?: string(name='ActivationId'),
    creationTime?: string(name='CreationTime'),
    deregisteredCount?: int32(name='DeregisteredCount'),
    description?: string(name='Description'),
    disabled?: boolean(name='Disabled'),
    instanceCount?: int32(name='InstanceCount'),
    instanceName?: string(name='InstanceName'),
    ipAddressRange?: string(name='IpAddressRange'),
    registeredCount?: int32(name='RegisteredCount'),
    timeToLiveInHours?: long(name='TimeToLiveInHours'),
  }(name='Activation'),
  requestId?: string(name='RequestId'),
}

model DisableActivationResponse = {
  headers: map[string]string(name='headers'),
  body: DisableActivationResponseBody(name='body'),
}

async function disableActivation(request: DisableActivationRequest): DisableActivationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableActivation', 'POST', '/', 'json', false, 'json', request);
}

model EipFillParamsRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
  data: string(name='data', position='Query'),
}

model EipFillParamsResponseBody = {
  code?: string(name='code'),
  data?: string(name='data'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model EipFillParamsResponse = {
  headers: map[string]string(name='headers'),
  body: EipFillParamsResponseBody(name='body'),
}

async function eipFillParams(request: EipFillParamsRequest): EipFillParamsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EipFillParams', 'POST', '/', 'json', false, 'json', request);
}

model EipFillProductRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
  data: string(name='data', position='Query'),
}

model EipFillProductResponseBody = {
  code?: string(name='code'),
  data?: string(name='data'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model EipFillProductResponse = {
  headers: map[string]string(name='headers'),
  body: EipFillProductResponseBody(name='body'),
}

async function eipFillProduct(request: EipFillProductRequest): EipFillProductResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EipFillProduct', 'POST', '/', 'json', false, 'json', request);
}

model EipNotifyPaidRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
  data: string(name='data', position='Query'),
}

model EipNotifyPaidResponseBody = {
  code?: string(name='code'),
  data?: string(name='data'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model EipNotifyPaidResponse = {
  headers: map[string]string(name='headers'),
  body: EipNotifyPaidResponseBody(name='body'),
}

async function eipNotifyPaid(request: EipNotifyPaidRequest): EipNotifyPaidResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EipNotifyPaid', 'POST', '/', 'json', false, 'json', request);
}

model EnablePhysicalConnectionRequest {
  clientToken: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  physicalConnectionId: string(name='PhysicalConnectionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
}

model EnablePhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnablePhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: EnablePhysicalConnectionResponseBody(name='body'),
}

async function enablePhysicalConnection(request: EnablePhysicalConnectionRequest): EnablePhysicalConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnablePhysicalConnection', 'POST', '/', 'json', false, 'json', request);
}

model ExportImageRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  imageFormat?: string(name='ImageFormat', position='Query'),
  imageId: string(name='ImageId', position='Query'),
  OSSBucket: string(name='OSSBucket', position='Query'),
  OSSPrefix?: string(name='OSSPrefix', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  roleName?: string(name='RoleName', position='Query'),
}

model ExportImageResponseBody = {
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model ExportImageResponse = {
  headers: map[string]string(name='headers'),
  body: ExportImageResponseBody(name='body'),
}

async function exportImage(request: ExportImageRequest): ExportImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExportImage', 'POST', '/', 'json', false, 'json', request);
}

model ExportSnapshotRequest {
  ossBucket: string(name='OssBucket', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  roleName?: string(name='RoleName', position='Query'),
  snapshotId: string(name='SnapshotId', position='Query'),
}

model ExportSnapshotResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model ExportSnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: ExportSnapshotResponseBody(name='body'),
}

async function exportSnapshot(request: ExportSnapshotRequest): ExportSnapshotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExportSnapshot', 'POST', '/', 'json', false, 'json', request);
}

model GetInstanceConsoleOutputRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  removeSymbols?: boolean(name='RemoveSymbols', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model GetInstanceConsoleOutputResponseBody = {
  consoleOutput?: string(name='ConsoleOutput'),
  instanceId?: string(name='InstanceId'),
  lastUpdateTime?: string(name='LastUpdateTime'),
  requestId?: string(name='RequestId'),
}

model GetInstanceConsoleOutputResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceConsoleOutputResponseBody(name='body'),
}

async function getInstanceConsoleOutput(request: GetInstanceConsoleOutputRequest): GetInstanceConsoleOutputResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetInstanceConsoleOutput', 'POST', '/', 'json', false, 'json', request);
}

model GetInstanceScreenshotRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  wakeUp?: boolean(name='WakeUp', position='Query'),
}

model GetInstanceScreenshotResponseBody = {
  instanceId?: string(name='InstanceId'),
  requestId?: string(name='RequestId'),
  screenshot?: string(name='Screenshot'),
}

model GetInstanceScreenshotResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceScreenshotResponseBody(name='body'),
}

async function getInstanceScreenshot(request: GetInstanceScreenshotRequest): GetInstanceScreenshotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetInstanceScreenshot', 'POST', '/', 'json', false, 'json', request);
}

model ImportImageRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  architecture?: string(name='Architecture', position='Query'),
  bootMode?: string(name='BootMode', position='Query'),
  description?: string(name='Description', position='Query'),
  detectionStrategy?: string(name='DetectionStrategy', position='Query'),
  diskDeviceMapping?: [ 
    {
      device?: string(name='Device'),
      diskImSize?: int32(name='DiskImSize'),
      diskImageSize?: int32(name='DiskImageSize'),
      format?: string(name='Format'),
      OSSBucket?: string(name='OSSBucket'),
      OSSObject?: string(name='OSSObject'),
    }
  ](name='DiskDeviceMapping', position='Query'),
  imageName?: string(name='ImageName', position='Query'),
  licenseType?: string(name='LicenseType', position='Query'),
  OSType?: string(name='OSType', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  platform?: string(name='Platform', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  roleName?: string(name='RoleName', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model ImportImageResponseBody = {
  imageId?: string(name='ImageId'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model ImportImageResponse = {
  headers: map[string]string(name='headers'),
  body: ImportImageResponseBody(name='body'),
}

async function importImage(request: ImportImageRequest): ImportImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ImportImage', 'POST', '/', 'json', false, 'json', request);
}

model ImportKeyPairRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  keyPairName: string(name='KeyPairName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  publicKeyBody: string(name='PublicKeyBody', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model ImportKeyPairResponseBody = {
  keyPairFingerPrint?: string(name='KeyPairFingerPrint'),
  keyPairName?: string(name='KeyPairName'),
  requestId?: string(name='RequestId'),
}

model ImportKeyPairResponse = {
  headers: map[string]string(name='headers'),
  body: ImportKeyPairResponseBody(name='body'),
}

async function importKeyPair(request: ImportKeyPairRequest): ImportKeyPairResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ImportKeyPair', 'POST', '/', 'json', false, 'json', request);
}

model ImportSnapshotRequest {
  ossBucket: string(name='OssBucket', position='Query'),
  ossObject: string(name='OssObject', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  roleName?: string(name='RoleName', position='Query'),
  snapshotName: string(name='SnapshotName', position='Query'),
}

model ImportSnapshotResponseBody = {
  requestId?: string(name='RequestId'),
  snapshotId?: string(name='SnapshotId'),
  taskId?: string(name='TaskId'),
}

model ImportSnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: ImportSnapshotResponseBody(name='body'),
}

async function importSnapshot(request: ImportSnapshotRequest): ImportSnapshotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ImportSnapshot', 'POST', '/', 'json', false, 'json', request);
}

model InstallCloudAssistantRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId: [ string ](name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model InstallCloudAssistantResponseBody = {
  requestId?: string(name='RequestId'),
}

model InstallCloudAssistantResponse = {
  headers: map[string]string(name='headers'),
  body: InstallCloudAssistantResponseBody(name='body'),
}

async function installCloudAssistant(request: InstallCloudAssistantRequest): InstallCloudAssistantResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'InstallCloudAssistant', 'POST', '/', 'json', false, 'json', request);
}

model InvokeCommandRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  commandId: string(name='CommandId', position='Query'),
  containerId?: string(name='ContainerId', position='Query'),
  containerName?: string(name='ContainerName', position='Query'),
  frequency?: string(name='Frequency', position='Query'),
  instanceId: [ string ](name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  parameters?: map[string]any(name='Parameters', shrink='json', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  repeatMode?: string(name='RepeatMode', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  timed?: boolean(name='Timed', position='Query'),
  username?: string(name='Username', position='Query'),
  windowsPasswordName?: string(name='WindowsPasswordName', position='Query'),
}

model InvokeCommandResponseBody = {
  invokeId?: string(name='InvokeId'),
  requestId?: string(name='RequestId'),
}

model InvokeCommandResponse = {
  headers: map[string]string(name='headers'),
  body: InvokeCommandResponseBody(name='body'),
}

async function invokeCommand(request: InvokeCommandRequest): InvokeCommandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'InvokeCommand', 'POST', '/', 'json', false, 'json', request);
}

model JoinResourceGroupRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceId?: string(name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
}

model JoinResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model JoinResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: JoinResourceGroupResponseBody(name='body'),
}

async function joinResourceGroup(request: JoinResourceGroupRequest): JoinResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'JoinResourceGroup', 'POST', '/', 'json', false, 'json', request);
}

model JoinSecurityGroupRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId?: string(name='InstanceId', position='Query'),
  networkInterfaceId?: string(name='NetworkInterfaceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId: string(name='SecurityGroupId', position='Query'),
}

model JoinSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model JoinSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: JoinSecurityGroupResponseBody(name='body'),
}

async function joinSecurityGroup(request: JoinSecurityGroupRequest): JoinSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'JoinSecurityGroup', 'POST', '/', 'json', false, 'json', request);
}

model LeaveSecurityGroupRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId?: string(name='InstanceId', position='Query'),
  networkInterfaceId?: string(name='NetworkInterfaceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId: string(name='SecurityGroupId', position='Query'),
}

model LeaveSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model LeaveSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: LeaveSecurityGroupResponseBody(name='body'),
}

async function leaveSecurityGroup(request: LeaveSecurityGroupRequest): LeaveSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'LeaveSecurityGroup', 'POST', '/', 'json', false, 'json', request);
}

model ListPluginStatusRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId?: [ string ](name='InstanceId', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListPluginStatusResponseBody = {
  instancePluginStatusSet?: {
    instancePluginStatus?: [ 
    {
      instanceId?: string(name='InstanceId'),
      pluginStatusSet?: {
        pluginStatus?: [ 
        {
          firstHeartbeatTime?: string(name='FirstHeartbeatTime'),
          lastHeartbeatTime?: string(name='LastHeartbeatTime'),
          pluginName?: string(name='PluginName'),
          pluginStatus?: string(name='PluginStatus'),
          pluginVersion?: string(name='PluginVersion'),
        }
      ](name='PluginStatus')
      }(name='PluginStatusSet'),
    }
  ](name='InstancePluginStatus')
  }(name='InstancePluginStatusSet'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListPluginStatusResponse = {
  headers: map[string]string(name='headers'),
  body: ListPluginStatusResponseBody(name='body'),
}

async function listPluginStatus(request: ListPluginStatusRequest): ListPluginStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListPluginStatus', 'POST', '/', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId?: [ string ](name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  tagFilter?: [ 
    {
      tagKey?: string(name='TagKey'),
      tagValues?: [ string ](name='TagValues'),
    }
  ](name='TagFilter', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', '/', 'json', false, 'json', request);
}

model ModifyAutoProvisioningGroupRequest {
  autoProvisioningGroupId?: string(name='AutoProvisioningGroupId', position='Query'),
  autoProvisioningGroupName?: string(name='AutoProvisioningGroupName', position='Query'),
  defaultTargetCapacityType?: string(name='DefaultTargetCapacityType', position='Query'),
  excessCapacityTerminationPolicy?: string(name='ExcessCapacityTerminationPolicy', position='Query'),
  launchTemplateConfig?: [ 
    {
      instanceType?: string(name='InstanceType'),
      maxPrice?: double(name='MaxPrice'),
      priority?: int32(name='Priority'),
      vSwitchId?: string(name='VSwitchId'),
      weightedCapacity?: double(name='WeightedCapacity'),
    }
  ](name='LaunchTemplateConfig', position='Query'),
  maxSpotPrice?: float(name='MaxSpotPrice', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  payAsYouGoTargetCapacity?: string(name='PayAsYouGoTargetCapacity', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  spotTargetCapacity?: string(name='SpotTargetCapacity', position='Query'),
  terminateInstancesWithExpiration?: boolean(name='TerminateInstancesWithExpiration', position='Query'),
  totalTargetCapacity?: string(name='TotalTargetCapacity', position='Query'),
}

model ModifyAutoProvisioningGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyAutoProvisioningGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyAutoProvisioningGroupResponseBody(name='body'),
}

async function modifyAutoProvisioningGroup(request: ModifyAutoProvisioningGroupRequest): ModifyAutoProvisioningGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyAutoProvisioningGroup', 'POST', '/', 'json', false, 'json', request);
}

model ModifyAutoSnapshotPolicyRequest {
  dataDiskPolicyEnabled?: boolean(name='DataDiskPolicyEnabled', position='Query'),
  dataDiskPolicyRetentionDays?: int32(name='DataDiskPolicyRetentionDays', minimum=1, maximum=3, position='Query'),
  dataDiskPolicyRetentionLastWeek?: boolean(name='DataDiskPolicyRetentionLastWeek', position='Query'),
  dataDiskPolicyTimePeriod?: int32(name='DataDiskPolicyTimePeriod', minimum=1, maximum=4, position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  systemDiskPolicyEnabled?: boolean(name='SystemDiskPolicyEnabled', position='Query'),
  systemDiskPolicyRetentionDays?: int32(name='SystemDiskPolicyRetentionDays', minimum=1, maximum=3, position='Query'),
  systemDiskPolicyRetentionLastWeek?: boolean(name='SystemDiskPolicyRetentionLastWeek', position='Query'),
  systemDiskPolicyTimePeriod?: int32(name='SystemDiskPolicyTimePeriod', minimum=1, maximum=4, position='Query'),
}

model ModifyAutoSnapshotPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyAutoSnapshotPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyAutoSnapshotPolicyResponseBody(name='body'),
}

async function modifyAutoSnapshotPolicy(request: ModifyAutoSnapshotPolicyRequest): ModifyAutoSnapshotPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyAutoSnapshotPolicy', 'POST', '/', 'json', false, 'json', request);
}

model ModifyAutoSnapshotPolicyExRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  copiedSnapshotsRetentionDays?: int32(name='CopiedSnapshotsRetentionDays', position='Query'),
  enableCrossRegionCopy?: boolean(name='EnableCrossRegionCopy', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  targetCopyRegions?: string(name='TargetCopyRegions', position='Query'),
  autoSnapshotPolicyId: string(name='autoSnapshotPolicyId', position='Query'),
  autoSnapshotPolicyName?: string(name='autoSnapshotPolicyName', position='Query'),
  regionId: string(name='regionId', position='Query'),
  repeatWeekdays?: string(name='repeatWeekdays', position='Query'),
  retentionDays?: int32(name='retentionDays', position='Query'),
  timePoints?: string(name='timePoints', position='Query'),
}

model ModifyAutoSnapshotPolicyExResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyAutoSnapshotPolicyExResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyAutoSnapshotPolicyExResponseBody(name='body'),
}

async function modifyAutoSnapshotPolicyEx(request: ModifyAutoSnapshotPolicyExRequest): ModifyAutoSnapshotPolicyExResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyAutoSnapshotPolicyEx', 'POST', '/', 'json', false, 'json', request);
}

model ModifyBandwidthPackageSpecRequest {
  bandwidth: string(name='Bandwidth', position='Query'),
  bandwidthPackageId: string(name='BandwidthPackageId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyBandwidthPackageSpecResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBandwidthPackageSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyBandwidthPackageSpecResponseBody(name='body'),
}

async function modifyBandwidthPackageSpec(request: ModifyBandwidthPackageSpecRequest): ModifyBandwidthPackageSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyBandwidthPackageSpec', 'POST', '/', 'json', false, 'json', request);
}

model ModifyCapacityReservationRequest {
  privatePoolOptions?: {
    id: string(name='Id'),
    name?: string(name='Name'),
  }(name='PrivatePoolOptions', position='Query'),
  description?: string(name='Description', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  endTimeType?: string(name='EndTimeType', position='Query'),
  instanceAmount?: int32(name='InstanceAmount', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  platform?: string(name='Platform', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model ModifyCapacityReservationResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyCapacityReservationResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCapacityReservationResponseBody(name='body'),
}

async function modifyCapacityReservation(request: ModifyCapacityReservationRequest): ModifyCapacityReservationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyCapacityReservation', 'POST', '/', 'json', false, 'json', request);
}

model ModifyCommandRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  commandContent?: string(name='CommandContent', position='Query'),
  commandId: string(name='CommandId', position='Query'),
  description?: string(name='Description', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  timeout?: long(name='Timeout', position='Query'),
  workingDir?: string(name='WorkingDir', position='Query'),
}

model ModifyCommandResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyCommandResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCommandResponseBody(name='body'),
}

async function modifyCommand(request: ModifyCommandRequest): ModifyCommandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyCommand', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDedicatedHostAttributeRequest {
  networkAttributes?: {
    slbUdpTimeout?: int32(name='SlbUdpTimeout'),
    udpTimeout?: int32(name='UdpTimeout'),
  }(name='NetworkAttributes', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  actionOnMaintenance?: string(name='ActionOnMaintenance', position='Query'),
  autoPlacement?: string(name='AutoPlacement', position='Query'),
  cpuOverCommitRatio?: float(name='CpuOverCommitRatio', position='Query'),
  dedicatedHostClusterId?: string(name='DedicatedHostClusterId', position='Query'),
  dedicatedHostId: string(name='DedicatedHostId', position='Query'),
  dedicatedHostName?: string(name='DedicatedHostName', position='Query'),
  description?: string(name='Description', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDedicatedHostAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDedicatedHostAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDedicatedHostAttributeResponseBody(name='body'),
}

async function modifyDedicatedHostAttribute(request: ModifyDedicatedHostAttributeRequest): ModifyDedicatedHostAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDedicatedHostAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDedicatedHostAutoReleaseTimeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  autoReleaseTime?: string(name='AutoReleaseTime', position='Query'),
  dedicatedHostId: string(name='DedicatedHostId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDedicatedHostAutoReleaseTimeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDedicatedHostAutoReleaseTimeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDedicatedHostAutoReleaseTimeResponseBody(name='body'),
}

async function modifyDedicatedHostAutoReleaseTime(request: ModifyDedicatedHostAutoReleaseTimeRequest): ModifyDedicatedHostAutoReleaseTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDedicatedHostAutoReleaseTime', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDedicatedHostAutoRenewAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  autoRenew?: boolean(name='AutoRenew', position='Query'),
  autoRenewWithEcs?: string(name='AutoRenewWithEcs', position='Query'),
  dedicatedHostIds: string(name='DedicatedHostIds', position='Query'),
  duration?: int32(name='Duration', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  renewalStatus?: string(name='RenewalStatus', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDedicatedHostAutoRenewAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDedicatedHostAutoRenewAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDedicatedHostAutoRenewAttributeResponseBody(name='body'),
}

async function modifyDedicatedHostAutoRenewAttribute(request: ModifyDedicatedHostAutoRenewAttributeRequest): ModifyDedicatedHostAutoRenewAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDedicatedHostAutoRenewAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDedicatedHostClusterAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  dedicatedHostClusterId: string(name='DedicatedHostClusterId', position='Query'),
  dedicatedHostClusterName?: string(name='DedicatedHostClusterName', position='Query'),
  description?: string(name='Description', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDedicatedHostClusterAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDedicatedHostClusterAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDedicatedHostClusterAttributeResponseBody(name='body'),
}

async function modifyDedicatedHostClusterAttribute(request: ModifyDedicatedHostClusterAttributeRequest): ModifyDedicatedHostClusterAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDedicatedHostClusterAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDedicatedHostsChargeTypeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dedicatedHostChargeType?: string(name='DedicatedHostChargeType', position='Query'),
  dedicatedHostIds: string(name='DedicatedHostIds', position='Query'),
  detailFee?: boolean(name='DetailFee', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDedicatedHostsChargeTypeResponseBody = {
  feeOfInstances?: {
    feeOfInstance?: [ 
    {
      currency?: string(name='Currency'),
      fee?: string(name='Fee'),
      instanceId?: string(name='InstanceId'),
    }
  ](name='FeeOfInstance')
  }(name='FeeOfInstances'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyDedicatedHostsChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDedicatedHostsChargeTypeResponseBody(name='body'),
}

async function modifyDedicatedHostsChargeType(request: ModifyDedicatedHostsChargeTypeRequest): ModifyDedicatedHostsChargeTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDedicatedHostsChargeType', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDemandRequest {
  amount?: int32(name='Amount', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  demandDescription?: string(name='DemandDescription', position='Query'),
  demandId: string(name='DemandId', position='Query'),
  demandName?: string(name='DemandName', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model ModifyDemandResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDemandResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDemandResponseBody(name='body'),
}

async function modifyDemand(request: ModifyDemandRequest): ModifyDemandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDemand', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDeploymentSetAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  deploymentSetId: string(name='DeploymentSetId', position='Query'),
  deploymentSetName?: string(name='DeploymentSetName', position='Query'),
  description?: string(name='Description', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDeploymentSetAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDeploymentSetAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDeploymentSetAttributeResponseBody(name='body'),
}

async function modifyDeploymentSetAttribute(request: ModifyDeploymentSetAttributeRequest): ModifyDeploymentSetAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDeploymentSetAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDiagnosticMetricSetRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  description?: string(name='Description', maxLength=255, position='Query'),
  metricIds?: [ string ](name='MetricIds', position='Query'),
  metricSetId: string(name='MetricSetId', position='Query'),
  metricSetName?: string(name='MetricSetName', maxLength=128, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
}

model ModifyDiagnosticMetricSetResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ModifyDiagnosticMetricSetResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDiagnosticMetricSetResponseBody(name='body'),
}

async function modifyDiagnosticMetricSet(request: ModifyDiagnosticMetricSetRequest): ModifyDiagnosticMetricSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDiagnosticMetricSet', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDiskAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  burstingEnabled?: boolean(name='BurstingEnabled', position='Query'),
  deleteAutoSnapshot?: boolean(name='DeleteAutoSnapshot', position='Query'),
  deleteWithInstance?: boolean(name='DeleteWithInstance', position='Query'),
  description?: string(name='Description', position='Query'),
  diskId?: string(name='DiskId', position='Query'),
  diskIds?: [ string ](name='DiskIds', position='Query'),
  diskName?: string(name='DiskName', position='Query'),
  enableAutoSnapshot?: boolean(name='EnableAutoSnapshot', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDiskAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDiskAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDiskAttributeResponseBody(name='body'),
}

async function modifyDiskAttribute(request: ModifyDiskAttributeRequest): ModifyDiskAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDiskAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDiskChargeTypeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  diskChargeType?: string(name='DiskChargeType', position='Query'),
  diskIds: string(name='DiskIds', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDiskChargeTypeResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyDiskChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDiskChargeTypeResponseBody(name='body'),
}

async function modifyDiskChargeType(request: ModifyDiskChargeTypeRequest): ModifyDiskChargeTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDiskChargeType', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDiskSpecRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  diskCategory?: string(name='DiskCategory', position='Query'),
  diskId: string(name='DiskId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  performanceLevel?: string(name='PerformanceLevel', position='Query'),
  provisionedIops?: long(name='ProvisionedIops', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDiskSpecResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model ModifyDiskSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDiskSpecResponseBody(name='body'),
}

async function modifyDiskSpec(request: ModifyDiskSpecRequest): ModifyDiskSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDiskSpec', 'POST', '/', 'json', false, 'json', request);
}

model ModifyEipAddressAttributeRequest {
  allocationId: string(name='AllocationId', position='Query'),
  bandwidth: string(name='Bandwidth', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyEipAddressAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyEipAddressAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyEipAddressAttributeResponseBody(name='body'),
}

async function modifyEipAddressAttribute(request: ModifyEipAddressAttributeRequest): ModifyEipAddressAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyEipAddressAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyElasticityAssuranceRequest {
  privatePoolOptions?: {
    id: string(name='Id'),
    name?: string(name='Name'),
  }(name='PrivatePoolOptions', position='Query'),
  description?: string(name='Description', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyElasticityAssuranceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyElasticityAssuranceResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyElasticityAssuranceResponseBody(name='body'),
}

async function modifyElasticityAssurance(request: ModifyElasticityAssuranceRequest): ModifyElasticityAssuranceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyElasticityAssurance', 'POST', '/', 'json', false, 'json', request);
}

model ModifyForwardEntryRequest {
  externalIp?: string(name='ExternalIp', position='Query'),
  externalPort?: string(name='ExternalPort', position='Query'),
  forwardEntryId: string(name='ForwardEntryId', position='Query'),
  forwardTableId: string(name='ForwardTableId', position='Query'),
  internalIp?: string(name='InternalIp', position='Query'),
  internalPort?: string(name='InternalPort', position='Query'),
  ipProtocol?: string(name='IpProtocol', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyForwardEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyForwardEntryResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyForwardEntryResponseBody(name='body'),
}

async function modifyForwardEntry(request: ModifyForwardEntryRequest): ModifyForwardEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyForwardEntry', 'POST', '/', 'json', false, 'json', request);
}

model ModifyHaVipAttributeRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  haVipId: string(name='HaVipId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyHaVipAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyHaVipAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyHaVipAttributeResponseBody(name='body'),
}

async function modifyHaVipAttribute(request: ModifyHaVipAttributeRequest): ModifyHaVipAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyHaVipAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyHpcClusterAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  hpcClusterId: string(name='HpcClusterId', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyHpcClusterAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyHpcClusterAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyHpcClusterAttributeResponseBody(name='body'),
}

async function modifyHpcClusterAttribute(request: ModifyHpcClusterAttributeRequest): ModifyHpcClusterAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyHpcClusterAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyImageAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  bootMode?: string(name='BootMode', position='Query'),
  description?: string(name='Description', position='Query'),
  features?: {
    nvmeSupport?: string(name='NvmeSupport'),
  }(name='Features', position='Query'),
  imageFamily?: string(name='ImageFamily', position='Query'),
  imageId: string(name='ImageId', position='Query'),
  imageName?: string(name='ImageName', position='Query'),
  licenseType?: string(name='LicenseType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: string(name='Status', position='Query'),
}

model ModifyImageAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyImageAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyImageAttributeResponseBody(name='body'),
}

async function modifyImageAttribute(request: ModifyImageAttributeRequest): ModifyImageAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyImageAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyImageShareGroupPermissionRequest {
  addGroup?: [ string ](name='AddGroup', position='Query'),
  removeGroup?: [ string ](name='RemoveGroup', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  imageId: string(name='ImageId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyImageShareGroupPermissionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyImageShareGroupPermissionResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyImageShareGroupPermissionResponseBody(name='body'),
}

async function modifyImageShareGroupPermission(request: ModifyImageShareGroupPermissionRequest): ModifyImageShareGroupPermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyImageShareGroupPermission', 'POST', '/', 'json', false, 'json', request);
}

model ModifyImageSharePermissionRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  addAccount?: [ string ](name='AddAccount', position='Query'),
  imageId: string(name='ImageId', position='Query'),
  isPublic?: boolean(name='IsPublic', description='', position='Query'),
  launchPermission?: string(name='LaunchPermission', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  removeAccount?: [ string ](name='RemoveAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyImageSharePermissionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyImageSharePermissionResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyImageSharePermissionResponseBody(name='body'),
}

async function modifyImageSharePermission(request: ModifyImageSharePermissionRequest): ModifyImageSharePermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyImageSharePermission', 'POST', '/', 'json', false, 'json', request);
}

model ModifyInstanceAttachmentAttributesRequest {
  privatePoolOptions?: {
    id?: string(name='Id'),
    matchCriteria: string(name='MatchCriteria'),
  }(name='PrivatePoolOptions', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyInstanceAttachmentAttributesResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceAttachmentAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceAttachmentAttributesResponseBody(name='body'),
}

async function modifyInstanceAttachmentAttributes(request: ModifyInstanceAttachmentAttributesRequest): ModifyInstanceAttachmentAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceAttachmentAttributes', 'POST', '/', 'json', false, 'json', request);
}

model ModifyInstanceAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  creditSpecification?: string(name='CreditSpecification', position='Query'),
  deletionProtection?: boolean(name='DeletionProtection', position='Query'),
  description?: string(name='Description', position='Query'),
  hostName?: string(name='HostName', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  instanceName?: string(name='InstanceName', position='Query'),
  networkInterfaceQueueNumber?: int32(name='NetworkInterfaceQueueNumber', minimum=-1, position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  password?: string(name='Password', position='Query'),
  recyclable?: boolean(name='Recyclable', position='Query'),
  remoteConnectionOptions?: {
    password?: string(name='Password'),
    type?: string(name='Type'),
  }(name='RemoteConnectionOptions', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupIds?: [ string ](name='SecurityGroupIds', position='Query'),
  userData?: string(name='UserData', position='Query'),
}

model ModifyInstanceAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceAttributeResponseBody(name='body'),
}

async function modifyInstanceAttribute(request: ModifyInstanceAttributeRequest): ModifyInstanceAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyInstanceAutoReleaseTimeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  autoReleaseTime?: string(name='AutoReleaseTime', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyInstanceAutoReleaseTimeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceAutoReleaseTimeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceAutoReleaseTimeResponseBody(name='body'),
}

async function modifyInstanceAutoReleaseTime(request: ModifyInstanceAutoReleaseTimeRequest): ModifyInstanceAutoReleaseTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceAutoReleaseTime', 'POST', '/', 'json', false, 'json', request);
}

model ModifyInstanceAutoRenewAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  autoRenew?: boolean(name='AutoRenew', position='Query'),
  duration?: int32(name='Duration', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  renewalStatus?: string(name='RenewalStatus', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyInstanceAutoRenewAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceAutoRenewAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceAutoRenewAttributeResponseBody(name='body'),
}

async function modifyInstanceAutoRenewAttribute(request: ModifyInstanceAutoRenewAttributeRequest): ModifyInstanceAutoRenewAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceAutoRenewAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyInstanceChargeTypeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  includeDataDisks?: boolean(name='IncludeDataDisks', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  instanceIds: string(name='InstanceIds', position='Query'),
  isDetailFee?: boolean(name='IsDetailFee', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyInstanceChargeTypeResponseBody = {
  feeOfInstances?: {
    feeOfInstance?: [ 
    {
      currency?: string(name='Currency'),
      fee?: string(name='Fee'),
      instanceId?: string(name='InstanceId'),
    }
  ](name='FeeOfInstance')
  }(name='FeeOfInstances'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyInstanceChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceChargeTypeResponseBody(name='body'),
}

async function modifyInstanceChargeType(request: ModifyInstanceChargeTypeRequest): ModifyInstanceChargeTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceChargeType', 'POST', '/', 'json', false, 'json', request);
}

model ModifyInstanceDeploymentRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  affinity?: string(name='Affinity', position='Query'),
  dedicatedHostClusterId?: string(name='DedicatedHostClusterId', position='Query'),
  dedicatedHostId?: string(name='DedicatedHostId', position='Query'),
  deploymentSetGroupNo?: int32(name='DeploymentSetGroupNo', position='Query'),
  deploymentSetId?: string(name='DeploymentSetId', position='Query'),
  force?: boolean(name='Force', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  migrationType?: string(name='MigrationType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  removeFromDeploymentSet?: boolean(name='RemoveFromDeploymentSet', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tenancy?: string(name='Tenancy', position='Query'),
}

model ModifyInstanceDeploymentResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceDeploymentResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceDeploymentResponseBody(name='body'),
}

async function modifyInstanceDeployment(request: ModifyInstanceDeploymentRequest): ModifyInstanceDeploymentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceDeployment', 'POST', '/', 'json', false, 'json', request);
}

model ModifyInstanceMaintenanceAttributesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  actionOnMaintenance?: string(name='ActionOnMaintenance', position='Query'),
  instanceId?: [ string ](name='InstanceId', position='Query'),
  maintenanceWindow?: [ 
    {
      endTime?: string(name='EndTime'),
      startTime?: string(name='StartTime'),
    }
  ](name='MaintenanceWindow', position='Query'),
  notifyOnMaintenance?: boolean(name='NotifyOnMaintenance', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyInstanceMaintenanceAttributesResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceMaintenanceAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceMaintenanceAttributesResponseBody(name='body'),
}

async function modifyInstanceMaintenanceAttributes(request: ModifyInstanceMaintenanceAttributesRequest): ModifyInstanceMaintenanceAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceMaintenanceAttributes', 'POST', '/', 'json', false, 'json', request);
}

model ModifyInstanceMetadataOptionsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  httpEndpoint: string(name='HttpEndpoint', position='Query'),
  httpPutResponseHopLimit?: int32(name='HttpPutResponseHopLimit', position='Query'),
  httpTokens?: string(name='HttpTokens', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyInstanceMetadataOptionsResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceMetadataOptionsResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceMetadataOptionsResponseBody(name='body'),
}

async function modifyInstanceMetadataOptions(request: ModifyInstanceMetadataOptionsRequest): ModifyInstanceMetadataOptionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceMetadataOptions', 'POST', '/', 'json', false, 'json', request);
}

model ModifyInstanceNetworkSpecRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  allocatePublicIp?: boolean(name='AllocatePublicIp', position='Query'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  ISP?: string(name='ISP', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn', minimum=1, maximum=200, position='Query'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', position='Query'),
  networkChargeType?: string(name='NetworkChargeType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model ModifyInstanceNetworkSpecResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyInstanceNetworkSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceNetworkSpecResponseBody(name='body'),
}

async function modifyInstanceNetworkSpec(request: ModifyInstanceNetworkSpecRequest): ModifyInstanceNetworkSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceNetworkSpec', 'POST', '/', 'json', false, 'json', request);
}

model ModifyInstanceSpecRequest {
  systemDisk?: {
    category?: string(name='Category'),
  }(name='SystemDisk', position='Query'),
  temporary?: {
    endTime?: string(name='EndTime'),
    internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', minimum=1, maximum=100),
    startTime?: string(name='StartTime'),
  }(name='Temporary', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  allowMigrateAcrossZone?: boolean(name='AllowMigrateAcrossZone', position='Query'),
  async?: boolean(name='Async', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn', minimum=1, maximum=200, position='Query'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyInstanceSpecResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceSpecResponseBody(name='body'),
}

async function modifyInstanceSpec(request: ModifyInstanceSpecRequest): ModifyInstanceSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceSpec', 'POST', '/', 'json', false, 'json', request);
}

model ModifyInstanceVncPasswdRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vncPassword: string(name='VncPassword', position='Query'),
}

model ModifyInstanceVncPasswdResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceVncPasswdResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceVncPasswdResponseBody(name='body'),
}

async function modifyInstanceVncPasswd(request: ModifyInstanceVncPasswdRequest): ModifyInstanceVncPasswdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceVncPasswd', 'POST', '/', 'json', false, 'json', request);
}

model ModifyInstanceVpcAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId?: [ string ](name='SecurityGroupId', position='Query'),
  vSwitchId: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model ModifyInstanceVpcAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceVpcAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceVpcAttributeResponseBody(name='body'),
}

async function modifyInstanceVpcAttribute(request: ModifyInstanceVpcAttributeRequest): ModifyInstanceVpcAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceVpcAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyLaunchTemplateDefaultVersionRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  defaultVersionNumber: long(name='DefaultVersionNumber', position='Query'),
  launchTemplateId?: string(name='LaunchTemplateId', position='Query'),
  launchTemplateName?: string(name='LaunchTemplateName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyLaunchTemplateDefaultVersionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyLaunchTemplateDefaultVersionResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyLaunchTemplateDefaultVersionResponseBody(name='body'),
}

async function modifyLaunchTemplateDefaultVersion(request: ModifyLaunchTemplateDefaultVersionRequest): ModifyLaunchTemplateDefaultVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyLaunchTemplateDefaultVersion', 'POST', '/', 'json', false, 'json', request);
}

model ModifyManagedInstanceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId: string(name='InstanceId', position='Query'),
  instanceName: string(name='InstanceName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyManagedInstanceResponseBody = {
  instance?: {
    instanceId?: string(name='InstanceId'),
    instanceName?: string(name='InstanceName'),
  }(name='Instance'),
  requestId?: string(name='RequestId'),
}

model ModifyManagedInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyManagedInstanceResponseBody(name='body'),
}

async function modifyManagedInstance(request: ModifyManagedInstanceRequest): ModifyManagedInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyManagedInstance', 'POST', '/', 'json', false, 'json', request);
}

model ModifyNetworkInterfaceAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  description?: string(name='Description', position='Query'),
  networkInterfaceId: string(name='NetworkInterfaceId', position='Query'),
  networkInterfaceName?: string(name='NetworkInterfaceName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  queueNumber?: int32(name='QueueNumber', minimum=-1, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId?: [ string ](name='SecurityGroupId', position='Query'),
}

model ModifyNetworkInterfaceAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNetworkInterfaceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNetworkInterfaceAttributeResponseBody(name='body'),
}

async function modifyNetworkInterfaceAttribute(request: ModifyNetworkInterfaceAttributeRequest): ModifyNetworkInterfaceAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyNetworkInterfaceAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyPhysicalConnectionAttributeRequest {
  circuitCode?: string(name='CircuitCode', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  lineOperator?: string(name='LineOperator', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  peerLocation?: string(name='PeerLocation', position='Query'),
  physicalConnectionId: string(name='PhysicalConnectionId', position='Query'),
  portType?: string(name='PortType', position='Query'),
  redundantPhysicalConnectionId?: string(name='RedundantPhysicalConnectionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
  bandwidth?: int32(name='bandwidth', position='Query'),
}

model ModifyPhysicalConnectionAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyPhysicalConnectionAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyPhysicalConnectionAttributeResponseBody(name='body'),
}

async function modifyPhysicalConnectionAttribute(request: ModifyPhysicalConnectionAttributeRequest): ModifyPhysicalConnectionAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyPhysicalConnectionAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyPrefixListRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  addEntry?: [ 
    {
      cidr: string(name='Cidr'),
      description?: string(name='Description'),
    }
  ](name='AddEntry', position='Query'),
  description?: string(name='Description', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  prefixListId: string(name='PrefixListId', position='Query'),
  prefixListName?: string(name='PrefixListName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  removeEntry?: [ 
    {
      cidr: string(name='Cidr'),
    }
  ](name='RemoveEntry', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyPrefixListResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyPrefixListResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyPrefixListResponseBody(name='body'),
}

async function modifyPrefixList(request: ModifyPrefixListRequest): ModifyPrefixListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyPrefixList', 'POST', '/', 'json', false, 'json', request);
}

model ModifyPrepayInstanceSpecRequest {
  systemDisk?: {
    category?: string(name='Category'),
  }(name='SystemDisk', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  instanceType: string(name='InstanceType', position='Query'),
  migrateAcrossZone?: boolean(name='MigrateAcrossZone', position='Query'),
  operatorType?: string(name='OperatorType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  rebootTime?: string(name='RebootTime', position='Query'),
  rebootWhenFinished?: boolean(name='RebootWhenFinished', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyPrepayInstanceSpecResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyPrepayInstanceSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyPrepayInstanceSpecResponseBody(name='body'),
}

async function modifyPrepayInstanceSpec(request: ModifyPrepayInstanceSpecRequest): ModifyPrepayInstanceSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyPrepayInstanceSpec', 'POST', '/', 'json', false, 'json', request);
}

model ModifyReservedInstanceAttributeRequest {
  description?: string(name='Description', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  reservedInstanceId: string(name='ReservedInstanceId', position='Query'),
  reservedInstanceName?: string(name='ReservedInstanceName', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyReservedInstanceAttributeResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ModifyReservedInstanceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyReservedInstanceAttributeResponseBody(name='body'),
}

async function modifyReservedInstanceAttribute(request: ModifyReservedInstanceAttributeRequest): ModifyReservedInstanceAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyReservedInstanceAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyReservedInstancesRequest {
  configuration?: [ 
    {
      instanceAmount?: int32(name='InstanceAmount'),
      instanceType?: string(name='InstanceType'),
      reservedInstanceName?: string(name='ReservedInstanceName'),
      scope?: string(name='Scope'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Configuration', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  reservedInstanceId: [ string ](name='ReservedInstanceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyReservedInstancesResponseBody = {
  requestId?: string(name='RequestId'),
  reservedInstanceIdSets?: {
    reservedInstanceId?: [ string ](name='ReservedInstanceId')
  }(name='ReservedInstanceIdSets'),
}

model ModifyReservedInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyReservedInstancesResponseBody(name='body'),
}

async function modifyReservedInstances(request: ModifyReservedInstancesRequest): ModifyReservedInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyReservedInstances', 'POST', '/', 'json', false, 'json', request);
}

model ModifyRouterInterfaceAttributeRequest {
  description?: string(name='Description', position='Query'),
  healthCheckSourceIp?: string(name='HealthCheckSourceIp', position='Query'),
  healthCheckTargetIp?: string(name='HealthCheckTargetIp', position='Query'),
  name?: string(name='Name', position='Query'),
  oppositeInterfaceId?: string(name='OppositeInterfaceId', position='Query'),
  oppositeInterfaceOwnerId?: long(name='OppositeInterfaceOwnerId', position='Query'),
  oppositeRouterId?: string(name='OppositeRouterId', position='Query'),
  oppositeRouterType?: string(name='OppositeRouterType', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routerInterfaceId: string(name='RouterInterfaceId', position='Query'),
}

model ModifyRouterInterfaceAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyRouterInterfaceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyRouterInterfaceAttributeResponseBody(name='body'),
}

async function modifyRouterInterfaceAttribute(request: ModifyRouterInterfaceAttributeRequest): ModifyRouterInterfaceAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyRouterInterfaceAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyRouterInterfaceSpecRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routerInterfaceId: string(name='RouterInterfaceId', position='Query'),
  spec: string(name='Spec', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
}

model ModifyRouterInterfaceSpecResponseBody = {
  requestId?: string(name='RequestId'),
  spec?: string(name='Spec'),
}

model ModifyRouterInterfaceSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyRouterInterfaceSpecResponseBody(name='body'),
}

async function modifyRouterInterfaceSpec(request: ModifyRouterInterfaceSpecRequest): ModifyRouterInterfaceSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyRouterInterfaceSpec', 'POST', '/', 'json', false, 'json', request);
}

model ModifySecurityGroupAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  description?: string(name='Description', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId: string(name='SecurityGroupId', position='Query'),
  securityGroupName?: string(name='SecurityGroupName', position='Query'),
}

model ModifySecurityGroupAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySecurityGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySecurityGroupAttributeResponseBody(name='body'),
}

async function modifySecurityGroupAttribute(request: ModifySecurityGroupAttributeRequest): ModifySecurityGroupAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySecurityGroupAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifySecurityGroupEgressRuleRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  destCidrIp?: string(name='DestCidrIp', position='Query'),
  destGroupId?: string(name='DestGroupId', position='Query'),
  destGroupOwnerAccount?: string(name='DestGroupOwnerAccount', position='Query'),
  destGroupOwnerId?: long(name='DestGroupOwnerId', position='Query'),
  destPrefixListId?: string(name='DestPrefixListId', position='Query'),
  ipProtocol: string(name='IpProtocol', position='Query'),
  ipv6DestCidrIp?: string(name='Ipv6DestCidrIp', position='Query'),
  ipv6SourceCidrIp?: string(name='Ipv6SourceCidrIp', position='Query'),
  nicType?: string(name='NicType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  policy?: string(name='Policy', position='Query'),
  portRange: string(name='PortRange', position='Query'),
  priority?: string(name='Priority', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId: string(name='SecurityGroupId', position='Query'),
  sourceCidrIp?: string(name='SourceCidrIp', position='Query'),
  sourcePortRange?: string(name='SourcePortRange', position='Query'),
}

model ModifySecurityGroupEgressRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySecurityGroupEgressRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySecurityGroupEgressRuleResponseBody(name='body'),
}

async function modifySecurityGroupEgressRule(request: ModifySecurityGroupEgressRuleRequest): ModifySecurityGroupEgressRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySecurityGroupEgressRule', 'POST', '/', 'json', false, 'json', request);
}

model ModifySecurityGroupPolicyRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  innerAccessPolicy: string(name='InnerAccessPolicy', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId: string(name='SecurityGroupId', position='Query'),
}

model ModifySecurityGroupPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySecurityGroupPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySecurityGroupPolicyResponseBody(name='body'),
}

async function modifySecurityGroupPolicy(request: ModifySecurityGroupPolicyRequest): ModifySecurityGroupPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySecurityGroupPolicy', 'POST', '/', 'json', false, 'json', request);
}

model ModifySecurityGroupRuleRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  destCidrIp?: string(name='DestCidrIp', position='Query'),
  ipProtocol: string(name='IpProtocol', position='Query'),
  ipv6DestCidrIp?: string(name='Ipv6DestCidrIp', position='Query'),
  ipv6SourceCidrIp?: string(name='Ipv6SourceCidrIp', position='Query'),
  nicType?: string(name='NicType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  policy?: string(name='Policy', position='Query'),
  portRange: string(name='PortRange', position='Query'),
  priority?: string(name='Priority', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId: string(name='SecurityGroupId', position='Query'),
  sourceCidrIp?: string(name='SourceCidrIp', position='Query'),
  sourceGroupId?: string(name='SourceGroupId', position='Query'),
  sourceGroupOwnerAccount?: string(name='SourceGroupOwnerAccount', position='Query'),
  sourceGroupOwnerId?: long(name='SourceGroupOwnerId', position='Query'),
  sourcePortRange?: string(name='SourcePortRange', position='Query'),
  sourcePrefixListId?: string(name='SourcePrefixListId', position='Query'),
}

model ModifySecurityGroupRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySecurityGroupRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySecurityGroupRuleResponseBody(name='body'),
}

async function modifySecurityGroupRule(request: ModifySecurityGroupRuleRequest): ModifySecurityGroupRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySecurityGroupRule', 'POST', '/', 'json', false, 'json', request);
}

model ModifySnapshotAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  description?: string(name='Description', position='Query'),
  disableInstantAccess?: boolean(name='DisableInstantAccess', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  snapshotId: string(name='SnapshotId', position='Query'),
  snapshotName?: string(name='SnapshotName', position='Query'),
}

model ModifySnapshotAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySnapshotAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySnapshotAttributeResponseBody(name='body'),
}

async function modifySnapshotAttribute(request: ModifySnapshotAttributeRequest): ModifySnapshotAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySnapshotAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifySnapshotGroupRequest {
  description?: string(name='Description', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  snapshotGroupId: string(name='SnapshotGroupId', position='Query'),
}

model ModifySnapshotGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySnapshotGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySnapshotGroupResponseBody(name='body'),
}

async function modifySnapshotGroup(request: ModifySnapshotGroupRequest): ModifySnapshotGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySnapshotGroup', 'POST', '/', 'json', false, 'json', request);
}

model ModifyStorageCapacityUnitAttributeRequest {
  description?: string(name='Description', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  storageCapacityUnitId: string(name='StorageCapacityUnitId', position='Query'),
}

model ModifyStorageCapacityUnitAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyStorageCapacityUnitAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyStorageCapacityUnitAttributeResponseBody(name='body'),
}

async function modifyStorageCapacityUnitAttribute(request: ModifyStorageCapacityUnitAttributeRequest): ModifyStorageCapacityUnitAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyStorageCapacityUnitAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyStorageSetAttributeRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  storageSetId: string(name='StorageSetId', position='Query'),
  storageSetName?: string(name='StorageSetName', position='Query'),
}

model ModifyStorageSetAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyStorageSetAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyStorageSetAttributeResponseBody(name='body'),
}

async function modifyStorageSetAttribute(request: ModifyStorageSetAttributeRequest): ModifyStorageSetAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyStorageSetAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyUserBusinessBehaviorRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  statusKey: string(name='statusKey', position='Query'),
  statusValue: string(name='statusValue', position='Query'),
}

model ModifyUserBusinessBehaviorResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyUserBusinessBehaviorResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyUserBusinessBehaviorResponseBody(name='body'),
}

async function modifyUserBusinessBehavior(request: ModifyUserBusinessBehaviorRequest): ModifyUserBusinessBehaviorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyUserBusinessBehavior', 'POST', '/', 'json', false, 'json', request);
}

model ModifyVRouterAttributeRequest {
  description?: string(name='Description', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vRouterId: string(name='VRouterId', position='Query'),
  vRouterName?: string(name='VRouterName', position='Query'),
}

model ModifyVRouterAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVRouterAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVRouterAttributeResponseBody(name='body'),
}

async function modifyVRouterAttribute(request: ModifyVRouterAttributeRequest): ModifyVRouterAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyVRouterAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyVSwitchAttributeRequest {
  description?: string(name='Description', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vSwitchId: string(name='VSwitchId', position='Query'),
  vSwitchName?: string(name='VSwitchName', position='Query'),
}

model ModifyVSwitchAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVSwitchAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVSwitchAttributeResponseBody(name='body'),
}

async function modifyVSwitchAttribute(request: ModifyVSwitchAttributeRequest): ModifyVSwitchAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyVSwitchAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyVirtualBorderRouterAttributeRequest {
  circuitCode?: string(name='CircuitCode', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  localGatewayIp?: string(name='LocalGatewayIp', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  peerGatewayIp?: string(name='PeerGatewayIp', position='Query'),
  peeringSubnetMask?: string(name='PeeringSubnetMask', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
  vbrId: string(name='VbrId', position='Query'),
  vlanId?: int32(name='VlanId', position='Query'),
}

model ModifyVirtualBorderRouterAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVirtualBorderRouterAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVirtualBorderRouterAttributeResponseBody(name='body'),
}

async function modifyVirtualBorderRouterAttribute(request: ModifyVirtualBorderRouterAttributeRequest): ModifyVirtualBorderRouterAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyVirtualBorderRouterAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyVpcAttributeRequest {
  cidrBlock?: string(name='CidrBlock', position='Query'),
  description?: string(name='Description', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
  vpcName?: string(name='VpcName', position='Query'),
}

model ModifyVpcAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVpcAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVpcAttributeResponseBody(name='body'),
}

async function modifyVpcAttribute(request: ModifyVpcAttributeRequest): ModifyVpcAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyVpcAttribute', 'POST', '/', 'json', false, 'json', request);
}

model PurchaseReservedInstancesOfferingRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  instanceAmount?: int32(name='InstanceAmount', minimum=1, maximum=100, position='Query'),
  instanceType: string(name='InstanceType', position='Query'),
  offeringType?: string(name='OfferingType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  platform?: string(name='Platform', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  reservedInstanceName?: string(name='ReservedInstanceName', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scope?: string(name='Scope', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model PurchaseReservedInstancesOfferingResponseBody = {
  requestId?: string(name='RequestId'),
  reservedInstanceIdSets?: {
    reservedInstanceId?: [ string ](name='ReservedInstanceId')
  }(name='ReservedInstanceIdSets'),
}

model PurchaseReservedInstancesOfferingResponse = {
  headers: map[string]string(name='headers'),
  body: PurchaseReservedInstancesOfferingResponseBody(name='body'),
}

async function purchaseReservedInstancesOffering(request: PurchaseReservedInstancesOfferingRequest): PurchaseReservedInstancesOfferingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PurchaseReservedInstancesOffering', 'POST', '/', 'json', false, 'json', request);
}

model PurchaseStorageCapacityUnitRequest {
  amount?: int32(name='Amount', minimum=1, maximum=20, position='Query'),
  capacity: int32(name='Capacity', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  fromApp?: string(name='FromApp', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model PurchaseStorageCapacityUnitResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
  storageCapacityUnitIds?: {
    storageCapacityUnitId?: [ string ](name='StorageCapacityUnitId')
  }(name='StorageCapacityUnitIds'),
}

model PurchaseStorageCapacityUnitResponse = {
  headers: map[string]string(name='headers'),
  body: PurchaseStorageCapacityUnitResponseBody(name='body'),
}

async function purchaseStorageCapacityUnit(request: PurchaseStorageCapacityUnitRequest): PurchaseStorageCapacityUnitResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PurchaseStorageCapacityUnit', 'POST', '/', 'json', false, 'json', request);
}

model ReActivateInstancesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ReActivateInstancesResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReActivateInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ReActivateInstancesResponseBody(name='body'),
}

async function reActivateInstances(request: ReActivateInstancesRequest): ReActivateInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReActivateInstances', 'POST', '/', 'json', false, 'json', request);
}

model ReInitDiskRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  autoStartInstance?: boolean(name='AutoStartInstance', position='Query'),
  diskId: string(name='DiskId', position='Query'),
  keyPairName?: string(name='KeyPairName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  password?: string(name='Password', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityEnhancementStrategy?: string(name='SecurityEnhancementStrategy', position='Query'),
}

model ReInitDiskResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReInitDiskResponse = {
  headers: map[string]string(name='headers'),
  body: ReInitDiskResponseBody(name='body'),
}

async function reInitDisk(request: ReInitDiskRequest): ReInitDiskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReInitDisk', 'POST', '/', 'json', false, 'json', request);
}

model RebootInstanceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  dryRun?: boolean(name='DryRun', position='Query'),
  forceStop?: boolean(name='ForceStop', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RebootInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model RebootInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RebootInstanceResponseBody(name='body'),
}

async function rebootInstance(request: RebootInstanceRequest): RebootInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RebootInstance', 'POST', '/', 'json', false, 'json', request);
}

model RebootInstancesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  batchOptimization?: string(name='BatchOptimization', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  forceReboot?: boolean(name='ForceReboot', position='Query'),
  instanceId: [ string ](name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RebootInstancesResponseBody = {
  instanceResponses?: {
    instanceResponse?: [ 
    {
      code?: string(name='Code'),
      currentStatus?: string(name='CurrentStatus'),
      instanceId?: string(name='InstanceId'),
      message?: string(name='Message'),
      previousStatus?: string(name='PreviousStatus'),
    }
  ](name='InstanceResponse')
  }(name='InstanceResponses'),
  requestId?: string(name='RequestId'),
}

model RebootInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: RebootInstancesResponseBody(name='body'),
}

async function rebootInstances(request: RebootInstancesRequest): RebootInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RebootInstances', 'POST', '/', 'json', false, 'json', request);
}

model RecoverVirtualBorderRouterRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
  vbrId: string(name='VbrId', position='Query'),
}

model RecoverVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model RecoverVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: RecoverVirtualBorderRouterResponseBody(name='body'),
}

async function recoverVirtualBorderRouter(request: RecoverVirtualBorderRouterRequest): RecoverVirtualBorderRouterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RecoverVirtualBorderRouter', 'POST', '/', 'json', false, 'json', request);
}

model RedeployDedicatedHostRequest {
  dedicatedHostId: string(name='DedicatedHostId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RedeployDedicatedHostResponseBody = {
  requestId?: string(name='RequestId'),
}

model RedeployDedicatedHostResponse = {
  headers: map[string]string(name='headers'),
  body: RedeployDedicatedHostResponseBody(name='body'),
}

async function redeployDedicatedHost(request: RedeployDedicatedHostRequest): RedeployDedicatedHostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RedeployDedicatedHost', 'POST', '/', 'json', false, 'json', request);
}

model RedeployInstanceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  forceStop?: boolean(name='ForceStop', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RedeployInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model RedeployInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RedeployInstanceResponseBody(name='body'),
}

async function redeployInstance(request: RedeployInstanceRequest): RedeployInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RedeployInstance', 'POST', '/', 'json', false, 'json', request);
}

model ReleaseCapacityReservationRequest {
  privatePoolOptions?: {
    id: string(name='Id'),
  }(name='PrivatePoolOptions', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ReleaseCapacityReservationResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseCapacityReservationResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseCapacityReservationResponseBody(name='body'),
}

async function releaseCapacityReservation(request: ReleaseCapacityReservationRequest): ReleaseCapacityReservationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleaseCapacityReservation', 'POST', '/', 'json', false, 'json', request);
}

model ReleaseDedicatedHostRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  dedicatedHostId: string(name='DedicatedHostId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ReleaseDedicatedHostResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseDedicatedHostResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseDedicatedHostResponseBody(name='body'),
}

async function releaseDedicatedHost(request: ReleaseDedicatedHostRequest): ReleaseDedicatedHostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleaseDedicatedHost', 'POST', '/', 'json', false, 'json', request);
}

model ReleaseEipAddressRequest {
  allocationId: string(name='AllocationId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ReleaseEipAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseEipAddressResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseEipAddressResponseBody(name='body'),
}

async function releaseEipAddress(request: ReleaseEipAddressRequest): ReleaseEipAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleaseEipAddress', 'POST', '/', 'json', false, 'json', request);
}

model ReleasePublicIpAddressRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId?: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  publicIpAddress: string(name='PublicIpAddress', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ReleasePublicIpAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleasePublicIpAddressResponse = {
  headers: map[string]string(name='headers'),
  body: ReleasePublicIpAddressResponseBody(name='body'),
}

async function releasePublicIpAddress(request: ReleasePublicIpAddressRequest): ReleasePublicIpAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleasePublicIpAddress', 'POST', '/', 'json', false, 'json', request);
}

model RemoveBandwidthPackageIpsRequest {
  bandwidthPackageId: string(name='BandwidthPackageId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  removedIpAddresses: [ string ](name='RemovedIpAddresses', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RemoveBandwidthPackageIpsResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveBandwidthPackageIpsResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveBandwidthPackageIpsResponseBody(name='body'),
}

async function removeBandwidthPackageIps(request: RemoveBandwidthPackageIpsRequest): RemoveBandwidthPackageIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveBandwidthPackageIps', 'POST', '/', 'json', false, 'json', request);
}

model RemoveTagsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId: string(name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model RemoveTagsResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveTagsResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveTagsResponseBody(name='body'),
}

async function removeTags(request: RemoveTagsRequest): RemoveTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveTags', 'POST', '/', 'json', false, 'json', request);
}

model RenewDedicatedHostsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  dedicatedHostIds: string(name='DedicatedHostIds', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RenewDedicatedHostsResponseBody = {
  requestId?: string(name='RequestId'),
}

model RenewDedicatedHostsResponse = {
  headers: map[string]string(name='headers'),
  body: RenewDedicatedHostsResponseBody(name='body'),
}

async function renewDedicatedHosts(request: RenewDedicatedHostsRequest): RenewDedicatedHostsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RenewDedicatedHosts', 'POST', '/', 'json', false, 'json', request);
}

model RenewInstanceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  expectedRenewDay?: int32(name='ExpectedRenewDay', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RenewInstanceResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model RenewInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RenewInstanceResponseBody(name='body'),
}

async function renewInstance(request: RenewInstanceRequest): RenewInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RenewInstance', 'POST', '/', 'json', false, 'json', request);
}

model RenewReservedInstancesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  reservedInstanceId?: [ string ](name='ReservedInstanceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RenewReservedInstancesResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
  reservedInstanceIdSets?: {
    reservedInstanceId?: [ string ](name='ReservedInstanceId')
  }(name='ReservedInstanceIdSets'),
}

model RenewReservedInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: RenewReservedInstancesResponseBody(name='body'),
}

async function renewReservedInstances(request: RenewReservedInstancesRequest): RenewReservedInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RenewReservedInstances', 'POST', '/', 'json', false, 'json', request);
}

model ReplaceSystemDiskRequest {
  systemDisk?: {
    size?: int32(name='Size'),
  }(name='SystemDisk', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  architecture?: string(name='Architecture', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  diskId?: string(name='DiskId', position='Query'),
  imageId?: string(name='ImageId', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  keyPairName?: string(name='KeyPairName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  password?: string(name='Password', position='Query'),
  passwordInherit?: boolean(name='PasswordInherit', position='Query'),
  platform?: string(name='Platform', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityEnhancementStrategy?: string(name='SecurityEnhancementStrategy', position='Query'),
  useAdditionalService?: boolean(name='UseAdditionalService', position='Query'),
}

model ReplaceSystemDiskResponseBody = {
  diskId?: string(name='DiskId'),
  requestId?: string(name='RequestId'),
}

model ReplaceSystemDiskResponse = {
  headers: map[string]string(name='headers'),
  body: ReplaceSystemDiskResponseBody(name='body'),
}

async function replaceSystemDisk(request: ReplaceSystemDiskRequest): ReplaceSystemDiskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReplaceSystemDisk', 'POST', '/', 'json', false, 'json', request);
}

model ReportInstancesStatusRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  description: string(name='Description', position='Query'),
  device?: [ string ](name='Device', position='Query'),
  diskId?: [ string ](name='DiskId', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  instanceId: [ string ](name='InstanceId', position='Query'),
  issueCategory?: string(name='IssueCategory', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  reason?: string(name='Reason', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model ReportInstancesStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReportInstancesStatusResponse = {
  headers: map[string]string(name='headers'),
  body: ReportInstancesStatusResponseBody(name='body'),
}

async function reportInstancesStatus(request: ReportInstancesStatusRequest): ReportInstancesStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReportInstancesStatus', 'POST', '/', 'json', false, 'json', request);
}

model ResetDiskRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  diskId: string(name='DiskId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  snapshotId: string(name='SnapshotId', position='Query'),
}

model ResetDiskResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetDiskResponse = {
  headers: map[string]string(name='headers'),
  body: ResetDiskResponseBody(name='body'),
}

async function resetDisk(request: ResetDiskRequest): ResetDiskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetDisk', 'POST', '/', 'json', false, 'json', request);
}

model ResetDisksRequest {
  disk: [ 
    {
      diskId?: string(name='DiskId'),
      snapshotId?: string(name='SnapshotId'),
    }
  ](name='Disk', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ResetDisksResponseBody = {
  operationProgressSet?: {
    operationProgress?: [ 
    {
      errorCode?: string(name='ErrorCode'),
      errorMsg?: string(name='ErrorMsg'),
      operationStatus?: string(name='OperationStatus'),
      relatedItemSet?: {
        relatedItem?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='RelatedItem')
      }(name='RelatedItemSet'),
    }
  ](name='OperationProgress')
  }(name='OperationProgressSet'),
  requestId?: string(name='RequestId'),
}

model ResetDisksResponse = {
  headers: map[string]string(name='headers'),
  body: ResetDisksResponseBody(name='body'),
}

async function resetDisks(request: ResetDisksRequest): ResetDisksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetDisks', 'POST', '/', 'json', false, 'json', request);
}

model ResizeDiskRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  diskId: string(name='DiskId', position='Query'),
  newSize: int32(name='NewSize', minimum=5, maximum=32768, position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  type?: string(name='Type', position='Query'),
}

model ResizeDiskResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ResizeDiskResponse = {
  headers: map[string]string(name='headers'),
  body: ResizeDiskResponseBody(name='body'),
}

async function resizeDisk(request: ResizeDiskRequest): ResizeDiskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResizeDisk', 'POST', '/', 'json', false, 'json', request);
}

model RevokeSecurityGroupRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  destCidrIp?: string(name='DestCidrIp', position='Query'),
  ipProtocol?: string(name='IpProtocol', position='Query'),
  ipv6DestCidrIp?: string(name='Ipv6DestCidrIp', position='Query'),
  ipv6SourceCidrIp?: string(name='Ipv6SourceCidrIp', position='Query'),
  nicType?: string(name='NicType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  permissions?: [ 
    {
      description?: string(name='Description'),
      destCidrIp?: string(name='DestCidrIp'),
      ipProtocol?: string(name='IpProtocol'),
      ipv6DestCidrIp?: string(name='Ipv6DestCidrIp'),
      ipv6SourceCidrIp?: string(name='Ipv6SourceCidrIp'),
      nicType?: string(name='NicType'),
      policy?: string(name='Policy'),
      portRange?: string(name='PortRange'),
      priority?: string(name='Priority'),
      sourceCidrIp?: string(name='SourceCidrIp'),
      sourceGroupId?: string(name='SourceGroupId'),
      sourceGroupOwnerAccount?: string(name='SourceGroupOwnerAccount'),
      sourceGroupOwnerId?: long(name='SourceGroupOwnerId'),
      sourcePortRange?: string(name='SourcePortRange'),
      sourcePrefixListId?: string(name='SourcePrefixListId'),
    }
  ](name='Permissions', position='Query'),
  policy?: string(name='Policy', position='Query'),
  portRange?: string(name='PortRange', position='Query'),
  priority?: string(name='Priority', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId: string(name='SecurityGroupId', position='Query'),
  sourceCidrIp?: string(name='SourceCidrIp', position='Query'),
  sourceGroupId?: string(name='SourceGroupId', position='Query'),
  sourceGroupOwnerAccount?: string(name='SourceGroupOwnerAccount', position='Query'),
  sourceGroupOwnerId?: long(name='SourceGroupOwnerId', position='Query'),
  sourcePortRange?: string(name='SourcePortRange', position='Query'),
  sourcePrefixListId?: string(name='SourcePrefixListId', position='Query'),
}

model RevokeSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model RevokeSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: RevokeSecurityGroupResponseBody(name='body'),
}

async function revokeSecurityGroup(request: RevokeSecurityGroupRequest): RevokeSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RevokeSecurityGroup', 'POST', '/', 'json', false, 'json', request);
}

model RevokeSecurityGroupEgressRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  destCidrIp?: string(name='DestCidrIp', position='Query'),
  destGroupId?: string(name='DestGroupId', position='Query'),
  destGroupOwnerAccount?: string(name='DestGroupOwnerAccount', position='Query'),
  destGroupOwnerId?: long(name='DestGroupOwnerId', position='Query'),
  destPrefixListId?: string(name='DestPrefixListId', position='Query'),
  ipProtocol?: string(name='IpProtocol', position='Query'),
  ipv6DestCidrIp?: string(name='Ipv6DestCidrIp', position='Query'),
  ipv6SourceCidrIp?: string(name='Ipv6SourceCidrIp', position='Query'),
  nicType?: string(name='NicType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  permissions?: [ 
    {
      description?: string(name='Description'),
      destCidrIp?: string(name='DestCidrIp'),
      destGroupId?: string(name='DestGroupId'),
      destGroupOwnerAccount?: string(name='DestGroupOwnerAccount'),
      destGroupOwnerId?: string(name='DestGroupOwnerId'),
      destPrefixListId?: string(name='DestPrefixListId'),
      ipProtocol?: string(name='IpProtocol'),
      ipv6DestCidrIp?: string(name='Ipv6DestCidrIp'),
      ipv6SourceCidrIp?: string(name='Ipv6SourceCidrIp'),
      nicType?: string(name='NicType'),
      policy?: string(name='Policy'),
      portRange?: string(name='PortRange'),
      priority?: string(name='Priority'),
      sourceCidrIp?: string(name='SourceCidrIp'),
      sourcePortRange?: string(name='SourcePortRange'),
    }
  ](name='Permissions', position='Query'),
  policy?: string(name='Policy', position='Query'),
  portRange?: string(name='PortRange', position='Query'),
  priority?: string(name='Priority', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId: string(name='SecurityGroupId', position='Query'),
  sourceCidrIp?: string(name='SourceCidrIp', position='Query'),
  sourcePortRange?: string(name='SourcePortRange', position='Query'),
}

model RevokeSecurityGroupEgressResponseBody = {
  requestId?: string(name='RequestId'),
}

model RevokeSecurityGroupEgressResponse = {
  headers: map[string]string(name='headers'),
  body: RevokeSecurityGroupEgressResponseBody(name='body'),
}

async function revokeSecurityGroupEgress(request: RevokeSecurityGroupEgressRequest): RevokeSecurityGroupEgressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RevokeSecurityGroupEgress', 'POST', '/', 'json', false, 'json', request);
}

model RunCommandRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  commandContent: string(name='CommandContent', position='Query'),
  containerId?: string(name='ContainerId', position='Query'),
  containerName?: string(name='ContainerName', position='Query'),
  contentEncoding?: string(name='ContentEncoding', position='Query'),
  description?: string(name='Description', position='Query'),
  enableParameter?: boolean(name='EnableParameter', position='Query'),
  frequency?: string(name='Frequency', position='Query'),
  instanceId: [ string ](name='InstanceId', position='Query'),
  keepCommand?: boolean(name='KeepCommand', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  parameters?: map[string]any(name='Parameters', shrink='json', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  repeatMode?: string(name='RepeatMode', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  timed?: boolean(name='Timed', position='Query'),
  timeout?: long(name='Timeout', position='Query'),
  type: string(name='Type', position='Query'),
  username?: string(name='Username', position='Query'),
  windowsPasswordName?: string(name='WindowsPasswordName', position='Query'),
  workingDir?: string(name='WorkingDir', position='Query'),
}

model RunCommandResponseBody = {
  commandId?: string(name='CommandId'),
  invokeId?: string(name='InvokeId'),
  requestId?: string(name='RequestId'),
}

model RunCommandResponse = {
  headers: map[string]string(name='headers'),
  body: RunCommandResponseBody(name='body'),
}

async function runCommand(request: RunCommandRequest): RunCommandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RunCommand', 'POST', '/', 'json', false, 'json', request);
}

model RunInstancesRequest {
  cpuOptions?: {
    core?: int32(name='Core'),
    numa?: string(name='Numa'),
    threadsPerCore?: int32(name='ThreadsPerCore'),
  }(name='CpuOptions', position='Query'),
  hibernationOptions?: {
    configured?: boolean(name='Configured'),
  }(name='HibernationOptions', position='Query'),
  privatePoolOptions?: {
    id?: string(name='Id'),
    matchCriteria?: string(name='MatchCriteria'),
  }(name='PrivatePoolOptions', position='Query'),
  schedulerOptions?: {
    dedicatedHostClusterId?: string(name='DedicatedHostClusterId'),
  }(name='SchedulerOptions', position='Query'),
  securityOptions?: {
    confidentialComputingMode?: string(name='ConfidentialComputingMode'),
    trustedSystemMode?: string(name='TrustedSystemMode'),
  }(name='SecurityOptions', position='Query'),
  systemDisk?: {
    autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId'),
    category?: string(name='Category'),
    description?: string(name='Description'),
    diskName?: string(name='DiskName'),
    performanceLevel?: string(name='PerformanceLevel'),
    size?: string(name='Size'),
    burstingEnabled?: boolean(name='BurstingEnabled'),
    encryptAlgorithm?: string(name='EncryptAlgorithm'),
    encrypted?: string(name='Encrypted'),
    KMSKeyId?: string(name='KMSKeyId'),
    provisionedIops?: long(name='ProvisionedIops'),
    storageClusterId?: string(name='StorageClusterId'),
  }(name='SystemDisk', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  affinity?: string(name='Affinity', position='Query'),
  amount?: int32(name='Amount', minimum=1, maximum=1000, position='Query'),
  arn?: [ 
    {
      assumeRoleFor?: long(name='AssumeRoleFor'),
      roleType?: string(name='RoleType'),
      rolearn?: string(name='Rolearn'),
    }
  ](name='Arn', position='Query'),
  autoReleaseTime?: string(name='AutoReleaseTime', position='Query'),
  autoRenew?: boolean(name='AutoRenew', position='Query'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  creditSpecification?: string(name='CreditSpecification', position='Query'),
  dataDisk?: [ 
    {
      autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId'),
      burstingEnabled?: boolean(name='BurstingEnabled'),
      category?: string(name='Category'),
      deleteWithInstance?: boolean(name='DeleteWithInstance'),
      description?: string(name='Description'),
      device?: string(name='Device'),
      diskName?: string(name='DiskName'),
      encryptAlgorithm?: string(name='EncryptAlgorithm'),
      encrypted?: string(name='Encrypted'),
      KMSKeyId?: string(name='KMSKeyId'),
      performanceLevel?: string(name='PerformanceLevel'),
      provisionedIops?: long(name='ProvisionedIops'),
      size?: int32(name='Size'),
      snapshotId?: string(name='SnapshotId'),
      storageClusterId?: string(name='StorageClusterId'),
    }
  ](name='DataDisk', position='Query'),
  dedicatedHostId?: string(name='DedicatedHostId', position='Query'),
  deletionProtection?: boolean(name='DeletionProtection', position='Query'),
  deploymentSetGroupNo?: int32(name='DeploymentSetGroupNo', position='Query'),
  deploymentSetId?: string(name='DeploymentSetId', position='Query'),
  description?: string(name='Description', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  hostName?: string(name='HostName', position='Query'),
  hostNames?: [ string ](name='HostNames', position='Query'),
  hpcClusterId?: string(name='HpcClusterId', position='Query'),
  httpEndpoint?: string(name='HttpEndpoint', position='Query'),
  httpPutResponseHopLimit?: int32(name='HttpPutResponseHopLimit', position='Query'),
  httpTokens?: string(name='HttpTokens', position='Query'),
  imageFamily?: string(name='ImageFamily', position='Query'),
  imageId?: string(name='ImageId', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  instanceName?: string(name='InstanceName', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  internetChargeType?: string(name='InternetChargeType', position='Query'),
  internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn', position='Query'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', position='Query'),
  ioOptimized?: string(name='IoOptimized', position='Query'),
  ipv6Address?: [ string ](name='Ipv6Address', position='Query'),
  ipv6AddressCount?: int32(name='Ipv6AddressCount', position='Query'),
  isp?: string(name='Isp', position='Query'),
  keyPairName?: string(name='KeyPairName', position='Query'),
  launchTemplateId?: string(name='LaunchTemplateId', position='Query'),
  launchTemplateName?: string(name='LaunchTemplateName', position='Query'),
  launchTemplateVersion?: long(name='LaunchTemplateVersion', position='Query'),
  minAmount?: int32(name='MinAmount', minimum=1, maximum=100, position='Query'),
  networkInterface?: [ 
    {
      description?: string(name='Description'),
      instanceType?: string(name='InstanceType'),
      ipv6Address?: [ string ](name='Ipv6Address'),
      ipv6AddressCount?: long(name='Ipv6AddressCount'),
      networkInterfaceName?: string(name='NetworkInterfaceName'),
      networkInterfaceTrafficMode?: string(name='NetworkInterfaceTrafficMode'),
      primaryIpAddress?: string(name='PrimaryIpAddress'),
      queueNumber?: int32(name='QueueNumber', minimum=1),
      queuePairNumber?: long(name='QueuePairNumber'),
      securityGroupId?: string(name='SecurityGroupId'),
      securityGroupIds?: [ string ](name='SecurityGroupIds'),
      vSwitchId?: string(name='VSwitchId'),
    }
  ](name='NetworkInterface', position='Query'),
  networkInterfaceQueueNumber?: int32(name='NetworkInterfaceQueueNumber', minimum=1, position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  password?: string(name='Password', position='Query'),
  passwordInherit?: boolean(name='PasswordInherit', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', position='Query'),
  ramRoleName?: string(name='RamRoleName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityEnhancementStrategy?: string(name='SecurityEnhancementStrategy', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', position='Query'),
  securityGroupIds?: [ string ](name='SecurityGroupIds', position='Query'),
  spotDuration?: int32(name='SpotDuration', minimum=0, maximum=6, position='Query'),
  spotInterruptionBehavior?: string(name='SpotInterruptionBehavior', position='Query'),
  spotPriceLimit?: float(name='SpotPriceLimit', minimum=0, maximum=999999, position='Query'),
  spotStrategy?: string(name='SpotStrategy', position='Query'),
  storageSetId?: string(name='StorageSetId', position='Query'),
  storageSetPartitionNumber?: int32(name='StorageSetPartitionNumber', minimum=1, position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  tenancy?: string(name='Tenancy', position='Query'),
  uniqueSuffix?: boolean(name='UniqueSuffix', position='Query'),
  userData?: string(name='UserData', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model RunInstancesResponseBody = {
  instanceIdSets?: {
    instanceIdSet?: [ string ](name='InstanceIdSet')
  }(name='InstanceIdSets'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
  tradePrice?: float(name='TradePrice'),
}

model RunInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: RunInstancesResponseBody(name='body'),
}

async function runInstances(request: RunInstancesRequest): RunInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RunInstances', 'POST', '/', 'json', false, 'json', request);
}

model SendFileRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  content: string(name='Content', position='Query'),
  contentType?: string(name='ContentType', position='Query'),
  description?: string(name='Description', position='Query'),
  fileGroup?: string(name='FileGroup', position='Query'),
  fileMode?: string(name='FileMode', position='Query'),
  fileOwner?: string(name='FileOwner', position='Query'),
  instanceId: [ string ](name='InstanceId', position='Query'),
  name: string(name='Name', position='Query'),
  overwrite?: boolean(name='Overwrite', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  targetDir: string(name='TargetDir', position='Query'),
  timeout?: long(name='Timeout', position='Query'),
}

model SendFileResponseBody = {
  invokeId?: string(name='InvokeId'),
  requestId?: string(name='RequestId'),
}

model SendFileResponse = {
  headers: map[string]string(name='headers'),
  body: SendFileResponseBody(name='body'),
}

async function sendFile(request: SendFileRequest): SendFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SendFile', 'POST', '/', 'json', false, 'json', request);
}

model StartElasticityAssuranceRequest {
  privatePoolOptions?: {
    id: string(name='Id'),
  }(name='PrivatePoolOptions', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model StartElasticityAssuranceResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartElasticityAssuranceResponse = {
  headers: map[string]string(name='headers'),
  body: StartElasticityAssuranceResponseBody(name='body'),
}

async function startElasticityAssurance(request: StartElasticityAssuranceRequest): StartElasticityAssuranceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartElasticityAssurance', 'POST', '/', 'json', false, 'json', request);
}

model StartImagePipelineExecutionRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  imagePipelineId: string(name='ImagePipelineId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  templateTag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='TemplateTag', position='Query'),
}

model StartImagePipelineExecutionResponseBody = {
  executionId?: string(name='ExecutionId'),
  requestId?: string(name='RequestId'),
}

model StartImagePipelineExecutionResponse = {
  headers: map[string]string(name='headers'),
  body: StartImagePipelineExecutionResponseBody(name='body'),
}

async function startImagePipelineExecution(request: StartImagePipelineExecutionRequest): StartImagePipelineExecutionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartImagePipelineExecution', 'POST', '/', 'json', false, 'json', request);
}

model StartInstanceRequest {
  dryRun?: boolean(name='DryRun', position='Query'),
  initLocalDisk?: boolean(name='InitLocalDisk', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Query'),
}

model StartInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StartInstanceResponseBody(name='body'),
}

async function startInstance(request: StartInstanceRequest): StartInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartInstance', 'POST', '/', 'json', false, 'json', request);
}

model StartInstancesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  batchOptimization?: string(name='BatchOptimization', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  instanceId: [ string ](name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model StartInstancesResponseBody = {
  instanceResponses?: {
    instanceResponse?: [ 
    {
      code?: string(name='Code'),
      currentStatus?: string(name='CurrentStatus'),
      instanceId?: string(name='InstanceId'),
      message?: string(name='Message'),
      previousStatus?: string(name='PreviousStatus'),
    }
  ](name='InstanceResponse')
  }(name='InstanceResponses'),
  requestId?: string(name='RequestId'),
}

model StartInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: StartInstancesResponseBody(name='body'),
}

async function startInstances(request: StartInstancesRequest): StartInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartInstances', 'POST', '/', 'json', false, 'json', request);
}

model StartTerminalSessionRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId: [ string ](name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  portNumber?: int32(name='PortNumber', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model StartTerminalSessionResponseBody = {
  requestId?: string(name='RequestId'),
  securityToken?: string(name='SecurityToken'),
  sessionId?: string(name='SessionId'),
  webSocketUrl?: string(name='WebSocketUrl'),
}

model StartTerminalSessionResponse = {
  headers: map[string]string(name='headers'),
  body: StartTerminalSessionResponseBody(name='body'),
}

async function startTerminalSession(request: StartTerminalSessionRequest): StartTerminalSessionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartTerminalSession', 'POST', '/', 'json', false, 'json', request);
}

model StopInstanceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  confirmStop?: boolean(name='ConfirmStop', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  forceStop?: boolean(name='ForceStop', position='Query'),
  hibernate?: boolean(name='Hibernate', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  stoppedMode?: string(name='StoppedMode', position='Query'),
}

model StopInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StopInstanceResponseBody(name='body'),
}

async function stopInstance(request: StopInstanceRequest): StopInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopInstance', 'POST', '/', 'json', false, 'json', request);
}

model StopInstancesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  batchOptimization?: string(name='BatchOptimization', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  forceStop?: boolean(name='ForceStop', position='Query'),
  instanceId: [ string ](name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  stoppedMode?: string(name='StoppedMode', position='Query'),
}

model StopInstancesResponseBody = {
  instanceResponses?: {
    instanceResponse?: [ 
    {
      code?: string(name='Code'),
      currentStatus?: string(name='CurrentStatus'),
      instanceId?: string(name='InstanceId'),
      message?: string(name='Message'),
      previousStatus?: string(name='PreviousStatus'),
    }
  ](name='InstanceResponse')
  }(name='InstanceResponses'),
  requestId?: string(name='RequestId'),
}

model StopInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: StopInstancesResponseBody(name='body'),
}

async function stopInstances(request: StopInstancesRequest): StopInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopInstances', 'POST', '/', 'json', false, 'json', request);
}

model StopInvocationRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId?: [ string ](name='InstanceId', position='Query'),
  invokeId: string(name='InvokeId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model StopInvocationResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopInvocationResponse = {
  headers: map[string]string(name='headers'),
  body: StopInvocationResponseBody(name='body'),
}

async function stopInvocation(request: StopInvocationRequest): StopInvocationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopInvocation', 'POST', '/', 'json', false, 'json', request);
}

model TagResourcesRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagResources', 'POST', '/', 'json', false, 'json', request);
}

model TerminatePhysicalConnectionRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  physicalConnectionId: string(name='PhysicalConnectionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
}

model TerminatePhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model TerminatePhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: TerminatePhysicalConnectionResponseBody(name='body'),
}

async function terminatePhysicalConnection(request: TerminatePhysicalConnectionRequest): TerminatePhysicalConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TerminatePhysicalConnection', 'POST', '/', 'json', false, 'json', request);
}

model TerminateVirtualBorderRouterRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
  vbrId: string(name='VbrId', position='Query'),
}

model TerminateVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model TerminateVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: TerminateVirtualBorderRouterResponseBody(name='body'),
}

async function terminateVirtualBorderRouter(request: TerminateVirtualBorderRouterRequest): TerminateVirtualBorderRouterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TerminateVirtualBorderRouter', 'POST', '/', 'json', false, 'json', request);
}

model UnassignIpv6AddressesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ipv6Address: [ string ](name='Ipv6Address', position='Query'),
  networkInterfaceId: string(name='NetworkInterfaceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UnassignIpv6AddressesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassignIpv6AddressesResponse = {
  headers: map[string]string(name='headers'),
  body: UnassignIpv6AddressesResponseBody(name='body'),
}

async function unassignIpv6Addresses(request: UnassignIpv6AddressesRequest): UnassignIpv6AddressesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnassignIpv6Addresses', 'POST', '/', 'json', false, 'json', request);
}

model UnassignPrivateIpAddressesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  networkInterfaceId: string(name='NetworkInterfaceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  privateIpAddress: [ string ](name='PrivateIpAddress', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UnassignPrivateIpAddressesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassignPrivateIpAddressesResponse = {
  headers: map[string]string(name='headers'),
  body: UnassignPrivateIpAddressesResponseBody(name='body'),
}

async function unassignPrivateIpAddresses(request: UnassignPrivateIpAddressesRequest): UnassignPrivateIpAddressesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnassignPrivateIpAddresses', 'POST', '/', 'json', false, 'json', request);
}

model UnassociateEipAddressRequest {
  allocationId: string(name='AllocationId', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UnassociateEipAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateEipAddressResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociateEipAddressResponseBody(name='body'),
}

async function unassociateEipAddress(request: UnassociateEipAddressRequest): UnassociateEipAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnassociateEipAddress', 'POST', '/', 'json', false, 'json', request);
}

model UnassociateHaVipRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  force?: string(name='Force', position='Query'),
  haVipId: string(name='HaVipId', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UnassociateHaVipResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateHaVipResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociateHaVipResponseBody(name='body'),
}

async function unassociateHaVip(request: UnassociateHaVipRequest): UnassociateHaVipResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnassociateHaVip', 'POST', '/', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  all?: boolean(name='All', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tagKey?: [ string ](name='TagKey', position='Query'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UntagResources', 'POST', '/', 'json', false, 'json', request);
}

