/**
 *
 */
import OpenApi;
import OpenApi.OpenApiUtil;

extends OpenApi;


init(config: OpenApiUtil.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('gwlb', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!$isNull(endpoint)) {
    return endpoint;
  }
  
  if (!$isNull(endpointMap) && !$isNull(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return OpenApiUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddServersToServerGroupRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  serverGroupId?: string(name='ServerGroupId', description='The server group ID.

This parameter is required.', example='sgp-atstuj3rtoptyui****'),
  servers?: [ 
    {
      port?: int32(name='Port', description='The backend server port. Valid values:

*   **6081**', example='6081'),
      serverId?: string(name='ServerId', description='The backend server ID.

*   If the server group is of the **Instance** type, set this parameter to the IDs of servers of the **Ecs**, **Eni**, or **Eci** type.
*   If the server group is of the **Ip** type, set ServerId to IP addresses.

This parameter is required.', example='i-bp67acfmxazb4p****'),
      serverIp?: string(name='ServerIp', description='The IP address of the backend server.', example='192.168.XX.XX'),
      serverType?: string(name='ServerType', description='The type of the backend server. Valid values:

*   **Ecs**: Elastic Compute Service (ECS) instance
*   **Eni**: elastic network interface (ENI)
*   **Eci**: elastic container instance
*   **Ip**: IP address

This parameter is required.', example='Ecs'),
    }
  ](name='Servers', description='The backend servers that you want to add.

> You can add at most 200 backend servers in each call.

This parameter is required.'),
}

model AddServersToServerGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
}

model AddServersToServerGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddServersToServerGroupResponseBody(name='body'),
}

/**
 * @summary Adds backend servers to the server group of a Gateway Load Balancer (GWLB) instance.
 *
 * @description **AddServersToServerGroup** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background.
 * 1.  You can call the ListServerGroups operation to query the status of the server group.
 * *   If the server group is in the **Configuring** state, the server group is being modified.
 * *   If the server group is in the **Available** state, the server group is running.
 * 2.  You can call the ListServerGroupServers operation to query the status of the backend server.
 * *   If the backend server is in the **Adding** state, the backend server is being added to the server group.
 * *   If the backend server is in the **Available** state, the server is running.
 *
 * @param request AddServersToServerGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddServersToServerGroupResponse
 */
async function addServersToServerGroupWithOptions(request: AddServersToServerGroupRequest, runtime: $RuntimeOptions): AddServersToServerGroupResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.serverGroupId)) {
    body['ServerGroupId'] = request.serverGroupId;
  }
  var bodyFlat : map[string]any = {};
  if (!$isNull(request.servers)) {
    bodyFlat['Servers'] = request.servers;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'AddServersToServerGroup',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Adds backend servers to the server group of a Gateway Load Balancer (GWLB) instance.
 *
 * @description **AddServersToServerGroup** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background.
 * 1.  You can call the ListServerGroups operation to query the status of the server group.
 * *   If the server group is in the **Configuring** state, the server group is being modified.
 * *   If the server group is in the **Available** state, the server group is running.
 * 2.  You can call the ListServerGroupServers operation to query the status of the backend server.
 * *   If the backend server is in the **Adding** state, the backend server is being added to the server group.
 * *   If the backend server is in the **Available** state, the server is running.
 *
 * @param request AddServersToServerGroupRequest
 * @return AddServersToServerGroupResponse
 */
async function addServersToServerGroup(request: AddServersToServerGroupRequest): AddServersToServerGroupResponse {
  var runtime = new $RuntimeOptions{};
  return addServersToServerGroupWithOptions(request, runtime);
}

model CreateListenerRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run, without sending the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  listenerDescription?: string(name='ListenerDescription', description='The description of the listener.

The description must be 2 to 256 characters in length, and can contain letters, digits, commas (,), periods (.), semicolons (;), forward slashes (/), at signs (@), underscores (_), and hyphens (-).', example='listener-description'),
  loadBalancerId?: string(name='LoadBalancerId', description='The GWLB instance ID.

This parameter is required.', example='gwlb-te609d6696632f7*****'),
  serverGroupId?: string(name='ServerGroupId', description='The server group ID.

This parameter is required.', example='sgp-ckh01px70dszof****'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key. The tag key cannot be an empty string. The tag key can be up to 128 characters in length, and cannot start with `acs:` or `aliyun`. The tag key cannot contain `http://` or `https://`.', example='testKey'),
      value?: string(name='Value', description='The tag value. The tag value can be up to 256 characters in length and cannot contain `http://` or `https://`.', example='testValue'),
    }
  ](name='Tag', description='The tags. You can specify at most 20 tags in each call.'),
}

model CreateListenerResponseBody = {
  listenerId?: string(name='ListenerId', description='The listener ID.', example='lsn-wi3c0v30ivysrg****'),
  requestId?: string(name='RequestId', description='The request ID.', example='A045E652-D298-5E70-A978-7247135336FB'),
}

model CreateListenerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateListenerResponseBody(name='body'),
}

/**
 * @summary Creates a listener for a Gateway Load Balancer (GWLB) instance.
 *
 * @description **CreateListener** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the **GetListenerAttribute** operation to query the status of the task.
 * *   If the listener is in the **Provisioning** state, the listener is being created.
 * *   If the listener is in the **Running** state, the listener is running.
 *
 * @param request CreateListenerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateListenerResponse
 */
async function createListenerWithOptions(request: CreateListenerRequest, runtime: $RuntimeOptions): CreateListenerResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.listenerDescription)) {
    body['ListenerDescription'] = request.listenerDescription;
  }
  if (!$isNull(request.loadBalancerId)) {
    body['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!$isNull(request.serverGroupId)) {
    body['ServerGroupId'] = request.serverGroupId;
  }
  var bodyFlat : map[string]any = {};
  if (!$isNull(request.tag)) {
    bodyFlat['Tag'] = request.tag;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateListener',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a listener for a Gateway Load Balancer (GWLB) instance.
 *
 * @description **CreateListener** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the **GetListenerAttribute** operation to query the status of the task.
 * *   If the listener is in the **Provisioning** state, the listener is being created.
 * *   If the listener is in the **Running** state, the listener is running.
 *
 * @param request CreateListenerRequest
 * @return CreateListenerResponse
 */
async function createListener(request: CreateListenerRequest): CreateListenerResponse {
  var runtime = new $RuntimeOptions{};
  return createListenerWithOptions(request, runtime);
}

model CreateLoadBalancerRequest {
  addressIpVersion?: string(name='AddressIpVersion', description='The IP version. Valid values:

*   **Ipv4** (default): IPv4', example='IPv4'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  loadBalancerName?: string(name='LoadBalancerName', description='The GWLB instance name.

The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (_), and hyphens (-). The name must start with a letter.', example='testGwlbName'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-acfmwbufq6q3****'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key. The tag key cannot be an empty string.

The tag key can be up to 128 characters in length. The tag key cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.', example='testTagKey'),
      value?: string(name='Value', description='The tag value. The tag value can be up to 256 characters in length and cannot contain `http://` or `https://`.', example='testTagValue'),
    }
  ](name='Tag', description='The tag keys. You can specify at most 20 tags in each call.'),
  vpcId?: string(name='VpcId', description='The virtual private cloud (VPC) ID.

This parameter is required.', example='vpc-uf6qcgpv22ttrnnjh****'),
  zoneMappings?: [ 
    {
      vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch in the zone. You can specify only one vSwitch (subnet) in each zone of a GWLB instance.

This parameter is required.', example='vsw-2f0eb020****'),
      zoneId?: string(name='ZoneId', description='The zone ID. You can call the DescribeZones operation to query the most recent zone list.

This parameter is required.', example='cn-hangzhou-a'),
    }
  ](name='ZoneMappings', description='The mappings between zones and vSwitches. You must specify at least one zone. You can specify at most 20 zones. If the region supports two or more zones, specify at least two zones.

This parameter is required.'),
}

model CreateLoadBalancerResponseBody = {
  loadBalancerId?: string(name='LoadBalancerId', description='The GWLB instance ID.', example='gwlb-9njtjmqt7zfcqm****'),
  requestId?: string(name='RequestId', description='The request ID.', example='00B19438-66BB-58C3-8C2F-DA5B6F95CBDA'),
}

model CreateLoadBalancerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLoadBalancerResponseBody(name='body'),
}

/**
 * @summary Creates a Gateway Load Balancer (GWLB) instance.
 *
 * @description **Make sure that you fully understand the billing methods and [pricing](https://help.aliyun.com/document_detail/2806160.html) of GWLB before calling this operation**.
 * *   When you create a GWLB instance, the service-linked role AliyunServiceRoleForGwlb is automatically created.
 * *   CreateLoadBalancer is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the GetLoadBalancerAttribute operation to query the status of a GWLB instance.
 *     *   If the GWLB instance is in the Provisioning state, the GWLB instance is being created.
 *     *   If the GWLB instance is in the Active state, the GWLB instance is created.
 *
 * @param request CreateLoadBalancerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLoadBalancerResponse
 */
async function createLoadBalancerWithOptions(request: CreateLoadBalancerRequest, runtime: $RuntimeOptions): CreateLoadBalancerResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.addressIpVersion)) {
    body['AddressIpVersion'] = request.addressIpVersion;
  }
  if (!$isNull(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.loadBalancerName)) {
    body['LoadBalancerName'] = request.loadBalancerName;
  }
  if (!$isNull(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  var bodyFlat : map[string]any = {};
  if (!$isNull(request.tag)) {
    bodyFlat['Tag'] = request.tag;
  }
  if (!$isNull(request.vpcId)) {
    body['VpcId'] = request.vpcId;
  }
  if (!$isNull(request.zoneMappings)) {
    bodyFlat['ZoneMappings'] = request.zoneMappings;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateLoadBalancer',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a Gateway Load Balancer (GWLB) instance.
 *
 * @description **Make sure that you fully understand the billing methods and [pricing](https://help.aliyun.com/document_detail/2806160.html) of GWLB before calling this operation**.
 * *   When you create a GWLB instance, the service-linked role AliyunServiceRoleForGwlb is automatically created.
 * *   CreateLoadBalancer is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the GetLoadBalancerAttribute operation to query the status of a GWLB instance.
 *     *   If the GWLB instance is in the Provisioning state, the GWLB instance is being created.
 *     *   If the GWLB instance is in the Active state, the GWLB instance is created.
 *
 * @param request CreateLoadBalancerRequest
 * @return CreateLoadBalancerResponse
 */
async function createLoadBalancer(request: CreateLoadBalancerRequest): CreateLoadBalancerResponse {
  var runtime = new $RuntimeOptions{};
  return createLoadBalancerWithOptions(request, runtime);
}

model CreateServerGroupRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  connectionDrainConfig?: {
    connectionDrainEnabled?: boolean(name='ConnectionDrainEnabled', description='Specifies whether to enable connection draining. Valid values:

*   **true**
*   **false**', example='false'),
    connectionDrainTimeout?: int32(name='ConnectionDrainTimeout', description='The timeout period of connection draining.

Unit: seconds

Valid values: **1** to **3600**.

Default value: **300**.', example='300'),
  }(name='ConnectionDrainConfig', description='The configurations of connection draining.'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='False'),
  healthCheckConfig?: {
    healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='The backend server port that is used for health checks.

Valid values: **1** to **65535**.

Default value: **80**.', example='80'),
    healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', description='The maximum timeout period of a health check response.

Unit: seconds

Valid values: **1** to **300**.

Default value: **5**.', example='5'),
    healthCheckDomain?: string(name='HealthCheckDomain', description='The domain name that you want to use for health checks. Valid values:

*   **$SERVER_IP** (default): the private IP address of a backend server.
*   **domain**: a domain name. The domain name must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), and periods (.).

> This parameter takes effect only if you set **HealthCheckProtocol** to **HTTP**.', example='$SERVER_IP'),
    healthCheckEnabled?: boolean(name='HealthCheckEnabled', description='Specifies whether to enable the health check feature. Valid values:

*   **true** (default)
*   **false**', example='true'),
    healthCheckHttpCode?: [ string ](name='HealthCheckHttpCode', description='The HTTP status codes that the system returns for health checks.'),
    healthCheckInterval?: int32(name='HealthCheckInterval', description='The interval at which health checks are performed.

Unit: seconds

Valid values: **1** to **50**.

Default value: **10**.', example='10'),
    healthCheckPath?: string(name='HealthCheckPath', description='The URL that is used for health checks.

The URL must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.), percent signs (%), question marks (?), number signs (#), and ampersands (&). The URL can also contain the following extended characters: _ ; ~ ! ( ) \\\\* [ ] @ $ ^ : \\\\" , + =

The URL must start with a forward slash (/).

> This parameter takes effect only if you set **HealthCheckProtocol** to **HTTP**.', example='/test/index.html'),
    healthCheckProtocol?: string(name='HealthCheckProtocol', description='The protocol that is used for health checks. Valid values:

*   **TCP** (default): GWLB performs TCP health checks by sending SYN packets to a backend server to check whether the port of the backend server is available to receive requests.
*   **HTTP**: GWLB performs HTTP health checks to check whether backend servers are healthy by sending HEAD or GET requests which simulate access from browsers.', example='TCP'),
    healthyThreshold?: int32(name='HealthyThreshold', description='The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status changes from **fail** to **success**.

Valid values: **2** to **10**.

Default value: **2**.', example='2'),
    unhealthyThreshold?: int32(name='UnhealthyThreshold', description='The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status changes from **success** to **fail**.

Valid values: **2** to **10**.

Default value: **2**.', example='2'),
  }(name='HealthCheckConfig', description='The configurations of the health check feature.'),
  protocol?: string(name='Protocol', description='The backend protocol. Valid values:

*   **GENEVE**(default)', example='GENEVE'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-atstuj3rtop****'),
  scheduler?: string(name='Scheduler', description='The scheduling algorithm. Valid values:

*   **5TCH** (default): specifies consistent hashing that is based on the following factors: source IP address, destination IP address, source port, protocol, and destination port. Requests that contain the same information based on the preceding factors are forwarded to the same backend server.
*   **3TCH**: specifies consistent hashing that is based on the following factors: source IP address, destination IP address, and protocol. Requests that contain the same information based on the preceding factors are forwarded to the same backend server.
*   **2TCH**: specifies consistent hashing that is based on the following factors: source IP address and destination IP address. Requests that contain the same information based on the preceding factors are forwarded to the same backend server.', example='5TCH'),
  serverFailoverMode?: string(name='ServerFailoverMode'),
  serverGroupName?: string(name='ServerGroupName', description='The server group name.

The name must be 2 to 128 characters in length, and can contain digits, periods (.), underscores (_), and hyphens (-). It must start with a letter.', example='testServerGroupName'),
  serverGroupType?: string(name='ServerGroupType', description='The type of server group. Valid values:

*   **Instance** (default): allows you to specify servers of the **Ecs**, **Eni**, or **Eci** type.
*   **Ip**: allows you to add servers of by specifying IP addresses.', example='Instance'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key. The tag key cannot be an empty string. The tag key can be up to 128 characters in length, and cannot start with `acs:` or `aliyun`. The tag key cannot contain `http://` or `https://`.', example='testTagKey'),
      value?: string(name='Value', description='The tag value. The tag value can be up to 256 characters in length and cannot contain `http://` or `https://`.', example='testTagValue'),
    }
  ](name='Tag', description='The tag keys.

You can specify at most 20 tags in each call.'),
  vpcId?: string(name='VpcId', description='The VPC ID.

> If **ServerGroupType** is set to **Instance**, only servers in the specified VPC can be added to the server group.

This parameter is required.', example='vpc-bp15zckdt37pq72zv****'),
}

model CreateServerGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
  serverGroupId?: string(name='ServerGroupId', description='The server group ID.', example='sgp-atstuj3rtoptyui****'),
}

model CreateServerGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateServerGroupResponseBody(name='body'),
}

/**
 * @summary Creates a server group for a Gateway Load Balancer (GWLB) instance.
 *
 * @description **CreateServerGroup** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the ListServerGroups operation to query the status of the task.
 * *   If the server group is in the **Creating** state, it indicates that the server group is being created.
 * *   If the server group is in the **Available** state, it indicates that the server group is created.
 *
 * @param request CreateServerGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateServerGroupResponse
 */
async function createServerGroupWithOptions(request: CreateServerGroupRequest, runtime: $RuntimeOptions): CreateServerGroupResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  var bodyFlat : map[string]any = {};
  if (!$isNull(request.connectionDrainConfig)) {
    bodyFlat['ConnectionDrainConfig'] = request.connectionDrainConfig;
  }
  if (!$isNull(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.healthCheckConfig)) {
    bodyFlat['HealthCheckConfig'] = request.healthCheckConfig;
  }
  if (!$isNull(request.protocol)) {
    body['Protocol'] = request.protocol;
  }
  if (!$isNull(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.scheduler)) {
    body['Scheduler'] = request.scheduler;
  }
  if (!$isNull(request.serverFailoverMode)) {
    body['ServerFailoverMode'] = request.serverFailoverMode;
  }
  if (!$isNull(request.serverGroupName)) {
    body['ServerGroupName'] = request.serverGroupName;
  }
  if (!$isNull(request.serverGroupType)) {
    body['ServerGroupType'] = request.serverGroupType;
  }
  if (!$isNull(request.tag)) {
    bodyFlat['Tag'] = request.tag;
  }
  if (!$isNull(request.vpcId)) {
    body['VpcId'] = request.vpcId;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateServerGroup',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a server group for a Gateway Load Balancer (GWLB) instance.
 *
 * @description **CreateServerGroup** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the ListServerGroups operation to query the status of the task.
 * *   If the server group is in the **Creating** state, it indicates that the server group is being created.
 * *   If the server group is in the **Available** state, it indicates that the server group is created.
 *
 * @param request CreateServerGroupRequest
 * @return CreateServerGroupResponse
 */
async function createServerGroup(request: CreateServerGroupRequest): CreateServerGroupResponse {
  var runtime = new $RuntimeOptions{};
  return createServerGroupWithOptions(request, runtime);
}

model DeleteListenerRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run, without sending the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  listenerId?: string(name='ListenerId', description='The listener ID.

This parameter is required.', example='lsn-brx2y3hqdincizg***'),
}

model DeleteListenerResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5C6E3548-086F-5FF6-A2B3-B1871B3AB488'),
}

model DeleteListenerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteListenerResponseBody(name='body'),
}

/**
 * @summary Deletes a listener from a Gateway Load Balancer (GWLB) instance.
 *
 * @description **DeleteListener** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the **GetListenerAttribute** operation to query the status of the task.
 * *   If the listener is in the **Deleting** state, the listener is being deleted.
 * *   If the listener cannot be found, the listener is deleted.
 *
 * @param request DeleteListenerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteListenerResponse
 */
async function deleteListenerWithOptions(request: DeleteListenerRequest, runtime: $RuntimeOptions): DeleteListenerResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.listenerId)) {
    body['ListenerId'] = request.listenerId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteListener',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a listener from a Gateway Load Balancer (GWLB) instance.
 *
 * @description **DeleteListener** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the **GetListenerAttribute** operation to query the status of the task.
 * *   If the listener is in the **Deleting** state, the listener is being deleted.
 * *   If the listener cannot be found, the listener is deleted.
 *
 * @param request DeleteListenerRequest
 * @return DeleteListenerResponse
 */
async function deleteListener(request: DeleteListenerRequest): DeleteListenerResponse {
  var runtime = new $RuntimeOptions{};
  return deleteListenerWithOptions(request, runtime);
}

model DeleteLoadBalancerRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run, without sending the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  loadBalancerId?: string(name='LoadBalancerId', description='The GWLB instance ID.

This parameter is required.', example='gwlb-9njtjmqt7zfcqm****'),
}

model DeleteLoadBalancerResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='37907828-01AB-5AC3-9DDE-25D419091D54'),
}

model DeleteLoadBalancerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLoadBalancerResponseBody(name='body'),
}

/**
 * @summary Deletes a Gateway Load Balancer (GWLB) instance.
 *
 * @param request DeleteLoadBalancerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteLoadBalancerResponse
 */
async function deleteLoadBalancerWithOptions(request: DeleteLoadBalancerRequest, runtime: $RuntimeOptions): DeleteLoadBalancerResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.loadBalancerId)) {
    body['LoadBalancerId'] = request.loadBalancerId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteLoadBalancer',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a Gateway Load Balancer (GWLB) instance.
 *
 * @param request DeleteLoadBalancerRequest
 * @return DeleteLoadBalancerResponse
 */
async function deleteLoadBalancer(request: DeleteLoadBalancerRequest): DeleteLoadBalancerResponse {
  var runtime = new $RuntimeOptions{};
  return deleteLoadBalancerWithOptions(request, runtime);
}

model DeleteServerGroupRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  serverGroupId?: string(name='ServerGroupId', description='The server group ID.

This parameter is required.', example='sgp-atstuj3rtoptyui****'),
}

model DeleteServerGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
}

model DeleteServerGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteServerGroupResponseBody(name='body'),
}

/**
 * @summary Deletes a server group from a Gateway Load Balancer (GWLB) instance.
 *
 * @description You can delete server groups that are not associated with listeners.
 *
 * @param request DeleteServerGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteServerGroupResponse
 */
async function deleteServerGroupWithOptions(request: DeleteServerGroupRequest, runtime: $RuntimeOptions): DeleteServerGroupResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.serverGroupId)) {
    body['ServerGroupId'] = request.serverGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteServerGroup',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a server group from a Gateway Load Balancer (GWLB) instance.
 *
 * @description You can delete server groups that are not associated with listeners.
 *
 * @param request DeleteServerGroupRequest
 * @return DeleteServerGroupResponse
 */
async function deleteServerGroup(request: DeleteServerGroupRequest): DeleteServerGroupResponse {
  var runtime = new $RuntimeOptions{};
  return deleteServerGroupWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The supported language. Valid values:

*   **zh-CN**: Chinese
*   **en-US** (default): English
*   **ja**: Japanese', example='zh-CN'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      localName?: string(name='LocalName', description='The region name.', example='China (Hangzhou)'),
      regionEndpoint?: string(name='RegionEndpoint', description='The region endpoint.', example='gwlb.cn-hangzhou.aliyuncs.com'),
      regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
    }
  ](name='Regions', description='A list of regions.'),
  requestId?: string(name='RequestId', description='The request ID.', example='162FCE8D-CEEC-5083-90BF-B45D8C4F81FB'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

/**
 * @summary Queries the most recent region list of Gateway Load Balancer (GWLB).
 *
 * @param request DescribeRegionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRegionsResponse
 */
async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: $RuntimeOptions): DescribeRegionsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.acceptLanguage)) {
    body['AcceptLanguage'] = request.acceptLanguage;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeRegions',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the most recent region list of Gateway Load Balancer (GWLB).
 *
 * @param request DescribeRegionsRequest
 * @return DescribeRegionsResponse
 */
async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new $RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeZonesRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The supported language. Valid values:

*   **zh-CN**: Chinese
*   **en-US** (default): English
*   **ja**: Japanese', example='zh-CN'),
}

model DescribeZonesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='4C605F7E-D0F6-54E2-B004-F9B132F0D8B2'),
  zones?: [ 
    {
      localName?: string(name='LocalName', description='The zone name.', example='Hangzhou Zone G'),
      zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-g'),
    }
  ](name='Zones', description='A list of zones.'),
}

model DescribeZonesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeZonesResponseBody(name='body'),
}

/**
 * @summary Queries the most recent zone list of Gateway Load Balancer (GWLB).
 *
 * @param request DescribeZonesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeZonesResponse
 */
async function describeZonesWithOptions(request: DescribeZonesRequest, runtime: $RuntimeOptions): DescribeZonesResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.acceptLanguage)) {
    body['AcceptLanguage'] = request.acceptLanguage;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeZones',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the most recent zone list of Gateway Load Balancer (GWLB).
 *
 * @param request DescribeZonesRequest
 * @return DescribeZonesResponse
 */
async function describeZones(request: DescribeZonesRequest): DescribeZonesResponse {
  var runtime = new $RuntimeOptions{};
  return describeZonesWithOptions(request, runtime);
}

model GetListenerAttributeRequest {
  listenerId?: string(name='ListenerId', description='The listener ID.

This parameter is required.', example='lsn-brx2y3hqdinciz****'),
}

model GetListenerAttributeResponseBody = {
  listenerDescription?: string(name='ListenerDescription', description='The listener description.

The description must be 2 to 256 characters in length, and can contain letters, digits, commas (,), periods (.), semicolons (;), forward slashes (/), at signs (@), underscores (_), and hyphens (-).', example='listener_description'),
  listenerId?: string(name='ListenerId', description='The listener ID.', example='lsn-3kbj3587mqhm3p****'),
  listenerStatus?: string(name='ListenerStatus', description='The listener status. Valid values:

*   **Provisioning**: The listener is being created.
*   **Running**: The listener is running.
*   **Configuring**: The listener is being configured.
*   **Deleting**: The listener is being deleted.', example='Provisioning'),
  loadBalancerId?: string(name='LoadBalancerId', description='The GWLB instance ID.', example='gwlb-te609d6696632f76****'),
  regionId?: string(name='RegionId', description='The region ID of the GWLB instance.', example='cn-hangzhou'),
  requestId?: string(name='RequestId', description='The request ID.', example='75CC3312-7757-5EE1-90D8-49CEA66608AE'),
  serverGroupId?: string(name='ServerGroupId', description='The server group ID.', example='sgp-sp8d2r6y7t0xtl****'),
  tags?: [ 
    {
      key?: string(name='Key', description='The tag key. The tag key cannot be an empty string. The tag key can be up to 128 characters in length, and cannot start with `acs: `or `aliyun`. The tag key cannot contain `http://` or `https://`.', example='testKey'),
      value?: string(name='Value', description='The tag value. The tag value can be up to 256 characters in length and cannot contain `http://` or `https://`.', example='testValue'),
    }
  ](name='Tags', description='The tags.'),
}

model GetListenerAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetListenerAttributeResponseBody(name='body'),
}

/**
 * @summary Queries the details of a Gateway Load Balancer (GWLB) listener.
 *
 * @param request GetListenerAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetListenerAttributeResponse
 */
async function getListenerAttributeWithOptions(request: GetListenerAttributeRequest, runtime: $RuntimeOptions): GetListenerAttributeResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.listenerId)) {
    body['ListenerId'] = request.listenerId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetListenerAttribute',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of a Gateway Load Balancer (GWLB) listener.
 *
 * @param request GetListenerAttributeRequest
 * @return GetListenerAttributeResponse
 */
async function getListenerAttribute(request: GetListenerAttributeRequest): GetListenerAttributeResponse {
  var runtime = new $RuntimeOptions{};
  return getListenerAttributeWithOptions(request, runtime);
}

model GetListenerHealthStatusRequest {
  filter?: [ 
    {
      name?: string(name='Name', description='The filter condition name. You can filter by one or more filter condition names. The URL must meet the following requirements:

*   **Status**: the health status.
*   **ReasonCode**: the cause of an unhealthy server.
*   **ServerId**: the ID of the backend server.
*   **ServerIp**: the IP address of the backend server.', example='Status'),
      values?: [ string ](name='Values', description='The filter condition values. You can specify at most 20 condition values.'),
    }
  ](name='Filter', description='The filter conditions. You can specify at most 20 filter conditions.'),
  listenerId?: string(name='ListenerId', description='The listener ID.

This parameter is required.', example='lsn-7sixpvm5fc3v0b****'),
  maxResults?: int32(name='MaxResults', description='The number of entries per page. Valid values: 1 to 1000. Default value: 20.', example='20'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value of **NextToken** is returned, the value indicates the token that is used for the next query.', example='4f1d7cc9f51e18904e8a063603a6b0c3d03bc69f78734254e0b5e8707e68****'),
  skip?: int32(name='Skip', description='The number of entries to be skipped in the call.', example='10'),
}

model GetListenerHealthStatusResponseBody = {
  listenerHealthStatus?: [ 
    {
      listenerId?: string(name='ListenerId', description='The listener ID.', example='lsn-sg8aha6pzjavvo****'),
      serverGroupInfos?: [ 
        {
          healthCheckEnabled?: boolean(name='HealthCheckEnabled', description='Indicates whether the health check feature is enabled. Valid values:

*   **true**
*   **false**', example='true'),
          serverGroupId?: string(name='ServerGroupId', description='The server group ID.', example='sgp-0vdsbyszro3nr6****'),
          servers?: [ 
            {
              port?: int32(name='Port', description='The backend port.', example='6081'),
              reason?: {
                reasonCode?: string(name='ReasonCode', description='The reason why **Status** indicates an unhealthy status. Valid values:

*   **CONNECT_TIMEOUT**: The GWLB instance failed to connect to the backend server within the specified period of time.
*   **CONNECT_FAILED**: The GWLB instance failed to connect to the backend server.
*   **RECV_RESPONSE_TIMEOUT**: The GWLB instance failed to receive a response from the backend server within the specified period of time.
*   **CONNECT_INTERRUPT**: The connection between the health check and the backend server was interrupted.
*   **HTTP_CODE_NOT_MATCH**: The HTTP status code from the backend server is not the expected one.
*   **HTTP_INVALID_HEADER**: The format of the response from the backend servers is invalid.', example='CONNECT_TIMEOUT'),
              }(name='Reason', description='The reason why **Status** indicates an unhealthy status.'),
              serverId?: string(name='ServerId', description='The backend server ID.', example='i-2ze4rnh8yj9kif3z****'),
              serverIp?: string(name='ServerIp', description='The IP address of the server.', example='192.168.0.XXX'),
              status?: string(name='Status', description='The health status of the backend server. Valid values:

*   **Initial**: Health checks are configured for the GWLB instance, but no data is found.
*   **Unhealthy**: The backend server consecutively fails health checks.
*   **Unused**: The backend server is not in use.
*   **Unavailable**: Health checks are disabled.
*   **Healthy**: The backend server is healthy.', example='Healthy'),
            }
          ](name='Servers', description='The backend servers.'),
        }
      ](name='ServerGroupInfos', description='The information about the server groups.'),
    }
  ](name='ListenerHealthStatus', description='The health check status of the server groups that are associated with the listener.'),
  maxResults?: int32(name='MaxResults', description='The number of entries per page. Valid values: 1 to 1000. Default value: 20.', example='20'),
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value of **NextToken** is returned, the value indicates the token that is used for the next query.', example='U12WEI6Ro2ol3wA54rBNSwdC5+lYy6q5SjIQEvc1wz5mjZxV+YjsHRdXV8XauY1BpOQIvwX63E0en54H3D****'),
  requestId?: string(name='RequestId', description='The request ID.', example='0ED4F222-36A0-5470-8A9A-AAB4E96BAC1A'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='31'),
}

model GetListenerHealthStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetListenerHealthStatusResponseBody(name='body'),
}

/**
 * @summary Queries the health check status of a Gateway Load Balancer (GWLB) listener.
 *
 * @param request GetListenerHealthStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetListenerHealthStatusResponse
 */
async function getListenerHealthStatusWithOptions(request: GetListenerHealthStatusRequest, runtime: $RuntimeOptions): GetListenerHealthStatusResponse {
  request.validate();
  var body : map[string]any = {};
  var bodyFlat : map[string]any = {};
  if (!$isNull(request.filter)) {
    bodyFlat['Filter'] = request.filter;
  }
  if (!$isNull(request.listenerId)) {
    body['ListenerId'] = request.listenerId;
  }
  if (!$isNull(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.skip)) {
    body['Skip'] = request.skip;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetListenerHealthStatus',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the health check status of a Gateway Load Balancer (GWLB) listener.
 *
 * @param request GetListenerHealthStatusRequest
 * @return GetListenerHealthStatusResponse
 */
async function getListenerHealthStatus(request: GetListenerHealthStatusRequest): GetListenerHealthStatusResponse {
  var runtime = new $RuntimeOptions{};
  return getListenerHealthStatusWithOptions(request, runtime);
}

model GetLoadBalancerAttributeRequest {
  loadBalancerId?: string(name='LoadBalancerId', description='The GWLB instance ID.

This parameter is required.', example='gwlb-9njtjmqt7zfcqm****'),
}

model GetLoadBalancerAttributeResponseBody = {
  addressIpVersion?: string(name='AddressIpVersion', description='The protocol version. Valid values:

*   **Ipv4**: IPv4.', example='IPv4'),
  createTime?: string(name='CreateTime', description='The time when the resource was created. The time follows the ISO 8601 standard in the **yyyy-MM-ddTHH:mm:ssZ** format. The time is displayed in UTC.', example='2024-07-08T10:12:58Z'),
  loadBalancerBusinessStatus?: string(name='LoadBalancerBusinessStatus', description='The business status of the GWLB instance. Valid values:

*   **Normal**: running as expected
*   **FinancialLocked**: locked due to overdue payments', example='Normal'),
  loadBalancerId?: string(name='LoadBalancerId', description='The GWLB instance ID.', example='gwlb-9njtjmqt7zfcqm****'),
  loadBalancerName?: string(name='LoadBalancerName', description='The GWLB instance name.

The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (_), and hyphens (-). The name must start with a letter.', example='gwlb'),
  loadBalancerStatus?: string(name='LoadBalancerStatus', description='The GWLB instance status. Valid values:

*   **Active**: The GWLB instance is running.
*   **Inactive**: The GWLB instance is disabled. Listeners of GWLB instances in the Inactive state do not forward traffic.
*   **Provisioning**: The GWLB instance is being created.
*   **Configuring**: The GWLB instance is being modified.', example='Active'),
  requestId?: string(name='RequestId', description='The request ID.', example='B6DC5DDC-9560-59BF-80FA-ED1E5CB417DF'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-acfmx7pmxcy****'),
  tags?: [ 
    {
      key?: string(name='Key', description='The tag key. The tag key cannot be an empty string.

The tag key can be up to 128 characters in length. The tag key cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.', example='testTagKey'),
      value?: string(name='Value', description='The tag value. The tag value can be up to 256 characters in length and cannot contain `http://` or `https://`.', example='testTagValue'),
    }
  ](name='Tags', description='The tags.'),
  trafficMode?: string(name='TrafficMode'),
  vpcId?: string(name='VpcId', description='The VPC ID.', example='vpc-k1aajsbwbaq4todet****'),
  zoneMappings?: [ 
    {
      loadBalancerAddresses?: [ 
        {
          eniId?: string(name='EniId', description='The ID of the elastic network interface (ENI) used by the GWLB instance.', example='eni-bp1iahwz3rzgvltz****'),
          privateIpv4Address?: string(name='PrivateIpv4Address', description='The private IPv4 address.', example='192.168.XX.XX'),
        }
      ](name='LoadBalancerAddresses', description='The GWLB instance addresses.'),
      vSwitchId?: string(name='VSwitchId', description='The vSwitch in the zone. You can specify only one vSwitch (subnet) in each zone of a GWLB instance.', example='vsw-uf6v8l7d2f1k53xrl****'),
      zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-j'),
    }
  ](name='ZoneMappings', description='The mappings between zones and vSwitches. You must specify at least one zone. You can specify at most 20 zones. If the region supports two or more zones, specify at least two zones.'),
}

model GetLoadBalancerAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLoadBalancerAttributeResponseBody(name='body'),
}

/**
 * @summary Queries the details of a Gateway Load Balancer (GWLB) instance.
 *
 * @param request GetLoadBalancerAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLoadBalancerAttributeResponse
 */
async function getLoadBalancerAttributeWithOptions(request: GetLoadBalancerAttributeRequest, runtime: $RuntimeOptions): GetLoadBalancerAttributeResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.loadBalancerId)) {
    body['LoadBalancerId'] = request.loadBalancerId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetLoadBalancerAttribute',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of a Gateway Load Balancer (GWLB) instance.
 *
 * @param request GetLoadBalancerAttributeRequest
 * @return GetLoadBalancerAttributeResponse
 */
async function getLoadBalancerAttribute(request: GetLoadBalancerAttributeRequest): GetLoadBalancerAttributeResponse {
  var runtime = new $RuntimeOptions{};
  return getLoadBalancerAttributeWithOptions(request, runtime);
}

model ListListenersRequest {
  listenerIds?: [ string ](name='ListenerIds', description='The listener IDs. You can specify at most 20 listener IDs.'),
  loadBalancerIds?: [ string ](name='LoadBalancerIds', description='The GWLB instance IDs. You can specify at most 20 instance IDs.'),
  maxResults?: int32(name='MaxResults', description='The maximum number of results to be returned from a single query when the NextToken parameter is used in the query. Valid values: 1 to 1000. Default value: 20.', example='20'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value of **NextToken** is returned, the value indicates the token that is used for the next query.', example='d209f4e63ec942c967c50c888a13****'),
  skip?: int32(name='Skip', description='The number of entries to be skipped in the call.', example='10'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key. The tag key cannot be an empty string.

The tag key can be up to 128 characters in length. The tag key cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.', example='tagKey'),
      value?: string(name='Value', description='The tag value. The tag value can be up to 256 characters in length and cannot contain `http://` or `https://`.', example='tagValue'),
    }
  ](name='Tag', description='The tags. You can specify at most 20 tags in each call.'),
}

model ListListenersResponseBody = {
  listeners?: [ 
    {
      listenerDescription?: string(name='ListenerDescription', description='The description of the listener.', example='listener-description'),
      listenerId?: string(name='ListenerId', description='The listener ID.', example='lsn-vu7folhh5ntm8u****'),
      listenerStatus?: string(name='ListenerStatus', description='The status of the listener. Valid values:

*   **Provisioning**: The listener is being created.
*   **Running**: The listener is running.
*   **Configuring**: The listener is being configured.
*   **Deleting**: The listener is being deleted.', example='Running'),
      loadBalancerId?: string(name='LoadBalancerId', description='The GWLB instance ID.', example='gwlb-uf6hbeh795xlqln7g****'),
      serverGroupId?: string(name='ServerGroupId', description='The server group ID.', example='sgp-5yapcb422i51ru****'),
      tags?: [ 
        {
          key?: string(name='Key', description='The tag key.', example='testKey'),
          value?: string(name='Value', description='The tag value.', example='testValue'),
        }
      ](name='Tags', description='The tags.'),
    }
  ](name='Listeners', description='The GWLB listeners.'),
  maxResults?: int32(name='MaxResults', description='The maximum number of results to be returned from a single query when the NextToken parameter is used in the query. Valid values: 1 to 1000. Default value: 20.', example='20'),
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value of **NextToken** is returned, the value indicates the token that is used for the next query.', example='5c281c0a0d6bfb6355ed088c2108aca8e0b5e8707e68****'),
  requestId?: string(name='RequestId', description='The request ID.', example='7DBFC67C-A272-5952-8287-6C3EBE4E04D9'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='8'),
}

model ListListenersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListListenersResponseBody(name='body'),
}

/**
 * @summary Queries Gateway Load Balancer (GWLB) listeners.
 *
 * @param request ListListenersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListListenersResponse
 */
async function listListenersWithOptions(request: ListListenersRequest, runtime: $RuntimeOptions): ListListenersResponse {
  request.validate();
  var body : map[string]any = {};
  var bodyFlat : map[string]any = {};
  if (!$isNull(request.listenerIds)) {
    bodyFlat['ListenerIds'] = request.listenerIds;
  }
  if (!$isNull(request.loadBalancerIds)) {
    bodyFlat['LoadBalancerIds'] = request.loadBalancerIds;
  }
  if (!$isNull(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.skip)) {
    body['Skip'] = request.skip;
  }
  if (!$isNull(request.tag)) {
    bodyFlat['Tag'] = request.tag;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListListeners',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries Gateway Load Balancer (GWLB) listeners.
 *
 * @param request ListListenersRequest
 * @return ListListenersResponse
 */
async function listListeners(request: ListListenersRequest): ListListenersResponse {
  var runtime = new $RuntimeOptions{};
  return listListenersWithOptions(request, runtime);
}

model ListLoadBalancersRequest {
  addressIpVersion?: string(name='AddressIpVersion', description='The IP version. Valid values:

*   **Ipv4**: IPv4

Enumeration values:

*   IPv4: IPv4
*   DualStack: DualStack', example='IPv4'),
  loadBalancerBusinessStatus?: string(name='LoadBalancerBusinessStatus', description='The business status of the GWLB instance. Valid values:

*   **Normal**: running as expected
*   **FinancialLocked**: locked due to overdue payments', example='Normal'),
  loadBalancerIds?: [ string ](name='LoadBalancerIds', description='The GWLB instance IDs. You can query at most 20 GWLB instances in each call.'),
  loadBalancerNames?: [ string ](name='LoadBalancerNames', description='The GWLB instance names. You can specify at most 20 GWLB instance names in each call.'),
  loadBalancerStatus?: string(name='LoadBalancerStatus', description='The GWLB instance status. Valid values:

*   **Active**: The GWLB instance is running.
*   **Inactive**: The GWLB instance is disabled. Listeners of GWLB instances in the Inactive state do not forward traffic.
*   **Provisioning**: The GWLB instance is being created.
*   **Configuring**: The GWLB instance is being modified.', example='Active'),
  maxResults?: int32(name='MaxResults', description='The number of entries per page. Valid values: 1 to 1000. Default value: 20.', example='20'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value of **NextToken** is returned, the value indicates the token that is used for the next query.', example='WyJyb290IiwibiIsIm4iLDEsMCwxNjg1MDY1NTgyNzYwLCI2NDcwMGY2ZTc2Zjc0MWFiZGEyZjQyNzc4ZDk2MmJkOTk3ZGZmM2Nm****'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-aek2htf5qsyrn****'),
  skip?: int32(name='Skip', description='The number of entries to be skipped in the call.', example='1'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key The tag key cannot be an empty string.

The tag key can be up to 128 characters in length. The tag key cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.', example='testTagKey'),
      value?: string(name='Value', description='The tag value The tag value can be up to 256 characters in length and cannot contain `http://` or `https://`.', example='testTagValue'),
    }
  ](name='Tag', description='The tags. You can specify at most 20 tags in each call.'),
  trafficMode?: string(name='TrafficMode'),
  vpcIds?: [ string ](name='VpcIds', description='The virtual private cloud (VPC) IDs. You can query at most 20 IDs in each call.'),
  zoneIds?: [ string ](name='ZoneIds', description='The zone IDs. You can query at most 20 zone IDs in each call.'),
}

model ListLoadBalancersResponseBody = {
  loadBalancers?: [ 
    {
      addressIpVersion?: string(name='AddressIpVersion', description='The IP version. Valid values:

*   **IPv4**', example='IPv4'),
      createTime?: string(name='CreateTime', description='The time when the resource was created. The time follows the ISO 8601 standard in the **yyyy-MM-ddTHH:mm:ssZ** format. The time is displayed in UTC.', example='2024-08-05 18:24:07'),
      loadBalancerBusinessStatus?: string(name='LoadBalancerBusinessStatus', description='The business status of the GWLB instance. Valid values:

*   **Normal**: running as expected
*   **FinancialLocked**: locked due to overdue payments', example='Normal'),
      loadBalancerId?: string(name='LoadBalancerId', description='The GWLB instance ID.', example='gwlb-9njtjmqt7zfcqm****'),
      loadBalancerName?: string(name='LoadBalancerName', description='The GWLB instance name.

The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (_), and hyphens (-). The name must start with a letter.', example='testGwlbName'),
      loadBalancerStatus?: string(name='LoadBalancerStatus', description='The GWLB instance status. Valid values:

*   **Active**: The GWLB instance is running.
*   **Inactive**: The GWLB instance is disabled. Listeners of GWLB instances in the Inactive state do not forward traffic.
*   **Provisioning**: The GWLB instance is being created.
*   **Configuring**: The GWLB instance is being modified.', example='Active'),
      resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-aek26jasguy****'),
      tags?: [ 
        {
          key?: string(name='Key', description='The tag key. The tag key cannot be an empty string.

The tag key can be up to 128 characters in length. The tag key cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.', example='testTagKey'),
          value?: string(name='Value', description='The tag value. You can specify at most 20 tag values. The tag value cannot be an empty string.

The tag value can be up to 128 characters in length. It must start with a letter and can contain digits, periods (.), underscores (_), and hyphens (-). It cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.', example='testTagValue'),
        }
      ](name='Tags', description='The tags.'),
      vpcId?: string(name='VpcId', description='The VPC ID.', example='vpc-uf6eg0vndlsa84n7r****'),
      zoneMappings?: [ 
        {
          loadBalancerAddresses?: [ 
            {
              eniId?: string(name='EniId', description='The ID of the elastic network interface (ENI) used by the GWLB instance.', example='eni-bp17qv9zbzyqy629****'),
              privateIpv4Address?: string(name='PrivateIpv4Address', description='The private IPv4 address.', example='192.168.XX.XX'),
            }
          ](name='LoadBalancerAddresses', description='The GWLB instance addresses.'),
          vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch in the zone. By default, each zone contains one vSwitch and one subnet.', example='vsw-2zemule5dz7okwqfv****'),
          zoneId?: string(name='ZoneId', description='The zone ID. You can call the DescribeZones operation to query the most recent zone list.', example='cn-hangzhou-g'),
        }
      ](name='ZoneMappings', description='The mappings between zones and vSwitches. You must specify at least one zone. You can specify at most 20 zones. If the region supports two or more zones, specify at least two zones.'),
    }
  ](name='LoadBalancers', description='The GWLB instances.'),
  maxResults?: int32(name='MaxResults', description='The number of entries per page. Valid values: 1 to 1000. Default value: 20.', example='20'),
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. Valid values:

*   If NextToken is empty, no next page exists.
*   You must specify the token that is obtained from the previous query as the value of NextToken.', example='CAESGgoSChAKDGNvbXBsZXRlVGltZRABCgQiAggAGAAiQAoJAIldD2UAAAAACjMDLgAAADFTNzMyZDMwMzAzMDY5NzQzNDM0NmI3NzM2NjUzNzc4NzM2YTc0NjYzOTYz****'),
  requestId?: string(name='RequestId', description='The request ID.', example='378A80E9-4262-5D8E-8D62-0969E52D7358'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
}

model ListLoadBalancersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLoadBalancersResponseBody(name='body'),
}

/**
 * @summary Queries Gateway Load Balancer (GWLB) instances.
 *
 * @param request ListLoadBalancersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListLoadBalancersResponse
 */
async function listLoadBalancersWithOptions(request: ListLoadBalancersRequest, runtime: $RuntimeOptions): ListLoadBalancersResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.addressIpVersion)) {
    body['AddressIpVersion'] = request.addressIpVersion;
  }
  if (!$isNull(request.loadBalancerBusinessStatus)) {
    body['LoadBalancerBusinessStatus'] = request.loadBalancerBusinessStatus;
  }
  var bodyFlat : map[string]any = {};
  if (!$isNull(request.loadBalancerIds)) {
    bodyFlat['LoadBalancerIds'] = request.loadBalancerIds;
  }
  if (!$isNull(request.loadBalancerNames)) {
    bodyFlat['LoadBalancerNames'] = request.loadBalancerNames;
  }
  if (!$isNull(request.loadBalancerStatus)) {
    body['LoadBalancerStatus'] = request.loadBalancerStatus;
  }
  if (!$isNull(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.skip)) {
    body['Skip'] = request.skip;
  }
  if (!$isNull(request.tag)) {
    bodyFlat['Tag'] = request.tag;
  }
  if (!$isNull(request.trafficMode)) {
    body['TrafficMode'] = request.trafficMode;
  }
  if (!$isNull(request.vpcIds)) {
    bodyFlat['VpcIds'] = request.vpcIds;
  }
  if (!$isNull(request.zoneIds)) {
    bodyFlat['ZoneIds'] = request.zoneIds;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListLoadBalancers',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries Gateway Load Balancer (GWLB) instances.
 *
 * @param request ListLoadBalancersRequest
 * @return ListLoadBalancersResponse
 */
async function listLoadBalancers(request: ListLoadBalancersRequest): ListLoadBalancersResponse {
  var runtime = new $RuntimeOptions{};
  return listLoadBalancersWithOptions(request, runtime);
}

model ListServerGroupServersRequest {
  maxResults?: int32(name='MaxResults', description='The number of entries per page.

Valid values: 1 to 1000.

Default value: 20.', example='20'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value of **NextToken** is returned, the value indicates the token that is used for the next query.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  serverGroupId?: string(name='ServerGroupId', description='The server group ID.', example='sgp-atstuj3rtoptyui****'),
  serverIds?: [ string ](name='ServerIds', description='The server IDs.

You can specify at most 200 servers in each call.'),
  serverIps?: [ string ](name='ServerIps', description='The server IP addresses.

You can specify at most 200 servers in each call.'),
  skip?: int32(name='Skip', description='The number of entries to be skipped in the call.', example='1'),
}

model ListServerGroupServersResponseBody = {
  maxResults?: int32(name='MaxResults', description='The number of entries per page.

Valid values: 1 to 1000.', example='20'),
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. Valid values:

*   If NextToken is empty, no next page exists.
*   You must specify the token that is obtained from the previous query as the value of NextToken.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', description='The request ID.', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
  servers?: [ 
    {
      port?: int32(name='Port', description='The backend server port. Valid values:

*   **6081**', example='6081'),
      serverGroupId?: string(name='ServerGroupId', description='The server group ID.', example='sgp-atstuj3rtoptyui****'),
      serverId?: string(name='ServerId', description='The backend server ID.', example='i-bp67acfmxazb4p****'),
      serverIp?: string(name='ServerIp', description='The IP address of the backend server.', example='192.168.xxx.xxx'),
      serverType?: string(name='ServerType', description='The type of the backend server. Valid values:

*   **Ecs**: Elastic Compute Service (ECS) instance
*   **Eni**: elastic network interface (ENI)
*   **Eci**: elastic container instance
*   **Ip**: IP address', example='Ecs'),
      status?: string(name='Status', description='Indicates the status of the backend server. Valid values:

*   **Adding**: The backend server is being added.
*   **Available**: The backend server is available.
*   **Draining**: The backend server is in connection draining.
*   **Removing**: The backend server is being removed.
*   **Replacing**: The backend server is being replaced.', example='Available'),
    }
  ](name='Servers', description='The backend servers.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model ListServerGroupServersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListServerGroupServersResponseBody(name='body'),
}

/**
 * @summary Queries the server groups of a Gateway Load Balancer (GWLB) instance.
 *
 * @param request ListServerGroupServersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListServerGroupServersResponse
 */
async function listServerGroupServersWithOptions(request: ListServerGroupServersRequest, runtime: $RuntimeOptions): ListServerGroupServersResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.serverGroupId)) {
    body['ServerGroupId'] = request.serverGroupId;
  }
  var bodyFlat : map[string]any = {};
  if (!$isNull(request.serverIds)) {
    bodyFlat['ServerIds'] = request.serverIds;
  }
  if (!$isNull(request.serverIps)) {
    bodyFlat['ServerIps'] = request.serverIps;
  }
  if (!$isNull(request.skip)) {
    body['Skip'] = request.skip;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListServerGroupServers',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the server groups of a Gateway Load Balancer (GWLB) instance.
 *
 * @param request ListServerGroupServersRequest
 * @return ListServerGroupServersResponse
 */
async function listServerGroupServers(request: ListServerGroupServersRequest): ListServerGroupServersResponse {
  var runtime = new $RuntimeOptions{};
  return listServerGroupServersWithOptions(request, runtime);
}

model ListServerGroupsRequest {
  maxResults?: int32(name='MaxResults', description='The number of entries per page.

Valid values: 1 to 1000.

Default value: 20.', example='20'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value of **NextToken** is returned, the value indicates the token that is used for the next query.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs.', example='rg-atstuj3rtop****'),
  serverGroupIds?: [ string ](name='ServerGroupIds', description='The server group IDs.

You can specify at most 20 server group IDs in each call.'),
  serverGroupNames?: [ string ](name='ServerGroupNames', description='The server group names.

You can specify at most 20 server group names in each call.'),
  serverGroupType?: string(name='ServerGroupType', description='The server group type. Valid values:

*   **Instance**: allows you to specify servers of the **Ecs**, **Eni**, or **Eci** type.
*   **Ip**: allows you to add servers of by specifying IP addresses.', example='Instance'),
  skip?: int32(name='Skip', description='The number of entries to be skipped in the call.', example='1'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key. The tag key cannot be an empty string. The tag key can be up to 128 characters in length, and cannot start with `acs:` or `aliyun`. The tag key cannot contain `http://` or `https://`.', example='testTagKey'),
      value?: string(name='Value', description='The tag value. The tag value can be up to 256 characters in length and cannot contain `http://` or `https://`.', example='testTagValue'),
    }
  ](name='Tag', description='The tag keys.

You can specify at most 20 tags in each call.'),
  vpcId?: string(name='VpcId', description='The VPC ID.', example='vpc-bp15zckdt37pq72zv****'),
}

model ListServerGroupsResponseBody = {
  maxResults?: int32(name='MaxResults', description='The number of entries per page.

Valid values: 1 to 1000.', example='20'),
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value of **NextToken** is returned, the value indicates the token that is used for the next query.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', description='The request ID.', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
  serverGroups?: [ 
    {
      connectionDrainConfig?: {
        connectionDrainEnabled?: boolean(name='ConnectionDrainEnabled', description='Indicates whether connection draining is enabled. Valid values:

*   **true**
*   **false**', example='false'),
        connectionDrainTimeout?: int32(name='ConnectionDrainTimeout', description='The timeout period of connection draining.

Unit: seconds

Valid values: 1 to 3600.', example='300'),
      }(name='ConnectionDrainConfig', description='The configurations of connection draining.'),
      createTime?: string(name='CreateTime', description='The time when the resource was created. The time follows the ISO 8601 standard in the **yyyy-MM-ddTHH:mm:ssZ** format. The time is displayed in UTC.', example='2024-08-05T18:24:07Z'),
      healthCheckConfig?: {
        healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='The backend server port that is used for health checks.

Valid values: **1** to **65535**.', example='80'),
        healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', description='The maximum timeout period of a health check.

Unit: seconds

Valid values: **1** to **300**.', example='5'),
        healthCheckDomain?: string(name='HealthCheckDomain', description='The domain name that is used for health checks. Valid values:

*   **$SERVER_IP**: the internal IP address of a backend server.
*   **domain**: a domain name. The domain name must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), and periods (.).

> This parameter takes effect only if you set **HealthCheckProtocol** to **HTTP**.', example='$SERVER_IP'),
        healthCheckEnabled?: boolean(name='HealthCheckEnabled', description='Indicates whether the health check feature is enabled. Valid values:

*   **true**
*   **false**', example='true'),
        healthCheckHttpCode?: [ string ](name='HealthCheckHttpCode', description='The HTTP status codes that the system returns for health checks.'),
        healthCheckInterval?: int32(name='HealthCheckInterval', description='The interval at which health checks are performed.

Unit: seconds

Valid values: **1** to **50**.', example='10'),
        healthCheckPath?: string(name='HealthCheckPath', description='The URL that is used for health checks.

The URL must be 1 to 80 characters in length, and can contain letters, digits, and the following special characters: ` - / . % ? # &  `The URL must start with a forward slash (/).

> This parameter takes effect only if you set **HealthCheckProtocol** to **HTTP**.', example='/test/index.html'),
        healthCheckProtocol?: string(name='HealthCheckProtocol', description='The protocol that is used for health checks. Valid values:

*   **TCP**: TCP health checks send TCP SYN packets to a backend server to check whether the port of the backend server is reachable.
*   **HTTP**: HTTP health checks simulate a process that uses a web browser to access resources by sending HEAD or GET requests to an instance. These requests are used to check whether the instance is healthy.', example='TCP'),
        healthyThreshold?: int32(name='HealthyThreshold', description='The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status changes from **fail** to **success**.

Valid values: **2** to **10**.', example='2'),
        unhealthyThreshold?: int32(name='UnhealthyThreshold', description='The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status changes from **success** to **fail**.

Valid values: **2** to **10**.', example='2'),
      }(name='HealthCheckConfig', description='The configuration of health checks.'),
      protocol?: string(name='Protocol', description='The backend protocol. Valid values:

*   **GENEVE**.', example='GENEVE'),
      relatedLoadBalancerIds?: [ string ](name='RelatedLoadBalancerIds', description='The IDs of the GWLB instances that are associated with the server group.'),
      resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-atstuj3rtop****'),
      scheduler?: string(name='Scheduler', description='The scheduling algorithm. Valid values:

*   **5TCH**: indicates consistent hashing that is based on the following factors: source IP address, destination IP address, source port, protocol, and destination port. Requests that contain the same information based on the preceding factors are forwarded to the same backend server.
*   **3TCH**: indicates consistent hashing that is based on the following factors: source IP address, destination IP address, and protocol. Requests that contain the same information based on the preceding factors are forwarded to the same backend server.
*   **2TCH**: indicates consistent hashing that is based on the following factors: source IP address and destination IP address. Requests that contain the same information based on the preceding factors are forwarded to the same backend server.', example='5TCH'),
      serverCount?: int32(name='ServerCount', description='The number of server groups.', example='2'),
      serverFailoverMode?: string(name='ServerFailoverMode'),
      serverGroupId?: string(name='ServerGroupId', description='The server group ID.', example='sgp-atstuj3rtoptyui****'),
      serverGroupName?: string(name='ServerGroupName', description='The server group name.', example='testServerGroupName'),
      serverGroupStatus?: string(name='ServerGroupStatus', description='The status of the server group. Valid values:

*   **Creating**
*   **Available**
*   **Configuring**', example='Available'),
      serverGroupType?: string(name='ServerGroupType', description='The server group type. Valid values:

*   **Instance**: allows you to specify servers of the **Ecs**, **Eni**, or **Eci** type.
*   **Ip**: allows you to add servers of by specifying IP addresses.', example='Instance'),
      tags?: [ 
        {
          key?: string(name='Key', description='The tag key. The tag key cannot be an empty string. The tag key can be up to 128 characters in length, and cannot start with `acs:` or `aliyun`. The tag key cannot contain `http://` or `https://`.', example='testTagKey'),
          value?: string(name='Value', description='The tag value. The tag value can be up to 256 characters in length and cannot contain `http://` or `https://`.', example='testTagValue'),
        }
      ](name='Tags', description='The tags.'),
      vpcId?: string(name='VpcId', description='The VPC ID.', example='vpc-bp15zckdt37pq72zv****'),
    }
  ](name='ServerGroups', description='The configurations of the server group.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model ListServerGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListServerGroupsResponseBody(name='body'),
}

/**
 * @summary Queries the server groups of a Gateway Load Balancer (GWLB) instance.
 *
 * @param request ListServerGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListServerGroupsResponse
 */
async function listServerGroupsWithOptions(request: ListServerGroupsRequest, runtime: $RuntimeOptions): ListServerGroupsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  var bodyFlat : map[string]any = {};
  if (!$isNull(request.serverGroupIds)) {
    bodyFlat['ServerGroupIds'] = request.serverGroupIds;
  }
  if (!$isNull(request.serverGroupNames)) {
    bodyFlat['ServerGroupNames'] = request.serverGroupNames;
  }
  if (!$isNull(request.serverGroupType)) {
    body['ServerGroupType'] = request.serverGroupType;
  }
  if (!$isNull(request.skip)) {
    body['Skip'] = request.skip;
  }
  if (!$isNull(request.tag)) {
    bodyFlat['Tag'] = request.tag;
  }
  if (!$isNull(request.vpcId)) {
    body['VpcId'] = request.vpcId;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListServerGroups',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the server groups of a Gateway Load Balancer (GWLB) instance.
 *
 * @param request ListServerGroupsRequest
 * @return ListServerGroupsResponse
 */
async function listServerGroups(request: ListServerGroupsRequest): ListServerGroupsResponse {
  var runtime = new $RuntimeOptions{};
  return listServerGroupsWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  maxResults?: int32(name='MaxResults', description='The maximum number of results to be returned from a single query when the NextToken parameter is used in the query. Valid values: 1 to 1000. Default value: 20.', example='20'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value of **NextToken** is returned, the value indicates the token that is used for the next query.', example='WyI2NDQ3MWUxM2EzOWNhMmY0Y2M2YTRiNzZhOWQwNmU1Y2RlNTYzMGEzIiwibiIsIm4iLDEsLTEsMTY5ODcxMzI2NjU0MywiNjU0MDRlYjI2MmI3MDhjY2JiMjM0ZmU0ODNkNTVmMGRhZDllOTBi****'),
  resourceId?: [ string ](name='ResourceId', description='The resource IDs. You can specify at most 50 resource IDs in each call.'),
  resourceType?: string(name='ResourceType', description='The type of resource. Valid values:

*   **loadbalancer**: Gateway Load Balancer (GWLB) instance
*   **listener**: listener
*   **servergroup**: server group

This parameter is required.', example='loadbalancer'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='testKey'),
      value?: string(name='Value', description='The tag value.', example='testValue'),
    }
  ](name='Tag', description='The tags. You can specify at most 20 tags in each call.'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value of **NextToken** is returned, the value indicates the token that is used for the next query.', example='d209f4e63ec942c967c50c888a13****'),
  requestId?: string(name='RequestId', description='The request ID.', example='A95325A2-E421-58A6-88AD-7A26CE610F45'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId', description='The resource ID.', example='gwlb-nrnrxwd15en27r****'),
      resourceType?: string(name='ResourceType', description='The resource type. Valid values:

*   **loadbalancer**: GWLB instance
*   **listener**: listener
*   **servergroup**: server group', example='loadbalancer'),
      tagKey?: string(name='TagKey', description='The tag key.', example='testKey'),
      tagValue?: string(name='TagValue', description='The tag value.', example='testValue'),
    }
  ](name='TagResources', description='The tags.'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesResponseBody(name='body'),
}

/**
 * @summary Queries the tags of resources.
 *
 * @param request ListTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesResponse
 */
async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: $RuntimeOptions): ListTagResourcesResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  var bodyFlat : map[string]any = {};
  if (!$isNull(request.resourceId)) {
    bodyFlat['ResourceId'] = request.resourceId;
  }
  if (!$isNull(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!$isNull(request.tag)) {
    bodyFlat['Tag'] = request.tag;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListTagResources',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the tags of resources.
 *
 * @param request ListTagResourcesRequest
 * @return ListTagResourcesResponse
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new $RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model MoveResourceGroupRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  newResourceGroupId?: string(name='NewResourceGroupId', description='The ID of the resource group to which you want to move the resource.

This parameter is required.', example='rg-aek253e4oit****'),
  resourceId?: string(name='ResourceId', description='The resource ID.

This parameter is required.', example='gwlb-nrnrxwd15en27r****'),
  resourceType?: string(name='ResourceType', description='The type of resource. Valid values:

*   **loadbalancer**: Gateway Load Balancer (GWLB) instance
*   **servergroup**: server group

This parameter is required.', example='loadbalancer'),
}

model MoveResourceGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='78828B5C-521E-50F3-84D4-7019691D1382'),
}

model MoveResourceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MoveResourceGroupResponseBody(name='body'),
}

/**
 * @summary Changes the resource group to which a specified cloud resource belongs.
 *
 * @param request MoveResourceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return MoveResourceGroupResponse
 */
async function moveResourceGroupWithOptions(request: MoveResourceGroupRequest, runtime: $RuntimeOptions): MoveResourceGroupResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.newResourceGroupId)) {
    body['NewResourceGroupId'] = request.newResourceGroupId;
  }
  if (!$isNull(request.resourceId)) {
    body['ResourceId'] = request.resourceId;
  }
  if (!$isNull(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'MoveResourceGroup',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Changes the resource group to which a specified cloud resource belongs.
 *
 * @param request MoveResourceGroupRequest
 * @return MoveResourceGroupResponse
 */
async function moveResourceGroup(request: MoveResourceGroupRequest): MoveResourceGroupResponse {
  var runtime = new $RuntimeOptions{};
  return moveResourceGroupWithOptions(request, runtime);
}

model RemoveServersFromServerGroupRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  serverGroupId?: string(name='ServerGroupId', description='The server group ID.

This parameter is required.', example='sgp-atstuj3rtoptyui****'),
  servers?: [ 
    {
      port?: int32(name='Port', description='The port that is used by the backend server. Valid values:

*   **6081**', example='6081'),
      serverId?: string(name='ServerId', description='The backend server ID.

*   If the server group is of the **Instance** type, set this parameter to the IDs of servers of the **Ecs**, **Eni**, or **Eci** type.
*   If the server group is of the **Ip** type, set ServerId to IP addresses.

This parameter is required.', example='i-bp67acfmxazb4p****'),
      serverIp?: string(name='ServerIp', description='The IP address of the backend server.', example='192.168.xxx.xxx'),
      serverType?: string(name='ServerType', description='The type of the backend server. Valid values:

*   **Ecs**: Elastic Compute Service (ECS) instance
*   **Eni**: elastic network interface (ENI)
*   **Eci**: elastic container instance
*   **Ip**: IP address

This parameter is required.', example='Ecs'),
    }
  ](name='Servers', description='The backend servers that you want to remove.

> You can remove at most 200 backend servers in each call.

This parameter is required.'),
}

model RemoveServersFromServerGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
}

model RemoveServersFromServerGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveServersFromServerGroupResponseBody(name='body'),
}

/**
 * @summary Removes backend servers from the server group of a Gateway Load Balancer (GWLB) instance.
 *
 * @description **RemoveServersFromServerGroup** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background.
 * 1.  You can call the ListServerGroups operation to query the status of a server group.
 *     *   If the server group is in the **Configuring** state, the server group is being modified.
 *     *   If the server group is in the **Available** state, the server group is running.
 * 2.  You can call the ListServerGroupServers operation to query the status of a backend server.
 *     *   If the backend server is in the **Removing** state, the backend server is being removed from the server group.
 *     *   If the backend server cannot be found, the backend server is no longer in the server group.
 * > 
 * *   If connection draining id enabled (**ConnectionDrainEnabled** set to true) for the server group of the backend server, the backend server that you remove enters the **Removing** state before entering the **Draining** state. When the connection draining timeout period (**ConnectionDrainTimeout**) ends, the backend server is removed from the server group.
 * *   You can add the backend server to the server group again before the connection draining timeout period ends. In this case, the status of the backend server changes from **Draining** to **Adding**. After the backend server is added to the server group, the backend server enters the **Available** state.
 *
 * @param request RemoveServersFromServerGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveServersFromServerGroupResponse
 */
async function removeServersFromServerGroupWithOptions(request: RemoveServersFromServerGroupRequest, runtime: $RuntimeOptions): RemoveServersFromServerGroupResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.serverGroupId)) {
    body['ServerGroupId'] = request.serverGroupId;
  }
  var bodyFlat : map[string]any = {};
  if (!$isNull(request.servers)) {
    bodyFlat['Servers'] = request.servers;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'RemoveServersFromServerGroup',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Removes backend servers from the server group of a Gateway Load Balancer (GWLB) instance.
 *
 * @description **RemoveServersFromServerGroup** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background.
 * 1.  You can call the ListServerGroups operation to query the status of a server group.
 *     *   If the server group is in the **Configuring** state, the server group is being modified.
 *     *   If the server group is in the **Available** state, the server group is running.
 * 2.  You can call the ListServerGroupServers operation to query the status of a backend server.
 *     *   If the backend server is in the **Removing** state, the backend server is being removed from the server group.
 *     *   If the backend server cannot be found, the backend server is no longer in the server group.
 * > 
 * *   If connection draining id enabled (**ConnectionDrainEnabled** set to true) for the server group of the backend server, the backend server that you remove enters the **Removing** state before entering the **Draining** state. When the connection draining timeout period (**ConnectionDrainTimeout**) ends, the backend server is removed from the server group.
 * *   You can add the backend server to the server group again before the connection draining timeout period ends. In this case, the status of the backend server changes from **Draining** to **Adding**. After the backend server is added to the server group, the backend server enters the **Available** state.
 *
 * @param request RemoveServersFromServerGroupRequest
 * @return RemoveServersFromServerGroupResponse
 */
async function removeServersFromServerGroup(request: RemoveServersFromServerGroupRequest): RemoveServersFromServerGroupResponse {
  var runtime = new $RuntimeOptions{};
  return removeServersFromServerGroupWithOptions(request, runtime);
}

model TagResourcesRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters. If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  resourceId?: [ string ](name='ResourceId', description='The resource IDs. You can specify at most 50 resource IDs in each call.

This parameter is required.'),
  resourceType?: string(name='ResourceType', description='The type of resource. Valid values:

*   **loadbalancer**: Gateway Load Balancer (GWLB) instance
*   **listener**: listener
*   **servergroup**: server group

This parameter is required.', example='loadbalancer'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key. The tag key cannot be an empty string. The tag key can be up to 128 characters in length, and cannot start with `acs:` or `aliyun`. The tag key cannot contain `http://` or `https://`.

This parameter is required.', example='testKey'),
      value?: string(name='Value', description='The tag value. The tag value can be up to 256 characters in length and cannot contain `http://` or `https://`.

This parameter is required.', example='testValue'),
    }
  ](name='Tag', description='The tags. You can specify at most 20 tags in each call.

This parameter is required.'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='54F6E60A-1777-5C17-A6A9-BCC1A7FE945B'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TagResourcesResponseBody(name='body'),
}

/**
 * @summary Creates and adds tags to resources.
 *
 * @param request TagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesResponse
 */
async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: $RuntimeOptions): TagResourcesResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  var bodyFlat : map[string]any = {};
  if (!$isNull(request.resourceId)) {
    bodyFlat['ResourceId'] = request.resourceId;
  }
  if (!$isNull(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!$isNull(request.tag)) {
    bodyFlat['Tag'] = request.tag;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'TagResources',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates and adds tags to resources.
 *
 * @param request TagResourcesRequest
 * @return TagResourcesResponse
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new $RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to remove all tags from the specified resource. This parameter is ignored if the TagKey parameter is specified. Valid values:

*   **true**: removes all tags from the specified resource.
*   **false**: does not remove all tags from the specified resource. This is the default value.', example='true'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters. If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  resourceId?: [ string ](name='ResourceId', description='The resource IDs. You can specify at most 50 resource IDs in each call.

This parameter is required.'),
  resourceType?: string(name='ResourceType', description='The type of resource. Valid values:

*   **loadbalancer**: Gateway Load Balancer (GWLB) instance
*   **listener**: listener
*   **servergroup**: server group

This parameter is required.', example='loadbalancer'),
  tagKey?: [ string ](name='TagKey', description='The keys of the tags that you want to remove. You can remove at most 20 tags in each call.'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='3DC0064C-C09E-5C99-8FD4-9CDB2DA7FA21'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UntagResourcesResponseBody(name='body'),
}

/**
 * @summary Removes tags from resources.
 *
 * @param request UntagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UntagResourcesResponse
 */
async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: $RuntimeOptions): UntagResourcesResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.all)) {
    body['All'] = request.all;
  }
  if (!$isNull(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  var bodyFlat : map[string]any = {};
  if (!$isNull(request.resourceId)) {
    bodyFlat['ResourceId'] = request.resourceId;
  }
  if (!$isNull(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!$isNull(request.tagKey)) {
    bodyFlat['TagKey'] = request.tagKey;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UntagResources',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Removes tags from resources.
 *
 * @param request UntagResourcesRequest
 * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new $RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateListenerAttributeRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters. If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  listenerDescription?: string(name='ListenerDescription', description='The listener description.

The description must be 2 to 256 characters in length, and can contain letters, digits, commas (,), periods (.), semicolons (;), forward slashes (/), at signs (@), underscores (_), and hyphens (-).', example='listener_description'),
  listenerId?: string(name='ListenerId', description='The listener ID.

This parameter is required.', example='lsn-lxce8iqbof2vl0****'),
  serverGroupId?: string(name='ServerGroupId', description='The server group ID.', example='sgp-sp8d2r6y7t0xtl****'),
}

model UpdateListenerAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='7DBFC67C-A272-5952-8287-6C3EBE4E04D9'),
}

model UpdateListenerAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateListenerAttributeResponseBody(name='body'),
}

/**
 * @summary Updates the configurations of a Gateway Load Balancer (GWLB) listener.
 *
 * @description **UpdateListenerAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the **GetListenerAttribute** operation to query the status of a listener.
 * *   If the listener is in the **Configuring** state, the listener is being modified.
 * *   If the listener is in the **Running** state, the listener is modified.
 *
 * @param request UpdateListenerAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateListenerAttributeResponse
 */
async function updateListenerAttributeWithOptions(request: UpdateListenerAttributeRequest, runtime: $RuntimeOptions): UpdateListenerAttributeResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.listenerDescription)) {
    body['ListenerDescription'] = request.listenerDescription;
  }
  if (!$isNull(request.listenerId)) {
    body['ListenerId'] = request.listenerId;
  }
  if (!$isNull(request.serverGroupId)) {
    body['ServerGroupId'] = request.serverGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateListenerAttribute',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the configurations of a Gateway Load Balancer (GWLB) listener.
 *
 * @description **UpdateListenerAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the **GetListenerAttribute** operation to query the status of a listener.
 * *   If the listener is in the **Configuring** state, the listener is being modified.
 * *   If the listener is in the **Running** state, the listener is modified.
 *
 * @param request UpdateListenerAttributeRequest
 * @return UpdateListenerAttributeResponse
 */
async function updateListenerAttribute(request: UpdateListenerAttributeRequest): UpdateListenerAttributeResponse {
  var runtime = new $RuntimeOptions{};
  return updateListenerAttributeWithOptions(request, runtime);
}

model UpdateLoadBalancerAttributeRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  loadBalancerId?: string(name='LoadBalancerId', description='The GWLB instance ID.

This parameter is required.', example='gwlb-9njtjmqt7zfcqm****'),
  loadBalancerName?: string(name='LoadBalancerName', description='The GWLB instance name.

The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (_), and hyphens (-). The name must start with a letter.', example='testGwlbName'),
  trafficMode?: string(name='TrafficMode'),
}

model UpdateLoadBalancerAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='B956C629-0E8C-5EFF-BAC1-B0E3A8C5CBDD'),
}

model UpdateLoadBalancerAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLoadBalancerAttributeResponseBody(name='body'),
}

/**
 * @summary Updates the attributes of a Gateway Load Balancer (GWLB) instance.
 *
 * @description *   UpdateLoadBalancerAttribute is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the GetLoadBalancerAttribute operation to query the status of the GWLB instance.
 *     *   If the GWLB instance is in the Configuring state, the GWLB instance is being modified.
 *     *   If the GWLB instance is in the Active state, the GWLB instance is modified.
 *
 * @param request UpdateLoadBalancerAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateLoadBalancerAttributeResponse
 */
async function updateLoadBalancerAttributeWithOptions(request: UpdateLoadBalancerAttributeRequest, runtime: $RuntimeOptions): UpdateLoadBalancerAttributeResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.loadBalancerId)) {
    body['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!$isNull(request.loadBalancerName)) {
    body['LoadBalancerName'] = request.loadBalancerName;
  }
  if (!$isNull(request.trafficMode)) {
    body['TrafficMode'] = request.trafficMode;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateLoadBalancerAttribute',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the attributes of a Gateway Load Balancer (GWLB) instance.
 *
 * @description *   UpdateLoadBalancerAttribute is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the GetLoadBalancerAttribute operation to query the status of the GWLB instance.
 *     *   If the GWLB instance is in the Configuring state, the GWLB instance is being modified.
 *     *   If the GWLB instance is in the Active state, the GWLB instance is modified.
 *
 * @param request UpdateLoadBalancerAttributeRequest
 * @return UpdateLoadBalancerAttributeResponse
 */
async function updateLoadBalancerAttribute(request: UpdateLoadBalancerAttributeRequest): UpdateLoadBalancerAttributeResponse {
  var runtime = new $RuntimeOptions{};
  return updateLoadBalancerAttributeWithOptions(request, runtime);
}

model UpdateLoadBalancerZonesRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  loadBalancerId?: string(name='LoadBalancerId', description='The GWLB instance ID.

This parameter is required.', example='gwlb-9njtjmqt7zfcqm****'),
  zoneMappings?: [ 
    {
      vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch in the zone. You can specify only one vSwitch (subnet) in each zone of a GWLB instance.

This parameter is required.', example='vsw-bp1n75pbs77v5q6p3****'),
      zoneId?: string(name='ZoneId', description='The zone ID. You can call the DescribeZones operation to query the most recent zone list.

This parameter is required.', example='cn-hangzhou-h'),
    }
  ](name='ZoneMappings', description='The mappings between zones and vSwitches. You must specify at least one zone. You can specify at most 20 zones. If the region supports two or more zones, we recommend that you select two or more zones.

This parameter is required.'),
}

model UpdateLoadBalancerZonesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='ED8905C2-A4F6-5E43-87B7-6A5DC8757146'),
}

model UpdateLoadBalancerZonesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLoadBalancerZonesResponseBody(name='body'),
}

/**
 * @summary Updates the zones of a Gateway Load Balancer (GWLB) instance.
 *
 * @description **Make sure that you fully understand the billing methods and [pricing](https://help.aliyun.com/document_detail/2806160.html) of GWLB before calling this operation**.
 * UpdateLoadBalancerZones is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the GetLoadBalancerAttribute operation to query the status of the GWLB instance.
 * *  If the GWLB instance is in the Configuring state, the GWLB instance is being modified.
 * *   If the GWLB instance is in the Active state, the GWLB instance is modified.
 * >  Before you call this operation, make sure that all zone parameters, including the current zones and the zones that you want to add, are specified. If you do not specify the current zones, the current zones are deleted. You can call the GetLoadBalancerAttribute operation to query the current zones of a GWLB instance.
 *
 * @param request UpdateLoadBalancerZonesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateLoadBalancerZonesResponse
 */
async function updateLoadBalancerZonesWithOptions(request: UpdateLoadBalancerZonesRequest, runtime: $RuntimeOptions): UpdateLoadBalancerZonesResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.loadBalancerId)) {
    body['LoadBalancerId'] = request.loadBalancerId;
  }
  var bodyFlat : map[string]any = {};
  if (!$isNull(request.zoneMappings)) {
    bodyFlat['ZoneMappings'] = request.zoneMappings;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateLoadBalancerZones',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the zones of a Gateway Load Balancer (GWLB) instance.
 *
 * @description **Make sure that you fully understand the billing methods and [pricing](https://help.aliyun.com/document_detail/2806160.html) of GWLB before calling this operation**.
 * UpdateLoadBalancerZones is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the GetLoadBalancerAttribute operation to query the status of the GWLB instance.
 * *  If the GWLB instance is in the Configuring state, the GWLB instance is being modified.
 * *   If the GWLB instance is in the Active state, the GWLB instance is modified.
 * >  Before you call this operation, make sure that all zone parameters, including the current zones and the zones that you want to add, are specified. If you do not specify the current zones, the current zones are deleted. You can call the GetLoadBalancerAttribute operation to query the current zones of a GWLB instance.
 *
 * @param request UpdateLoadBalancerZonesRequest
 * @return UpdateLoadBalancerZonesResponse
 */
async function updateLoadBalancerZones(request: UpdateLoadBalancerZonesRequest): UpdateLoadBalancerZonesResponse {
  var runtime = new $RuntimeOptions{};
  return updateLoadBalancerZonesWithOptions(request, runtime);
}

model UpdateServerGroupAttributeRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  connectionDrainConfig?: {
    connectionDrainEnabled?: boolean(name='ConnectionDrainEnabled', description='Specifies whether to enable connection draining. Valid values:

*   **true**
*   **false**', example='false'),
    connectionDrainTimeout?: int32(name='ConnectionDrainTimeout', description='The timeout period of connection draining.

Unit: seconds

Valid values: 1 to 3600.', example='300'),
  }(name='ConnectionDrainConfig', description='The configurations of connection draining.'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  healthCheckConfig?: {
    healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='The backend server port that is used by health checks.

Valid values: 1 to 65535.', example='80'),
    healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', description='The maximum timeout period of a health check response.

Unit: seconds

Valid values: **1** to **300**.', example='5'),
    healthCheckDomain?: string(name='HealthCheckDomain', description='The domain name that is used for health checks. Valid values:

*   **$SERVER_IP**: the internal IP address of a backend server.
*   **domain**: a domain name. The domain name must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), and periods (.).

> This parameter takes effect only if you set **HealthCheckProtocol** to **HTTP**.', example='$SERVER_IP'),
    healthCheckEnabled?: boolean(name='HealthCheckEnabled', description='Specifies whether to enable the health check feature. Valid values:

*   **true**
*   **false**', example='true'),
    healthCheckHttpCode?: [ string ](name='HealthCheckHttpCode', description='The HTTP status codes that the system returns for health checks.'),
    healthCheckInterval?: int32(name='HealthCheckInterval', description='The interval at which health checks are performed.

Unit: seconds

Valid values: **1** to **50**.', example='10'),
    healthCheckPath?: string(name='HealthCheckPath', description='The URL that is used for health checks.

The URL must be 1 to 80 characters in length, and can contain letters, digits, and the following special characters: ` - / . % ? # &  `The URL must start with a forward slash (/).

> This parameter takes effect only if you set **HealthCheckProtocol** to **HTTP**.', example='/test/index.html'),
    healthCheckProtocol?: string(name='HealthCheckProtocol', description='The protocol that is used for health checks. Valid values:

*   **TCP**: TCP health checks send TCP SYN packets to a backend server to check whether the port of the backend server is reachable.
*   **HTTP**: HTTP health checks simulate a process that uses a web browser to access resources by sending HEAD or GET requests to an instance. These requests are used to check whether the instance is healthy.', example='TCP'),
    healthyThreshold?: int32(name='HealthyThreshold', description='The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status changes from **fail** to **success**.

Valid values: **2** to **10**.', example='2'),
    unhealthyThreshold?: int32(name='UnhealthyThreshold', description='The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status changes from **success** to **fail**.

Valid values: **2** to **10**.', example='2'),
  }(name='HealthCheckConfig', description='The configurations of the health check feature.'),
  scheduler?: string(name='Scheduler', description='The scheduling algorithm. Valid values:

*   **5TCH**: specifies consistent hashing that is based on the following factors: source IP address, destination IP address, source port, protocol, and destination port. Requests that contain the same information based on the preceding factors are forwarded to the same backend server.
*   **3TCH**: specifies consistent hashing that is based on the following factors: source IP address, destination IP address, and protocol. Requests that contain the same information based on the preceding factors are forwarded to the same backend server.
*   **2TCH**: specifies consistent hashing that is based on the following factors: source IP address and destination IP address. Requests that contain the same information based on the preceding factors are forwarded to the same backend server.', example='5TCH'),
  serverFailoverMode?: string(name='ServerFailoverMode'),
  serverGroupId?: string(name='ServerGroupId', description='The server group ID.

This parameter is required.', example='sgp-atstuj3rtoptyui****'),
  serverGroupName?: string(name='ServerGroupName', description='The server group name.

The name must be 2 to 128 characters in length, and can contain digits, periods (.), underscores (_), and hyphens (-). It must start with a letter.', example='testServerGroupName'),
}

model UpdateServerGroupAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
}

model UpdateServerGroupAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateServerGroupAttributeResponseBody(name='body'),
}

/**
 * @summary Updates the attributes of a server group.
 *
 * @description **UpdateServerGroupAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the ListServerGroups operation to query the status of the task.
 * *   If the server group is in the **Configuring** state, the configuration of the server group is being modified.
 * *   If the server group is in the **Available** state, the configuration of the server group is modified.
 *
 * @param request UpdateServerGroupAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateServerGroupAttributeResponse
 */
async function updateServerGroupAttributeWithOptions(request: UpdateServerGroupAttributeRequest, runtime: $RuntimeOptions): UpdateServerGroupAttributeResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  var bodyFlat : map[string]any = {};
  if (!$isNull(request.connectionDrainConfig)) {
    bodyFlat['ConnectionDrainConfig'] = request.connectionDrainConfig;
  }
  if (!$isNull(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.healthCheckConfig)) {
    bodyFlat['HealthCheckConfig'] = request.healthCheckConfig;
  }
  if (!$isNull(request.scheduler)) {
    body['Scheduler'] = request.scheduler;
  }
  if (!$isNull(request.serverFailoverMode)) {
    body['ServerFailoverMode'] = request.serverFailoverMode;
  }
  if (!$isNull(request.serverGroupId)) {
    body['ServerGroupId'] = request.serverGroupId;
  }
  if (!$isNull(request.serverGroupName)) {
    body['ServerGroupName'] = request.serverGroupName;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateServerGroupAttribute',
    version = '2024-04-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the attributes of a server group.
 *
 * @description **UpdateServerGroupAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the ListServerGroups operation to query the status of the task.
 * *   If the server group is in the **Configuring** state, the configuration of the server group is being modified.
 * *   If the server group is in the **Available** state, the configuration of the server group is modified.
 *
 * @param request UpdateServerGroupAttributeRequest
 * @return UpdateServerGroupAttributeResponse
 */
async function updateServerGroupAttribute(request: UpdateServerGroupAttributeRequest): UpdateServerGroupAttributeResponse {
  var runtime = new $RuntimeOptions{};
  return updateServerGroupAttributeWithOptions(request, runtime);
}

