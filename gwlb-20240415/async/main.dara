/**
  *
  */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Gwlb';
  @version = '2024-04-15';
  @endpointRule = 'regional';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AddServersToServerGroupRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-426655440000', position='Body'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false', position='Body'),
  serverGroupId: string(name='ServerGroupId', description='The server group ID.

This parameter is required.', example='sgp-atstuj3rtoptyui****', position='Body'),
  servers: [ 
    {
      port?: int32(name='Port', description='The backend server port. Valid values:

*   **6081**', example='6081'),
      serverId: string(name='ServerId', description='The backend server ID.

*   If the server group is of the **Instance** type, set this parameter to the IDs of servers of the **Ecs**, **Eni**, or **Eci** type.
*   If the server group is of the **Ip** type, set ServerId to IP addresses.

This parameter is required.', example='i-bp67acfmxazb4p****'),
      serverIp?: string(name='ServerIp', description='The IP address of the backend server.', example='192.168.XX.XX'),
      serverType: string(name='ServerType', description='The type of the backend server. Valid values:

*   **Ecs**: Elastic Compute Service (ECS) instance
*   **Eni**: elastic network interface (ENI)
*   **Eci**: elastic container instance
*   **Ip**: IP address

This parameter is required.', example='Ecs'),
    }
  ](name='Servers', description='The backend servers that you want to add.

> You can add at most 200 backend servers in each call.

This parameter is required.', position='Body'),
}

model AddServersToServerGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
}

model AddServersToServerGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddServersToServerGroupResponseBody(name='body'),
}

/**
  * @description **AddServersToServerGroup** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background.
  * 1.  You can call the ListServerGroups operation to query the status of the server group.
  * *   If the server group is in the **Configuring** state, the server group is being modified.
  * *   If the server group is in the **Available** state, the server group is running.
  * 2.  You can call the ListServerGroupServers operation to query the status of the backend server.
  * *   If the backend server is in the **Adding** state, the backend server is being added to the server group.
  * *   If the backend server is in the **Available** state, the server is running.
  * @param request  the request parameters of AddServersToServerGroup  AddServersToServerGroupRequest
  * @return AddServersToServerGroupResponse
 */
async function addServersToServerGroup(request: AddServersToServerGroupRequest): AddServersToServerGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddServersToServerGroup', 'POST', '/', 'json', true, 'form', request);
}

model CreateListenerRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****', position='Body'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run, without sending the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false', position='Body'),
  listenerDescription?: string(name='ListenerDescription', description='The description of the listener.

The description must be 2 to 256 characters in length, and can contain letters, digits, commas (,), periods (.), semicolons (;), forward slashes (/), at signs (@), underscores (_), and hyphens (-).', example='listener-description', position='Body'),
  loadBalancerId: string(name='LoadBalancerId', description='The GWLB instance ID.

This parameter is required.', example='gwlb-te609d6696632f7*****', position='Body'),
  serverGroupId: string(name='ServerGroupId', description='The server group ID.

This parameter is required.', example='sgp-ckh01px70dszof****', position='Body'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key. The tag key cannot be an empty string. The tag key can be up to 128 characters in length, and cannot start with `acs:` or `aliyun`. The tag key cannot contain `http://` or `https://`.', example='testKey'),
      value?: string(name='Value', description='The tag value. The tag value can be up to 256 characters in length and cannot contain `http://` or `https://`.', example='testValue'),
    }
  ](name='Tag', description='The tags. You can specify at most 20 tags in each call.', position='Body'),
}

model CreateListenerResponseBody = {
  listenerId?: string(name='ListenerId', description='The listener ID.', example='lsn-wi3c0v30ivysrg****'),
  requestId?: string(name='RequestId', description='The request ID.', example='A045E652-D298-5E70-A978-7247135336FB'),
}

model CreateListenerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateListenerResponseBody(name='body'),
}

/**
  * @description **CreateListener** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the **GetListenerAttribute** operation to query the status of the task.
  * *   If the listener is in the **Provisioning** state, the listener is being created.
  * *   If the listener is in the **Running** state, the listener is running.
  * @param request  the request parameters of CreateListener  CreateListenerRequest
  * @return CreateListenerResponse
 */
async function createListener(request: CreateListenerRequest): CreateListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateListener', 'POST', '/', 'json', true, 'form', request);
}

model CreateLoadBalancerRequest {
  addressIpVersion?: string(name='AddressIpVersion', description='The IP version. Valid values:

*   **Ipv4** (default): IPv4', example='IPv4', position='Body'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-426655440000', position='Body'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false', position='Body'),
  loadBalancerName?: string(name='LoadBalancerName', description='The GWLB instance name.

The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (_), and hyphens (-). The name must start with a letter.', example='testGwlbName', position='Body'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-acfmwbufq6q3****', position='Body'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key. The tag key cannot be an empty string.

The tag key can be up to 128 characters in length. The tag key cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.', example='testTagKey'),
      value?: string(name='Value', description='The tag value. The tag value can be up to 256 characters in length and cannot contain `http://` or `https://`.', example='testTagValue'),
    }
  ](name='Tag', description='The tag keys. You can specify at most 20 tags in each call.', position='Body'),
  vpcId: string(name='VpcId', description='The virtual private cloud (VPC) ID.

This parameter is required.', example='vpc-uf6qcgpv22ttrnnjh****', position='Body'),
  zoneMappings: [ 
    {
      vSwitchId: string(name='VSwitchId', description='The ID of the vSwitch in the zone. You can specify only one vSwitch (subnet) in each zone of a GWLB instance.

This parameter is required.', example='vsw-2f0eb020****'),
      zoneId: string(name='ZoneId', description='The zone ID. You can call the DescribeZones operation to query the most recent zone list.

This parameter is required.', example='cn-hangzhou-a'),
    }
  ](name='ZoneMappings', description='The mappings between zones and vSwitches. You must specify at least one zone. You can specify at most 20 zones. If the region supports two or more zones, specify at least two zones.

This parameter is required.', position='Body'),
}

model CreateLoadBalancerResponseBody = {
  loadBalancerId?: string(name='LoadBalancerId', description='The GWLB instance ID.', example='gwlb-9njtjmqt7zfcqm****'),
  requestId?: string(name='RequestId', description='The request ID.', example='00B19438-66BB-58C3-8C2F-DA5B6F95CBDA'),
}

model CreateLoadBalancerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLoadBalancerResponseBody(name='body'),
}

/**
  * @description **Make sure that you fully understand the billing methods and [pricing](https://help.aliyun.com/document_detail/2806160.html) of GWLB before calling this operation**.
  * *   When you create a GWLB instance, the service-linked role AliyunServiceRoleForGwlb is automatically created.
  * *   CreateLoadBalancer is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the GetLoadBalancerAttribute operation to query the status of a GWLB instance.
  *     *   If the GWLB instance is in the Provisioning state, the GWLB instance is being created.
  *     *   If the GWLB instance is in the Active state, the GWLB instance is created.
  * @param request  the request parameters of CreateLoadBalancer  CreateLoadBalancerRequest
  * @return CreateLoadBalancerResponse
 */
async function createLoadBalancer(request: CreateLoadBalancerRequest): CreateLoadBalancerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLoadBalancer', 'POST', '/', 'json', true, 'form', request);
}

model CreateServerGroupRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****', position='Body'),
  connectionDrainConfig?: {
    connectionDrainEnabled?: boolean(name='ConnectionDrainEnabled', description='Specifies whether to enable connection draining. Valid values:

*   **true**
*   **false**', example='false'),
    connectionDrainTimeout?: int32(name='ConnectionDrainTimeout', description='The timeout period of connection draining.

Unit: seconds

Valid values: **1** to **3600**.

Default value: **300**.', example='300'),
  }(name='ConnectionDrainConfig', description='The configurations of connection draining.', position='Body'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='False', position='Body'),
  healthCheckConfig?: {
    healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='The backend server port that is used for health checks.

Valid values: **1** to **65535**.

Default value: **80**.', example='80'),
    healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', description='The maximum timeout period of a health check response.

Unit: seconds

Valid values: **1** to **300**.

Default value: **5**.', example='5'),
    healthCheckDomain?: string(name='HealthCheckDomain', description='The domain name that you want to use for health checks. Valid values:

*   **$SERVER_IP** (default): the private IP address of a backend server.
*   **domain**: a domain name. The domain name must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), and periods (.).

> This parameter takes effect only if you set **HealthCheckProtocol** to **HTTP**.', example='$SERVER_IP'),
    healthCheckEnabled?: boolean(name='HealthCheckEnabled', description='Specifies whether to enable the health check feature. Valid values:

*   **true** (default)
*   **false**', example='true'),
    healthCheckHttpCode?: [ string ](name='HealthCheckHttpCode', description='The HTTP status codes that the system returns for health checks.'),
    healthCheckInterval?: int32(name='HealthCheckInterval', description='The interval at which health checks are performed.

Unit: seconds

Valid values: **1** to **50**.

Default value: **10**.', example='10'),
    healthCheckPath?: string(name='HealthCheckPath', description='The URL that is used for health checks.

The URL must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.), percent signs (%), question marks (?), number signs (#), and ampersands (&). The URL can also contain the following extended characters: _ ; ~ ! ( ) \\* [ ] @ $ ^ : \\" , + =

The URL must start with a forward slash (/).

> This parameter takes effect only if you set **HealthCheckProtocol** to **HTTP**.', example='/test/index.html'),
    healthCheckProtocol?: string(name='HealthCheckProtocol', description='The protocol that is used for health checks. Valid values:

*   **TCP** (default): GWLB performs TCP health checks by sending SYN packets to a backend server to check whether the port of the backend server is available to receive requests.
*   **HTTP**: GWLB performs HTTP health checks to check whether backend servers are healthy by sending HEAD or GET requests which simulate access from browsers.', example='TCP'),
    healthyThreshold?: int32(name='HealthyThreshold', description='The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status changes from **fail** to **success**.

Valid values: **2** to **10**.

Default value: **2**.', example='2'),
    unhealthyThreshold?: int32(name='UnhealthyThreshold', description='The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status changes from **success** to **fail**.

Valid values: **2** to **10**.

Default value: **2**.', example='2'),
  }(name='HealthCheckConfig', description='The configurations of the health check feature.', position='Body'),
  protocol?: string(name='Protocol', description='The backend protocol. Valid values:

*   **GENEVE**(default)', example='GENEVE', position='Body'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-atstuj3rtop****', position='Body'),
  scheduler?: string(name='Scheduler', description='The scheduling algorithm. Valid values:

*   **5TCH** (default): specifies consistent hashing that is based on the following factors: source IP address, destination IP address, source port, protocol, and destination port. Requests that contain the same information based on the preceding factors are forwarded to the same backend server.
*   **3TCH**: specifies consistent hashing that is based on the following factors: source IP address, destination IP address, and protocol. Requests that contain the same information based on the preceding factors are forwarded to the same backend server.
*   **2TCH**: specifies consistent hashing that is based on the following factors: source IP address and destination IP address. Requests that contain the same information based on the preceding factors are forwarded to the same backend server.', example='5TCH', position='Body'),
  serverFailoverMode?: string(name='ServerFailoverMode', position='Body'),
  serverGroupName?: string(name='ServerGroupName', description='The server group name.

The name must be 2 to 128 characters in length, and can contain digits, periods (.), underscores (_), and hyphens (-). It must start with a letter.', example='testServerGroupName', position='Body'),
  serverGroupType?: string(name='ServerGroupType', description='The type of server group. Valid values:

*   **Instance** (default): allows you to specify servers of the **Ecs**, **Eni**, or **Eci** type.
*   **Ip**: allows you to add servers of by specifying IP addresses.', example='Instance', position='Body'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key. The tag key cannot be an empty string. The tag key can be up to 128 characters in length, and cannot start with `acs:` or `aliyun`. The tag key cannot contain `http://` or `https://`.', example='testTagKey'),
      value?: string(name='Value', description='The tag value. The tag value can be up to 256 characters in length and cannot contain `http://` or `https://`.', example='testTagValue'),
    }
  ](name='Tag', description='The tag keys.

You can specify at most 20 tags in each call.', position='Body'),
  vpcId: string(name='VpcId', description='The VPC ID.

> If **ServerGroupType** is set to **Instance**, only servers in the specified VPC can be added to the server group.

This parameter is required.', example='vpc-bp15zckdt37pq72zv****', position='Body'),
}

model CreateServerGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
  serverGroupId?: string(name='ServerGroupId', description='The server group ID.', example='sgp-atstuj3rtoptyui****'),
}

model CreateServerGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateServerGroupResponseBody(name='body'),
}

/**
  * @description **CreateServerGroup** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the ListServerGroups operation to query the status of the task.
  * *   If the server group is in the **Creating** state, it indicates that the server group is being created.
  * *   If the server group is in the **Available** state, it indicates that the server group is created.
  * @param request  the request parameters of CreateServerGroup  CreateServerGroupRequest
  * @return CreateServerGroupResponse
 */
async function createServerGroup(request: CreateServerGroupRequest): CreateServerGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateServerGroup', 'POST', '/', 'json', true, 'form', request);
}

model DeleteListenerRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****', position='Body'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run, without sending the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false', position='Body'),
  listenerId: string(name='ListenerId', description='The listener ID.

This parameter is required.', example='lsn-brx2y3hqdincizg***', position='Body'),
}

model DeleteListenerResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5C6E3548-086F-5FF6-A2B3-B1871B3AB488'),
}

model DeleteListenerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteListenerResponseBody(name='body'),
}

/**
  * @description **DeleteListener** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the **GetListenerAttribute** operation to query the status of the task.
  * *   If the listener is in the **Deleting** state, the listener is being deleted.
  * *   If the listener cannot be found, the listener is deleted.
  * @param request  the request parameters of DeleteListener  DeleteListenerRequest
  * @return DeleteListenerResponse
 */
async function deleteListener(request: DeleteListenerRequest): DeleteListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteListener', 'POST', '/', 'json', true, 'form', request);
}

model DeleteLoadBalancerRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-426655440000', position='Body'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run, without sending the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false', position='Body'),
  loadBalancerId: string(name='LoadBalancerId', description='The GWLB instance ID.

This parameter is required.', example='gwlb-9njtjmqt7zfcqm****', position='Body'),
}

model DeleteLoadBalancerResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='37907828-01AB-5AC3-9DDE-25D419091D54'),
}

model DeleteLoadBalancerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLoadBalancerResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteLoadBalancer  DeleteLoadBalancerRequest
  * @return DeleteLoadBalancerResponse
 */
async function deleteLoadBalancer(request: DeleteLoadBalancerRequest): DeleteLoadBalancerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLoadBalancer', 'POST', '/', 'json', true, 'form', request);
}

model DeleteServerGroupRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****', position='Body'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false', position='Body'),
  serverGroupId: string(name='ServerGroupId', description='The server group ID.

This parameter is required.', example='sgp-atstuj3rtoptyui****', position='Body'),
}

model DeleteServerGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
}

model DeleteServerGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteServerGroupResponseBody(name='body'),
}

/**
  * @description You can delete server groups that are not associated with listeners.
  * @param request  the request parameters of DeleteServerGroup  DeleteServerGroupRequest
  * @return DeleteServerGroupResponse
 */
async function deleteServerGroup(request: DeleteServerGroupRequest): DeleteServerGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteServerGroup', 'POST', '/', 'json', true, 'form', request);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The supported language. Valid values:

*   **zh-CN**: Chinese
*   **en-US** (default): English
*   **ja**: Japanese', example='zh-CN', position='Body'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      localName?: string(name='LocalName', description='The region name.', example='China (Hangzhou)'),
      regionEndpoint?: string(name='RegionEndpoint', description='The region endpoint.', example='gwlb.cn-hangzhou.aliyuncs.com'),
      regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
    }
  ](name='Regions', description='A list of regions.'),
  requestId?: string(name='RequestId', description='The request ID.', example='162FCE8D-CEEC-5083-90BF-B45D8C4F81FB'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeRegions  DescribeRegionsRequest
  * @return DescribeRegionsResponse
 */
async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRegions', 'POST', '/', 'json', true, 'form', request);
}

model DescribeZonesRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The supported language. Valid values:

*   **zh-CN**: Chinese
*   **en-US** (default): English
*   **ja**: Japanese', example='zh-CN', position='Body'),
}

model DescribeZonesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='4C605F7E-D0F6-54E2-B004-F9B132F0D8B2'),
  zones?: [ 
    {
      localName?: string(name='LocalName', description='The zone name.', example='Hangzhou Zone G'),
      zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-g'),
    }
  ](name='Zones', description='A list of zones.'),
}

model DescribeZonesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeZonesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeZones  DescribeZonesRequest
  * @return DescribeZonesResponse
 */
async function describeZones(request: DescribeZonesRequest): DescribeZonesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeZones', 'POST', '/', 'json', true, 'form', request);
}

model GetListenerAttributeRequest {
  listenerId: string(name='ListenerId', description='The listener ID.

This parameter is required.', example='lsn-brx2y3hqdinciz****', position='Body'),
}

model GetListenerAttributeResponseBody = {
  listenerDescription?: string(name='ListenerDescription', description='The listener description.

The description must be 2 to 256 characters in length, and can contain letters, digits, commas (,), periods (.), semicolons (;), forward slashes (/), at signs (@), underscores (_), and hyphens (-).', example='listener_description'),
  listenerId?: string(name='ListenerId', description='The listener ID.', example='lsn-3kbj3587mqhm3p****'),
  listenerStatus?: string(name='ListenerStatus', description='The listener status. Valid values:

*   **Provisioning**: The listener is being created.
*   **Running**: The listener is running.
*   **Configuring**: The listener is being configured.
*   **Deleting**: The listener is being deleted.', example='Provisioning'),
  loadBalancerId?: string(name='LoadBalancerId', description='The GWLB instance ID.', example='gwlb-te609d6696632f76****'),
  regionId?: string(name='RegionId', description='The region ID of the GWLB instance.', example='cn-hangzhou'),
  requestId?: string(name='RequestId', description='The request ID.', example='75CC3312-7757-5EE1-90D8-49CEA66608AE'),
  serverGroupId?: string(name='ServerGroupId', description='The server group ID.', example='sgp-sp8d2r6y7t0xtl****'),
  tags?: [ 
    {
      key?: string(name='Key', description='The tag key. The tag key cannot be an empty string. The tag key can be up to 128 characters in length, and cannot start with `acs: `or `aliyun`. The tag key cannot contain `http://` or `https://`.', example='testKey'),
      value?: string(name='Value', description='The tag value. The tag value can be up to 256 characters in length and cannot contain `http://` or `https://`.', example='testValue'),
    }
  ](name='Tags', description='The tags.'),
}

model GetListenerAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetListenerAttributeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetListenerAttribute  GetListenerAttributeRequest
  * @return GetListenerAttributeResponse
 */
async function getListenerAttribute(request: GetListenerAttributeRequest): GetListenerAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetListenerAttribute', 'POST', '/', 'json', true, 'form', request);
}

model GetListenerHealthStatusRequest {
  filter?: [ 
    {
      name?: string(name='Name', description='The filter condition name. You can filter by one or more filter condition names. The URL must meet the following requirements:

*   **Status**: the health status.
*   **ReasonCode**: the cause of an unhealthy server.
*   **ServerId**: the ID of the backend server.
*   **ServerIp**: the IP address of the backend server.', example='Status'),
      values?: [ string ](name='Values', description='The filter condition values. You can specify at most 20 condition values.'),
    }
  ](name='Filter', description='The filter conditions. You can specify at most 20 filter conditions.', position='Body'),
  listenerId: string(name='ListenerId', description='The listener ID.

This parameter is required.', example='lsn-7sixpvm5fc3v0b****', position='Body'),
  maxResults?: int32(name='MaxResults', description='The number of entries per page. Valid values: 1 to 1000. Default value: 20.', example='20', minimum=1, maximum=1000, position='Body'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value of **NextToken** is returned, the value indicates the token that is used for the next query.', example='4f1d7cc9f51e18904e8a063603a6b0c3d03bc69f78734254e0b5e8707e68****', position='Body'),
  skip?: int32(name='Skip', description='The number of entries to be skipped in the call.', example='10', position='Body'),
}

model GetListenerHealthStatusResponseBody = {
  listenerHealthStatus?: [ 
    {
      listenerId?: string(name='ListenerId', description='The listener ID.', example='lsn-sg8aha6pzjavvo****'),
      serverGroupInfos?: [ 
        {
          healthCheckEnabled?: boolean(name='HealthCheckEnabled', description='Indicates whether the health check feature is enabled. Valid values:

*   **true**
*   **false**', example='true'),
          serverGroupId?: string(name='ServerGroupId', description='The server group ID.', example='sgp-0vdsbyszro3nr6****'),
          servers?: [ 
            {
              port?: int32(name='Port', description='The backend port.', example='6081'),
              reason?: {
                reasonCode?: string(name='ReasonCode', description='The reason why **Status** indicates an unhealthy status. Valid values:

*   **CONNECT_TIMEOUT**: The GWLB instance failed to connect to the backend server within the specified period of time.
*   **CONNECT_FAILED**: The GWLB instance failed to connect to the backend server.
*   **RECV_RESPONSE_TIMEOUT**: The GWLB instance failed to receive a response from the backend server within the specified period of time.
*   **CONNECT_INTERRUPT**: The connection between the health check and the backend server was interrupted.
*   **HTTP_CODE_NOT_MATCH**: The HTTP status code from the backend server is not the expected one.
*   **HTTP_INVALID_HEADER**: The format of the response from the backend servers is invalid.', example='CONNECT_TIMEOUT'),
              }(name='Reason', description='The reason why **Status** indicates an unhealthy status.'),
              serverId?: string(name='ServerId', description='The backend server ID.', example='i-2ze4rnh8yj9kif3z****'),
              serverIp?: string(name='ServerIp', description='The IP address of the server.', example='192.168.0.XXX'),
              status?: string(name='Status', description='The health status of the backend server. Valid values:

*   **Initial**: Health checks are configured for the GWLB instance, but no data is found.
*   **Unhealthy**: The backend server consecutively fails health checks.
*   **Unused**: The backend server is not in use.
*   **Unavailable**: Health checks are disabled.
*   **Healthy**: The backend server is healthy.', example='Healthy'),
            }
          ](name='Servers', description='The backend servers.'),
        }
      ](name='ServerGroupInfos', description='The information about the server groups.'),
    }
  ](name='ListenerHealthStatus', description='The health check status of the server groups that are associated with the listener.'),
  maxResults?: int32(name='MaxResults', description='The number of entries per page. Valid values: 1 to 1000. Default value: 20.', example='20'),
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value of **NextToken** is returned, the value indicates the token that is used for the next query.', example='U12WEI6Ro2ol3wA54rBNSwdC5+lYy6q5SjIQEvc1wz5mjZxV+YjsHRdXV8XauY1BpOQIvwX63E0en54H3D****'),
  requestId?: string(name='RequestId', description='The request ID.', example='0ED4F222-36A0-5470-8A9A-AAB4E96BAC1A'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='31'),
}

model GetListenerHealthStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetListenerHealthStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetListenerHealthStatus  GetListenerHealthStatusRequest
  * @return GetListenerHealthStatusResponse
 */
async function getListenerHealthStatus(request: GetListenerHealthStatusRequest): GetListenerHealthStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetListenerHealthStatus', 'POST', '/', 'json', true, 'form', request);
}

model GetLoadBalancerAttributeRequest {
  loadBalancerId: string(name='LoadBalancerId', description='The GWLB instance ID.

This parameter is required.', example='gwlb-9njtjmqt7zfcqm****', position='Body'),
}

model GetLoadBalancerAttributeResponseBody = {
  addressIpVersion?: string(name='AddressIpVersion', description='The protocol version. Valid values:

*   **Ipv4**: IPv4.', example='IPv4'),
  createTime?: string(name='CreateTime', description='The time when the resource was created. The time follows the ISO 8601 standard in the **yyyy-MM-ddTHH:mm:ssZ** format. The time is displayed in UTC.', example='2024-07-08T10:12:58Z'),
  loadBalancerBusinessStatus?: string(name='LoadBalancerBusinessStatus', description='The business status of the GWLB instance. Valid values:

*   **Normal**: running as expected
*   **FinancialLocked**: locked due to overdue payments', example='Normal'),
  loadBalancerId?: string(name='LoadBalancerId', description='The GWLB instance ID.', example='gwlb-9njtjmqt7zfcqm****'),
  loadBalancerName?: string(name='LoadBalancerName', description='The GWLB instance name.

The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (_), and hyphens (-). The name must start with a letter.', example='gwlb'),
  loadBalancerStatus?: string(name='LoadBalancerStatus', description='The GWLB instance status. Valid values:

*   **Active**: The GWLB instance is running.
*   **Inactive**: The GWLB instance is disabled. Listeners of GWLB instances in the Inactive state do not forward traffic.
*   **Provisioning**: The GWLB instance is being created.
*   **Configuring**: The GWLB instance is being modified.', example='Active'),
  requestId?: string(name='RequestId', description='The request ID.', example='B6DC5DDC-9560-59BF-80FA-ED1E5CB417DF'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-acfmx7pmxcy****'),
  tags?: [ 
    {
      key?: string(name='Key', description='The tag key. The tag key cannot be an empty string.

The tag key can be up to 128 characters in length. The tag key cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.', example='testTagKey'),
      value?: string(name='Value', description='The tag value. The tag value can be up to 256 characters in length and cannot contain `http://` or `https://`.', example='testTagValue'),
    }
  ](name='Tags', description='The tags.'),
  trafficMode?: string(name='TrafficMode'),
  vpcId?: string(name='VpcId', description='The VPC ID.', example='vpc-k1aajsbwbaq4todet****'),
  zoneMappings?: [ 
    {
      loadBalancerAddresses?: [ 
        {
          eniId?: string(name='EniId', description='The ID of the elastic network interface (ENI) used by the GWLB instance.', example='eni-bp1iahwz3rzgvltz****'),
          privateIpv4Address?: string(name='PrivateIpv4Address', description='The private IPv4 address.', example='192.168.XX.XX'),
        }
      ](name='LoadBalancerAddresses', description='The GWLB instance addresses.'),
      vSwitchId?: string(name='VSwitchId', description='The vSwitch in the zone. You can specify only one vSwitch (subnet) in each zone of a GWLB instance.', example='vsw-uf6v8l7d2f1k53xrl****'),
      zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-j'),
    }
  ](name='ZoneMappings', description='The mappings between zones and vSwitches. You must specify at least one zone. You can specify at most 20 zones. If the region supports two or more zones, specify at least two zones.'),
}

model GetLoadBalancerAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLoadBalancerAttributeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetLoadBalancerAttribute  GetLoadBalancerAttributeRequest
  * @return GetLoadBalancerAttributeResponse
 */
async function getLoadBalancerAttribute(request: GetLoadBalancerAttributeRequest): GetLoadBalancerAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetLoadBalancerAttribute', 'POST', '/', 'json', true, 'form', request);
}

model ListListenersRequest {
  listenerIds?: [ string ](name='ListenerIds', description='The listener IDs. You can specify at most 20 listener IDs.', position='Body'),
  loadBalancerIds?: [ string ](name='LoadBalancerIds', description='The GWLB instance IDs. You can specify at most 20 instance IDs.', position='Body'),
  maxResults?: int32(name='MaxResults', description='The maximum number of results to be returned from a single query when the NextToken parameter is used in the query. Valid values: 1 to 1000. Default value: 20.', example='20', position='Body'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value of **NextToken** is returned, the value indicates the token that is used for the next query.', example='d209f4e63ec942c967c50c888a13****', position='Body'),
  skip?: int32(name='Skip', description='The number of entries to be skipped in the call.', example='10', position='Body'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key. The tag key cannot be an empty string.

The tag key can be up to 128 characters in length. The tag key cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.', example='tagKey'),
      value?: string(name='Value', description='The tag value. The tag value can be up to 256 characters in length and cannot contain `http://` or `https://`.', example='tagValue'),
    }
  ](name='Tag', description='The tags. You can specify at most 20 tags in each call.', position='Body'),
}

model ListListenersResponseBody = {
  listeners?: [ 
    {
      listenerDescription?: string(name='ListenerDescription', description='The description of the listener.', example='listener-description'),
      listenerId?: string(name='ListenerId', description='The listener ID.', example='lsn-vu7folhh5ntm8u****'),
      listenerStatus?: string(name='ListenerStatus', description='The status of the listener. Valid values:

*   **Provisioning**: The listener is being created.
*   **Running**: The listener is running.
*   **Configuring**: The listener is being configured.
*   **Deleting**: The listener is being deleted.', example='Running'),
      loadBalancerId?: string(name='LoadBalancerId', description='The GWLB instance ID.', example='gwlb-uf6hbeh795xlqln7g****'),
      serverGroupId?: string(name='ServerGroupId', description='The server group ID.', example='sgp-5yapcb422i51ru****'),
      tags?: [ 
        {
          key?: string(name='Key', description='The tag key.', example='testKey'),
          value?: string(name='Value', description='The tag value.', example='testValue'),
        }
      ](name='Tags', description='The tags.'),
    }
  ](name='Listeners', description='The GWLB listeners.'),
  maxResults?: int32(name='MaxResults', description='The maximum number of results to be returned from a single query when the NextToken parameter is used in the query. Valid values: 1 to 1000. Default value: 20.', example='20'),
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value of **NextToken** is returned, the value indicates the token that is used for the next query.', example='5c281c0a0d6bfb6355ed088c2108aca8e0b5e8707e68****'),
  requestId?: string(name='RequestId', description='The request ID.', example='7DBFC67C-A272-5952-8287-6C3EBE4E04D9'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='8'),
}

model ListListenersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListListenersResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListListeners  ListListenersRequest
  * @return ListListenersResponse
 */
async function listListeners(request: ListListenersRequest): ListListenersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListListeners', 'POST', '/', 'json', true, 'form', request);
}

model ListLoadBalancersRequest {
  addressIpVersion?: string(name='AddressIpVersion', description='The IP version. Valid values:

*   **Ipv4**: IPv4

Enumeration values:

*   IPv4: IPv4
*   DualStack: DualStack', example='IPv4', position='Body'),
  loadBalancerBusinessStatus?: string(name='LoadBalancerBusinessStatus', description='The business status of the GWLB instance. Valid values:

*   **Normal**: running as expected
*   **FinancialLocked**: locked due to overdue payments', example='Normal', position='Body'),
  loadBalancerIds?: [ string ](name='LoadBalancerIds', description='The GWLB instance IDs. You can query at most 20 GWLB instances in each call.', position='Body'),
  loadBalancerNames?: [ string ](name='LoadBalancerNames', description='The GWLB instance names. You can specify at most 20 GWLB instance names in each call.', position='Body'),
  loadBalancerStatus?: string(name='LoadBalancerStatus', description='The GWLB instance status. Valid values:

*   **Active**: The GWLB instance is running.
*   **Inactive**: The GWLB instance is disabled. Listeners of GWLB instances in the Inactive state do not forward traffic.
*   **Provisioning**: The GWLB instance is being created.
*   **Configuring**: The GWLB instance is being modified.', example='Active', position='Body'),
  maxResults?: int32(name='MaxResults', description='The number of entries per page. Valid values: 1 to 1000. Default value: 20.', example='20', position='Body'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value of **NextToken** is returned, the value indicates the token that is used for the next query.', example='WyJyb290IiwibiIsIm4iLDEsMCwxNjg1MDY1NTgyNzYwLCI2NDcwMGY2ZTc2Zjc0MWFiZGEyZjQyNzc4ZDk2MmJkOTk3ZGZmM2Nm****', position='Body'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-aek2htf5qsyrn****', position='Body'),
  skip?: int32(name='Skip', description='The number of entries to be skipped in the call.', example='1', position='Body'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key The tag key cannot be an empty string.

The tag key can be up to 128 characters in length. The tag key cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.', example='testTagKey'),
      value?: string(name='Value', description='The tag value The tag value can be up to 256 characters in length and cannot contain `http://` or `https://`.', example='testTagValue'),
    }
  ](name='Tag', description='The tags. You can specify at most 20 tags in each call.', position='Body'),
  trafficMode?: string(name='TrafficMode', position='Body'),
  vpcIds?: [ string ](name='VpcIds', description='The virtual private cloud (VPC) IDs. You can query at most 20 IDs in each call.', position='Body'),
  zoneIds?: [ string ](name='ZoneIds', description='The zone IDs. You can query at most 20 zone IDs in each call.', position='Body'),
}

model ListLoadBalancersResponseBody = {
  loadBalancers?: [ 
    {
      addressIpVersion?: string(name='AddressIpVersion', description='The IP version. Valid values:

*   **IPv4**', example='IPv4'),
      createTime?: string(name='CreateTime', description='The time when the resource was created. The time follows the ISO 8601 standard in the **yyyy-MM-ddTHH:mm:ssZ** format. The time is displayed in UTC.', example='2024-08-05 18:24:07'),
      loadBalancerBusinessStatus?: string(name='LoadBalancerBusinessStatus', description='The business status of the GWLB instance. Valid values:

*   **Normal**: running as expected
*   **FinancialLocked**: locked due to overdue payments', example='Normal'),
      loadBalancerId?: string(name='LoadBalancerId', description='The GWLB instance ID.', example='gwlb-9njtjmqt7zfcqm****'),
      loadBalancerName?: string(name='LoadBalancerName', description='The GWLB instance name.

The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (_), and hyphens (-). The name must start with a letter.', example='testGwlbName'),
      loadBalancerStatus?: string(name='LoadBalancerStatus', description='The GWLB instance status. Valid values:

*   **Active**: The GWLB instance is running.
*   **Inactive**: The GWLB instance is disabled. Listeners of GWLB instances in the Inactive state do not forward traffic.
*   **Provisioning**: The GWLB instance is being created.
*   **Configuring**: The GWLB instance is being modified.', example='Active'),
      resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-aek26jasguy****'),
      tags?: [ 
        {
          key?: string(name='Key', description='The tag key. The tag key cannot be an empty string.

The tag key can be up to 128 characters in length. The tag key cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.', example='testTagKey'),
          value?: string(name='Value', description='The tag value. You can specify at most 20 tag values. The tag value cannot be an empty string.

The tag value can be up to 128 characters in length. It must start with a letter and can contain digits, periods (.), underscores (_), and hyphens (-). It cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.', example='testTagValue'),
        }
      ](name='Tags', description='The tags.'),
      vpcId?: string(name='VpcId', description='The VPC ID.', example='vpc-uf6eg0vndlsa84n7r****'),
      zoneMappings?: [ 
        {
          loadBalancerAddresses?: [ 
            {
              eniId?: string(name='EniId', description='The ID of the elastic network interface (ENI) used by the GWLB instance.', example='eni-bp17qv9zbzyqy629****'),
              privateIpv4Address?: string(name='PrivateIpv4Address', description='The private IPv4 address.', example='192.168.XX.XX'),
            }
          ](name='LoadBalancerAddresses', description='The GWLB instance addresses.'),
          vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch in the zone. By default, each zone contains one vSwitch and one subnet.', example='vsw-2zemule5dz7okwqfv****'),
          zoneId?: string(name='ZoneId', description='The zone ID. You can call the DescribeZones operation to query the most recent zone list.', example='cn-hangzhou-g'),
        }
      ](name='ZoneMappings', description='The mappings between zones and vSwitches. You must specify at least one zone. You can specify at most 20 zones. If the region supports two or more zones, specify at least two zones.'),
    }
  ](name='LoadBalancers', description='The GWLB instances.'),
  maxResults?: int32(name='MaxResults', description='The number of entries per page. Valid values: 1 to 1000. Default value: 20.', example='20'),
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. Valid values:

*   If NextToken is empty, no next page exists.
*   You must specify the token that is obtained from the previous query as the value of NextToken.', example='CAESGgoSChAKDGNvbXBsZXRlVGltZRABCgQiAggAGAAiQAoJAIldD2UAAAAACjMDLgAAADFTNzMyZDMwMzAzMDY5NzQzNDM0NmI3NzM2NjUzNzc4NzM2YTc0NjYzOTYz****'),
  requestId?: string(name='RequestId', description='The request ID.', example='378A80E9-4262-5D8E-8D62-0969E52D7358'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
}

model ListLoadBalancersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLoadBalancersResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListLoadBalancers  ListLoadBalancersRequest
  * @return ListLoadBalancersResponse
 */
async function listLoadBalancers(request: ListLoadBalancersRequest): ListLoadBalancersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListLoadBalancers', 'POST', '/', 'json', true, 'form', request);
}

model ListServerGroupServersRequest {
  maxResults?: int32(name='MaxResults', description='The number of entries per page.

Valid values: 1 to 1000.

Default value: 20.', example='20', position='Body'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value of **NextToken** is returned, the value indicates the token that is used for the next query.', example='FFmyTO70tTpLG6I3FmYAXGKPd****', position='Body'),
  serverGroupId?: string(name='ServerGroupId', description='The server group ID.', example='sgp-atstuj3rtoptyui****', position='Body'),
  serverIds?: [ string ](name='ServerIds', description='The server IDs.

You can specify at most 200 servers in each call.', position='Body'),
  serverIps?: [ string ](name='ServerIps', description='The server IP addresses.

You can specify at most 200 servers in each call.', position='Body'),
  skip?: int32(name='Skip', description='The number of entries to be skipped in the call.', example='1', position='Body'),
}

model ListServerGroupServersResponseBody = {
  maxResults?: int32(name='MaxResults', description='The number of entries per page.

Valid values: 1 to 1000.', example='20'),
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. Valid values:

*   If NextToken is empty, no next page exists.
*   You must specify the token that is obtained from the previous query as the value of NextToken.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', description='The request ID.', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
  servers?: [ 
    {
      port?: int32(name='Port', description='The backend server port. Valid values:

*   **6081**', example='6081'),
      serverGroupId?: string(name='ServerGroupId', description='The server group ID.', example='sgp-atstuj3rtoptyui****'),
      serverId?: string(name='ServerId', description='The backend server ID.', example='i-bp67acfmxazb4p****'),
      serverIp?: string(name='ServerIp', description='The IP address of the backend server.', example='192.168.xxx.xxx'),
      serverType?: string(name='ServerType', description='The type of the backend server. Valid values:

*   **Ecs**: Elastic Compute Service (ECS) instance
*   **Eni**: elastic network interface (ENI)
*   **Eci**: elastic container instance
*   **Ip**: IP address', example='Ecs'),
      status?: string(name='Status', description='Indicates the status of the backend server. Valid values:

*   **Adding**: The backend server is being added.
*   **Available**: The backend server is available.
*   **Draining**: The backend server is in connection draining.
*   **Removing**: The backend server is being removed.
*   **Replacing**: The backend server is being replaced.', example='Available'),
    }
  ](name='Servers', description='The backend servers.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model ListServerGroupServersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListServerGroupServersResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListServerGroupServers  ListServerGroupServersRequest
  * @return ListServerGroupServersResponse
 */
async function listServerGroupServers(request: ListServerGroupServersRequest): ListServerGroupServersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListServerGroupServers', 'POST', '/', 'json', true, 'form', request);
}

model ListServerGroupsRequest {
  maxResults?: int32(name='MaxResults', description='The number of entries per page.

Valid values: 1 to 1000.

Default value: 20.', example='20', position='Body'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value of **NextToken** is returned, the value indicates the token that is used for the next query.', example='FFmyTO70tTpLG6I3FmYAXGKPd****', position='Body'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs.', example='rg-atstuj3rtop****', position='Body'),
  serverGroupIds?: [ string ](name='ServerGroupIds', description='The server group IDs.

You can specify at most 20 server group IDs in each call.', position='Body'),
  serverGroupNames?: [ string ](name='ServerGroupNames', description='The server group names.

You can specify at most 20 server group names in each call.', position='Body'),
  serverGroupType?: string(name='ServerGroupType', description='The server group type. Valid values:

*   **Instance**: allows you to specify servers of the **Ecs**, **Eni**, or **Eci** type.
*   **Ip**: allows you to add servers of by specifying IP addresses.', example='Instance', position='Body'),
  skip?: int32(name='Skip', description='The number of entries to be skipped in the call.', example='1', position='Body'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key. The tag key cannot be an empty string. The tag key can be up to 128 characters in length, and cannot start with `acs:` or `aliyun`. The tag key cannot contain `http://` or `https://`.', example='testTagKey'),
      value?: string(name='Value', description='The tag value. The tag value can be up to 256 characters in length and cannot contain `http://` or `https://`.', example='testTagValue'),
    }
  ](name='Tag', description='The tag keys.

You can specify at most 20 tags in each call.', position='Body'),
  vpcId?: string(name='VpcId', description='The VPC ID.', example='vpc-bp15zckdt37pq72zv****', position='Body'),
}

model ListServerGroupsResponseBody = {
  maxResults?: int32(name='MaxResults', description='The number of entries per page.

Valid values: 1 to 1000.', example='20'),
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value of **NextToken** is returned, the value indicates the token that is used for the next query.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', description='The request ID.', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
  serverGroups?: [ 
    {
      connectionDrainConfig?: {
        connectionDrainEnabled?: boolean(name='ConnectionDrainEnabled', description='Indicates whether connection draining is enabled. Valid values:

*   **true**
*   **false**', example='false'),
        connectionDrainTimeout?: int32(name='ConnectionDrainTimeout', description='The timeout period of connection draining.

Unit: seconds

Valid values: 1 to 3600.', example='300'),
      }(name='ConnectionDrainConfig', description='The configurations of connection draining.'),
      createTime?: string(name='CreateTime', description='The time when the resource was created. The time follows the ISO 8601 standard in the **yyyy-MM-ddTHH:mm:ssZ** format. The time is displayed in UTC.', example='2024-08-05T18:24:07Z'),
      healthCheckConfig?: {
        healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='The backend server port that is used for health checks.

Valid values: **1** to **65535**.', example='80'),
        healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', description='The maximum timeout period of a health check.

Unit: seconds

Valid values: **1** to **300**.', example='5'),
        healthCheckDomain?: string(name='HealthCheckDomain', description='The domain name that is used for health checks. Valid values:

*   **$SERVER_IP**: the internal IP address of a backend server.
*   **domain**: a domain name. The domain name must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), and periods (.).

> This parameter takes effect only if you set **HealthCheckProtocol** to **HTTP**.', example='$SERVER_IP'),
        healthCheckEnabled?: boolean(name='HealthCheckEnabled', description='Indicates whether the health check feature is enabled. Valid values:

*   **true**
*   **false**', example='true'),
        healthCheckHttpCode?: [ string ](name='HealthCheckHttpCode', description='The HTTP status codes that the system returns for health checks.'),
        healthCheckInterval?: int32(name='HealthCheckInterval', description='The interval at which health checks are performed.

Unit: seconds

Valid values: **1** to **50**.', example='10'),
        healthCheckPath?: string(name='HealthCheckPath', description='The URL that is used for health checks.

The URL must be 1 to 80 characters in length, and can contain letters, digits, and the following special characters: ` - / . % ? # &  `The URL must start with a forward slash (/).

> This parameter takes effect only if you set **HealthCheckProtocol** to **HTTP**.', example='/test/index.html'),
        healthCheckProtocol?: string(name='HealthCheckProtocol', description='The protocol that is used for health checks. Valid values:

*   **TCP**: TCP health checks send TCP SYN packets to a backend server to check whether the port of the backend server is reachable.
*   **HTTP**: HTTP health checks simulate a process that uses a web browser to access resources by sending HEAD or GET requests to an instance. These requests are used to check whether the instance is healthy.', example='TCP'),
        healthyThreshold?: int32(name='HealthyThreshold', description='The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status changes from **fail** to **success**.

Valid values: **2** to **10**.', example='2'),
        unhealthyThreshold?: int32(name='UnhealthyThreshold', description='The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status changes from **success** to **fail**.

Valid values: **2** to **10**.', example='2'),
      }(name='HealthCheckConfig', description='The configuration of health checks.'),
      protocol?: string(name='Protocol', description='The backend protocol. Valid values:

*   **GENEVE**.', example='GENEVE'),
      relatedLoadBalancerIds?: [ string ](name='RelatedLoadBalancerIds', description='The IDs of the GWLB instances that are associated with the server group.'),
      resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-atstuj3rtop****'),
      scheduler?: string(name='Scheduler', description='The scheduling algorithm. Valid values:

*   **5TCH**: indicates consistent hashing that is based on the following factors: source IP address, destination IP address, source port, protocol, and destination port. Requests that contain the same information based on the preceding factors are forwarded to the same backend server.
*   **3TCH**: indicates consistent hashing that is based on the following factors: source IP address, destination IP address, and protocol. Requests that contain the same information based on the preceding factors are forwarded to the same backend server.
*   **2TCH**: indicates consistent hashing that is based on the following factors: source IP address and destination IP address. Requests that contain the same information based on the preceding factors are forwarded to the same backend server.', example='5TCH'),
      serverCount?: int32(name='ServerCount', description='The number of server groups.', example='2'),
      serverFailoverMode?: string(name='ServerFailoverMode'),
      serverGroupId?: string(name='ServerGroupId', description='The server group ID.', example='sgp-atstuj3rtoptyui****'),
      serverGroupName?: string(name='ServerGroupName', description='The server group name.', example='testServerGroupName'),
      serverGroupStatus?: string(name='ServerGroupStatus', description='The status of the server group. Valid values:

*   **Creating**
*   **Available**
*   **Configuring**', example='Available'),
      serverGroupType?: string(name='ServerGroupType', description='The server group type. Valid values:

*   **Instance**: allows you to specify servers of the **Ecs**, **Eni**, or **Eci** type.
*   **Ip**: allows you to add servers of by specifying IP addresses.', example='Instance'),
      tags?: [ 
        {
          key?: string(name='Key', description='The tag key. The tag key cannot be an empty string. The tag key can be up to 128 characters in length, and cannot start with `acs:` or `aliyun`. The tag key cannot contain `http://` or `https://`.', example='testTagKey'),
          value?: string(name='Value', description='The tag value. The tag value can be up to 256 characters in length and cannot contain `http://` or `https://`.', example='testTagValue'),
        }
      ](name='Tags', description='The tags.'),
      vpcId?: string(name='VpcId', description='The VPC ID.', example='vpc-bp15zckdt37pq72zv****'),
    }
  ](name='ServerGroups', description='The configurations of the server group.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model ListServerGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListServerGroupsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListServerGroups  ListServerGroupsRequest
  * @return ListServerGroupsResponse
 */
async function listServerGroups(request: ListServerGroupsRequest): ListServerGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListServerGroups', 'POST', '/', 'json', true, 'form', request);
}

model ListTagResourcesRequest {
  maxResults?: int32(name='MaxResults', description='The maximum number of results to be returned from a single query when the NextToken parameter is used in the query. Valid values: 1 to 1000. Default value: 20.', example='20', position='Body'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value of **NextToken** is returned, the value indicates the token that is used for the next query.', example='WyI2NDQ3MWUxM2EzOWNhMmY0Y2M2YTRiNzZhOWQwNmU1Y2RlNTYzMGEzIiwibiIsIm4iLDEsLTEsMTY5ODcxMzI2NjU0MywiNjU0MDRlYjI2MmI3MDhjY2JiMjM0ZmU0ODNkNTVmMGRhZDllOTBi****', position='Body'),
  resourceId?: [ string ](name='ResourceId', description='The resource IDs. You can specify at most 50 resource IDs in each call.', position='Body'),
  resourceType: string(name='ResourceType', description='The type of resource. Valid values:

*   **loadbalancer**: Gateway Load Balancer (GWLB) instance
*   **listener**: listener
*   **servergroup**: server group

This parameter is required.', example='loadbalancer', position='Body'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='testKey'),
      value?: string(name='Value', description='The tag value.', example='testValue'),
    }
  ](name='Tag', description='The tags. You can specify at most 20 tags in each call.', position='Body'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value of **NextToken** is returned, the value indicates the token that is used for the next query.', example='d209f4e63ec942c967c50c888a13****'),
  requestId?: string(name='RequestId', description='The request ID.', example='A95325A2-E421-58A6-88AD-7A26CE610F45'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId', description='The resource ID.', example='gwlb-nrnrxwd15en27r****'),
      resourceType?: string(name='ResourceType', description='The resource type. Valid values:

*   **loadbalancer**: GWLB instance
*   **listener**: listener
*   **servergroup**: server group', example='loadbalancer'),
      tagKey?: string(name='TagKey', description='The tag key.', example='testKey'),
      tagValue?: string(name='TagValue', description='The tag value.', example='testValue'),
    }
  ](name='TagResources', description='The tags.'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListTagResources  ListTagResourcesRequest
  * @return ListTagResourcesResponse
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', '/', 'json', true, 'form', request);
}

model MoveResourceGroupRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****', position='Body'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false', position='Body'),
  newResourceGroupId: string(name='NewResourceGroupId', description='The ID of the resource group to which you want to move the resource.

This parameter is required.', example='rg-aek253e4oit****', position='Body'),
  resourceId: string(name='ResourceId', description='The resource ID.

This parameter is required.', example='gwlb-nrnrxwd15en27r****', position='Body'),
  resourceType: string(name='ResourceType', description='The type of resource. Valid values:

*   **loadbalancer**: Gateway Load Balancer (GWLB) instance
*   **servergroup**: server group

This parameter is required.', example='loadbalancer', position='Body'),
}

model MoveResourceGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='78828B5C-521E-50F3-84D4-7019691D1382'),
}

model MoveResourceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MoveResourceGroupResponseBody(name='body'),
}

/**
  * @param request  the request parameters of MoveResourceGroup  MoveResourceGroupRequest
  * @return MoveResourceGroupResponse
 */
async function moveResourceGroup(request: MoveResourceGroupRequest): MoveResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'MoveResourceGroup', 'POST', '/', 'json', true, 'form', request);
}

model RemoveServersFromServerGroupRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****', position='Body'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false', position='Body'),
  serverGroupId: string(name='ServerGroupId', description='The server group ID.

This parameter is required.', example='sgp-atstuj3rtoptyui****', position='Body'),
  servers: [ 
    {
      port?: int32(name='Port', description='The port that is used by the backend server. Valid values:

*   **6081**', example='6081'),
      serverId: string(name='ServerId', description='The backend server ID.

*   If the server group is of the **Instance** type, set this parameter to the IDs of servers of the **Ecs**, **Eni**, or **Eci** type.
*   If the server group is of the **Ip** type, set ServerId to IP addresses.

This parameter is required.', example='i-bp67acfmxazb4p****'),
      serverIp?: string(name='ServerIp', description='The IP address of the backend server.', example='192.168.xxx.xxx'),
      serverType: string(name='ServerType', description='The type of the backend server. Valid values:

*   **Ecs**: Elastic Compute Service (ECS) instance
*   **Eni**: elastic network interface (ENI)
*   **Eci**: elastic container instance
*   **Ip**: IP address

This parameter is required.', example='Ecs'),
    }
  ](name='Servers', description='The backend servers that you want to remove.

> You can remove at most 200 backend servers in each call.

This parameter is required.', position='Body'),
}

model RemoveServersFromServerGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
}

model RemoveServersFromServerGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveServersFromServerGroupResponseBody(name='body'),
}

/**
  * @description **RemoveServersFromServerGroup** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background.
  * 1.  You can call the ListServerGroups operation to query the status of a server group.
  *     *   If the server group is in the **Configuring** state, the server group is being modified.
  *     *   If the server group is in the **Available** state, the server group is running.
  * 2.  You can call the ListServerGroupServers operation to query the status of a backend server.
  *     *   If the backend server is in the **Removing** state, the backend server is being removed from the server group.
  *     *   If the backend server cannot be found, the backend server is no longer in the server group.
  * > 
  * *   If connection draining id enabled (**ConnectionDrainEnabled** set to true) for the server group of the backend server, the backend server that you remove enters the **Removing** state before entering the **Draining** state. When the connection draining timeout period (**ConnectionDrainTimeout**) ends, the backend server is removed from the server group.
  * *   You can add the backend server to the server group again before the connection draining timeout period ends. In this case, the status of the backend server changes from **Draining** to **Adding**. After the backend server is added to the server group, the backend server enters the **Available** state.
  * @param request  the request parameters of RemoveServersFromServerGroup  RemoveServersFromServerGroupRequest
  * @return RemoveServersFromServerGroupResponse
 */
async function removeServersFromServerGroup(request: RemoveServersFromServerGroupRequest): RemoveServersFromServerGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveServersFromServerGroup', 'POST', '/', 'json', true, 'form', request);
}

model TagResourcesRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters. If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****', position='Body'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false', position='Body'),
  resourceId: [ string ](name='ResourceId', description='The resource IDs. You can specify at most 50 resource IDs in each call.

This parameter is required.', position='Body'),
  resourceType: string(name='ResourceType', description='The type of resource. Valid values:

*   **loadbalancer**: Gateway Load Balancer (GWLB) instance
*   **listener**: listener
*   **servergroup**: server group

This parameter is required.', example='loadbalancer', position='Body'),
  tag: [ 
    {
      key: string(name='Key', description='The tag key. The tag key cannot be an empty string. The tag key can be up to 128 characters in length, and cannot start with `acs:` or `aliyun`. The tag key cannot contain `http://` or `https://`.

This parameter is required.', example='testKey'),
      value: string(name='Value', description='The tag value. The tag value can be up to 256 characters in length and cannot contain `http://` or `https://`.

This parameter is required.', example='testValue'),
    }
  ](name='Tag', description='The tags. You can specify at most 20 tags in each call.

This parameter is required.', position='Body'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='54F6E60A-1777-5C17-A6A9-BCC1A7FE945B'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TagResourcesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of TagResources  TagResourcesRequest
  * @return TagResourcesResponse
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagResources', 'POST', '/', 'json', true, 'form', request);
}

model UntagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to remove all tags from the specified resource. This parameter is ignored if the TagKey parameter is specified. Valid values:

*   **true**: removes all tags from the specified resource.
*   **false**: does not remove all tags from the specified resource. This is the default value.', example='true', position='Body'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters. If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****', position='Body'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false', position='Body'),
  resourceId: [ string ](name='ResourceId', description='The resource IDs. You can specify at most 50 resource IDs in each call.

This parameter is required.', position='Body'),
  resourceType: string(name='ResourceType', description='The type of resource. Valid values:

*   **loadbalancer**: Gateway Load Balancer (GWLB) instance
*   **listener**: listener
*   **servergroup**: server group

This parameter is required.', example='loadbalancer', position='Body'),
  tagKey?: [ string ](name='TagKey', description='The keys of the tags that you want to remove. You can remove at most 20 tags in each call.', position='Body'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='3DC0064C-C09E-5C99-8FD4-9CDB2DA7FA21'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UntagResourcesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UntagResources  UntagResourcesRequest
  * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UntagResources', 'POST', '/', 'json', true, 'form', request);
}

model UpdateListenerAttributeRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters. If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****', position='Body'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false', position='Body'),
  listenerDescription?: string(name='ListenerDescription', description='The listener description.

The description must be 2 to 256 characters in length, and can contain letters, digits, commas (,), periods (.), semicolons (;), forward slashes (/), at signs (@), underscores (_), and hyphens (-).', example='listener_description', position='Body'),
  listenerId: string(name='ListenerId', description='The listener ID.

This parameter is required.', example='lsn-lxce8iqbof2vl0****', position='Body'),
  serverGroupId?: string(name='ServerGroupId', description='The server group ID.', example='sgp-sp8d2r6y7t0xtl****', position='Body'),
}

model UpdateListenerAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='7DBFC67C-A272-5952-8287-6C3EBE4E04D9'),
}

model UpdateListenerAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateListenerAttributeResponseBody(name='body'),
}

/**
  * @description **UpdateListenerAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the **GetListenerAttribute** operation to query the status of a listener.
  * *   If the listener is in the **Configuring** state, the listener is being modified.
  * *   If the listener is in the **Running** state, the listener is modified.
  * @param request  the request parameters of UpdateListenerAttribute  UpdateListenerAttributeRequest
  * @return UpdateListenerAttributeResponse
 */
async function updateListenerAttribute(request: UpdateListenerAttributeRequest): UpdateListenerAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateListenerAttribute', 'POST', '/', 'json', true, 'form', request);
}

model UpdateLoadBalancerAttributeRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-426655440000', position='Body'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false', position='Body'),
  loadBalancerId: string(name='LoadBalancerId', description='The GWLB instance ID.

This parameter is required.', example='gwlb-9njtjmqt7zfcqm****', position='Body'),
  loadBalancerName?: string(name='LoadBalancerName', description='The GWLB instance name.

The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (_), and hyphens (-). The name must start with a letter.', example='testGwlbName', position='Body'),
  trafficMode?: string(name='TrafficMode', position='Body'),
}

model UpdateLoadBalancerAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='B956C629-0E8C-5EFF-BAC1-B0E3A8C5CBDD'),
}

model UpdateLoadBalancerAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLoadBalancerAttributeResponseBody(name='body'),
}

/**
  * @description *   UpdateLoadBalancerAttribute is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the GetLoadBalancerAttribute operation to query the status of the GWLB instance.
  *     *   If the GWLB instance is in the Configuring state, the GWLB instance is being modified.
  *     *   If the GWLB instance is in the Active state, the GWLB instance is modified.
  * @param request  the request parameters of UpdateLoadBalancerAttribute  UpdateLoadBalancerAttributeRequest
  * @return UpdateLoadBalancerAttributeResponse
 */
async function updateLoadBalancerAttribute(request: UpdateLoadBalancerAttributeRequest): UpdateLoadBalancerAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLoadBalancerAttribute', 'POST', '/', 'json', true, 'form', request);
}

model UpdateLoadBalancerZonesRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****', position='Body'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false', position='Body'),
  loadBalancerId: string(name='LoadBalancerId', description='The GWLB instance ID.

This parameter is required.', example='gwlb-9njtjmqt7zfcqm****', position='Body'),
  zoneMappings: [ 
    {
      vSwitchId: string(name='VSwitchId', description='The ID of the vSwitch in the zone. You can specify only one vSwitch (subnet) in each zone of a GWLB instance.

This parameter is required.', example='vsw-bp1n75pbs77v5q6p3****'),
      zoneId: string(name='ZoneId', description='The zone ID. You can call the DescribeZones operation to query the most recent zone list.

This parameter is required.', example='cn-hangzhou-h'),
    }
  ](name='ZoneMappings', description='The mappings between zones and vSwitches. You must specify at least one zone. You can specify at most 20 zones. If the region supports two or more zones, we recommend that you select two or more zones.

This parameter is required.', position='Body'),
}

model UpdateLoadBalancerZonesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='ED8905C2-A4F6-5E43-87B7-6A5DC8757146'),
}

model UpdateLoadBalancerZonesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLoadBalancerZonesResponseBody(name='body'),
}

/**
  * @description **Make sure that you fully understand the billing methods and [pricing](https://help.aliyun.com/document_detail/2806160.html) of GWLB before calling this operation**.
  * UpdateLoadBalancerZones is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the GetLoadBalancerAttribute operation to query the status of the GWLB instance.
  * *  If the GWLB instance is in the Configuring state, the GWLB instance is being modified.
  * *   If the GWLB instance is in the Active state, the GWLB instance is modified.
  * >  Before you call this operation, make sure that all zone parameters, including the current zones and the zones that you want to add, are specified. If you do not specify the current zones, the current zones are deleted. You can call the GetLoadBalancerAttribute operation to query the current zones of a GWLB instance.
  * @param request  the request parameters of UpdateLoadBalancerZones  UpdateLoadBalancerZonesRequest
  * @return UpdateLoadBalancerZonesResponse
 */
async function updateLoadBalancerZones(request: UpdateLoadBalancerZonesRequest): UpdateLoadBalancerZonesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLoadBalancerZones', 'POST', '/', 'json', true, 'form', request);
}

model UpdateServerGroupAttributeRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****', position='Body'),
  connectionDrainConfig?: {
    connectionDrainEnabled?: boolean(name='ConnectionDrainEnabled', description='Specifies whether to enable connection draining. Valid values:

*   **true**
*   **false**', example='false'),
    connectionDrainTimeout?: int32(name='ConnectionDrainTimeout', description='The timeout period of connection draining.

Unit: seconds

Valid values: 1 to 3600.', example='300'),
  }(name='ConnectionDrainConfig', description='The configurations of connection draining.', position='Body'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false', position='Body'),
  healthCheckConfig?: {
    healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='The backend server port that is used by health checks.

Valid values: 1 to 65535.', example='80'),
    healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', description='The maximum timeout period of a health check response.

Unit: seconds

Valid values: **1** to **300**.', example='5'),
    healthCheckDomain?: string(name='HealthCheckDomain', description='The domain name that is used for health checks. Valid values:

*   **$SERVER_IP**: the internal IP address of a backend server.
*   **domain**: a domain name. The domain name must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), and periods (.).

> This parameter takes effect only if you set **HealthCheckProtocol** to **HTTP**.', example='$SERVER_IP'),
    healthCheckEnabled?: boolean(name='HealthCheckEnabled', description='Specifies whether to enable the health check feature. Valid values:

*   **true**
*   **false**', example='true'),
    healthCheckHttpCode?: [ string ](name='HealthCheckHttpCode', description='The HTTP status codes that the system returns for health checks.'),
    healthCheckInterval?: int32(name='HealthCheckInterval', description='The interval at which health checks are performed.

Unit: seconds

Valid values: **1** to **50**.', example='10'),
    healthCheckPath?: string(name='HealthCheckPath', description='The URL that is used for health checks.

The URL must be 1 to 80 characters in length, and can contain letters, digits, and the following special characters: ` - / . % ? # &  `The URL must start with a forward slash (/).

> This parameter takes effect only if you set **HealthCheckProtocol** to **HTTP**.', example='/test/index.html'),
    healthCheckProtocol?: string(name='HealthCheckProtocol', description='The protocol that is used for health checks. Valid values:

*   **TCP**: TCP health checks send TCP SYN packets to a backend server to check whether the port of the backend server is reachable.
*   **HTTP**: HTTP health checks simulate a process that uses a web browser to access resources by sending HEAD or GET requests to an instance. These requests are used to check whether the instance is healthy.', example='TCP'),
    healthyThreshold?: int32(name='HealthyThreshold', description='The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status changes from **fail** to **success**.

Valid values: **2** to **10**.', example='2'),
    unhealthyThreshold?: int32(name='UnhealthyThreshold', description='The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status changes from **success** to **fail**.

Valid values: **2** to **10**.', example='2'),
  }(name='HealthCheckConfig', description='The configurations of the health check feature.', position='Body'),
  scheduler?: string(name='Scheduler', description='The scheduling algorithm. Valid values:

*   **5TCH**: specifies consistent hashing that is based on the following factors: source IP address, destination IP address, source port, protocol, and destination port. Requests that contain the same information based on the preceding factors are forwarded to the same backend server.
*   **3TCH**: specifies consistent hashing that is based on the following factors: source IP address, destination IP address, and protocol. Requests that contain the same information based on the preceding factors are forwarded to the same backend server.
*   **2TCH**: specifies consistent hashing that is based on the following factors: source IP address and destination IP address. Requests that contain the same information based on the preceding factors are forwarded to the same backend server.', example='5TCH', position='Body'),
  serverFailoverMode?: string(name='ServerFailoverMode', position='Body'),
  serverGroupId: string(name='ServerGroupId', description='The server group ID.

This parameter is required.', example='sgp-atstuj3rtoptyui****', position='Body'),
  serverGroupName?: string(name='ServerGroupName', description='The server group name.

The name must be 2 to 128 characters in length, and can contain digits, periods (.), underscores (_), and hyphens (-). It must start with a letter.', example='testServerGroupName', position='Body'),
}

model UpdateServerGroupAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
}

model UpdateServerGroupAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateServerGroupAttributeResponseBody(name='body'),
}

/**
  * @description **UpdateServerGroupAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the ListServerGroups operation to query the status of the task.
  * *   If the server group is in the **Configuring** state, the configuration of the server group is being modified.
  * *   If the server group is in the **Available** state, the configuration of the server group is modified.
  * @param request  the request parameters of UpdateServerGroupAttribute  UpdateServerGroupAttributeRequest
  * @return UpdateServerGroupAttributeResponse
 */
async function updateServerGroupAttribute(request: UpdateServerGroupAttributeRequest): UpdateServerGroupAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateServerGroupAttribute', 'POST', '/', 'json', true, 'form', request);
}

