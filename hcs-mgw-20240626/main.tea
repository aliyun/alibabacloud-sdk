/**
 *
 */
import Util;
import GatewayClient;
import OpenApi;
import OpenApiUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @productId = 'hcs-mgw';
  var gatewayClient = new GatewayClient();
  @spi = gatewayClient;
  @endpointRule = '';
  }

model AddressDetail {
  accessId?: string(name='AccessId', description='This parameter is required.', example='test_access_id'),
  accessSecret?: string(name='AccessSecret', description='This parameter is required.', example='test_secret_key'),
  addressType?: string(name='AddressType', description='This parameter is required.', example='ossinv'),
  agentList?: string(name='AgentList'),
  bucket?: string(name='Bucket', description='This parameter is required.', example='test_bucket'),
  domain?: string(name='Domain', description='This parameter is required.', example='test_domain'),
  invAccessId?: string(name='InvAccessId', example='test_inv_access_id'),
  invAccessSecret?: string(name='InvAccessSecret', example='test_inv_secret_key'),
  invBucket?: string(name='InvBucket', example='test_inv_bucket'),
  invDomain?: string(name='InvDomain', example='test_inv_domain'),
  invLocation?: string(name='InvLocation', example='oss'),
  invPath?: string(name='InvPath', example='manifest.json'),
  invRegionId?: string(name='InvRegionId', example='test_inv_region_id'),
  invRole?: string(name='InvRole', example='test_inv_role'),
  prefix?: string(name='Prefix', example='test_prefix'),
  regionId?: string(name='RegionId', example='test_region_id'),
  role?: string(name='Role', example='test_role'),
}

model Audit {
  logMode?: string(name='LogMode', example='off'),
}

model CreateAddressInfo {
  addressDetail?: AddressDetail(name='AddressDetail', description='This parameter is required.'),
  name?: string(name='Name', description='This parameter is required.', example='test_name'),
  tags?: string(name='Tags', example='K1:V1,K2:V2'),
}

model CreateAgentInfo {
  agentEndpoint?: string(name='AgentEndpoint', description='This parameter is required.', example='vpc'),
  deployMethod?: string(name='DeployMethod', description='This parameter is required.', example='default'),
  name?: string(name='Name', description='This parameter is required.', example='test_name'),
  tags?: string(name='Tags', example='K1:V1,K2:V2'),
  tunnelId?: string(name='TunnelId', description='This parameter is required.', example='test_tunnel_id'),
}

model CreateJobInfo {
  audit?: Audit(name='Audit'),
  convertSymlinkTarget?: boolean(name='ConvertSymlinkTarget', example='false'),
  createReport?: boolean(name='CreateReport'),
  destAddress?: string(name='DestAddress', description='This parameter is required.', example='test_dest_address'),
  enableMultiVersioning?: boolean(name='EnableMultiVersioning'),
  filterRule?: FilterRule(name='FilterRule'),
  importQos?: ImportQos(name='ImportQos'),
  name?: string(name='Name', description='This parameter is required.', example='test_name'),
  overwriteMode?: string(name='OverwriteMode', description='This parameter is required.', example='always'),
  parentVersion?: string(name='ParentVersion'),
  scheduleRule?: ScheduleRule(name='ScheduleRule'),
  srcAddress?: string(name='SrcAddress', description='This parameter is required.', example='test_src_address'),
  tags?: string(name='Tags', example='K1:V1,K2:V2'),
  transferMode?: string(name='TransferMode', description='This parameter is required.', example='all'),
}

model CreateReportInfo {
  jobName?: string(name='JobName', example='test_job_name'),
  runtimeId?: int32(name='RuntimeId', example='1'),
  version?: string(name='Version', example='test_job_id'),
}

model CreateTunnelInfo {
  tags?: string(name='Tags', example='K1:V1,K2:V2'),
  tunnelQos?: TunnelQos(name='TunnelQos'),
}

model FileTypeFilters {
  excludeDir?: boolean(name='ExcludeDir', example='fasle'),
  excludeSymlink?: boolean(name='ExcludeSymlink', example='fasle'),
}

model FilterRule {
  fileTypeFilters?: FileTypeFilters(name='FileTypeFilters'),
  keyFilters?: KeyFilters(name='KeyFilters'),
  lastModifiedFilters?: LastModifiedFilters(name='LastModifiedFilters'),
}

model GetAddressResp {
  addressDetail?: AddressDetail(name='AddressDetail'),
  createTime?: string(name='CreateTime', example='2024-05-01 12:00:00'),
  modifyTime?: string(name='ModifyTime', example='2024-05-01 12:00:00'),
  name?: string(name='Name', example='test_name'),
  owner?: string(name='Owner', example='test_owner'),
  status?: string(name='Status', example='avaliable'),
  tags?: string(name='Tags', example='K1:V1,K2:V2'),
  verifyResult?: VerifyResp(name='VerifyResult'),
  verifyTime?: string(name='VerifyTime', example='2024-05-01 12:00:00'),
  version?: string(name='Version', example='test_id'),
}

model GetAgentResp {
  activationKey?: string(name='ActivationKey'),
  agentEndpoint?: string(name='AgentEndpoint', example='vpc'),
  createTime?: string(name='CreateTime', example='2024-05-01 12:00:00'),
  deployMethod?: string(name='DeployMethod', example='default'),
  modifyTime?: string(name='ModifyTime', example='2024-05-01 12:00:00'),
  name?: string(name='Name', example='test_name'),
  owner?: string(name='Owner', example='test_owner'),
  tags?: string(name='Tags', example='K1:V1,K2:V2'),
  tunnelId?: string(name='TunnelId', example='test_tunnel_id'),
  version?: string(name='Version', example='test_agent_id'),
}

model GetAgentStatusResp {
  status?: string(name='Status', example='OK'),
}

model GetJobResp {
  audit?: Audit(name='Audit'),
  convertSymlinkTarget?: boolean(name='ConvertSymlinkTarget', example='false'),
  createReport?: boolean(name='CreateReport', example='false'),
  createTime?: string(name='CreateTime', example='2024-05-01 12:00:00'),
  destAddress?: string(name='DestAddress', example='test_dest_address'),
  enableMultiVersioning?: boolean(name='EnableMultiVersioning', example='false'),
  filterRule?: FilterRule(name='FilterRule'),
  importQos?: ImportQos(name='ImportQos'),
  modifyTime?: string(name='ModifyTime', example='2024-05-01 12:00:00'),
  name?: string(name='Name', example='test_name'),
  overwriteMode?: string(name='OverwriteMode', example='always'),
  owner?: string(name='Owner'),
  parentName?: string(name='ParentName'),
  parentVersion?: string(name='ParentVersion'),
  scheduleRule?: ScheduleRule(name='ScheduleRule'),
  srcAddress?: string(name='SrcAddress', example='test_src_address'),
  status?: string(name='Status', example='IMPORT_JOB_DOING'),
  tags?: string(name='Tags', example='K1:V1,K2:V2'),
  transferMode?: string(name='TransferMode', example='all'),
  version?: string(name='Version', example='test_id'),
}

model GetJobResultResp {
  addressType?: string(name='AddressType', example='ossinv'),
  copiedObjectCount?: long(name='CopiedObjectCount', example='800'),
  copiedObjectSize?: long(name='CopiedObjectSize', example='800'),
  failedObjectCount?: long(name='FailedObjectCount', example='200'),
  invAccessId?: string(name='InvAccessId', example='test_access_id'),
  invAccessSecret?: string(name='InvAccessSecret', example='test_secret_key'),
  invBucket?: string(name='InvBucket', example='test_sys_bucket'),
  invDomain?: string(name='InvDomain', example='test_domain'),
  invLocation?: string(name='InvLocation', example='oss'),
  invPath?: string(name='InvPath', example='mainfest.json'),
  invRegionId?: string(name='InvRegionId', example='test_region_id'),
  readyRetry?: string(name='ReadyRetry', example='Ready'),
  totalObjectCount?: long(name='TotalObjectCount', example='1000'),
  totalObjectSize?: long(name='TotalObjectSize', example='1000'),
  version?: string(name='Version', example='test_job_id'),
}

model GetReportResp {
  copiedCount?: long(name='CopiedCount', example='800'),
  errorMessage?: string(name='ErrorMessage'),
  failedCount?: long(name='FailedCount', example='100'),
  failedListPrefix?: string(name='FailedListPrefix', example='test_failed_prefix/'),
  jobCreateTime?: string(name='JobCreateTime', example='2024-05-01 12:00:00'),
  jobEndTime?: string(name='JobEndTime', example='2024-05-01 12:00:00'),
  jobExecuteTime?: string(name='JobExecuteTime', example='1000'),
  reportCreateTime?: string(name='ReportCreateTime', example='2024-05-01 12:00:00'),
  reportEndTime?: string(name='ReportEndTime', example='2024-05-01 12:00:00'),
  skippedCount?: long(name='SkippedCount', example='100'),
  skippedListPrefix?: string(name='SkippedListPrefix', example='test_skipped_prefix/'),
  status?: string(name='Status', example='Running'),
  totalCount?: long(name='TotalCount', example='1000'),
  totalListPrefix?: string(name='TotalListPrefix', example='test_total_prefix/'),
}

model GetTunnelResp {
  createTime?: string(name='CreateTime', example='2024-05-01 12:00:00'),
  modifyTime?: string(name='ModifyTime', example='2024-05-01 12:00:00'),
  owner?: string(name='Owner', example='test_owner'),
  tags?: string(name='Tags', example='K1:V1,K2:V2'),
  tunnelId?: string(name='TunnelId', example='test_tunnel_id'),
  tunnelQos?: TunnelQos(name='TunnelQos'),
}

model ImportQos {
  maxBandWidth?: long(name='MaxBandWidth', example='1073741824'),
  maxImportTaskQps?: long(name='MaxImportTaskQps', example='1000'),
}

model JobHistory {
  commitId?: string(name='CommitId', example='2'),
  copiedCount?: long(name='CopiedCount', example='900'),
  copiedSize?: long(name='CopiedSize', example='1000'),
  endTime?: string(name='EndTime', example='2024-05-01 12:00:00'),
  failedCount?: long(name='FailedCount', example='100'),
  jobVersion?: string(name='JobVersion', example='test_id'),
  listStatus?: string(name='ListStatus', example='Listing'),
  message?: string(name='Message'),
  name?: string(name='Name', example='test_name'),
  operator?: string(name='Operator', example='user'),
  runtimeId?: string(name='RuntimeId', example='1'),
  runtimeState?: string(name='RuntimeState', example='Normal'),
  startTime?: string(name='StartTime', example='2024-05-01 12:00:00'),
  status?: string(name='Status', example='IMPORT_JOB_DOING'),
  totalCount?: long(name='TotalCount', example='1000'),
  totalSize?: long(name='TotalSize', example='1000'),
}

model KeyFilterItem {
  regex?: [ string ](name='Regex'),
}

model KeyFilters {
  excludes?: KeyFilterItem(name='Excludes'),
  includes?: KeyFilterItem(name='Includes'),
}

model LastModifiedFilters {
  excludes?: LastModifyFilterItem(name='Excludes'),
  includes?: LastModifyFilterItem(name='Includes'),
}

model LastModifyFilterItem {
  timeFilter?: [
    TimeFilter
  ](name='TimeFilter'),
}

model ListAddressResp {
  importAddress?: [
    GetAddressResp
  ](name='ImportAddress'),
  nextMarker?: string(name='NextMarker', example='test_marker'),
  truncated?: boolean(name='Truncated', example='true'),
}

model ListAgentResp {
  importAgent?: [
    GetAgentResp
  ](name='ImportAgent'),
  nextMarker?: string(name='NextMarker', example='test_next_marker'),
  truncated?: boolean(name='Truncated', example='true'),
}

model ListJobHistoryResp {
  jobHistory?: [
    JobHistory
  ](name='JobHistory'),
  nextMarker?: string(name='NextMarker', example='test_next_marker'),
  truncated?: string(name='Truncated', example='true'),
}

model ListJobInfo {
  importJob?: [
    CreateJobInfo
  ](name='ImportJob'),
  nextMarker?: string(name='NextMarker', example='test_next_marker'),
  truncated?: boolean(name='Truncated', example='true'),
}

model ListJobResp {
  importJob?: [
    GetJobResp
  ](name='ImportJob'),
  nextMarker?: string(name='NextMarker'),
  truncated?: boolean(name='Truncated'),
}

model ListTunnelResp {
  importTunnel?: [
    GetTunnelResp
  ](name='ImportTunnel'),
  nextMarker?: string(name='NextMarker'),
  truncated?: boolean(name='Truncated'),
}

model ScheduleRule {
  maxScheduleCount?: long(name='MaxScheduleCount'),
  startCronExpression?: string(name='StartCronExpression'),
  suspendCronExpression?: string(name='SuspendCronExpression'),
}

model TimeFilter {
  endTime?: string(name='EndTime'),
  startTime?: string(name='StartTime'),
}

model TunnelQos {
  maxBandwidth?: long(name='MaxBandwidth', example='1073741824'),
  maxQps?: int32(name='MaxQps', example='100'),
}

model UpdateAddressInfo {
  agentList?: string(name='AgentList'),
}

model UpdateJobInfo {
  importQos?: ImportQos(name='ImportQos'),
  status?: string(name='Status', example='IMPORT_JOB_LAUNCHING'),
}

model UpdateTunnelInfo {
  tags?: string(name='Tags', example='k1=v1;k2=v2'),
  tunnelQos?: TunnelQos(name='TunnelQos'),
}

model VerifyAddressResp {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  status?: string(name='Status', example='avaliable'),
  verifyTime?: string(name='VerifyTime', example='2024-05-01 12:00:00'),
}

model VerifyResp {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  httpCode?: string(name='HttpCode', example='200'),
}

model CreateAddressRequest {
  importAddress?: CreateAddressInfo(name='ImportAddress', description='The details for creating the data address.'),
}

model CreateAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates a data address.
 *
 * @description *   To create a data address, you must have the permission on mgw:CreateImportAddress.
 * *   If you want to use an agent to migrate data, you must create an agent first and then associate the agent with a data address when you create the data address.
 *
 * @param request CreateAddressRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAddressResponse
 */
async function createAddressWithOptions(userid: string, request: CreateAddressRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAddressResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var body : map[string]any = {};
  if (!Util.isUnset(request.importAddress)) {
    body['ImportAddress'] = request.importAddress;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAddress',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/address`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates a data address.
 *
 * @description *   To create a data address, you must have the permission on mgw:CreateImportAddress.
 * *   If you want to use an agent to migrate data, you must create an agent first and then associate the agent with a data address when you create the data address.
 *
 * @param request CreateAddressRequest
 * @return CreateAddressResponse
 */
async function createAddress(userid: string, request: CreateAddressRequest): CreateAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAddressWithOptions(userid, request, headers, runtime);
}

model CreateAgentRequest {
  importAgent?: CreateAgentInfo(name='ImportAgent', description='The details for creating the agent.'),
}

model CreateAgentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary The request boy for creating the agent.
 *
 * @description *   To create an agent, you must have the permission on mgw:CreateImportAgent.
 * *   If you want to migrate data to Alibaba Cloud over an Express Connect circuit or a VPN gateway, or migrate data from a self-managed storage space to Alibaba Cloud, you can deploy an agent.
 * *   Before you create an agent, you must create a tunnel. An agent must be associated with a tunnel.
 *
 * @param request CreateAgentRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAgentResponse
 */
async function createAgentWithOptions(userid: string, request: CreateAgentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAgentResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var body : map[string]any = {};
  if (!Util.isUnset(request.importAgent)) {
    body['ImportAgent'] = request.importAgent;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAgent',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/agent`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

/**
 * @summary The request boy for creating the agent.
 *
 * @description *   To create an agent, you must have the permission on mgw:CreateImportAgent.
 * *   If you want to migrate data to Alibaba Cloud over an Express Connect circuit or a VPN gateway, or migrate data from a self-managed storage space to Alibaba Cloud, you can deploy an agent.
 * *   Before you create an agent, you must create a tunnel. An agent must be associated with a tunnel.
 *
 * @param request CreateAgentRequest
 * @return CreateAgentResponse
 */
async function createAgent(userid: string, request: CreateAgentRequest): CreateAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAgentWithOptions(userid, request, headers, runtime);
}

model CreateJobRequest {
  importJob?: CreateJobInfo(name='ImportJob', description='The details for creating the migration task.

This parameter is required.'),
}

model CreateJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates a migration task.
 *
 * @description *   To create a migration task, you must have the permission on mgw:CreateImportJob.
 * *   Before you create a migration task, you must create data addresses.
 * *   A migration task can run multiple rounds. Each round has an execution ID.
 *
 * @param request CreateJobRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateJobResponse
 */
async function createJobWithOptions(userid: string, request: CreateJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateJobResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var body : map[string]any = {};
  if (!Util.isUnset(request.importJob)) {
    body['ImportJob'] = request.importJob;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateJob',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/job`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates a migration task.
 *
 * @description *   To create a migration task, you must have the permission on mgw:CreateImportJob.
 * *   Before you create a migration task, you must create data addresses.
 * *   A migration task can run multiple rounds. Each round has an execution ID.
 *
 * @param request CreateJobRequest
 * @return CreateJobResponse
 */
async function createJob(userid: string, request: CreateJobRequest): CreateJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createJobWithOptions(userid, request, headers, runtime);
}

model CreateReportRequest {
  createReport?: CreateReportInfo(name='CreateReport', description='The details for creating the migration report.'),
}

model CreateReportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates a migration report.
 *
 * @description *   To create a migration report, you must have the permission on mgw:CreateImportReport.
 * *   If you specify that a migration report is to be generated when you create a migration task, you do not need to call this operation. If you do not specify that a migration report is to be generated when you create a migration task, you can call this operation to create a migration report for an execution with the specified ID.
 *
 * @param request CreateReportRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateReportResponse
 */
async function createReportWithOptions(userid: string, request: CreateReportRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateReportResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var body : map[string]any = {};
  if (!Util.isUnset(request.createReport)) {
    body['CreateReport'] = request.createReport;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateReport',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/report`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates a migration report.
 *
 * @description *   To create a migration report, you must have the permission on mgw:CreateImportReport.
 * *   If you specify that a migration report is to be generated when you create a migration task, you do not need to call this operation. If you do not specify that a migration report is to be generated when you create a migration task, you can call this operation to create a migration report for an execution with the specified ID.
 *
 * @param request CreateReportRequest
 * @return CreateReportResponse
 */
async function createReport(userid: string, request: CreateReportRequest): CreateReportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createReportWithOptions(userid, request, headers, runtime);
}

model CreateTunnelRequest {
  importTunnel?: CreateTunnelInfo(name='ImportTunnel', description='The details for creating the tunnel.'),
}

model CreateTunnelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates a tunnel.
 *
 * @description *   To create a tunnel, you must have the permission on mgw:CreateImportTunnel.
 * *   When you use an agent to migrate data, the agent must be associated with a tunnel.
 * *   A tunnel can be associated with multiple agents. You can throttle the traffic of the agents that are associated with the same tunnel by setting the bandwidth and the number of requests per second for the tunnel.
 *
 * @param request CreateTunnelRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTunnelResponse
 */
async function createTunnelWithOptions(userid: string, request: CreateTunnelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTunnelResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var body : map[string]any = {};
  if (!Util.isUnset(request.importTunnel)) {
    body['ImportTunnel'] = request.importTunnel;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTunnel',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/tunnel`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates a tunnel.
 *
 * @description *   To create a tunnel, you must have the permission on mgw:CreateImportTunnel.
 * *   When you use an agent to migrate data, the agent must be associated with a tunnel.
 * *   A tunnel can be associated with multiple agents. You can throttle the traffic of the agents that are associated with the same tunnel by setting the bandwidth and the number of requests per second for the tunnel.
 *
 * @param request CreateTunnelRequest
 * @return CreateTunnelResponse
 */
async function createTunnel(userid: string, request: CreateTunnelRequest): CreateTunnelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTunnelWithOptions(userid, request, headers, runtime);
}

model DeleteAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a data address.
 *
 * @description *   To delete a data address, you must have the permission on mgw:DeleteImportAddress.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAddressResponse
 */
async function deleteAddressWithOptions(userid: string, addressName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAddressResponse {
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteAddress',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/address/${addressName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a data address.
 *
 * @description *   To delete a data address, you must have the permission on mgw:DeleteImportAddress.
 *
 * @return DeleteAddressResponse
 */
async function deleteAddress(userid: string, addressName: string): DeleteAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAddressWithOptions(userid, addressName, headers, runtime);
}

model DeleteAgentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes an agent.
 *
 * @description *   To delete an agent, you must have the permission on mgw:DeleteImportAgent.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAgentResponse
 */
async function deleteAgentWithOptions(userid: string, agentName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAgentResponse {
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteAgent',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/agent/${agentName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes an agent.
 *
 * @description *   To delete an agent, you must have the permission on mgw:DeleteImportAgent.
 *
 * @return DeleteAgentResponse
 */
async function deleteAgent(userid: string, agentName: string): DeleteAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAgentWithOptions(userid, agentName, headers, runtime);
}

model DeleteJobRequest {
  forceDelete?: boolean(name='forceDelete', description='Specifies whether to force delete the subtask. If the task has subtasks and you set this parameter to true, the task and its subtasks are forcibly deleted. If this parameter is set to false, the task and its subtasks fail to be deleted.', example='true'),
}

model DeleteJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a migration task.
 *
 * @description *   To delete a migration task, you must have the permission on mgw:DeleteImportJob.
 * *   The operation to delete a migration task is asynchronous. The migration task remains in the Deleting state until it is deleted.
 *
 * @param request DeleteJobRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteJobResponse
 */
async function deleteJobWithOptions(userid: string, jobName: string, request: DeleteJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteJobResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var query : map[string]any = {};
  if (!Util.isUnset(request.forceDelete)) {
    query['forceDelete'] = request.forceDelete;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteJob',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/job/${jobName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a migration task.
 *
 * @description *   To delete a migration task, you must have the permission on mgw:DeleteImportJob.
 * *   The operation to delete a migration task is asynchronous. The migration task remains in the Deleting state until it is deleted.
 *
 * @param request DeleteJobRequest
 * @return DeleteJobResponse
 */
async function deleteJob(userid: string, jobName: string, request: DeleteJobRequest): DeleteJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteJobWithOptions(userid, jobName, request, headers, runtime);
}

model DeleteTunnelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a tunnel.
 *
 * @description *   To delete a tunnel, you must have the permission on mgw:DeleteImportTunnel.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTunnelResponse
 */
async function deleteTunnelWithOptions(userid: string, tunnelId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTunnelResponse {
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteTunnel',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/tunnel/${tunnelId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a tunnel.
 *
 * @description *   To delete a tunnel, you must have the permission on mgw:DeleteImportTunnel.
 *
 * @return DeleteTunnelResponse
 */
async function deleteTunnel(userid: string, tunnelId: string): DeleteTunnelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTunnelWithOptions(userid, tunnelId, headers, runtime);
}

model GetAddressResponseBody = {
  importAddress?: GetAddressResp(name='ImportAddress', description='The details for obtaining the data address.

Valid values:

*   1:1'),
}

model GetAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAddressResponseBody(name='body'),
}

/**
 * @summary Obtains the details of a data address.
 *
 * @description *   To query the information about a data address, you must have the permission on mgw:GetImportAddress.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAddressResponse
 */
async function getAddressWithOptions(userid: string, addressName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAddressResponse {
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAddress',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/address/${addressName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

/**
 * @summary Obtains the details of a data address.
 *
 * @description *   To query the information about a data address, you must have the permission on mgw:GetImportAddress.
 *
 * @return GetAddressResponse
 */
async function getAddress(userid: string, addressName: string): GetAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAddressWithOptions(userid, addressName, headers, runtime);
}

model GetAgentResponseBody = {
  importAgent?: GetAgentResp(name='ImportAgent', description='The details for obtaining the details of the agent.'),
}

model GetAgentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAgentResponseBody(name='body'),
}

/**
 * @summary Obtains the details of an agent.
 *
 * @description *   To query the information about an agent, you must have the permission on mgw:GetImportAgent.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAgentResponse
 */
async function getAgentWithOptions(userid: string, agentName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAgentResponse {
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAgent',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/agent/${agentName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

/**
 * @summary Obtains the details of an agent.
 *
 * @description *   To query the information about an agent, you must have the permission on mgw:GetImportAgent.
 *
 * @return GetAgentResponse
 */
async function getAgent(userid: string, agentName: string): GetAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAgentWithOptions(userid, agentName, headers, runtime);
}

model GetAgentStatusResponseBody = {
  importAgentStatus?: GetAgentStatusResp(name='ImportAgentStatus', description='The details for obtaining the status of the agent.'),
}

model GetAgentStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAgentStatusResponseBody(name='body'),
}

/**
 * @summary Obtains the running status of an agent.
 *
 * @description *   To query the status of an agent, you must have the permission on mgw:GetImportAgent.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAgentStatusResponse
 */
async function getAgentStatusWithOptions(userid: string, agentName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAgentStatusResponse {
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAgentStatus',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/agent/${agentName}?status`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

/**
 * @summary Obtains the running status of an agent.
 *
 * @description *   To query the status of an agent, you must have the permission on mgw:GetImportAgent.
 *
 * @return GetAgentStatusResponse
 */
async function getAgentStatus(userid: string, agentName: string): GetAgentStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAgentStatusWithOptions(userid, agentName, headers, runtime);
}

model GetJobRequest {
  byVersion?: string(name='byVersion', description='Specifies whether to obtain the details of the migration task by using the task ID.', example='false'),
}

model GetJobResponseBody = {
  importJob?: GetJobResp(name='ImportJob', description='The details for obtaining the details of the migration task.'),
}

model GetJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetJobResponseBody(name='body'),
}

/**
 * @summary Obtains the details of a migration task.
 *
 * @description *   To query the information about a migration task, you must have the permission on mgw:GetImportJob.
 *
 * @param request GetJobRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetJobResponse
 */
async function getJobWithOptions(userid: string, jobName: string, request: GetJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetJobResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var query : map[string]any = {};
  if (!Util.isUnset(request.byVersion)) {
    query['byVersion'] = request.byVersion;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJob',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/job/${jobName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

/**
 * @summary Obtains the details of a migration task.
 *
 * @description *   To query the information about a migration task, you must have the permission on mgw:GetImportJob.
 *
 * @param request GetJobRequest
 * @return GetJobResponse
 */
async function getJob(userid: string, jobName: string, request: GetJobRequest): GetJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getJobWithOptions(userid, jobName, request, headers, runtime);
}

model GetJobResultRequest {
  runtimeId?: int32(name='runtimeId', description='The execution ID of the task.

This parameter is required.', example='2'),
}

model GetJobResultResponseBody = {
  importJobResult?: GetJobResultResp(name='ImportJobResult', description='The details for obtaining the retries of the migration task.'),
}

model GetJobResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetJobResultResponseBody(name='body'),
}

/**
 * @summary Obtains the list of files that fail to be migrated when files fail to be migrated during a migration task.
 *
 * @description *   To query the retry information about a migration task, you must have the permission on mgw:GetImportJobResult.
 * *   If files fail to be migrated during a migration task, a list of files that fail to be migrated is generated. You can call this operation to query this list. You can create a data address based on this list and create a subtask. This way, you can migrate these files again.
 *
 * @param request GetJobResultRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetJobResultResponse
 */
async function getJobResultWithOptions(userid: string, jobName: string, request: GetJobResultRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetJobResultResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var query : map[string]any = {};
  if (!Util.isUnset(request.runtimeId)) {
    query['runtimeId'] = request.runtimeId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJobResult',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/job/${jobName}?jobResult`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

/**
 * @summary Obtains the list of files that fail to be migrated when files fail to be migrated during a migration task.
 *
 * @description *   To query the retry information about a migration task, you must have the permission on mgw:GetImportJobResult.
 * *   If files fail to be migrated during a migration task, a list of files that fail to be migrated is generated. You can call this operation to query this list. You can create a data address based on this list and create a subtask. This way, you can migrate these files again.
 *
 * @param request GetJobResultRequest
 * @return GetJobResultResponse
 */
async function getJobResult(userid: string, jobName: string, request: GetJobResultRequest): GetJobResultResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getJobResultWithOptions(userid, jobName, request, headers, runtime);
}

model GetReportRequest {
  runtimeId?: int32(name='runtimeId', description='The execution ID of the migration task.', example='1'),
  version?: string(name='version', description='The ID of the migration task.

This parameter is required.', example='test_job_id'),
}

model GetReportResponseBody = {
  getReportResponse?: GetReportResp(name='GetReportResponse', description='The details for obtaining the migration report.'),
}

model GetReportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetReportResponseBody(name='body'),
}

/**
 * @summary Obtains the details of a migration report.
 *
 * @description *   To query the information about a migration report, you must have the permission on mgw:GetImportReport.
 * *   The migration report is pushed to the destination data address. For more information, see the "View a migration report" section of the "Subsequent operations" topic in migration tutorials.
 *
 * @param request GetReportRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetReportResponse
 */
async function getReportWithOptions(userid: string, request: GetReportRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetReportResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var query : map[string]any = {};
  if (!Util.isUnset(request.runtimeId)) {
    query['runtimeId'] = request.runtimeId;
  }
  if (!Util.isUnset(request.version)) {
    query['version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetReport',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/report`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

/**
 * @summary Obtains the details of a migration report.
 *
 * @description *   To query the information about a migration report, you must have the permission on mgw:GetImportReport.
 * *   The migration report is pushed to the destination data address. For more information, see the "View a migration report" section of the "Subsequent operations" topic in migration tutorials.
 *
 * @param request GetReportRequest
 * @return GetReportResponse
 */
async function getReport(userid: string, request: GetReportRequest): GetReportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getReportWithOptions(userid, request, headers, runtime);
}

model GetTunnelResponseBody = {
  importTunnel?: GetTunnelResp(name='ImportTunnel', description='The details for obtaining the details of the tunnel.'),
}

model GetTunnelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTunnelResponseBody(name='body'),
}

/**
 * @summary Obtains the details of a tunnel.
 *
 * @description *   To query the information about a tunnel, you must have the permission on mgw:GetImportTunnel.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTunnelResponse
 */
async function getTunnelWithOptions(userid: string, tunnelId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTunnelResponse {
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetTunnel',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/tunnel/${tunnelId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

/**
 * @summary Obtains the details of a tunnel.
 *
 * @description *   To query the information about a tunnel, you must have the permission on mgw:GetImportTunnel.
 *
 * @return GetTunnelResponse
 */
async function getTunnel(userid: string, tunnelId: string): GetTunnelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTunnelWithOptions(userid, tunnelId, headers, runtime);
}

model ListAddressRequest {
  count?: int32(name='count', description='Specifies the number of migration addresses to be returned.\\\\
Valid values: 0 - 1000 (excluding 0).\\\\
Default value: 1000.', example='100'),
  marker?: string(name='marker', description='The marker after which the migration addresses are listed.\\\\
By default, this parameter is left empty.', example='test_marker'),
}

model ListAddressResponseBody = {
  importAddressList?: ListAddressResp(name='ImportAddressList', description='The details of migration addresses.'),
}

model ListAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAddressResponseBody(name='body'),
}

/**
 * @summary Lists the data addresses created by a user in the specific region.
 *
 * @description *   To query a list of data addresses, you must have the permission on mgw:ListImportAddress.
 *
 * @param request ListAddressRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAddressResponse
 */
async function listAddressWithOptions(userid: string, request: ListAddressRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAddressResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var query : map[string]any = {};
  if (!Util.isUnset(request.count)) {
    query['count'] = request.count;
  }
  if (!Util.isUnset(request.marker)) {
    query['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAddress',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/addresslist`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

/**
 * @summary Lists the data addresses created by a user in the specific region.
 *
 * @description *   To query a list of data addresses, you must have the permission on mgw:ListImportAddress.
 *
 * @param request ListAddressRequest
 * @return ListAddressResponse
 */
async function listAddress(userid: string, request: ListAddressRequest): ListAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAddressWithOptions(userid, request, headers, runtime);
}

model ListAgentRequest {
  count?: int32(name='count', description='Specifies the number of agents to be returned.\\\\
Valid values: 0 - 1000.\\\\
Default value: 1000.', example='100'),
  marker?: string(name='marker', description='The marker after which the agents are listed.\\\\
By default, this parameter is left empty.', example='test_agent'),
}

model ListAgentResponseBody = {
  importAgentList?: ListAgentResp(name='ImportAgentList', description='The details of the agents.'),
}

model ListAgentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAgentResponseBody(name='body'),
}

/**
 * @summary Lists the agents created by a user in the specific region.
 *
 * @description *   To query a list of agents, you must have the permission on mgw:ListImportAgent.
 *
 * @param request ListAgentRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAgentResponse
 */
async function listAgentWithOptions(userid: string, request: ListAgentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAgentResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var query : map[string]any = {};
  if (!Util.isUnset(request.count)) {
    query['count'] = request.count;
  }
  if (!Util.isUnset(request.marker)) {
    query['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAgent',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/agentlist`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

/**
 * @summary Lists the agents created by a user in the specific region.
 *
 * @description *   To query a list of agents, you must have the permission on mgw:ListImportAgent.
 *
 * @param request ListAgentRequest
 * @return ListAgentResponse
 */
async function listAgent(userid: string, request: ListAgentRequest): ListAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAgentWithOptions(userid, request, headers, runtime);
}

model ListJobRequest {
  all?: boolean(name='all', description='Specifies whether to return subtasks.\\\\
Valid values: true and false.', example='true'),
  count?: int32(name='count', description='Specifies the number of migration tasks to be returned.\\\\
Valid values: 0 - 1000 (excluding 0).\\\\
Default value: 1000.', example='1000'),
  marker?: string(name='marker', description='The marker after which the migration tasks are listed.\\\\
By default, this parameter is left empty.', example='test_marker'),
  parentName?: string(name='parentName', description='The name of the parent task. If this parameter is specified, all subtasks of the parent task are returned.', example='test_parent_job_name'),
}

model ListJobResponseBody = {
  importJobList?: ListJobResp(name='ImportJobList', description='The queried migration tasks.'),
}

model ListJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListJobResponseBody(name='body'),
}

/**
 * @summary Lists the migration tasks created by a user in the specific region.
 *
 * @description *   To query a list of migration tasks, you must have the permission on mgw:ListImportJob.
 *
 * @param request ListJobRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListJobResponse
 */
async function listJobWithOptions(userid: string, request: ListJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListJobResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var query : map[string]any = {};
  if (!Util.isUnset(request.all)) {
    query['all'] = request.all;
  }
  if (!Util.isUnset(request.count)) {
    query['count'] = request.count;
  }
  if (!Util.isUnset(request.marker)) {
    query['marker'] = request.marker;
  }
  if (!Util.isUnset(request.parentName)) {
    query['parentName'] = request.parentName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJob',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/joblist`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

/**
 * @summary Lists the migration tasks created by a user in the specific region.
 *
 * @description *   To query a list of migration tasks, you must have the permission on mgw:ListImportJob.
 *
 * @param request ListJobRequest
 * @return ListJobResponse
 */
async function listJob(userid: string, request: ListJobRequest): ListJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listJobWithOptions(userid, request, headers, runtime);
}

model ListJobHistoryRequest {
  count?: int32(name='count', description='Specifies the number of running records of the migration task to be returned.\\\\
Valid values: 0 - 1000.\\\\
Default value: 1000.', example='100'),
  marker?: string(name='marker', description='The marker after which the running history of the task is listed.\\\\
By default, this parameter is left empty.', example='test_marker'),
  runtimeId?: int32(name='runtimeId', description='The execution ID of the task. If you specify an execution ID, only the running history related to the execution ID is listed.', example='1'),
}

model ListJobHistoryResponseBody = {
  jobHistoryList?: ListJobHistoryResp(name='JobHistoryList', description='The running history of the migration task.'),
}

model ListJobHistoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListJobHistoryResponseBody(name='body'),
}

/**
 * @summary Lists the running history of a migration task.
 *
 * @description *   To query the execution history of a migration task, you must have the permission on mgw:ListImportJobHistory.
 * *   A migration task can run multiple rounds. A unique execution ID is generated for each round.
 * *   The execution history of a migration task records the change history of the task status.
 *
 * @param request ListJobHistoryRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListJobHistoryResponse
 */
async function listJobHistoryWithOptions(userid: string, jobName: string, request: ListJobHistoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListJobHistoryResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var query : map[string]any = {};
  if (!Util.isUnset(request.count)) {
    query['count'] = request.count;
  }
  if (!Util.isUnset(request.marker)) {
    query['marker'] = request.marker;
  }
  if (!Util.isUnset(request.runtimeId)) {
    query['runtimeId'] = request.runtimeId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJobHistory',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/jobhistory/${jobName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

/**
 * @summary Lists the running history of a migration task.
 *
 * @description *   To query the execution history of a migration task, you must have the permission on mgw:ListImportJobHistory.
 * *   A migration task can run multiple rounds. A unique execution ID is generated for each round.
 * *   The execution history of a migration task records the change history of the task status.
 *
 * @param request ListJobHistoryRequest
 * @return ListJobHistoryResponse
 */
async function listJobHistory(userid: string, jobName: string, request: ListJobHistoryRequest): ListJobHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listJobHistoryWithOptions(userid, jobName, request, headers, runtime);
}

model ListTunnelRequest {
  count?: int32(name='count', description='Specifies the number of tunnels to be returned.\\\\
Valid values: 0 - 1000.\\\\
Default value: 1000.', example='2'),
  marker?: string(name='marker', description='The marker after which tunnels are listed.\\\\
By default, this parameter is left empty.', example='1'),
}

model ListTunnelResponseBody = {
  importTunnelList?: ListTunnelResp(name='ImportTunnelList', description='The details of the tunnels.'),
}

model ListTunnelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTunnelResponseBody(name='body'),
}

/**
 * @summary Lists tunnels.
 *
 * @description *   To query a list of tunnels, you must have the permission on mgw:ListImportTunnel.
 *
 * @param request ListTunnelRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTunnelResponse
 */
async function listTunnelWithOptions(userid: string, request: ListTunnelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTunnelResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var query : map[string]any = {};
  if (!Util.isUnset(request.count)) {
    query['count'] = request.count;
  }
  if (!Util.isUnset(request.marker)) {
    query['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTunnel',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/tunnellist`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

/**
 * @summary Lists tunnels.
 *
 * @description *   To query a list of tunnels, you must have the permission on mgw:ListImportTunnel.
 *
 * @param request ListTunnelRequest
 * @return ListTunnelResponse
 */
async function listTunnel(userid: string, request: ListTunnelRequest): ListTunnelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTunnelWithOptions(userid, request, headers, runtime);
}

model UpdateAddressRequest {
  importAddress?: UpdateAddressInfo(name='ImportAddress', description='The details for updating the data address.'),
}

model UpdateAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates a data address.
 *
 * @description *   To update a data address, you must have the permission on mgw:UpdateImportAddress.
 * *   If the data address is associated with an agent, you can scale up or down the agent.
 *
 * @param request UpdateAddressRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAddressResponse
 */
async function updateAddressWithOptions(userid: string, addressName: string, request: UpdateAddressRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAddressResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var body : map[string]any = {};
  if (!Util.isUnset(request.importAddress)) {
    body['ImportAddress'] = request.importAddress;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAddress',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/address/${addressName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates a data address.
 *
 * @description *   To update a data address, you must have the permission on mgw:UpdateImportAddress.
 * *   If the data address is associated with an agent, you can scale up or down the agent.
 *
 * @param request UpdateAddressRequest
 * @return UpdateAddressResponse
 */
async function updateAddress(userid: string, addressName: string, request: UpdateAddressRequest): UpdateAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAddressWithOptions(userid, addressName, request, headers, runtime);
}

model UpdateJobRequest {
  importJob?: UpdateJobInfo(name='ImportJob', description='The details for updating the task.'),
}

model UpdateJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates the status or throttling of a task.
 *
 * @description *   To update a migration task, you must have the permission on mgw:UpdateImportJob.
 * *   You can update only the status or throttling settings of a task in a single request.
 *
 * @param request UpdateJobRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateJobResponse
 */
async function updateJobWithOptions(userid: string, jobName: string, request: UpdateJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateJobResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var body : map[string]any = {};
  if (!Util.isUnset(request.importJob)) {
    body['ImportJob'] = request.importJob;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateJob',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/job/${jobName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates the status or throttling of a task.
 *
 * @description *   To update a migration task, you must have the permission on mgw:UpdateImportJob.
 * *   You can update only the status or throttling settings of a task in a single request.
 *
 * @param request UpdateJobRequest
 * @return UpdateJobResponse
 */
async function updateJob(userid: string, jobName: string, request: UpdateJobRequest): UpdateJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateJobWithOptions(userid, jobName, request, headers, runtime);
}

model UpdateTunnelRequest {
  importTunnel?: UpdateTunnelInfo(name='ImportTunnel', description='The details for updating the tunnel.'),
}

model UpdateTunnelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates a tunnel.
 *
 * @description *   To update a tunnel, you must have the permission on mgw:UpdateImportTunnel.
 *
 * @param request UpdateTunnelRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTunnelResponse
 */
async function updateTunnelWithOptions(userid: string, tunnelId: string, request: UpdateTunnelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTunnelResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var body : map[string]any = {};
  if (!Util.isUnset(request.importTunnel)) {
    body['ImportTunnel'] = request.importTunnel;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTunnel',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/tunnel/${tunnelId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates a tunnel.
 *
 * @description *   To update a tunnel, you must have the permission on mgw:UpdateImportTunnel.
 *
 * @param request UpdateTunnelRequest
 * @return UpdateTunnelResponse
 */
async function updateTunnel(userid: string, tunnelId: string, request: UpdateTunnelRequest): UpdateTunnelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTunnelWithOptions(userid, tunnelId, request, headers, runtime);
}

model VerifyAddressResponseBody = {
  verifyAddressResponse?: VerifyAddressResp(name='VerifyAddressResponse', description=''),
}

model VerifyAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VerifyAddressResponseBody(name='body'),
}

/**
 * @summary Verifies whether a data address is available.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return VerifyAddressResponse
 */
async function verifyAddressWithOptions(userid: string, addressName: string, headers: map[string]string, runtime: Util.RuntimeOptions): VerifyAddressResponse {
  var hostMap : map[string]string = {};
  hostMap['userid'] = userid;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'VerifyAddress',
    version = '2024-06-26',
    protocol = 'HTTPS',
    pathname = `/address/${addressName}?verify`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

/**
 * @summary Verifies whether a data address is available.
 *
 * @return VerifyAddressResponse
 */
async function verifyAddress(userid: string, addressName: string): VerifyAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return verifyAddressWithOptions(userid, addressName, headers, runtime);
}

