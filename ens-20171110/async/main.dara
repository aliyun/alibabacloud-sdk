/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Ens';
  @version = '2017-11-10';
  @endpointRule = '';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model BucketInfo {
  bucketAcl?: string(name='BucketAcl', description='Bucket读写权限类型： public-read-write：公共读写 public-read：公共读 private：私有（默认值）'),
  bucketName: string(name='BucketName', description='Bucket名称。 3~50 个字符，只允许小写字母、数字、短横线（-），且不能以短横线开头或结尾。'),
  comment?: string(name='Comment', description='备注。 1-128个字符或汉字，UTF-8编码。'),
  createTime?: string(name='CreateTime', description='Bucket创建时间。 （格式：yyyy-mm-ddThh:mm:ss.timezone, 例如 2011-12-01T12:27:13.000Z）'),
  dataRedundancyType?: string(name='DataRedundancyType', description='指定Bucket的数据容灾类型。 取值范围： LRS（默认值）。本地冗余LRS ZRS 同城冗余ZRS采用多可用区（AZ）机制。'),
  dispatcherType?: string(name='DispatcherType', description='Bucket的调度类型： node：节点(同城) area：区域(多城市) global：全局(全国)'),
  endpoint?: string(name='Endpoint', description='访问域名，边缘存储取值： eos.aliyuncs.com'),
  ensRegionId?: string(name='EnsRegionId', description='节点区域id，如果为空表示全局'),
  modifyTime?: string(name='ModifyTime', description='Bucket修改时间。 （格式：yyyy-mm-ddThh:mm:ss.timezone, 例如 2011-12-01T12:27:13.000Z）'),
  resourceType?: string(name='ResourceType', description='指定Bucket的资源类型。 取值范围： general：通用 national-network：国网'),
  storageClass?: string(name='StorageClass', description='Bucket存储类型，支持Standard'),
}

model DataDisk {
  size?: long(name='Size', description='数据盘'),
}

model HealthCheck {
  healthCheck?: string(name='HealthCheck', description='是否开启健康检查。  取值：on | off。'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='健康检查的后端服务器的端口。  取值： 1~65535。    说明 在HealthCheck值为on时才会有效。', minimum=1, maximum=65535),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', description='每次健康检查响应的最大超时时间。  取值：1~300（秒）。  默认值：5。', minimum=1, maximum=300),
  healthCheckDomain?: string(name='HealthCheckDomain', description='用于健康检查的域名，取值：  $_ip： 后端服务器的私网IP。当指定了IP或该参数未指定时，负载均衡会使用各后端服务器的私网IP当做健康检查使用的域名。是否要支持？ domain：域名长度为1-80字符，只能包含字母、数字、点号（.）和连字符（-）。   说明 在HealthCheck值为on时才会有效。'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode', description='健康检查正常的HTTP状态码，多个状态码用逗号分隔。  默认值为http_2xx。  取值：http_2xx | http_3xx | http_4xx | http_5xx。   说明 在HealthCheck值为on时才会有效。'),
  healthCheckInterval?: int32(name='HealthCheckInterval', description='健康检查的时间间隔。  取值： 1~50（秒）。   说明 在HealthCheck值为on时才会有效。', minimum=1, maximum=50),
  healthCheckMethod?: string(name='HealthCheckMethod', description='健康检查的method'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout', description='接收来自运行状况检查的响应需要等待的时间。如果后端ECS在指定的时间内没有正确响应，则判定为健康检查失败。在HealthCheck值为on时才会有效。  取值：1~300（秒）。   说明 如果HealthCHeckTimeout的值小于HealthCheckInterval的值，则HealthCHeckTimeout无效，超时时间为HealthCheckInterval的值。', minimum=1, maximum=300),
  healthCheckType?: string(name='HealthCheckType', description='健康检查类型。  取值：tcp（默认值） | http。'),
  healthCheckURI?: string(name='HealthCheckURI', description='用于健康检查的URI。  长度限制为1~80，只能使用字母、数字和”-/.%?#&amp;“这些字符。 URL不能只为”/“，但必须以”/“开头。    说明 在HealthCheck值为on时才会有效。'),
  healthyThreshold?: int32(name='HealthyThreshold', description='健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success。  取值：2~10。    说明 在HealthCheck值为on时才会有效。', minimum=2, maximum=10),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', description='健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail。  取值：2~10。   说明 在HealthCheck值为on时才会有效。', minimum=2, maximum=10),
}

model HttpConfig {
  cookie?: string(name='Cookie', description='服务器上配置的Cookie。 长度为1-200，只能包含ASCII英文字母和数字字符，不能包含逗号、分号或空格，也不能以$开头。 说明 当StickySession为on且StickySessionType为server时，该参数必选。'),
  cookieTimeout?: int32(name='CookieTimeout', description='Cookie超时时间。  取值：1~86400（秒）。   说明 当StickySession为on且StickySessionType为insert时，该参数必选。', minimum=1, maximum=86400),
  idleTimeout?: int32(name='IdleTimeout', description='指定连接空闲超时时间，取值范围为1~60秒，默认值为15秒。  在超时时间内一直没有访问请求，负载均衡会暂时中断当前连接，直到一下次请求来临时重新建立新的连接。', minimum=1, maximum=60),
  requestTimeout?: int32(name='RequestTimeout', description='指定请求超时时间，取值范围为1~180秒，默认值为60秒。  在超时时间内后端服务器一直没有响应，负载均衡将放弃等待，给客户端返回 HTTP 504 错误码。', minimum=1, maximum=180),
  scheduler?: string(name='Scheduler', description='调度算法。取值：  wrr（默认值）：权重值越高的后端服务器，被轮询到的次数（概率）也越高。 wlc：除了根据每台后端服务器设定的权重值来进行轮询，同时还考虑后端服务器的实际负载（即连接数）。当权重值相同时，当前连接数越小的后端服务器被轮询到的次数（概率）也越高。 rr：按照访问顺序依次将外部请求依序分发到后端服务器。'),
  serverCertificateId?: string(name='ServerCertificateId', description='服务器证书的ID。'),
  stickySession?: string(name='StickySession', description='是否开启会话保持。  取值：on | off。'),
  stickySessionType?: string(name='StickySessionType', description='cookie的处理方式。取值：  insert：植入Cookie。  客户端第一次访问时，负载均衡会在返回请求中植入Cookie（即在HTTP/HTTPS响应报文中插入SERVERID），下次客户端携带此Cookie访问，负载均衡服务会将请求定向转发给之前记录到的后端服务器上。  server：重写Cookie。  负载均衡发现用户自定义了Cookie，将会对原来的Cookie进行重写，下次客户端携带新的Cookie访问，负载均衡服务会将请求定向转发给之前记录到的后端服务器。   说明 当StickySession的值为on时，必须指定该参数。'),
  xForwardedFor?: string(name='XForwardedFor', description='是否开启通过X-Forwarded-For头字段获取来访者真实 IP。  取值为on。'),
}

model SecurityGroupRule {
  description?: string(name='Description', description='描述'),
  destCidrIp?: string(name='DestCidrIp', description='目标网段'),
  direction?: string(name='Direction', description='方向'),
  ipProtocol?: string(name='IpProtocol', description='协议'),
  policy?: string(name='Policy', description='授权策略'),
  portRange?: string(name='PortRange', description='目的端口'),
  sourceCidrIp?: string(name='SourceCidrIp', description='源网段'),
  sourcePortRange?: string(name='SourcePortRange', description='源端口'),
  priority?: int32(name='priority', description='优先级', minimum=1, maximum=100),
}

model TcpConfig {
  establishedTimeout?: int32(name='EstablishedTimeout', description='连接超时时间。取值：10~900（秒）。', minimum=10, maximum=900),
  persistenceTimeout?: int32(name='PersistenceTimeout', description='会话保持的超时时间。取值：0~3600（秒）。默认值：0，表示关闭会话保持。', minimum=0, maximum=3600),
  scheduler?: string(name='Scheduler', description='调度算法。取值：wrr（默认值）：权重值越高的后端服务器，被轮询到的次数（概率）也越高。wlc：除了根据每台后端服务器设定的权重值来进行轮询，同时还考虑后端服务器的实际负载（即连接数）。当权重值相同时，当前连接数越小的后端服务器被轮询到的次数（概率）也越高。rr：按照访问顺序依次将外部请求依序分发到后端服务器。sch：基于源IP地址的一致性hash，相同的源地址会调度到相同的后端服务器。'),
}

model UdpCheck {
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='健康检查使用的端口。取值：1-65535  不设置此参数时，表示使用后端服务端口（BackendServerPort）。', minimum=1, maximum=65535),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', description='接收来自运行状况检查的响应需要等待的时间。  如果后端ENS在指定的时间内没有正确响应，则判定为健康检查失败。  取值：1-300（秒）。默认为5秒', minimum=1, maximum=300),
  healthCheckInterval?: int32(name='HealthCheckInterval', description='健康检查的时间间隔。  取值：1-50（秒）。', minimum=1, maximum=50),
  healthyThreshold?: int32(name='HealthyThreshold', description='健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success。  取值：2-10。', minimum=2, maximum=10),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', description='健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail。  取值：2-10。', minimum=2, maximum=10),
}

model UdpConfig {
  hashKey?: string(name='HashKey', description='hash key'),
  scheduler?: string(name='Scheduler', description='调度算法。取值：  wrr（默认值）：权重值越高的后端服务器，被轮询到的次数（概率）也越高。 wlc：除了根据每台后端服务器设定的权重值来进行轮询，同时还考虑后端服务器的实际负载（即连接数）。当权重值相同时，当前连接数越小的后端服务器被轮询到的次数（概率）也越高。 rr：按照访问顺序依次将外部请求依序分发到后端服务器。 sch：基于源IP地址的一致性hash，相同的源地址会调度到相同的后端服务器。'),
}

model AddBackendServersRequest {
  backendServers: [ 
    {
      ip?: string(name='Ip'),
      port?: int32(name='Port', description='端口', minimum=0, maximum=65535),
      serverId: string(name='ServerId'),
      type?: string(name='Type', description='后端服务器类型。  ens：ENS实例（默认）'),
      weight?: int32(name='Weight', description='后端服务器的权重。  取值：0~100  默认值为100，如果值为0，则不会将请求转发给该后端服务器。', minimum=0, maximum=100),
    }
  ](name='BackendServers', shrink='json', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
}

model AddBackendServersResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      ip?: string(name='Ip'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AddBackendServersResponse = {
  headers: map[string]string(name='headers'),
  body: AddBackendServersResponseBody(name='body'),
}

async function addBackendServers(request: AddBackendServersRequest): AddBackendServersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddBackendServers', 'POST', '/', 'json', false, 'json', request);
}

model AddDeviceInternetPortRequest {
  ISP?: string(name='ISP', position='Query'),
  instanceId: string(name='InstanceId', description='实例ID', position='Query'),
  internalIp: string(name='InternalIp', position='Query'),
  internalPort?: string(name='InternalPort', position='Query'),
  natType: string(name='NatType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model AddDeviceInternetPortResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  ruleIds?: [ string ](name='RuleIds', description='RuleIds'),
}

model AddDeviceInternetPortResponse = {
  headers: map[string]string(name='headers'),
  body: AddDeviceInternetPortResponseBody(name='body'),
}

async function addDeviceInternetPort(request: AddDeviceInternetPortRequest): AddDeviceInternetPortResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddDeviceInternetPort', 'GET', '/', 'json', false, 'json', request);
}

model AddNetworkInterfaceToInstanceRequest {
  autoStart?: boolean(name='AutoStart', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  networks: string(name='Networks', position='Query'),
}

model AddNetworkInterfaceToInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddNetworkInterfaceToInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: AddNetworkInterfaceToInstanceResponseBody(name='body'),
}

async function addNetworkInterfaceToInstance(request: AddNetworkInterfaceToInstanceRequest): AddNetworkInterfaceToInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddNetworkInterfaceToInstance', 'POST', '/', 'json', false, 'json', request);
}

model AssignPrivateIpAddressesRequest {
  networkInterfaceId: string(name='NetworkInterfaceId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
}

model AssignPrivateIpAddressesResponseBody = {
  assignedPrivateIpAddressesSet?: {
    networkInterfaceId?: string(name='NetworkInterfaceId'),
    privateIpSet?: [ string ](name='PrivateIpSet'),
  }(name='AssignedPrivateIpAddressesSet'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AssignPrivateIpAddressesResponse = {
  headers: map[string]string(name='headers'),
  body: AssignPrivateIpAddressesResponseBody(name='body'),
}

async function assignPrivateIpAddresses(request: AssignPrivateIpAddressesRequest): AssignPrivateIpAddressesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssignPrivateIpAddresses', 'POST', '/', 'json', false, 'json', request);
}

model AssociateEnsEipAddressRequest {
  allocationId: string(name='AllocationId', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
}

model AssociateEnsEipAddressResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AssociateEnsEipAddressResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateEnsEipAddressResponseBody(name='body'),
}

async function associateEnsEipAddress(request: AssociateEnsEipAddressRequest): AssociateEnsEipAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssociateEnsEipAddress', 'POST', '/', 'json', false, 'json', request);
}

model AttachDiskRequest {
  deleteWithInstance?: string(name='DeleteWithInstance', position='Query'),
  diskId: string(name='DiskId', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
}

model AttachDiskResponseBody = {
  code?: int32(name='Code'),
  requestId?: string(name='RequestId'),
}

model AttachDiskResponse = {
  headers: map[string]string(name='headers'),
  body: AttachDiskResponseBody(name='body'),
}

async function attachDisk(request: AttachDiskRequest): AttachDiskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AttachDisk', 'POST', '/', 'json', false, 'json', request);
}

model AttachEnsInstancesRequest {
  instanceId: string(name='InstanceId', position='Query'),
  scripts: string(name='Scripts', position='Query'),
}

model AttachEnsInstancesResponseBody = {
  requestId?: string(name='RequestId'),
}

model AttachEnsInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: AttachEnsInstancesResponseBody(name='body'),
}

async function attachEnsInstances(request: AttachEnsInstancesRequest): AttachEnsInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AttachEnsInstances', 'POST', '/', 'json', false, 'json', request);
}

model AuthorizeSecurityGroupRequest {
  ipProtocol: string(name='IpProtocol', position='Query'),
  policy?: string(name='Policy', position='Query'),
  portRange: string(name='PortRange', position='Query'),
  priority?: int32(name='Priority', minimum=1, maximum=100, position='Query'),
  securityGroupId: string(name='SecurityGroupId', position='Query'),
  sourceCidrIp: string(name='SourceCidrIp', position='Query'),
  sourcePortRange?: string(name='SourcePortRange', position='Query'),
  version: string(name='Version', position='Query'),
}

model AuthorizeSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model AuthorizeSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AuthorizeSecurityGroupResponseBody(name='body'),
}

async function authorizeSecurityGroup(request: AuthorizeSecurityGroupRequest): AuthorizeSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AuthorizeSecurityGroup', 'POST', '/', 'json', false, 'json', request);
}

model AuthorizeSecurityGroupEgressRequest {
  destCidrIp: string(name='DestCidrIp', position='Query'),
  ipProtocol: string(name='IpProtocol', position='Query'),
  policy?: string(name='Policy', position='Query'),
  portRange: string(name='PortRange', position='Query'),
  priority?: int32(name='Priority', minimum=1, maximum=100, position='Query'),
  securityGroupId: string(name='SecurityGroupId', position='Query'),
  sourcePortRange?: string(name='SourcePortRange', position='Query'),
  version: string(name='Version', position='Query'),
}

model AuthorizeSecurityGroupEgressResponseBody = {
  requestId?: string(name='RequestId'),
}

model AuthorizeSecurityGroupEgressResponse = {
  headers: map[string]string(name='headers'),
  body: AuthorizeSecurityGroupEgressResponseBody(name='body'),
}

async function authorizeSecurityGroupEgress(request: AuthorizeSecurityGroupEgressRequest): AuthorizeSecurityGroupEgressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AuthorizeSecurityGroupEgress', 'POST', '/', 'json', false, 'json', request);
}

model CreateARMServerInstancesRequest {
  amount: int32(name='Amount', description='数量，最大支持10', minimum=1, maximum=10, position='Query'),
  autoRenew?: boolean(name='AutoRenew', description='是否自动续费，默认为false。', position='Query'),
  ensRegionId: string(name='EnsRegionId', description='ENS节点ID。', position='Query'),
  frequency?: int32(name='Frequency', position='Query'),
  imageId: string(name='ImageId', description='镜像ID。', position='Query'),
  instanceType: string(name='InstanceType', description='AIC容器实例规格。', position='Query'),
  keyPairName?: string(name='KeyPairName', description='keypair名称', position='Query'),
  payType: string(name='PayType', description='付费类型。PrePaid（目前只支持此种）：包年包月', position='Query'),
  period: int32(name='Period', description='购买周期。', position='Query'),
  periodUnit: string(name='PeriodUnit', description='Month（默认）：按月计费的价格单位。', position='Query'),
  resolution?: string(name='Resolution', description='分辨率。目前取值
1920*1080
1280*720
1080*1920
720*1280', position='Query'),
  serverType: string(name='ServerType', description='服务器规格。', position='Query'),
}

model CreateARMServerInstancesResponseBody = {
  instanceIds?: [ string ](name='InstanceIds'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateARMServerInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: CreateARMServerInstancesResponseBody(name='body'),
}

async function createARMServerInstances(request: CreateARMServerInstancesRequest): CreateARMServerInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateARMServerInstances', 'POST', '/', 'json', false, 'json', request);
}

model CreateApplicationRequest {
  template: string(name='Template', position='Query'),
  timeout?: int32(name='Timeout', position='Query'),
}

model CreateApplicationResponseBody = {
  appId?: string(name='AppId'),
  requestId?: string(name='RequestId'),
}

model CreateApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: CreateApplicationResponseBody(name='body'),
}

async function createApplication(request: CreateApplicationRequest): CreateApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateApplication', 'POST', '/', 'json', false, 'json', request);
}

model CreateClassicNetworkRequest {
  cidrBlock: string(name='CidrBlock', position='Query'),
  description?: string(name='Description', position='Query'),
  ensRegionId: string(name='EnsRegionId', position='Query'),
  networkName?: string(name='NetworkName', position='Query'),
}

model CreateClassicNetworkResponseBody = {
  networkId?: string(name='NetworkId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateClassicNetworkResponse = {
  headers: map[string]string(name='headers'),
  body: CreateClassicNetworkResponseBody(name='body'),
}

async function createClassicNetwork(request: CreateClassicNetworkRequest): CreateClassicNetworkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateClassicNetwork', 'POST', '/', 'json', false, 'json', request);
}

model CreateDiskRequest {
  category: string(name='Category', description='磁盘种类 高效云盘:cloud_efficiency 全闪云盘:cloud_ssd', position='Query'),
  ensRegionId: string(name='EnsRegionId', description='节点ID', position='Query'),
  instanceChargeType: string(name='InstanceChargeType', description='实例付费方式，取值 PrePaid:预付费，包年包月 PostPaid:按量付费。目前只支持：PostPaid', position='Query'),
  size: string(name='Size', description='磁盘大小,单位GB', position='Query'),
}

model CreateDiskResponseBody = {
  instanceIds?: [ string ](name='InstanceIds', description='实列ID集合'),
  orderId?: string(name='OrderId', description='订单id,多个以逗号分割，可以直接跳转到收银行台 只有预付费返回订单号，后付费不返回'),
  requestId?: string(name='RequestId', description='请求唯一ID'),
}

model CreateDiskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDiskResponseBody(name='body'),
}

async function createDisk(request: CreateDiskRequest): CreateDiskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDisk', 'POST', '/', 'json', false, 'json', request);
}

model CreateEipInstanceRequest {
  bandwidth?: long(name='Bandwidth', description='EIP的带宽峰值', minimum=5, maximum=10000, position='Query'),
  ensRegionId: string(name='EnsRegionId', description='ENS节点ID', position='Query'),
  instanceChargeType: string(name='InstanceChargeType', description='EIP的计费方式，取值：  PrePaid：包年包月。 PostPaid（默认值）：按量计费。 当InstanceChargeType取值为PostPaid时，InternetChargeType不能为PayByBandwidth', position='Query'),
  internetChargeType: string(name='InternetChargeType', description='EIP的计量方式，取值：  PayByBandwidth（默认值）：按带宽计费。 取值：95BandwidthByMonth：月95。', position='Query'),
  isp?: string(name='Isp', description='运营商信息', position='Query'),
  name?: string(name='Name', description='EIP实例名称。', position='Query'),
}

model CreateEipInstanceResponseBody = {
  allocationId?: string(name='AllocationId', description='EIP的ID。'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateEipInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateEipInstanceResponseBody(name='body'),
}

async function createEipInstance(request: CreateEipInstanceRequest): CreateEipInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateEipInstance', 'POST', '/', 'json', false, 'json', request);
}

model CreateEnsRouteEntryRequest {
  description?: string(name='Description', description='自定义路由条目的描述信息。', minLength=2, maxLength=256, position='Query'),
  destinationCidrBlock: string(name='DestinationCidrBlock', description='自定义路由条目的目标网段。', position='Query'),
  nextHopId: string(name='NextHopId', description='自定义路由条目的下一跳实例的ID。', position='Query'),
  nextHopType?: string(name='NextHopType', description='自定义路由条目的下一跳的类型', position='Query'),
  routeEntryName?: string(name='RouteEntryName', description='要创建的自定义路由条目的名称。', minLength=2, maxLength=128, position='Query'),
  routeTableId: string(name='RouteTableId', description='要创建自定义路由条目的路由表ID。', position='Query'),
}

model CreateEnsRouteEntryResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  routeEntryId?: string(name='RouteEntryId', description='路由条目id。'),
}

model CreateEnsRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateEnsRouteEntryResponseBody(name='body'),
}

async function createEnsRouteEntry(request: CreateEnsRouteEntryRequest): CreateEnsRouteEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateEnsRouteEntry', 'POST', '/', 'json', false, 'json', request);
}

model CreateEnsServiceRequest {
  ensServiceId: string(name='EnsServiceId', position='Query'),
  orderType: string(name='OrderType', position='Query'),
  version: string(name='Version', position='Query'),
}

model CreateEnsServiceResponseBody = {
  code?: int32(name='Code'),
  requestId?: string(name='RequestId'),
}

model CreateEnsServiceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateEnsServiceResponseBody(name='body'),
}

async function createEnsService(request: CreateEnsServiceRequest): CreateEnsServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateEnsService', 'POST', '/', 'json', false, 'json', request);
}

model CreateEpnInstanceRequest {
  EPNInstanceName?: string(name='EPNInstanceName', position='Query'),
  EPNInstanceType: string(name='EPNInstanceType', position='Query'),
  internetChargeType: string(name='InternetChargeType', position='Query'),
  internetMaxBandwidthOut: int32(name='InternetMaxBandwidthOut', position='Query'),
  networkingModel: string(name='NetworkingModel', position='Query'),
}

model CreateEpnInstanceResponseBody = {
  EPNInstanceId?: string(name='EPNInstanceId'),
  requestId?: string(name='RequestId'),
}

model CreateEpnInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateEpnInstanceResponseBody(name='body'),
}

async function createEpnInstance(request: CreateEpnInstanceRequest): CreateEpnInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateEpnInstance', 'POST', '/', 'json', false, 'json', request);
}

model CreateForwardEntryRequest {
  externalIp: string(name='ExternalIp', position='Query'),
  externalPort: string(name='ExternalPort', position='Query'),
  forwardEntryName?: string(name='ForwardEntryName', maxLength=128, position='Query'),
  healthCheckPort?: int32(name='HealthCheckPort', minimum=1, maximum=65535, position='Query'),
  internalIp: string(name='InternalIp', position='Query'),
  internalPort: string(name='InternalPort', position='Query'),
  ipProtocol?: string(name='IpProtocol', position='Query'),
  natGatewayId: string(name='NatGatewayId', position='Query'),
}

model CreateForwardEntryResponseBody = {
  forwardEntryId?: string(name='ForwardEntryId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateForwardEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateForwardEntryResponseBody(name='body'),
}

async function createForwardEntry(request: CreateForwardEntryRequest): CreateForwardEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateForwardEntry', 'POST', '/', 'json', false, 'json', request);
}

model CreateImageRequest {
  deleteAfterImageUpload?: string(name='DeleteAfterImageUpload', position='Query'),
  imageName: string(name='ImageName', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  product?: string(name='product', position='Query'),
}

model CreateImageResponseBody = {
  code?: int32(name='Code'),
  imageId?: string(name='ImageId', description='镜像ID'),
  requestId?: string(name='RequestId'),
}

model CreateImageResponse = {
  headers: map[string]string(name='headers'),
  body: CreateImageResponseBody(name='body'),
}

async function createImage(request: CreateImageRequest): CreateImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateImage', 'POST', '/', 'json', false, 'json', request);
}

model CreateInstanceRequest {
  dataDisk?: [
    {
      size?: string(name='Size'),
    }
  ](name='DataDisk', position='Query'),
  systemDisk?: {
    size?: string(name='Size'),
  }(name='SystemDisk', position='Query'),
  autoRenew?: string(name='AutoRenew', position='Query'),
  autoRenewPeriod?: string(name='AutoRenewPeriod', position='Query'),
  ensRegionId: string(name='EnsRegionId', position='Query'),
  hostName?: string(name='HostName', position='Query'),
  imageId?: string(name='ImageId', position='Query'),
  instanceName?: string(name='InstanceName', position='Query'),
  instanceType: string(name='InstanceType', position='Query'),
  internetChargeType?: string(name='InternetChargeType', position='Query'),
  ipType?: string(name='IpType', position='Query'),
  keyPairName?: string(name='KeyPairName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  password?: string(name='Password', position='Query'),
  passwordInherit?: boolean(name='PasswordInherit', description='是否使用镜像预设的密码。使用该参数时，Password参数必须为空，同时您需要确保使用的镜像已经设置了密码。', position='Query'),
  paymentType?: string(name='PaymentType', position='Query'),
  period: string(name='Period', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', position='Query'),
  publicIpIdentification?: boolean(name='PublicIpIdentification', position='Query'),
  quantity: string(name='Quantity', position='Query'),
  uniqueSuffix?: boolean(name='UniqueSuffix', position='Query'),
  userData?: string(name='UserData', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
}

model CreateInstanceResponseBody = {
  code?: int32(name='Code'),
  instanceIds?: {
    instanceId?: [ string ](name='InstanceId')
  }(name='InstanceIds'),
  requestId?: string(name='RequestId'),
}

model CreateInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateInstanceResponseBody(name='body'),
}

async function createInstance(request: CreateInstanceRequest): CreateInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateInstance', 'POST', '/', 'json', false, 'json', request);
}

model CreateKeyPairRequest {
  keyPairName: string(name='KeyPairName', position='Query'),
  version: string(name='Version', position='Query'),
}

model CreateKeyPairResponseBody = {
  keyPairFingerPrint?: string(name='KeyPairFingerPrint'),
  keyPairId?: string(name='KeyPairId'),
  keyPairName?: string(name='KeyPairName'),
  privateKeyBody?: string(name='PrivateKeyBody'),
  requestId?: string(name='RequestId'),
}

model CreateKeyPairResponse = {
  headers: map[string]string(name='headers'),
  body: CreateKeyPairResponseBody(name='body'),
}

async function createKeyPair(request: CreateKeyPairRequest): CreateKeyPairResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateKeyPair', 'POST', '/', 'json', false, 'json', request);
}

model CreateLoadBalancerRequest {
  ensRegionId: string(name='EnsRegionId', description='ENS节点ID。', position='Query'),
  loadBalancerName?: string(name='LoadBalancerName', description='负载均衡实例的名称。', position='Query'),
  loadBalancerSpec: string(name='LoadBalancerSpec', description='负载均衡实例的名称。', position='Query'),
  networkId: string(name='NetworkId', description='要创建的ELB实例的网络ID', position='Query'),
  payType: string(name='PayType', description='付费类型。PostPaid（目前只支持此种）：按量付费', position='Query'),
  vSwitchId: string(name='VSwitchId', description='专有网络实例的所属的交换机ID。', position='Query'),
}

model CreateLoadBalancerResponseBody = {
  loadBalancerId?: string(name='LoadBalancerId'),
  loadBalancerName?: string(name='LoadBalancerName'),
  networkId?: string(name='NetworkId'),
  requestId?: string(name='RequestId'),
  vSwitchId?: string(name='VSwitchId'),
}

model CreateLoadBalancerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLoadBalancerResponseBody(name='body'),
}

async function createLoadBalancer(request: CreateLoadBalancerRequest): CreateLoadBalancerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLoadBalancer', 'POST', '/', 'json', false, 'json', request);
}

model CreateLoadBalancerHTTPListenerRequest {
  description?: string(name='Description', description='设置监听的描述信息。  长度限制为1-80个字符，允许包含字母、数字、“-”、“/”、“.”和“_”等字符。支持中文描述。', minLength=1, maxLength=80, position='Query'),
  forwardPort?: int32(name='ForwardPort', description='HTTP至HTTPS的监听转发端口。', minimum=0, maximum=65535, position='Query'),
  healthCheck: string(name='HealthCheck', description='是否开启健康检查。  取值：on | off。', position='Query'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='健康检查的后端服务器的端口。  取值： 1~65535。    说明 在HealthCheck值为on时才会有效。', minimum=1, maximum=65535, position='Query'),
  healthCheckDomain?: string(name='HealthCheckDomain', description='用于健康检查的域名，取值：  $_ip： 后端服务器的私网IP。当指定了IP或该参数未指定时，负载均衡会使用各后端服务器的私网IP当做健康检查使用的域名。是否要支持？ domain：域名长度为1-80字符，只能包含字母、数字、点号（.）和连字符（-）。   说明 在HealthCheck值为on时才会有效。', minLength=1, maxLength=80, position='Query'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode', description='健康检查正常的HTTP状态码，多个状态码用逗号分隔。  默认值为http_2xx。  取值：http_2xx | http_3xx | http_4xx | http_5xx。   说明 在HealthCheck值为on时才会有效。', position='Query'),
  healthCheckInterval?: int32(name='HealthCheckInterval', description='健康检查的时间间隔。  取值： 1~50（秒）。   说明 在HealthCheck值为on时才会有效。', minimum=1, maximum=50, position='Query'),
  healthCheckMethod?: string(name='HealthCheckMethod', position='Query'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout', description='接收来自运行状况检查的响应需要等待的时间。如果后端ECS在指定的时间内没有正确响应，则判定为健康检查失败。在HealthCheck值为on时才会有效。  取值：1~300（秒）。   说明 如果HealthCHeckTimeout的值小于HealthCheckInterval的值，则HealthCHeckTimeout无效，超时时间为HealthCheckInterval的值。', minimum=1, maximum=300, position='Query'),
  healthCheckURI?: string(name='HealthCheckURI', description='用于健康检查的URI。  长度限制为1~80，只能使用字母、数字和”-/.%?#&amp;“这些字符。 URL不能只为”/“，但必须以”/“开头。    说明 在HealthCheck值为on时才会有效。', minLength=1, maxLength=80, position='Query'),
  healthyThreshold?: int32(name='HealthyThreshold', description='健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success。  取值：2~10。    说明 在HealthCheck值为on时才会有效。', minimum=2, maximum=10, position='Query'),
  idleTimeout?: int32(name='IdleTimeout', description='指定连接空闲超时时间，取值范围为1~60秒，默认值为15秒。  在超时时间内一直没有访问请求，负载均衡会暂时中断当前连接，直到一下次请求来临时重新建立新的连接。', minimum=1, maximum=60, position='Query'),
  listenerForward?: string(name='ListenerForward', description='是否开启HTTP至HTTPS的转发。取值：on | off。', position='Query'),
  listenerPort: int32(name='ListenerPort', description='负载均衡实例前端使用的端口。  取值：1-65535。', minimum=1, maximum=65535, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', description='负载均衡实例的ID。', position='Query'),
  requestTimeout?: int32(name='RequestTimeout', description='指定请求超时时间，取值范围为1~180秒，默认值为60秒。  在超时时间内后端服务器一直没有响应，负载均衡将放弃等待，给客户端返回 HTTP 504 错误码。', minimum=1, maximum=180, position='Query'),
  scheduler?: string(name='Scheduler', description='调度算法。取值：  wrr（默认值）：权重值越高的后端服务器，被轮询到的次数（概率）也越高。 wlc：除了根据每台后端服务器设定的权重值来进行轮询，同时还考虑后端服务器的实际负载（即连接数）。当权重值相同时，当前连接数越小的后端服务器被轮询到的次数（概率）也越高。 rr：按照访问顺序依次将外部请求依序分发到后端服务器。', position='Query'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', description='健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail。  取值：2~10。   说明 在HealthCheck值为on时才会有效。', minimum=2, maximum=10, position='Query'),
  xForwardedFor?: string(name='XForwardedFor', description='是否开启通过X-Forwarded-For头字段获取来访者真实 IP。  取值为on。', position='Query'),
}

model CreateLoadBalancerHTTPListenerResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateLoadBalancerHTTPListenerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLoadBalancerHTTPListenerResponseBody(name='body'),
}

async function createLoadBalancerHTTPListener(request: CreateLoadBalancerHTTPListenerRequest): CreateLoadBalancerHTTPListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLoadBalancerHTTPListener', 'POST', '/', 'json', false, 'json', request);
}

model CreateLoadBalancerHTTPSListenerRequest {
  cookie?: string(name='Cookie', description='服务器上配置的Cookie。 长度为1-200，只能包含ASCII英文字母和数字字符，不能包含逗号、分号或空格，也不能以$开头。 说明 当StickySession为on且StickySessionType为server时，该参数必选。', position='Query'),
  cookieTimeout?: int32(name='CookieTimeout', description='Cookie超时时间。  取值：1~86400（秒）。   说明 当StickySession为on且StickySessionType为insert时，该参数必选。', minimum=1, maximum=86400, position='Query'),
  description?: string(name='Description', description='设置监听的描述信息。  长度限制为1-80个字符，允许包含字母、数字、“-”、“/”、“.”和“_”等字符。支持中文描述。', minLength=1, maxLength=80, position='Query'),
  forwardPort?: int32(name='ForwardPort', description='HTTP至HTTPS的监听转发端口。', minimum=1, maximum=65535, position='Query'),
  healthCheck: string(name='HealthCheck', description='是否开启健康检查。  取值：on | off。', position='Query'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='健康检查的后端服务器的端口。  取值： 1~65535。    说明 在HealthCheck值为on时才会有效。', minimum=1, maximum=65535, position='Query'),
  healthCheckDomain?: string(name='HealthCheckDomain', description='用于健康检查的域名，取值：  $_ip： 后端服务器的私网IP。当指定了IP或该参数未指定时，负载均衡会使用各后端服务器的私网IP当做健康检查使用的域名。是否要支持？ domain：域名长度为1-80字符，只能包含字母、数字、点号（.）和连字符（-）。   说明 在HealthCheck值为on时才会有效。', minLength=1, maxLength=80, position='Query'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode', description='健康检查正常的HTTP状态码，多个状态码用逗号分隔。  默认值为http_2xx。  取值：http_2xx | http_3xx | http_4xx | http_5xx。   说明 在HealthCheck值为on时才会有效。', position='Query'),
  healthCheckInterval?: int32(name='HealthCheckInterval', description='健康检查的时间间隔。  取值： 1~50（秒）。   说明 在HealthCheck值为on时才会有效。', minimum=1, maximum=50, position='Query'),
  healthCheckMethod?: string(name='HealthCheckMethod', position='Query'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout', description='接收来自运行状况检查的响应需要等待的时间。如果后端ECS在指定的时间内没有正确响应，则判定为健康检查失败。在HealthCheck值为on时才会有效。  取值：1~300（秒）。   说明 如果HealthCHeckTimeout的值小于HealthCheckInterval的值，则HealthCHeckTimeout无效，超时时间为HealthCheckInterval的值。', minimum=1, maximum=300, position='Query'),
  healthCheckURI?: string(name='HealthCheckURI', description='用于健康检查的URI。  长度限制为1~80，只能使用字母、数字和”-/.%?#&amp;“这些字符。 URL不能只为”/“，但必须以”/“开头。    说明 在HealthCheck值为on时才会有效。', minLength=1, maxLength=80, position='Query'),
  healthyThreshold?: int32(name='HealthyThreshold', description='健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success。  取值：2~10。    说明 在HealthCheck值为on时才会有效。', minimum=2, maximum=10, position='Query'),
  idleTimeout?: int32(name='IdleTimeout', description='指定连接空闲超时时间，取值范围为1~60秒，默认值为15秒。  在超时时间内一直没有访问请求，负载均衡会暂时中断当前连接，直到一下次请求来临时重新建立新的连接。', minimum=1, maximum=60, position='Query'),
  listenerForward?: string(name='ListenerForward', description='是否开启HTTP至HTTPS的转发。取值：on | off。', position='Query'),
  listenerPort: int32(name='ListenerPort', description='负载均衡实例前端使用的端口。  取值：1-65535。', minimum=1, maximum=65535, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', description='负载均衡实例的ID。', position='Query'),
  requestTimeout?: int32(name='RequestTimeout', description='指定请求超时时间，取值范围为1~180秒，默认值为60秒。  在超时时间内后端服务器一直没有响应，负载均衡将放弃等待，给客户端返回 HTTP 504 错误码。', minimum=1, maximum=180, position='Query'),
  scheduler?: string(name='Scheduler', description='调度算法。取值：  wrr（默认值）：权重值越高的后端服务器，被轮询到的次数（概率）也越高。 wlc：除了根据每台后端服务器设定的权重值来进行轮询，同时还考虑后端服务器的实际负载（即连接数）。当权重值相同时，当前连接数越小的后端服务器被轮询到的次数（概率）也越高。 rr：按照访问顺序依次将外部请求依序分发到后端服务器。', position='Query'),
  serverCertificateId: string(name='ServerCertificateId', description='服务器证书的ID。', position='Query'),
  stickySessionType?: string(name='StickySessionType', description='cookie的处理方式。取值：  insert：植入Cookie。  客户端第一次访问时，负载均衡会在返回请求中植入Cookie（即在HTTP/HTTPS响应报文中插入SERVERID），下次客户端携带此Cookie访问，负载均衡服务会将请求定向转发给之前记录到的后端服务器上。  server：重写Cookie。  负载均衡发现用户自定义了Cookie，将会对原来的Cookie进行重写，下次客户端携带新的Cookie访问，负载均衡服务会将请求定向转发给之前记录到的后端服务器。   说明 当StickySession的值为on时，必须指定该参数。', position='Query'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', description='健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail。  取值：2~10。   说明 在HealthCheck值为on时才会有效。', minimum=2, maximum=10, position='Query'),
}

model CreateLoadBalancerHTTPSListenerResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateLoadBalancerHTTPSListenerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLoadBalancerHTTPSListenerResponseBody(name='body'),
}

async function createLoadBalancerHTTPSListener(request: CreateLoadBalancerHTTPSListenerRequest): CreateLoadBalancerHTTPSListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLoadBalancerHTTPSListener', 'POST', '/', 'json', false, 'json', request);
}

model CreateLoadBalancerTCPListenerRequest {
  backendServerPort?: int32(name='BackendServerPort', description='负载均衡实例后端使用的端口，取值：1~65535', minimum=1, maximum=65535, position='Query'),
  description?: string(name='Description', description='设置监听的描述信息。  长度限制为1-80个字符，允许包含字母、数字、“-”、“/”、“.”和“_”等字符。支持中文描述。', minLength=1, maxLength=80, position='Query'),
  eipTransmit?: string(name='EipTransmit', position='Query'),
  establishedTimeout?: int32(name='EstablishedTimeout', description='连接超时时间。  取值：10~900（秒）。', minimum=10, maximum=900, position='Query'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='健康检查使用的端口。  取值：1~65535。  不设置此参数时，表示使用后端服务端口（BackendServerPort）。', minimum=1, maximum=65535, position='Query'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', description='每次健康检查响应的最大超时时间。  取值：1~300（秒）。  默认值：5。', minimum=1, maximum=300, position='Query'),
  healthCheckDomain?: string(name='HealthCheckDomain', description='用于健康检查的域名', minLength=1, maxLength=80, position='Query'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode', description='健康检查正常的HTTP状态码，多个状态码用逗号（,）分割。  取值：http_2xx（默认值） | http_3xx | http_4xx | http_5xx。', position='Query'),
  healthCheckInterval?: int32(name='HealthCheckInterval', description='健康检查的时间间隔。  取值：1~50（秒）。', minimum=1, maximum=50, position='Query'),
  healthCheckType?: string(name='HealthCheckType', description='健康检查类型。  取值：tcp（默认值） | http。', position='Query'),
  healthCheckURI?: string(name='HealthCheckURI', description='用于健康检查的URI。长度限制为1~80，只能使用字母、数字、短横线（-）、正斜杠（/）、点号（.）、百分号（%）、#和&amp;这些字符。 URL不能只为/，但必须以/开头。  当TCP监听需要使用HTTP健康检查时可配置此参数，如不配置则按TCP健康检查。', minLength=1, maxLength=80, position='Query'),
  healthyThreshold?: int32(name='HealthyThreshold', description='健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success。  取值： 2~10。', minimum=2, maximum=10, position='Query'),
  listenerPort: int32(name='ListenerPort', description='负载均衡实例前端使用的端口。  取值：1-65535。', minimum=1, maximum=65535, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', description='负载均衡实例的ID。', position='Query'),
  persistenceTimeout?: int32(name='PersistenceTimeout', description='会话保持的超时时间。  取值：0~3600（秒）。  默认值：0，表示关闭会话保持。', minimum=0, maximum=3600, position='Query'),
  scheduler?: string(name='Scheduler', description='度算法。取值：  wrr（默认值）：权重值越高的后端服务器，被轮询到的次数（概率）也越高。 wlc：除了根据每台后端服务器设定的权重值来进行轮询，同时还考虑后端服务器的实际负载（即连接数）。当权重值相同时，当前连接数越小的后端服务器被轮询到的次数（概率）也越高。 rr：按照访问顺序依次将外部请求依序分发到后端服务器。 sch：基于源IP地址的一致性hash，相同的源地址会调度到相同的后端服务器。', position='Query'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', description='健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail。  取值：2~10。', minimum=2, maximum=10, position='Query'),
}

model CreateLoadBalancerTCPListenerResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateLoadBalancerTCPListenerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLoadBalancerTCPListenerResponseBody(name='body'),
}

async function createLoadBalancerTCPListener(request: CreateLoadBalancerTCPListenerRequest): CreateLoadBalancerTCPListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLoadBalancerTCPListener', 'POST', '/', 'json', false, 'json', request);
}

model CreateLoadBalancerUDPListenerRequest {
  backendServerPort?: int32(name='BackendServerPort', description='负载均衡实例后端使用的端口，取值：1~65535', minimum=1, maximum=65535, position='Query'),
  description?: string(name='Description', description='设置监听的描述信息。  长度限制为1-80个字符，允许包含字母、数字、“-”、“/”、“.”和“_”等字符。支持中文描述。', minLength=1, maxLength=80, position='Query'),
  eipTransmit?: string(name='EipTransmit', position='Query'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='健康检查使用的端口。取值：1-65535  不设置此参数时，表示使用后端服务端口（BackendServerPort）', minimum=1, maximum=65535, position='Query'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', description='接收来自运行状况检查的响应需要等待的时间。  如果后端ENS在指定的时间内没有正确响应，则判定为健康检查失败。  取值：1-300（秒）。默认为5秒', minimum=1, maximum=300, position='Query'),
  healthCheckExp?: string(name='HealthCheckExp', description='UDP监听健康检查的响应串，只允许包含字母、数字，最大长度限制为64个字符。', maxLength=64, position='Query'),
  healthCheckInterval?: int32(name='HealthCheckInterval', description='健康检查的时间间隔。  取值：1-50（秒）。', minimum=1, maximum=50, position='Query'),
  healthCheckReq?: string(name='HealthCheckReq', description='UDP监听健康检查的请求串，只允许包含字母、数字，最大长度限制为64个字符。', maxLength=64, position='Query'),
  healthyThreshold?: int32(name='HealthyThreshold', description='健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success。  取值：2-10。', minimum=2, maximum=10, position='Query'),
  listenerPort: int32(name='ListenerPort', description='负载均衡实例前端使用的端口。  取值：1-65535。', minimum=1, maximum=65535, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', description='负载均衡实例的ID。', position='Query'),
  scheduler?: string(name='Scheduler', description='调度算法。取值：  wrr（默认值）：权重值越高的后端服务器，被轮询到的次数（概率）也越高。 wlc：除了根据每台后端服务器设定的权重值来进行轮询，同时还考虑后端服务器的实际负载（即连接数）。当权重值相同时，当前连接数越小的后端服务器被轮询到的次数（概率）也越高。 rr：按照访问顺序依次将外部请求依序分发到后端服务器。 sch：基于源IP地址的一致性hash，相同的源地址会调度到相同的后端服务器。', position='Query'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', description='健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail。  取值：2-10。', minimum=2, maximum=10, position='Query'),
}

model CreateLoadBalancerUDPListenerResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateLoadBalancerUDPListenerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLoadBalancerUDPListenerResponseBody(name='body'),
}

async function createLoadBalancerUDPListener(request: CreateLoadBalancerUDPListenerRequest): CreateLoadBalancerUDPListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLoadBalancerUDPListener', 'POST', '/', 'json', false, 'json', request);
}

model CreateNatGatewayRequest {
  ensRegionId: string(name='EnsRegionId', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  name?: string(name='Name', minLength=1, maxLength=128, position='Query'),
  networkId: string(name='NetworkId', position='Query'),
  vSwitchId: string(name='VSwitchId', position='Query'),
}

model CreateNatGatewayResponseBody = {
  natGatewayId?: string(name='NatGatewayId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateNatGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNatGatewayResponseBody(name='body'),
}

async function createNatGateway(request: CreateNatGatewayRequest): CreateNatGatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateNatGateway', 'POST', '/', 'json', false, 'json', request);
}

model CreateNetworkRequest {
  cidrBlock: string(name='CidrBlock', position='Query'),
  description?: string(name='Description', minLength=2, maxLength=256, position='Query'),
  ensRegionId: string(name='EnsRegionId', position='Query'),
  networkName?: string(name='NetworkName', minLength=2, maxLength=128, position='Query'),
}

model CreateNetworkResponseBody = {
  networkId?: string(name='NetworkId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateNetworkResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNetworkResponseBody(name='body'),
}

async function createNetwork(request: CreateNetworkRequest): CreateNetworkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateNetwork', 'POST', '/', 'json', false, 'json', request);
}

model CreateSecurityGroupRequest {
  description?: string(name='Description', position='Query'),
  securityGroupName?: string(name='SecurityGroupName', position='Query'),
  version: string(name='Version', position='Query'),
}

model CreateSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
  securityGroupId?: string(name='SecurityGroupId'),
}

model CreateSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSecurityGroupResponseBody(name='body'),
}

async function createSecurityGroup(request: CreateSecurityGroupRequest): CreateSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSecurityGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateSnatEntryRequest {
  natGatewayId: string(name='NatGatewayId', position='Query'),
  snatEntryName?: string(name='SnatEntryName', position='Query'),
  snatIp: string(name='SnatIp', position='Query'),
  sourceCIDR?: string(name='SourceCIDR', position='Query'),
  sourceNetworkId?: string(name='SourceNetworkId', position='Query'),
  sourceVSwitchId?: string(name='SourceVSwitchId', position='Query'),
}

model CreateSnatEntryResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  snatEntryId?: string(name='SnatEntryId'),
}

model CreateSnatEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSnatEntryResponseBody(name='body'),
}

async function createSnatEntry(request: CreateSnatEntryRequest): CreateSnatEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSnatEntry', 'POST', '/', 'json', false, 'json', request);
}

model CreateVSwitchRequest {
  cidrBlock: string(name='CidrBlock', position='Query'),
  description?: string(name='Description', position='Query'),
  ensRegionId: string(name='EnsRegionId', position='Query'),
  networkId?: string(name='NetworkId', position='Query'),
  vSwitchName?: string(name='VSwitchName', position='Query'),
}

model CreateVSwitchResponseBody = {
  requestId?: string(name='RequestId'),
  vSwitchId?: string(name='VSwitchId'),
}

model CreateVSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVSwitchResponseBody(name='body'),
}

async function createVSwitch(request: CreateVSwitchRequest): CreateVSwitchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVSwitch', 'POST', '/', 'json', false, 'json', request);
}

model DeleteApplicationRequest {
  appId: string(name='AppId', position='Query'),
  timeout?: int32(name='Timeout', position='Query'),
}

model DeleteApplicationResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteApplicationResponseBody(name='body'),
}

async function deleteApplication(request: DeleteApplicationRequest): DeleteApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteApplication', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDeviceInternetPortRequest {
  instanceId: string(name='InstanceId', description='InstanceId', position='Query'),
  natType: string(name='NatType', description='NatType', position='Query'),
  ruleId: string(name='RuleId', description='RuleId', position='Query'),
}

model DeleteDeviceInternetPortResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  ruleIds?: [ string ](name='RuleIds', description='RuleIds'),
}

model DeleteDeviceInternetPortResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDeviceInternetPortResponseBody(name='body'),
}

async function deleteDeviceInternetPort(request: DeleteDeviceInternetPortRequest): DeleteDeviceInternetPortResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDeviceInternetPort', 'GET', '/', 'json', false, 'json', request);
}

model DeleteEnsRouteEntryRequest {
  routeEntryId: string(name='RouteEntryId', description='要删除的路由条目ID。', position='Query'),
}

model DeleteEnsRouteEntryResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteEnsRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEnsRouteEntryResponseBody(name='body'),
}

async function deleteEnsRouteEntry(request: DeleteEnsRouteEntryRequest): DeleteEnsRouteEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteEnsRouteEntry', 'POST', '/', 'json', false, 'json', request);
}

model DeleteEpnInstanceRequest {
  EPNInstanceId: string(name='EPNInstanceId', position='Query'),
}

model DeleteEpnInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteEpnInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEpnInstanceResponseBody(name='body'),
}

async function deleteEpnInstance(request: DeleteEpnInstanceRequest): DeleteEpnInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteEpnInstance', 'POST', '/', 'json', false, 'json', request);
}

model DeleteForwardEntryRequest {
  forwardEntryId: string(name='ForwardEntryId', position='Query'),
}

model DeleteForwardEntryResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteForwardEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteForwardEntryResponseBody(name='body'),
}

async function deleteForwardEntry(request: DeleteForwardEntryRequest): DeleteForwardEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteForwardEntry', 'POST', '/', 'json', false, 'json', request);
}

model DeleteImageRequest {
  imageId: string(name='ImageId', position='Query'),
}

model DeleteImageResponseBody = {
  code?: int32(name='Code'),
  requestId?: string(name='RequestId'),
}

model DeleteImageResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteImageResponseBody(name='body'),
}

async function deleteImage(request: DeleteImageRequest): DeleteImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteImage', 'POST', '/', 'json', false, 'json', request);
}

model DeleteKeyPairsRequest {
  keyPairName: string(name='KeyPairName', position='Query'),
  version: string(name='Version', position='Query'),
}

model DeleteKeyPairsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteKeyPairsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteKeyPairsResponseBody(name='body'),
}

async function deleteKeyPairs(request: DeleteKeyPairsRequest): DeleteKeyPairsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteKeyPairs', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLoadBalancerListenerRequest {
  listenerPort: int32(name='ListenerPort', minimum=1, maximum=65535, position='Query'),
  listenerProtocol?: string(name='ListenerProtocol', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
}

model DeleteLoadBalancerListenerResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteLoadBalancerListenerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLoadBalancerListenerResponseBody(name='body'),
}

async function deleteLoadBalancerListener(request: DeleteLoadBalancerListenerRequest): DeleteLoadBalancerListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLoadBalancerListener', 'POST', '/', 'json', false, 'json', request);
}

model DeleteNatGatewayRequest {
  natGatewayId: string(name='NatGatewayId', position='Query'),
}

model DeleteNatGatewayResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteNatGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNatGatewayResponseBody(name='body'),
}

async function deleteNatGateway(request: DeleteNatGatewayRequest): DeleteNatGatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteNatGateway', 'POST', '/', 'json', false, 'json', request);
}

model DeleteNetworkRequest {
  networkId: string(name='NetworkId', position='Query'),
}

model DeleteNetworkResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteNetworkResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNetworkResponseBody(name='body'),
}

async function deleteNetwork(request: DeleteNetworkRequest): DeleteNetworkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteNetwork', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSecurityGroupRequest {
  securityGroupId: string(name='SecurityGroupId', position='Query'),
  version: string(name='Version', position='Query'),
}

model DeleteSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSecurityGroupResponseBody(name='body'),
}

async function deleteSecurityGroup(request: DeleteSecurityGroupRequest): DeleteSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSecurityGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSnatEntryRequest {
  snatEntryId: string(name='SnatEntryId', position='Query'),
}

model DeleteSnatEntryResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteSnatEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSnatEntryResponseBody(name='body'),
}

async function deleteSnatEntry(request: DeleteSnatEntryRequest): DeleteSnatEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSnatEntry', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVSwitchRequest {
  vSwitchId: string(name='VSwitchId', position='Query'),
  version: string(name='Version', position='Query'),
}

model DeleteVSwitchResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVSwitchResponseBody(name='body'),
}

async function deleteVSwitch(request: DeleteVSwitchRequest): DeleteVSwitchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVSwitch', 'POST', '/', 'json', false, 'json', request);
}

model DescribeARMServerInstancesRequest {
  ensRegionIds?: [ string ](name='EnsRegionIds', shrink='json', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  serverIds?: [ string ](name='ServerIds', shrink='json', position='Query'),
}

model DescribeARMServerInstancesResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  servers?: [ 
    {
      AICInstances?: [ 
        {
          frequency?: long(name='Frequency'),
          imageId?: string(name='ImageId'),
          instanceId?: string(name='InstanceId'),
          networkAttributes?: {
            ipAddress?: string(name='IpAddress'),
            networkId?: string(name='NetworkId'),
            vSwitchId?: string(name='VSwitchId'),
          }(name='NetworkAttributes'),
          resolution?: string(name='Resolution'),
          spec?: string(name='Spec'),
          state?: string(name='State'),
          status?: string(name='Status'),
        }
      ](name='AICInstances'),
      creationTime?: string(name='CreationTime'),
      ensRegionId?: string(name='EnsRegionId'),
      expiredTime?: string(name='ExpiredTime'),
      serverId?: string(name='ServerId'),
      specName?: string(name='SpecName'),
      state?: string(name='State'),
      status?: string(name='Status'),
    }
  ](name='Servers'),
}

model DescribeARMServerInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeARMServerInstancesResponseBody(name='body'),
}

async function describeARMServerInstances(request: DescribeARMServerInstancesRequest): DescribeARMServerInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeARMServerInstances', 'GET', '/', 'json', false, 'json', request);
}

model DescribeApplicationRequest {
  appId: string(name='AppId', position='Query'),
  appVersions?: string(name='AppVersions', position='Query'),
  level?: string(name='Level', position='Query'),
  outDetailStatParams?: string(name='OutDetailStatParams', position='Query'),
}

model DescribeApplicationResponseBody = {
  application?: string(name='Application'),
  requestId?: string(name='RequestId'),
}

model DescribeApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeApplicationResponseBody(name='body'),
}

async function describeApplication(request: DescribeApplicationRequest): DescribeApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeApplication', 'POST', '/', 'json', false, 'json', request);
}

model DescribeApplicationResourceSummaryRequest {
  level?: string(name='Level', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
}

model DescribeApplicationResourceSummaryResponseBody = {
  applicationResource?: string(name='ApplicationResource'),
  requestId?: string(name='RequestId'),
}

model DescribeApplicationResourceSummaryResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeApplicationResourceSummaryResponseBody(name='body'),
}

async function describeApplicationResourceSummary(request: DescribeApplicationResourceSummaryRequest): DescribeApplicationResourceSummaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeApplicationResourceSummary', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAvailableResourceRequest {
  version: string(name='Version', position='Query'),
}

model DescribeAvailableResourceResponseBody = {
  code?: int32(name='Code'),
  images?: {
    image?: [ 
    {
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
    }
  ](name='Image')
  }(name='Images'),
  requestId?: string(name='RequestId'),
  supportResources?: {
    supportResource?: [ 
    {
      dataDiskSize?: string(name='DataDiskSize'),
      ensRegionId?: string(name='EnsRegionId'),
      instanceSpec?: string(name='InstanceSpec'),
      supportResourcesCount?: string(name='SupportResourcesCount'),
      systemDiskSize?: string(name='SystemDiskSize'),
    }
  ](name='SupportResource')
  }(name='SupportResources'),
}

model DescribeAvailableResourceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAvailableResourceResponseBody(name='body'),
}

async function describeAvailableResource(request: DescribeAvailableResourceRequest): DescribeAvailableResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAvailableResource', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAvailableResourceInfoRequest {
  version: string(name='Version', position='Query'),
}

model DescribeAvailableResourceInfoResponseBody = {
  images?: {
    image?: [ 
    {
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
      imageSize?: int32(name='ImageSize'),
    }
  ](name='Image')
  }(name='Images'),
  requestId?: string(name='RequestId'),
  supportResources?: {
    supportResource?: [ 
    {
      bandwidthTypes?: {
        bandwidthType?: [ string ](name='BandwidthType')
      }(name='BandwidthTypes'),
      dataDiskMaxSize?: int32(name='DataDiskMaxSize'),
      dataDiskMinSize?: int32(name='DataDiskMinSize'),
      ensRegionIds?: {
        ensRegionId?: [ string ](name='EnsRegionId')
      }(name='EnsRegionIds'),
      ensRegionIdsExtends?: {
        ensRegionId?: [ 
        {
          area?: string(name='Area'),
          enName?: string(name='EnName'),
          ensRegionId?: string(name='EnsRegionId'),
          name?: string(name='Name'),
          province?: string(name='Province'),
        }
      ](name='EnsRegionId')
      }(name='EnsRegionIdsExtends'),
      instanceSpeces?: {
        instanceSpec?: [ string ](name='InstanceSpec')
      }(name='InstanceSpeces'),
      systemDiskMaxSize?: int32(name='SystemDiskMaxSize'),
      systemDiskMinSize?: int32(name='SystemDiskMinSize'),
    }
  ](name='SupportResource')
  }(name='SupportResources'),
}

model DescribeAvailableResourceInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAvailableResourceInfoResponseBody(name='body'),
}

async function describeAvailableResourceInfo(request: DescribeAvailableResourceInfoRequest): DescribeAvailableResourceInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAvailableResourceInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBandWithdChargeTypeRequest {
  version: string(name='Version', position='Query'),
}

model DescribeBandWithdChargeTypeResponseBody = {
  bandWithTypeInfo?: string(name='BandWithTypeInfo'),
  chargeContractType?: string(name='ChargeContractType'),
  chargeCycleInfo?: string(name='ChargeCycleInfo'),
  code?: int32(name='Code'),
  requestId?: string(name='RequestId'),
}

model DescribeBandWithdChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBandWithdChargeTypeResponseBody(name='body'),
}

async function describeBandWithdChargeType(request: DescribeBandWithdChargeTypeRequest): DescribeBandWithdChargeTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBandWithdChargeType', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBandwitdhByInternetChargeTypeRequest {
  endTime: string(name='EndTime', position='Query'),
  ensRegionId?: string(name='EnsRegionId', position='Query'),
  isp?: string(name='Isp', position='Query'),
  startTime: string(name='StartTime', position='Query'),
  version: string(name='Version', position='Query'),
}

model DescribeBandwitdhByInternetChargeTypeResponseBody = {
  bandwidthValue?: long(name='BandwidthValue'),
  internetChargeType?: string(name='InternetChargeType'),
  requestId?: string(name='RequestId'),
  timeStamp?: string(name='TimeStamp'),
}

model DescribeBandwitdhByInternetChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBandwitdhByInternetChargeTypeResponseBody(name='body'),
}

async function describeBandwitdhByInternetChargeType(request: DescribeBandwitdhByInternetChargeTypeRequest): DescribeBandwitdhByInternetChargeTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBandwitdhByInternetChargeType', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCloudDiskAvailableResourceInfoRequest {
}

model DescribeCloudDiskAvailableResourceInfoResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  supportResources?: {
    supportResource?: [ 
    {
      canBuyCount?: long(name='CanBuyCount'),
      category?: string(name='Category'),
      defaultDiskSize?: long(name='DefaultDiskSize'),
      diskMaxSize?: long(name='DiskMaxSize'),
      diskMinSize?: long(name='DiskMinSize'),
      ensRegionId?: string(name='EnsRegionId'),
      ensRegionName?: string(name='EnsRegionName'),
    }
  ](name='SupportResource')
  }(name='SupportResources'),
}

model DescribeCloudDiskAvailableResourceInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCloudDiskAvailableResourceInfoResponseBody(name='body'),
}

async function describeCloudDiskAvailableResourceInfo(request: DescribeCloudDiskAvailableResourceInfoRequest): DescribeCloudDiskAvailableResourceInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCloudDiskAvailableResourceInfo', 'GET', '/', 'json', false, 'json', request);
}

model DescribeCloudDiskTypesRequest {
  ensRegionId?: string(name='EnsRegionId', description='A short description of struct', position='Query'),
}

model DescribeCloudDiskTypesResponseBody = {
  requestId?: string(name='RequestId'),
  supportResources?: {
    supportResource?: [ 
    {
      category?: string(name='Category'),
      ensRegionId?: string(name='EnsRegionId'),
    }
  ](name='SupportResource')
  }(name='SupportResources'),
}

model DescribeCloudDiskTypesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCloudDiskTypesResponseBody(name='body'),
}

async function describeCloudDiskTypes(request: DescribeCloudDiskTypesRequest): DescribeCloudDiskTypesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCloudDiskTypes', 'GET', '/', 'json', false, 'json', request);
}

model DescribeCreatePrePaidInstanceResultRequest {
  instanceId: string(name='InstanceId', position='Query'),
  version: string(name='Version', position='Query'),
}

model DescribeCreatePrePaidInstanceResultResponseBody = {
  instanceCreateResult?: {
    instanceCreateStatus?: string(name='InstanceCreateStatus'),
    instanceId?: string(name='InstanceId'),
  }(name='InstanceCreateResult'),
  requestId?: string(name='RequestId'),
}

model DescribeCreatePrePaidInstanceResultResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCreatePrePaidInstanceResultResponseBody(name='body'),
}

async function describeCreatePrePaidInstanceResult(request: DescribeCreatePrePaidInstanceResultRequest): DescribeCreatePrePaidInstanceResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCreatePrePaidInstanceResult', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDataDistResultRequest {
  appId: string(name='AppId', position='Query'),
  dataNames?: string(name='DataNames', position='Query'),
  dataVersions?: string(name='DataVersions', position='Query'),
  instanceIds?: string(name='InstanceIds', position='Query'),
  maxDate?: string(name='MaxDate', position='Query'),
  minDate?: string(name='MinDate', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model DescribeDataDistResultResponseBody = {
  distResults?: {
    distResult?: [ 
    {
      name?: string(name='Name'),
      statusStats?: {
        statusStat?: [ 
        {
          instanceCount?: string(name='InstanceCount'),
          instances?: {
            instance?: [ 
            {
              instanceId?: string(name='InstanceId'),
              startTime?: string(name='StartTime'),
              statusDescrip?: string(name='StatusDescrip'),
              updateTime?: string(name='UpdateTime'),
            }
          ](name='Instance')
          }(name='Instances'),
          status?: string(name='Status'),
        }
      ](name='StatusStat')
      }(name='StatusStats'),
      version?: string(name='Version'),
    }
  ](name='DistResult')
  }(name='DistResults'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeDataDistResultResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDataDistResultResponseBody(name='body'),
}

async function describeDataDistResult(request: DescribeDataDistResultRequest): DescribeDataDistResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDataDistResult', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDataDownloadURLRequest {
  appId: string(name='AppId', position='Query'),
  dataName: string(name='DataName', position='Query'),
  dataVersion: string(name='DataVersion', position='Query'),
  expireTimeout?: long(name='ExpireTimeout', position='Query'),
  serverFilterStrategy?: string(name='ServerFilterStrategy', position='Query'),
}

model DescribeDataDownloadURLResponseBody = {
  code?: long(name='Code'),
  data?: {
    expireTime?: string(name='ExpireTime'),
    serverList?: [ 
      {
        host?: string(name='Host'),
        regionId?: string(name='RegionId'),
      }
    ](name='ServerList'),
    url?: string(name='Url'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DescribeDataDownloadURLResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDataDownloadURLResponseBody(name='body'),
}

async function describeDataDownloadURL(request: DescribeDataDownloadURLRequest): DescribeDataDownloadURLResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDataDownloadURL', 'GET', '/', 'json', false, 'json', request);
}

model DescribeDataPushResultRequest {
  appId: string(name='AppId', position='Query'),
  dataNames?: string(name='DataNames', position='Query'),
  dataVersions?: string(name='DataVersions', position='Query'),
  maxDate?: string(name='MaxDate', position='Query'),
  minDate?: string(name='MinDate', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionIds?: string(name='RegionIds', position='Query'),
}

model DescribeDataPushResultResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  pushResults?: {
    pushResult?: [ 
    {
      name?: string(name='Name'),
      statusStatS?: {
        statusStat?: [ 
        {
          regionIdCount?: int32(name='RegionIdCount'),
          regionIds?: {
            regionId?: [ 
            {
              regionId?: string(name='RegionId'),
              startTime?: string(name='StartTime'),
              statusDescrip?: string(name='StatusDescrip'),
              updateTime?: string(name='UpdateTime'),
            }
          ](name='RegionId')
          }(name='RegionIds'),
          status?: string(name='Status'),
        }
      ](name='StatusStat')
      }(name='StatusStatS'),
      version?: string(name='Version'),
    }
  ](name='PushResult')
  }(name='PushResults'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeDataPushResultResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDataPushResultResponseBody(name='body'),
}

async function describeDataPushResult(request: DescribeDataPushResultRequest): DescribeDataPushResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDataPushResult', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDeviceServiceRequest {
  appId?: string(name='AppId', position='Query'),
  ensRegionId?: string(name='EnsRegionId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  orderId?: string(name='OrderId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  serviceId?: string(name='ServiceId', description='Service ID', position='Query'),
}

model DescribeDeviceServiceResponseBody = {
  appMetaData?: {
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    appStableVersion?: string(name='AppStableVersion'),
    appType?: string(name='AppType'),
    clusterName?: string(name='ClusterName'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
  }(name='AppMetaData'),
  appStatus?: {
    phase?: string(name='Phase'),
    statusDescrip?: string(name='StatusDescrip'),
    updateTime?: string(name='UpdateTime'),
  }(name='AppStatus'),
  requestId?: string(name='RequestId', description='Id of the request'),
  resourceDetailInfos?: [ 
    {
      deviceName?: string(name='DeviceName'),
      id?: string(name='ID'),
      ip?: string(name='IP'),
      ISP?: string(name='ISP'),
      imageID?: string(name='ImageID'),
      mac?: string(name='Mac'),
      regionID?: string(name='RegionID'),
      server?: string(name='Server'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='ResourceDetailInfos'),
  resourceInfos?: [ 
    {
      appVersion?: string(name='AppVersion'),
      areaCode?: string(name='AreaCode'),
      areaName?: string(name='AreaName'),
      createTime?: string(name='CreateTime'),
      deviceInfos?: [ 
        {
          name?: string(name='Name'),
          network?: [ 
            {
              containerPorts?: string(name='ContainerPorts'),
              externalIp?: string(name='ExternalIp'),
              hostPorts?: string(name='HostPorts'),
              protocol?: string(name='Protocol'),
            }
          ](name='Network'),
          status?: string(name='Status'),
        }
      ](name='DeviceInfos'),
      instanceId?: string(name='InstanceId'),
      instanceStatus?: string(name='InstanceStatus'),
      internalIps?: [ 
        {
          ip?: string(name='Ip'),
        }
      ](name='InternalIps'),
      publicIps?: [ 
        {
          ip?: string(name='Ip'),
        }
      ](name='PublicIps'),
      regionCode?: string(name='RegionCode'),
      regionId?: string(name='RegionId'),
      regionName?: string(name='RegionName'),
    }
  ](name='ResourceInfos'),
}

model DescribeDeviceServiceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDeviceServiceResponseBody(name='body'),
}

async function describeDeviceService(request: DescribeDeviceServiceRequest): DescribeDeviceServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDeviceService', 'GET', '/', 'json', false, 'json', request);
}

model DescribeDisksRequest {
  category?: string(name='Category', position='Query'),
  diskChargeType?: string(name='DiskChargeType', position='Query'),
  diskId?: string(name='DiskId', position='Query'),
  diskIds?: string(name='DiskIds', position='Query'),
  diskName?: string(name='DiskName', position='Query'),
  diskType?: string(name='DiskType', position='Query'),
  ensRegionId?: string(name='EnsRegionId', position='Query'),
  ensRegionIds?: string(name='EnsRegionIds', position='Query'),
  orderByParams?: string(name='OrderByParams', position='Query'),
  pageNumber?: string(name='PageNumber', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  status?: string(name='Status', position='Query'),
  type?: string(name='Type', position='Query'),
}

model DescribeDisksResponseBody = {
  code?: int32(name='Code'),
  disks?: {
    disks?: [ 
    {
      category?: string(name='Category'),
      creationTime?: string(name='CreationTime'),
      diskChargeType?: string(name='DiskChargeType'),
      diskId?: string(name='DiskId'),
      diskName?: string(name='DiskName'),
      ensRegionId?: string(name='EnsRegionId'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      portable?: boolean(name='Portable'),
      size?: int32(name='Size'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='Disks')
  }(name='Disks'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeDisksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDisksResponseBody(name='body'),
}

async function describeDisks(request: DescribeDisksRequest): DescribeDisksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDisks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeEipAddressesRequest {
  eips?: string(name='Eips', position='Query'),
  ensRegionId: string(name='EnsRegionId', position='Query'),
  version: string(name='Version', position='Query'),
}

model DescribeEipAddressesResponseBody = {
  eipAddresses?: {
    eipAddress?: [ 
    {
      eip?: string(name='Eip'),
      instanceIdInternetIp?: string(name='InstanceIdInternetIp'),
    }
  ](name='EipAddress')
  }(name='EipAddresses'),
  requestId?: string(name='RequestId'),
}

model DescribeEipAddressesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEipAddressesResponseBody(name='body'),
}

async function describeEipAddresses(request: DescribeEipAddressesRequest): DescribeEipAddressesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEipAddresses', 'POST', '/', 'json', false, 'json', request);
}

model DescribeElbAvailableResourceInfoRequest {
}

model DescribeElbAvailableResourceInfoResponseBody = {
  elbAvailableResourceInfo?: [ 
    {
      area?: string(name='Area'),
      canBuyCount?: string(name='CanBuyCount'),
      enName?: string(name='EnName'),
      ensRegionId?: string(name='EnsRegionId'),
      loadBalancerSpec?: [ string ](name='LoadBalancerSpec'),
      name?: string(name='Name'),
      province?: string(name='Province'),
    }
  ](name='ElbAvailableResourceInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeElbAvailableResourceInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeElbAvailableResourceInfoResponseBody(name='body'),
}

async function describeElbAvailableResourceInfo(request: DescribeElbAvailableResourceInfoRequest): DescribeElbAvailableResourceInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeElbAvailableResourceInfo', 'GET', '/', 'json', false, 'json', request);
}

model DescribeEnsEipAddressesRequest {
  allocationId?: string(name='AllocationId', description='要查询的EIP实例的ID。  最多支持输入50个EIP实例ID，实例ID之间用逗号（,）分隔。', position='Query'),
  associatedInstanceId?: string(name='AssociatedInstanceId', position='Query'),
  associatedInstanceType?: string(name='AssociatedInstanceType', position='Query'),
  eipAddress?: string(name='EipAddress', description='要查询的EIP的IP地址。  最多支持输入50个EIP的IP地址，IP地址之间用逗号（,）分隔。', position='Query'),
  ensRegionId?: string(name='EnsRegionId', description='ENS节点ID', position='Query'),
  pageNumber?: int32(name='PageNumber', description='列表的页码，默认值为1。', position='Query'),
  pageSize?: int32(name='PageSize', description='分页查询时每页的行数，最大值为100，默认值为10。', maximum=100, position='Query'),
}

model DescribeEnsEipAddressesResponseBody = {
  eipAddresses?: {
    eipAddress?: [ 
    {
      allocationId?: string(name='AllocationId'),
      allocationTime?: string(name='AllocationTime'),
      bandwidth?: int32(name='Bandwidth'),
      chargeType?: string(name='ChargeType'),
      description?: string(name='Description'),
      ensRegionId?: string(name='EnsRegionId'),
      instanceId?: string(name='InstanceId'),
      instanceType?: string(name='InstanceType'),
      internetChargeType?: string(name='InternetChargeType'),
      ipAddress?: string(name='IpAddress'),
      isp?: string(name='Isp'),
      name?: string(name='Name'),
      status?: string(name='Status'),
    }
  ](name='EipAddress')
  }(name='EipAddresses'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeEnsEipAddressesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEnsEipAddressesResponseBody(name='body'),
}

async function describeEnsEipAddresses(request: DescribeEnsEipAddressesRequest): DescribeEnsEipAddressesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEnsEipAddresses', 'POST', '/', 'json', false, 'json', request);
}

model DescribeEnsNetDistrictRequest {
  netDistrictCode?: string(name='NetDistrictCode', position='Query'),
  netLevelCode: string(name='NetLevelCode', position='Query'),
  version: string(name='Version', position='Query'),
}

model DescribeEnsNetDistrictResponseBody = {
  code?: int32(name='Code'),
  ensNetDistricts?: {
    ensNetDistrict?: [ 
    {
      ensRegionIdCount?: string(name='EnsRegionIdCount'),
      netDistrictCode?: string(name='NetDistrictCode'),
      netDistrictEnName?: string(name='NetDistrictEnName'),
      netDistrictFatherCode?: string(name='NetDistrictFatherCode'),
      netDistrictLevel?: string(name='NetDistrictLevel'),
      netDistrictName?: string(name='NetDistrictName'),
    }
  ](name='EnsNetDistrict')
  }(name='EnsNetDistricts'),
  requestId?: string(name='RequestId'),
}

model DescribeEnsNetDistrictResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEnsNetDistrictResponseBody(name='body'),
}

async function describeEnsNetDistrict(request: DescribeEnsNetDistrictRequest): DescribeEnsNetDistrictResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEnsNetDistrict', 'POST', '/', 'json', false, 'json', request);
}

model DescribeEnsNetLevelRequest {
  version: string(name='Version', position='Query'),
}

model DescribeEnsNetLevelResponseBody = {
  code?: int32(name='Code'),
  ensNetLevels?: {
    ensNetLevel?: [ 
    {
      ensNetLevelCode?: string(name='EnsNetLevelCode'),
    }
  ](name='EnsNetLevel')
  }(name='EnsNetLevels'),
  requestId?: string(name='RequestId'),
}

model DescribeEnsNetLevelResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEnsNetLevelResponseBody(name='body'),
}

async function describeEnsNetLevel(request: DescribeEnsNetLevelRequest): DescribeEnsNetLevelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEnsNetLevel', 'POST', '/', 'json', false, 'json', request);
}

model DescribeEnsNetSaleDistrictRequest {
  netDistrictCode?: string(name='NetDistrictCode', position='Query'),
  netLevelCode: string(name='NetLevelCode', position='Query'),
  version: string(name='Version', position='Query'),
}

model DescribeEnsNetSaleDistrictResponseBody = {
  code?: int32(name='Code'),
  ensNetDistricts?: {
    ensNetDistrict?: [ 
    {
      ensRegionIdCount?: string(name='EnsRegionIdCount'),
      instanceCount?: string(name='InstanceCount'),
      netDistrictCode?: string(name='NetDistrictCode'),
      netDistrictEnName?: string(name='NetDistrictEnName'),
      netDistrictFatherCode?: string(name='NetDistrictFatherCode'),
      netDistrictLevel?: string(name='NetDistrictLevel'),
      netDistrictName?: string(name='NetDistrictName'),
    }
  ](name='EnsNetDistrict')
  }(name='EnsNetDistricts'),
  requestId?: string(name='RequestId'),
}

model DescribeEnsNetSaleDistrictResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEnsNetSaleDistrictResponseBody(name='body'),
}

async function describeEnsNetSaleDistrict(request: DescribeEnsNetSaleDistrictRequest): DescribeEnsNetSaleDistrictResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEnsNetSaleDistrict', 'POST', '/', 'json', false, 'json', request);
}

model DescribeEnsRegionIdIpv6InfoRequest {
  ensRegionId: string(name='EnsRegionId', position='Query'),
  version: string(name='Version', position='Query'),
}

model DescribeEnsRegionIdIpv6InfoResponseBody = {
  requestId?: string(name='RequestId'),
  supportIpv6Info?: {
    ensRegionId?: string(name='EnsRegionId'),
    supportIpv6?: boolean(name='SupportIpv6'),
  }(name='SupportIpv6Info'),
}

model DescribeEnsRegionIdIpv6InfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEnsRegionIdIpv6InfoResponseBody(name='body'),
}

async function describeEnsRegionIdIpv6Info(request: DescribeEnsRegionIdIpv6InfoRequest): DescribeEnsRegionIdIpv6InfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEnsRegionIdIpv6Info', 'POST', '/', 'json', false, 'json', request);
}

model DescribeEnsRegionIdResourceRequest {
  endTime: string(name='EndTime', position='Query'),
  isp?: string(name='Isp', position='Query'),
  orderByParams?: string(name='OrderByParams', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: string(name='PageSize', minimum=1, maximum=100, position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeEnsRegionIdResourceResponseBody = {
  ensRegionIdResources?: {
    ensRegionIdResource?: [ 
    {
      area?: string(name='Area'),
      areaCode?: string(name='AreaCode'),
      bizDate?: string(name='BizDate'),
      ensRegionId?: string(name='EnsRegionId'),
      ensRegionIdName?: string(name='EnsRegionIdName'),
      instanceCount?: int32(name='InstanceCount'),
      internetBandwidth?: long(name='InternetBandwidth'),
      isp?: string(name='Isp'),
      vCpu?: int32(name='VCpu'),
    }
  ](name='EnsRegionIdResource')
  }(name='EnsRegionIdResources'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeEnsRegionIdResourceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEnsRegionIdResourceResponseBody(name='body'),
}

async function describeEnsRegionIdResource(request: DescribeEnsRegionIdResourceRequest): DescribeEnsRegionIdResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEnsRegionIdResource', 'POST', '/', 'json', false, 'json', request);
}

model DescribeEnsRegionsRequest {
  ensRegionId?: string(name='EnsRegionId', position='Query'),
}

model DescribeEnsRegionsResponseBody = {
  code?: int32(name='Code'),
  ensRegions?: {
    ensRegions?: [ 
    {
      area?: string(name='Area'),
      enName?: string(name='EnName'),
      ensRegionId?: string(name='EnsRegionId'),
      name?: string(name='Name'),
      province?: string(name='Province'),
    }
  ](name='EnsRegions')
  }(name='EnsRegions'),
  requestId?: string(name='RequestId'),
}

model DescribeEnsRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEnsRegionsResponseBody(name='body'),
}

async function describeEnsRegions(request: DescribeEnsRegionsRequest): DescribeEnsRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEnsRegions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeEnsResourceUsageRequest {
  expiredEndTime?: string(name='ExpiredEndTime', description='vm实例使用结束时间查询结束范围，，格式： yyyy-MM-dd或yyyy-MM-dd HH:mm:ss', position='Query'),
  expiredStartTime?: string(name='ExpiredStartTime', description='vm实例使用结束时间查询开始范围，格式： yyyy-MM-dd或yyyy-MM-dd HH:mm:ss', position='Query'),
}

model DescribeEnsResourceUsageResponseBody = {
  ensResourceUsage?: [ 
    {
      computeResourceCount?: int32(name='ComputeResourceCount'),
      cpuSum?: long(name='CpuSum'),
      diskCount?: int32(name='DiskCount'),
      downCount?: int32(name='DownCount'),
      expiredCount?: int32(name='ExpiredCount'),
      expiringCount?: int32(name='ExpiringCount'),
      gpuSum?: long(name='GpuSum'),
      instanceCount?: int32(name='InstanceCount'),
      runningCount?: int32(name='RunningCount'),
      serviceType?: string(name='ServiceType'),
      storageSum?: long(name='StorageSum'),
    }
  ](name='EnsResourceUsage'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DescribeEnsResourceUsageResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEnsResourceUsageResponseBody(name='body'),
}

async function describeEnsResourceUsage(request: DescribeEnsResourceUsageRequest): DescribeEnsResourceUsageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEnsResourceUsage', 'GET', '/', 'json', false, 'json', request);
}

model DescribeEnsRouteEntryListRequest {
  destinationCidrBlock?: string(name='DestinationCidrBlock', description='路由条目的目标网段', position='Query'),
  nextHopId?: string(name='NextHopId', description='下一跳实例ID。', position='Query'),
  nextHopType?: string(name='NextHopType', description='下一跳类型', position='Query'),
  pageNumber?: int32(name='PageNumber', description='列表的页码，默认值为1。', position='Query'),
  pageSize?: int32(name='PageSize', description='分页查询时每页的行数，最大值为100，默认值为10。', maximum=100, position='Query'),
  routeEntryId?: string(name='RouteEntryId', description='要查询的路由条目的ID。', position='Query'),
  routeEntryName?: string(name='RouteEntryName', description='路由条目的名称。', position='Query'),
  routeEntryType?: string(name='RouteEntryType', description='路由条目的类型', position='Query'),
  routeTableId: string(name='RouteTableId', description='要查询的路由表的ID。', position='Query'),
}

model DescribeEnsRouteEntryListResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  routeEntrys?: [ 
    {
      description?: string(name='Description', description='路由条目的描述信息。'),
      destinationCidrBlock?: string(name='DestinationCidrBlock', description='路由条目的目标网段。'),
      nextHops?: [ 
        {
          nextHopId?: string(name='NextHopId', description='下一跳实例ID。'),
          nextHopType?: string(name='NextHopType', description='下一跳类型'),
        }
      ](name='NextHops', description='下一跳'),
      routeEntryId?: string(name='RouteEntryId', description='路由条目的ID。'),
      routeEntryName?: string(name='RouteEntryName', description='路由条目的名称。'),
      routeTableId?: string(name='RouteTableId', description='路由表ID。'),
      status?: string(name='Status', description='路由条目的状态'),
      type?: string(name='Type', description='路由条目的类型'),
    }
  ](name='RouteEntrys', description='路由条目信息。'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeEnsRouteEntryListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEnsRouteEntryListResponseBody(name='body'),
}

async function describeEnsRouteEntryList(request: DescribeEnsRouteEntryListRequest): DescribeEnsRouteEntryListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEnsRouteEntryList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeEpnBandWidthDataRequest {
  EPNInstanceId?: string(name='EPNInstanceId', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  ensRegionId?: string(name='EnsRegionId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  isp?: string(name='Isp', position='Query'),
  networkingModel?: string(name='NetworkingModel', position='Query'),
  period: string(name='Period', position='Query'),
  startTime: string(name='StartTime', position='Query'),
  version: string(name='Version', position='Query'),
}

model DescribeEpnBandWidthDataResponseBody = {
  monitorData?: {
    bandWidthMonitorData?: [ 
      {
        downBandWidth?: long(name='DownBandWidth'),
        internetRX?: long(name='InternetRX'),
        internetTX?: long(name='InternetTX'),
        timeStamp?: string(name='TimeStamp'),
        upBandWidth?: long(name='UpBandWidth'),
      }
    ](name='BandWidthMonitorData'),
    maxDownBandWidth?: long(name='MaxDownBandWidth'),
    maxUpBandWidth?: long(name='MaxUpBandWidth'),
  }(name='MonitorData'),
  requestId?: string(name='RequestId'),
}

model DescribeEpnBandWidthDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEpnBandWidthDataResponseBody(name='body'),
}

async function describeEpnBandWidthData(request: DescribeEpnBandWidthDataRequest): DescribeEpnBandWidthDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEpnBandWidthData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeEpnBandwitdhByInternetChargeTypeRequest {
  endTime: string(name='EndTime', position='Query'),
  ensRegionId?: string(name='EnsRegionId', position='Query'),
  isp?: string(name='Isp', position='Query'),
  networkingModel?: string(name='NetworkingModel', position='Query'),
  startTime: string(name='StartTime', position='Query'),
  version: string(name='Version', position='Query'),
}

model DescribeEpnBandwitdhByInternetChargeTypeResponseBody = {
  bandwidthValue?: long(name='BandwidthValue'),
  internetChargeType?: string(name='InternetChargeType'),
  requestId?: string(name='RequestId'),
  timeStamp?: string(name='TimeStamp'),
}

model DescribeEpnBandwitdhByInternetChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEpnBandwitdhByInternetChargeTypeResponseBody(name='body'),
}

async function describeEpnBandwitdhByInternetChargeType(request: DescribeEpnBandwitdhByInternetChargeTypeRequest): DescribeEpnBandwitdhByInternetChargeTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEpnBandwitdhByInternetChargeType', 'POST', '/', 'json', false, 'json', request);
}

model DescribeEpnInstanceAttributeRequest {
  EPNInstanceId: string(name='EPNInstanceId', position='Query'),
}

model DescribeEpnInstanceAttributeResponseBody = {
  confVersions?: [ 
    {
      confVersion?: string(name='ConfVersion'),
      ensRegionId?: string(name='EnsRegionId'),
    }
  ](name='ConfVersions'),
  EPNInstanceId?: string(name='EPNInstanceId'),
  EPNInstanceName?: string(name='EPNInstanceName'),
  instances?: [ 
    {
      ensRegionId?: string(name='EnsRegionId'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      isp?: string(name='Isp'),
      privateIpAddress?: string(name='PrivateIpAddress'),
      publicIpAddress?: string(name='PublicIpAddress'),
      status?: string(name='Status'),
    }
  ](name='Instances'),
  networkingModel?: string(name='NetworkingModel'),
  requestId?: string(name='RequestId'),
  vSwitches?: [ 
    {
      cidrBlock?: string(name='CidrBlock'),
      ensRegionId?: string(name='EnsRegionId'),
      vSwitchId?: string(name='VSwitchId'),
      vSwitchName?: string(name='VSwitchName'),
    }
  ](name='VSwitches'),
}

model DescribeEpnInstanceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEpnInstanceAttributeResponseBody(name='body'),
}

async function describeEpnInstanceAttribute(request: DescribeEpnInstanceAttributeRequest): DescribeEpnInstanceAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEpnInstanceAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeEpnInstancesRequest {
  EPNInstanceId?: string(name='EPNInstanceId', position='Query'),
  EPNInstanceName?: string(name='EPNInstanceName', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model DescribeEpnInstancesResponseBody = {
  EPNInstances?: {
    EPNInstance?: [ 
    {
      creationTime?: string(name='CreationTime'),
      EPNInstanceId?: string(name='EPNInstanceId'),
      EPNInstanceName?: string(name='EPNInstanceName'),
      EPNInstanceType?: string(name='EPNInstanceType'),
      endTime?: string(name='EndTime'),
      internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut'),
      modifyTime?: string(name='ModifyTime'),
      networkingModel?: string(name='NetworkingModel'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
    }
  ](name='EPNInstance')
  }(name='EPNInstances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeEpnInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEpnInstancesResponseBody(name='body'),
}

async function describeEpnInstances(request: DescribeEpnInstancesRequest): DescribeEpnInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEpnInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeEpnMeasurementDataRequest {
  endDate: string(name='EndDate', position='Query'),
  startDate: string(name='StartDate', position='Query'),
  version: string(name='Version', position='Query'),
}

model DescribeEpnMeasurementDataResponseBody = {
  measurementDatas?: {
    measurementData?: [ 
    {
      bandWidthFeeDatas?: {
        bandWidthFeeData?: [ 
        {
          costCode?: string(name='CostCode'),
          costName?: string(name='CostName'),
          costType?: string(name='CostType'),
          costVal?: int32(name='CostVal'),
          ispLine?: string(name='IspLine'),
        }
      ](name='BandWidthFeeData')
      }(name='BandWidthFeeDatas'),
      chargeModel?: string(name='ChargeModel'),
      costCycle?: string(name='CostCycle'),
      costEndTime?: string(name='CostEndTime'),
      costStartTime?: string(name='CostStartTime'),
    }
  ](name='MeasurementData')
  }(name='MeasurementDatas'),
  requestId?: string(name='RequestId'),
}

model DescribeEpnMeasurementDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEpnMeasurementDataResponseBody(name='body'),
}

async function describeEpnMeasurementData(request: DescribeEpnMeasurementDataRequest): DescribeEpnMeasurementDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEpnMeasurementData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeExportImageInfoRequest {
  imageId?: string(name='ImageId', position='Query'),
  imageName?: string(name='ImageName', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', maximum=50, position='Query'),
}

model DescribeExportImageInfoResponseBody = {
  images?: {
    image?: [ 
    {
      architecture?: string(name='Architecture'),
      creationTime?: string(name='CreationTime'),
      exportedImageURL?: string(name='ExportedImageURL'),
      imageExportStatus?: string(name='ImageExportStatus'),
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
      imageOwnerAlias?: string(name='ImageOwnerAlias'),
      platform?: string(name='Platform'),
    }
  ](name='Image')
  }(name='Images'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeExportImageInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeExportImageInfoResponseBody(name='body'),
}

async function describeExportImageInfo(request: DescribeExportImageInfoRequest): DescribeExportImageInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeExportImageInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeExportImageStatusRequest {
  imageId: string(name='ImageId', position='Query'),
  version: string(name='Version', position='Query'),
}

model DescribeExportImageStatusResponseBody = {
  imageExportStatus?: string(name='ImageExportStatus'),
  requestId?: string(name='RequestId'),
}

model DescribeExportImageStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeExportImageStatusResponseBody(name='body'),
}

async function describeExportImageStatus(request: DescribeExportImageStatusRequest): DescribeExportImageStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeExportImageStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeForwardTableEntriesRequest {
  externalIp?: string(name='ExternalIp', position='Query'),
  forwardEntryId?: string(name='ForwardEntryId', position='Query'),
  forwardEntryName?: string(name='ForwardEntryName', position='Query'),
  internalIp?: string(name='InternalIp', position='Query'),
  ipProtocol?: string(name='IpProtocol', position='Query'),
  natGatewayId: string(name='NatGatewayId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model DescribeForwardTableEntriesResponseBody = {
  forwardTableEntries?: [ 
    {
      externalIp?: string(name='ExternalIp'),
      externalPort?: string(name='ExternalPort'),
      forwardEntryId?: string(name='ForwardEntryId'),
      forwardEntryName?: string(name='ForwardEntryName'),
      healthCheckPort?: string(name='HealthCheckPort'),
      internalIp?: string(name='InternalIp'),
      internalPort?: string(name='InternalPort'),
      ipProtocol?: string(name='IpProtocol'),
      natGatewayId?: string(name='NatGatewayId'),
      status?: string(name='Status'),
    }
  ](name='ForwardTableEntries'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: string(name='TotalCount'),
}

model DescribeForwardTableEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeForwardTableEntriesResponseBody(name='body'),
}

async function describeForwardTableEntries(request: DescribeForwardTableEntriesRequest): DescribeForwardTableEntriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeForwardTableEntries', 'POST', '/', 'json', false, 'json', request);
}

model DescribeImageInfosRequest {
  osType?: string(name='OsType', position='Query'),
  version: string(name='Version', position='Query'),
}

model DescribeImageInfosResponseBody = {
  code?: int32(name='Code'),
  images?: {
    image?: [ 
    {
      description?: string(name='Description'),
      imageId?: string(name='ImageId'),
      imageSize?: string(name='ImageSize'),
      imageVersion?: string(name='ImageVersion'),
      OSName?: string(name='OSName'),
      OSType?: string(name='OSType'),
    }
  ](name='Image')
  }(name='Images'),
  requestId?: string(name='RequestId'),
}

model DescribeImageInfosResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImageInfosResponseBody(name='body'),
}

async function describeImageInfos(request: DescribeImageInfosRequest): DescribeImageInfosResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImageInfos', 'POST', '/', 'json', false, 'json', request);
}

model DescribeImageSharePermissionRequest {
  aliyunId?: long(name='AliyunId', position='Query'),
  imageId: string(name='ImageId', position='Query'),
  pageNumber?: string(name='PageNumber', position='Query'),
  pageSize?: string(name='PageSize', maximum=100, position='Query'),
}

model DescribeImageSharePermissionResponseBody = {
  accounts?: {
    account?: [ string ](name='Account')
  }(name='Accounts'),
  imageId?: string(name='ImageId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeImageSharePermissionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImageSharePermissionResponseBody(name='body'),
}

async function describeImageSharePermission(request: DescribeImageSharePermissionRequest): DescribeImageSharePermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImageSharePermission', 'POST', '/', 'json', false, 'json', request);
}

model DescribeImagesRequest {
  ensRegionId?: string(name='EnsRegionId', position='Query'),
  imageId?: string(name='ImageId', position='Query'),
  imageName?: string(name='ImageName', position='Query'),
  pageNumber?: string(name='PageNumber', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  status?: string(name='Status', position='Query'),
  version: string(name='Version', position='Query'),
  product?: string(name='product', position='Query'),
}

model DescribeImagesResponseBody = {
  code?: int32(name='Code'),
  images?: {
    image?: [ 
    {
      architecture?: string(name='Architecture'),
      creationTime?: string(name='CreationTime'),
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
      imageOwnerAlias?: string(name='ImageOwnerAlias'),
      imageSize?: string(name='ImageSize'),
      platform?: string(name='Platform'),
    }
  ](name='Image')
  }(name='Images'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeImagesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImagesResponseBody(name='body'),
}

async function describeImages(request: DescribeImagesRequest): DescribeImagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImages', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceAutoRenewAttributeRequest {
  instanceIds: string(name='InstanceIds', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  version: string(name='Version', position='Query'),
}

model DescribeInstanceAutoRenewAttributeResponseBody = {
  code?: int32(name='Code'),
  instanceRenewAttributes?: {
    instanceRenewAttribute?: [ 
    {
      autoRenewal?: boolean(name='AutoRenewal'),
      duration?: string(name='Duration'),
      instanceId?: string(name='InstanceId'),
    }
  ](name='InstanceRenewAttribute')
  }(name='InstanceRenewAttributes'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceAutoRenewAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceAutoRenewAttributeResponseBody(name='body'),
}

async function describeInstanceAutoRenewAttribute(request: DescribeInstanceAutoRenewAttributeRequest): DescribeInstanceAutoRenewAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceAutoRenewAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceMonitorDataRequest {
  endTime?: string(name='EndTime', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  period?: string(name='Period', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  version: string(name='Version', position='Query'),
}

model DescribeInstanceMonitorDataResponseBody = {
  code?: int32(name='Code'),
  monitorData?: {
    instanceMonitorData?: [ 
    {
      CPU?: string(name='CPU'),
      instanceId?: string(name='InstanceId'),
      memory?: string(name='Memory'),
    }
  ](name='InstanceMonitorData')
  }(name='MonitorData'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceMonitorDataResponseBody(name='body'),
}

async function describeInstanceMonitorData(request: DescribeInstanceMonitorDataRequest): DescribeInstanceMonitorDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceMonitorData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceSpecRequest {
  version: string(name='Version', position='Query'),
}

model DescribeInstanceSpecResponseBody = {
  bandwidthLimit?: int32(name='BandwidthLimit'),
  code?: int32(name='Code'),
  dataDiskMaxSize?: int32(name='DataDiskMaxSize'),
  dataDiskMinSize?: int32(name='DataDiskMinSize'),
  instanceSpecs?: {
    instanceSpec?: [ 
    {
      core?: string(name='Core'),
      displayName?: string(name='DisplayName'),
      instanceType?: string(name='InstanceType'),
      memory?: string(name='Memory'),
    }
  ](name='InstanceSpec')
  }(name='InstanceSpecs'),
  requestId?: string(name='RequestId'),
  systemDiskMaxSize?: int32(name='SystemDiskMaxSize'),
}

model DescribeInstanceSpecResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceSpecResponseBody(name='body'),
}

async function describeInstanceSpec(request: DescribeInstanceSpecRequest): DescribeInstanceSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceSpec', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceTypesRequest {
  version: string(name='Version', position='Query'),
}

model DescribeInstanceTypesResponseBody = {
  code?: int32(name='Code'),
  instanceTypes?: {
    instanceType?: [ 
    {
      cpuCoreCount?: int32(name='CpuCoreCount'),
      instanceTypeId?: string(name='InstanceTypeId'),
      instanceTypeName?: string(name='InstanceTypeName'),
      memorySize?: int32(name='MemorySize'),
    }
  ](name='InstanceType')
  }(name='InstanceTypes'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceTypesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceTypesResponseBody(name='body'),
}

async function describeInstanceTypes(request: DescribeInstanceTypesRequest): DescribeInstanceTypesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceTypes', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceVncUrlRequest {
  instanceId: string(name='InstanceId', description='实例ID。', position='Query'),
}

model DescribeInstanceVncUrlResponseBody = {
  requestId?: string(name='RequestId', description='请求ID。'),
  vncUrl?: string(name='VncUrl', description='管理终端Url。'),
}

model DescribeInstanceVncUrlResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceVncUrlResponseBody(name='body'),
}

async function describeInstanceVncUrl(request: DescribeInstanceVncUrlRequest): DescribeInstanceVncUrlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceVncUrl', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstancesRequest {
  ensRegionId?: string(name='EnsRegionId', position='Query'),
  ensRegionIds?: string(name='EnsRegionIds', position='Query'),
  ensServiceId?: string(name='EnsServiceId', position='Query'),
  imageId?: string(name='ImageId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  instanceIds?: string(name='InstanceIds', position='Query'),
  instanceName?: string(name='InstanceName', position='Query'),
  instanceResourceType?: string(name='InstanceResourceType', position='Query'),
  networkId?: string(name='NetworkId', position='Query'),
  orderByParams?: string(name='OrderByParams', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  searchKey?: string(name='SearchKey', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', position='Query'),
  status?: string(name='Status', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
}

model DescribeInstancesResponseBody = {
  code?: int32(name='Code'),
  instances?: {
    instance?: [ 
    {
      cpu?: string(name='Cpu'),
      creationTime?: string(name='CreationTime'),
      dataDisk?: {
        dataDisk?: [ 
        {
          category?: string(name='Category'),
          diskId?: string(name='DiskId'),
          diskName?: string(name='DiskName'),
          size?: int32(name='Size'),
          deviceType?: string(name='device_type'),
          diskType?: string(name='disk_type'),
          name?: string(name='name'),
          storage?: int32(name='storage'),
          uuid?: string(name='uuid'),
        }
      ](name='DataDisk')
      }(name='DataDisk'),
      disk?: int32(name='Disk'),
      ensRegionId?: string(name='EnsRegionId'),
      expiredTime?: string(name='ExpiredTime'),
      hostName?: string(name='HostName'),
      imageId?: string(name='ImageId'),
      innerIpAddress?: {
        ipAddress?: [ string ](name='IpAddress')
      }(name='InnerIpAddress'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      instanceResourceType?: string(name='InstanceResourceType'),
      internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn'),
      internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut'),
      memory?: int32(name='Memory'),
      networkAttributes?: {
        networkId?: string(name='NetworkId'),
        privateIpAddress?: {
          ipAddress?: [ string ](name='IpAddress')
        }(name='PrivateIpAddress'),
        vSwitchId?: string(name='VSwitchId'),
      }(name='NetworkAttributes'),
      OSName?: string(name='OSName'),
      privateIpAddresses?: {
        privateIpAddress?: [ 
        {
          gateWay?: string(name='GateWay'),
          ip?: string(name='Ip'),
          isp?: string(name='Isp'),
        }
      ](name='PrivateIpAddress')
      }(name='PrivateIpAddresses'),
      publicIpAddress?: {
        ipAddress?: [ string ](name='IpAddress')
      }(name='PublicIpAddress'),
      publicIpAddresses?: {
        publicIpAddress?: [ 
        {
          gateWay?: string(name='GateWay'),
          ip?: string(name='Ip'),
          isp?: string(name='Isp'),
        }
      ](name='PublicIpAddress')
      }(name='PublicIpAddresses'),
      securityGroupIds?: {
        securityGroupId?: [ string ](name='SecurityGroupId')
      }(name='SecurityGroupIds'),
      specName?: string(name='SpecName'),
      status?: string(name='Status'),
      systemDisk?: {
        category?: string(name='Category'),
        diskId?: string(name='DiskId'),
        diskName?: string(name='DiskName'),
        size?: int32(name='Size'),
        deviceType?: string(name='device_type'),
        diskType?: string(name='disk_type'),
        name?: string(name='name'),
        storage?: int32(name='storage'),
        uuid?: string(name='uuid'),
      }(name='SystemDisk'),
    }
  ](name='Instance')
  }(name='Instances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstancesResponseBody(name='body'),
}

async function describeInstances(request: DescribeInstancesRequest): DescribeInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeKeyPairsRequest {
  keyPairName?: string(name='KeyPairName', position='Query'),
  pageNumber?: string(name='PageNumber', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  version: string(name='Version', position='Query'),
}

model DescribeKeyPairsResponseBody = {
  keyPairs?: {
    keyPair?: [ 
    {
      creationTime?: string(name='CreationTime'),
      keyPairFingerPrint?: string(name='KeyPairFingerPrint'),
      keyPairName?: string(name='KeyPairName'),
    }
  ](name='KeyPair')
  }(name='KeyPairs'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeKeyPairsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeKeyPairsResponseBody(name='body'),
}

async function describeKeyPairs(request: DescribeKeyPairsRequest): DescribeKeyPairsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeKeyPairs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLoadBalancerAttributeRequest {
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
}

model DescribeLoadBalancerAttributeResponseBody = {
  address?: string(name='Address'),
  addressIPVersion?: string(name='AddressIPVersion'),
  backendServers?: [ 
    {
      ip?: string(name='Ip'),
      port?: string(name='Port'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='BackendServers'),
  bandwidth?: int32(name='Bandwidth'),
  createTime?: string(name='CreateTime'),
  endTime?: string(name='EndTime'),
  ensRegionId?: string(name='EnsRegionId'),
  listenerPorts?: [ string ](name='ListenerPorts'),
  listenerPortsAndProtocols?: [ 
    {
      description?: string(name='Description'),
      forwardPort?: int32(name='ForwardPort'),
      listenerForward?: string(name='ListenerForward'),
      listenerPort?: int32(name='ListenerPort'),
      listenerProtocol?: string(name='ListenerProtocol'),
    }
  ](name='ListenerPortsAndProtocols'),
  loadBalancerId?: string(name='LoadBalancerId'),
  loadBalancerName?: string(name='LoadBalancerName'),
  loadBalancerSpec?: string(name='LoadBalancerSpec'),
  loadBalancerStatus?: string(name='LoadBalancerStatus'),
  networkId?: string(name='NetworkId'),
  payType?: string(name='PayType'),
  requestId?: string(name='RequestId', description='Id of the request'),
  vSwitchId?: string(name='VSwitchId'),
}

model DescribeLoadBalancerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerAttribute(request: DescribeLoadBalancerAttributeRequest): DescribeLoadBalancerAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLoadBalancerAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLoadBalancerHTTPListenerAttributeRequest {
  listenerPort: int32(name='ListenerPort', minimum=0, maximum=65535, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
}

model DescribeLoadBalancerHTTPListenerAttributeResponseBody = {
  bandwidth?: int32(name='Bandwidth'),
  description?: string(name='Description'),
  forwardPort?: int32(name='ForwardPort'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckMethod?: string(name='HealthCheckMethod'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  idleTimeout?: int32(name='IdleTimeout'),
  listenerForward?: string(name='ListenerForward'),
  listenerPort?: int32(name='ListenerPort'),
  requestId?: string(name='RequestId', description='Id of the request'),
  requestTimeout?: int32(name='RequestTimeout'),
  scheduler?: string(name='Scheduler'),
  serverCertificateId?: string(name='ServerCertificateId'),
  status?: string(name='Status'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
}

model DescribeLoadBalancerHTTPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancerHTTPListenerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerHTTPListenerAttribute(request: DescribeLoadBalancerHTTPListenerAttributeRequest): DescribeLoadBalancerHTTPListenerAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLoadBalancerHTTPListenerAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLoadBalancerHTTPSListenerAttributeRequest {
  listenerPort: int32(name='ListenerPort', minimum=0, maximum=65535, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
}

model DescribeLoadBalancerHTTPSListenerAttributeResponseBody = {
  bandwidth?: int32(name='Bandwidth'),
  description?: string(name='Description'),
  forwardPort?: int32(name='ForwardPort'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckMethod?: string(name='HealthCheckMethod'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  idleTimeout?: int32(name='IdleTimeout'),
  listenerForward?: string(name='ListenerForward'),
  listenerPort?: int32(name='ListenerPort'),
  requestId?: string(name='RequestId', description='Id of the request'),
  requestTimeout?: int32(name='RequestTimeout'),
  scheduler?: string(name='Scheduler'),
  serverCertificateId?: string(name='ServerCertificateId'),
  status?: string(name='Status'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
}

model DescribeLoadBalancerHTTPSListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancerHTTPSListenerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerHTTPSListenerAttribute(request: DescribeLoadBalancerHTTPSListenerAttributeRequest): DescribeLoadBalancerHTTPSListenerAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLoadBalancerHTTPSListenerAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLoadBalancerSpecRequest {
  loadBalancerSpec?: string(name='LoadBalancerSpec', position='Query'),
}

model DescribeLoadBalancerSpecResponseBody = {
  loadBalancerSpecs?: [ 
    {
      displayName?: string(name='DisplayName'),
      loadBalancerSpec?: string(name='LoadBalancerSpec'),
    }
  ](name='LoadBalancerSpecs'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeLoadBalancerSpecResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancerSpecResponseBody(name='body'),
}

async function describeLoadBalancerSpec(request: DescribeLoadBalancerSpecRequest): DescribeLoadBalancerSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLoadBalancerSpec', 'GET', '/', 'json', false, 'json', request);
}

model DescribeLoadBalancerTCPListenerAttributeRequest {
  listenerPort: int32(name='ListenerPort', minimum=0, maximum=65535, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
}

model DescribeLoadBalancerTCPListenerAttributeResponseBody = {
  backendServerPort?: int32(name='BackendServerPort'),
  bandwidth?: int32(name='Bandwidth'),
  description?: string(name='Description'),
  eipTransmit?: string(name='EipTransmit'),
  establishedTimeout?: int32(name='EstablishedTimeout'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckType?: string(name='HealthCheckType'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  listenerPort?: int32(name='ListenerPort'),
  persistenceTimeout?: int32(name='PersistenceTimeout'),
  requestId?: string(name='RequestId', description='Id of the request'),
  scheduler?: string(name='Scheduler'),
  status?: string(name='Status'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
}

model DescribeLoadBalancerTCPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancerTCPListenerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerTCPListenerAttribute(request: DescribeLoadBalancerTCPListenerAttributeRequest): DescribeLoadBalancerTCPListenerAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLoadBalancerTCPListenerAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLoadBalancerUDPListenerAttributeRequest {
  listenerPort: int32(name='ListenerPort', minimum=0, maximum=65535, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
}

model DescribeLoadBalancerUDPListenerAttributeResponseBody = {
  backendServerPort?: int32(name='BackendServerPort'),
  bandwidth?: int32(name='Bandwidth'),
  description?: string(name='Description'),
  eipTransmit?: string(name='EipTransmit'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout'),
  healthCheckExp?: string(name='HealthCheckExp'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckReq?: string(name='HealthCheckReq'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  listenerPort?: int32(name='ListenerPort'),
  requestId?: string(name='RequestId', description='Id of the request'),
  scheduler?: string(name='Scheduler'),
  status?: string(name='Status'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
}

model DescribeLoadBalancerUDPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancerUDPListenerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerUDPListenerAttribute(request: DescribeLoadBalancerUDPListenerAttributeRequest): DescribeLoadBalancerUDPListenerAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLoadBalancerUDPListenerAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLoadBalancersRequest {
  address?: string(name='Address', position='Query'),
  ensRegionId?: string(name='EnsRegionId', position='Query'),
  loadBalancerId?: string(name='LoadBalancerId', position='Query'),
  loadBalancerName?: string(name='LoadBalancerName', minLength=2, maxLength=128, position='Query'),
  loadBalancerStatus?: string(name='LoadBalancerStatus', position='Query'),
  networkId?: string(name='NetworkId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  serverId?: string(name='ServerId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
}

model DescribeLoadBalancersResponseBody = {
  loadBalancers?: {
    loadBalancer?: [ 
    {
      address?: string(name='Address'),
      addressIPVersion?: string(name='AddressIPVersion'),
      createTime?: string(name='CreateTime'),
      ensRegionId?: string(name='EnsRegionId'),
      loadBalancerId?: string(name='LoadBalancerId'),
      loadBalancerName?: string(name='LoadBalancerName'),
      loadBalancerStatus?: string(name='LoadBalancerStatus'),
      networkId?: string(name='NetworkId'),
      payType?: string(name='PayType'),
      vSwitchId?: string(name='VSwitchId'),
    }
  ](name='LoadBalancer')
  }(name='LoadBalancers'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeLoadBalancersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancersResponseBody(name='body'),
}

async function describeLoadBalancers(request: DescribeLoadBalancersRequest): DescribeLoadBalancersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLoadBalancers', 'GET', '/', 'json', false, 'json', request);
}

model DescribeMeasurementDataRequest {
  endDate: string(name='EndDate', position='Query'),
  startDate: string(name='StartDate', position='Query'),
  version: string(name='Version', position='Query'),
}

model DescribeMeasurementDataResponseBody = {
  measurementDatas?: {
    measurementData?: [ 
    {
      bandWidthFeeDatas?: {
        bandWidthFeeData?: [ 
        {
          costCode?: string(name='CostCode'),
          costName?: string(name='CostName'),
          costVal?: int32(name='CostVal'),
        }
      ](name='BandWidthFeeData')
      }(name='BandWidthFeeDatas'),
      chargeModel?: string(name='ChargeModel'),
      costCycle?: string(name='CostCycle'),
      costEndTime?: string(name='CostEndTime'),
      costStartTime?: string(name='CostStartTime'),
      resourceFeeData?: {
        memory?: int32(name='Memory'),
        storage?: int32(name='Storage'),
        vcpu?: int32(name='Vcpu'),
      }(name='ResourceFeeData'),
      resourceFeeDataDetails?: {
        resourceFeeDataDetail?: [ 
        {
          costCode?: string(name='CostCode'),
          costName?: string(name='CostName'),
          costVal?: int32(name='CostVal'),
          resourceType?: string(name='ResourceType'),
        }
      ](name='ResourceFeeDataDetail')
      }(name='ResourceFeeDataDetails'),
    }
  ](name='MeasurementData')
  }(name='MeasurementDatas'),
  requestId?: string(name='RequestId'),
}

model DescribeMeasurementDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMeasurementDataResponseBody(name='body'),
}

async function describeMeasurementData(request: DescribeMeasurementDataRequest): DescribeMeasurementDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMeasurementData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeNatGatewaysRequest {
  ensRegionId?: string(name='EnsRegionId', position='Query'),
  name?: string(name='Name', position='Query'),
  natGatewayId?: string(name='NatGatewayId', position='Query'),
  networkId?: string(name='NetworkId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
}

model DescribeNatGatewaysResponseBody = {
  natGateways?: [ 
    {
      creationTime?: string(name='CreationTime'),
      ensRegionId?: string(name='EnsRegionId'),
      name?: string(name='Name'),
      natGatewayId?: string(name='NatGatewayId'),
      networkId?: string(name='NetworkId'),
      spec?: string(name='Spec'),
      vSwitchId?: string(name='VSwitchId'),
    }
  ](name='NatGateways'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeNatGatewaysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNatGatewaysResponseBody(name='body'),
}

async function describeNatGateways(request: DescribeNatGatewaysRequest): DescribeNatGatewaysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNatGateways', 'GET', '/', 'json', false, 'json', request);
}

model DescribeNetworkAttributeRequest {
  networkId: string(name='NetworkId', position='Query'),
}

model DescribeNetworkAttributeResponseBody = {
  cidrBlock?: string(name='CidrBlock'),
  cloudResources?: {
    cloudResourceSetType?: [ 
    {
      resourceCount?: int32(name='ResourceCount'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='CloudResourceSetType')
  }(name='CloudResources'),
  createdTime?: string(name='CreatedTime'),
  description?: string(name='Description'),
  ensRegionId?: string(name='EnsRegionId'),
  networkId?: string(name='NetworkId'),
  networkName?: string(name='NetworkName'),
  requestId?: string(name='RequestId', description='Id of the request'),
  routerTableId?: string(name='RouterTableId'),
  status?: string(name='Status'),
  vSwitchIds?: {
    vSwitchId?: [ string ](name='VSwitchId')
  }(name='VSwitchIds'),
}

model DescribeNetworkAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNetworkAttributeResponseBody(name='body'),
}

async function describeNetworkAttribute(request: DescribeNetworkAttributeRequest): DescribeNetworkAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNetworkAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeNetworkInterfacesRequest {
  ensRegionId?: string(name='EnsRegionId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  pageNumber?: string(name='PageNumber', position='Query'),
  pageSize?: string(name='PageSize', maximum=100, position='Query'),
  primaryIpAddress?: string(name='PrimaryIpAddress', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
}

model DescribeNetworkInterfacesResponseBody = {
  networkInterfaceSets?: {
    networkInterfaceSet?: [ 
    {
      creationTime?: string(name='CreationTime'),
      ensRegionId?: string(name='EnsRegionId'),
      instanceId?: string(name='InstanceId'),
      macAddress?: string(name='MacAddress'),
      networkInterfaceId?: string(name='NetworkInterfaceId'),
      primaryIp?: string(name='PrimaryIp'),
      primaryIpType?: string(name='PrimaryIpType'),
      privateIpSets?: {
        privateIpSet?: [ 
        {
          primary?: boolean(name='Primary'),
          privateIpAddress?: string(name='PrivateIpAddress'),
        }
      ](name='PrivateIpSet')
      }(name='PrivateIpSets'),
      status?: string(name='Status'),
      vSwitchId?: string(name='VSwitchId'),
    }
  ](name='NetworkInterfaceSet')
  }(name='NetworkInterfaceSets'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeNetworkInterfacesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNetworkInterfacesResponseBody(name='body'),
}

async function describeNetworkInterfaces(request: DescribeNetworkInterfacesRequest): DescribeNetworkInterfacesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNetworkInterfaces', 'POST', '/', 'json', false, 'json', request);
}

model DescribeNetworksRequest {
  ensRegionId?: string(name='EnsRegionId', position='Query'),
  networkId?: string(name='NetworkId', position='Query'),
  networkName?: string(name='NetworkName', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model DescribeNetworksResponseBody = {
  networks?: {
    network?: [ 
    {
      cidrBlock?: string(name='CidrBlock'),
      createdTime?: string(name='CreatedTime'),
      description?: string(name='Description'),
      ensRegionId?: string(name='EnsRegionId'),
      networkId?: string(name='NetworkId'),
      networkName?: string(name='NetworkName'),
      routerTableId?: string(name='RouterTableId'),
      status?: string(name='Status'),
      vSwitchIds?: {
        vSwitchId?: [ string ](name='VSwitchId')
      }(name='VSwitchIds'),
    }
  ](name='Network')
  }(name='Networks'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeNetworksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNetworksResponseBody(name='body'),
}

async function describeNetworks(request: DescribeNetworksRequest): DescribeNetworksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNetworks', 'POST', '/', 'json', false, 'json', request);
}

model DescribePrePaidInstanceStockRequest {
  dataDiskSize: int32(name='DataDiskSize', position='Query'),
  ensRegionId: string(name='EnsRegionId', position='Query'),
  instanceSpec: string(name='InstanceSpec', position='Query'),
  systemDiskSize: int32(name='SystemDiskSize', minimum=20, position='Query'),
  version: string(name='Version', position='Query'),
}

model DescribePrePaidInstanceStockResponseBody = {
  avaliableCount?: int32(name='AvaliableCount'),
  cores?: int32(name='Cores'),
  dataDiskSize?: int32(name='DataDiskSize'),
  ensRegionId?: string(name='EnsRegionId'),
  instanceSpec?: string(name='InstanceSpec'),
  memory?: int32(name='Memory'),
  requestId?: string(name='RequestId'),
  systemDiskSize?: int32(name='SystemDiskSize'),
}

model DescribePrePaidInstanceStockResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePrePaidInstanceStockResponseBody(name='body'),
}

async function describePrePaidInstanceStock(request: DescribePrePaidInstanceStockRequest): DescribePrePaidInstanceStockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePrePaidInstanceStock', 'POST', '/', 'json', false, 'json', request);
}

model DescribePriceRequest {
  dataDisk?: [
    {
      size?: int32(name='Size', description='数据盘大小，单位GB。如果此字段不为空，则以此段为准。'),
    }
  ](name='DataDisk', position='Query'),
  systemDisk?: {
    size: int32(name='Size', description='系统盘大小，单位：GB'),
  }(name='SystemDisk', position='Query'),
  dataDisks?: [ 
    {
      category?: string(name='Category', description='磁盘类型'),
      size?: long(name='Size', minimum=20),
    }
  ](name='DataDisks', description='如果DataDisk.1.Size为空且此字段不为空时的则以此字段为准', shrink='json', position='Query'),
  ensRegionId: string(name='EnsRegionId', description='节点ID。', position='Query'),
  instanceType: string(name='InstanceType', description='实列规格。', position='Query'),
  internetChargeType: string(name='InternetChargeType', description='带宽计费方式', position='Query'),
  period: int32(name='Period', description='购买资源的时长，如果不指定PeriodUnit，则默认按月购买。目前只支持按Days和Month。如果PeriodUnit=Day时，Period仅可以3。如果PeriodUnit=Monthc时，则Period可以为1-9,12。', minimum=1, maximum=12, position='Query'),
  periodUnit?: string(name='PeriodUnit', description='查询云服务器ENS不同计费周期的价格。取值范围：
Month（默认）：按月计费的价格单位。
Day：按天计费的价格单位。', position='Query'),
  quantity: int32(name='Quantity', description='数量。', position='Query'),
}

model DescribePriceResponseBody = {
  priceInfo?: {
    price?: {
      currency?: string(name='Currency'),
      discountPrice?: float(name='DiscountPrice'),
      originalPrice?: float(name='OriginalPrice'),
      tradePrice?: float(name='TradePrice'),
    }(name='Price'),
  }(name='PriceInfo'),
  requestId?: string(name='RequestId'),
}

model DescribePriceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePriceResponseBody(name='body'),
}

async function describePrice(request: DescribePriceRequest): DescribePriceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePrice', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRegionIspsRequest {
  ensRegionId?: string(name='EnsRegionId', position='Query'),
}

model DescribeRegionIspsResponseBody = {
  isps?: [ 
    {
      code?: string(name='Code'),
      name?: string(name='Name'),
    }
  ](name='Isps'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DescribeRegionIspsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionIspsResponseBody(name='body'),
}

async function describeRegionIsps(request: DescribeRegionIspsRequest): DescribeRegionIspsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRegionIsps', 'GET', '/', 'json', false, 'json', request);
}

model DescribeReservedResourceRequest {
  version: string(name='Version', position='Query'),
}

model DescribeReservedResourceResponseBody = {
  code?: int32(name='Code'),
  images?: {
    image?: [ 
    {
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
    }
  ](name='Image')
  }(name='Images'),
  requestId?: string(name='RequestId'),
  supportResources?: {
    supportResource?: [ 
    {
      dataDiskSizes?: {
        dataDiskSize?: [ string ](name='DataDiskSize')
      }(name='DataDiskSizes'),
      ensRegionId?: string(name='EnsRegionId'),
      instanceSpec?: string(name='InstanceSpec'),
      supportResourcesCount?: string(name='SupportResourcesCount'),
      systemDiskSizes?: {
        systemDiskSize?: [ string ](name='SystemDiskSize')
      }(name='SystemDiskSizes'),
    }
  ](name='SupportResource')
  }(name='SupportResources'),
}

model DescribeReservedResourceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeReservedResourceResponseBody(name='body'),
}

async function describeReservedResource(request: DescribeReservedResourceRequest): DescribeReservedResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeReservedResource', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSecurityGroupAttributeRequest {
  securityGroupId: string(name='SecurityGroupId', position='Query'),
}

model DescribeSecurityGroupAttributeResponseBody = {
  description?: string(name='Description'),
  permissions?: {
    permission?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      destCidrIp?: string(name='DestCidrIp'),
      direction?: string(name='Direction'),
      ipProtocol?: string(name='IpProtocol'),
      policy?: string(name='Policy'),
      portRange?: string(name='PortRange'),
      priority?: int32(name='Priority'),
      sourceCidrIp?: string(name='SourceCidrIp'),
      sourcePortRange?: string(name='SourcePortRange'),
    }
  ](name='Permission')
  }(name='Permissions'),
  requestId?: string(name='RequestId'),
  securityGroupId?: string(name='SecurityGroupId'),
  securityGroupName?: string(name='SecurityGroupName'),
}

model DescribeSecurityGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSecurityGroupAttributeResponseBody(name='body'),
}

async function describeSecurityGroupAttribute(request: DescribeSecurityGroupAttributeRequest): DescribeSecurityGroupAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSecurityGroupAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSecurityGroupsRequest {
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  securityGroupId?: string(name='SecurityGroupId', position='Query'),
  securityGroupName?: string(name='SecurityGroupName', position='Query'),
  version: string(name='Version', position='Query'),
}

model DescribeSecurityGroupsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  securityGroups?: {
    securityGroup?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      instanceCount?: int32(name='InstanceCount'),
      securityGroupId?: string(name='SecurityGroupId'),
      securityGroupName?: string(name='SecurityGroupName'),
    }
  ](name='SecurityGroup')
  }(name='SecurityGroups'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSecurityGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSecurityGroupsResponseBody(name='body'),
}

async function describeSecurityGroups(request: DescribeSecurityGroupsRequest): DescribeSecurityGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSecurityGroups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeServcieScheduleRequest {
  appId: string(name='AppId', position='Query'),
  podConfigName?: string(name='PodConfigName', position='Query'),
  uuid: string(name='Uuid', position='Query'),
}

model DescribeServcieScheduleResponseBody = {
  index?: int32(name='Index'),
  instanceId?: string(name='InstanceId'),
  instanceIp?: string(name='InstanceIp'),
  instancePort?: int32(name='InstancePort'),
  podAbstractInfo?: {
    containerService?: boolean(name='ContainerService'),
    containerStatuses?: {
      containerStatus?: [ 
      {
        containerId?: string(name='ContainerId'),
        name?: string(name='Name'),
      }
    ](name='ContainerStatus')
    }(name='ContainerStatuses'),
    name?: boolean(name='Name'),
    namespace?: boolean(name='Namespace'),
    resourceScope?: boolean(name='ResourceScope'),
    status?: boolean(name='Status'),
  }(name='PodAbstractInfo'),
  requestId?: string(name='RequestId'),
  requestRepeated?: boolean(name='RequestRepeated'),
  tcpPorts?: string(name='TcpPorts'),
}

model DescribeServcieScheduleResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServcieScheduleResponseBody(name='body'),
}

async function describeServcieSchedule(request: DescribeServcieScheduleRequest): DescribeServcieScheduleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeServcieSchedule', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSnatTableEntriesRequest {
  natGatewayId: string(name='NatGatewayId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  snatEntryId?: string(name='SnatEntryId', position='Query'),
  snatEntryName?: string(name='SnatEntryName', maxLength=128, position='Query'),
  snatIp?: string(name='SnatIp', position='Query'),
  sourceCIDR?: string(name='SourceCIDR', position='Query'),
}

model DescribeSnatTableEntriesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  snatTableEntries?: [ 
    {
      natGatewayId?: string(name='NatGatewayId'),
      snatEntryId?: string(name='SnatEntryId'),
      snatEntryName?: string(name='SnatEntryName'),
      snatIp?: string(name='SnatIp'),
      sourceCIDR?: string(name='SourceCIDR'),
      status?: string(name='Status'),
    }
  ](name='SnatTableEntries'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSnatTableEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSnatTableEntriesResponseBody(name='body'),
}

async function describeSnatTableEntries(request: DescribeSnatTableEntriesRequest): DescribeSnatTableEntriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSnatTableEntries', 'GET', '/', 'json', false, 'json', request);
}

model DescribeUserBandWidthDataRequest {
  endTime: string(name='EndTime', position='Query'),
  ensRegionId?: string(name='EnsRegionId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  isp?: string(name='Isp', position='Query'),
  period: string(name='Period', position='Query'),
  startTime: string(name='StartTime', position='Query'),
  version: string(name='Version', position='Query'),
}

model DescribeUserBandWidthDataResponseBody = {
  code?: int32(name='Code'),
  monitorData?: {
    bandWidthMonitorData?: [ 
      {
        downBandWidth?: int32(name='DownBandWidth'),
        internetRX?: int32(name='InternetRX'),
        internetTX?: int32(name='InternetTX'),
        timeStamp?: string(name='TimeStamp'),
        upBandWidth?: int32(name='UpBandWidth'),
      }
    ](name='BandWidthMonitorData'),
    maxDownBandWidth?: string(name='MaxDownBandWidth'),
    maxUpBandWidth?: string(name='MaxUpBandWidth'),
  }(name='MonitorData'),
  requestId?: string(name='RequestId'),
}

model DescribeUserBandWidthDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUserBandWidthDataResponseBody(name='body'),
}

async function describeUserBandWidthData(request: DescribeUserBandWidthDataRequest): DescribeUserBandWidthDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUserBandWidthData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVSwitchesRequest {
  ensRegionId?: string(name='EnsRegionId', position='Query'),
  networkId?: string(name='NetworkId', position='Query'),
  orderByParams?: string(name='OrderByParams', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', maximum=50, position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vSwitchName?: string(name='VSwitchName', position='Query'),
  version: string(name='Version', position='Query'),
}

model DescribeVSwitchesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vSwitches?: {
    vSwitch?: [ 
    {
      cidrBlock?: string(name='CidrBlock'),
      createdTime?: string(name='CreatedTime'),
      description?: string(name='Description'),
      ensRegionId?: string(name='EnsRegionId'),
      freeIpCount?: long(name='FreeIpCount'),
      networkId?: string(name='NetworkId'),
      status?: string(name='Status'),
      vSwitchId?: string(name='VSwitchId'),
      vSwitchName?: string(name='VSwitchName'),
    }
  ](name='VSwitch')
  }(name='VSwitches'),
}

model DescribeVSwitchesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVSwitchesResponseBody(name='body'),
}

async function describeVSwitches(request: DescribeVSwitchesRequest): DescribeVSwitchesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVSwitches', 'POST', '/', 'json', false, 'json', request);
}

model DetachDiskRequest {
  diskId: string(name='DiskId', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
}

model DetachDiskResponseBody = {
  code?: int32(name='Code'),
  requestId?: string(name='RequestId'),
}

model DetachDiskResponse = {
  headers: map[string]string(name='headers'),
  body: DetachDiskResponseBody(name='body'),
}

async function detachDisk(request: DetachDiskRequest): DetachDiskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetachDisk', 'POST', '/', 'json', false, 'json', request);
}

model DistApplicationDataRequest {
  appId: string(name='AppId', position='Query'),
  data: string(name='Data', position='Query'),
  distStrategy?: string(name='DistStrategy', position='Query'),
}

model DistApplicationDataResponseBody = {
  distInstanceIds?: {
    distInstanceId?: [ string ](name='DistInstanceId')
  }(name='DistInstanceIds'),
  distInstanceTotalCount?: int32(name='DistInstanceTotalCount'),
  distResults?: {
    distResult?: [ 
    {
      name?: string(name='Name'),
      resultCode?: int32(name='ResultCode'),
      resultDescrip?: string(name='ResultDescrip'),
      version?: string(name='Version'),
    }
  ](name='DistResult')
  }(name='DistResults'),
  requestId?: string(name='RequestId'),
}

model DistApplicationDataResponse = {
  headers: map[string]string(name='headers'),
  body: DistApplicationDataResponseBody(name='body'),
}

async function distApplicationData(request: DistApplicationDataRequest): DistApplicationDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DistApplicationData', 'POST', '/', 'json', false, 'json', request);
}

model ExportBillDetailDataRequest {
  endDate: string(name='EndDate', description='结束时间UTC格式', position='Query'),
  startDate: string(name='StartDate', description='开始时间，UTC格式', position='Query'),
}

model ExportBillDetailDataResponseBody = {
  filePath?: string(name='FilePath', description='文件下载地址'),
  requestId?: string(name='RequestId', description='请求ID，公共字段'),
}

model ExportBillDetailDataResponse = {
  headers: map[string]string(name='headers'),
  body: ExportBillDetailDataResponseBody(name='body'),
}

async function exportBillDetailData(request: ExportBillDetailDataRequest): ExportBillDetailDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExportBillDetailData', 'POST', '/', 'json', false, 'json', request);
}

model ExportImageRequest {
  imageId: string(name='ImageId', position='Query'),
  OSSBucket: string(name='OSSBucket', position='Query'),
  OSSPrefix?: string(name='OSSPrefix', position='Query'),
  OSSRegionId: string(name='OSSRegionId', position='Query'),
  roleName?: string(name='RoleName', position='Query'),
}

model ExportImageResponseBody = {
  exportedImageURL?: string(name='ExportedImageURL'),
  requestId?: string(name='RequestId'),
}

model ExportImageResponse = {
  headers: map[string]string(name='headers'),
  body: ExportImageResponseBody(name='body'),
}

async function exportImage(request: ExportImageRequest): ExportImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExportImage', 'POST', '/', 'json', false, 'json', request);
}

model ExportMeasurementDataRequest {
  endDate: string(name='EndDate', description='结束时间，UTC格式', position='Query'),
  startDate: string(name='StartDate', description='开始时间，UTC格式', position='Query'),
}

model ExportMeasurementDataResponseBody = {
  filePath?: string(name='FilePath', description='文件下载地址'),
  requestId?: string(name='RequestId', description='请求ID，公共字段'),
}

model ExportMeasurementDataResponse = {
  headers: map[string]string(name='headers'),
  body: ExportMeasurementDataResponseBody(name='body'),
}

async function exportMeasurementData(request: ExportMeasurementDataRequest): ExportMeasurementDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExportMeasurementData', 'POST', '/', 'json', false, 'json', request);
}

model GetDeviceInternetPortRequest {
  instanceId: string(name='InstanceId', description='A short description of struct', position='Query'),
  natType: string(name='NatType', position='Query'),
  ruleId?: string(name='RuleId', position='Query'),
}

model GetDeviceInternetPortResponseBody = {
  instanceId?: string(name='InstanceId', description='InstanceId'),
  networkInfo?: [ 
    {
      externalIp?: string(name='ExternalIp'),
      externalPort?: string(name='ExternalPort'),
      ISP?: string(name='ISP'),
      internalIp?: string(name='InternalIp'),
      internalPort?: string(name='InternalPort'),
      status?: string(name='Status'),
    }
  ](name='NetworkInfo'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetDeviceInternetPortResponse = {
  headers: map[string]string(name='headers'),
  body: GetDeviceInternetPortResponseBody(name='body'),
}

async function getDeviceInternetPort(request: GetDeviceInternetPortRequest): GetDeviceInternetPortResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDeviceInternetPort', 'GET', '/', 'json', false, 'json', request);
}

model GetOssStorageAndAccByBucketsRequest {
  bucketList?: string(name='BucketList', position='Query'),
}

model GetOssStorageAndAccByBucketsResponseBody = {
  bucketList?: [ 
    {
      acc?: long(name='Acc'),
      bucket?: string(name='Bucket'),
      storageUsageByte?: long(name='StorageUsageByte'),
    }
  ](name='BucketList'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetOssStorageAndAccByBucketsResponse = {
  headers: map[string]string(name='headers'),
  body: GetOssStorageAndAccByBucketsResponseBody(name='body'),
}

async function getOssStorageAndAccByBuckets(request: GetOssStorageAndAccByBucketsRequest): GetOssStorageAndAccByBucketsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetOssStorageAndAccByBuckets', 'GET', '/', 'json', false, 'json', request);
}

model ImportKeyPairRequest {
  keyPairName: string(name='KeyPairName', position='Query'),
  publicKeyBody: string(name='PublicKeyBody', position='Query'),
  version: string(name='Version', position='Query'),
}

model ImportKeyPairResponseBody = {
  keyPairFingerPrint?: string(name='KeyPairFingerPrint'),
  keyPairName?: string(name='KeyPairName'),
  requestId?: string(name='RequestId'),
}

model ImportKeyPairResponse = {
  headers: map[string]string(name='headers'),
  body: ImportKeyPairResponseBody(name='body'),
}

async function importKeyPair(request: ImportKeyPairRequest): ImportKeyPairResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ImportKeyPair', 'POST', '/', 'json', false, 'json', request);
}

model JoinPublicIpsToEpnInstanceRequest {
  EPNInstanceId: string(name='EPNInstanceId', position='Query'),
  instanceInfos: string(name='InstanceInfos', position='Query'),
}

model JoinPublicIpsToEpnInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model JoinPublicIpsToEpnInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: JoinPublicIpsToEpnInstanceResponseBody(name='body'),
}

async function joinPublicIpsToEpnInstance(request: JoinPublicIpsToEpnInstanceRequest): JoinPublicIpsToEpnInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'JoinPublicIpsToEpnInstance', 'POST', '/', 'json', false, 'json', request);
}

model JoinSecurityGroupRequest {
  instanceId: string(name='InstanceId', position='Query'),
  securityGroupId: string(name='SecurityGroupId', position='Query'),
}

model JoinSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model JoinSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: JoinSecurityGroupResponseBody(name='body'),
}

async function joinSecurityGroup(request: JoinSecurityGroupRequest): JoinSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'JoinSecurityGroup', 'POST', '/', 'json', false, 'json', request);
}

model JoinVSwitchesToEpnInstanceRequest {
  EPNInstanceId: string(name='EPNInstanceId', position='Query'),
  vSwitchesInfo: string(name='VSwitchesInfo', position='Query'),
}

model JoinVSwitchesToEpnInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model JoinVSwitchesToEpnInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: JoinVSwitchesToEpnInstanceResponseBody(name='body'),
}

async function joinVSwitchesToEpnInstance(request: JoinVSwitchesToEpnInstanceRequest): JoinVSwitchesToEpnInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'JoinVSwitchesToEpnInstance', 'POST', '/', 'json', false, 'json', request);
}

model LeaveSecurityGroupRequest {
  instanceId: string(name='InstanceId', position='Query'),
  securityGroupId: string(name='SecurityGroupId', position='Query'),
  version: string(name='Version', position='Query'),
}

model LeaveSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model LeaveSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: LeaveSecurityGroupResponseBody(name='body'),
}

async function leaveSecurityGroup(request: LeaveSecurityGroupRequest): LeaveSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'LeaveSecurityGroup', 'POST', '/', 'json', false, 'json', request);
}

model ListApplicationsRequest {
  appVersions?: string(name='AppVersions', position='Query'),
  clusterNames?: string(name='ClusterNames', position='Query'),
  level?: string(name='Level', position='Query'),
  maxDate?: string(name='MaxDate', position='Query'),
  minDate?: string(name='MinDate', position='Query'),
  outAppInfoParams?: string(name='OutAppInfoParams', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model ListApplicationsResponseBody = {
  applications?: {
    application?: [ 
    {
      appList?: {
        app?: [ 
        {
          appId?: string(name='AppId'),
          appInfo?: string(name='AppInfo'),
        }
      ](name='App')
      }(name='AppList'),
      clusterName?: string(name='ClusterName'),
    }
  ](name='Application')
  }(name='Applications'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListApplicationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListApplicationsResponseBody(name='body'),
}

async function listApplications(request: ListApplicationsRequest): ListApplicationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListApplications', 'POST', '/', 'json', false, 'json', request);
}

model ModifyEnsEipAddressAttributeRequest {
  allocationId: string(name='AllocationId', position='Query'),
  bandwidth?: int32(name='Bandwidth', minimum=1, maximum=10000, position='Query'),
  description?: string(name='Description', minLength=2, maxLength=256, position='Query'),
  name?: string(name='Name', minLength=2, maxLength=128, position='Query'),
}

model ModifyEnsEipAddressAttributeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ModifyEnsEipAddressAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyEnsEipAddressAttributeResponseBody(name='body'),
}

async function modifyEnsEipAddressAttribute(request: ModifyEnsEipAddressAttributeRequest): ModifyEnsEipAddressAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyEnsEipAddressAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyEpnInstanceRequest {
  EPNInstanceId: string(name='EPNInstanceId', position='Query'),
  EPNInstanceName?: string(name='EPNInstanceName', position='Query'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', position='Query'),
  networkingModel?: string(name='NetworkingModel', position='Query'),
}

model ModifyEpnInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyEpnInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyEpnInstanceResponseBody(name='body'),
}

async function modifyEpnInstance(request: ModifyEpnInstanceRequest): ModifyEpnInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyEpnInstance', 'POST', '/', 'json', false, 'json', request);
}

model ModifyForwardEntryRequest {
  forwardEntryId: string(name='ForwardEntryId', position='Query'),
  forwardEntryName?: string(name='ForwardEntryName', maxLength=128, position='Query'),
  healthCheckPort?: int32(name='HealthCheckPort', minimum=0, maximum=65535, position='Query'),
}

model ModifyForwardEntryResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ModifyForwardEntryResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyForwardEntryResponseBody(name='body'),
}

async function modifyForwardEntry(request: ModifyForwardEntryRequest): ModifyForwardEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyForwardEntry', 'POST', '/', 'json', false, 'json', request);
}

model ModifyImageAttributeRequest {
  imageId: string(name='ImageId', position='Query'),
  imageName: string(name='ImageName', position='Query'),
  version: string(name='Version', position='Query'),
  product?: string(name='product', position='Query'),
}

model ModifyImageAttributeResponseBody = {
  code?: int32(name='Code'),
  requestId?: string(name='RequestId'),
}

model ModifyImageAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyImageAttributeResponseBody(name='body'),
}

async function modifyImageAttribute(request: ModifyImageAttributeRequest): ModifyImageAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyImageAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyImageSharePermissionRequest {
  addAccounts?: string(name='AddAccounts', position='Query'),
  imageId: string(name='ImageId', position='Query'),
  removeAccounts?: string(name='RemoveAccounts', position='Query'),
}

model ModifyImageSharePermissionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyImageSharePermissionResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyImageSharePermissionResponseBody(name='body'),
}

async function modifyImageSharePermission(request: ModifyImageSharePermissionRequest): ModifyImageSharePermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyImageSharePermission', 'POST', '/', 'json', false, 'json', request);
}

model ModifyInstanceAttributeRequest {
  instanceId: string(name='InstanceId', position='Query'),
  instanceName?: string(name='InstanceName', position='Query'),
  password?: string(name='Password', position='Query'),
  version: string(name='Version', position='Query'),
}

model ModifyInstanceAttributeResponseBody = {
  code?: int32(name='Code'),
  requestId?: string(name='RequestId'),
}

model ModifyInstanceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceAttributeResponseBody(name='body'),
}

async function modifyInstanceAttribute(request: ModifyInstanceAttributeRequest): ModifyInstanceAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyInstanceAutoRenewAttributeRequest {
  autoRenew: string(name='AutoRenew', position='Query'),
  duration?: string(name='Duration', position='Query'),
  instanceIds: string(name='InstanceIds', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  renewalStatus?: string(name='RenewalStatus', position='Query'),
}

model ModifyInstanceAutoRenewAttributeResponseBody = {
  code?: int32(name='Code'),
  requestId?: string(name='RequestId'),
}

model ModifyInstanceAutoRenewAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceAutoRenewAttributeResponseBody(name='body'),
}

async function modifyInstanceAutoRenewAttribute(request: ModifyInstanceAutoRenewAttributeRequest): ModifyInstanceAutoRenewAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceAutoRenewAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyLoadBalancerAttributeRequest {
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  loadBalancerName: string(name='LoadBalancerName', minLength=2, maxLength=128, position='Query'),
}

model ModifyLoadBalancerAttributeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ModifyLoadBalancerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyLoadBalancerAttributeResponseBody(name='body'),
}

async function modifyLoadBalancerAttribute(request: ModifyLoadBalancerAttributeRequest): ModifyLoadBalancerAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyLoadBalancerAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyNetworkAttributeRequest {
  description?: string(name='Description', minLength=2, maxLength=256, position='Query'),
  networkId: string(name='NetworkId', position='Query'),
  networkName?: string(name='NetworkName', minLength=2, maxLength=128, position='Query'),
}

model ModifyNetworkAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNetworkAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNetworkAttributeResponseBody(name='body'),
}

async function modifyNetworkAttribute(request: ModifyNetworkAttributeRequest): ModifyNetworkAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyNetworkAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyPrepayInstanceSpecRequest {
  instanceId?: string(name='InstanceId', description='变配实例id', position='Query'),
  instanceType?: string(name='InstanceType', description='更新的配置', position='Query'),
}

model ModifyPrepayInstanceSpecResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ModifyPrepayInstanceSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyPrepayInstanceSpecResponseBody(name='body'),
}

async function modifyPrepayInstanceSpec(request: ModifyPrepayInstanceSpecRequest): ModifyPrepayInstanceSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyPrepayInstanceSpec', 'POST', '/', 'json', false, 'json', request);
}

model ModifySecurityGroupAttributeRequest {
  description?: string(name='Description', minLength=2, maxLength=256, position='Query'),
  securityGroupId: string(name='SecurityGroupId', position='Query'),
  securityGroupName?: string(name='SecurityGroupName', minLength=2, maxLength=128, position='Query'),
}

model ModifySecurityGroupAttributeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ModifySecurityGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySecurityGroupAttributeResponseBody(name='body'),
}

async function modifySecurityGroupAttribute(request: ModifySecurityGroupAttributeRequest): ModifySecurityGroupAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySecurityGroupAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyVSwitchAttributeRequest {
  description?: string(name='Description', minLength=2, maxLength=256, position='Query'),
  vSwitchId: string(name='VSwitchId', position='Query'),
  vSwitchName?: string(name='VSwitchName', minLength=2, maxLength=128, position='Query'),
}

model ModifyVSwitchAttributeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ModifyVSwitchAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVSwitchAttributeResponseBody(name='body'),
}

async function modifyVSwitchAttribute(request: ModifyVSwitchAttributeRequest): ModifyVSwitchAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyVSwitchAttribute', 'POST', '/', 'json', false, 'json', request);
}

model PreCreateEnsServiceRequest {
  bandwidthType: string(name='BandwidthType', position='Query'),
  buyResourcesDetail: string(name='BuyResourcesDetail', position='Query'),
  dataDiskSize?: string(name='DataDiskSize', position='Query'),
  ensServiceName: string(name='EnsServiceName', position='Query'),
  imageId: string(name='ImageId', position='Query'),
  instanceBandwithdLimit: string(name='InstanceBandwithdLimit', position='Query'),
  instanceSpec: string(name='InstanceSpec', position='Query'),
  keyPairName?: string(name='KeyPairName', position='Query'),
  netLevel: string(name='NetLevel', position='Query'),
  password?: string(name='Password', position='Query'),
  schedulingPriceStrategy?: string(name='SchedulingPriceStrategy', position='Query'),
  schedulingStrategy: string(name='SchedulingStrategy', position='Query'),
  systemDiskSize: string(name='SystemDiskSize', position='Query'),
  userData?: string(name='UserData', position='Query'),
}

model PreCreateEnsServiceResponseBody = {
  buyResourcesDetail?: string(name='BuyResourcesDetail'),
  code?: int32(name='Code'),
  ensServiceId?: string(name='EnsServiceId'),
  netLevel?: string(name='NetLevel'),
  requestId?: string(name='RequestId'),
}

model PreCreateEnsServiceResponse = {
  headers: map[string]string(name='headers'),
  body: PreCreateEnsServiceResponseBody(name='body'),
}

async function preCreateEnsService(request: PreCreateEnsServiceRequest): PreCreateEnsServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PreCreateEnsService', 'POST', '/', 'json', false, 'json', request);
}

model PushApplicationDataRequest {
  appId: string(name='AppId', position='Query'),
  data: string(name='Data', position='Query'),
  pushStrategy?: string(name='PushStrategy', position='Query'),
  timeout?: int32(name='Timeout', position='Query'),
}

model PushApplicationDataResponseBody = {
  pushResults?: {
    pushResult?: [ 
    {
      name?: string(name='Name'),
      resultCode?: int32(name='ResultCode'),
      resultDescrip?: string(name='ResultDescrip'),
      version?: string(name='Version'),
    }
  ](name='PushResult')
  }(name='PushResults'),
  requestId?: string(name='RequestId'),
}

model PushApplicationDataResponse = {
  headers: map[string]string(name='headers'),
  body: PushApplicationDataResponseBody(name='body'),
}

async function pushApplicationData(request: PushApplicationDataRequest): PushApplicationDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PushApplicationData', 'POST', '/', 'json', false, 'json', request);
}

model ReInitDiskRequest {
  diskId: string(name='DiskId', position='Query'),
  imageId: string(name='ImageId', position='Query'),
  version: string(name='Version', position='Query'),
}

model ReInitDiskResponseBody = {
  code?: int32(name='Code'),
  requestId?: string(name='RequestId'),
}

model ReInitDiskResponse = {
  headers: map[string]string(name='headers'),
  body: ReInitDiskResponseBody(name='body'),
}

async function reInitDisk(request: ReInitDiskRequest): ReInitDiskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReInitDisk', 'POST', '/', 'json', false, 'json', request);
}

model RebootAICInstanceRequest {
  instanceId?: string(name='InstanceId', position='Query'),
  serverId?: string(name='ServerId', position='Query'),
}

model RebootAICInstanceResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model RebootAICInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RebootAICInstanceResponseBody(name='body'),
}

async function rebootAICInstance(request: RebootAICInstanceRequest): RebootAICInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RebootAICInstance', 'GET', '/', 'json', false, 'json', request);
}

model RebootARMServerInstanceRequest {
  serverId?: string(name='ServerId', position='Query'),
}

model RebootARMServerInstanceResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model RebootARMServerInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RebootARMServerInstanceResponseBody(name='body'),
}

async function rebootARMServerInstance(request: RebootARMServerInstanceRequest): RebootARMServerInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RebootARMServerInstance', 'GET', '/', 'json', false, 'json', request);
}

model RebootInstanceRequest {
  forceStop?: string(name='ForceStop', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
}

model RebootInstanceResponseBody = {
  code?: int32(name='Code'),
  requestId?: string(name='RequestId'),
}

model RebootInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RebootInstanceResponseBody(name='body'),
}

async function rebootInstance(request: RebootInstanceRequest): RebootInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RebootInstance', 'POST', '/', 'json', false, 'json', request);
}

model ReinitInstanceRequest {
  imageId: string(name='ImageId', position='Body'),
  instanceId: string(name='InstanceId', position='Body'),
  password?: string(name='Password', position='Body'),
}

model ReinitInstanceResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ReinitInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ReinitInstanceResponseBody(name='body'),
}

async function reinitInstance(request: ReinitInstanceRequest): ReinitInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReinitInstance', 'POST', '/', 'json', true, 'form', request);
}

model ReleaseARMServerInstanceRequest {
  instanceId: string(name='InstanceId', description='AIC实例ID.', position='Query'),
}

model ReleaseARMServerInstanceResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ReleaseARMServerInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseARMServerInstanceResponseBody(name='body'),
}

async function releaseARMServerInstance(request: ReleaseARMServerInstanceRequest): ReleaseARMServerInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleaseARMServerInstance', 'POST', '/', 'json', false, 'json', request);
}

model ReleaseInstanceRequest {
  instanceId: string(name='InstanceId', description='实例id', position='Query'),
}

model ReleaseInstanceResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ReleaseInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseInstanceResponseBody(name='body'),
}

async function releaseInstance(request: ReleaseInstanceRequest): ReleaseInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleaseInstance', 'POST', '/', 'json', false, 'json', request);
}

model ReleasePostPaidInstanceRequest {
  instanceId: string(name='InstanceId', position='Query'),
}

model ReleasePostPaidInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleasePostPaidInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ReleasePostPaidInstanceResponseBody(name='body'),
}

async function releasePostPaidInstance(request: ReleasePostPaidInstanceRequest): ReleasePostPaidInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleasePostPaidInstance', 'POST', '/', 'json', false, 'json', request);
}

model ReleasePrePaidInstanceRequest {
  instanceId: string(name='InstanceId', position='Query'),
}

model ReleasePrePaidInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleasePrePaidInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ReleasePrePaidInstanceResponseBody(name='body'),
}

async function releasePrePaidInstance(request: ReleasePrePaidInstanceRequest): ReleasePrePaidInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleasePrePaidInstance', 'POST', '/', 'json', false, 'json', request);
}

model RemoveBackendServersRequest {
  backendServers: [ 
    {
      ip?: string(name='Ip'),
      port?: int32(name='Port', description='端口', minimum=0, maximum=65535),
      serverId: string(name='ServerId'),
      type?: string(name='Type', description='后端服务器类型。  ens：ENS实例（默认）'),
      weight?: int32(name='Weight', description='后端服务器的权重。  取值：0~100  默认值为100，如果值为0，则不会将请求转发给该后端服务器。', minimum=0, maximum=100),
    }
  ](name='BackendServers', shrink='json', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
}

model RemoveBackendServersResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      ip?: string(name='Ip'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model RemoveBackendServersResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveBackendServersResponseBody(name='body'),
}

async function removeBackendServers(request: RemoveBackendServersRequest): RemoveBackendServersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveBackendServers', 'POST', '/', 'json', false, 'json', request);
}

model RemovePublicIpsFromEpnInstanceRequest {
  EPNInstanceId: string(name='EPNInstanceId', position='Query'),
  instanceInfos: string(name='InstanceInfos', position='Query'),
}

model RemovePublicIpsFromEpnInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemovePublicIpsFromEpnInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RemovePublicIpsFromEpnInstanceResponseBody(name='body'),
}

async function removePublicIpsFromEpnInstance(request: RemovePublicIpsFromEpnInstanceRequest): RemovePublicIpsFromEpnInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemovePublicIpsFromEpnInstance', 'POST', '/', 'json', false, 'json', request);
}

model RemoveVSwitchesFromEpnInstanceRequest {
  EPNInstanceId: string(name='EPNInstanceId', position='Query'),
  vSwitchesInfo: string(name='VSwitchesInfo', position='Query'),
}

model RemoveVSwitchesFromEpnInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveVSwitchesFromEpnInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveVSwitchesFromEpnInstanceResponseBody(name='body'),
}

async function removeVSwitchesFromEpnInstance(request: RemoveVSwitchesFromEpnInstanceRequest): RemoveVSwitchesFromEpnInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveVSwitchesFromEpnInstance', 'POST', '/', 'json', false, 'json', request);
}

model RenewARMServerInstanceRequest {
  instanceId: string(name='InstanceId', position='Query'),
  period: int32(name='Period', position='Query'),
  periodUnit: string(name='PeriodUnit', position='Query'),
}

model RenewARMServerInstanceResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model RenewARMServerInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RenewARMServerInstanceResponseBody(name='body'),
}

async function renewARMServerInstance(request: RenewARMServerInstanceRequest): RenewARMServerInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RenewARMServerInstance', 'POST', '/', 'json', false, 'json', request);
}

model RenewInstanceRequest {
  instanceId: string(name='InstanceId', description='需要续费的实例ID。', position='Query'),
  period: long(name='Period', description='包年包月续费时长。', position='Query'),
}

model RenewInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model RenewInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RenewInstanceResponseBody(name='body'),
}

async function renewInstance(request: RenewInstanceRequest): RenewInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RenewInstance', 'GET', '/', 'json', false, 'json', request);
}

model RescaleApplicationRequest {
  appId: string(name='AppId', position='Query'),
  rescaleLevel?: string(name='RescaleLevel', position='Query'),
  rescaleType: string(name='RescaleType', position='Query'),
  resourceSelector: string(name='ResourceSelector', position='Query'),
  timeout?: int32(name='Timeout', position='Query'),
  toAppVersion?: string(name='ToAppVersion', position='Query'),
}

model RescaleApplicationResponseBody = {
  requestId?: string(name='RequestId'),
}

model RescaleApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: RescaleApplicationResponseBody(name='body'),
}

async function rescaleApplication(request: RescaleApplicationRequest): RescaleApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RescaleApplication', 'POST', '/', 'json', false, 'json', request);
}

model RescaleDeviceServiceRequest {
  appId?: string(name='AppId', position='Query'),
  imageId?: string(name='ImageId', position='Query'),
  ipType?: int32(name='IpType', position='Query'),
  rescaleLevel: string(name='RescaleLevel', position='Query'),
  rescaleType: string(name='RescaleType', position='Query'),
  resourceInfo?: string(name='ResourceInfo', position='Body'),
  resourceSelector: string(name='ResourceSelector', position='Body'),
  resourceSpec?: string(name='ResourceSpec', position='Query'),
  serviceId?: string(name='ServiceId', position='Query'),
  timeout?: long(name='Timeout', position='Query'),
}

model RescaleDeviceServiceResponseBody = {
  deviceIds?: [ string ](name='DeviceIds'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId', description='Id of the request'),
  resourceDetailInfos?: [ 
    {
      id?: string(name='ID'),
      ip?: string(name='IP'),
      ISP?: string(name='ISP'),
      mac?: string(name='Mac'),
      regionID?: string(name='RegionID'),
      server?: string(name='Server'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='ResourceDetailInfos'),
}

model RescaleDeviceServiceResponse = {
  headers: map[string]string(name='headers'),
  body: RescaleDeviceServiceResponseBody(name='body'),
}

async function rescaleDeviceService(request: RescaleDeviceServiceRequest): RescaleDeviceServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RescaleDeviceService', 'POST', '/', 'json', true, 'form', request);
}

model ResetAICInstanceRequest {
  instanceId?: string(name='InstanceId', position='Query'),
  serverId?: string(name='ServerId', position='Query'),
}

model ResetAICInstanceResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ResetAICInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ResetAICInstanceResponseBody(name='body'),
}

async function resetAICInstance(request: ResetAICInstanceRequest): ResetAICInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetAICInstance', 'GET', '/', 'json', false, 'json', request);
}

model ResetDeviceInstanceRequest {
  appId: string(name='AppId', description='A short description of struct', position='Query'),
  imageId: string(name='ImageId', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
}

model ResetDeviceInstanceResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ResetDeviceInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ResetDeviceInstanceResponseBody(name='body'),
}

async function resetDeviceInstance(request: ResetDeviceInstanceRequest): ResetDeviceInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetDeviceInstance', 'GET', '/', 'json', false, 'json', request);
}

model RestartDeviceInstanceRequest {
  appId: string(name='AppId', description='App ID', position='Query'),
  instanceId: string(name='InstanceId', description='Instance ID', position='Query'),
}

model RestartDeviceInstanceResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model RestartDeviceInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RestartDeviceInstanceResponseBody(name='body'),
}

async function restartDeviceInstance(request: RestartDeviceInstanceRequest): RestartDeviceInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RestartDeviceInstance', 'GET', '/', 'json', false, 'json', request);
}

model RevokeSecurityGroupRequest {
  ipProtocol: string(name='IpProtocol', position='Query'),
  policy?: string(name='Policy', position='Query'),
  portRange: string(name='PortRange', position='Query'),
  priority?: int32(name='Priority', minimum=1, maximum=100, position='Query'),
  securityGroupId: string(name='SecurityGroupId', position='Query'),
  sourceCidrIp: string(name='SourceCidrIp', position='Query'),
  sourcePortRange?: string(name='SourcePortRange', position='Query'),
  version: string(name='Version', position='Query'),
}

model RevokeSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model RevokeSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: RevokeSecurityGroupResponseBody(name='body'),
}

async function revokeSecurityGroup(request: RevokeSecurityGroupRequest): RevokeSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RevokeSecurityGroup', 'POST', '/', 'json', false, 'json', request);
}

model RevokeSecurityGroupEgressRequest {
  destCidrIp: string(name='DestCidrIp', position='Query'),
  ipProtocol: string(name='IpProtocol', position='Query'),
  policy?: string(name='Policy', position='Query'),
  portRange: string(name='PortRange', position='Query'),
  priority?: int32(name='Priority', minimum=1, maximum=100, position='Query'),
  securityGroupId: string(name='SecurityGroupId', position='Query'),
  sourcePortRange?: string(name='SourcePortRange', position='Query'),
  version: string(name='Version', position='Query'),
}

model RevokeSecurityGroupEgressResponseBody = {
  requestId?: string(name='RequestId'),
}

model RevokeSecurityGroupEgressResponse = {
  headers: map[string]string(name='headers'),
  body: RevokeSecurityGroupEgressResponseBody(name='body'),
}

async function revokeSecurityGroupEgress(request: RevokeSecurityGroupEgressRequest): RevokeSecurityGroupEgressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RevokeSecurityGroupEgress', 'POST', '/', 'json', false, 'json', request);
}

model RollbackApplicationRequest {
  appId: string(name='AppId', position='Query'),
  fromAppVersion: string(name='FromAppVersion', position='Query'),
  timeout?: int32(name='Timeout', position='Query'),
  toAppVersion?: string(name='ToAppVersion', position='Query'),
}

model RollbackApplicationResponseBody = {
  requestId?: string(name='RequestId'),
}

model RollbackApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: RollbackApplicationResponseBody(name='body'),
}

async function rollbackApplication(request: RollbackApplicationRequest): RollbackApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RollbackApplication', 'POST', '/', 'json', false, 'json', request);
}

model RunInstancesRequest {
  amount: long(name='Amount', description='数量', minimum=1, maximum=100, position='Query'),
  autoRenew?: boolean(name='AutoRenew', description='是否自动续费，默认为false', position='Query'),
  carrier?: string(name='Carrier', description='运营商', position='Query'),
  dataDisk?: [ 
    {
      category?: string(name='Category'),
      size?: long(name='Size'),
    }
  ](name='DataDisk', description='数据盘规格', shrink='json', position='Query'),
  ensRegionId?: string(name='EnsRegionId', description='节点id', position='Query'),
  hostName?: string(name='HostName', description='主机名称', position='Query'),
  imageId?: string(name='ImageId', description='镜像id', position='Query'),
  instanceChargeType: string(name='InstanceChargeType', description='实例付费方式，PrePaid:预付费，包年包月 PostPaid:按量付费', position='Query'),
  instanceName?: string(name='InstanceName', description='实例名称。长度为2~128个字符，必须以大小字母或中文开头，不能以http://和https://开头。可以包含中文、英文、数字、半角冒号（:）、下划线（_）、点号（.）或者连字符（-）。默认值为实例的InstanceId', position='Query'),
  instanceType: string(name='InstanceType', description='实例规格', position='Query'),
  internetChargeType?: string(name='InternetChargeType', description='带宽计费方式', position='Query'),
  internetMaxBandwidthOut: long(name='InternetMaxBandwidthOut', description='公网最大带宽，如果参数InternetMaxBandwidthOut的值大于0，则自动为实例分配公网IP。', position='Query'),
  keyPairName?: string(name='KeyPairName', description='密钥对名称', position='Query'),
  netDistrictCode?: string(name='NetDistrictCode', description='地区code', position='Query'),
  netWorkId?: string(name='NetWorkId', description='网络id', position='Query'),
  password?: string(name='Password', description='实例密码', position='Query'),
  period?: long(name='Period', description='购买资源的时长，单位为：月', position='Query'),
  periodUnit?: string(name='PeriodUnit', description='查询云服务器ENS不同计费周期的价格。取值范围：
Month（默认）：按月计费的价格单位。
Day：按天计费的价格单位。', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', description='私网ip', position='Query'),
  publicIpIdentification?: boolean(name='PublicIpIdentification', position='Query'),
  scheduleAreaLevel: string(name='ScheduleAreaLevel', description='调度层级', position='Query'),
  schedulingPriceStrategy?: string(name='SchedulingPriceStrategy', description='调度价格策略', position='Query'),
  schedulingStrategy?: string(name='SchedulingStrategy', description='调度策略', position='Query'),
  securityId?: string(name='SecurityId', description='安全组id', position='Query'),
  systemDisk?: {
    size?: long(name='Size'),
  }(name='SystemDisk', description='系统盘规格', shrink='json', position='Query'),
  uniqueSuffix?: boolean(name='UniqueSuffix', description='是否为HostName和InstanceName添加有序后缀，有序后缀从001开始递增，最大不能超过999', position='Query'),
  userData?: string(name='UserData', description='用户自定义数据，最大支持16KB 您可传入UserData信息。UserData以Base64的方式编码', position='Query'),
  vSwitchId?: string(name='VSwitchId', description='交换机id', position='Query'),
}

model RunInstancesResponseBody = {
  instanceIds?: [ string ](name='InstanceIds'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model RunInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: RunInstancesResponseBody(name='body'),
}

async function runInstances(request: RunInstancesRequest): RunInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RunInstances', 'POST', '/', 'json', false, 'json', request);
}

model RunServiceScheduleRequest {
  appId: string(name='AppId', position='Query'),
  clientIp: string(name='ClientIp', position='Query'),
  directorys?: string(name='Directorys', position='Query'),
  podConfigName?: string(name='PodConfigName', position='Query'),
  preLockedTimeout?: int32(name='PreLockedTimeout', position='Query'),
  scheduleStrategy?: string(name='ScheduleStrategy', position='Query'),
  serviceAction: string(name='ServiceAction', position='Query'),
  serviceCommands?: string(name='ServiceCommands', position='Query'),
  uuid: string(name='Uuid', position='Query'),
}

model RunServiceScheduleResponseBody = {
  commandResults?: {
    commandResult?: [ 
    {
      command?: string(name='Command'),
      containerName?: string(name='ContainerName'),
      resultMsg?: string(name='ResultMsg'),
    }
  ](name='CommandResult')
  }(name='CommandResults'),
  index?: int32(name='Index'),
  instanceId?: string(name='InstanceId'),
  instanceIp?: string(name='InstanceIp'),
  instancePort?: int32(name='InstancePort'),
  requestId?: string(name='RequestId'),
  requestRepeated?: string(name='RequestRepeated'),
  tcpPorts?: boolean(name='TcpPorts'),
}

model RunServiceScheduleResponse = {
  headers: map[string]string(name='headers'),
  body: RunServiceScheduleResponseBody(name='body'),
}

async function runServiceSchedule(request: RunServiceScheduleRequest): RunServiceScheduleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RunServiceSchedule', 'POST', '/', 'json', false, 'json', request);
}

model SetBackendServersRequest {
  backendServers: [ 
    {
      serverId: string(name='ServerId'),
      type?: string(name='Type', description='后端服务器类型。  ens：ENS实例（默认）'),
      weight: int32(name='Weight', description='后端服务器的权重。  取值：0~100  默认值为100，如果值为0，则不会将请求转发给该后端服务器。', minimum=0, maximum=100),
    }
  ](name='BackendServers', shrink='json', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
}

model SetBackendServersResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      ip?: string(name='Ip'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SetBackendServersResponse = {
  headers: map[string]string(name='headers'),
  body: SetBackendServersResponseBody(name='body'),
}

async function setBackendServers(request: SetBackendServersRequest): SetBackendServersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetBackendServers', 'POST', '/', 'json', false, 'json', request);
}

model SetLoadBalancerHTTPListenerAttributeRequest {
  description?: string(name='Description', description='设置监听的描述信息。  长度限制为1-80个字符，允许包含字母、数字、“-”、“/”、“.”和“_”等字符。支持中文描述。', minLength=1, maxLength=80, position='Query'),
  healthCheck?: string(name='HealthCheck', description='是否开启健康检查。  取值：on | off。', position='Query'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='健康检查的后端服务器的端口。  取值： 1~65535。    说明 在HealthCheck值为on时才会有效。', minimum=1, maximum=65535, position='Query'),
  healthCheckDomain?: string(name='HealthCheckDomain', description='用于健康检查的域名，取值：  $_ip： 后端服务器的私网IP。当指定了IP或该参数未指定时，负载均衡会使用各后端服务器的私网IP当做健康检查使用的域名。是否要支持？ domain：域名长度为1-80字符，只能包含字母、数字、点号（.）和连字符（-）。   说明 在HealthCheck值为on时才会有效。', minLength=1, maxLength=80, position='Query'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode', description='健康检查正常的HTTP状态码，多个状态码用逗号分隔。  默认值为http_2xx。  取值：http_2xx | http_3xx | http_4xx | http_5xx。   说明 在HealthCheck值为on时才会有效。', position='Query'),
  healthCheckInterval?: int32(name='HealthCheckInterval', description='健康检查的时间间隔。  取值： 1~50（秒）。   说明 在HealthCheck值为on时才会有效。', minimum=1, maximum=50, position='Query'),
  healthCheckMethod?: string(name='HealthCheckMethod', position='Query'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout', description='接收来自运行状况检查的响应需要等待的时间。如果后端ECS在指定的时间内没有正确响应，则判定为健康检查失败。在HealthCheck值为on时才会有效。  取值：1~300（秒）。   说明 如果HealthCHeckTimeout的值小于HealthCheckInterval的值，则HealthCHeckTimeout无效，超时时间为HealthCheckInterval的值。', minimum=1, maximum=300, position='Query'),
  healthCheckURI?: string(name='HealthCheckURI', description='用于健康检查的URI。  长度限制为1~80，只能使用字母、数字和”-/.%?#&amp;“这些字符。 URL不能只为”/“，但必须以”/“开头。    说明 在HealthCheck值为on时才会有效。', minLength=1, maxLength=80, position='Query'),
  healthyThreshold?: int32(name='HealthyThreshold', description='健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success。  取值：2~10。    说明 在HealthCheck值为on时才会有效。', minimum=2, maximum=10, position='Query'),
  idleTimeout?: int32(name='IdleTimeout', description='指定连接空闲超时时间，取值范围为1~60秒，默认值为15秒。  在超时时间内一直没有访问请求，负载均衡会暂时中断当前连接，直到一下次请求来临时重新建立新的连接。', minimum=1, maximum=60, position='Query'),
  listenerPort: int32(name='ListenerPort', description='负载均衡实例前端使用的端口。  取值：1-65535。', minimum=1, maximum=65535, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', description='负载均衡实例的ID。', position='Query'),
  requestTimeout?: int32(name='RequestTimeout', description='指定请求超时时间，取值范围为1~180秒，默认值为60秒。  在超时时间内后端服务器一直没有响应，负载均衡将放弃等待，给客户端返回 HTTP 504 错误码。', minimum=1, maximum=180, position='Query'),
  scheduler?: string(name='Scheduler', description='调度算法。取值：  wrr（默认值）：权重值越高的后端服务器，被轮询到的次数（概率）也越高。 wlc：除了根据每台后端服务器设定的权重值来进行轮询，同时还考虑后端服务器的实际负载（即连接数）。当权重值相同时，当前连接数越小的后端服务器被轮询到的次数（概率）也越高。 rr：按照访问顺序依次将外部请求依序分发到后端服务器。', position='Query'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', description='健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail。  取值：2~10。   说明 在HealthCheck值为on时才会有效。', minimum=2, maximum=10, position='Query'),
}

model SetLoadBalancerHTTPListenerAttributeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SetLoadBalancerHTTPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerHTTPListenerAttributeResponseBody(name='body'),
}

async function setLoadBalancerHTTPListenerAttribute(request: SetLoadBalancerHTTPListenerAttributeRequest): SetLoadBalancerHTTPListenerAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLoadBalancerHTTPListenerAttribute', 'POST', '/', 'json', false, 'json', request);
}

model SetLoadBalancerHTTPSListenerAttributeRequest {
  description?: string(name='Description', description='设置监听的描述信息。  长度限制为1-80个字符，允许包含字母、数字、“-”、“/”、“.”和“_”等字符。支持中文描述。', minLength=1, maxLength=80, position='Query'),
  healthCheck?: string(name='HealthCheck', description='是否开启健康检查。  取值：on | off。', position='Query'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='健康检查的后端服务器的端口。  取值： 1~65535。    说明 在HealthCheck值为on时才会有效。', minimum=1, maximum=65535, position='Query'),
  healthCheckDomain?: string(name='HealthCheckDomain', description='用于健康检查的域名，取值：  $_ip： 后端服务器的私网IP。当指定了IP或该参数未指定时，负载均衡会使用各后端服务器的私网IP当做健康检查使用的域名。是否要支持？ domain：域名长度为1-80字符，只能包含字母、数字、点号（.）和连字符（-）。   说明 在HealthCheck值为on时才会有效。', minLength=1, maxLength=80, position='Query'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode', description='健康检查正常的HTTP状态码，多个状态码用逗号分隔。  默认值为http_2xx。  取值：http_2xx | http_3xx | http_4xx | http_5xx。   说明 在HealthCheck值为on时才会有效。', position='Query'),
  healthCheckInterval?: int32(name='HealthCheckInterval', description='健康检查的时间间隔。  取值： 1~50（秒）。   说明 在HealthCheck值为on时才会有效。', minimum=1, maximum=50, position='Query'),
  healthCheckMethod?: string(name='HealthCheckMethod', position='Query'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout', description='接收来自运行状况检查的响应需要等待的时间。如果后端ECS在指定的时间内没有正确响应，则判定为健康检查失败。在HealthCheck值为on时才会有效。  取值：1~300（秒）。   说明 如果HealthCHeckTimeout的值小于HealthCheckInterval的值，则HealthCHeckTimeout无效，超时时间为HealthCheckInterval的值。', minimum=1, maximum=300, position='Query'),
  healthCheckURI?: string(name='HealthCheckURI', description='用于健康检查的URI。  长度限制为1~80，只能使用字母、数字和”-/.%?#&amp;“这些字符。 URL不能只为”/“，但必须以”/“开头。    说明 在HealthCheck值为on时才会有效。', minLength=1, maxLength=80, position='Query'),
  healthyThreshold?: int32(name='HealthyThreshold', description='健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success。  取值：2~10。    说明 在HealthCheck值为on时才会有效。', minimum=2, maximum=10, position='Query'),
  idleTimeout?: int32(name='IdleTimeout', description='指定连接空闲超时时间，取值范围为1~60秒，默认值为15秒。  在超时时间内一直没有访问请求，负载均衡会暂时中断当前连接，直到一下次请求来临时重新建立新的连接。', minimum=1, maximum=60, position='Query'),
  listenerPort: int32(name='ListenerPort', description='负载均衡实例前端使用的端口。  取值：1-65535。', minimum=1, maximum=65535, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', description='负载均衡实例的ID。', position='Query'),
  requestTimeout?: int32(name='RequestTimeout', description='指定请求超时时间，取值范围为1~180秒，默认值为60秒。  在超时时间内后端服务器一直没有响应，负载均衡将放弃等待，给客户端返回 HTTP 504 错误码。', minimum=1, maximum=180, position='Query'),
  scheduler?: string(name='Scheduler', description='调度算法。取值：  wrr（默认值）：权重值越高的后端服务器，被轮询到的次数（概率）也越高。 wlc：除了根据每台后端服务器设定的权重值来进行轮询，同时还考虑后端服务器的实际负载（即连接数）。当权重值相同时，当前连接数越小的后端服务器被轮询到的次数（概率）也越高。 rr：按照访问顺序依次将外部请求依序分发到后端服务器。', position='Query'),
  serverCertificateId?: string(name='ServerCertificateId', description='服务器证书的ID。', position='Query'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', description='健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail。  取值：2~10。   说明 在HealthCheck值为on时才会有效。', minimum=2, maximum=10, position='Query'),
}

model SetLoadBalancerHTTPSListenerAttributeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SetLoadBalancerHTTPSListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerHTTPSListenerAttributeResponseBody(name='body'),
}

async function setLoadBalancerHTTPSListenerAttribute(request: SetLoadBalancerHTTPSListenerAttributeRequest): SetLoadBalancerHTTPSListenerAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLoadBalancerHTTPSListenerAttribute', 'POST', '/', 'json', false, 'json', request);
}

model SetLoadBalancerStatusRequest {
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  loadBalancerStatus: string(name='LoadBalancerStatus', position='Query'),
}

model SetLoadBalancerStatusResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SetLoadBalancerStatusResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerStatusResponseBody(name='body'),
}

async function setLoadBalancerStatus(request: SetLoadBalancerStatusRequest): SetLoadBalancerStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLoadBalancerStatus', 'POST', '/', 'json', false, 'json', request);
}

model SetLoadBalancerTCPListenerAttributeRequest {
  description?: string(name='Description', description='设置监听的描述信息。  长度限制为1-80个字符，允许包含字母、数字、“-”、“/”、“.”和“_”等字符。支持中文描述。', minLength=1, maxLength=80, position='Query'),
  eipTransmit?: string(name='EipTransmit', position='Query'),
  establishedTimeout?: int32(name='EstablishedTimeout', description='连接超时时间。  取值：10~900（秒）。', minimum=10, maximum=900, position='Query'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='健康检查使用的端口。  取值：1~65535。  不设置此参数时，表示使用后端服务端口（BackendServerPort）。', minimum=1, maximum=65535, position='Query'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', description='每次健康检查响应的最大超时时间。  取值：1~300（秒）。  默认值：5。', minimum=1, maximum=300, position='Query'),
  healthCheckDomain?: string(name='HealthCheckDomain', description='用于健康检查的域名', minLength=1, maxLength=80, position='Query'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode', description='健康检查正常的HTTP状态码，多个状态码用逗号（,）分割。  取值：http_2xx（默认值） | http_3xx | http_4xx | http_5xx。', position='Query'),
  healthCheckInterval?: int32(name='HealthCheckInterval', description='健康检查的时间间隔。  取值：1~50（秒）。', minimum=1, maximum=50, position='Query'),
  healthCheckType?: string(name='HealthCheckType', description='健康检查类型。  取值：tcp（默认值） | http。', position='Query'),
  healthCheckURI?: string(name='HealthCheckURI', description='用于健康检查的URI。长度限制为1~80，只能使用字母、数字、短横线（-）、正斜杠（/）、点号（.）、百分号（%）、#和&amp;这些字符。 URL不能只为/，但必须以/开头。  当TCP监听需要使用HTTP健康检查时可配置此参数，如不配置则按TCP健康检查。', minLength=1, maxLength=80, position='Query'),
  healthyThreshold?: int32(name='HealthyThreshold', description='健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success。  取值： 2~10。', minimum=2, maximum=10, position='Query'),
  listenerPort: int32(name='ListenerPort', description='负载均衡实例前端使用的端口。  取值：1-65535。', minimum=1, maximum=65535, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', description='负载均衡实例的ID。', position='Query'),
  persistenceTimeout?: int32(name='PersistenceTimeout', description='会话保持的超时时间。  取值：0~3600（秒）。  默认值：0，表示关闭会话保持。', minimum=0, maximum=3600, position='Query'),
  scheduler?: string(name='Scheduler', description='度算法。取值：  wrr（默认值）：权重值越高的后端服务器，被轮询到的次数（概率）也越高。 wlc：除了根据每台后端服务器设定的权重值来进行轮询，同时还考虑后端服务器的实际负载（即连接数）。当权重值相同时，当前连接数越小的后端服务器被轮询到的次数（概率）也越高。 rr：按照访问顺序依次将外部请求依序分发到后端服务器。 sch：基于源IP地址的一致性hash，相同的源地址会调度到相同的后端服务器。', position='Query'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', description='健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail。  取值：2~10。', minimum=2, maximum=10, position='Query'),
}

model SetLoadBalancerTCPListenerAttributeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SetLoadBalancerTCPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerTCPListenerAttributeResponseBody(name='body'),
}

async function setLoadBalancerTCPListenerAttribute(request: SetLoadBalancerTCPListenerAttributeRequest): SetLoadBalancerTCPListenerAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLoadBalancerTCPListenerAttribute', 'POST', '/', 'json', false, 'json', request);
}

model SetLoadBalancerUDPListenerAttributeRequest {
  description?: string(name='Description', description='设置监听的描述信息。  长度限制为1-80个字符，允许包含字母、数字、“-”、“/”、“.”和“_”等字符。支持中文描述。', minLength=1, maxLength=80, position='Query'),
  eipTransmit?: string(name='EipTransmit', position='Query'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='健康检查使用的端口。取值：1-65535  不设置此参数时，表示使用后端服务端口（BackendServerPort）', minimum=1, maximum=65535, position='Query'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', description='接收来自运行状况检查的响应需要等待的时间。  如果后端ENS在指定的时间内没有正确响应，则判定为健康检查失败。  取值：1-300（秒）。默认为5秒', minimum=1, maximum=300, position='Query'),
  healthCheckExp?: string(name='HealthCheckExp', description='UDP监听健康检查的响应串，只允许包含字母、数字，最大长度限制为64个字符。', maxLength=64, position='Query'),
  healthCheckInterval?: int32(name='HealthCheckInterval', description='健康检查的时间间隔。  取值：1-50（秒）。', minimum=1, maximum=50, position='Query'),
  healthCheckReq?: string(name='HealthCheckReq', description='UDP监听健康检查的请求串，只允许包含字母、数字，最大长度限制为64个字符。', maxLength=64, position='Query'),
  healthyThreshold?: int32(name='HealthyThreshold', description='健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success。  取值：2-10。', minimum=2, maximum=10, position='Query'),
  listenerPort: int32(name='ListenerPort', description='负载均衡实例前端使用的端口。  取值：1-65535。', minimum=1, maximum=65535, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', description='负载均衡实例的ID。', position='Query'),
  scheduler?: string(name='Scheduler', description='调度算法。取值：  wrr（默认值）：权重值越高的后端服务器，被轮询到的次数（概率）也越高。 wlc：除了根据每台后端服务器设定的权重值来进行轮询，同时还考虑后端服务器的实际负载（即连接数）。当权重值相同时，当前连接数越小的后端服务器被轮询到的次数（概率）也越高。 rr：按照访问顺序依次将外部请求依序分发到后端服务器。 sch：基于源IP地址的一致性hash，相同的源地址会调度到相同的后端服务器。', position='Query'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', description='健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail。  取值：2-10。', minimum=2, maximum=10, position='Query'),
}

model SetLoadBalancerUDPListenerAttributeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SetLoadBalancerUDPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerUDPListenerAttributeResponseBody(name='body'),
}

async function setLoadBalancerUDPListenerAttribute(request: SetLoadBalancerUDPListenerAttributeRequest): SetLoadBalancerUDPListenerAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLoadBalancerUDPListenerAttribute', 'POST', '/', 'json', false, 'json', request);
}

model StartEpnInstanceRequest {
  EPNInstanceId: string(name='EPNInstanceId', position='Query'),
}

model StartEpnInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartEpnInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StartEpnInstanceResponseBody(name='body'),
}

async function startEpnInstance(request: StartEpnInstanceRequest): StartEpnInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartEpnInstance', 'POST', '/', 'json', false, 'json', request);
}

model StartInstanceRequest {
  instanceId: string(name='InstanceId', position='Query'),
}

model StartInstanceResponseBody = {
  code?: int32(name='Code'),
  requestId?: string(name='RequestId'),
}

model StartInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StartInstanceResponseBody(name='body'),
}

async function startInstance(request: StartInstanceRequest): StartInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartInstance', 'POST', '/', 'json', false, 'json', request);
}

model StartLoadBalancerListenerRequest {
  listenerPort: int32(name='ListenerPort', minimum=0, maximum=65535, position='Query'),
  listenerProtocol?: string(name='ListenerProtocol', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
}

model StartLoadBalancerListenerResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model StartLoadBalancerListenerResponse = {
  headers: map[string]string(name='headers'),
  body: StartLoadBalancerListenerResponseBody(name='body'),
}

async function startLoadBalancerListener(request: StartLoadBalancerListenerRequest): StartLoadBalancerListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartLoadBalancerListener', 'POST', '/', 'json', false, 'json', request);
}

model StopEpnInstanceRequest {
  EPNInstanceId: string(name='EPNInstanceId', position='Query'),
}

model StopEpnInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopEpnInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StopEpnInstanceResponseBody(name='body'),
}

async function stopEpnInstance(request: StopEpnInstanceRequest): StopEpnInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopEpnInstance', 'POST', '/', 'json', false, 'json', request);
}

model StopInstanceRequest {
  forceStop?: string(name='ForceStop', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  version: string(name='Version', position='Query'),
}

model StopInstanceResponseBody = {
  code?: int32(name='Code'),
  requestId?: string(name='RequestId'),
}

model StopInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StopInstanceResponseBody(name='body'),
}

async function stopInstance(request: StopInstanceRequest): StopInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopInstance', 'POST', '/', 'json', false, 'json', request);
}

model StopLoadBalancerListenerRequest {
  listenerPort: int32(name='ListenerPort', minimum=0, maximum=65535, position='Query'),
  listenerProtocol?: string(name='ListenerProtocol', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
}

model StopLoadBalancerListenerResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model StopLoadBalancerListenerResponse = {
  headers: map[string]string(name='headers'),
  body: StopLoadBalancerListenerResponseBody(name='body'),
}

async function stopLoadBalancerListener(request: StopLoadBalancerListenerRequest): StopLoadBalancerListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopLoadBalancerListener', 'POST', '/', 'json', false, 'json', request);
}

model UnAssociateEnsEipAddressRequest {
  allocationId: string(name='AllocationId', position='Query'),
}

model UnAssociateEnsEipAddressResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UnAssociateEnsEipAddressResponse = {
  headers: map[string]string(name='headers'),
  body: UnAssociateEnsEipAddressResponseBody(name='body'),
}

async function unAssociateEnsEipAddress(request: UnAssociateEnsEipAddressRequest): UnAssociateEnsEipAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnAssociateEnsEipAddress', 'POST', '/', 'json', false, 'json', request);
}

model UnassignPrivateIpAddressesRequest {
  networkInterfaceId: string(name='NetworkInterfaceId', position='Query'),
  privateIpAddress: [ string ](name='PrivateIpAddress', position='Query'),
}

model UnassignPrivateIpAddressesResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UnassignPrivateIpAddressesResponse = {
  headers: map[string]string(name='headers'),
  body: UnassignPrivateIpAddressesResponseBody(name='body'),
}

async function unassignPrivateIpAddresses(request: UnassignPrivateIpAddressesRequest): UnassignPrivateIpAddressesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnassignPrivateIpAddresses', 'POST', '/', 'json', false, 'json', request);
}

model UpgradeAICInstanceImageRequest {
  imageId?: string(name='ImageId', position='Query'),
  serverIds?: [ string ](name='ServerIds', shrink='json', position='Query'),
  timeout?: int32(name='Timeout', position='Query'),
}

model UpgradeAICInstanceImageResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpgradeAICInstanceImageResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeAICInstanceImageResponseBody(name='body'),
}

async function upgradeAICInstanceImage(request: UpgradeAICInstanceImageRequest): UpgradeAICInstanceImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpgradeAICInstanceImage', 'GET', '/', 'json', false, 'json', request);
}

model UpgradeApplicationRequest {
  appId: string(name='AppId', position='Query'),
  template: string(name='Template', position='Query'),
  timeout?: int32(name='Timeout', position='Query'),
}

model UpgradeApplicationResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpgradeApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeApplicationResponseBody(name='body'),
}

async function upgradeApplication(request: UpgradeApplicationRequest): UpgradeApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpgradeApplication', 'POST', '/', 'json', false, 'json', request);
}

