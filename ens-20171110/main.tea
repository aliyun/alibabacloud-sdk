/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('ens', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model BucketInfo {
  bucketAcl?: string(name='BucketAcl', description='Bucket读写权限类型： public-read-write：公共读写 public-read：公共读 private：私有（默认值）'),
  bucketName?: string(name='BucketName', description='Bucket名称。 3~50 个字符，只允许小写字母、数字、短横线（-），且不能以短横线开头或结尾。'),
  comment?: string(name='Comment', description='备注。 1-128个字符或汉字，UTF-8编码。'),
  createTime?: string(name='CreateTime', description='Bucket创建时间。 （格式：yyyy-mm-ddThh:mm:ss.timezone, 例如 2011-12-01T12:27:13.000Z）'),
  dataRedundancyType?: string(name='DataRedundancyType', description='指定Bucket的数据容灾类型。 取值范围： LRS（默认值）。本地冗余LRS ZRS 同城冗余ZRS采用多可用区（AZ）机制。'),
  dispatcherType?: string(name='DispatcherType', description='Bucket的调度类型： node：节点(同城) area：区域(多城市) global：全局(全国)'),
  endpoint?: string(name='Endpoint', description='访问域名，边缘存储取值： eos.aliyuncs.com'),
  ensRegionId?: string(name='EnsRegionId', description='节点区域id，如果为空表示全局'),
  modifyTime?: string(name='ModifyTime', description='Bucket修改时间。 （格式：yyyy-mm-ddThh:mm:ss.timezone, 例如 2011-12-01T12:27:13.000Z）'),
  resourceType?: string(name='ResourceType', description='指定Bucket的资源类型。 取值范围： general：通用 national-network：国网'),
  storageClass?: string(name='StorageClass', description='Bucket存储类型，支持Standard'),
}

model DataDisk {
  size?: long(name='Size', description='数据盘'),
}

model HealthCheck {
  healthCheck?: string(name='HealthCheck', description='是否开启健康检查。  取值：on | off。'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='健康检查的后端服务器的端口。  取值： 1~65535。    说明 在HealthCheck值为on时才会有效。'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', description='每次健康检查响应的最大超时时间。  取值：1~300（秒）。  默认值：5。'),
  healthCheckDomain?: string(name='HealthCheckDomain', description='用于健康检查的域名，取值：  $_ip： 后端服务器的私网IP。当指定了IP或该参数未指定时，负载均衡会使用各后端服务器的私网IP当做健康检查使用的域名。是否要支持？ domain：域名长度为1-80字符，只能包含字母、数字、点号（.）和连字符（-）。   说明 在HealthCheck值为on时才会有效。'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode', description='健康检查正常的HTTP状态码，多个状态码用逗号分隔。  默认值为http_2xx。  取值：http_2xx | http_3xx | http_4xx | http_5xx。   说明 在HealthCheck值为on时才会有效。'),
  healthCheckInterval?: int32(name='HealthCheckInterval', description='健康检查的时间间隔。  取值： 1~50（秒）。   说明 在HealthCheck值为on时才会有效。'),
  healthCheckMethod?: string(name='HealthCheckMethod', description='健康检查的method'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout', description='接收来自运行状况检查的响应需要等待的时间。如果后端ECS在指定的时间内没有正确响应，则判定为健康检查失败。在HealthCheck值为on时才会有效。  取值：1~300（秒）。   说明 如果HealthCHeckTimeout的值小于HealthCheckInterval的值，则HealthCHeckTimeout无效，超时时间为HealthCheckInterval的值。'),
  healthCheckType?: string(name='HealthCheckType', description='健康检查类型。  取值：tcp（默认值） | http。'),
  healthCheckURI?: string(name='HealthCheckURI', description='用于健康检查的URI。  长度限制为1~80，只能使用字母、数字和”-/.%?#&amp;“这些字符。 URL不能只为”/“，但必须以”/“开头。    说明 在HealthCheck值为on时才会有效。'),
  healthyThreshold?: int32(name='HealthyThreshold', description='健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success。  取值：2~10。    说明 在HealthCheck值为on时才会有效。'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', description='健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail。  取值：2~10。   说明 在HealthCheck值为on时才会有效。'),
}

model HttpConfig {
  cookie?: string(name='Cookie', description='服务器上配置的Cookie。 长度为1-200，只能包含ASCII英文字母和数字字符，不能包含逗号、分号或空格，也不能以$开头。 说明 当StickySession为on且StickySessionType为server时，该参数必选。'),
  cookieTimeout?: int32(name='CookieTimeout', description='Cookie超时时间。  取值：1~86400（秒）。   说明 当StickySession为on且StickySessionType为insert时，该参数必选。'),
  idleTimeout?: int32(name='IdleTimeout', description='指定连接空闲超时时间，取值范围为1~60秒，默认值为15秒。  在超时时间内一直没有访问请求，负载均衡会暂时中断当前连接，直到一下次请求来临时重新建立新的连接。'),
  requestTimeout?: int32(name='RequestTimeout', description='指定请求超时时间，取值范围为1~180秒，默认值为60秒。  在超时时间内后端服务器一直没有响应，负载均衡将放弃等待，给客户端返回 HTTP 504 错误码。'),
  scheduler?: string(name='Scheduler', description='调度算法。取值：  wrr（默认值）：权重值越高的后端服务器，被轮询到的次数（概率）也越高。 wlc：除了根据每台后端服务器设定的权重值来进行轮询，同时还考虑后端服务器的实际负载（即连接数）。当权重值相同时，当前连接数越小的后端服务器被轮询到的次数（概率）也越高。 rr：按照访问顺序依次将外部请求依序分发到后端服务器。'),
  serverCertificateId?: string(name='ServerCertificateId', description='服务器证书的ID。'),
  stickySession?: string(name='StickySession', description='是否开启会话保持。  取值：on | off。'),
  stickySessionType?: string(name='StickySessionType', description='cookie的处理方式。取值：  insert：植入Cookie。  客户端第一次访问时，负载均衡会在返回请求中植入Cookie（即在HTTP/HTTPS响应报文中插入SERVERID），下次客户端携带此Cookie访问，负载均衡服务会将请求定向转发给之前记录到的后端服务器上。  server：重写Cookie。  负载均衡发现用户自定义了Cookie，将会对原来的Cookie进行重写，下次客户端携带新的Cookie访问，负载均衡服务会将请求定向转发给之前记录到的后端服务器。   说明 当StickySession的值为on时，必须指定该参数。'),
  XForwardedFor?: string(name='XForwardedFor', description='是否开启通过X-Forwarded-For头字段获取来访者真实 IP。  取值为on。'),
}

model SecurityGroupRule {
  description?: string(name='Description', description='描述'),
  destCidrIp?: string(name='DestCidrIp', description='目标网段'),
  direction?: string(name='Direction', description='方向'),
  ipProtocol?: string(name='IpProtocol', description='协议'),
  policy?: string(name='Policy', description='授权策略'),
  portRange?: string(name='PortRange', description='目的端口'),
  sourceCidrIp?: string(name='SourceCidrIp', description='源网段'),
  sourcePortRange?: string(name='SourcePortRange', description='源端口'),
  priority?: int32(name='priority', description='优先级'),
}

model TcpConfig {
  establishedTimeout?: int32(name='EstablishedTimeout', description='连接超时时间。取值：10~900（秒）。'),
  persistenceTimeout?: int32(name='PersistenceTimeout', description='会话保持的超时时间。取值：0~3600（秒）。默认值：0，表示关闭会话保持。'),
  scheduler?: string(name='Scheduler', description='调度算法。取值：wrr（默认值）：权重值越高的后端服务器，被轮询到的次数（概率）也越高。wlc：除了根据每台后端服务器设定的权重值来进行轮询，同时还考虑后端服务器的实际负载（即连接数）。当权重值相同时，当前连接数越小的后端服务器被轮询到的次数（概率）也越高。rr：按照访问顺序依次将外部请求依序分发到后端服务器。sch：基于源IP地址的一致性hash，相同的源地址会调度到相同的后端服务器。'),
}

model UdpCheck {
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='健康检查使用的端口。取值：1-65535  不设置此参数时，表示使用后端服务端口（BackendServerPort）。'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', description='接收来自运行状况检查的响应需要等待的时间。  如果后端ENS在指定的时间内没有正确响应，则判定为健康检查失败。  取值：1-300（秒）。默认为5秒'),
  healthCheckInterval?: int32(name='HealthCheckInterval', description='健康检查的时间间隔。  取值：1-50（秒）。'),
  healthyThreshold?: int32(name='HealthyThreshold', description='健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success。  取值：2-10。'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', description='健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail。  取值：2-10。'),
}

model UdpConfig {
  hashKey?: string(name='HashKey', description='hash key'),
  scheduler?: string(name='Scheduler', description='调度算法。取值：  wrr（默认值）：权重值越高的后端服务器，被轮询到的次数（概率）也越高。 wlc：除了根据每台后端服务器设定的权重值来进行轮询，同时还考虑后端服务器的实际负载（即连接数）。当权重值相同时，当前连接数越小的后端服务器被轮询到的次数（概率）也越高。 rr：按照访问顺序依次将外部请求依序分发到后端服务器。 sch：基于源IP地址的一致性hash，相同的源地址会调度到相同的后端服务器。'),
}

model AddBackendServersRequest {
  backendServers?: [ 
    {
      ip?: string(name='Ip'),
      port?: int32(name='Port', description='端口'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type', description='后端服务器类型。  ens：ENS实例（默认）'),
      weight?: int32(name='Weight', description='后端服务器的权重。  取值：0~100  默认值为100，如果值为0，则不会将请求转发给该后端服务器。'),
    }
  ](name='BackendServers'),
  loadBalancerId?: string(name='LoadBalancerId'),
}

model AddBackendServersShrinkRequest {
  backendServersShrink?: string(name='BackendServers'),
  loadBalancerId?: string(name='LoadBalancerId'),
}

model AddBackendServersResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      ip?: string(name='Ip'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AddBackendServersResponse = {
  headers: map[string]string(name='headers'),
  body: AddBackendServersResponseBody(name='body'),
}

async function addBackendServersWithOptions(tmpReq: AddBackendServersRequest, runtime: Util.RuntimeOptions): AddBackendServersResponse {
  Util.validateModel(tmpReq);
  var request = new AddBackendServersShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.backendServers)) {
    request.backendServersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.backendServers, 'BackendServers', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.backendServersShrink)) {
    query['BackendServers'] = request.backendServersShrink;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddBackendServers',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addBackendServers(request: AddBackendServersRequest): AddBackendServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return addBackendServersWithOptions(request, runtime);
}

model AddDeviceInternetPortRequest {
  ISP?: string(name='ISP'),
  instanceId?: string(name='InstanceId', description='实例ID'),
  internalIp?: string(name='InternalIp'),
  internalPort?: string(name='InternalPort'),
  natType?: string(name='NatType'),
  regionId?: string(name='RegionId'),
}

model AddDeviceInternetPortResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  ruleIds?: [ string ](name='RuleIds', description='RuleIds'),
}

model AddDeviceInternetPortResponse = {
  headers: map[string]string(name='headers'),
  body: AddDeviceInternetPortResponseBody(name='body'),
}

async function addDeviceInternetPortWithOptions(request: AddDeviceInternetPortRequest, runtime: Util.RuntimeOptions): AddDeviceInternetPortResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDeviceInternetPort',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDeviceInternetPort(request: AddDeviceInternetPortRequest): AddDeviceInternetPortResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDeviceInternetPortWithOptions(request, runtime);
}

model AddNetworkInterfaceToInstanceRequest {
  autoStart?: boolean(name='AutoStart'),
  instanceId?: string(name='InstanceId'),
  networks?: string(name='Networks'),
}

model AddNetworkInterfaceToInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddNetworkInterfaceToInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: AddNetworkInterfaceToInstanceResponseBody(name='body'),
}

async function addNetworkInterfaceToInstanceWithOptions(request: AddNetworkInterfaceToInstanceRequest, runtime: Util.RuntimeOptions): AddNetworkInterfaceToInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoStart)) {
    query['AutoStart'] = request.autoStart;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.networks)) {
    query['Networks'] = request.networks;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddNetworkInterfaceToInstance',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addNetworkInterfaceToInstance(request: AddNetworkInterfaceToInstanceRequest): AddNetworkInterfaceToInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addNetworkInterfaceToInstanceWithOptions(request, runtime);
}

model AssociateEnsEipAddressRequest {
  allocationId?: string(name='AllocationId'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
}

model AssociateEnsEipAddressResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AssociateEnsEipAddressResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateEnsEipAddressResponseBody(name='body'),
}

async function associateEnsEipAddressWithOptions(request: AssociateEnsEipAddressRequest, runtime: Util.RuntimeOptions): AssociateEnsEipAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allocationId)) {
    query['AllocationId'] = request.allocationId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AssociateEnsEipAddress',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function associateEnsEipAddress(request: AssociateEnsEipAddressRequest): AssociateEnsEipAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateEnsEipAddressWithOptions(request, runtime);
}

model AttachDiskRequest {
  deleteWithInstance?: string(name='DeleteWithInstance'),
  diskId?: string(name='DiskId'),
  instanceId?: string(name='InstanceId'),
}

model AttachDiskResponseBody = {
  code?: int32(name='Code'),
  requestId?: string(name='RequestId'),
}

model AttachDiskResponse = {
  headers: map[string]string(name='headers'),
  body: AttachDiskResponseBody(name='body'),
}

async function attachDiskWithOptions(request: AttachDiskRequest, runtime: Util.RuntimeOptions): AttachDiskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deleteWithInstance)) {
    query['DeleteWithInstance'] = request.deleteWithInstance;
  }
  if (!Util.isUnset(request.diskId)) {
    query['DiskId'] = request.diskId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachDisk',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachDisk(request: AttachDiskRequest): AttachDiskResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachDiskWithOptions(request, runtime);
}

model AttachEnsInstancesRequest {
  instanceId?: string(name='InstanceId'),
  scripts?: string(name='Scripts'),
  version?: string(name='Version'),
}

model AttachEnsInstancesResponseBody = {
  requestId?: string(name='RequestId'),
}

model AttachEnsInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: AttachEnsInstancesResponseBody(name='body'),
}

async function attachEnsInstancesWithOptions(request: AttachEnsInstancesRequest, runtime: Util.RuntimeOptions): AttachEnsInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.scripts)) {
    query['Scripts'] = request.scripts;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachEnsInstances',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachEnsInstances(request: AttachEnsInstancesRequest): AttachEnsInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachEnsInstancesWithOptions(request, runtime);
}

model AuthorizeSecurityGroupRequest {
  ipProtocol?: string(name='IpProtocol'),
  policy?: string(name='Policy'),
  portRange?: string(name='PortRange'),
  priority?: int32(name='Priority'),
  securityGroupId?: string(name='SecurityGroupId'),
  sourceCidrIp?: string(name='SourceCidrIp'),
  sourcePortRange?: string(name='SourcePortRange'),
  version?: string(name='Version'),
}

model AuthorizeSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model AuthorizeSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AuthorizeSecurityGroupResponseBody(name='body'),
}

async function authorizeSecurityGroupWithOptions(request: AuthorizeSecurityGroupRequest, runtime: Util.RuntimeOptions): AuthorizeSecurityGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ipProtocol)) {
    query['IpProtocol'] = request.ipProtocol;
  }
  if (!Util.isUnset(request.policy)) {
    query['Policy'] = request.policy;
  }
  if (!Util.isUnset(request.portRange)) {
    query['PortRange'] = request.portRange;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.sourceCidrIp)) {
    query['SourceCidrIp'] = request.sourceCidrIp;
  }
  if (!Util.isUnset(request.sourcePortRange)) {
    query['SourcePortRange'] = request.sourcePortRange;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AuthorizeSecurityGroup',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function authorizeSecurityGroup(request: AuthorizeSecurityGroupRequest): AuthorizeSecurityGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return authorizeSecurityGroupWithOptions(request, runtime);
}

model AuthorizeSecurityGroupEgressRequest {
  destCidrIp?: string(name='DestCidrIp'),
  ipProtocol?: string(name='IpProtocol'),
  policy?: string(name='Policy'),
  portRange?: string(name='PortRange'),
  priority?: int32(name='Priority'),
  securityGroupId?: string(name='SecurityGroupId'),
  sourcePortRange?: string(name='SourcePortRange'),
  version?: string(name='Version'),
}

model AuthorizeSecurityGroupEgressResponseBody = {
  requestId?: string(name='RequestId'),
}

model AuthorizeSecurityGroupEgressResponse = {
  headers: map[string]string(name='headers'),
  body: AuthorizeSecurityGroupEgressResponseBody(name='body'),
}

async function authorizeSecurityGroupEgressWithOptions(request: AuthorizeSecurityGroupEgressRequest, runtime: Util.RuntimeOptions): AuthorizeSecurityGroupEgressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.destCidrIp)) {
    query['DestCidrIp'] = request.destCidrIp;
  }
  if (!Util.isUnset(request.ipProtocol)) {
    query['IpProtocol'] = request.ipProtocol;
  }
  if (!Util.isUnset(request.policy)) {
    query['Policy'] = request.policy;
  }
  if (!Util.isUnset(request.portRange)) {
    query['PortRange'] = request.portRange;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.sourcePortRange)) {
    query['SourcePortRange'] = request.sourcePortRange;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AuthorizeSecurityGroupEgress',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function authorizeSecurityGroupEgress(request: AuthorizeSecurityGroupEgressRequest): AuthorizeSecurityGroupEgressResponse {
  var runtime = new Util.RuntimeOptions{};
  return authorizeSecurityGroupEgressWithOptions(request, runtime);
}

model CreateApplicationRequest {
  template?: string(name='Template'),
  timeout?: int32(name='Timeout'),
}

model CreateApplicationResponseBody = {
  appId?: string(name='AppId'),
  requestId?: string(name='RequestId'),
}

model CreateApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: CreateApplicationResponseBody(name='body'),
}

async function createApplicationWithOptions(request: CreateApplicationRequest, runtime: Util.RuntimeOptions): CreateApplicationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.template)) {
    query['Template'] = request.template;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateApplication',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createApplication(request: CreateApplicationRequest): CreateApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createApplicationWithOptions(request, runtime);
}

model CreateDiskRequest {
  category?: string(name='Category', description='磁盘种类 高效云盘:cloud_efficiency 全闪云盘:cloud_ssd'),
  ensRegionId?: string(name='EnsRegionId', description='节点ID'),
  instanceChargeType?: string(name='InstanceChargeType', description='实例付费方式，取值 PrePaid:预付费，包年包月 PostPaid:按量付费。目前只支持：PostPaid'),
  size?: string(name='Size', description='磁盘大小,单位GB'),
}

model CreateDiskResponseBody = {
  instanceIds?: [ string ](name='InstanceIds', description='实列ID集合'),
  orderId?: string(name='OrderId', description='订单id,多个以逗号分割，可以直接跳转到收银行台 只有预付费返回订单号，后付费不返回'),
  requestId?: string(name='RequestId', description='请求唯一ID'),
}

model CreateDiskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDiskResponseBody(name='body'),
}

async function createDiskWithOptions(request: CreateDiskRequest, runtime: Util.RuntimeOptions): CreateDiskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.instanceChargeType)) {
    query['InstanceChargeType'] = request.instanceChargeType;
  }
  if (!Util.isUnset(request.size)) {
    query['Size'] = request.size;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDisk',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDisk(request: CreateDiskRequest): CreateDiskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDiskWithOptions(request, runtime);
}

model CreateEipInstanceRequest {
  bandwidth?: long(name='Bandwidth', description='EIP的带宽峰值'),
  ensRegionId?: string(name='EnsRegionId', description='ENS节点ID'),
  instanceChargeType?: string(name='InstanceChargeType', description='EIP的计费方式，取值：  PrePaid：包年包月。 PostPaid（默认值）：按量计费。 当InstanceChargeType取值为PostPaid时，InternetChargeType不能为PayByBandwidth'),
  internetChargeType?: string(name='InternetChargeType', description='EIP的计量方式，取值：  PayByBandwidth（默认值）：按带宽计费。 取值：95BandwidthByMonth：月95。'),
  isp?: string(name='Isp', description='运营商信息'),
  name?: string(name='Name', description='EIP实例名称。'),
}

model CreateEipInstanceResponseBody = {
  allocationId?: string(name='AllocationId', description='EIP的ID。'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateEipInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateEipInstanceResponseBody(name='body'),
}

async function createEipInstanceWithOptions(request: CreateEipInstanceRequest, runtime: Util.RuntimeOptions): CreateEipInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.instanceChargeType)) {
    query['InstanceChargeType'] = request.instanceChargeType;
  }
  if (!Util.isUnset(request.internetChargeType)) {
    query['InternetChargeType'] = request.internetChargeType;
  }
  if (!Util.isUnset(request.isp)) {
    query['Isp'] = request.isp;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateEipInstance',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createEipInstance(request: CreateEipInstanceRequest): CreateEipInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEipInstanceWithOptions(request, runtime);
}

model CreateEnsRouteEntryRequest {
  description?: string(name='Description', description='自定义路由条目的描述信息。'),
  destinationCidrBlock?: string(name='DestinationCidrBlock', description='自定义路由条目的目标网段。'),
  nextHopId?: string(name='NextHopId', description='自定义路由条目的下一跳实例的ID。'),
  nextHopType?: string(name='NextHopType', description='自定义路由条目的下一跳的类型'),
  routeEntryName?: string(name='RouteEntryName', description='要创建的自定义路由条目的名称。'),
  routeTableId?: string(name='RouteTableId', description='要创建自定义路由条目的路由表ID。'),
}

model CreateEnsRouteEntryResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  routeEntryId?: string(name='RouteEntryId', description='路由条目id。'),
}

model CreateEnsRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateEnsRouteEntryResponseBody(name='body'),
}

async function createEnsRouteEntryWithOptions(request: CreateEnsRouteEntryRequest, runtime: Util.RuntimeOptions): CreateEnsRouteEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.destinationCidrBlock)) {
    query['DestinationCidrBlock'] = request.destinationCidrBlock;
  }
  if (!Util.isUnset(request.nextHopId)) {
    query['NextHopId'] = request.nextHopId;
  }
  if (!Util.isUnset(request.nextHopType)) {
    query['NextHopType'] = request.nextHopType;
  }
  if (!Util.isUnset(request.routeEntryName)) {
    query['RouteEntryName'] = request.routeEntryName;
  }
  if (!Util.isUnset(request.routeTableId)) {
    query['RouteTableId'] = request.routeTableId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateEnsRouteEntry',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createEnsRouteEntry(request: CreateEnsRouteEntryRequest): CreateEnsRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEnsRouteEntryWithOptions(request, runtime);
}

model CreateEnsServiceRequest {
  ensServiceId?: string(name='EnsServiceId'),
  orderType?: string(name='OrderType'),
  version?: string(name='Version'),
}

model CreateEnsServiceResponseBody = {
  code?: int32(name='Code'),
  requestId?: string(name='RequestId'),
}

model CreateEnsServiceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateEnsServiceResponseBody(name='body'),
}

async function createEnsServiceWithOptions(request: CreateEnsServiceRequest, runtime: Util.RuntimeOptions): CreateEnsServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ensServiceId)) {
    query['EnsServiceId'] = request.ensServiceId;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateEnsService',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createEnsService(request: CreateEnsServiceRequest): CreateEnsServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEnsServiceWithOptions(request, runtime);
}

model CreateEpnInstanceRequest {
  EPNInstanceName?: string(name='EPNInstanceName'),
  EPNInstanceType?: string(name='EPNInstanceType'),
  internetChargeType?: string(name='InternetChargeType'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut'),
  networkingModel?: string(name='NetworkingModel'),
}

model CreateEpnInstanceResponseBody = {
  EPNInstanceId?: string(name='EPNInstanceId'),
  requestId?: string(name='RequestId'),
}

model CreateEpnInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateEpnInstanceResponseBody(name='body'),
}

async function createEpnInstanceWithOptions(request: CreateEpnInstanceRequest, runtime: Util.RuntimeOptions): CreateEpnInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.EPNInstanceName)) {
    query['EPNInstanceName'] = request.EPNInstanceName;
  }
  if (!Util.isUnset(request.EPNInstanceType)) {
    query['EPNInstanceType'] = request.EPNInstanceType;
  }
  if (!Util.isUnset(request.internetChargeType)) {
    query['InternetChargeType'] = request.internetChargeType;
  }
  if (!Util.isUnset(request.internetMaxBandwidthOut)) {
    query['InternetMaxBandwidthOut'] = request.internetMaxBandwidthOut;
  }
  if (!Util.isUnset(request.networkingModel)) {
    query['NetworkingModel'] = request.networkingModel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateEpnInstance',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createEpnInstance(request: CreateEpnInstanceRequest): CreateEpnInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEpnInstanceWithOptions(request, runtime);
}

model CreateForwardEntryRequest {
  externalIp?: string(name='ExternalIp'),
  externalPort?: string(name='ExternalPort'),
  forwardEntryName?: string(name='ForwardEntryName'),
  internalIp?: string(name='InternalIp'),
  internalPort?: string(name='InternalPort'),
  ipProtocol?: string(name='IpProtocol'),
  natGatewayId?: string(name='NatGatewayId'),
}

model CreateForwardEntryResponseBody = {
  forwardEntryId?: string(name='ForwardEntryId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateForwardEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateForwardEntryResponseBody(name='body'),
}

async function createForwardEntryWithOptions(request: CreateForwardEntryRequest, runtime: Util.RuntimeOptions): CreateForwardEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.externalIp)) {
    query['ExternalIp'] = request.externalIp;
  }
  if (!Util.isUnset(request.externalPort)) {
    query['ExternalPort'] = request.externalPort;
  }
  if (!Util.isUnset(request.forwardEntryName)) {
    query['ForwardEntryName'] = request.forwardEntryName;
  }
  if (!Util.isUnset(request.internalIp)) {
    query['InternalIp'] = request.internalIp;
  }
  if (!Util.isUnset(request.internalPort)) {
    query['InternalPort'] = request.internalPort;
  }
  if (!Util.isUnset(request.ipProtocol)) {
    query['IpProtocol'] = request.ipProtocol;
  }
  if (!Util.isUnset(request.natGatewayId)) {
    query['NatGatewayId'] = request.natGatewayId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateForwardEntry',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createForwardEntry(request: CreateForwardEntryRequest): CreateForwardEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createForwardEntryWithOptions(request, runtime);
}

model CreateImageRequest {
  deleteAfterImageUpload?: string(name='DeleteAfterImageUpload'),
  imageName?: string(name='ImageName'),
  instanceId?: string(name='InstanceId'),
  product?: string(name='product'),
}

model CreateImageResponseBody = {
  code?: int32(name='Code'),
  imageId?: string(name='ImageId', description='镜像ID'),
  requestId?: string(name='RequestId'),
}

model CreateImageResponse = {
  headers: map[string]string(name='headers'),
  body: CreateImageResponseBody(name='body'),
}

async function createImageWithOptions(request: CreateImageRequest, runtime: Util.RuntimeOptions): CreateImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deleteAfterImageUpload)) {
    query['DeleteAfterImageUpload'] = request.deleteAfterImageUpload;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.product)) {
    query['product'] = request.product;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateImage',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createImage(request: CreateImageRequest): CreateImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createImageWithOptions(request, runtime);
}

model CreateInstanceRequest {
  dataDisk?: [
    {
      size?: string(name='Size'),
    }
  ](name='DataDisk'),
  systemDisk?: {
    size?: string(name='Size'),
  }(name='SystemDisk'),
  autoRenew?: string(name='AutoRenew'),
  autoRenewPeriod?: string(name='AutoRenewPeriod'),
  ensRegionId?: string(name='EnsRegionId'),
  hostName?: string(name='HostName'),
  imageId?: string(name='ImageId'),
  instanceName?: string(name='InstanceName'),
  instanceType?: string(name='InstanceType'),
  internetChargeType?: string(name='InternetChargeType'),
  ipType?: string(name='IpType'),
  keyPairName?: string(name='KeyPairName'),
  ownerId?: long(name='OwnerId'),
  password?: string(name='Password'),
  passwordInherit?: boolean(name='PasswordInherit', description='是否使用镜像预设的密码。使用该参数时，Password参数必须为空，同时您需要确保使用的镜像已经设置了密码。'),
  paymentType?: string(name='PaymentType'),
  period?: string(name='Period'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  publicIpIdentification?: boolean(name='PublicIpIdentification'),
  quantity?: string(name='Quantity'),
  uniqueSuffix?: boolean(name='UniqueSuffix'),
  userData?: string(name='UserData'),
  vSwitchId?: string(name='VSwitchId'),
}

model CreateInstanceResponseBody = {
  code?: int32(name='Code'),
  instanceIds?: {
    instanceId?: [ string ](name='InstanceId')
  }(name='InstanceIds'),
  requestId?: string(name='RequestId'),
}

model CreateInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateInstanceResponseBody(name='body'),
}

async function createInstanceWithOptions(request: CreateInstanceRequest, runtime: Util.RuntimeOptions): CreateInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.autoRenewPeriod)) {
    query['AutoRenewPeriod'] = request.autoRenewPeriod;
  }
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.hostName)) {
    query['HostName'] = request.hostName;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.internetChargeType)) {
    query['InternetChargeType'] = request.internetChargeType;
  }
  if (!Util.isUnset(request.ipType)) {
    query['IpType'] = request.ipType;
  }
  if (!Util.isUnset(request.keyPairName)) {
    query['KeyPairName'] = request.keyPairName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.passwordInherit)) {
    query['PasswordInherit'] = request.passwordInherit;
  }
  if (!Util.isUnset(request.paymentType)) {
    query['PaymentType'] = request.paymentType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.privateIpAddress)) {
    query['PrivateIpAddress'] = request.privateIpAddress;
  }
  if (!Util.isUnset(request.publicIpIdentification)) {
    query['PublicIpIdentification'] = request.publicIpIdentification;
  }
  if (!Util.isUnset(request.quantity)) {
    query['Quantity'] = request.quantity;
  }
  if (!Util.isUnset(request.uniqueSuffix)) {
    query['UniqueSuffix'] = request.uniqueSuffix;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.dataDisk)) {
    query['DataDisk'] = request.dataDisk;
  }
  if (!Util.isUnset(request.systemDisk)) {
    query['SystemDisk'] = request.systemDisk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateInstance',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createInstance(request: CreateInstanceRequest): CreateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createInstanceWithOptions(request, runtime);
}

model CreateKeyPairRequest {
  keyPairName?: string(name='KeyPairName'),
  version?: string(name='Version'),
}

model CreateKeyPairResponseBody = {
  keyPairFingerPrint?: string(name='KeyPairFingerPrint'),
  keyPairId?: string(name='KeyPairId'),
  keyPairName?: string(name='KeyPairName'),
  privateKeyBody?: string(name='PrivateKeyBody'),
  requestId?: string(name='RequestId'),
}

model CreateKeyPairResponse = {
  headers: map[string]string(name='headers'),
  body: CreateKeyPairResponseBody(name='body'),
}

async function createKeyPairWithOptions(request: CreateKeyPairRequest, runtime: Util.RuntimeOptions): CreateKeyPairResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyPairName)) {
    query['KeyPairName'] = request.keyPairName;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateKeyPair',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createKeyPair(request: CreateKeyPairRequest): CreateKeyPairResponse {
  var runtime = new Util.RuntimeOptions{};
  return createKeyPairWithOptions(request, runtime);
}

model CreateLoadBalancerRequest {
  ensRegionId?: string(name='EnsRegionId', description='ENS节点ID。'),
  loadBalancerName?: string(name='LoadBalancerName', description='负载均衡实例的名称。'),
  loadBalancerSpec?: string(name='LoadBalancerSpec', description='负载均衡实例的名称。'),
  networkId?: string(name='NetworkId', description='要创建的ELB实例的网络ID'),
  payType?: string(name='PayType', description='付费类型。PostPaid（目前只支持此种）：按量付费'),
  vSwitchId?: string(name='VSwitchId', description='专有网络实例的所属的交换机ID。'),
}

model CreateLoadBalancerResponseBody = {
  loadBalancerId?: string(name='LoadBalancerId'),
  loadBalancerName?: string(name='LoadBalancerName'),
  networkId?: string(name='NetworkId'),
  requestId?: string(name='RequestId'),
  vSwitchId?: string(name='VSwitchId'),
}

model CreateLoadBalancerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLoadBalancerResponseBody(name='body'),
}

async function createLoadBalancerWithOptions(request: CreateLoadBalancerRequest, runtime: Util.RuntimeOptions): CreateLoadBalancerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.loadBalancerName)) {
    query['LoadBalancerName'] = request.loadBalancerName;
  }
  if (!Util.isUnset(request.loadBalancerSpec)) {
    query['LoadBalancerSpec'] = request.loadBalancerSpec;
  }
  if (!Util.isUnset(request.networkId)) {
    query['NetworkId'] = request.networkId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateLoadBalancer',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLoadBalancer(request: CreateLoadBalancerRequest): CreateLoadBalancerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoadBalancerWithOptions(request, runtime);
}

model CreateLoadBalancerHTTPListenerRequest {
  description?: string(name='Description', description='设置监听的描述信息。  长度限制为1-80个字符，允许包含字母、数字、“-”、“/”、“.”和“_”等字符。支持中文描述。'),
  forwardPort?: int32(name='ForwardPort', description='HTTP至HTTPS的监听转发端口。'),
  healthCheck?: string(name='HealthCheck', description='是否开启健康检查。  取值：on | off。'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='健康检查的后端服务器的端口。  取值： 1~65535。    说明 在HealthCheck值为on时才会有效。'),
  healthCheckDomain?: string(name='HealthCheckDomain', description='用于健康检查的域名，取值：  $_ip： 后端服务器的私网IP。当指定了IP或该参数未指定时，负载均衡会使用各后端服务器的私网IP当做健康检查使用的域名。是否要支持？ domain：域名长度为1-80字符，只能包含字母、数字、点号（.）和连字符（-）。   说明 在HealthCheck值为on时才会有效。'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode', description='健康检查正常的HTTP状态码，多个状态码用逗号分隔。  默认值为http_2xx。  取值：http_2xx | http_3xx | http_4xx | http_5xx。   说明 在HealthCheck值为on时才会有效。'),
  healthCheckInterval?: int32(name='HealthCheckInterval', description='健康检查的时间间隔。  取值： 1~50（秒）。   说明 在HealthCheck值为on时才会有效。'),
  healthCheckMethod?: string(name='HealthCheckMethod'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout', description='接收来自运行状况检查的响应需要等待的时间。如果后端ECS在指定的时间内没有正确响应，则判定为健康检查失败。在HealthCheck值为on时才会有效。  取值：1~300（秒）。   说明 如果HealthCHeckTimeout的值小于HealthCheckInterval的值，则HealthCHeckTimeout无效，超时时间为HealthCheckInterval的值。'),
  healthCheckURI?: string(name='HealthCheckURI', description='用于健康检查的URI。  长度限制为1~80，只能使用字母、数字和”-/.%?#&amp;“这些字符。 URL不能只为”/“，但必须以”/“开头。    说明 在HealthCheck值为on时才会有效。'),
  healthyThreshold?: int32(name='HealthyThreshold', description='健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success。  取值：2~10。    说明 在HealthCheck值为on时才会有效。'),
  idleTimeout?: int32(name='IdleTimeout', description='指定连接空闲超时时间，取值范围为1~60秒，默认值为15秒。  在超时时间内一直没有访问请求，负载均衡会暂时中断当前连接，直到一下次请求来临时重新建立新的连接。'),
  listenerForward?: string(name='ListenerForward', description='是否开启HTTP至HTTPS的转发。取值：on | off。'),
  listenerPort?: int32(name='ListenerPort', description='负载均衡实例前端使用的端口。  取值：1-65535。'),
  loadBalancerId?: string(name='LoadBalancerId', description='负载均衡实例的ID。'),
  requestTimeout?: int32(name='RequestTimeout', description='指定请求超时时间，取值范围为1~180秒，默认值为60秒。  在超时时间内后端服务器一直没有响应，负载均衡将放弃等待，给客户端返回 HTTP 504 错误码。'),
  scheduler?: string(name='Scheduler', description='调度算法。取值：  wrr（默认值）：权重值越高的后端服务器，被轮询到的次数（概率）也越高。 wlc：除了根据每台后端服务器设定的权重值来进行轮询，同时还考虑后端服务器的实际负载（即连接数）。当权重值相同时，当前连接数越小的后端服务器被轮询到的次数（概率）也越高。 rr：按照访问顺序依次将外部请求依序分发到后端服务器。'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', description='健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail。  取值：2~10。   说明 在HealthCheck值为on时才会有效。'),
  XForwardedFor?: string(name='XForwardedFor', description='是否开启通过X-Forwarded-For头字段获取来访者真实 IP。  取值为on。'),
}

model CreateLoadBalancerHTTPListenerResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateLoadBalancerHTTPListenerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLoadBalancerHTTPListenerResponseBody(name='body'),
}

async function createLoadBalancerHTTPListenerWithOptions(request: CreateLoadBalancerHTTPListenerRequest, runtime: Util.RuntimeOptions): CreateLoadBalancerHTTPListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.forwardPort)) {
    query['ForwardPort'] = request.forwardPort;
  }
  if (!Util.isUnset(request.healthCheck)) {
    query['HealthCheck'] = request.healthCheck;
  }
  if (!Util.isUnset(request.healthCheckConnectPort)) {
    query['HealthCheckConnectPort'] = request.healthCheckConnectPort;
  }
  if (!Util.isUnset(request.healthCheckDomain)) {
    query['HealthCheckDomain'] = request.healthCheckDomain;
  }
  if (!Util.isUnset(request.healthCheckHttpCode)) {
    query['HealthCheckHttpCode'] = request.healthCheckHttpCode;
  }
  if (!Util.isUnset(request.healthCheckInterval)) {
    query['HealthCheckInterval'] = request.healthCheckInterval;
  }
  if (!Util.isUnset(request.healthCheckMethod)) {
    query['HealthCheckMethod'] = request.healthCheckMethod;
  }
  if (!Util.isUnset(request.healthCheckTimeout)) {
    query['HealthCheckTimeout'] = request.healthCheckTimeout;
  }
  if (!Util.isUnset(request.healthCheckURI)) {
    query['HealthCheckURI'] = request.healthCheckURI;
  }
  if (!Util.isUnset(request.healthyThreshold)) {
    query['HealthyThreshold'] = request.healthyThreshold;
  }
  if (!Util.isUnset(request.idleTimeout)) {
    query['IdleTimeout'] = request.idleTimeout;
  }
  if (!Util.isUnset(request.listenerForward)) {
    query['ListenerForward'] = request.listenerForward;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.requestTimeout)) {
    query['RequestTimeout'] = request.requestTimeout;
  }
  if (!Util.isUnset(request.scheduler)) {
    query['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.unhealthyThreshold)) {
    query['UnhealthyThreshold'] = request.unhealthyThreshold;
  }
  if (!Util.isUnset(request.XForwardedFor)) {
    query['XForwardedFor'] = request.XForwardedFor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateLoadBalancerHTTPListener',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLoadBalancerHTTPListener(request: CreateLoadBalancerHTTPListenerRequest): CreateLoadBalancerHTTPListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoadBalancerHTTPListenerWithOptions(request, runtime);
}

model CreateLoadBalancerHTTPSListenerRequest {
  cookie?: string(name='Cookie', description='服务器上配置的Cookie。 长度为1-200，只能包含ASCII英文字母和数字字符，不能包含逗号、分号或空格，也不能以$开头。 说明 当StickySession为on且StickySessionType为server时，该参数必选。'),
  cookieTimeout?: int32(name='CookieTimeout', description='Cookie超时时间。  取值：1~86400（秒）。   说明 当StickySession为on且StickySessionType为insert时，该参数必选。'),
  description?: string(name='Description', description='设置监听的描述信息。  长度限制为1-80个字符，允许包含字母、数字、“-”、“/”、“.”和“_”等字符。支持中文描述。'),
  forwardPort?: int32(name='ForwardPort', description='HTTP至HTTPS的监听转发端口。'),
  healthCheck?: string(name='HealthCheck', description='是否开启健康检查。  取值：on | off。'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='健康检查的后端服务器的端口。  取值： 1~65535。    说明 在HealthCheck值为on时才会有效。'),
  healthCheckDomain?: string(name='HealthCheckDomain', description='用于健康检查的域名，取值：  $_ip： 后端服务器的私网IP。当指定了IP或该参数未指定时，负载均衡会使用各后端服务器的私网IP当做健康检查使用的域名。是否要支持？ domain：域名长度为1-80字符，只能包含字母、数字、点号（.）和连字符（-）。   说明 在HealthCheck值为on时才会有效。'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode', description='健康检查正常的HTTP状态码，多个状态码用逗号分隔。  默认值为http_2xx。  取值：http_2xx | http_3xx | http_4xx | http_5xx。   说明 在HealthCheck值为on时才会有效。'),
  healthCheckInterval?: int32(name='HealthCheckInterval', description='健康检查的时间间隔。  取值： 1~50（秒）。   说明 在HealthCheck值为on时才会有效。'),
  healthCheckMethod?: string(name='HealthCheckMethod'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout', description='接收来自运行状况检查的响应需要等待的时间。如果后端ECS在指定的时间内没有正确响应，则判定为健康检查失败。在HealthCheck值为on时才会有效。  取值：1~300（秒）。   说明 如果HealthCHeckTimeout的值小于HealthCheckInterval的值，则HealthCHeckTimeout无效，超时时间为HealthCheckInterval的值。'),
  healthCheckURI?: string(name='HealthCheckURI', description='用于健康检查的URI。  长度限制为1~80，只能使用字母、数字和”-/.%?#&amp;“这些字符。 URL不能只为”/“，但必须以”/“开头。    说明 在HealthCheck值为on时才会有效。'),
  healthyThreshold?: int32(name='HealthyThreshold', description='健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success。  取值：2~10。    说明 在HealthCheck值为on时才会有效。'),
  idleTimeout?: int32(name='IdleTimeout', description='指定连接空闲超时时间，取值范围为1~60秒，默认值为15秒。  在超时时间内一直没有访问请求，负载均衡会暂时中断当前连接，直到一下次请求来临时重新建立新的连接。'),
  listenerForward?: string(name='ListenerForward', description='是否开启HTTP至HTTPS的转发。取值：on | off。'),
  listenerPort?: int32(name='ListenerPort', description='负载均衡实例前端使用的端口。  取值：1-65535。'),
  loadBalancerId?: string(name='LoadBalancerId', description='负载均衡实例的ID。'),
  requestTimeout?: int32(name='RequestTimeout', description='指定请求超时时间，取值范围为1~180秒，默认值为60秒。  在超时时间内后端服务器一直没有响应，负载均衡将放弃等待，给客户端返回 HTTP 504 错误码。'),
  scheduler?: string(name='Scheduler', description='调度算法。取值：  wrr（默认值）：权重值越高的后端服务器，被轮询到的次数（概率）也越高。 wlc：除了根据每台后端服务器设定的权重值来进行轮询，同时还考虑后端服务器的实际负载（即连接数）。当权重值相同时，当前连接数越小的后端服务器被轮询到的次数（概率）也越高。 rr：按照访问顺序依次将外部请求依序分发到后端服务器。'),
  serverCertificateId?: string(name='ServerCertificateId', description='服务器证书的ID。'),
  stickySessionType?: string(name='StickySessionType', description='cookie的处理方式。取值：  insert：植入Cookie。  客户端第一次访问时，负载均衡会在返回请求中植入Cookie（即在HTTP/HTTPS响应报文中插入SERVERID），下次客户端携带此Cookie访问，负载均衡服务会将请求定向转发给之前记录到的后端服务器上。  server：重写Cookie。  负载均衡发现用户自定义了Cookie，将会对原来的Cookie进行重写，下次客户端携带新的Cookie访问，负载均衡服务会将请求定向转发给之前记录到的后端服务器。   说明 当StickySession的值为on时，必须指定该参数。'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', description='健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail。  取值：2~10。   说明 在HealthCheck值为on时才会有效。'),
}

model CreateLoadBalancerHTTPSListenerResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateLoadBalancerHTTPSListenerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLoadBalancerHTTPSListenerResponseBody(name='body'),
}

async function createLoadBalancerHTTPSListenerWithOptions(request: CreateLoadBalancerHTTPSListenerRequest, runtime: Util.RuntimeOptions): CreateLoadBalancerHTTPSListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cookie)) {
    query['Cookie'] = request.cookie;
  }
  if (!Util.isUnset(request.cookieTimeout)) {
    query['CookieTimeout'] = request.cookieTimeout;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.forwardPort)) {
    query['ForwardPort'] = request.forwardPort;
  }
  if (!Util.isUnset(request.healthCheck)) {
    query['HealthCheck'] = request.healthCheck;
  }
  if (!Util.isUnset(request.healthCheckConnectPort)) {
    query['HealthCheckConnectPort'] = request.healthCheckConnectPort;
  }
  if (!Util.isUnset(request.healthCheckDomain)) {
    query['HealthCheckDomain'] = request.healthCheckDomain;
  }
  if (!Util.isUnset(request.healthCheckHttpCode)) {
    query['HealthCheckHttpCode'] = request.healthCheckHttpCode;
  }
  if (!Util.isUnset(request.healthCheckInterval)) {
    query['HealthCheckInterval'] = request.healthCheckInterval;
  }
  if (!Util.isUnset(request.healthCheckMethod)) {
    query['HealthCheckMethod'] = request.healthCheckMethod;
  }
  if (!Util.isUnset(request.healthCheckTimeout)) {
    query['HealthCheckTimeout'] = request.healthCheckTimeout;
  }
  if (!Util.isUnset(request.healthCheckURI)) {
    query['HealthCheckURI'] = request.healthCheckURI;
  }
  if (!Util.isUnset(request.healthyThreshold)) {
    query['HealthyThreshold'] = request.healthyThreshold;
  }
  if (!Util.isUnset(request.idleTimeout)) {
    query['IdleTimeout'] = request.idleTimeout;
  }
  if (!Util.isUnset(request.listenerForward)) {
    query['ListenerForward'] = request.listenerForward;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.requestTimeout)) {
    query['RequestTimeout'] = request.requestTimeout;
  }
  if (!Util.isUnset(request.scheduler)) {
    query['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.serverCertificateId)) {
    query['ServerCertificateId'] = request.serverCertificateId;
  }
  if (!Util.isUnset(request.stickySessionType)) {
    query['StickySessionType'] = request.stickySessionType;
  }
  if (!Util.isUnset(request.unhealthyThreshold)) {
    query['UnhealthyThreshold'] = request.unhealthyThreshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateLoadBalancerHTTPSListener',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLoadBalancerHTTPSListener(request: CreateLoadBalancerHTTPSListenerRequest): CreateLoadBalancerHTTPSListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoadBalancerHTTPSListenerWithOptions(request, runtime);
}

model CreateLoadBalancerTCPListenerRequest {
  backendServerPort?: int32(name='BackendServerPort', description='负载均衡实例后端使用的端口，取值：1~65535'),
  description?: string(name='Description', description='设置监听的描述信息。  长度限制为1-80个字符，允许包含字母、数字、“-”、“/”、“.”和“_”等字符。支持中文描述。'),
  eipTransmit?: string(name='EipTransmit'),
  establishedTimeout?: int32(name='EstablishedTimeout', description='连接超时时间。  取值：10~900（秒）。'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='健康检查使用的端口。  取值：1~65535。  不设置此参数时，表示使用后端服务端口（BackendServerPort）。'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', description='每次健康检查响应的最大超时时间。  取值：1~300（秒）。  默认值：5。'),
  healthCheckDomain?: string(name='HealthCheckDomain', description='用于健康检查的域名'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode', description='健康检查正常的HTTP状态码，多个状态码用逗号（,）分割。  取值：http_2xx（默认值） | http_3xx | http_4xx | http_5xx。'),
  healthCheckInterval?: int32(name='HealthCheckInterval', description='健康检查的时间间隔。  取值：1~50（秒）。'),
  healthCheckType?: string(name='HealthCheckType', description='健康检查类型。  取值：tcp（默认值） | http。'),
  healthCheckURI?: string(name='HealthCheckURI', description='用于健康检查的URI。长度限制为1~80，只能使用字母、数字、短横线（-）、正斜杠（/）、点号（.）、百分号（%）、#和&amp;这些字符。 URL不能只为/，但必须以/开头。  当TCP监听需要使用HTTP健康检查时可配置此参数，如不配置则按TCP健康检查。'),
  healthyThreshold?: int32(name='HealthyThreshold', description='健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success。  取值： 2~10。'),
  listenerPort?: int32(name='ListenerPort', description='负载均衡实例前端使用的端口。  取值：1-65535。'),
  loadBalancerId?: string(name='LoadBalancerId', description='负载均衡实例的ID。'),
  persistenceTimeout?: int32(name='PersistenceTimeout', description='会话保持的超时时间。  取值：0~3600（秒）。  默认值：0，表示关闭会话保持。'),
  scheduler?: string(name='Scheduler', description='度算法。取值：  wrr（默认值）：权重值越高的后端服务器，被轮询到的次数（概率）也越高。 wlc：除了根据每台后端服务器设定的权重值来进行轮询，同时还考虑后端服务器的实际负载（即连接数）。当权重值相同时，当前连接数越小的后端服务器被轮询到的次数（概率）也越高。 rr：按照访问顺序依次将外部请求依序分发到后端服务器。 sch：基于源IP地址的一致性hash，相同的源地址会调度到相同的后端服务器。'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', description='健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail。  取值：2~10。'),
}

model CreateLoadBalancerTCPListenerResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateLoadBalancerTCPListenerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLoadBalancerTCPListenerResponseBody(name='body'),
}

async function createLoadBalancerTCPListenerWithOptions(request: CreateLoadBalancerTCPListenerRequest, runtime: Util.RuntimeOptions): CreateLoadBalancerTCPListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backendServerPort)) {
    query['BackendServerPort'] = request.backendServerPort;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.eipTransmit)) {
    query['EipTransmit'] = request.eipTransmit;
  }
  if (!Util.isUnset(request.establishedTimeout)) {
    query['EstablishedTimeout'] = request.establishedTimeout;
  }
  if (!Util.isUnset(request.healthCheckConnectPort)) {
    query['HealthCheckConnectPort'] = request.healthCheckConnectPort;
  }
  if (!Util.isUnset(request.healthCheckConnectTimeout)) {
    query['HealthCheckConnectTimeout'] = request.healthCheckConnectTimeout;
  }
  if (!Util.isUnset(request.healthCheckDomain)) {
    query['HealthCheckDomain'] = request.healthCheckDomain;
  }
  if (!Util.isUnset(request.healthCheckHttpCode)) {
    query['HealthCheckHttpCode'] = request.healthCheckHttpCode;
  }
  if (!Util.isUnset(request.healthCheckInterval)) {
    query['HealthCheckInterval'] = request.healthCheckInterval;
  }
  if (!Util.isUnset(request.healthCheckType)) {
    query['HealthCheckType'] = request.healthCheckType;
  }
  if (!Util.isUnset(request.healthCheckURI)) {
    query['HealthCheckURI'] = request.healthCheckURI;
  }
  if (!Util.isUnset(request.healthyThreshold)) {
    query['HealthyThreshold'] = request.healthyThreshold;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.persistenceTimeout)) {
    query['PersistenceTimeout'] = request.persistenceTimeout;
  }
  if (!Util.isUnset(request.scheduler)) {
    query['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.unhealthyThreshold)) {
    query['UnhealthyThreshold'] = request.unhealthyThreshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateLoadBalancerTCPListener',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLoadBalancerTCPListener(request: CreateLoadBalancerTCPListenerRequest): CreateLoadBalancerTCPListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoadBalancerTCPListenerWithOptions(request, runtime);
}

model CreateLoadBalancerUDPListenerRequest {
  backendServerPort?: int32(name='BackendServerPort', description='负载均衡实例后端使用的端口，取值：1~65535'),
  description?: string(name='Description', description='设置监听的描述信息。  长度限制为1-80个字符，允许包含字母、数字、“-”、“/”、“.”和“_”等字符。支持中文描述。'),
  eipTransmit?: string(name='EipTransmit'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='健康检查使用的端口。取值：1-65535  不设置此参数时，表示使用后端服务端口（BackendServerPort）'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', description='接收来自运行状况检查的响应需要等待的时间。  如果后端ENS在指定的时间内没有正确响应，则判定为健康检查失败。  取值：1-300（秒）。默认为5秒'),
  healthCheckExp?: string(name='HealthCheckExp', description='UDP监听健康检查的响应串，只允许包含字母、数字，最大长度限制为64个字符。'),
  healthCheckInterval?: int32(name='HealthCheckInterval', description='健康检查的时间间隔。  取值：1-50（秒）。'),
  healthCheckReq?: string(name='HealthCheckReq', description='UDP监听健康检查的请求串，只允许包含字母、数字，最大长度限制为64个字符。'),
  healthyThreshold?: int32(name='HealthyThreshold', description='健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success。  取值：2-10。'),
  listenerPort?: int32(name='ListenerPort', description='负载均衡实例前端使用的端口。  取值：1-65535。'),
  loadBalancerId?: string(name='LoadBalancerId', description='负载均衡实例的ID。'),
  scheduler?: string(name='Scheduler', description='调度算法。取值：  wrr（默认值）：权重值越高的后端服务器，被轮询到的次数（概率）也越高。 wlc：除了根据每台后端服务器设定的权重值来进行轮询，同时还考虑后端服务器的实际负载（即连接数）。当权重值相同时，当前连接数越小的后端服务器被轮询到的次数（概率）也越高。 rr：按照访问顺序依次将外部请求依序分发到后端服务器。 sch：基于源IP地址的一致性hash，相同的源地址会调度到相同的后端服务器。'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', description='健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail。  取值：2-10。'),
}

model CreateLoadBalancerUDPListenerResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateLoadBalancerUDPListenerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLoadBalancerUDPListenerResponseBody(name='body'),
}

async function createLoadBalancerUDPListenerWithOptions(request: CreateLoadBalancerUDPListenerRequest, runtime: Util.RuntimeOptions): CreateLoadBalancerUDPListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backendServerPort)) {
    query['BackendServerPort'] = request.backendServerPort;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.eipTransmit)) {
    query['EipTransmit'] = request.eipTransmit;
  }
  if (!Util.isUnset(request.healthCheckConnectPort)) {
    query['HealthCheckConnectPort'] = request.healthCheckConnectPort;
  }
  if (!Util.isUnset(request.healthCheckConnectTimeout)) {
    query['HealthCheckConnectTimeout'] = request.healthCheckConnectTimeout;
  }
  if (!Util.isUnset(request.healthCheckExp)) {
    query['HealthCheckExp'] = request.healthCheckExp;
  }
  if (!Util.isUnset(request.healthCheckInterval)) {
    query['HealthCheckInterval'] = request.healthCheckInterval;
  }
  if (!Util.isUnset(request.healthCheckReq)) {
    query['HealthCheckReq'] = request.healthCheckReq;
  }
  if (!Util.isUnset(request.healthyThreshold)) {
    query['HealthyThreshold'] = request.healthyThreshold;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.scheduler)) {
    query['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.unhealthyThreshold)) {
    query['UnhealthyThreshold'] = request.unhealthyThreshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateLoadBalancerUDPListener',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLoadBalancerUDPListener(request: CreateLoadBalancerUDPListenerRequest): CreateLoadBalancerUDPListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoadBalancerUDPListenerWithOptions(request, runtime);
}

model CreateNatGatewayRequest {
  ensRegionId?: string(name='EnsRegionId'),
  name?: string(name='Name'),
  networkId?: string(name='NetworkId'),
  vSwitchId?: string(name='VSwitchId'),
}

model CreateNatGatewayResponseBody = {
  natGatewayId?: string(name='NatGatewayId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateNatGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNatGatewayResponseBody(name='body'),
}

async function createNatGatewayWithOptions(request: CreateNatGatewayRequest, runtime: Util.RuntimeOptions): CreateNatGatewayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.networkId)) {
    query['NetworkId'] = request.networkId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNatGateway',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createNatGateway(request: CreateNatGatewayRequest): CreateNatGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNatGatewayWithOptions(request, runtime);
}

model CreateNetworkRequest {
  cidrBlock?: string(name='CidrBlock'),
  description?: string(name='Description'),
  ensRegionId?: string(name='EnsRegionId'),
  networkName?: string(name='NetworkName'),
}

model CreateNetworkResponseBody = {
  networkId?: string(name='NetworkId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateNetworkResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNetworkResponseBody(name='body'),
}

async function createNetworkWithOptions(request: CreateNetworkRequest, runtime: Util.RuntimeOptions): CreateNetworkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cidrBlock)) {
    query['CidrBlock'] = request.cidrBlock;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.networkName)) {
    query['NetworkName'] = request.networkName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNetwork',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createNetwork(request: CreateNetworkRequest): CreateNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNetworkWithOptions(request, runtime);
}

model CreateSecurityGroupRequest {
  description?: string(name='Description'),
  securityGroupName?: string(name='SecurityGroupName'),
  version?: string(name='Version'),
}

model CreateSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
  securityGroupId?: string(name='SecurityGroupId'),
}

model CreateSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSecurityGroupResponseBody(name='body'),
}

async function createSecurityGroupWithOptions(request: CreateSecurityGroupRequest, runtime: Util.RuntimeOptions): CreateSecurityGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.securityGroupName)) {
    query['SecurityGroupName'] = request.securityGroupName;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSecurityGroup',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSecurityGroup(request: CreateSecurityGroupRequest): CreateSecurityGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSecurityGroupWithOptions(request, runtime);
}

model CreateSnatEntryRequest {
  natGatewayId?: string(name='NatGatewayId'),
  snatEntryName?: string(name='SnatEntryName'),
  snatIp?: string(name='SnatIp'),
  sourceCIDR?: string(name='SourceCIDR'),
  sourceVSwitchId?: string(name='SourceVSwitchId'),
}

model CreateSnatEntryResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  snatEntryId?: string(name='SnatEntryId'),
}

model CreateSnatEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSnatEntryResponseBody(name='body'),
}

async function createSnatEntryWithOptions(request: CreateSnatEntryRequest, runtime: Util.RuntimeOptions): CreateSnatEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.natGatewayId)) {
    query['NatGatewayId'] = request.natGatewayId;
  }
  if (!Util.isUnset(request.snatEntryName)) {
    query['SnatEntryName'] = request.snatEntryName;
  }
  if (!Util.isUnset(request.snatIp)) {
    query['SnatIp'] = request.snatIp;
  }
  if (!Util.isUnset(request.sourceCIDR)) {
    query['SourceCIDR'] = request.sourceCIDR;
  }
  if (!Util.isUnset(request.sourceVSwitchId)) {
    query['SourceVSwitchId'] = request.sourceVSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSnatEntry',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSnatEntry(request: CreateSnatEntryRequest): CreateSnatEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSnatEntryWithOptions(request, runtime);
}

model CreateVSwitchRequest {
  cidrBlock?: string(name='CidrBlock'),
  description?: string(name='Description'),
  ensRegionId?: string(name='EnsRegionId'),
  networkId?: string(name='NetworkId'),
  vSwitchName?: string(name='VSwitchName'),
  version?: string(name='Version'),
}

model CreateVSwitchResponseBody = {
  requestId?: string(name='RequestId'),
  vSwitchId?: string(name='VSwitchId'),
}

model CreateVSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVSwitchResponseBody(name='body'),
}

async function createVSwitchWithOptions(request: CreateVSwitchRequest, runtime: Util.RuntimeOptions): CreateVSwitchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cidrBlock)) {
    query['CidrBlock'] = request.cidrBlock;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.networkId)) {
    query['NetworkId'] = request.networkId;
  }
  if (!Util.isUnset(request.vSwitchName)) {
    query['VSwitchName'] = request.vSwitchName;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVSwitch',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVSwitch(request: CreateVSwitchRequest): CreateVSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVSwitchWithOptions(request, runtime);
}

model DeleteApplicationRequest {
  appId?: string(name='AppId'),
  timeout?: int32(name='Timeout'),
}

model DeleteApplicationResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteApplicationResponseBody(name='body'),
}

async function deleteApplicationWithOptions(request: DeleteApplicationRequest, runtime: Util.RuntimeOptions): DeleteApplicationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteApplication',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteApplication(request: DeleteApplicationRequest): DeleteApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteApplicationWithOptions(request, runtime);
}

model DeleteDeviceInternetPortRequest {
  instanceId?: string(name='InstanceId', description='InstanceId'),
  natType?: string(name='NatType', description='NatType'),
  ruleId?: string(name='RuleId', description='RuleId'),
}

model DeleteDeviceInternetPortResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  ruleIds?: [ string ](name='RuleIds', description='RuleIds'),
}

model DeleteDeviceInternetPortResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDeviceInternetPortResponseBody(name='body'),
}

async function deleteDeviceInternetPortWithOptions(request: DeleteDeviceInternetPortRequest, runtime: Util.RuntimeOptions): DeleteDeviceInternetPortResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDeviceInternetPort',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDeviceInternetPort(request: DeleteDeviceInternetPortRequest): DeleteDeviceInternetPortResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDeviceInternetPortWithOptions(request, runtime);
}

model DeleteEnsRouteEntryRequest {
  routeEntryId?: string(name='RouteEntryId', description='要删除的路由条目ID。'),
}

model DeleteEnsRouteEntryResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteEnsRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEnsRouteEntryResponseBody(name='body'),
}

async function deleteEnsRouteEntryWithOptions(request: DeleteEnsRouteEntryRequest, runtime: Util.RuntimeOptions): DeleteEnsRouteEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.routeEntryId)) {
    query['RouteEntryId'] = request.routeEntryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEnsRouteEntry',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteEnsRouteEntry(request: DeleteEnsRouteEntryRequest): DeleteEnsRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEnsRouteEntryWithOptions(request, runtime);
}

model DeleteEpnInstanceRequest {
  EPNInstanceId?: string(name='EPNInstanceId'),
}

model DeleteEpnInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteEpnInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEpnInstanceResponseBody(name='body'),
}

async function deleteEpnInstanceWithOptions(request: DeleteEpnInstanceRequest, runtime: Util.RuntimeOptions): DeleteEpnInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.EPNInstanceId)) {
    query['EPNInstanceId'] = request.EPNInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEpnInstance',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteEpnInstance(request: DeleteEpnInstanceRequest): DeleteEpnInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEpnInstanceWithOptions(request, runtime);
}

model DeleteForwardEntryRequest {
  forwardEntryId?: string(name='ForwardEntryId'),
}

model DeleteForwardEntryResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteForwardEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteForwardEntryResponseBody(name='body'),
}

async function deleteForwardEntryWithOptions(request: DeleteForwardEntryRequest, runtime: Util.RuntimeOptions): DeleteForwardEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.forwardEntryId)) {
    query['ForwardEntryId'] = request.forwardEntryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteForwardEntry',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteForwardEntry(request: DeleteForwardEntryRequest): DeleteForwardEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteForwardEntryWithOptions(request, runtime);
}

model DeleteKeyPairsRequest {
  keyPairName?: string(name='KeyPairName'),
  version?: string(name='Version'),
}

model DeleteKeyPairsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteKeyPairsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteKeyPairsResponseBody(name='body'),
}

async function deleteKeyPairsWithOptions(request: DeleteKeyPairsRequest, runtime: Util.RuntimeOptions): DeleteKeyPairsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyPairName)) {
    query['KeyPairName'] = request.keyPairName;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteKeyPairs',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteKeyPairs(request: DeleteKeyPairsRequest): DeleteKeyPairsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteKeyPairsWithOptions(request, runtime);
}

model DeleteLoadBalancerListenerRequest {
  listenerPort?: int32(name='ListenerPort'),
  loadBalancerId?: string(name='LoadBalancerId'),
}

model DeleteLoadBalancerListenerResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteLoadBalancerListenerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLoadBalancerListenerResponseBody(name='body'),
}

async function deleteLoadBalancerListenerWithOptions(request: DeleteLoadBalancerListenerRequest, runtime: Util.RuntimeOptions): DeleteLoadBalancerListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLoadBalancerListener',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLoadBalancerListener(request: DeleteLoadBalancerListenerRequest): DeleteLoadBalancerListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLoadBalancerListenerWithOptions(request, runtime);
}

model DeleteNatGatewayRequest {
  natGatewayId?: string(name='NatGatewayId'),
}

model DeleteNatGatewayResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteNatGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNatGatewayResponseBody(name='body'),
}

async function deleteNatGatewayWithOptions(request: DeleteNatGatewayRequest, runtime: Util.RuntimeOptions): DeleteNatGatewayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.natGatewayId)) {
    query['NatGatewayId'] = request.natGatewayId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNatGateway',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteNatGateway(request: DeleteNatGatewayRequest): DeleteNatGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNatGatewayWithOptions(request, runtime);
}

model DeleteNetworkRequest {
  networkId?: string(name='NetworkId'),
}

model DeleteNetworkResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteNetworkResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNetworkResponseBody(name='body'),
}

async function deleteNetworkWithOptions(request: DeleteNetworkRequest, runtime: Util.RuntimeOptions): DeleteNetworkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.networkId)) {
    query['NetworkId'] = request.networkId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNetwork',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteNetwork(request: DeleteNetworkRequest): DeleteNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNetworkWithOptions(request, runtime);
}

model DeleteSecurityGroupRequest {
  securityGroupId?: string(name='SecurityGroupId'),
  version?: string(name='Version'),
}

model DeleteSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSecurityGroupResponseBody(name='body'),
}

async function deleteSecurityGroupWithOptions(request: DeleteSecurityGroupRequest, runtime: Util.RuntimeOptions): DeleteSecurityGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSecurityGroup',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSecurityGroup(request: DeleteSecurityGroupRequest): DeleteSecurityGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSecurityGroupWithOptions(request, runtime);
}

model DeleteSnatEntryRequest {
  snatEntryId?: string(name='SnatEntryId'),
}

model DeleteSnatEntryResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteSnatEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSnatEntryResponseBody(name='body'),
}

async function deleteSnatEntryWithOptions(request: DeleteSnatEntryRequest, runtime: Util.RuntimeOptions): DeleteSnatEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.snatEntryId)) {
    query['SnatEntryId'] = request.snatEntryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSnatEntry',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSnatEntry(request: DeleteSnatEntryRequest): DeleteSnatEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSnatEntryWithOptions(request, runtime);
}

model DeleteVSwitchRequest {
  vSwitchId?: string(name='VSwitchId'),
  version?: string(name='Version'),
}

model DeleteVSwitchResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVSwitchResponseBody(name='body'),
}

async function deleteVSwitchWithOptions(request: DeleteVSwitchRequest, runtime: Util.RuntimeOptions): DeleteVSwitchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVSwitch',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVSwitch(request: DeleteVSwitchRequest): DeleteVSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVSwitchWithOptions(request, runtime);
}

model DescribeApplicationRequest {
  appId?: string(name='AppId'),
  appVersions?: string(name='AppVersions'),
  level?: string(name='Level'),
  outDetailStatParams?: string(name='OutDetailStatParams'),
}

model DescribeApplicationResponseBody = {
  application?: string(name='Application'),
  requestId?: string(name='RequestId'),
}

model DescribeApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeApplicationResponseBody(name='body'),
}

async function describeApplicationWithOptions(request: DescribeApplicationRequest, runtime: Util.RuntimeOptions): DescribeApplicationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appVersions)) {
    query['AppVersions'] = request.appVersions;
  }
  if (!Util.isUnset(request.level)) {
    query['Level'] = request.level;
  }
  if (!Util.isUnset(request.outDetailStatParams)) {
    query['OutDetailStatParams'] = request.outDetailStatParams;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeApplication',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeApplication(request: DescribeApplicationRequest): DescribeApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeApplicationWithOptions(request, runtime);
}

model DescribeApplicationResourceSummaryRequest {
  level?: string(name='Level'),
  resourceType?: string(name='ResourceType'),
}

model DescribeApplicationResourceSummaryResponseBody = {
  applicationResource?: string(name='ApplicationResource'),
  requestId?: string(name='RequestId'),
}

model DescribeApplicationResourceSummaryResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeApplicationResourceSummaryResponseBody(name='body'),
}

async function describeApplicationResourceSummaryWithOptions(request: DescribeApplicationResourceSummaryRequest, runtime: Util.RuntimeOptions): DescribeApplicationResourceSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.level)) {
    query['Level'] = request.level;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeApplicationResourceSummary',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeApplicationResourceSummary(request: DescribeApplicationResourceSummaryRequest): DescribeApplicationResourceSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeApplicationResourceSummaryWithOptions(request, runtime);
}

model DescribeAvailableResourceRequest {
  version?: string(name='Version'),
}

model DescribeAvailableResourceResponseBody = {
  code?: int32(name='Code'),
  images?: {
    image?: [ 
    {
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
    }
  ](name='Image')
  }(name='Images'),
  requestId?: string(name='RequestId'),
  supportResources?: {
    supportResource?: [ 
    {
      dataDiskSize?: string(name='DataDiskSize'),
      ensRegionId?: string(name='EnsRegionId'),
      instanceSpec?: string(name='InstanceSpec'),
      supportResourcesCount?: string(name='SupportResourcesCount'),
      systemDiskSize?: string(name='SystemDiskSize'),
    }
  ](name='SupportResource')
  }(name='SupportResources'),
}

model DescribeAvailableResourceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAvailableResourceResponseBody(name='body'),
}

async function describeAvailableResourceWithOptions(request: DescribeAvailableResourceRequest, runtime: Util.RuntimeOptions): DescribeAvailableResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAvailableResource',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAvailableResource(request: DescribeAvailableResourceRequest): DescribeAvailableResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableResourceWithOptions(request, runtime);
}

model DescribeAvailableResourceInfoRequest {
  version?: string(name='Version'),
}

model DescribeAvailableResourceInfoResponseBody = {
  images?: {
    image?: [ 
    {
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
      imageSize?: int32(name='ImageSize'),
    }
  ](name='Image')
  }(name='Images'),
  requestId?: string(name='RequestId'),
  supportResources?: {
    supportResource?: [ 
    {
      bandwidthTypes?: {
        bandwidthType?: [ string ](name='BandwidthType')
      }(name='BandwidthTypes'),
      dataDiskMaxSize?: int32(name='DataDiskMaxSize'),
      dataDiskMinSize?: int32(name='DataDiskMinSize'),
      ensRegionIds?: {
        ensRegionId?: [ string ](name='EnsRegionId')
      }(name='EnsRegionIds'),
      ensRegionIdsExtends?: {
        ensRegionId?: [ 
        {
          area?: string(name='Area'),
          enName?: string(name='EnName'),
          ensRegionId?: string(name='EnsRegionId'),
          name?: string(name='Name'),
          province?: string(name='Province'),
        }
      ](name='EnsRegionId')
      }(name='EnsRegionIdsExtends'),
      instanceSpeces?: {
        instanceSpec?: [ string ](name='InstanceSpec')
      }(name='InstanceSpeces'),
      systemDiskMaxSize?: int32(name='SystemDiskMaxSize'),
      systemDiskMinSize?: int32(name='SystemDiskMinSize'),
    }
  ](name='SupportResource')
  }(name='SupportResources'),
}

model DescribeAvailableResourceInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAvailableResourceInfoResponseBody(name='body'),
}

async function describeAvailableResourceInfoWithOptions(request: DescribeAvailableResourceInfoRequest, runtime: Util.RuntimeOptions): DescribeAvailableResourceInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAvailableResourceInfo',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAvailableResourceInfo(request: DescribeAvailableResourceInfoRequest): DescribeAvailableResourceInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableResourceInfoWithOptions(request, runtime);
}

model DescribeBandWithdChargeTypeRequest {
  version?: string(name='Version'),
}

model DescribeBandWithdChargeTypeResponseBody = {
  bandWithTypeInfo?: string(name='BandWithTypeInfo'),
  chargeContractType?: string(name='ChargeContractType'),
  chargeCycleInfo?: string(name='ChargeCycleInfo'),
  code?: int32(name='Code'),
  requestId?: string(name='RequestId'),
}

model DescribeBandWithdChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBandWithdChargeTypeResponseBody(name='body'),
}

async function describeBandWithdChargeTypeWithOptions(request: DescribeBandWithdChargeTypeRequest, runtime: Util.RuntimeOptions): DescribeBandWithdChargeTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBandWithdChargeType',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBandWithdChargeType(request: DescribeBandWithdChargeTypeRequest): DescribeBandWithdChargeTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBandWithdChargeTypeWithOptions(request, runtime);
}

model DescribeBandwitdhByInternetChargeTypeRequest {
  endTime?: string(name='EndTime'),
  ensRegionId?: string(name='EnsRegionId'),
  isp?: string(name='Isp'),
  startTime?: string(name='StartTime'),
  version?: string(name='Version'),
}

model DescribeBandwitdhByInternetChargeTypeResponseBody = {
  bandwidthValue?: long(name='BandwidthValue'),
  internetChargeType?: string(name='InternetChargeType'),
  requestId?: string(name='RequestId'),
  timeStamp?: string(name='TimeStamp'),
}

model DescribeBandwitdhByInternetChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBandwitdhByInternetChargeTypeResponseBody(name='body'),
}

async function describeBandwitdhByInternetChargeTypeWithOptions(request: DescribeBandwitdhByInternetChargeTypeRequest, runtime: Util.RuntimeOptions): DescribeBandwitdhByInternetChargeTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.isp)) {
    query['Isp'] = request.isp;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBandwitdhByInternetChargeType',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBandwitdhByInternetChargeType(request: DescribeBandwitdhByInternetChargeTypeRequest): DescribeBandwitdhByInternetChargeTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBandwitdhByInternetChargeTypeWithOptions(request, runtime);
}

model DescribeCloudDiskAvailableResourceInfoResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  supportResources?: {
    supportResource?: [ 
    {
      canBuyCount?: long(name='CanBuyCount'),
      category?: string(name='Category'),
      defaultDiskSize?: long(name='DefaultDiskSize'),
      diskMaxSize?: long(name='DiskMaxSize'),
      diskMinSize?: long(name='DiskMinSize'),
      ensRegionId?: string(name='EnsRegionId'),
      ensRegionName?: string(name='EnsRegionName'),
    }
  ](name='SupportResource')
  }(name='SupportResources'),
}

model DescribeCloudDiskAvailableResourceInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCloudDiskAvailableResourceInfoResponseBody(name='body'),
}

async function describeCloudDiskAvailableResourceInfoWithOptions(runtime: Util.RuntimeOptions): DescribeCloudDiskAvailableResourceInfoResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeCloudDiskAvailableResourceInfo',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCloudDiskAvailableResourceInfo(): DescribeCloudDiskAvailableResourceInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudDiskAvailableResourceInfoWithOptions(runtime);
}

model DescribeCloudDiskTypesRequest {
  ensRegionId?: string(name='EnsRegionId', description='A short description of struct'),
}

model DescribeCloudDiskTypesResponseBody = {
  requestId?: string(name='RequestId'),
  supportResources?: {
    supportResource?: [ 
    {
      category?: string(name='Category'),
      ensRegionId?: string(name='EnsRegionId'),
    }
  ](name='SupportResource')
  }(name='SupportResources'),
}

model DescribeCloudDiskTypesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCloudDiskTypesResponseBody(name='body'),
}

async function describeCloudDiskTypesWithOptions(request: DescribeCloudDiskTypesRequest, runtime: Util.RuntimeOptions): DescribeCloudDiskTypesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCloudDiskTypes',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCloudDiskTypes(request: DescribeCloudDiskTypesRequest): DescribeCloudDiskTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudDiskTypesWithOptions(request, runtime);
}

model DescribeCreatePrePaidInstanceResultRequest {
  instanceId?: string(name='InstanceId'),
  version?: string(name='Version'),
}

model DescribeCreatePrePaidInstanceResultResponseBody = {
  instanceCreateResult?: {
    instanceCreateStatus?: string(name='InstanceCreateStatus'),
    instanceId?: string(name='InstanceId'),
  }(name='InstanceCreateResult'),
  requestId?: string(name='RequestId'),
}

model DescribeCreatePrePaidInstanceResultResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCreatePrePaidInstanceResultResponseBody(name='body'),
}

async function describeCreatePrePaidInstanceResultWithOptions(request: DescribeCreatePrePaidInstanceResultRequest, runtime: Util.RuntimeOptions): DescribeCreatePrePaidInstanceResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCreatePrePaidInstanceResult',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCreatePrePaidInstanceResult(request: DescribeCreatePrePaidInstanceResultRequest): DescribeCreatePrePaidInstanceResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCreatePrePaidInstanceResultWithOptions(request, runtime);
}

model DescribeDataDistResultRequest {
  appId?: string(name='AppId'),
  dataNames?: string(name='DataNames'),
  dataVersions?: string(name='DataVersions'),
  instanceIds?: string(name='InstanceIds'),
  maxDate?: string(name='MaxDate'),
  minDate?: string(name='MinDate'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeDataDistResultResponseBody = {
  distResults?: {
    distResult?: [ 
    {
      name?: string(name='Name'),
      statusStats?: {
        statusStat?: [ 
        {
          instanceCount?: string(name='InstanceCount'),
          instances?: {
            instance?: [ 
            {
              instanceId?: string(name='InstanceId'),
              startTime?: string(name='StartTime'),
              statusDescrip?: string(name='StatusDescrip'),
              updateTime?: string(name='UpdateTime'),
            }
          ](name='Instance')
          }(name='Instances'),
          status?: string(name='Status'),
        }
      ](name='StatusStat')
      }(name='StatusStats'),
      version?: string(name='Version'),
    }
  ](name='DistResult')
  }(name='DistResults'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeDataDistResultResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDataDistResultResponseBody(name='body'),
}

async function describeDataDistResultWithOptions(request: DescribeDataDistResultRequest, runtime: Util.RuntimeOptions): DescribeDataDistResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.dataNames)) {
    query['DataNames'] = request.dataNames;
  }
  if (!Util.isUnset(request.dataVersions)) {
    query['DataVersions'] = request.dataVersions;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.maxDate)) {
    query['MaxDate'] = request.maxDate;
  }
  if (!Util.isUnset(request.minDate)) {
    query['MinDate'] = request.minDate;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDataDistResult',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDataDistResult(request: DescribeDataDistResultRequest): DescribeDataDistResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDataDistResultWithOptions(request, runtime);
}

model DescribeDataDownloadURLRequest {
  appId?: string(name='AppId'),
  dataName?: string(name='DataName'),
  dataVersion?: string(name='DataVersion'),
  expireTimeout?: long(name='ExpireTimeout'),
  serverFilterStrategy?: string(name='ServerFilterStrategy'),
}

model DescribeDataDownloadURLResponseBody = {
  code?: long(name='Code'),
  data?: {
    expireTime?: string(name='ExpireTime'),
    serverList?: [ 
      {
        host?: string(name='Host'),
        regionId?: string(name='RegionId'),
      }
    ](name='ServerList'),
    url?: string(name='Url'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DescribeDataDownloadURLResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDataDownloadURLResponseBody(name='body'),
}

async function describeDataDownloadURLWithOptions(request: DescribeDataDownloadURLRequest, runtime: Util.RuntimeOptions): DescribeDataDownloadURLResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDataDownloadURL',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDataDownloadURL(request: DescribeDataDownloadURLRequest): DescribeDataDownloadURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDataDownloadURLWithOptions(request, runtime);
}

model DescribeDataPushResultRequest {
  appId?: string(name='AppId'),
  dataNames?: string(name='DataNames'),
  dataVersions?: string(name='DataVersions'),
  maxDate?: string(name='MaxDate'),
  minDate?: string(name='MinDate'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionIds?: string(name='RegionIds'),
}

model DescribeDataPushResultResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  pushResults?: {
    pushResult?: [ 
    {
      name?: string(name='Name'),
      statusStatS?: {
        statusStat?: [ 
        {
          regionIdCount?: int32(name='RegionIdCount'),
          regionIds?: {
            regionId?: [ 
            {
              regionId?: string(name='RegionId'),
              startTime?: string(name='StartTime'),
              statusDescrip?: string(name='StatusDescrip'),
              updateTime?: string(name='UpdateTime'),
            }
          ](name='RegionId')
          }(name='RegionIds'),
          status?: string(name='Status'),
        }
      ](name='StatusStat')
      }(name='StatusStatS'),
      version?: string(name='Version'),
    }
  ](name='PushResult')
  }(name='PushResults'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeDataPushResultResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDataPushResultResponseBody(name='body'),
}

async function describeDataPushResultWithOptions(request: DescribeDataPushResultRequest, runtime: Util.RuntimeOptions): DescribeDataPushResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.dataNames)) {
    query['DataNames'] = request.dataNames;
  }
  if (!Util.isUnset(request.dataVersions)) {
    query['DataVersions'] = request.dataVersions;
  }
  if (!Util.isUnset(request.maxDate)) {
    query['MaxDate'] = request.maxDate;
  }
  if (!Util.isUnset(request.minDate)) {
    query['MinDate'] = request.minDate;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionIds)) {
    query['RegionIds'] = request.regionIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDataPushResult',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDataPushResult(request: DescribeDataPushResultRequest): DescribeDataPushResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDataPushResultWithOptions(request, runtime);
}

model DescribeDeviceServiceRequest {
  appId?: string(name='AppId'),
  ensRegionId?: string(name='EnsRegionId'),
  instanceId?: string(name='InstanceId'),
  orderId?: string(name='OrderId'),
  regionId?: string(name='RegionId'),
  serviceId?: string(name='ServiceId', description='Service ID'),
}

model DescribeDeviceServiceResponseBody = {
  appMetaData?: {
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    appStableVersion?: string(name='AppStableVersion'),
    appType?: string(name='AppType'),
    clusterName?: string(name='ClusterName'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
  }(name='AppMetaData'),
  appStatus?: {
    phase?: string(name='Phase'),
    statusDescrip?: string(name='StatusDescrip'),
    updateTime?: string(name='UpdateTime'),
  }(name='AppStatus'),
  requestId?: string(name='RequestId', description='Id of the request'),
  resourceDetailInfos?: [ 
    {
      deviceName?: string(name='DeviceName'),
      ID?: string(name='ID'),
      IP?: string(name='IP'),
      ISP?: string(name='ISP'),
      imageID?: string(name='ImageID'),
      mac?: string(name='Mac'),
      regionID?: string(name='RegionID'),
      server?: string(name='Server'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='ResourceDetailInfos'),
  resourceInfos?: [ 
    {
      appVersion?: string(name='AppVersion'),
      areaCode?: string(name='AreaCode'),
      areaName?: string(name='AreaName'),
      createTime?: string(name='CreateTime'),
      deviceInfos?: [ 
        {
          name?: string(name='Name'),
          network?: [ 
            {
              containerPorts?: string(name='ContainerPorts'),
              externalIp?: string(name='ExternalIp'),
              hostPorts?: string(name='HostPorts'),
              protocol?: string(name='Protocol'),
            }
          ](name='Network'),
          status?: string(name='Status'),
        }
      ](name='DeviceInfos'),
      instanceId?: string(name='InstanceId'),
      instanceStatus?: string(name='InstanceStatus'),
      internalIps?: [ 
        {
          ip?: string(name='Ip'),
        }
      ](name='InternalIps'),
      publicIps?: [ 
        {
          ip?: string(name='Ip'),
        }
      ](name='PublicIps'),
      regionCode?: string(name='RegionCode'),
      regionId?: string(name='RegionId'),
      regionName?: string(name='RegionName'),
    }
  ](name='ResourceInfos'),
}

model DescribeDeviceServiceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDeviceServiceResponseBody(name='body'),
}

async function describeDeviceServiceWithOptions(request: DescribeDeviceServiceRequest, runtime: Util.RuntimeOptions): DescribeDeviceServiceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDeviceService',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDeviceService(request: DescribeDeviceServiceRequest): DescribeDeviceServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDeviceServiceWithOptions(request, runtime);
}

model DescribeDisksRequest {
  category?: string(name='Category'),
  diskChargeType?: string(name='DiskChargeType'),
  diskId?: string(name='DiskId'),
  diskIds?: string(name='DiskIds'),
  diskName?: string(name='DiskName'),
  diskType?: string(name='DiskType'),
  ensRegionId?: string(name='EnsRegionId'),
  ensRegionIds?: string(name='EnsRegionIds'),
  orderByParams?: string(name='OrderByParams'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  status?: string(name='Status'),
  type?: string(name='Type'),
}

model DescribeDisksResponseBody = {
  code?: int32(name='Code'),
  disks?: {
    disks?: [ 
    {
      category?: string(name='Category'),
      creationTime?: string(name='CreationTime'),
      diskChargeType?: string(name='DiskChargeType'),
      diskId?: string(name='DiskId'),
      diskName?: string(name='DiskName'),
      ensRegionId?: string(name='EnsRegionId'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      portable?: boolean(name='Portable'),
      size?: int32(name='Size'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='Disks')
  }(name='Disks'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeDisksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDisksResponseBody(name='body'),
}

async function describeDisksWithOptions(request: DescribeDisksRequest, runtime: Util.RuntimeOptions): DescribeDisksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.diskChargeType)) {
    query['DiskChargeType'] = request.diskChargeType;
  }
  if (!Util.isUnset(request.diskId)) {
    query['DiskId'] = request.diskId;
  }
  if (!Util.isUnset(request.diskIds)) {
    query['DiskIds'] = request.diskIds;
  }
  if (!Util.isUnset(request.diskName)) {
    query['DiskName'] = request.diskName;
  }
  if (!Util.isUnset(request.diskType)) {
    query['DiskType'] = request.diskType;
  }
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.ensRegionIds)) {
    query['EnsRegionIds'] = request.ensRegionIds;
  }
  if (!Util.isUnset(request.orderByParams)) {
    query['OrderByParams'] = request.orderByParams;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDisks',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDisks(request: DescribeDisksRequest): DescribeDisksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDisksWithOptions(request, runtime);
}

model DescribeEipAddressesRequest {
  eips?: string(name='Eips'),
  ensRegionId?: string(name='EnsRegionId'),
  version?: string(name='Version'),
}

model DescribeEipAddressesResponseBody = {
  eipAddresses?: {
    eipAddress?: [ 
    {
      eip?: string(name='Eip'),
      instanceIdInternetIp?: string(name='InstanceIdInternetIp'),
    }
  ](name='EipAddress')
  }(name='EipAddresses'),
  requestId?: string(name='RequestId'),
}

model DescribeEipAddressesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEipAddressesResponseBody(name='body'),
}

async function describeEipAddressesWithOptions(request: DescribeEipAddressesRequest, runtime: Util.RuntimeOptions): DescribeEipAddressesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eips)) {
    query['Eips'] = request.eips;
  }
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEipAddresses',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEipAddresses(request: DescribeEipAddressesRequest): DescribeEipAddressesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEipAddressesWithOptions(request, runtime);
}

model DescribeElbAvailableResourceInfoResponseBody = {
  elbAvailableResourceInfo?: [ 
    {
      area?: string(name='Area'),
      canBuyCount?: string(name='CanBuyCount'),
      enName?: string(name='EnName'),
      ensRegionId?: string(name='EnsRegionId'),
      loadBalancerSpec?: [ string ](name='LoadBalancerSpec'),
      name?: string(name='Name'),
      province?: string(name='Province'),
    }
  ](name='ElbAvailableResourceInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeElbAvailableResourceInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeElbAvailableResourceInfoResponseBody(name='body'),
}

async function describeElbAvailableResourceInfoWithOptions(runtime: Util.RuntimeOptions): DescribeElbAvailableResourceInfoResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeElbAvailableResourceInfo',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeElbAvailableResourceInfo(): DescribeElbAvailableResourceInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeElbAvailableResourceInfoWithOptions(runtime);
}

model DescribeEnsEipAddressesRequest {
  allocationId?: string(name='AllocationId', description='要查询的EIP实例的ID。  最多支持输入50个EIP实例ID，实例ID之间用逗号（,）分隔。'),
  associatedInstanceId?: string(name='AssociatedInstanceId'),
  associatedInstanceType?: string(name='AssociatedInstanceType'),
  eipAddress?: string(name='EipAddress', description='要查询的EIP的IP地址。  最多支持输入50个EIP的IP地址，IP地址之间用逗号（,）分隔。'),
  ensRegionId?: string(name='EnsRegionId', description='ENS节点ID'),
  pageNumber?: int32(name='PageNumber', description='列表的页码，默认值为1。'),
  pageSize?: int32(name='PageSize', description='分页查询时每页的行数，最大值为100，默认值为10。'),
}

model DescribeEnsEipAddressesResponseBody = {
  eipAddresses?: {
    eipAddress?: [ 
    {
      allocationId?: string(name='AllocationId'),
      allocationTime?: string(name='AllocationTime'),
      bandwidth?: int32(name='Bandwidth'),
      chargeType?: string(name='ChargeType'),
      description?: string(name='Description'),
      ensRegionId?: string(name='EnsRegionId'),
      instanceId?: string(name='InstanceId'),
      instanceType?: string(name='InstanceType'),
      internetChargeType?: string(name='InternetChargeType'),
      ipAddress?: string(name='IpAddress'),
      isp?: string(name='Isp'),
      name?: string(name='Name'),
      status?: string(name='Status'),
    }
  ](name='EipAddress')
  }(name='EipAddresses'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeEnsEipAddressesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEnsEipAddressesResponseBody(name='body'),
}

async function describeEnsEipAddressesWithOptions(request: DescribeEnsEipAddressesRequest, runtime: Util.RuntimeOptions): DescribeEnsEipAddressesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allocationId)) {
    query['AllocationId'] = request.allocationId;
  }
  if (!Util.isUnset(request.associatedInstanceId)) {
    query['AssociatedInstanceId'] = request.associatedInstanceId;
  }
  if (!Util.isUnset(request.associatedInstanceType)) {
    query['AssociatedInstanceType'] = request.associatedInstanceType;
  }
  if (!Util.isUnset(request.eipAddress)) {
    query['EipAddress'] = request.eipAddress;
  }
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEnsEipAddresses',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEnsEipAddresses(request: DescribeEnsEipAddressesRequest): DescribeEnsEipAddressesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEnsEipAddressesWithOptions(request, runtime);
}

model DescribeEnsNetDistrictRequest {
  netDistrictCode?: string(name='NetDistrictCode'),
  netLevelCode?: string(name='NetLevelCode'),
  version?: string(name='Version'),
}

model DescribeEnsNetDistrictResponseBody = {
  code?: int32(name='Code'),
  ensNetDistricts?: {
    ensNetDistrict?: [ 
    {
      ensRegionIdCount?: string(name='EnsRegionIdCount'),
      netDistrictCode?: string(name='NetDistrictCode'),
      netDistrictEnName?: string(name='NetDistrictEnName'),
      netDistrictFatherCode?: string(name='NetDistrictFatherCode'),
      netDistrictLevel?: string(name='NetDistrictLevel'),
      netDistrictName?: string(name='NetDistrictName'),
    }
  ](name='EnsNetDistrict')
  }(name='EnsNetDistricts'),
  requestId?: string(name='RequestId'),
}

model DescribeEnsNetDistrictResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEnsNetDistrictResponseBody(name='body'),
}

async function describeEnsNetDistrictWithOptions(request: DescribeEnsNetDistrictRequest, runtime: Util.RuntimeOptions): DescribeEnsNetDistrictResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.netDistrictCode)) {
    query['NetDistrictCode'] = request.netDistrictCode;
  }
  if (!Util.isUnset(request.netLevelCode)) {
    query['NetLevelCode'] = request.netLevelCode;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEnsNetDistrict',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEnsNetDistrict(request: DescribeEnsNetDistrictRequest): DescribeEnsNetDistrictResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEnsNetDistrictWithOptions(request, runtime);
}

model DescribeEnsNetLevelRequest {
  version?: string(name='Version'),
}

model DescribeEnsNetLevelResponseBody = {
  code?: int32(name='Code'),
  ensNetLevels?: {
    ensNetLevel?: [ 
    {
      ensNetLevelCode?: string(name='EnsNetLevelCode'),
    }
  ](name='EnsNetLevel')
  }(name='EnsNetLevels'),
  requestId?: string(name='RequestId'),
}

model DescribeEnsNetLevelResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEnsNetLevelResponseBody(name='body'),
}

async function describeEnsNetLevelWithOptions(request: DescribeEnsNetLevelRequest, runtime: Util.RuntimeOptions): DescribeEnsNetLevelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEnsNetLevel',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEnsNetLevel(request: DescribeEnsNetLevelRequest): DescribeEnsNetLevelResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEnsNetLevelWithOptions(request, runtime);
}

model DescribeEnsNetSaleDistrictRequest {
  netDistrictCode?: string(name='NetDistrictCode'),
  netLevelCode?: string(name='NetLevelCode'),
  version?: string(name='Version'),
}

model DescribeEnsNetSaleDistrictResponseBody = {
  code?: int32(name='Code'),
  ensNetDistricts?: {
    ensNetDistrict?: [ 
    {
      ensRegionIdCount?: string(name='EnsRegionIdCount'),
      instanceCount?: string(name='InstanceCount'),
      netDistrictCode?: string(name='NetDistrictCode'),
      netDistrictEnName?: string(name='NetDistrictEnName'),
      netDistrictFatherCode?: string(name='NetDistrictFatherCode'),
      netDistrictLevel?: string(name='NetDistrictLevel'),
      netDistrictName?: string(name='NetDistrictName'),
    }
  ](name='EnsNetDistrict')
  }(name='EnsNetDistricts'),
  requestId?: string(name='RequestId'),
}

model DescribeEnsNetSaleDistrictResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEnsNetSaleDistrictResponseBody(name='body'),
}

async function describeEnsNetSaleDistrictWithOptions(request: DescribeEnsNetSaleDistrictRequest, runtime: Util.RuntimeOptions): DescribeEnsNetSaleDistrictResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.netDistrictCode)) {
    query['NetDistrictCode'] = request.netDistrictCode;
  }
  if (!Util.isUnset(request.netLevelCode)) {
    query['NetLevelCode'] = request.netLevelCode;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEnsNetSaleDistrict',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEnsNetSaleDistrict(request: DescribeEnsNetSaleDistrictRequest): DescribeEnsNetSaleDistrictResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEnsNetSaleDistrictWithOptions(request, runtime);
}

model DescribeEnsRegionIdIpv6InfoRequest {
  ensRegionId?: string(name='EnsRegionId'),
  version?: string(name='Version'),
}

model DescribeEnsRegionIdIpv6InfoResponseBody = {
  requestId?: string(name='RequestId'),
  supportIpv6Info?: {
    ensRegionId?: string(name='EnsRegionId'),
    supportIpv6?: boolean(name='SupportIpv6'),
  }(name='SupportIpv6Info'),
}

model DescribeEnsRegionIdIpv6InfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEnsRegionIdIpv6InfoResponseBody(name='body'),
}

async function describeEnsRegionIdIpv6InfoWithOptions(request: DescribeEnsRegionIdIpv6InfoRequest, runtime: Util.RuntimeOptions): DescribeEnsRegionIdIpv6InfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEnsRegionIdIpv6Info',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEnsRegionIdIpv6Info(request: DescribeEnsRegionIdIpv6InfoRequest): DescribeEnsRegionIdIpv6InfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEnsRegionIdIpv6InfoWithOptions(request, runtime);
}

model DescribeEnsRegionIdResourceRequest {
  endTime?: string(name='EndTime'),
  isp?: string(name='Isp'),
  orderByParams?: string(name='OrderByParams'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  startTime?: string(name='StartTime'),
}

model DescribeEnsRegionIdResourceResponseBody = {
  ensRegionIdResources?: {
    ensRegionIdResource?: [ 
    {
      area?: string(name='Area'),
      areaCode?: string(name='AreaCode'),
      bizDate?: string(name='BizDate'),
      ensRegionId?: string(name='EnsRegionId'),
      ensRegionIdName?: string(name='EnsRegionIdName'),
      instanceCount?: int32(name='InstanceCount'),
      internetBandwidth?: long(name='InternetBandwidth'),
      isp?: string(name='Isp'),
      VCpu?: int32(name='VCpu'),
    }
  ](name='EnsRegionIdResource')
  }(name='EnsRegionIdResources'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeEnsRegionIdResourceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEnsRegionIdResourceResponseBody(name='body'),
}

async function describeEnsRegionIdResourceWithOptions(request: DescribeEnsRegionIdResourceRequest, runtime: Util.RuntimeOptions): DescribeEnsRegionIdResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.isp)) {
    query['Isp'] = request.isp;
  }
  if (!Util.isUnset(request.orderByParams)) {
    query['OrderByParams'] = request.orderByParams;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEnsRegionIdResource',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEnsRegionIdResource(request: DescribeEnsRegionIdResourceRequest): DescribeEnsRegionIdResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEnsRegionIdResourceWithOptions(request, runtime);
}

model DescribeEnsRegionsRequest {
  ensRegionId?: string(name='EnsRegionId'),
  version?: string(name='Version'),
}

model DescribeEnsRegionsResponseBody = {
  code?: int32(name='Code'),
  ensRegions?: {
    ensRegions?: [ 
    {
      area?: string(name='Area'),
      enName?: string(name='EnName'),
      ensRegionId?: string(name='EnsRegionId'),
      name?: string(name='Name'),
      province?: string(name='Province'),
    }
  ](name='EnsRegions')
  }(name='EnsRegions'),
  requestId?: string(name='RequestId'),
}

model DescribeEnsRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEnsRegionsResponseBody(name='body'),
}

async function describeEnsRegionsWithOptions(request: DescribeEnsRegionsRequest, runtime: Util.RuntimeOptions): DescribeEnsRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEnsRegions',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEnsRegions(request: DescribeEnsRegionsRequest): DescribeEnsRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEnsRegionsWithOptions(request, runtime);
}

model DescribeEnsResourceUsageRequest {
  expiredEndTime?: string(name='ExpiredEndTime', description='vm实例使用结束时间查询结束范围，，格式： yyyy-MM-dd或yyyy-MM-dd HH:mm:ss'),
  expiredStartTime?: string(name='ExpiredStartTime', description='vm实例使用结束时间查询开始范围，格式： yyyy-MM-dd或yyyy-MM-dd HH:mm:ss'),
}

model DescribeEnsResourceUsageResponseBody = {
  ensResourceUsage?: [ 
    {
      computeResourceCount?: int32(name='ComputeResourceCount'),
      cpuSum?: long(name='CpuSum'),
      diskCount?: int32(name='DiskCount'),
      downCount?: int32(name='DownCount'),
      expiredCount?: int32(name='ExpiredCount'),
      expiringCount?: int32(name='ExpiringCount'),
      gpuSum?: long(name='GpuSum'),
      instanceCount?: int32(name='InstanceCount'),
      runningCount?: int32(name='RunningCount'),
      serviceType?: string(name='ServiceType'),
      storageSum?: long(name='StorageSum'),
    }
  ](name='EnsResourceUsage'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DescribeEnsResourceUsageResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEnsResourceUsageResponseBody(name='body'),
}

async function describeEnsResourceUsageWithOptions(request: DescribeEnsResourceUsageRequest, runtime: Util.RuntimeOptions): DescribeEnsResourceUsageResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEnsResourceUsage',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEnsResourceUsage(request: DescribeEnsResourceUsageRequest): DescribeEnsResourceUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEnsResourceUsageWithOptions(request, runtime);
}

model DescribeEnsRouteEntryListRequest {
  destinationCidrBlock?: string(name='DestinationCidrBlock', description='路由条目的目标网段'),
  nextHopId?: string(name='NextHopId', description='下一跳实例ID。'),
  nextHopType?: string(name='NextHopType', description='下一跳类型'),
  pageNumber?: int32(name='PageNumber', description='列表的页码，默认值为1。'),
  pageSize?: int32(name='PageSize', description='分页查询时每页的行数，最大值为100，默认值为10。'),
  routeEntryId?: string(name='RouteEntryId', description='要查询的路由条目的ID。'),
  routeEntryName?: string(name='RouteEntryName', description='路由条目的名称。'),
  routeEntryType?: string(name='RouteEntryType', description='路由条目的类型'),
  routeTableId?: string(name='RouteTableId', description='要查询的路由表的ID。'),
}

model DescribeEnsRouteEntryListResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  routeEntrys?: [ 
    {
      description?: string(name='Description', description='路由条目的描述信息。'),
      destinationCidrBlock?: string(name='DestinationCidrBlock', description='路由条目的目标网段。'),
      nextHops?: [ 
        {
          nextHopId?: string(name='NextHopId', description='下一跳实例ID。'),
          nextHopType?: string(name='NextHopType', description='下一跳类型'),
        }
      ](name='NextHops', description='下一跳'),
      routeEntryId?: string(name='RouteEntryId', description='路由条目的ID。'),
      routeEntryName?: string(name='RouteEntryName', description='路由条目的名称。'),
      routeTableId?: string(name='RouteTableId', description='路由表ID。'),
      status?: string(name='Status', description='路由条目的状态'),
      type?: string(name='Type', description='路由条目的类型'),
    }
  ](name='RouteEntrys', description='路由条目信息。'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeEnsRouteEntryListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEnsRouteEntryListResponseBody(name='body'),
}

async function describeEnsRouteEntryListWithOptions(request: DescribeEnsRouteEntryListRequest, runtime: Util.RuntimeOptions): DescribeEnsRouteEntryListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.destinationCidrBlock)) {
    query['DestinationCidrBlock'] = request.destinationCidrBlock;
  }
  if (!Util.isUnset(request.nextHopId)) {
    query['NextHopId'] = request.nextHopId;
  }
  if (!Util.isUnset(request.nextHopType)) {
    query['NextHopType'] = request.nextHopType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.routeEntryId)) {
    query['RouteEntryId'] = request.routeEntryId;
  }
  if (!Util.isUnset(request.routeEntryName)) {
    query['RouteEntryName'] = request.routeEntryName;
  }
  if (!Util.isUnset(request.routeEntryType)) {
    query['RouteEntryType'] = request.routeEntryType;
  }
  if (!Util.isUnset(request.routeTableId)) {
    query['RouteTableId'] = request.routeTableId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEnsRouteEntryList',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEnsRouteEntryList(request: DescribeEnsRouteEntryListRequest): DescribeEnsRouteEntryListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEnsRouteEntryListWithOptions(request, runtime);
}

model DescribeEpnBandWidthDataRequest {
  EPNInstanceId?: string(name='EPNInstanceId'),
  endTime?: string(name='EndTime'),
  ensRegionId?: string(name='EnsRegionId'),
  instanceId?: string(name='InstanceId'),
  isp?: string(name='Isp'),
  networkingModel?: string(name='NetworkingModel'),
  period?: string(name='Period'),
  startTime?: string(name='StartTime'),
  version?: string(name='Version'),
}

model DescribeEpnBandWidthDataResponseBody = {
  monitorData?: {
    bandWidthMonitorData?: [ 
      {
        downBandWidth?: long(name='DownBandWidth'),
        internetRX?: long(name='InternetRX'),
        internetTX?: long(name='InternetTX'),
        timeStamp?: string(name='TimeStamp'),
        upBandWidth?: long(name='UpBandWidth'),
      }
    ](name='BandWidthMonitorData'),
    maxDownBandWidth?: long(name='MaxDownBandWidth'),
    maxUpBandWidth?: long(name='MaxUpBandWidth'),
  }(name='MonitorData'),
  requestId?: string(name='RequestId'),
}

model DescribeEpnBandWidthDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEpnBandWidthDataResponseBody(name='body'),
}

async function describeEpnBandWidthDataWithOptions(request: DescribeEpnBandWidthDataRequest, runtime: Util.RuntimeOptions): DescribeEpnBandWidthDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.EPNInstanceId)) {
    query['EPNInstanceId'] = request.EPNInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.isp)) {
    query['Isp'] = request.isp;
  }
  if (!Util.isUnset(request.networkingModel)) {
    query['NetworkingModel'] = request.networkingModel;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEpnBandWidthData',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEpnBandWidthData(request: DescribeEpnBandWidthDataRequest): DescribeEpnBandWidthDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEpnBandWidthDataWithOptions(request, runtime);
}

model DescribeEpnBandwitdhByInternetChargeTypeRequest {
  endTime?: string(name='EndTime'),
  ensRegionId?: string(name='EnsRegionId'),
  isp?: string(name='Isp'),
  networkingModel?: string(name='NetworkingModel'),
  startTime?: string(name='StartTime'),
  version?: string(name='Version'),
}

model DescribeEpnBandwitdhByInternetChargeTypeResponseBody = {
  bandwidthValue?: long(name='BandwidthValue'),
  internetChargeType?: string(name='InternetChargeType'),
  requestId?: string(name='RequestId'),
  timeStamp?: string(name='TimeStamp'),
}

model DescribeEpnBandwitdhByInternetChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEpnBandwitdhByInternetChargeTypeResponseBody(name='body'),
}

async function describeEpnBandwitdhByInternetChargeTypeWithOptions(request: DescribeEpnBandwitdhByInternetChargeTypeRequest, runtime: Util.RuntimeOptions): DescribeEpnBandwitdhByInternetChargeTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.isp)) {
    query['Isp'] = request.isp;
  }
  if (!Util.isUnset(request.networkingModel)) {
    query['NetworkingModel'] = request.networkingModel;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEpnBandwitdhByInternetChargeType',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEpnBandwitdhByInternetChargeType(request: DescribeEpnBandwitdhByInternetChargeTypeRequest): DescribeEpnBandwitdhByInternetChargeTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEpnBandwitdhByInternetChargeTypeWithOptions(request, runtime);
}

model DescribeEpnInstanceAttributeRequest {
  EPNInstanceId?: string(name='EPNInstanceId'),
}

model DescribeEpnInstanceAttributeResponseBody = {
  confVersions?: [ 
    {
      confVersion?: string(name='ConfVersion'),
      ensRegionId?: string(name='EnsRegionId'),
    }
  ](name='ConfVersions'),
  EPNInstanceId?: string(name='EPNInstanceId'),
  EPNInstanceName?: string(name='EPNInstanceName'),
  instances?: [ 
    {
      ensRegionId?: string(name='EnsRegionId'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      isp?: string(name='Isp'),
      privateIpAddress?: string(name='PrivateIpAddress'),
      publicIpAddress?: string(name='PublicIpAddress'),
      status?: string(name='Status'),
    }
  ](name='Instances'),
  networkingModel?: string(name='NetworkingModel'),
  requestId?: string(name='RequestId'),
  vSwitches?: [ 
    {
      cidrBlock?: string(name='CidrBlock'),
      ensRegionId?: string(name='EnsRegionId'),
      vSwitchId?: string(name='VSwitchId'),
      vSwitchName?: string(name='VSwitchName'),
    }
  ](name='VSwitches'),
}

model DescribeEpnInstanceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEpnInstanceAttributeResponseBody(name='body'),
}

async function describeEpnInstanceAttributeWithOptions(request: DescribeEpnInstanceAttributeRequest, runtime: Util.RuntimeOptions): DescribeEpnInstanceAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.EPNInstanceId)) {
    query['EPNInstanceId'] = request.EPNInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEpnInstanceAttribute',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEpnInstanceAttribute(request: DescribeEpnInstanceAttributeRequest): DescribeEpnInstanceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEpnInstanceAttributeWithOptions(request, runtime);
}

model DescribeEpnInstancesRequest {
  EPNInstanceId?: string(name='EPNInstanceId'),
  EPNInstanceName?: string(name='EPNInstanceName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeEpnInstancesResponseBody = {
  EPNInstances?: {
    EPNInstance?: [ 
    {
      creationTime?: string(name='CreationTime'),
      EPNInstanceId?: string(name='EPNInstanceId'),
      EPNInstanceName?: string(name='EPNInstanceName'),
      EPNInstanceType?: string(name='EPNInstanceType'),
      endTime?: string(name='EndTime'),
      internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut'),
      modifyTime?: string(name='ModifyTime'),
      networkingModel?: string(name='NetworkingModel'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
    }
  ](name='EPNInstance')
  }(name='EPNInstances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeEpnInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEpnInstancesResponseBody(name='body'),
}

async function describeEpnInstancesWithOptions(request: DescribeEpnInstancesRequest, runtime: Util.RuntimeOptions): DescribeEpnInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.EPNInstanceId)) {
    query['EPNInstanceId'] = request.EPNInstanceId;
  }
  if (!Util.isUnset(request.EPNInstanceName)) {
    query['EPNInstanceName'] = request.EPNInstanceName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEpnInstances',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEpnInstances(request: DescribeEpnInstancesRequest): DescribeEpnInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEpnInstancesWithOptions(request, runtime);
}

model DescribeEpnMeasurementDataRequest {
  endDate?: string(name='EndDate'),
  startDate?: string(name='StartDate'),
  version?: string(name='Version'),
}

model DescribeEpnMeasurementDataResponseBody = {
  measurementDatas?: {
    measurementData?: [ 
    {
      bandWidthFeeDatas?: {
        bandWidthFeeData?: [ 
        {
          costCode?: string(name='CostCode'),
          costName?: string(name='CostName'),
          costType?: string(name='CostType'),
          costVal?: int32(name='CostVal'),
          ispLine?: string(name='IspLine'),
        }
      ](name='BandWidthFeeData')
      }(name='BandWidthFeeDatas'),
      chargeModel?: string(name='ChargeModel'),
      costCycle?: string(name='CostCycle'),
      costEndTime?: string(name='CostEndTime'),
      costStartTime?: string(name='CostStartTime'),
    }
  ](name='MeasurementData')
  }(name='MeasurementDatas'),
  requestId?: string(name='RequestId'),
}

model DescribeEpnMeasurementDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEpnMeasurementDataResponseBody(name='body'),
}

async function describeEpnMeasurementDataWithOptions(request: DescribeEpnMeasurementDataRequest, runtime: Util.RuntimeOptions): DescribeEpnMeasurementDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEpnMeasurementData',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEpnMeasurementData(request: DescribeEpnMeasurementDataRequest): DescribeEpnMeasurementDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEpnMeasurementDataWithOptions(request, runtime);
}

model DescribeExportImageInfoRequest {
  imageId?: string(name='ImageId'),
  imageName?: string(name='ImageName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeExportImageInfoResponseBody = {
  images?: {
    image?: [ 
    {
      architecture?: string(name='Architecture'),
      creationTime?: string(name='CreationTime'),
      exportedImageURL?: string(name='ExportedImageURL'),
      imageExportStatus?: string(name='ImageExportStatus'),
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
      imageOwnerAlias?: string(name='ImageOwnerAlias'),
      platform?: string(name='Platform'),
    }
  ](name='Image')
  }(name='Images'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeExportImageInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeExportImageInfoResponseBody(name='body'),
}

async function describeExportImageInfoWithOptions(request: DescribeExportImageInfoRequest, runtime: Util.RuntimeOptions): DescribeExportImageInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExportImageInfo',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeExportImageInfo(request: DescribeExportImageInfoRequest): DescribeExportImageInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExportImageInfoWithOptions(request, runtime);
}

model DescribeExportImageStatusRequest {
  imageId?: string(name='ImageId'),
  version?: string(name='Version'),
}

model DescribeExportImageStatusResponseBody = {
  imageExportStatus?: string(name='ImageExportStatus'),
  requestId?: string(name='RequestId'),
}

model DescribeExportImageStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeExportImageStatusResponseBody(name='body'),
}

async function describeExportImageStatusWithOptions(request: DescribeExportImageStatusRequest, runtime: Util.RuntimeOptions): DescribeExportImageStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExportImageStatus',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeExportImageStatus(request: DescribeExportImageStatusRequest): DescribeExportImageStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExportImageStatusWithOptions(request, runtime);
}

model DescribeForwardTableEntriesRequest {
  externalIp?: string(name='ExternalIp'),
  forwardEntryId?: string(name='ForwardEntryId'),
  forwardEntryName?: string(name='ForwardEntryName'),
  internalIp?: string(name='InternalIp'),
  ipProtocol?: string(name='IpProtocol'),
  natGatewayId?: string(name='NatGatewayId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeForwardTableEntriesResponseBody = {
  forwardTableEntries?: [ 
    {
      externalIp?: string(name='ExternalIp'),
      externalPort?: string(name='ExternalPort'),
      forwardEntryId?: string(name='ForwardEntryId'),
      forwardEntryName?: string(name='ForwardEntryName'),
      internalIp?: string(name='InternalIp'),
      internalPort?: string(name='InternalPort'),
      ipProtocol?: string(name='IpProtocol'),
      natGatewayId?: string(name='NatGatewayId'),
      status?: string(name='Status'),
    }
  ](name='ForwardTableEntries'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: string(name='TotalCount'),
}

model DescribeForwardTableEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeForwardTableEntriesResponseBody(name='body'),
}

async function describeForwardTableEntriesWithOptions(request: DescribeForwardTableEntriesRequest, runtime: Util.RuntimeOptions): DescribeForwardTableEntriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.externalIp)) {
    query['ExternalIp'] = request.externalIp;
  }
  if (!Util.isUnset(request.forwardEntryId)) {
    query['ForwardEntryId'] = request.forwardEntryId;
  }
  if (!Util.isUnset(request.forwardEntryName)) {
    query['ForwardEntryName'] = request.forwardEntryName;
  }
  if (!Util.isUnset(request.internalIp)) {
    query['InternalIp'] = request.internalIp;
  }
  if (!Util.isUnset(request.ipProtocol)) {
    query['IpProtocol'] = request.ipProtocol;
  }
  if (!Util.isUnset(request.natGatewayId)) {
    query['NatGatewayId'] = request.natGatewayId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeForwardTableEntries',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeForwardTableEntries(request: DescribeForwardTableEntriesRequest): DescribeForwardTableEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeForwardTableEntriesWithOptions(request, runtime);
}

model DescribeImageInfosRequest {
  osType?: string(name='OsType'),
  version?: string(name='Version'),
}

model DescribeImageInfosResponseBody = {
  code?: int32(name='Code'),
  images?: {
    image?: [ 
    {
      description?: string(name='Description'),
      imageId?: string(name='ImageId'),
      imageSize?: string(name='ImageSize'),
      imageVersion?: string(name='ImageVersion'),
      OSName?: string(name='OSName'),
      OSType?: string(name='OSType'),
    }
  ](name='Image')
  }(name='Images'),
  requestId?: string(name='RequestId'),
}

model DescribeImageInfosResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImageInfosResponseBody(name='body'),
}

async function describeImageInfosWithOptions(request: DescribeImageInfosRequest, runtime: Util.RuntimeOptions): DescribeImageInfosResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageInfos',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageInfos(request: DescribeImageInfosRequest): DescribeImageInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageInfosWithOptions(request, runtime);
}

model DescribeImageSharePermissionRequest {
  aliyunId?: long(name='AliyunId'),
  imageId?: string(name='ImageId'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
}

model DescribeImageSharePermissionResponseBody = {
  accounts?: {
    account?: [ string ](name='Account')
  }(name='Accounts'),
  imageId?: string(name='ImageId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeImageSharePermissionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImageSharePermissionResponseBody(name='body'),
}

async function describeImageSharePermissionWithOptions(request: DescribeImageSharePermissionRequest, runtime: Util.RuntimeOptions): DescribeImageSharePermissionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliyunId)) {
    query['AliyunId'] = request.aliyunId;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageSharePermission',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageSharePermission(request: DescribeImageSharePermissionRequest): DescribeImageSharePermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageSharePermissionWithOptions(request, runtime);
}

model DescribeImagesRequest {
  ensRegionId?: string(name='EnsRegionId'),
  imageId?: string(name='ImageId'),
  imageName?: string(name='ImageName'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  status?: string(name='Status'),
  version?: string(name='Version'),
  product?: string(name='product'),
}

model DescribeImagesResponseBody = {
  code?: int32(name='Code'),
  images?: {
    image?: [ 
    {
      architecture?: string(name='Architecture'),
      creationTime?: string(name='CreationTime'),
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
      imageOwnerAlias?: string(name='ImageOwnerAlias'),
      imageSize?: string(name='ImageSize'),
      platform?: string(name='Platform'),
    }
  ](name='Image')
  }(name='Images'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeImagesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImagesResponseBody(name='body'),
}

async function describeImagesWithOptions(request: DescribeImagesRequest, runtime: Util.RuntimeOptions): DescribeImagesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  if (!Util.isUnset(request.product)) {
    query['product'] = request.product;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImages',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImages(request: DescribeImagesRequest): DescribeImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImagesWithOptions(request, runtime);
}

model DescribeInstanceAutoRenewAttributeRequest {
  instanceIds?: string(name='InstanceIds'),
  ownerId?: long(name='OwnerId'),
  version?: string(name='Version'),
}

model DescribeInstanceAutoRenewAttributeResponseBody = {
  code?: int32(name='Code'),
  instanceRenewAttributes?: {
    instanceRenewAttribute?: [ 
    {
      autoRenewal?: boolean(name='AutoRenewal'),
      duration?: string(name='Duration'),
      instanceId?: string(name='InstanceId'),
    }
  ](name='InstanceRenewAttribute')
  }(name='InstanceRenewAttributes'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceAutoRenewAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceAutoRenewAttributeResponseBody(name='body'),
}

async function describeInstanceAutoRenewAttributeWithOptions(request: DescribeInstanceAutoRenewAttributeRequest, runtime: Util.RuntimeOptions): DescribeInstanceAutoRenewAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceAutoRenewAttribute',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceAutoRenewAttribute(request: DescribeInstanceAutoRenewAttributeRequest): DescribeInstanceAutoRenewAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceAutoRenewAttributeWithOptions(request, runtime);
}

model DescribeInstanceMonitorDataRequest {
  endTime?: string(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  period?: string(name='Period'),
  startTime?: string(name='StartTime'),
  version?: string(name='Version'),
}

model DescribeInstanceMonitorDataResponseBody = {
  code?: int32(name='Code'),
  monitorData?: {
    instanceMonitorData?: [ 
    {
      CPU?: string(name='CPU'),
      instanceId?: string(name='InstanceId'),
      memory?: string(name='Memory'),
    }
  ](name='InstanceMonitorData')
  }(name='MonitorData'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceMonitorDataResponseBody(name='body'),
}

async function describeInstanceMonitorDataWithOptions(request: DescribeInstanceMonitorDataRequest, runtime: Util.RuntimeOptions): DescribeInstanceMonitorDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceMonitorData',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceMonitorData(request: DescribeInstanceMonitorDataRequest): DescribeInstanceMonitorDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceMonitorDataWithOptions(request, runtime);
}

model DescribeInstanceSpecRequest {
  version?: string(name='Version'),
}

model DescribeInstanceSpecResponseBody = {
  bandwidthLimit?: int32(name='BandwidthLimit'),
  code?: int32(name='Code'),
  dataDiskMaxSize?: int32(name='DataDiskMaxSize'),
  dataDiskMinSize?: int32(name='DataDiskMinSize'),
  instanceSpecs?: {
    instanceSpec?: [ 
    {
      core?: string(name='Core'),
      displayName?: string(name='DisplayName'),
      instanceType?: string(name='InstanceType'),
      memory?: string(name='Memory'),
    }
  ](name='InstanceSpec')
  }(name='InstanceSpecs'),
  requestId?: string(name='RequestId'),
  systemDiskMaxSize?: int32(name='SystemDiskMaxSize'),
}

model DescribeInstanceSpecResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceSpecResponseBody(name='body'),
}

async function describeInstanceSpecWithOptions(request: DescribeInstanceSpecRequest, runtime: Util.RuntimeOptions): DescribeInstanceSpecResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceSpec',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceSpec(request: DescribeInstanceSpecRequest): DescribeInstanceSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceSpecWithOptions(request, runtime);
}

model DescribeInstanceTypesRequest {
  version?: string(name='Version'),
}

model DescribeInstanceTypesResponseBody = {
  code?: int32(name='Code'),
  instanceTypes?: {
    instanceType?: [ 
    {
      cpuCoreCount?: int32(name='CpuCoreCount'),
      instanceTypeId?: string(name='InstanceTypeId'),
      instanceTypeName?: string(name='InstanceTypeName'),
      memorySize?: int32(name='MemorySize'),
    }
  ](name='InstanceType')
  }(name='InstanceTypes'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceTypesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceTypesResponseBody(name='body'),
}

async function describeInstanceTypesWithOptions(request: DescribeInstanceTypesRequest, runtime: Util.RuntimeOptions): DescribeInstanceTypesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceTypes',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceTypes(request: DescribeInstanceTypesRequest): DescribeInstanceTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceTypesWithOptions(request, runtime);
}

model DescribeInstanceVncUrlRequest {
  instanceId?: string(name='InstanceId', description='实例ID。'),
}

model DescribeInstanceVncUrlResponseBody = {
  requestId?: string(name='RequestId', description='请求ID。'),
  vncUrl?: string(name='VncUrl', description='管理终端Url。'),
}

model DescribeInstanceVncUrlResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceVncUrlResponseBody(name='body'),
}

async function describeInstanceVncUrlWithOptions(request: DescribeInstanceVncUrlRequest, runtime: Util.RuntimeOptions): DescribeInstanceVncUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceVncUrl',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceVncUrl(request: DescribeInstanceVncUrlRequest): DescribeInstanceVncUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceVncUrlWithOptions(request, runtime);
}

model DescribeInstancesRequest {
  ensRegionId?: string(name='EnsRegionId'),
  ensRegionIds?: string(name='EnsRegionIds'),
  ensServiceId?: string(name='EnsServiceId'),
  imageId?: string(name='ImageId'),
  instanceId?: string(name='InstanceId'),
  instanceIds?: string(name='InstanceIds'),
  instanceName?: string(name='InstanceName'),
  instanceResourceType?: string(name='InstanceResourceType'),
  networkId?: string(name='NetworkId'),
  orderByParams?: string(name='OrderByParams'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  searchKey?: string(name='SearchKey'),
  securityGroupId?: string(name='SecurityGroupId'),
  status?: string(name='Status'),
  vSwitchId?: string(name='VSwitchId'),
}

model DescribeInstancesResponseBody = {
  code?: int32(name='Code'),
  instances?: {
    instance?: [ 
    {
      cpu?: string(name='Cpu'),
      creationTime?: string(name='CreationTime'),
      dataDisk?: {
        dataDisk?: [ 
        {
          category?: string(name='Category'),
          diskId?: string(name='DiskId'),
          diskName?: string(name='DiskName'),
          size?: int32(name='Size'),
          deviceType?: string(name='device_type'),
          diskType?: string(name='disk_type'),
          name?: string(name='name'),
          storage?: int32(name='storage'),
          uuid?: string(name='uuid'),
        }
      ](name='DataDisk')
      }(name='DataDisk'),
      disk?: int32(name='Disk'),
      ensRegionId?: string(name='EnsRegionId'),
      expiredTime?: string(name='ExpiredTime'),
      hostName?: string(name='HostName'),
      imageId?: string(name='ImageId'),
      innerIpAddress?: {
        ipAddress?: [ string ](name='IpAddress')
      }(name='InnerIpAddress'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      instanceResourceType?: string(name='InstanceResourceType'),
      internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn'),
      internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut'),
      memory?: int32(name='Memory'),
      networkAttributes?: {
        networkId?: string(name='NetworkId'),
        privateIpAddress?: {
          ipAddress?: [ string ](name='IpAddress')
        }(name='PrivateIpAddress'),
        vSwitchId?: string(name='VSwitchId'),
      }(name='NetworkAttributes'),
      OSName?: string(name='OSName'),
      privateIpAddresses?: {
        privateIpAddress?: [ 
        {
          gateWay?: string(name='GateWay'),
          ip?: string(name='Ip'),
          isp?: string(name='Isp'),
        }
      ](name='PrivateIpAddress')
      }(name='PrivateIpAddresses'),
      publicIpAddress?: {
        ipAddress?: [ string ](name='IpAddress')
      }(name='PublicIpAddress'),
      publicIpAddresses?: {
        publicIpAddress?: [ 
        {
          gateWay?: string(name='GateWay'),
          ip?: string(name='Ip'),
          isp?: string(name='Isp'),
        }
      ](name='PublicIpAddress')
      }(name='PublicIpAddresses'),
      securityGroupIds?: {
        securityGroupId?: [ string ](name='SecurityGroupId')
      }(name='SecurityGroupIds'),
      specName?: string(name='SpecName'),
      status?: string(name='Status'),
      systemDisk?: {
        category?: string(name='Category'),
        diskId?: string(name='DiskId'),
        diskName?: string(name='DiskName'),
        size?: int32(name='Size'),
        deviceType?: string(name='device_type'),
        diskType?: string(name='disk_type'),
        name?: string(name='name'),
        storage?: int32(name='storage'),
        uuid?: string(name='uuid'),
      }(name='SystemDisk'),
    }
  ](name='Instance')
  }(name='Instances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstancesResponseBody(name='body'),
}

async function describeInstancesWithOptions(request: DescribeInstancesRequest, runtime: Util.RuntimeOptions): DescribeInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.ensRegionIds)) {
    query['EnsRegionIds'] = request.ensRegionIds;
  }
  if (!Util.isUnset(request.ensServiceId)) {
    query['EnsServiceId'] = request.ensServiceId;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.instanceResourceType)) {
    query['InstanceResourceType'] = request.instanceResourceType;
  }
  if (!Util.isUnset(request.networkId)) {
    query['NetworkId'] = request.networkId;
  }
  if (!Util.isUnset(request.orderByParams)) {
    query['OrderByParams'] = request.orderByParams;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchKey)) {
    query['SearchKey'] = request.searchKey;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstances',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstances(request: DescribeInstancesRequest): DescribeInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstancesWithOptions(request, runtime);
}

model DescribeKeyPairsRequest {
  keyPairName?: string(name='KeyPairName'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  version?: string(name='Version'),
}

model DescribeKeyPairsResponseBody = {
  keyPairs?: {
    keyPair?: [ 
    {
      creationTime?: string(name='CreationTime'),
      keyPairFingerPrint?: string(name='KeyPairFingerPrint'),
      keyPairName?: string(name='KeyPairName'),
    }
  ](name='KeyPair')
  }(name='KeyPairs'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeKeyPairsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeKeyPairsResponseBody(name='body'),
}

async function describeKeyPairsWithOptions(request: DescribeKeyPairsRequest, runtime: Util.RuntimeOptions): DescribeKeyPairsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyPairName)) {
    query['KeyPairName'] = request.keyPairName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeKeyPairs',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeKeyPairs(request: DescribeKeyPairsRequest): DescribeKeyPairsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeKeyPairsWithOptions(request, runtime);
}

model DescribeLoadBalancerAttributeRequest {
  loadBalancerId?: string(name='LoadBalancerId'),
}

model DescribeLoadBalancerAttributeResponseBody = {
  address?: string(name='Address'),
  addressIPVersion?: string(name='AddressIPVersion'),
  backendServers?: [ 
    {
      ip?: string(name='Ip'),
      port?: string(name='Port'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='BackendServers'),
  bandwidth?: int32(name='Bandwidth'),
  createTime?: string(name='CreateTime'),
  endTime?: string(name='EndTime'),
  ensRegionId?: string(name='EnsRegionId'),
  listenerPorts?: [ string ](name='ListenerPorts'),
  listenerPortsAndProtocols?: [ 
    {
      description?: string(name='Description'),
      forwardPort?: int32(name='ForwardPort'),
      listenerForward?: string(name='ListenerForward'),
      listenerPort?: int32(name='ListenerPort'),
      listenerProtocol?: string(name='ListenerProtocol'),
    }
  ](name='ListenerPortsAndProtocols'),
  loadBalancerId?: string(name='LoadBalancerId'),
  loadBalancerName?: string(name='LoadBalancerName'),
  loadBalancerSpec?: string(name='LoadBalancerSpec'),
  loadBalancerStatus?: string(name='LoadBalancerStatus'),
  networkId?: string(name='NetworkId'),
  payType?: string(name='PayType'),
  requestId?: string(name='RequestId', description='Id of the request'),
  vSwitchId?: string(name='VSwitchId'),
}

model DescribeLoadBalancerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerAttributeWithOptions(request: DescribeLoadBalancerAttributeRequest, runtime: Util.RuntimeOptions): DescribeLoadBalancerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLoadBalancerAttribute',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLoadBalancerAttribute(request: DescribeLoadBalancerAttributeRequest): DescribeLoadBalancerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoadBalancerAttributeWithOptions(request, runtime);
}

model DescribeLoadBalancerHTTPListenerAttributeRequest {
  listenerPort?: int32(name='ListenerPort'),
  loadBalancerId?: string(name='LoadBalancerId'),
}

model DescribeLoadBalancerHTTPListenerAttributeResponseBody = {
  bandwidth?: int32(name='Bandwidth'),
  description?: string(name='Description'),
  forwardPort?: int32(name='ForwardPort'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckMethod?: string(name='HealthCheckMethod'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  idleTimeout?: int32(name='IdleTimeout'),
  listenerForward?: string(name='ListenerForward'),
  listenerPort?: int32(name='ListenerPort'),
  requestId?: string(name='RequestId', description='Id of the request'),
  requestTimeout?: int32(name='RequestTimeout'),
  scheduler?: string(name='Scheduler'),
  serverCertificateId?: string(name='ServerCertificateId'),
  status?: string(name='Status'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
}

model DescribeLoadBalancerHTTPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancerHTTPListenerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerHTTPListenerAttributeWithOptions(request: DescribeLoadBalancerHTTPListenerAttributeRequest, runtime: Util.RuntimeOptions): DescribeLoadBalancerHTTPListenerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLoadBalancerHTTPListenerAttribute',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLoadBalancerHTTPListenerAttribute(request: DescribeLoadBalancerHTTPListenerAttributeRequest): DescribeLoadBalancerHTTPListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoadBalancerHTTPListenerAttributeWithOptions(request, runtime);
}

model DescribeLoadBalancerHTTPSListenerAttributeRequest {
  listenerPort?: int32(name='ListenerPort'),
  loadBalancerId?: string(name='LoadBalancerId'),
}

model DescribeLoadBalancerHTTPSListenerAttributeResponseBody = {
  bandwidth?: int32(name='Bandwidth'),
  description?: string(name='Description'),
  forwardPort?: int32(name='ForwardPort'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckMethod?: string(name='HealthCheckMethod'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  idleTimeout?: int32(name='IdleTimeout'),
  listenerForward?: string(name='ListenerForward'),
  listenerPort?: int32(name='ListenerPort'),
  requestId?: string(name='RequestId', description='Id of the request'),
  requestTimeout?: int32(name='RequestTimeout'),
  scheduler?: string(name='Scheduler'),
  serverCertificateId?: string(name='ServerCertificateId'),
  status?: string(name='Status'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
}

model DescribeLoadBalancerHTTPSListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancerHTTPSListenerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerHTTPSListenerAttributeWithOptions(request: DescribeLoadBalancerHTTPSListenerAttributeRequest, runtime: Util.RuntimeOptions): DescribeLoadBalancerHTTPSListenerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLoadBalancerHTTPSListenerAttribute',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLoadBalancerHTTPSListenerAttribute(request: DescribeLoadBalancerHTTPSListenerAttributeRequest): DescribeLoadBalancerHTTPSListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoadBalancerHTTPSListenerAttributeWithOptions(request, runtime);
}

model DescribeLoadBalancerSpecRequest {
  loadBalancerSpec?: string(name='LoadBalancerSpec'),
}

model DescribeLoadBalancerSpecResponseBody = {
  loadBalancerSpecs?: [ 
    {
      displayName?: string(name='DisplayName'),
      loadBalancerSpec?: string(name='LoadBalancerSpec'),
    }
  ](name='LoadBalancerSpecs'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeLoadBalancerSpecResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancerSpecResponseBody(name='body'),
}

async function describeLoadBalancerSpecWithOptions(request: DescribeLoadBalancerSpecRequest, runtime: Util.RuntimeOptions): DescribeLoadBalancerSpecResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLoadBalancerSpec',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLoadBalancerSpec(request: DescribeLoadBalancerSpecRequest): DescribeLoadBalancerSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoadBalancerSpecWithOptions(request, runtime);
}

model DescribeLoadBalancerTCPListenerAttributeRequest {
  listenerPort?: int32(name='ListenerPort'),
  loadBalancerId?: string(name='LoadBalancerId'),
}

model DescribeLoadBalancerTCPListenerAttributeResponseBody = {
  backendServerPort?: int32(name='BackendServerPort'),
  bandwidth?: int32(name='Bandwidth'),
  description?: string(name='Description'),
  eipTransmit?: string(name='EipTransmit'),
  establishedTimeout?: int32(name='EstablishedTimeout'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckType?: string(name='HealthCheckType'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  listenerPort?: int32(name='ListenerPort'),
  persistenceTimeout?: int32(name='PersistenceTimeout'),
  requestId?: string(name='RequestId', description='Id of the request'),
  scheduler?: string(name='Scheduler'),
  status?: string(name='Status'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
}

model DescribeLoadBalancerTCPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancerTCPListenerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerTCPListenerAttributeWithOptions(request: DescribeLoadBalancerTCPListenerAttributeRequest, runtime: Util.RuntimeOptions): DescribeLoadBalancerTCPListenerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLoadBalancerTCPListenerAttribute',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLoadBalancerTCPListenerAttribute(request: DescribeLoadBalancerTCPListenerAttributeRequest): DescribeLoadBalancerTCPListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoadBalancerTCPListenerAttributeWithOptions(request, runtime);
}

model DescribeLoadBalancerUDPListenerAttributeRequest {
  listenerPort?: int32(name='ListenerPort'),
  loadBalancerId?: string(name='LoadBalancerId'),
}

model DescribeLoadBalancerUDPListenerAttributeResponseBody = {
  backendServerPort?: int32(name='BackendServerPort'),
  bandwidth?: int32(name='Bandwidth'),
  description?: string(name='Description'),
  eipTransmit?: string(name='EipTransmit'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout'),
  healthCheckExp?: string(name='HealthCheckExp'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckReq?: string(name='HealthCheckReq'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  listenerPort?: int32(name='ListenerPort'),
  requestId?: string(name='RequestId', description='Id of the request'),
  scheduler?: string(name='Scheduler'),
  status?: string(name='Status'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
}

model DescribeLoadBalancerUDPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancerUDPListenerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerUDPListenerAttributeWithOptions(request: DescribeLoadBalancerUDPListenerAttributeRequest, runtime: Util.RuntimeOptions): DescribeLoadBalancerUDPListenerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLoadBalancerUDPListenerAttribute',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLoadBalancerUDPListenerAttribute(request: DescribeLoadBalancerUDPListenerAttributeRequest): DescribeLoadBalancerUDPListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoadBalancerUDPListenerAttributeWithOptions(request, runtime);
}

model DescribeLoadBalancersRequest {
  address?: string(name='Address'),
  ensRegionId?: string(name='EnsRegionId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  loadBalancerName?: string(name='LoadBalancerName'),
  loadBalancerStatus?: string(name='LoadBalancerStatus'),
  networkId?: string(name='NetworkId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  serverId?: string(name='ServerId'),
  vSwitchId?: string(name='VSwitchId'),
}

model DescribeLoadBalancersResponseBody = {
  loadBalancers?: {
    loadBalancer?: [ 
    {
      address?: string(name='Address'),
      addressIPVersion?: string(name='AddressIPVersion'),
      createTime?: string(name='CreateTime'),
      ensRegionId?: string(name='EnsRegionId'),
      loadBalancerId?: string(name='LoadBalancerId'),
      loadBalancerName?: string(name='LoadBalancerName'),
      loadBalancerStatus?: string(name='LoadBalancerStatus'),
      networkId?: string(name='NetworkId'),
      payType?: string(name='PayType'),
      vSwitchId?: string(name='VSwitchId'),
    }
  ](name='LoadBalancer')
  }(name='LoadBalancers'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeLoadBalancersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancersResponseBody(name='body'),
}

async function describeLoadBalancersWithOptions(request: DescribeLoadBalancersRequest, runtime: Util.RuntimeOptions): DescribeLoadBalancersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLoadBalancers',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLoadBalancers(request: DescribeLoadBalancersRequest): DescribeLoadBalancersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoadBalancersWithOptions(request, runtime);
}

model DescribeMeasurementDataRequest {
  endDate?: string(name='EndDate'),
  startDate?: string(name='StartDate'),
  version?: string(name='Version'),
}

model DescribeMeasurementDataResponseBody = {
  measurementDatas?: {
    measurementData?: [ 
    {
      bandWidthFeeDatas?: {
        bandWidthFeeData?: [ 
        {
          costCode?: string(name='CostCode'),
          costName?: string(name='CostName'),
          costVal?: int32(name='CostVal'),
        }
      ](name='BandWidthFeeData')
      }(name='BandWidthFeeDatas'),
      chargeModel?: string(name='ChargeModel'),
      costCycle?: string(name='CostCycle'),
      costEndTime?: string(name='CostEndTime'),
      costStartTime?: string(name='CostStartTime'),
      resourceFeeData?: {
        memory?: int32(name='Memory'),
        storage?: int32(name='Storage'),
        vcpu?: int32(name='Vcpu'),
      }(name='ResourceFeeData'),
      resourceFeeDataDetails?: {
        resourceFeeDataDetail?: [ 
        {
          costCode?: string(name='CostCode'),
          costName?: string(name='CostName'),
          costVal?: int32(name='CostVal'),
          resourceType?: string(name='ResourceType'),
        }
      ](name='ResourceFeeDataDetail')
      }(name='ResourceFeeDataDetails'),
    }
  ](name='MeasurementData')
  }(name='MeasurementDatas'),
  requestId?: string(name='RequestId'),
}

model DescribeMeasurementDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMeasurementDataResponseBody(name='body'),
}

async function describeMeasurementDataWithOptions(request: DescribeMeasurementDataRequest, runtime: Util.RuntimeOptions): DescribeMeasurementDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMeasurementData',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMeasurementData(request: DescribeMeasurementDataRequest): DescribeMeasurementDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMeasurementDataWithOptions(request, runtime);
}

model DescribeNatGatewaysRequest {
  ensRegionId?: string(name='EnsRegionId'),
  name?: string(name='Name'),
  natGatewayId?: string(name='NatGatewayId'),
  networkId?: string(name='NetworkId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  vSwitchId?: string(name='VSwitchId'),
}

model DescribeNatGatewaysResponseBody = {
  natGateways?: [ 
    {
      creationTime?: string(name='CreationTime'),
      ensRegionId?: string(name='EnsRegionId'),
      name?: string(name='Name'),
      natGatewayId?: string(name='NatGatewayId'),
      networkId?: string(name='NetworkId'),
      vSwitchId?: string(name='VSwitchId'),
    }
  ](name='NatGateways'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeNatGatewaysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNatGatewaysResponseBody(name='body'),
}

async function describeNatGatewaysWithOptions(request: DescribeNatGatewaysRequest, runtime: Util.RuntimeOptions): DescribeNatGatewaysResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNatGateways',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNatGateways(request: DescribeNatGatewaysRequest): DescribeNatGatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNatGatewaysWithOptions(request, runtime);
}

model DescribeNetworkAttributeRequest {
  networkId?: string(name='NetworkId'),
}

model DescribeNetworkAttributeResponseBody = {
  cidrBlock?: string(name='CidrBlock'),
  cloudResources?: {
    cloudResourceSetType?: [ 
    {
      resourceCount?: int32(name='ResourceCount'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='CloudResourceSetType')
  }(name='CloudResources'),
  createdTime?: string(name='CreatedTime'),
  description?: string(name='Description'),
  ensRegionId?: string(name='EnsRegionId'),
  networkId?: string(name='NetworkId'),
  networkName?: string(name='NetworkName'),
  requestId?: string(name='RequestId', description='Id of the request'),
  routerTableId?: string(name='RouterTableId'),
  status?: string(name='Status'),
  vSwitchIds?: {
    vSwitchId?: [ string ](name='VSwitchId')
  }(name='VSwitchIds'),
}

model DescribeNetworkAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNetworkAttributeResponseBody(name='body'),
}

async function describeNetworkAttributeWithOptions(request: DescribeNetworkAttributeRequest, runtime: Util.RuntimeOptions): DescribeNetworkAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.networkId)) {
    query['NetworkId'] = request.networkId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNetworkAttribute',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNetworkAttribute(request: DescribeNetworkAttributeRequest): DescribeNetworkAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNetworkAttributeWithOptions(request, runtime);
}

model DescribeNetworkInterfacesRequest {
  ensRegionId?: string(name='EnsRegionId'),
  instanceId?: string(name='InstanceId'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  primaryIpAddress?: string(name='PrimaryIpAddress'),
  vSwitchId?: string(name='VSwitchId'),
}

model DescribeNetworkInterfacesResponseBody = {
  networkInterfaceSets?: {
    networkInterfaceSet?: [ 
    {
      creationTime?: string(name='CreationTime'),
      ensRegionId?: string(name='EnsRegionId'),
      instanceId?: string(name='InstanceId'),
      macAddress?: string(name='MacAddress'),
      networkInterfaceId?: string(name='NetworkInterfaceId'),
      primaryIp?: string(name='PrimaryIp'),
      primaryIpType?: string(name='PrimaryIpType'),
      status?: string(name='Status'),
      vSwitchId?: string(name='VSwitchId'),
    }
  ](name='NetworkInterfaceSet')
  }(name='NetworkInterfaceSets'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeNetworkInterfacesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNetworkInterfacesResponseBody(name='body'),
}

async function describeNetworkInterfacesWithOptions(request: DescribeNetworkInterfacesRequest, runtime: Util.RuntimeOptions): DescribeNetworkInterfacesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.primaryIpAddress)) {
    query['PrimaryIpAddress'] = request.primaryIpAddress;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNetworkInterfaces',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNetworkInterfaces(request: DescribeNetworkInterfacesRequest): DescribeNetworkInterfacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNetworkInterfacesWithOptions(request, runtime);
}

model DescribeNetworksRequest {
  ensRegionId?: string(name='EnsRegionId'),
  networkId?: string(name='NetworkId'),
  networkName?: string(name='NetworkName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeNetworksResponseBody = {
  networks?: {
    network?: [ 
    {
      cidrBlock?: string(name='CidrBlock'),
      createdTime?: string(name='CreatedTime'),
      description?: string(name='Description'),
      ensRegionId?: string(name='EnsRegionId'),
      networkId?: string(name='NetworkId'),
      networkName?: string(name='NetworkName'),
      routerTableId?: string(name='RouterTableId'),
      status?: string(name='Status'),
      vSwitchIds?: {
        vSwitchId?: [ string ](name='VSwitchId')
      }(name='VSwitchIds'),
    }
  ](name='Network')
  }(name='Networks'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeNetworksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNetworksResponseBody(name='body'),
}

async function describeNetworksWithOptions(request: DescribeNetworksRequest, runtime: Util.RuntimeOptions): DescribeNetworksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.networkId)) {
    query['NetworkId'] = request.networkId;
  }
  if (!Util.isUnset(request.networkName)) {
    query['NetworkName'] = request.networkName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNetworks',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNetworks(request: DescribeNetworksRequest): DescribeNetworksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNetworksWithOptions(request, runtime);
}

model DescribePrePaidInstanceStockRequest {
  dataDiskSize?: int32(name='DataDiskSize'),
  ensRegionId?: string(name='EnsRegionId'),
  instanceSpec?: string(name='InstanceSpec'),
  systemDiskSize?: int32(name='SystemDiskSize'),
  version?: string(name='Version'),
}

model DescribePrePaidInstanceStockResponseBody = {
  avaliableCount?: int32(name='AvaliableCount'),
  cores?: int32(name='Cores'),
  dataDiskSize?: int32(name='DataDiskSize'),
  ensRegionId?: string(name='EnsRegionId'),
  instanceSpec?: string(name='InstanceSpec'),
  memory?: int32(name='Memory'),
  requestId?: string(name='RequestId'),
  systemDiskSize?: int32(name='SystemDiskSize'),
}

model DescribePrePaidInstanceStockResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePrePaidInstanceStockResponseBody(name='body'),
}

async function describePrePaidInstanceStockWithOptions(request: DescribePrePaidInstanceStockRequest, runtime: Util.RuntimeOptions): DescribePrePaidInstanceStockResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dataDiskSize)) {
    query['DataDiskSize'] = request.dataDiskSize;
  }
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.instanceSpec)) {
    query['InstanceSpec'] = request.instanceSpec;
  }
  if (!Util.isUnset(request.systemDiskSize)) {
    query['SystemDiskSize'] = request.systemDiskSize;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePrePaidInstanceStock',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePrePaidInstanceStock(request: DescribePrePaidInstanceStockRequest): DescribePrePaidInstanceStockResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePrePaidInstanceStockWithOptions(request, runtime);
}

model DescribePriceRequest {
  dataDisk?: [
    {
      size?: int32(name='Size', description='数据盘大小，单位GB。如果此字段不为空，则以此段为准。'),
    }
  ](name='DataDisk'),
  systemDisk?: {
    size?: int32(name='Size', description='系统盘大小，单位：GB'),
  }(name='SystemDisk'),
  dataDisks?: [ 
    {
      category?: string(name='Category', description='磁盘类型'),
      size?: long(name='Size'),
    }
  ](name='DataDisks', description='如果DataDisk.1.Size为空且此字段不为空时的则以此字段为准'),
  ensRegionId?: string(name='EnsRegionId', description='节点ID。'),
  instanceType?: string(name='InstanceType', description='实列规格。'),
  internetChargeType?: string(name='InternetChargeType', description='带宽计费方式'),
  period?: int32(name='Period', description='购买资源的时长，如果不指定PeriodUnit，则默认按月购买。目前只支持按Days和Month。如果PeriodUnit=Day时，Period仅可以3。如果PeriodUnit=Monthc时，则Period可以为1-9,12。'),
  periodUnit?: string(name='PeriodUnit', description='查询云服务器ENS不同计费周期的价格。取值范围：
Month（默认）：按月计费的价格单位。
Day：按天计费的价格单位。'),
  quantity?: int32(name='Quantity', description='数量。'),
}

model DescribePriceShrinkRequest {
  dataDisk?: [
    {
      size?: int32(name='Size', description='数据盘大小，单位GB。如果此字段不为空，则以此段为准。'),
    }
  ](name='DataDisk'),
  systemDisk?: {
    size?: int32(name='Size', description='系统盘大小，单位：GB'),
  }(name='SystemDisk'),
  dataDisksShrink?: string(name='DataDisks', description='如果DataDisk.1.Size为空且此字段不为空时的则以此字段为准'),
  ensRegionId?: string(name='EnsRegionId', description='节点ID。'),
  instanceType?: string(name='InstanceType', description='实列规格。'),
  internetChargeType?: string(name='InternetChargeType', description='带宽计费方式'),
  period?: int32(name='Period', description='购买资源的时长，如果不指定PeriodUnit，则默认按月购买。目前只支持按Days和Month。如果PeriodUnit=Day时，Period仅可以3。如果PeriodUnit=Monthc时，则Period可以为1-9,12。'),
  periodUnit?: string(name='PeriodUnit', description='查询云服务器ENS不同计费周期的价格。取值范围：
Month（默认）：按月计费的价格单位。
Day：按天计费的价格单位。'),
  quantity?: int32(name='Quantity', description='数量。'),
}

model DescribePriceResponseBody = {
  priceInfo?: {
    price?: {
      currency?: string(name='Currency'),
      discountPrice?: float(name='DiscountPrice'),
      originalPrice?: float(name='OriginalPrice'),
      tradePrice?: float(name='TradePrice'),
    }(name='Price'),
  }(name='PriceInfo'),
  requestId?: string(name='RequestId'),
}

model DescribePriceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePriceResponseBody(name='body'),
}

async function describePriceWithOptions(tmpReq: DescribePriceRequest, runtime: Util.RuntimeOptions): DescribePriceResponse {
  Util.validateModel(tmpReq);
  var request = new DescribePriceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.dataDisks)) {
    request.dataDisksShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dataDisks, 'DataDisks', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.dataDisksShrink)) {
    query['DataDisks'] = request.dataDisksShrink;
  }
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.internetChargeType)) {
    query['InternetChargeType'] = request.internetChargeType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.quantity)) {
    query['Quantity'] = request.quantity;
  }
  if (!Util.isUnset(request.dataDisk)) {
    query['DataDisk'] = request.dataDisk;
  }
  if (!Util.isUnset(request.systemDisk)) {
    query['SystemDisk'] = request.systemDisk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePrice',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePrice(request: DescribePriceRequest): DescribePriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePriceWithOptions(request, runtime);
}

model DescribeRegionIspsRequest {
  ensRegionId?: string(name='EnsRegionId'),
}

model DescribeRegionIspsResponseBody = {
  isps?: [ 
    {
      code?: string(name='Code'),
      name?: string(name='Name'),
    }
  ](name='Isps'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DescribeRegionIspsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionIspsResponseBody(name='body'),
}

async function describeRegionIspsWithOptions(request: DescribeRegionIspsRequest, runtime: Util.RuntimeOptions): DescribeRegionIspsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegionIsps',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegionIsps(request: DescribeRegionIspsRequest): DescribeRegionIspsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionIspsWithOptions(request, runtime);
}

model DescribeReservedResourceRequest {
  version?: string(name='Version'),
}

model DescribeReservedResourceResponseBody = {
  code?: int32(name='Code'),
  images?: {
    image?: [ 
    {
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
    }
  ](name='Image')
  }(name='Images'),
  requestId?: string(name='RequestId'),
  supportResources?: {
    supportResource?: [ 
    {
      dataDiskSizes?: {
        dataDiskSize?: [ string ](name='DataDiskSize')
      }(name='DataDiskSizes'),
      ensRegionId?: string(name='EnsRegionId'),
      instanceSpec?: string(name='InstanceSpec'),
      supportResourcesCount?: string(name='SupportResourcesCount'),
      systemDiskSizes?: {
        systemDiskSize?: [ string ](name='SystemDiskSize')
      }(name='SystemDiskSizes'),
    }
  ](name='SupportResource')
  }(name='SupportResources'),
}

model DescribeReservedResourceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeReservedResourceResponseBody(name='body'),
}

async function describeReservedResourceWithOptions(request: DescribeReservedResourceRequest, runtime: Util.RuntimeOptions): DescribeReservedResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeReservedResource',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeReservedResource(request: DescribeReservedResourceRequest): DescribeReservedResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeReservedResourceWithOptions(request, runtime);
}

model DescribeSecurityGroupAttributeRequest {
  securityGroupId?: string(name='SecurityGroupId'),
}

model DescribeSecurityGroupAttributeResponseBody = {
  description?: string(name='Description'),
  permissions?: {
    permission?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      destCidrIp?: string(name='DestCidrIp'),
      direction?: string(name='Direction'),
      ipProtocol?: string(name='IpProtocol'),
      policy?: string(name='Policy'),
      portRange?: string(name='PortRange'),
      priority?: int32(name='Priority'),
      sourceCidrIp?: string(name='SourceCidrIp'),
      sourcePortRange?: string(name='SourcePortRange'),
    }
  ](name='Permission')
  }(name='Permissions'),
  requestId?: string(name='RequestId'),
  securityGroupId?: string(name='SecurityGroupId'),
  securityGroupName?: string(name='SecurityGroupName'),
}

model DescribeSecurityGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSecurityGroupAttributeResponseBody(name='body'),
}

async function describeSecurityGroupAttributeWithOptions(request: DescribeSecurityGroupAttributeRequest, runtime: Util.RuntimeOptions): DescribeSecurityGroupAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecurityGroupAttribute',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSecurityGroupAttribute(request: DescribeSecurityGroupAttributeRequest): DescribeSecurityGroupAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecurityGroupAttributeWithOptions(request, runtime);
}

model DescribeSecurityGroupsRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  securityGroupId?: string(name='SecurityGroupId'),
  securityGroupName?: string(name='SecurityGroupName'),
  version?: string(name='Version'),
}

model DescribeSecurityGroupsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  securityGroups?: {
    securityGroup?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      instanceCount?: int32(name='InstanceCount'),
      securityGroupId?: string(name='SecurityGroupId'),
      securityGroupName?: string(name='SecurityGroupName'),
    }
  ](name='SecurityGroup')
  }(name='SecurityGroups'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSecurityGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSecurityGroupsResponseBody(name='body'),
}

async function describeSecurityGroupsWithOptions(request: DescribeSecurityGroupsRequest, runtime: Util.RuntimeOptions): DescribeSecurityGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.securityGroupName)) {
    query['SecurityGroupName'] = request.securityGroupName;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecurityGroups',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSecurityGroups(request: DescribeSecurityGroupsRequest): DescribeSecurityGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecurityGroupsWithOptions(request, runtime);
}

model DescribeServcieScheduleRequest {
  appId?: string(name='AppId'),
  podConfigName?: string(name='PodConfigName'),
  uuid?: string(name='Uuid'),
}

model DescribeServcieScheduleResponseBody = {
  index?: int32(name='Index'),
  instanceId?: string(name='InstanceId'),
  instanceIp?: string(name='InstanceIp'),
  instancePort?: int32(name='InstancePort'),
  podAbstractInfo?: {
    containerService?: boolean(name='ContainerService'),
    containerStatuses?: {
      containerStatus?: [ 
      {
        containerId?: string(name='ContainerId'),
        name?: string(name='Name'),
      }
    ](name='ContainerStatus')
    }(name='ContainerStatuses'),
    name?: boolean(name='Name'),
    namespace?: boolean(name='Namespace'),
    resourceScope?: boolean(name='ResourceScope'),
    status?: boolean(name='Status'),
  }(name='PodAbstractInfo'),
  requestId?: string(name='RequestId'),
  requestRepeated?: boolean(name='RequestRepeated'),
  tcpPorts?: string(name='TcpPorts'),
}

model DescribeServcieScheduleResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServcieScheduleResponseBody(name='body'),
}

async function describeServcieScheduleWithOptions(request: DescribeServcieScheduleRequest, runtime: Util.RuntimeOptions): DescribeServcieScheduleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.podConfigName)) {
    query['PodConfigName'] = request.podConfigName;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServcieSchedule',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServcieSchedule(request: DescribeServcieScheduleRequest): DescribeServcieScheduleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServcieScheduleWithOptions(request, runtime);
}

model DescribeSnatTableEntriesRequest {
  natGatewayId?: string(name='NatGatewayId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  snatEntryId?: string(name='SnatEntryId'),
  snatEntryName?: string(name='SnatEntryName'),
  snatIp?: string(name='SnatIp'),
  sourceCIDR?: string(name='SourceCIDR'),
}

model DescribeSnatTableEntriesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  snatTableEntries?: [ 
    {
      natGatewayId?: string(name='NatGatewayId'),
      snatEntryId?: string(name='SnatEntryId'),
      snatEntryName?: string(name='SnatEntryName'),
      snatIp?: string(name='SnatIp'),
      sourceCIDR?: string(name='SourceCIDR'),
      status?: string(name='Status'),
    }
  ](name='SnatTableEntries'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSnatTableEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSnatTableEntriesResponseBody(name='body'),
}

async function describeSnatTableEntriesWithOptions(request: DescribeSnatTableEntriesRequest, runtime: Util.RuntimeOptions): DescribeSnatTableEntriesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSnatTableEntries',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSnatTableEntries(request: DescribeSnatTableEntriesRequest): DescribeSnatTableEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSnatTableEntriesWithOptions(request, runtime);
}

model DescribeUserBandWidthDataRequest {
  endTime?: string(name='EndTime'),
  ensRegionId?: string(name='EnsRegionId'),
  instanceId?: string(name='InstanceId'),
  isp?: string(name='Isp'),
  period?: string(name='Period'),
  startTime?: string(name='StartTime'),
  version?: string(name='Version'),
}

model DescribeUserBandWidthDataResponseBody = {
  code?: int32(name='Code'),
  monitorData?: {
    bandWidthMonitorData?: [ 
      {
        downBandWidth?: int32(name='DownBandWidth'),
        internetRX?: int32(name='InternetRX'),
        internetTX?: int32(name='InternetTX'),
        timeStamp?: string(name='TimeStamp'),
        upBandWidth?: int32(name='UpBandWidth'),
      }
    ](name='BandWidthMonitorData'),
    maxDownBandWidth?: string(name='MaxDownBandWidth'),
    maxUpBandWidth?: string(name='MaxUpBandWidth'),
  }(name='MonitorData'),
  requestId?: string(name='RequestId'),
}

model DescribeUserBandWidthDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUserBandWidthDataResponseBody(name='body'),
}

async function describeUserBandWidthDataWithOptions(request: DescribeUserBandWidthDataRequest, runtime: Util.RuntimeOptions): DescribeUserBandWidthDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.isp)) {
    query['Isp'] = request.isp;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUserBandWidthData',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUserBandWidthData(request: DescribeUserBandWidthDataRequest): DescribeUserBandWidthDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserBandWidthDataWithOptions(request, runtime);
}

model DescribeVSwitchesRequest {
  ensRegionId?: string(name='EnsRegionId'),
  networkId?: string(name='NetworkId'),
  orderByParams?: string(name='OrderByParams'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  vSwitchId?: string(name='VSwitchId'),
  vSwitchName?: string(name='VSwitchName'),
  version?: string(name='Version'),
}

model DescribeVSwitchesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vSwitches?: {
    vSwitch?: [ 
    {
      cidrBlock?: string(name='CidrBlock'),
      createdTime?: string(name='CreatedTime'),
      description?: string(name='Description'),
      ensRegionId?: string(name='EnsRegionId'),
      freeIpCount?: long(name='FreeIpCount'),
      networkId?: string(name='NetworkId'),
      status?: string(name='Status'),
      vSwitchId?: string(name='VSwitchId'),
      vSwitchName?: string(name='VSwitchName'),
    }
  ](name='VSwitch')
  }(name='VSwitches'),
}

model DescribeVSwitchesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVSwitchesResponseBody(name='body'),
}

async function describeVSwitchesWithOptions(request: DescribeVSwitchesRequest, runtime: Util.RuntimeOptions): DescribeVSwitchesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.networkId)) {
    query['NetworkId'] = request.networkId;
  }
  if (!Util.isUnset(request.orderByParams)) {
    query['OrderByParams'] = request.orderByParams;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vSwitchName)) {
    query['VSwitchName'] = request.vSwitchName;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVSwitches',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVSwitches(request: DescribeVSwitchesRequest): DescribeVSwitchesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVSwitchesWithOptions(request, runtime);
}

model DetachDiskRequest {
  diskId?: string(name='DiskId'),
  instanceId?: string(name='InstanceId'),
}

model DetachDiskResponseBody = {
  code?: int32(name='Code'),
  requestId?: string(name='RequestId'),
}

model DetachDiskResponse = {
  headers: map[string]string(name='headers'),
  body: DetachDiskResponseBody(name='body'),
}

async function detachDiskWithOptions(request: DetachDiskRequest, runtime: Util.RuntimeOptions): DetachDiskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.diskId)) {
    query['DiskId'] = request.diskId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachDisk',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachDisk(request: DetachDiskRequest): DetachDiskResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachDiskWithOptions(request, runtime);
}

model DistApplicationDataRequest {
  appId?: string(name='AppId'),
  data?: string(name='Data'),
  distStrategy?: string(name='DistStrategy'),
}

model DistApplicationDataResponseBody = {
  distInstanceIds?: {
    distInstanceId?: [ string ](name='DistInstanceId')
  }(name='DistInstanceIds'),
  distInstanceTotalCount?: int32(name='DistInstanceTotalCount'),
  distResults?: {
    distResult?: [ 
    {
      name?: string(name='Name'),
      resultCode?: int32(name='ResultCode'),
      resultDescrip?: string(name='ResultDescrip'),
      version?: string(name='Version'),
    }
  ](name='DistResult')
  }(name='DistResults'),
  requestId?: string(name='RequestId'),
}

model DistApplicationDataResponse = {
  headers: map[string]string(name='headers'),
  body: DistApplicationDataResponseBody(name='body'),
}

async function distApplicationDataWithOptions(request: DistApplicationDataRequest, runtime: Util.RuntimeOptions): DistApplicationDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.data)) {
    query['Data'] = request.data;
  }
  if (!Util.isUnset(request.distStrategy)) {
    query['DistStrategy'] = request.distStrategy;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DistApplicationData',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function distApplicationData(request: DistApplicationDataRequest): DistApplicationDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return distApplicationDataWithOptions(request, runtime);
}

model ExportBillDetailDataRequest {
  endDate?: string(name='EndDate', description='结束时间UTC格式'),
  startDate?: string(name='StartDate', description='开始时间，UTC格式'),
}

model ExportBillDetailDataResponseBody = {
  filePath?: string(name='FilePath', description='文件下载地址'),
  requestId?: string(name='RequestId', description='请求ID，公共字段'),
}

model ExportBillDetailDataResponse = {
  headers: map[string]string(name='headers'),
  body: ExportBillDetailDataResponseBody(name='body'),
}

async function exportBillDetailDataWithOptions(request: ExportBillDetailDataRequest, runtime: Util.RuntimeOptions): ExportBillDetailDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExportBillDetailData',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function exportBillDetailData(request: ExportBillDetailDataRequest): ExportBillDetailDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportBillDetailDataWithOptions(request, runtime);
}

model ExportImageRequest {
  imageId?: string(name='ImageId'),
  OSSBucket?: string(name='OSSBucket'),
  OSSPrefix?: string(name='OSSPrefix'),
  OSSRegionId?: string(name='OSSRegionId'),
  roleName?: string(name='RoleName'),
}

model ExportImageResponseBody = {
  exportedImageURL?: string(name='ExportedImageURL'),
  requestId?: string(name='RequestId'),
}

model ExportImageResponse = {
  headers: map[string]string(name='headers'),
  body: ExportImageResponseBody(name='body'),
}

async function exportImageWithOptions(request: ExportImageRequest, runtime: Util.RuntimeOptions): ExportImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.OSSBucket)) {
    query['OSSBucket'] = request.OSSBucket;
  }
  if (!Util.isUnset(request.OSSPrefix)) {
    query['OSSPrefix'] = request.OSSPrefix;
  }
  if (!Util.isUnset(request.OSSRegionId)) {
    query['OSSRegionId'] = request.OSSRegionId;
  }
  if (!Util.isUnset(request.roleName)) {
    query['RoleName'] = request.roleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExportImage',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function exportImage(request: ExportImageRequest): ExportImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportImageWithOptions(request, runtime);
}

model ExportMeasurementDataRequest {
  endDate?: string(name='EndDate', description='结束时间，UTC格式'),
  startDate?: string(name='StartDate', description='开始时间，UTC格式'),
}

model ExportMeasurementDataResponseBody = {
  filePath?: string(name='FilePath', description='文件下载地址'),
  requestId?: string(name='RequestId', description='请求ID，公共字段'),
}

model ExportMeasurementDataResponse = {
  headers: map[string]string(name='headers'),
  body: ExportMeasurementDataResponseBody(name='body'),
}

async function exportMeasurementDataWithOptions(request: ExportMeasurementDataRequest, runtime: Util.RuntimeOptions): ExportMeasurementDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExportMeasurementData',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function exportMeasurementData(request: ExportMeasurementDataRequest): ExportMeasurementDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportMeasurementDataWithOptions(request, runtime);
}

model GetDeviceInternetPortRequest {
  instanceId?: string(name='InstanceId', description='A short description of struct'),
  natType?: string(name='NatType'),
  ruleId?: string(name='RuleId'),
}

model GetDeviceInternetPortResponseBody = {
  instanceId?: string(name='InstanceId', description='InstanceId'),
  networkInfo?: [ 
    {
      externalIp?: string(name='ExternalIp'),
      externalPort?: string(name='ExternalPort'),
      ISP?: string(name='ISP'),
      internalIp?: string(name='InternalIp'),
      internalPort?: string(name='InternalPort'),
      status?: string(name='Status'),
    }
  ](name='NetworkInfo'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetDeviceInternetPortResponse = {
  headers: map[string]string(name='headers'),
  body: GetDeviceInternetPortResponseBody(name='body'),
}

async function getDeviceInternetPortWithOptions(request: GetDeviceInternetPortRequest, runtime: Util.RuntimeOptions): GetDeviceInternetPortResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceInternetPort',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceInternetPort(request: GetDeviceInternetPortRequest): GetDeviceInternetPortResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceInternetPortWithOptions(request, runtime);
}

model ImportKeyPairRequest {
  keyPairName?: string(name='KeyPairName'),
  publicKeyBody?: string(name='PublicKeyBody'),
  version?: string(name='Version'),
}

model ImportKeyPairResponseBody = {
  keyPairFingerPrint?: string(name='KeyPairFingerPrint'),
  keyPairName?: string(name='KeyPairName'),
  requestId?: string(name='RequestId'),
}

model ImportKeyPairResponse = {
  headers: map[string]string(name='headers'),
  body: ImportKeyPairResponseBody(name='body'),
}

async function importKeyPairWithOptions(request: ImportKeyPairRequest, runtime: Util.RuntimeOptions): ImportKeyPairResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyPairName)) {
    query['KeyPairName'] = request.keyPairName;
  }
  if (!Util.isUnset(request.publicKeyBody)) {
    query['PublicKeyBody'] = request.publicKeyBody;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImportKeyPair',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function importKeyPair(request: ImportKeyPairRequest): ImportKeyPairResponse {
  var runtime = new Util.RuntimeOptions{};
  return importKeyPairWithOptions(request, runtime);
}

model JoinPublicIpsToEpnInstanceRequest {
  EPNInstanceId?: string(name='EPNInstanceId'),
  instanceInfos?: string(name='InstanceInfos'),
}

model JoinPublicIpsToEpnInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model JoinPublicIpsToEpnInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: JoinPublicIpsToEpnInstanceResponseBody(name='body'),
}

async function joinPublicIpsToEpnInstanceWithOptions(request: JoinPublicIpsToEpnInstanceRequest, runtime: Util.RuntimeOptions): JoinPublicIpsToEpnInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.EPNInstanceId)) {
    query['EPNInstanceId'] = request.EPNInstanceId;
  }
  if (!Util.isUnset(request.instanceInfos)) {
    query['InstanceInfos'] = request.instanceInfos;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'JoinPublicIpsToEpnInstance',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function joinPublicIpsToEpnInstance(request: JoinPublicIpsToEpnInstanceRequest): JoinPublicIpsToEpnInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return joinPublicIpsToEpnInstanceWithOptions(request, runtime);
}

model JoinSecurityGroupRequest {
  instanceId?: string(name='InstanceId'),
  securityGroupId?: string(name='SecurityGroupId'),
  version?: string(name='Version'),
}

model JoinSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model JoinSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: JoinSecurityGroupResponseBody(name='body'),
}

async function joinSecurityGroupWithOptions(request: JoinSecurityGroupRequest, runtime: Util.RuntimeOptions): JoinSecurityGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'JoinSecurityGroup',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function joinSecurityGroup(request: JoinSecurityGroupRequest): JoinSecurityGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return joinSecurityGroupWithOptions(request, runtime);
}

model JoinVSwitchesToEpnInstanceRequest {
  EPNInstanceId?: string(name='EPNInstanceId'),
  vSwitchesInfo?: string(name='VSwitchesInfo'),
}

model JoinVSwitchesToEpnInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model JoinVSwitchesToEpnInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: JoinVSwitchesToEpnInstanceResponseBody(name='body'),
}

async function joinVSwitchesToEpnInstanceWithOptions(request: JoinVSwitchesToEpnInstanceRequest, runtime: Util.RuntimeOptions): JoinVSwitchesToEpnInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.EPNInstanceId)) {
    query['EPNInstanceId'] = request.EPNInstanceId;
  }
  if (!Util.isUnset(request.vSwitchesInfo)) {
    query['VSwitchesInfo'] = request.vSwitchesInfo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'JoinVSwitchesToEpnInstance',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function joinVSwitchesToEpnInstance(request: JoinVSwitchesToEpnInstanceRequest): JoinVSwitchesToEpnInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return joinVSwitchesToEpnInstanceWithOptions(request, runtime);
}

model LeaveSecurityGroupRequest {
  instanceId?: string(name='InstanceId'),
  securityGroupId?: string(name='SecurityGroupId'),
  version?: string(name='Version'),
}

model LeaveSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model LeaveSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: LeaveSecurityGroupResponseBody(name='body'),
}

async function leaveSecurityGroupWithOptions(request: LeaveSecurityGroupRequest, runtime: Util.RuntimeOptions): LeaveSecurityGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'LeaveSecurityGroup',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function leaveSecurityGroup(request: LeaveSecurityGroupRequest): LeaveSecurityGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return leaveSecurityGroupWithOptions(request, runtime);
}

model ListApplicationsRequest {
  appVersions?: string(name='AppVersions'),
  clusterNames?: string(name='ClusterNames'),
  level?: string(name='Level'),
  maxDate?: string(name='MaxDate'),
  minDate?: string(name='MinDate'),
  outAppInfoParams?: string(name='OutAppInfoParams'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListApplicationsResponseBody = {
  applications?: {
    application?: [ 
    {
      appList?: {
        app?: [ 
        {
          appId?: string(name='AppId'),
          appInfo?: string(name='AppInfo'),
        }
      ](name='App')
      }(name='AppList'),
      clusterName?: string(name='ClusterName'),
    }
  ](name='Application')
  }(name='Applications'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListApplicationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListApplicationsResponseBody(name='body'),
}

async function listApplicationsWithOptions(request: ListApplicationsRequest, runtime: Util.RuntimeOptions): ListApplicationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appVersions)) {
    query['AppVersions'] = request.appVersions;
  }
  if (!Util.isUnset(request.clusterNames)) {
    query['ClusterNames'] = request.clusterNames;
  }
  if (!Util.isUnset(request.level)) {
    query['Level'] = request.level;
  }
  if (!Util.isUnset(request.maxDate)) {
    query['MaxDate'] = request.maxDate;
  }
  if (!Util.isUnset(request.minDate)) {
    query['MinDate'] = request.minDate;
  }
  if (!Util.isUnset(request.outAppInfoParams)) {
    query['OutAppInfoParams'] = request.outAppInfoParams;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListApplications',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listApplications(request: ListApplicationsRequest): ListApplicationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listApplicationsWithOptions(request, runtime);
}

model ModifyEnsEipAddressAttributeRequest {
  allocationId?: string(name='AllocationId'),
  bandwidth?: int32(name='Bandwidth'),
  description?: string(name='Description'),
  name?: string(name='Name'),
}

model ModifyEnsEipAddressAttributeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ModifyEnsEipAddressAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyEnsEipAddressAttributeResponseBody(name='body'),
}

async function modifyEnsEipAddressAttributeWithOptions(request: ModifyEnsEipAddressAttributeRequest, runtime: Util.RuntimeOptions): ModifyEnsEipAddressAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allocationId)) {
    query['AllocationId'] = request.allocationId;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyEnsEipAddressAttribute',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyEnsEipAddressAttribute(request: ModifyEnsEipAddressAttributeRequest): ModifyEnsEipAddressAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyEnsEipAddressAttributeWithOptions(request, runtime);
}

model ModifyEpnInstanceRequest {
  EPNInstanceId?: string(name='EPNInstanceId'),
  EPNInstanceName?: string(name='EPNInstanceName'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut'),
  networkingModel?: string(name='NetworkingModel'),
}

model ModifyEpnInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyEpnInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyEpnInstanceResponseBody(name='body'),
}

async function modifyEpnInstanceWithOptions(request: ModifyEpnInstanceRequest, runtime: Util.RuntimeOptions): ModifyEpnInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.EPNInstanceId)) {
    query['EPNInstanceId'] = request.EPNInstanceId;
  }
  if (!Util.isUnset(request.EPNInstanceName)) {
    query['EPNInstanceName'] = request.EPNInstanceName;
  }
  if (!Util.isUnset(request.internetMaxBandwidthOut)) {
    query['InternetMaxBandwidthOut'] = request.internetMaxBandwidthOut;
  }
  if (!Util.isUnset(request.networkingModel)) {
    query['NetworkingModel'] = request.networkingModel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyEpnInstance',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyEpnInstance(request: ModifyEpnInstanceRequest): ModifyEpnInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyEpnInstanceWithOptions(request, runtime);
}

model ModifyImageAttributeRequest {
  imageId?: string(name='ImageId'),
  imageName?: string(name='ImageName'),
  version?: string(name='Version'),
  product?: string(name='product'),
}

model ModifyImageAttributeResponseBody = {
  code?: int32(name='Code'),
  requestId?: string(name='RequestId'),
}

model ModifyImageAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyImageAttributeResponseBody(name='body'),
}

async function modifyImageAttributeWithOptions(request: ModifyImageAttributeRequest, runtime: Util.RuntimeOptions): ModifyImageAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  if (!Util.isUnset(request.product)) {
    query['product'] = request.product;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyImageAttribute',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyImageAttribute(request: ModifyImageAttributeRequest): ModifyImageAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyImageAttributeWithOptions(request, runtime);
}

model ModifyImageSharePermissionRequest {
  addAccounts?: string(name='AddAccounts'),
  imageId?: string(name='ImageId'),
  removeAccounts?: string(name='RemoveAccounts'),
}

model ModifyImageSharePermissionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyImageSharePermissionResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyImageSharePermissionResponseBody(name='body'),
}

async function modifyImageSharePermissionWithOptions(request: ModifyImageSharePermissionRequest, runtime: Util.RuntimeOptions): ModifyImageSharePermissionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addAccounts)) {
    query['AddAccounts'] = request.addAccounts;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.removeAccounts)) {
    query['RemoveAccounts'] = request.removeAccounts;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyImageSharePermission',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyImageSharePermission(request: ModifyImageSharePermissionRequest): ModifyImageSharePermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyImageSharePermissionWithOptions(request, runtime);
}

model ModifyInstanceAttributeRequest {
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  password?: string(name='Password'),
  version?: string(name='Version'),
}

model ModifyInstanceAttributeResponseBody = {
  code?: int32(name='Code'),
  requestId?: string(name='RequestId'),
}

model ModifyInstanceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceAttributeResponseBody(name='body'),
}

async function modifyInstanceAttributeWithOptions(request: ModifyInstanceAttributeRequest, runtime: Util.RuntimeOptions): ModifyInstanceAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstanceAttribute',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyInstanceAttribute(request: ModifyInstanceAttributeRequest): ModifyInstanceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceAttributeWithOptions(request, runtime);
}

model ModifyInstanceAutoRenewAttributeRequest {
  autoRenew?: string(name='AutoRenew'),
  duration?: string(name='Duration'),
  instanceIds?: string(name='InstanceIds'),
  ownerId?: string(name='OwnerId'),
  renewalStatus?: string(name='RenewalStatus'),
}

model ModifyInstanceAutoRenewAttributeResponseBody = {
  code?: int32(name='Code'),
  requestId?: string(name='RequestId'),
}

model ModifyInstanceAutoRenewAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceAutoRenewAttributeResponseBody(name='body'),
}

async function modifyInstanceAutoRenewAttributeWithOptions(request: ModifyInstanceAutoRenewAttributeRequest, runtime: Util.RuntimeOptions): ModifyInstanceAutoRenewAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.renewalStatus)) {
    query['RenewalStatus'] = request.renewalStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstanceAutoRenewAttribute',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyInstanceAutoRenewAttribute(request: ModifyInstanceAutoRenewAttributeRequest): ModifyInstanceAutoRenewAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceAutoRenewAttributeWithOptions(request, runtime);
}

model ModifyLoadBalancerAttributeRequest {
  loadBalancerId?: string(name='LoadBalancerId'),
  loadBalancerName?: string(name='LoadBalancerName'),
}

model ModifyLoadBalancerAttributeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ModifyLoadBalancerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyLoadBalancerAttributeResponseBody(name='body'),
}

async function modifyLoadBalancerAttributeWithOptions(request: ModifyLoadBalancerAttributeRequest, runtime: Util.RuntimeOptions): ModifyLoadBalancerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.loadBalancerName)) {
    query['LoadBalancerName'] = request.loadBalancerName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyLoadBalancerAttribute',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyLoadBalancerAttribute(request: ModifyLoadBalancerAttributeRequest): ModifyLoadBalancerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyLoadBalancerAttributeWithOptions(request, runtime);
}

model ModifyNetworkAttributeRequest {
  description?: string(name='Description'),
  networkId?: string(name='NetworkId'),
  networkName?: string(name='NetworkName'),
}

model ModifyNetworkAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNetworkAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNetworkAttributeResponseBody(name='body'),
}

async function modifyNetworkAttributeWithOptions(request: ModifyNetworkAttributeRequest, runtime: Util.RuntimeOptions): ModifyNetworkAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.networkId)) {
    query['NetworkId'] = request.networkId;
  }
  if (!Util.isUnset(request.networkName)) {
    query['NetworkName'] = request.networkName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyNetworkAttribute',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyNetworkAttribute(request: ModifyNetworkAttributeRequest): ModifyNetworkAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNetworkAttributeWithOptions(request, runtime);
}

model ModifyPrepayInstanceSpecRequest {
  instanceId?: string(name='InstanceId', description='变配实例id'),
  instanceType?: string(name='InstanceType', description='更新的配置'),
}

model ModifyPrepayInstanceSpecResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ModifyPrepayInstanceSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyPrepayInstanceSpecResponseBody(name='body'),
}

async function modifyPrepayInstanceSpecWithOptions(request: ModifyPrepayInstanceSpecRequest, runtime: Util.RuntimeOptions): ModifyPrepayInstanceSpecResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyPrepayInstanceSpec',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyPrepayInstanceSpec(request: ModifyPrepayInstanceSpecRequest): ModifyPrepayInstanceSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyPrepayInstanceSpecWithOptions(request, runtime);
}

model ModifySecurityGroupAttributeRequest {
  description?: string(name='Description'),
  securityGroupId?: string(name='SecurityGroupId'),
  securityGroupName?: string(name='SecurityGroupName'),
}

model ModifySecurityGroupAttributeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ModifySecurityGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySecurityGroupAttributeResponseBody(name='body'),
}

async function modifySecurityGroupAttributeWithOptions(request: ModifySecurityGroupAttributeRequest, runtime: Util.RuntimeOptions): ModifySecurityGroupAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.securityGroupName)) {
    query['SecurityGroupName'] = request.securityGroupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifySecurityGroupAttribute',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifySecurityGroupAttribute(request: ModifySecurityGroupAttributeRequest): ModifySecurityGroupAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySecurityGroupAttributeWithOptions(request, runtime);
}

model ModifyVSwitchAttributeRequest {
  description?: string(name='Description'),
  vSwitchId?: string(name='VSwitchId'),
  vSwitchName?: string(name='VSwitchName'),
}

model ModifyVSwitchAttributeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ModifyVSwitchAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVSwitchAttributeResponseBody(name='body'),
}

async function modifyVSwitchAttributeWithOptions(request: ModifyVSwitchAttributeRequest, runtime: Util.RuntimeOptions): ModifyVSwitchAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vSwitchName)) {
    query['VSwitchName'] = request.vSwitchName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVSwitchAttribute',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyVSwitchAttribute(request: ModifyVSwitchAttributeRequest): ModifyVSwitchAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVSwitchAttributeWithOptions(request, runtime);
}

model PreCreateEnsServiceRequest {
  bandwidthType?: string(name='BandwidthType'),
  buyResourcesDetail?: string(name='BuyResourcesDetail'),
  dataDiskSize?: string(name='DataDiskSize'),
  ensServiceName?: string(name='EnsServiceName'),
  imageId?: string(name='ImageId'),
  instanceBandwithdLimit?: string(name='InstanceBandwithdLimit'),
  instanceSpec?: string(name='InstanceSpec'),
  keyPairName?: string(name='KeyPairName'),
  netLevel?: string(name='NetLevel'),
  password?: string(name='Password'),
  schedulingPriceStrategy?: string(name='SchedulingPriceStrategy'),
  schedulingStrategy?: string(name='SchedulingStrategy'),
  systemDiskSize?: string(name='SystemDiskSize'),
  userData?: string(name='UserData'),
  version?: string(name='Version'),
}

model PreCreateEnsServiceResponseBody = {
  buyResourcesDetail?: string(name='BuyResourcesDetail'),
  code?: int32(name='Code'),
  ensServiceId?: string(name='EnsServiceId'),
  netLevel?: string(name='NetLevel'),
  requestId?: string(name='RequestId'),
}

model PreCreateEnsServiceResponse = {
  headers: map[string]string(name='headers'),
  body: PreCreateEnsServiceResponseBody(name='body'),
}

async function preCreateEnsServiceWithOptions(request: PreCreateEnsServiceRequest, runtime: Util.RuntimeOptions): PreCreateEnsServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidthType)) {
    query['BandwidthType'] = request.bandwidthType;
  }
  if (!Util.isUnset(request.buyResourcesDetail)) {
    query['BuyResourcesDetail'] = request.buyResourcesDetail;
  }
  if (!Util.isUnset(request.dataDiskSize)) {
    query['DataDiskSize'] = request.dataDiskSize;
  }
  if (!Util.isUnset(request.ensServiceName)) {
    query['EnsServiceName'] = request.ensServiceName;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.instanceBandwithdLimit)) {
    query['InstanceBandwithdLimit'] = request.instanceBandwithdLimit;
  }
  if (!Util.isUnset(request.instanceSpec)) {
    query['InstanceSpec'] = request.instanceSpec;
  }
  if (!Util.isUnset(request.keyPairName)) {
    query['KeyPairName'] = request.keyPairName;
  }
  if (!Util.isUnset(request.netLevel)) {
    query['NetLevel'] = request.netLevel;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.schedulingPriceStrategy)) {
    query['SchedulingPriceStrategy'] = request.schedulingPriceStrategy;
  }
  if (!Util.isUnset(request.schedulingStrategy)) {
    query['SchedulingStrategy'] = request.schedulingStrategy;
  }
  if (!Util.isUnset(request.systemDiskSize)) {
    query['SystemDiskSize'] = request.systemDiskSize;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PreCreateEnsService',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function preCreateEnsService(request: PreCreateEnsServiceRequest): PreCreateEnsServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return preCreateEnsServiceWithOptions(request, runtime);
}

model PushApplicationDataRequest {
  appId?: string(name='AppId'),
  data?: string(name='Data'),
  pushStrategy?: string(name='PushStrategy'),
  timeout?: int32(name='Timeout'),
}

model PushApplicationDataResponseBody = {
  pushResults?: {
    pushResult?: [ 
    {
      name?: string(name='Name'),
      resultCode?: int32(name='ResultCode'),
      resultDescrip?: string(name='ResultDescrip'),
      version?: string(name='Version'),
    }
  ](name='PushResult')
  }(name='PushResults'),
  requestId?: string(name='RequestId'),
}

model PushApplicationDataResponse = {
  headers: map[string]string(name='headers'),
  body: PushApplicationDataResponseBody(name='body'),
}

async function pushApplicationDataWithOptions(request: PushApplicationDataRequest, runtime: Util.RuntimeOptions): PushApplicationDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.data)) {
    query['Data'] = request.data;
  }
  if (!Util.isUnset(request.pushStrategy)) {
    query['PushStrategy'] = request.pushStrategy;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PushApplicationData',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pushApplicationData(request: PushApplicationDataRequest): PushApplicationDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return pushApplicationDataWithOptions(request, runtime);
}

model ReInitDiskRequest {
  diskId?: string(name='DiskId'),
  imageId?: string(name='ImageId'),
  version?: string(name='Version'),
}

model ReInitDiskResponseBody = {
  code?: int32(name='Code'),
  requestId?: string(name='RequestId'),
}

model ReInitDiskResponse = {
  headers: map[string]string(name='headers'),
  body: ReInitDiskResponseBody(name='body'),
}

async function reInitDiskWithOptions(request: ReInitDiskRequest, runtime: Util.RuntimeOptions): ReInitDiskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.diskId)) {
    query['DiskId'] = request.diskId;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReInitDisk',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reInitDisk(request: ReInitDiskRequest): ReInitDiskResponse {
  var runtime = new Util.RuntimeOptions{};
  return reInitDiskWithOptions(request, runtime);
}

model RebootInstanceRequest {
  forceStop?: string(name='ForceStop'),
  instanceId?: string(name='InstanceId'),
  version?: string(name='Version'),
}

model RebootInstanceResponseBody = {
  code?: int32(name='Code'),
  requestId?: string(name='RequestId'),
}

model RebootInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RebootInstanceResponseBody(name='body'),
}

async function rebootInstanceWithOptions(request: RebootInstanceRequest, runtime: Util.RuntimeOptions): RebootInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.forceStop)) {
    query['ForceStop'] = request.forceStop;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RebootInstance',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rebootInstance(request: RebootInstanceRequest): RebootInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return rebootInstanceWithOptions(request, runtime);
}

model ReleaseInstanceRequest {
  instanceId?: string(name='InstanceId', description='实例id'),
}

model ReleaseInstanceResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ReleaseInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseInstanceResponseBody(name='body'),
}

async function releaseInstanceWithOptions(request: ReleaseInstanceRequest, runtime: Util.RuntimeOptions): ReleaseInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseInstance',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function releaseInstance(request: ReleaseInstanceRequest): ReleaseInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseInstanceWithOptions(request, runtime);
}

model ReleasePostPaidInstanceRequest {
  instanceId?: string(name='InstanceId'),
  version?: string(name='Version'),
}

model ReleasePostPaidInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleasePostPaidInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ReleasePostPaidInstanceResponseBody(name='body'),
}

async function releasePostPaidInstanceWithOptions(request: ReleasePostPaidInstanceRequest, runtime: Util.RuntimeOptions): ReleasePostPaidInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleasePostPaidInstance',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function releasePostPaidInstance(request: ReleasePostPaidInstanceRequest): ReleasePostPaidInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return releasePostPaidInstanceWithOptions(request, runtime);
}

model ReleasePrePaidInstanceRequest {
  instanceId?: string(name='InstanceId'),
  version?: string(name='Version'),
}

model ReleasePrePaidInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleasePrePaidInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ReleasePrePaidInstanceResponseBody(name='body'),
}

async function releasePrePaidInstanceWithOptions(request: ReleasePrePaidInstanceRequest, runtime: Util.RuntimeOptions): ReleasePrePaidInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleasePrePaidInstance',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function releasePrePaidInstance(request: ReleasePrePaidInstanceRequest): ReleasePrePaidInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return releasePrePaidInstanceWithOptions(request, runtime);
}

model RemoveBackendServersRequest {
  backendServers?: [ 
    {
      ip?: string(name='Ip'),
      port?: int32(name='Port', description='端口'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type', description='后端服务器类型。  ens：ENS实例（默认）'),
      weight?: int32(name='Weight', description='后端服务器的权重。  取值：0~100  默认值为100，如果值为0，则不会将请求转发给该后端服务器。'),
    }
  ](name='BackendServers'),
  loadBalancerId?: string(name='LoadBalancerId'),
}

model RemoveBackendServersShrinkRequest {
  backendServersShrink?: string(name='BackendServers'),
  loadBalancerId?: string(name='LoadBalancerId'),
}

model RemoveBackendServersResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      ip?: string(name='Ip'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model RemoveBackendServersResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveBackendServersResponseBody(name='body'),
}

async function removeBackendServersWithOptions(tmpReq: RemoveBackendServersRequest, runtime: Util.RuntimeOptions): RemoveBackendServersResponse {
  Util.validateModel(tmpReq);
  var request = new RemoveBackendServersShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.backendServers)) {
    request.backendServersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.backendServers, 'BackendServers', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.backendServersShrink)) {
    query['BackendServers'] = request.backendServersShrink;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveBackendServers',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeBackendServers(request: RemoveBackendServersRequest): RemoveBackendServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeBackendServersWithOptions(request, runtime);
}

model RemovePublicIpsFromEpnInstanceRequest {
  EPNInstanceId?: string(name='EPNInstanceId'),
  instanceInfos?: string(name='InstanceInfos'),
}

model RemovePublicIpsFromEpnInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemovePublicIpsFromEpnInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RemovePublicIpsFromEpnInstanceResponseBody(name='body'),
}

async function removePublicIpsFromEpnInstanceWithOptions(request: RemovePublicIpsFromEpnInstanceRequest, runtime: Util.RuntimeOptions): RemovePublicIpsFromEpnInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.EPNInstanceId)) {
    query['EPNInstanceId'] = request.EPNInstanceId;
  }
  if (!Util.isUnset(request.instanceInfos)) {
    query['InstanceInfos'] = request.instanceInfos;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemovePublicIpsFromEpnInstance',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removePublicIpsFromEpnInstance(request: RemovePublicIpsFromEpnInstanceRequest): RemovePublicIpsFromEpnInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return removePublicIpsFromEpnInstanceWithOptions(request, runtime);
}

model RemoveVSwitchesFromEpnInstanceRequest {
  EPNInstanceId?: string(name='EPNInstanceId'),
  vSwitchesInfo?: string(name='VSwitchesInfo'),
}

model RemoveVSwitchesFromEpnInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveVSwitchesFromEpnInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveVSwitchesFromEpnInstanceResponseBody(name='body'),
}

async function removeVSwitchesFromEpnInstanceWithOptions(request: RemoveVSwitchesFromEpnInstanceRequest, runtime: Util.RuntimeOptions): RemoveVSwitchesFromEpnInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.EPNInstanceId)) {
    query['EPNInstanceId'] = request.EPNInstanceId;
  }
  if (!Util.isUnset(request.vSwitchesInfo)) {
    query['VSwitchesInfo'] = request.vSwitchesInfo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveVSwitchesFromEpnInstance',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeVSwitchesFromEpnInstance(request: RemoveVSwitchesFromEpnInstanceRequest): RemoveVSwitchesFromEpnInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeVSwitchesFromEpnInstanceWithOptions(request, runtime);
}

model RenewInstanceRequest {
  instanceId?: string(name='InstanceId', description='需要续费的实例ID。'),
  period?: long(name='Period', description='包年包月续费时长。'),
}

model RenewInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model RenewInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RenewInstanceResponseBody(name='body'),
}

async function renewInstanceWithOptions(request: RenewInstanceRequest, runtime: Util.RuntimeOptions): RenewInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RenewInstance',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function renewInstance(request: RenewInstanceRequest): RenewInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return renewInstanceWithOptions(request, runtime);
}

model RescaleApplicationRequest {
  appId?: string(name='AppId'),
  rescaleLevel?: string(name='RescaleLevel'),
  rescaleType?: string(name='RescaleType'),
  resourceSelector?: string(name='ResourceSelector'),
  timeout?: int32(name='Timeout'),
  toAppVersion?: string(name='ToAppVersion'),
}

model RescaleApplicationResponseBody = {
  requestId?: string(name='RequestId'),
}

model RescaleApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: RescaleApplicationResponseBody(name='body'),
}

async function rescaleApplicationWithOptions(request: RescaleApplicationRequest, runtime: Util.RuntimeOptions): RescaleApplicationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.rescaleLevel)) {
    query['RescaleLevel'] = request.rescaleLevel;
  }
  if (!Util.isUnset(request.rescaleType)) {
    query['RescaleType'] = request.rescaleType;
  }
  if (!Util.isUnset(request.resourceSelector)) {
    query['ResourceSelector'] = request.resourceSelector;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  if (!Util.isUnset(request.toAppVersion)) {
    query['ToAppVersion'] = request.toAppVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RescaleApplication',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rescaleApplication(request: RescaleApplicationRequest): RescaleApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return rescaleApplicationWithOptions(request, runtime);
}

model RescaleDeviceServiceRequest {
  appId?: string(name='AppId'),
  imageId?: string(name='ImageId'),
  ipType?: int32(name='IpType'),
  rescaleLevel?: string(name='RescaleLevel'),
  rescaleType?: string(name='RescaleType'),
  resourceInfo?: string(name='ResourceInfo'),
  resourceSelector?: string(name='ResourceSelector'),
  resourceSpec?: string(name='ResourceSpec'),
  serviceId?: string(name='ServiceId'),
  timeout?: long(name='Timeout'),
}

model RescaleDeviceServiceResponseBody = {
  deviceIds?: [ string ](name='DeviceIds'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId', description='Id of the request'),
  resourceDetailInfos?: [ 
    {
      ID?: string(name='ID'),
      IP?: string(name='IP'),
      ISP?: string(name='ISP'),
      mac?: string(name='Mac'),
      regionID?: string(name='RegionID'),
      server?: string(name='Server'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='ResourceDetailInfos'),
}

model RescaleDeviceServiceResponse = {
  headers: map[string]string(name='headers'),
  body: RescaleDeviceServiceResponseBody(name='body'),
}

async function rescaleDeviceServiceWithOptions(request: RescaleDeviceServiceRequest, runtime: Util.RuntimeOptions): RescaleDeviceServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.ipType)) {
    query['IpType'] = request.ipType;
  }
  if (!Util.isUnset(request.rescaleLevel)) {
    query['RescaleLevel'] = request.rescaleLevel;
  }
  if (!Util.isUnset(request.rescaleType)) {
    query['RescaleType'] = request.rescaleType;
  }
  if (!Util.isUnset(request.resourceSpec)) {
    query['ResourceSpec'] = request.resourceSpec;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['ServiceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.resourceInfo)) {
    body['ResourceInfo'] = request.resourceInfo;
  }
  if (!Util.isUnset(request.resourceSelector)) {
    body['ResourceSelector'] = request.resourceSelector;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RescaleDeviceService',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rescaleDeviceService(request: RescaleDeviceServiceRequest): RescaleDeviceServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return rescaleDeviceServiceWithOptions(request, runtime);
}

model ResetDeviceInstanceRequest {
  appId?: string(name='AppId', description='A short description of struct'),
  imageId?: string(name='ImageId'),
  instanceId?: string(name='InstanceId'),
}

model ResetDeviceInstanceResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ResetDeviceInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ResetDeviceInstanceResponseBody(name='body'),
}

async function resetDeviceInstanceWithOptions(request: ResetDeviceInstanceRequest, runtime: Util.RuntimeOptions): ResetDeviceInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetDeviceInstance',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resetDeviceInstance(request: ResetDeviceInstanceRequest): ResetDeviceInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetDeviceInstanceWithOptions(request, runtime);
}

model RestartDeviceInstanceRequest {
  appId?: string(name='AppId', description='App ID'),
  instanceId?: string(name='InstanceId', description='Instance ID'),
}

model RestartDeviceInstanceResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model RestartDeviceInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RestartDeviceInstanceResponseBody(name='body'),
}

async function restartDeviceInstanceWithOptions(request: RestartDeviceInstanceRequest, runtime: Util.RuntimeOptions): RestartDeviceInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestartDeviceInstance',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function restartDeviceInstance(request: RestartDeviceInstanceRequest): RestartDeviceInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartDeviceInstanceWithOptions(request, runtime);
}

model RevokeSecurityGroupRequest {
  ipProtocol?: string(name='IpProtocol'),
  policy?: string(name='Policy'),
  portRange?: string(name='PortRange'),
  priority?: int32(name='Priority'),
  securityGroupId?: string(name='SecurityGroupId'),
  sourceCidrIp?: string(name='SourceCidrIp'),
  sourcePortRange?: string(name='SourcePortRange'),
  version?: string(name='Version'),
}

model RevokeSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model RevokeSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: RevokeSecurityGroupResponseBody(name='body'),
}

async function revokeSecurityGroupWithOptions(request: RevokeSecurityGroupRequest, runtime: Util.RuntimeOptions): RevokeSecurityGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ipProtocol)) {
    query['IpProtocol'] = request.ipProtocol;
  }
  if (!Util.isUnset(request.policy)) {
    query['Policy'] = request.policy;
  }
  if (!Util.isUnset(request.portRange)) {
    query['PortRange'] = request.portRange;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.sourceCidrIp)) {
    query['SourceCidrIp'] = request.sourceCidrIp;
  }
  if (!Util.isUnset(request.sourcePortRange)) {
    query['SourcePortRange'] = request.sourcePortRange;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RevokeSecurityGroup',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function revokeSecurityGroup(request: RevokeSecurityGroupRequest): RevokeSecurityGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokeSecurityGroupWithOptions(request, runtime);
}

model RevokeSecurityGroupEgressRequest {
  destCidrIp?: string(name='DestCidrIp'),
  ipProtocol?: string(name='IpProtocol'),
  policy?: string(name='Policy'),
  portRange?: string(name='PortRange'),
  priority?: int32(name='Priority'),
  securityGroupId?: string(name='SecurityGroupId'),
  sourcePortRange?: string(name='SourcePortRange'),
  version?: string(name='Version'),
}

model RevokeSecurityGroupEgressResponseBody = {
  requestId?: string(name='RequestId'),
}

model RevokeSecurityGroupEgressResponse = {
  headers: map[string]string(name='headers'),
  body: RevokeSecurityGroupEgressResponseBody(name='body'),
}

async function revokeSecurityGroupEgressWithOptions(request: RevokeSecurityGroupEgressRequest, runtime: Util.RuntimeOptions): RevokeSecurityGroupEgressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.destCidrIp)) {
    query['DestCidrIp'] = request.destCidrIp;
  }
  if (!Util.isUnset(request.ipProtocol)) {
    query['IpProtocol'] = request.ipProtocol;
  }
  if (!Util.isUnset(request.policy)) {
    query['Policy'] = request.policy;
  }
  if (!Util.isUnset(request.portRange)) {
    query['PortRange'] = request.portRange;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.sourcePortRange)) {
    query['SourcePortRange'] = request.sourcePortRange;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RevokeSecurityGroupEgress',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function revokeSecurityGroupEgress(request: RevokeSecurityGroupEgressRequest): RevokeSecurityGroupEgressResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokeSecurityGroupEgressWithOptions(request, runtime);
}

model RollbackApplicationRequest {
  appId?: string(name='AppId'),
  fromAppVersion?: string(name='FromAppVersion'),
  timeout?: int32(name='Timeout'),
  toAppVersion?: string(name='ToAppVersion'),
}

model RollbackApplicationResponseBody = {
  requestId?: string(name='RequestId'),
}

model RollbackApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: RollbackApplicationResponseBody(name='body'),
}

async function rollbackApplicationWithOptions(request: RollbackApplicationRequest, runtime: Util.RuntimeOptions): RollbackApplicationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.fromAppVersion)) {
    query['FromAppVersion'] = request.fromAppVersion;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  if (!Util.isUnset(request.toAppVersion)) {
    query['ToAppVersion'] = request.toAppVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RollbackApplication',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rollbackApplication(request: RollbackApplicationRequest): RollbackApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return rollbackApplicationWithOptions(request, runtime);
}

model RunInstancesRequest {
  amount?: long(name='Amount', description='数量'),
  autoRenew?: boolean(name='AutoRenew', description='是否自动续费，默认为false'),
  carrier?: string(name='Carrier', description='运营商'),
  dataDisk?: [ 
    {
      category?: string(name='Category'),
      size?: long(name='Size'),
    }
  ](name='DataDisk', description='数据盘规格'),
  ensRegionId?: string(name='EnsRegionId', description='节点id'),
  hostName?: string(name='HostName', description='主机名称'),
  imageId?: string(name='ImageId', description='镜像id'),
  instanceChargeType?: string(name='InstanceChargeType', description='实例付费方式，PrePaid:预付费，包年包月 PostPaid:按量付费'),
  instanceName?: string(name='InstanceName', description='实例名称。长度为2~128个字符，必须以大小字母或中文开头，不能以http://和https://开头。可以包含中文、英文、数字、半角冒号（:）、下划线（_）、点号（.）或者连字符（-）。默认值为实例的InstanceId'),
  instanceType?: string(name='InstanceType', description='实例规格'),
  internetChargeType?: string(name='InternetChargeType', description='带宽计费方式'),
  internetMaxBandwidthOut?: long(name='InternetMaxBandwidthOut', description='公网最大带宽，如果参数InternetMaxBandwidthOut的值大于0，则自动为实例分配公网IP。'),
  keyPairName?: string(name='KeyPairName', description='密钥对名称'),
  netDistrictCode?: string(name='NetDistrictCode', description='地区code'),
  netWorkId?: string(name='NetWorkId', description='网络id'),
  password?: string(name='Password', description='实例密码'),
  period?: long(name='Period', description='购买资源的时长，单位为：月'),
  periodUnit?: string(name='PeriodUnit', description='查询云服务器ENS不同计费周期的价格。取值范围：
Month（默认）：按月计费的价格单位。
Day：按天计费的价格单位。'),
  privateIpAddress?: string(name='PrivateIpAddress', description='私网ip'),
  scheduleAreaLevel?: string(name='ScheduleAreaLevel', description='调度层级'),
  schedulingPriceStrategy?: string(name='SchedulingPriceStrategy', description='调度价格策略'),
  schedulingStrategy?: string(name='SchedulingStrategy', description='调度策略'),
  securityId?: string(name='SecurityId', description='安全组id'),
  systemDisk?: {
    size?: long(name='Size'),
  }(name='SystemDisk', description='系统盘规格'),
  uniqueSuffix?: boolean(name='UniqueSuffix', description='是否为HostName和InstanceName添加有序后缀，有序后缀从001开始递增，最大不能超过999'),
  userData?: string(name='UserData', description='用户自定义数据，最大支持16KB 您可传入UserData信息。UserData以Base64的方式编码'),
  vSwitchId?: string(name='VSwitchId', description='交换机id'),
}

model RunInstancesShrinkRequest {
  amount?: long(name='Amount', description='数量'),
  autoRenew?: boolean(name='AutoRenew', description='是否自动续费，默认为false'),
  carrier?: string(name='Carrier', description='运营商'),
  dataDiskShrink?: string(name='DataDisk', description='数据盘规格'),
  ensRegionId?: string(name='EnsRegionId', description='节点id'),
  hostName?: string(name='HostName', description='主机名称'),
  imageId?: string(name='ImageId', description='镜像id'),
  instanceChargeType?: string(name='InstanceChargeType', description='实例付费方式，PrePaid:预付费，包年包月 PostPaid:按量付费'),
  instanceName?: string(name='InstanceName', description='实例名称。长度为2~128个字符，必须以大小字母或中文开头，不能以http://和https://开头。可以包含中文、英文、数字、半角冒号（:）、下划线（_）、点号（.）或者连字符（-）。默认值为实例的InstanceId'),
  instanceType?: string(name='InstanceType', description='实例规格'),
  internetChargeType?: string(name='InternetChargeType', description='带宽计费方式'),
  internetMaxBandwidthOut?: long(name='InternetMaxBandwidthOut', description='公网最大带宽，如果参数InternetMaxBandwidthOut的值大于0，则自动为实例分配公网IP。'),
  keyPairName?: string(name='KeyPairName', description='密钥对名称'),
  netDistrictCode?: string(name='NetDistrictCode', description='地区code'),
  netWorkId?: string(name='NetWorkId', description='网络id'),
  password?: string(name='Password', description='实例密码'),
  period?: long(name='Period', description='购买资源的时长，单位为：月'),
  periodUnit?: string(name='PeriodUnit', description='查询云服务器ENS不同计费周期的价格。取值范围：
Month（默认）：按月计费的价格单位。
Day：按天计费的价格单位。'),
  privateIpAddress?: string(name='PrivateIpAddress', description='私网ip'),
  scheduleAreaLevel?: string(name='ScheduleAreaLevel', description='调度层级'),
  schedulingPriceStrategy?: string(name='SchedulingPriceStrategy', description='调度价格策略'),
  schedulingStrategy?: string(name='SchedulingStrategy', description='调度策略'),
  securityId?: string(name='SecurityId', description='安全组id'),
  systemDiskShrink?: string(name='SystemDisk', description='系统盘规格'),
  uniqueSuffix?: boolean(name='UniqueSuffix', description='是否为HostName和InstanceName添加有序后缀，有序后缀从001开始递增，最大不能超过999'),
  userData?: string(name='UserData', description='用户自定义数据，最大支持16KB 您可传入UserData信息。UserData以Base64的方式编码'),
  vSwitchId?: string(name='VSwitchId', description='交换机id'),
}

model RunInstancesResponseBody = {
  instanceIds?: [ string ](name='InstanceIds'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model RunInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: RunInstancesResponseBody(name='body'),
}

async function runInstancesWithOptions(tmpReq: RunInstancesRequest, runtime: Util.RuntimeOptions): RunInstancesResponse {
  Util.validateModel(tmpReq);
  var request = new RunInstancesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.dataDisk)) {
    request.dataDiskShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dataDisk, 'DataDisk', 'json');
  }
  if (!Util.isUnset(tmpReq.systemDisk)) {
    request.systemDiskShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.systemDisk, 'SystemDisk', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.amount)) {
    query['Amount'] = request.amount;
  }
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.carrier)) {
    query['Carrier'] = request.carrier;
  }
  if (!Util.isUnset(request.dataDiskShrink)) {
    query['DataDisk'] = request.dataDiskShrink;
  }
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.hostName)) {
    query['HostName'] = request.hostName;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.instanceChargeType)) {
    query['InstanceChargeType'] = request.instanceChargeType;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.internetChargeType)) {
    query['InternetChargeType'] = request.internetChargeType;
  }
  if (!Util.isUnset(request.internetMaxBandwidthOut)) {
    query['InternetMaxBandwidthOut'] = request.internetMaxBandwidthOut;
  }
  if (!Util.isUnset(request.keyPairName)) {
    query['KeyPairName'] = request.keyPairName;
  }
  if (!Util.isUnset(request.netDistrictCode)) {
    query['NetDistrictCode'] = request.netDistrictCode;
  }
  if (!Util.isUnset(request.netWorkId)) {
    query['NetWorkId'] = request.netWorkId;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.privateIpAddress)) {
    query['PrivateIpAddress'] = request.privateIpAddress;
  }
  if (!Util.isUnset(request.scheduleAreaLevel)) {
    query['ScheduleAreaLevel'] = request.scheduleAreaLevel;
  }
  if (!Util.isUnset(request.schedulingPriceStrategy)) {
    query['SchedulingPriceStrategy'] = request.schedulingPriceStrategy;
  }
  if (!Util.isUnset(request.schedulingStrategy)) {
    query['SchedulingStrategy'] = request.schedulingStrategy;
  }
  if (!Util.isUnset(request.securityId)) {
    query['SecurityId'] = request.securityId;
  }
  if (!Util.isUnset(request.systemDiskShrink)) {
    query['SystemDisk'] = request.systemDiskShrink;
  }
  if (!Util.isUnset(request.uniqueSuffix)) {
    query['UniqueSuffix'] = request.uniqueSuffix;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RunInstances',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function runInstances(request: RunInstancesRequest): RunInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return runInstancesWithOptions(request, runtime);
}

model RunServiceScheduleRequest {
  appId?: string(name='AppId'),
  clientIp?: string(name='ClientIp'),
  directorys?: string(name='Directorys'),
  podConfigName?: string(name='PodConfigName'),
  preLockedTimeout?: int32(name='PreLockedTimeout'),
  scheduleStrategy?: string(name='ScheduleStrategy'),
  serviceAction?: string(name='ServiceAction'),
  serviceCommands?: string(name='ServiceCommands'),
  uuid?: string(name='Uuid'),
}

model RunServiceScheduleResponseBody = {
  commandResults?: {
    commandResult?: [ 
    {
      command?: string(name='Command'),
      containerName?: string(name='ContainerName'),
      resultMsg?: string(name='ResultMsg'),
    }
  ](name='CommandResult')
  }(name='CommandResults'),
  index?: int32(name='Index'),
  instanceId?: string(name='InstanceId'),
  instanceIp?: string(name='InstanceIp'),
  instancePort?: int32(name='InstancePort'),
  requestId?: string(name='RequestId'),
  requestRepeated?: string(name='RequestRepeated'),
  tcpPorts?: boolean(name='TcpPorts'),
}

model RunServiceScheduleResponse = {
  headers: map[string]string(name='headers'),
  body: RunServiceScheduleResponseBody(name='body'),
}

async function runServiceScheduleWithOptions(request: RunServiceScheduleRequest, runtime: Util.RuntimeOptions): RunServiceScheduleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.clientIp)) {
    query['ClientIp'] = request.clientIp;
  }
  if (!Util.isUnset(request.directorys)) {
    query['Directorys'] = request.directorys;
  }
  if (!Util.isUnset(request.podConfigName)) {
    query['PodConfigName'] = request.podConfigName;
  }
  if (!Util.isUnset(request.preLockedTimeout)) {
    query['PreLockedTimeout'] = request.preLockedTimeout;
  }
  if (!Util.isUnset(request.scheduleStrategy)) {
    query['ScheduleStrategy'] = request.scheduleStrategy;
  }
  if (!Util.isUnset(request.serviceAction)) {
    query['ServiceAction'] = request.serviceAction;
  }
  if (!Util.isUnset(request.serviceCommands)) {
    query['ServiceCommands'] = request.serviceCommands;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RunServiceSchedule',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function runServiceSchedule(request: RunServiceScheduleRequest): RunServiceScheduleResponse {
  var runtime = new Util.RuntimeOptions{};
  return runServiceScheduleWithOptions(request, runtime);
}

model SetBackendServersRequest {
  backendServers?: [ 
    {
      serverId?: string(name='ServerId'),
      type?: string(name='Type', description='后端服务器类型。  ens：ENS实例（默认）'),
      weight?: int32(name='Weight', description='后端服务器的权重。  取值：0~100  默认值为100，如果值为0，则不会将请求转发给该后端服务器。'),
    }
  ](name='BackendServers'),
  loadBalancerId?: string(name='LoadBalancerId'),
}

model SetBackendServersShrinkRequest {
  backendServersShrink?: string(name='BackendServers'),
  loadBalancerId?: string(name='LoadBalancerId'),
}

model SetBackendServersResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      ip?: string(name='Ip'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SetBackendServersResponse = {
  headers: map[string]string(name='headers'),
  body: SetBackendServersResponseBody(name='body'),
}

async function setBackendServersWithOptions(tmpReq: SetBackendServersRequest, runtime: Util.RuntimeOptions): SetBackendServersResponse {
  Util.validateModel(tmpReq);
  var request = new SetBackendServersShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.backendServers)) {
    request.backendServersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.backendServers, 'BackendServers', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.backendServersShrink)) {
    query['BackendServers'] = request.backendServersShrink;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetBackendServers',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setBackendServers(request: SetBackendServersRequest): SetBackendServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return setBackendServersWithOptions(request, runtime);
}

model SetLoadBalancerHTTPListenerAttributeRequest {
  description?: string(name='Description', description='设置监听的描述信息。  长度限制为1-80个字符，允许包含字母、数字、“-”、“/”、“.”和“_”等字符。支持中文描述。'),
  healthCheck?: string(name='HealthCheck', description='是否开启健康检查。  取值：on | off。'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='健康检查的后端服务器的端口。  取值： 1~65535。    说明 在HealthCheck值为on时才会有效。'),
  healthCheckDomain?: string(name='HealthCheckDomain', description='用于健康检查的域名，取值：  $_ip： 后端服务器的私网IP。当指定了IP或该参数未指定时，负载均衡会使用各后端服务器的私网IP当做健康检查使用的域名。是否要支持？ domain：域名长度为1-80字符，只能包含字母、数字、点号（.）和连字符（-）。   说明 在HealthCheck值为on时才会有效。'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode', description='健康检查正常的HTTP状态码，多个状态码用逗号分隔。  默认值为http_2xx。  取值：http_2xx | http_3xx | http_4xx | http_5xx。   说明 在HealthCheck值为on时才会有效。'),
  healthCheckInterval?: int32(name='HealthCheckInterval', description='健康检查的时间间隔。  取值： 1~50（秒）。   说明 在HealthCheck值为on时才会有效。'),
  healthCheckMethod?: string(name='HealthCheckMethod'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout', description='接收来自运行状况检查的响应需要等待的时间。如果后端ECS在指定的时间内没有正确响应，则判定为健康检查失败。在HealthCheck值为on时才会有效。  取值：1~300（秒）。   说明 如果HealthCHeckTimeout的值小于HealthCheckInterval的值，则HealthCHeckTimeout无效，超时时间为HealthCheckInterval的值。'),
  healthCheckURI?: string(name='HealthCheckURI', description='用于健康检查的URI。  长度限制为1~80，只能使用字母、数字和”-/.%?#&amp;“这些字符。 URL不能只为”/“，但必须以”/“开头。    说明 在HealthCheck值为on时才会有效。'),
  healthyThreshold?: int32(name='HealthyThreshold', description='健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success。  取值：2~10。    说明 在HealthCheck值为on时才会有效。'),
  idleTimeout?: int32(name='IdleTimeout', description='指定连接空闲超时时间，取值范围为1~60秒，默认值为15秒。  在超时时间内一直没有访问请求，负载均衡会暂时中断当前连接，直到一下次请求来临时重新建立新的连接。'),
  listenerPort?: int32(name='ListenerPort', description='负载均衡实例前端使用的端口。  取值：1-65535。'),
  loadBalancerId?: string(name='LoadBalancerId', description='负载均衡实例的ID。'),
  requestTimeout?: int32(name='RequestTimeout', description='指定请求超时时间，取值范围为1~180秒，默认值为60秒。  在超时时间内后端服务器一直没有响应，负载均衡将放弃等待，给客户端返回 HTTP 504 错误码。'),
  scheduler?: string(name='Scheduler', description='调度算法。取值：  wrr（默认值）：权重值越高的后端服务器，被轮询到的次数（概率）也越高。 wlc：除了根据每台后端服务器设定的权重值来进行轮询，同时还考虑后端服务器的实际负载（即连接数）。当权重值相同时，当前连接数越小的后端服务器被轮询到的次数（概率）也越高。 rr：按照访问顺序依次将外部请求依序分发到后端服务器。'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', description='健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail。  取值：2~10。   说明 在HealthCheck值为on时才会有效。'),
}

model SetLoadBalancerHTTPListenerAttributeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SetLoadBalancerHTTPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerHTTPListenerAttributeResponseBody(name='body'),
}

async function setLoadBalancerHTTPListenerAttributeWithOptions(request: SetLoadBalancerHTTPListenerAttributeRequest, runtime: Util.RuntimeOptions): SetLoadBalancerHTTPListenerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.healthCheck)) {
    query['HealthCheck'] = request.healthCheck;
  }
  if (!Util.isUnset(request.healthCheckConnectPort)) {
    query['HealthCheckConnectPort'] = request.healthCheckConnectPort;
  }
  if (!Util.isUnset(request.healthCheckDomain)) {
    query['HealthCheckDomain'] = request.healthCheckDomain;
  }
  if (!Util.isUnset(request.healthCheckHttpCode)) {
    query['HealthCheckHttpCode'] = request.healthCheckHttpCode;
  }
  if (!Util.isUnset(request.healthCheckInterval)) {
    query['HealthCheckInterval'] = request.healthCheckInterval;
  }
  if (!Util.isUnset(request.healthCheckMethod)) {
    query['HealthCheckMethod'] = request.healthCheckMethod;
  }
  if (!Util.isUnset(request.healthCheckTimeout)) {
    query['HealthCheckTimeout'] = request.healthCheckTimeout;
  }
  if (!Util.isUnset(request.healthCheckURI)) {
    query['HealthCheckURI'] = request.healthCheckURI;
  }
  if (!Util.isUnset(request.healthyThreshold)) {
    query['HealthyThreshold'] = request.healthyThreshold;
  }
  if (!Util.isUnset(request.idleTimeout)) {
    query['IdleTimeout'] = request.idleTimeout;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.requestTimeout)) {
    query['RequestTimeout'] = request.requestTimeout;
  }
  if (!Util.isUnset(request.scheduler)) {
    query['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.unhealthyThreshold)) {
    query['UnhealthyThreshold'] = request.unhealthyThreshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetLoadBalancerHTTPListenerAttribute',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setLoadBalancerHTTPListenerAttribute(request: SetLoadBalancerHTTPListenerAttributeRequest): SetLoadBalancerHTTPListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setLoadBalancerHTTPListenerAttributeWithOptions(request, runtime);
}

model SetLoadBalancerHTTPSListenerAttributeRequest {
  description?: string(name='Description', description='设置监听的描述信息。  长度限制为1-80个字符，允许包含字母、数字、“-”、“/”、“.”和“_”等字符。支持中文描述。'),
  healthCheck?: string(name='HealthCheck', description='是否开启健康检查。  取值：on | off。'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='健康检查的后端服务器的端口。  取值： 1~65535。    说明 在HealthCheck值为on时才会有效。'),
  healthCheckDomain?: string(name='HealthCheckDomain', description='用于健康检查的域名，取值：  $_ip： 后端服务器的私网IP。当指定了IP或该参数未指定时，负载均衡会使用各后端服务器的私网IP当做健康检查使用的域名。是否要支持？ domain：域名长度为1-80字符，只能包含字母、数字、点号（.）和连字符（-）。   说明 在HealthCheck值为on时才会有效。'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode', description='健康检查正常的HTTP状态码，多个状态码用逗号分隔。  默认值为http_2xx。  取值：http_2xx | http_3xx | http_4xx | http_5xx。   说明 在HealthCheck值为on时才会有效。'),
  healthCheckInterval?: int32(name='HealthCheckInterval', description='健康检查的时间间隔。  取值： 1~50（秒）。   说明 在HealthCheck值为on时才会有效。'),
  healthCheckMethod?: string(name='HealthCheckMethod'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout', description='接收来自运行状况检查的响应需要等待的时间。如果后端ECS在指定的时间内没有正确响应，则判定为健康检查失败。在HealthCheck值为on时才会有效。  取值：1~300（秒）。   说明 如果HealthCHeckTimeout的值小于HealthCheckInterval的值，则HealthCHeckTimeout无效，超时时间为HealthCheckInterval的值。'),
  healthCheckURI?: string(name='HealthCheckURI', description='用于健康检查的URI。  长度限制为1~80，只能使用字母、数字和”-/.%?#&amp;“这些字符。 URL不能只为”/“，但必须以”/“开头。    说明 在HealthCheck值为on时才会有效。'),
  healthyThreshold?: int32(name='HealthyThreshold', description='健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success。  取值：2~10。    说明 在HealthCheck值为on时才会有效。'),
  idleTimeout?: int32(name='IdleTimeout', description='指定连接空闲超时时间，取值范围为1~60秒，默认值为15秒。  在超时时间内一直没有访问请求，负载均衡会暂时中断当前连接，直到一下次请求来临时重新建立新的连接。'),
  listenerPort?: int32(name='ListenerPort', description='负载均衡实例前端使用的端口。  取值：1-65535。'),
  loadBalancerId?: string(name='LoadBalancerId', description='负载均衡实例的ID。'),
  requestTimeout?: int32(name='RequestTimeout', description='指定请求超时时间，取值范围为1~180秒，默认值为60秒。  在超时时间内后端服务器一直没有响应，负载均衡将放弃等待，给客户端返回 HTTP 504 错误码。'),
  scheduler?: string(name='Scheduler', description='调度算法。取值：  wrr（默认值）：权重值越高的后端服务器，被轮询到的次数（概率）也越高。 wlc：除了根据每台后端服务器设定的权重值来进行轮询，同时还考虑后端服务器的实际负载（即连接数）。当权重值相同时，当前连接数越小的后端服务器被轮询到的次数（概率）也越高。 rr：按照访问顺序依次将外部请求依序分发到后端服务器。'),
  serverCertificateId?: string(name='ServerCertificateId', description='服务器证书的ID。'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', description='健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail。  取值：2~10。   说明 在HealthCheck值为on时才会有效。'),
}

model SetLoadBalancerHTTPSListenerAttributeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SetLoadBalancerHTTPSListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerHTTPSListenerAttributeResponseBody(name='body'),
}

async function setLoadBalancerHTTPSListenerAttributeWithOptions(request: SetLoadBalancerHTTPSListenerAttributeRequest, runtime: Util.RuntimeOptions): SetLoadBalancerHTTPSListenerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.healthCheck)) {
    query['HealthCheck'] = request.healthCheck;
  }
  if (!Util.isUnset(request.healthCheckConnectPort)) {
    query['HealthCheckConnectPort'] = request.healthCheckConnectPort;
  }
  if (!Util.isUnset(request.healthCheckDomain)) {
    query['HealthCheckDomain'] = request.healthCheckDomain;
  }
  if (!Util.isUnset(request.healthCheckHttpCode)) {
    query['HealthCheckHttpCode'] = request.healthCheckHttpCode;
  }
  if (!Util.isUnset(request.healthCheckInterval)) {
    query['HealthCheckInterval'] = request.healthCheckInterval;
  }
  if (!Util.isUnset(request.healthCheckMethod)) {
    query['HealthCheckMethod'] = request.healthCheckMethod;
  }
  if (!Util.isUnset(request.healthCheckTimeout)) {
    query['HealthCheckTimeout'] = request.healthCheckTimeout;
  }
  if (!Util.isUnset(request.healthCheckURI)) {
    query['HealthCheckURI'] = request.healthCheckURI;
  }
  if (!Util.isUnset(request.healthyThreshold)) {
    query['HealthyThreshold'] = request.healthyThreshold;
  }
  if (!Util.isUnset(request.idleTimeout)) {
    query['IdleTimeout'] = request.idleTimeout;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.requestTimeout)) {
    query['RequestTimeout'] = request.requestTimeout;
  }
  if (!Util.isUnset(request.scheduler)) {
    query['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.serverCertificateId)) {
    query['ServerCertificateId'] = request.serverCertificateId;
  }
  if (!Util.isUnset(request.unhealthyThreshold)) {
    query['UnhealthyThreshold'] = request.unhealthyThreshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetLoadBalancerHTTPSListenerAttribute',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setLoadBalancerHTTPSListenerAttribute(request: SetLoadBalancerHTTPSListenerAttributeRequest): SetLoadBalancerHTTPSListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setLoadBalancerHTTPSListenerAttributeWithOptions(request, runtime);
}

model SetLoadBalancerStatusRequest {
  loadBalancerId?: string(name='LoadBalancerId'),
  loadBalancerStatus?: string(name='LoadBalancerStatus'),
}

model SetLoadBalancerStatusResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SetLoadBalancerStatusResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerStatusResponseBody(name='body'),
}

async function setLoadBalancerStatusWithOptions(request: SetLoadBalancerStatusRequest, runtime: Util.RuntimeOptions): SetLoadBalancerStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.loadBalancerStatus)) {
    query['LoadBalancerStatus'] = request.loadBalancerStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetLoadBalancerStatus',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setLoadBalancerStatus(request: SetLoadBalancerStatusRequest): SetLoadBalancerStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setLoadBalancerStatusWithOptions(request, runtime);
}

model SetLoadBalancerTCPListenerAttributeRequest {
  description?: string(name='Description', description='设置监听的描述信息。  长度限制为1-80个字符，允许包含字母、数字、“-”、“/”、“.”和“_”等字符。支持中文描述。'),
  eipTransmit?: string(name='EipTransmit'),
  establishedTimeout?: int32(name='EstablishedTimeout', description='连接超时时间。  取值：10~900（秒）。'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='健康检查使用的端口。  取值：1~65535。  不设置此参数时，表示使用后端服务端口（BackendServerPort）。'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', description='每次健康检查响应的最大超时时间。  取值：1~300（秒）。  默认值：5。'),
  healthCheckDomain?: string(name='HealthCheckDomain', description='用于健康检查的域名'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode', description='健康检查正常的HTTP状态码，多个状态码用逗号（,）分割。  取值：http_2xx（默认值） | http_3xx | http_4xx | http_5xx。'),
  healthCheckInterval?: int32(name='HealthCheckInterval', description='健康检查的时间间隔。  取值：1~50（秒）。'),
  healthCheckType?: string(name='HealthCheckType', description='健康检查类型。  取值：tcp（默认值） | http。'),
  healthCheckURI?: string(name='HealthCheckURI', description='用于健康检查的URI。长度限制为1~80，只能使用字母、数字、短横线（-）、正斜杠（/）、点号（.）、百分号（%）、#和&amp;这些字符。 URL不能只为/，但必须以/开头。  当TCP监听需要使用HTTP健康检查时可配置此参数，如不配置则按TCP健康检查。'),
  healthyThreshold?: int32(name='HealthyThreshold', description='健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success。  取值： 2~10。'),
  listenerPort?: int32(name='ListenerPort', description='负载均衡实例前端使用的端口。  取值：1-65535。'),
  loadBalancerId?: string(name='LoadBalancerId', description='负载均衡实例的ID。'),
  persistenceTimeout?: int32(name='PersistenceTimeout', description='会话保持的超时时间。  取值：0~3600（秒）。  默认值：0，表示关闭会话保持。'),
  scheduler?: string(name='Scheduler', description='度算法。取值：  wrr（默认值）：权重值越高的后端服务器，被轮询到的次数（概率）也越高。 wlc：除了根据每台后端服务器设定的权重值来进行轮询，同时还考虑后端服务器的实际负载（即连接数）。当权重值相同时，当前连接数越小的后端服务器被轮询到的次数（概率）也越高。 rr：按照访问顺序依次将外部请求依序分发到后端服务器。 sch：基于源IP地址的一致性hash，相同的源地址会调度到相同的后端服务器。'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', description='健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail。  取值：2~10。'),
}

model SetLoadBalancerTCPListenerAttributeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SetLoadBalancerTCPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerTCPListenerAttributeResponseBody(name='body'),
}

async function setLoadBalancerTCPListenerAttributeWithOptions(request: SetLoadBalancerTCPListenerAttributeRequest, runtime: Util.RuntimeOptions): SetLoadBalancerTCPListenerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.eipTransmit)) {
    query['EipTransmit'] = request.eipTransmit;
  }
  if (!Util.isUnset(request.establishedTimeout)) {
    query['EstablishedTimeout'] = request.establishedTimeout;
  }
  if (!Util.isUnset(request.healthCheckConnectPort)) {
    query['HealthCheckConnectPort'] = request.healthCheckConnectPort;
  }
  if (!Util.isUnset(request.healthCheckConnectTimeout)) {
    query['HealthCheckConnectTimeout'] = request.healthCheckConnectTimeout;
  }
  if (!Util.isUnset(request.healthCheckDomain)) {
    query['HealthCheckDomain'] = request.healthCheckDomain;
  }
  if (!Util.isUnset(request.healthCheckHttpCode)) {
    query['HealthCheckHttpCode'] = request.healthCheckHttpCode;
  }
  if (!Util.isUnset(request.healthCheckInterval)) {
    query['HealthCheckInterval'] = request.healthCheckInterval;
  }
  if (!Util.isUnset(request.healthCheckType)) {
    query['HealthCheckType'] = request.healthCheckType;
  }
  if (!Util.isUnset(request.healthCheckURI)) {
    query['HealthCheckURI'] = request.healthCheckURI;
  }
  if (!Util.isUnset(request.healthyThreshold)) {
    query['HealthyThreshold'] = request.healthyThreshold;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.persistenceTimeout)) {
    query['PersistenceTimeout'] = request.persistenceTimeout;
  }
  if (!Util.isUnset(request.scheduler)) {
    query['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.unhealthyThreshold)) {
    query['UnhealthyThreshold'] = request.unhealthyThreshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetLoadBalancerTCPListenerAttribute',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setLoadBalancerTCPListenerAttribute(request: SetLoadBalancerTCPListenerAttributeRequest): SetLoadBalancerTCPListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setLoadBalancerTCPListenerAttributeWithOptions(request, runtime);
}

model SetLoadBalancerUDPListenerAttributeRequest {
  description?: string(name='Description', description='设置监听的描述信息。  长度限制为1-80个字符，允许包含字母、数字、“-”、“/”、“.”和“_”等字符。支持中文描述。'),
  eipTransmit?: string(name='EipTransmit'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='健康检查使用的端口。取值：1-65535  不设置此参数时，表示使用后端服务端口（BackendServerPort）'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', description='接收来自运行状况检查的响应需要等待的时间。  如果后端ENS在指定的时间内没有正确响应，则判定为健康检查失败。  取值：1-300（秒）。默认为5秒'),
  healthCheckExp?: string(name='HealthCheckExp', description='UDP监听健康检查的响应串，只允许包含字母、数字，最大长度限制为64个字符。'),
  healthCheckInterval?: int32(name='HealthCheckInterval', description='健康检查的时间间隔。  取值：1-50（秒）。'),
  healthCheckReq?: string(name='HealthCheckReq', description='UDP监听健康检查的请求串，只允许包含字母、数字，最大长度限制为64个字符。'),
  healthyThreshold?: int32(name='HealthyThreshold', description='健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success。  取值：2-10。'),
  listenerPort?: int32(name='ListenerPort', description='负载均衡实例前端使用的端口。  取值：1-65535。'),
  loadBalancerId?: string(name='LoadBalancerId', description='负载均衡实例的ID。'),
  scheduler?: string(name='Scheduler', description='调度算法。取值：  wrr（默认值）：权重值越高的后端服务器，被轮询到的次数（概率）也越高。 wlc：除了根据每台后端服务器设定的权重值来进行轮询，同时还考虑后端服务器的实际负载（即连接数）。当权重值相同时，当前连接数越小的后端服务器被轮询到的次数（概率）也越高。 rr：按照访问顺序依次将外部请求依序分发到后端服务器。 sch：基于源IP地址的一致性hash，相同的源地址会调度到相同的后端服务器。'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', description='健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail。  取值：2-10。'),
}

model SetLoadBalancerUDPListenerAttributeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SetLoadBalancerUDPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerUDPListenerAttributeResponseBody(name='body'),
}

async function setLoadBalancerUDPListenerAttributeWithOptions(request: SetLoadBalancerUDPListenerAttributeRequest, runtime: Util.RuntimeOptions): SetLoadBalancerUDPListenerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.eipTransmit)) {
    query['EipTransmit'] = request.eipTransmit;
  }
  if (!Util.isUnset(request.healthCheckConnectPort)) {
    query['HealthCheckConnectPort'] = request.healthCheckConnectPort;
  }
  if (!Util.isUnset(request.healthCheckConnectTimeout)) {
    query['HealthCheckConnectTimeout'] = request.healthCheckConnectTimeout;
  }
  if (!Util.isUnset(request.healthCheckExp)) {
    query['HealthCheckExp'] = request.healthCheckExp;
  }
  if (!Util.isUnset(request.healthCheckInterval)) {
    query['HealthCheckInterval'] = request.healthCheckInterval;
  }
  if (!Util.isUnset(request.healthCheckReq)) {
    query['HealthCheckReq'] = request.healthCheckReq;
  }
  if (!Util.isUnset(request.healthyThreshold)) {
    query['HealthyThreshold'] = request.healthyThreshold;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.scheduler)) {
    query['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.unhealthyThreshold)) {
    query['UnhealthyThreshold'] = request.unhealthyThreshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetLoadBalancerUDPListenerAttribute',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setLoadBalancerUDPListenerAttribute(request: SetLoadBalancerUDPListenerAttributeRequest): SetLoadBalancerUDPListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setLoadBalancerUDPListenerAttributeWithOptions(request, runtime);
}

model StartEpnInstanceRequest {
  EPNInstanceId?: string(name='EPNInstanceId'),
}

model StartEpnInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartEpnInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StartEpnInstanceResponseBody(name='body'),
}

async function startEpnInstanceWithOptions(request: StartEpnInstanceRequest, runtime: Util.RuntimeOptions): StartEpnInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.EPNInstanceId)) {
    query['EPNInstanceId'] = request.EPNInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartEpnInstance',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startEpnInstance(request: StartEpnInstanceRequest): StartEpnInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return startEpnInstanceWithOptions(request, runtime);
}

model StartInstanceRequest {
  instanceId?: string(name='InstanceId'),
  version?: string(name='Version'),
}

model StartInstanceResponseBody = {
  code?: int32(name='Code'),
  requestId?: string(name='RequestId'),
}

model StartInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StartInstanceResponseBody(name='body'),
}

async function startInstanceWithOptions(request: StartInstanceRequest, runtime: Util.RuntimeOptions): StartInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartInstance',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startInstance(request: StartInstanceRequest): StartInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return startInstanceWithOptions(request, runtime);
}

model StartLoadBalancerListenerRequest {
  listenerPort?: int32(name='ListenerPort'),
  loadBalancerId?: string(name='LoadBalancerId'),
}

model StartLoadBalancerListenerResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model StartLoadBalancerListenerResponse = {
  headers: map[string]string(name='headers'),
  body: StartLoadBalancerListenerResponseBody(name='body'),
}

async function startLoadBalancerListenerWithOptions(request: StartLoadBalancerListenerRequest, runtime: Util.RuntimeOptions): StartLoadBalancerListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartLoadBalancerListener',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startLoadBalancerListener(request: StartLoadBalancerListenerRequest): StartLoadBalancerListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return startLoadBalancerListenerWithOptions(request, runtime);
}

model StopEpnInstanceRequest {
  EPNInstanceId?: string(name='EPNInstanceId'),
}

model StopEpnInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopEpnInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StopEpnInstanceResponseBody(name='body'),
}

async function stopEpnInstanceWithOptions(request: StopEpnInstanceRequest, runtime: Util.RuntimeOptions): StopEpnInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.EPNInstanceId)) {
    query['EPNInstanceId'] = request.EPNInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopEpnInstance',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopEpnInstance(request: StopEpnInstanceRequest): StopEpnInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopEpnInstanceWithOptions(request, runtime);
}

model StopInstanceRequest {
  forceStop?: string(name='ForceStop'),
  instanceId?: string(name='InstanceId'),
  version?: string(name='Version'),
}

model StopInstanceResponseBody = {
  code?: int32(name='Code'),
  requestId?: string(name='RequestId'),
}

model StopInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StopInstanceResponseBody(name='body'),
}

async function stopInstanceWithOptions(request: StopInstanceRequest, runtime: Util.RuntimeOptions): StopInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.forceStop)) {
    query['ForceStop'] = request.forceStop;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopInstance',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopInstance(request: StopInstanceRequest): StopInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopInstanceWithOptions(request, runtime);
}

model StopLoadBalancerListenerRequest {
  listenerPort?: int32(name='ListenerPort'),
  loadBalancerId?: string(name='LoadBalancerId'),
}

model StopLoadBalancerListenerResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model StopLoadBalancerListenerResponse = {
  headers: map[string]string(name='headers'),
  body: StopLoadBalancerListenerResponseBody(name='body'),
}

async function stopLoadBalancerListenerWithOptions(request: StopLoadBalancerListenerRequest, runtime: Util.RuntimeOptions): StopLoadBalancerListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopLoadBalancerListener',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopLoadBalancerListener(request: StopLoadBalancerListenerRequest): StopLoadBalancerListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopLoadBalancerListenerWithOptions(request, runtime);
}

model UnAssociateEnsEipAddressRequest {
  allocationId?: string(name='AllocationId'),
}

model UnAssociateEnsEipAddressResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UnAssociateEnsEipAddressResponse = {
  headers: map[string]string(name='headers'),
  body: UnAssociateEnsEipAddressResponseBody(name='body'),
}

async function unAssociateEnsEipAddressWithOptions(request: UnAssociateEnsEipAddressRequest, runtime: Util.RuntimeOptions): UnAssociateEnsEipAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allocationId)) {
    query['AllocationId'] = request.allocationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnAssociateEnsEipAddress',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unAssociateEnsEipAddress(request: UnAssociateEnsEipAddressRequest): UnAssociateEnsEipAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return unAssociateEnsEipAddressWithOptions(request, runtime);
}

model UpgradeApplicationRequest {
  appId?: string(name='AppId'),
  template?: string(name='Template'),
  timeout?: int32(name='Timeout'),
}

model UpgradeApplicationResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpgradeApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeApplicationResponseBody(name='body'),
}

async function upgradeApplicationWithOptions(request: UpgradeApplicationRequest, runtime: Util.RuntimeOptions): UpgradeApplicationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.template)) {
    query['Template'] = request.template;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeApplication',
    version = '2017-11-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradeApplication(request: UpgradeApplicationRequest): UpgradeApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeApplicationWithOptions(request, runtime);
}

