/**
 *
 */
import Util;
import GatewayClient;
import OpenApi;
import OpenApiUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @productId = 'Sls';
  var gatewayClient = new GatewayClient();
  @spi = gatewayClient;
  @endpointRule = 'central';
  }

model Alert {
  configuration?: AlertConfiguration(name='configuration', description='This parameter is required.'),
  createTime?: long(name='createTime'),
  description?: string(name='description', example='Alert Desc'),
  displayName?: string(name='displayName', description='This parameter is required.', example='alertNameExample'),
  lastModifiedTime?: long(name='lastModifiedTime'),
  name?: string(name='name', description='This parameter is required.', example='alert-123456'),
  schedule?: Schedule(name='schedule', description='This parameter is required.'),
  status?: string(name='status', example='ENABLED/DISABLED'),
}

model AlertConfiguration {
  annotations?: [
    AlertTag
  ](name='annotations'),
  autoAnnotation?: boolean(name='autoAnnotation', description='This parameter is required.', example='false'),
  conditionConfiguration?: ConditionConfiguration(name='conditionConfiguration'),
  dashboard?: string(name='dashboard', example='dasnboardExample'),
  groupConfiguration?: GroupConfiguration(name='groupConfiguration', description='This parameter is required.'),
  joinConfigurations?: [
    JoinConfiguration
  ](name='joinConfigurations'),
  labels?: [
    AlertTag
  ](name='labels'),
  muteUntil?: long(name='muteUntil', example='1698907508'),
  noDataFire?: boolean(name='noDataFire', description='This parameter is required.', example='false'),
  noDataSeverity?: int32(name='noDataSeverity', example='6'),
  policyConfiguration?: PolicyConfiguration(name='policyConfiguration'),
  queryList?: [
    AlertQuery
  ](name='queryList', description='This parameter is required.'),
  sendResolved?: boolean(name='sendResolved', description='This parameter is required.', example='false'),
  severityConfigurations?: [
    SeverityConfiguration
  ](name='severityConfigurations', description='This parameter is required.'),
  sinkAlerthub?: SinkAlerthubConfiguration(name='sinkAlerthub'),
  sinkCms?: SinkCmsConfiguration(name='sinkCms'),
  sinkEventStore?: SinkEventStoreConfiguration(name='sinkEventStore'),
  tags?: [ string ](name='tags'),
  templateConfiguration?: TemplateConfiguration(name='templateConfiguration'),
  threshold?: int32(name='threshold', description='This parameter is required.', example='1'),
  type?: string(name='type', example='default'),
  version?: string(name='version', description='This parameter is required.', example='2.0'),
}

model AlertQuery {
  chartTitle?: string(name='chartTitle', example='chartExmaple'),
  dashboardId?: string(name='dashboardId', example='dashboardExample'),
  end?: string(name='end', description='This parameter is required.', example='now'),
  powerSqlMode?: string(name='powerSqlMode', example='auto'),
  project?: string(name='project', description='This parameter is required.', example='projectExample'),
  query?: string(name='query', description='This parameter is required.', example='* | select *'),
  region?: string(name='region', description='This parameter is required.', example='cn-hangzhou'),
  roleArn?: string(name='roleArn'),
  start?: string(name='start', description='This parameter is required.', example='-5m'),
  store?: string(name='store', description='This parameter is required.', example='store Example'),
  storeType?: string(name='storeType', description='This parameter is required.', example='log'),
  timeSpanType?: string(name='timeSpanType', description='This parameter is required.', example='Relative'),
  ui?: string(name='ui'),
}

model AlertTag {
  key?: string(name='key', example='title'),
  value?: string(name='value', example='example value'),
}

model ConditionConfiguration {
  condition?: string(name='condition', example='cnt > 100'),
  countCondition?: string(name='countCondition', example='__count__ > 5'),
}

model ConsumeProcessor {
  configuration?: ConsumeProcessorConfiguration(name='configuration', description='This parameter is required.'),
  createTime?: long(name='createTime', example='1717171200'),
  description?: string(name='description', example='过滤content字段'),
  displayName?: string(name='displayName', description='This parameter is required.', example='字段过滤处理'),
  processorName?: string(name='processorName', description='This parameter is required.', example='consume-processor-1'),
  updateTime?: long(name='updateTime', example='1717171200'),
}

model ConsumeProcessorConfiguration {
  spl?: string(name='spl', description='This parameter is required.', example='* | project content'),
}

model ConsumerGroup {
  name?: string(name='name', example='test-group'),
  order?: boolean(name='order', example='false'),
  timeout?: int32(name='timeout', example='300'),
}

model CopilotAction {
  action?: string(name='action'),
  description?: string(name='description'),
  name?: string(name='name'),
  parameters?: [ 
    {
      name?: string(name='name'),
      prompt?: string(name='prompt'),
      required?: string(name='required'),
      type?: string(name='type'),
    }
  ](name='parameters'),
  queryTemplate?: string(name='queryTemplate'),
  queryTemplateParameters?: [ 
    {
      name?: string(name='name'),
      prompt?: string(name='prompt'),
      required?: string(name='required'),
      type?: string(name='type'),
    }
  ](name='queryTemplateParameters'),
  scene?: string(name='scene'),
}

model ETL {
  configuration?: ETLConfiguration(name='configuration', description='This parameter is required.'),
  createTime?: long(name='createTime', example='1714274900'),
  description?: string(name='description', example='加工作业'),
  displayName?: string(name='displayName', description='This parameter is required.', example='etljob'),
  lastModifiedTime?: long(name='lastModifiedTime', example='1714274900'),
  name?: string(name='name', description='This parameter is required.', example='etl-20240426'),
  scheduleId?: string(name='scheduleId', example='f0eb655e501a8780808d1970ef6d04c4'),
  status?: string(name='status', example='RUNNING'),
}

model ETLConfiguration {
  accessKeyId?: string(name='accessKeyId', deprecated=true),
  accessKeySecret?: string(name='accessKeySecret', deprecated=true),
  fromTime?: long(name='fromTime', description='This parameter is required.', example='1714274900'),
  lang?: string(name='lang', example='SPL'),
  logstore?: string(name='logstore', description='This parameter is required.', example='test-logstore'),
  parameters?: map[string]any(name='parameters', example='config.vpc.vpc_id.test1：vpc-uf6mskb0b****n9yj'),
  roleArn?: string(name='roleArn', description='This parameter is required.', example='acs:ram::13234:role/logtarget'),
  script?: string(name='script', description='This parameter is required.', example='e_set("key","value")'),
  sinks?: [
    ETLConfigurationSink
  ](name='sinks', description='This parameter is required.'),
  toTime?: long(name='toTime', description='This parameter is required.', example='1714274970'),
}

model ETLConfigurationSink {
  accessKeyId?: string(name='accessKeyId', deprecated=true),
  accessKeySecret?: string(name='accessKeySecret', deprecated=true),
  datasets?: [ string ](name='datasets'),
  endpoint?: string(name='endpoint'),
  logstore?: string(name='logstore', description='This parameter is required.', example='test-logstore'),
  name?: string(name='name', description='This parameter is required.', example='test-etljob'),
  project?: string(name='project', description='This parameter is required.', example='test-project'),
  roleArn?: string(name='roleArn', description='This parameter is required.', example='acs:ram::13234:role/logtarget'),
}

model EncryptConf {
  enable?: boolean(name='enable', description='This parameter is required.'),
  encryptType?: string(name='encrypt_type', example='default'),
  userCmkInfo?: EncryptUserCmkConf(name='user_cmk_info'),
}

model EncryptUserCmkConf {
  arn?: string(name='arn', description='This parameter is required.'),
  cmkKeyId?: string(name='cmk_key_id', description='This parameter is required.'),
  regionId?: string(name='region_id', description='This parameter is required.'),
}

model GroupConfiguration {
  fields?: [ string ](name='fields'),
  type?: string(name='type', description='This parameter is required.', example='custom'),
}

model Histogram {
  count?: long(name='count'),
  from?: int32(name='from'),
  progress?: string(name='progress'),
  to?: int32(name='to'),
}

model IndexJsonKey {
  alias?: string(name='alias', example='myAlias'),
  caseSensitive?: boolean(name='caseSensitive', example='true'),
  chn?: boolean(name='chn', example='true'),
  docValue?: boolean(name='doc_value', example='true'),
  token?: [ string ](name='token'),
  type?: string(name='type', description='This parameter is required.', example='text'),
}

model IndexKey {
  alias?: string(name='alias', example='myAlias'),
  caseSensitive?: boolean(name='caseSensitive', example='true'),
  chn?: boolean(name='chn', example='true'),
  docValue?: boolean(name='doc_value', example='true'),
  indexAll?: boolean(name='index_all', example='true'),
  jsonKeys?: map[string]IndexJsonKey(name='json_keys'),
  maxDepth?: long(name='max_depth'),
  token?: [ string ](name='token'),
  type?: string(name='type', description='This parameter is required.', example='text'),
}

model IngestProcessor {
  configuration?: IngestProcessorConfiguration(name='configuration', description='This parameter is required.'),
  createTime?: long(name='createTime', example='1717171200'),
  description?: string(name='description', example='过滤content字段'),
  displayName?: string(name='displayName', description='This parameter is required.', example='字段过滤处理'),
  processorName?: string(name='processorName', description='This parameter is required.', example='ingest-processor-1'),
  updateTime?: long(name='updateTime', example='1717171200'),
}

model IngestProcessorConfiguration {
  parseFail?: string(name='parseFail', example='keep'),
  spl?: string(name='spl', description='This parameter is required.', example='* | project content'),
}

model JoinConfiguration {
  condition?: string(name='condition', example='$0.id == $1.id'),
  type?: string(name='type', example='left_join'),
}

model LogContent {
  key?: string(name='Key', description='This parameter is required.', example='key-test'),
  value?: string(name='Value', description='This parameter is required.', example='value-test'),
}

model LogGroup {
  logItems?: [
    LogItem
  ](name='LogItems', description='This parameter is required.'),
  logTags?: [
    LogTag
  ](name='LogTags'),
  source?: string(name='Source', example='192.1.1.1'),
  topic?: string(name='Topic', example='topic-test'),
}

model LogGroupList {
  logGroupList?: [
    LogGroup
  ](name='logGroupList', description='This parameter is required.'),
}

model LogItem {
  contents?: [
    LogContent
  ](name='Contents', description='This parameter is required.'),
  time?: int32(name='Time', description='This parameter is required.', example='1690254376'),
}

model LogTag {
  key?: string(name='Key', description='This parameter is required.', example='key-test'),
  value?: string(name='Value', description='This parameter is required.', example='value-test'),
}

model LogtailConfig {
  configName?: string(name='configName', description='This parameter is required.', example='test-config'),
  createTime?: long(name='createTime', example='1655176807'),
  inputDetail?: map[string]any(name='inputDetail', description='This parameter is required.'),
  inputType?: string(name='inputType', description='This parameter is required.', example='file'),
  lastModifyTime?: long(name='lastModifyTime', example='1655176807'),
  logSample?: string(name='logSample', example='2022-06-14 11:13:29.796 | DEBUG    | __main__:<module>:1 - hello world'),
  outputDetail?: {
    endpoint?: string(name='endpoint', description='This parameter is required.', example='cn-hangzhou-intranet.log.aliyuncs.com'),
    logstoreName?: string(name='logstoreName', description='This parameter is required.', example='test-logstore'),
    region?: string(name='region', example='cn-hangzhou'),
    telemetryType?: string(name='telemetryType', example='logs'),
  }(name='outputDetail', description='This parameter is required.'),
  outputType?: string(name='outputType', description='This parameter is required.', example='LogService'),
}

model LogtailPipelineConfig {
  aggregators?: [  map[string]any ](name='aggregators'),
  configName?: string(name='configName', description='This parameter is required.', example='test-config'),
  createTime?: long(name='createTime', example='1655176807'),
  flushers?: [  map[string]any ](name='flushers', description='This parameter is required.'),
  global?: map[string]any(name='global'),
  inputs?: [  map[string]any ](name='inputs', description='This parameter is required.'),
  lastModifyTime?: long(name='lastModifyTime', example='1655176807'),
  logSample?: string(name='logSample', example='127.0.0.1 - - [10/Jun/2022:12:36:49 +0800] "GET /index.html HTTP/1.1" 200'),
  processors?: [  map[string]any ](name='processors'),
}

model MLDataParam {
  annotationdataId?: string(name='annotationdataId', example='dc74b0f569126bb310e1ba6454c351ac'),
  annotations?: map[string]MLDataParamAnnotationsValue(name='annotations'),
  config?: map[string]string(name='config'),
  createTime?: long(name='createTime', example='1695094335'),
  dataHash?: string(name='dataHash', example='59db060bd89468245d76416a68a510ac'),
  datasetId?: string(name='datasetId', example='a9bd488f6dd42d294495fb780858e83d'),
  lastModifyTime?: long(name='lastModifyTime', example='1695094335'),
  predictions?: map[string]MLDataParamPredictionsValue(name='predictions'),
  value?: string(name='value', example='xxx/xxx/xxx/'),
  valueType?: string(name='valueType', example='oss'),
}

model MLDataSetParam {
  createBy?: string(name='createBy', example='sls-console'),
  createTime?: long(name='createTime', example='1695090077'),
  dataType?: string(name='dataType', example='Metric'),
  datasetId?: string(name='datasetId', example='d9bd488f6dd42d294495fb780858e83d'),
  description?: string(name='description', example='数据集A'),
  labelId?: string(name='labelId', example='a191ae4ca615b0ccb93c211fc8a998af'),
  lastModifyTime?: long(name='lastModifyTime', example='1695090077'),
  name?: string(name='name', example='sls_builtin_dataset_metric.shapeclassification.anomalydetection'),
  settingType?: string(name='settingType', example='Metric.ShapeClassification.AnomalyDetection'),
}

model MLLabelParam {
  createTime?: long(name='createTime', example='1695090077'),
  description?: string(name='description', example='默认表'),
  labelId?: string(name='labelId', example='abbd488f6dd42d294495fb780858e83d'),
  lastModifyTime?: long(name='lastModifyTime', example='1695090077'),
  name?: string(name='name', example='标签表'),
  settings?: [ 
    {
      config?: string(name='config', example='""'),
      mode?: string(name='mode', example='builtin'),
      type?: string(name='type', example='Trace.RCA'),
      version?: string(name='version', example='0.01'),
    }
  ](name='settings'),
  type?: string(name='type', example='xxx'),
}

model MLServiceAnalysisParam {
  input?: [ map[string]string ](name='input'),
  parameter?: map[string]string(name='parameter'),
}

model MLServiceParam {
  description?: string(name='description', example='某某服务'),
  model?: {
    modelResourceId?: string(name='modelResourceId', example='xxxx'),
    modelResourceType?: string(name='modelResourceType', example='xxx_type'),
  }(name='model'),
  name?: string(name='name', example='service_name'),
  resource?: {
    cpuLimit?: int32(name='cpuLimit', example='2'),
    gpu?: int32(name='gpu', example='20'),
    memoryLimit?: int32(name='memoryLimit', example='64'),
    replica?: int32(name='replica', example='2'),
  }(name='resource'),
  serviceType?: string(name='serviceType', example='sls_builtin'),
  status?: string(name='status', example='running'),
  updateTimestamp?: long(name='updateTimestamp', example='1695090077'),
}

model MaxComputeExport {
  configuration?: MaxComputeExportConfiguration(name='configuration', description='This parameter is required.'),
  createTime?: long(name='createTime', example='1714284115'),
  description?: string(name='description', example='odpsexport-demo'),
  displayName?: string(name='displayName', description='This parameter is required.', example='odpsexport-test'),
  lastModifiedTime?: long(name='lastModifiedTime', example='1714284589'),
  name?: string(name='name', description='This parameter is required.', example='export-general-1714033191-584993-hcl'),
  scheduleId?: string(name='scheduleId', example='c7f01719d9feb105fc9d8df92af62010'),
  status?: string(name='status', example='RUNNING'),
}

model MaxComputeExportConfiguration {
  fromTime?: long(name='fromTime', description='This parameter is required.', example='1'),
  logstore?: string(name='logstore', description='This parameter is required.', example='sls-logstore-demo'),
  roleArn?: string(name='roleArn', description='This parameter is required.', example='acs:ram::123456789:role/aliyunlogdefaultrole'),
  sink?: MaxComputeExportConfigurationSink(name='sink', description='This parameter is required.'),
  toTime?: long(name='toTime', description='This parameter is required.', example='0'),
}

model MaxComputeExportConfigurationSink {
  bufferInterval?: string(name='bufferInterval', example='1800'),
  fields?: [ string ](name='fields', description='This parameter is required.'),
  filterInvalid?: boolean(name='filterInvalid', example='true'),
  odpsAccessKeyId?: string(name='odpsAccessKeyId', example='asdfghjk', deprecated=true),
  odpsAccessSecret?: string(name='odpsAccessSecret', example='esasdfghjkl', deprecated=true),
  odpsEndpoint?: string(name='odpsEndpoint', description='This parameter is required.', example='http://service.cn-hangzhou.maxcompute.aliyun-inc.com/api'),
  odpsProject?: string(name='odpsProject', description='This parameter is required.', example='demo_project'),
  odpsRolearn?: string(name='odpsRolearn', description='This parameter is required.', example='acs:ram::123456789:role/aliyunlogdefaultrole'),
  odpsTable?: string(name='odpsTable', description='This parameter is required.', example='demo_table'),
  odpsTunnelEndpoint?: string(name='odpsTunnelEndpoint', example='http://dt.cn-hangzhou.maxcompute.aliyun-inc.com'),
  partitionColumn?: [ string ](name='partitionColumn', description='This parameter is required.'),
  partitionTimeFormat?: string(name='partitionTimeFormat', description='This parameter is required.', example='%Y_%m_%d'),
  timeFormatType?: string(name='timeFormatType', example='StrfTimeFormat'),
  timeZone?: string(name='timeZone', description='This parameter is required.', example='+0800'),
}

model OSSExport {
  configuration?: OSSExportConfiguration(name='configuration'),
  createTime?: long(name='createTime', example='1714284025'),
  description?: string(name='description', example='job-test'),
  displayName?: string(name='displayName', description='This parameter is required.', example='job-demo'),
  lastModifiedTime?: long(name='lastModifiedTime', example='1714284115'),
  name?: string(name='name', description='This parameter is required.', example='job-1714109458-123456'),
  scheduleId?: string(name='scheduleId', example='c7f01719d9feb105fc9d8df92af62010'),
  status?: string(name='status', example='RUNNING'),
}

model OSSExportConfiguration {
  fromTime?: long(name='fromTime', example='1714123644'),
  logstore?: string(name='logstore', example='logstore-demo'),
  roleArn?: string(name='roleArn', example='acs:ram::123456789:role/aliyunlogdefaultrole'),
  sink?: {
    bucket?: string(name='bucket', description='This parameter is required.', example='test-bucket'),
    bufferInterval?: long(name='bufferInterval', example='300'),
    bufferSize?: long(name='bufferSize', example='256'),
    compressionType?: string(name='compressionType', example='snappy'),
    contentDetail?: map[string]any(name='contentDetail'),
    contentType?: string(name='contentType', example='json'),
    delaySec?: long(name='delaySec', example='900', deprecated=true),
    delaySeconds?: long(name='delaySeconds', example='900'),
    endpoint?: string(name='endpoint', description='This parameter is required.', example='http://oss-cn-hangzhou-internal.aliyuncs.com'),
    pathFormat?: string(name='pathFormat', description='This parameter is required.', example='%Y/%m/%d/%H/%M'),
    pathFormatType?: string(name='pathFormatType', description='This parameter is required.', example='time'),
    prefix?: string(name='prefix', example='demo/'),
    roleArn?: string(name='roleArn', description='This parameter is required.', example='acs:ram::123456789:role/aliyunlogdefaultrole'),
    suffix?: string(name='suffix', example='.json'),
    timeZone?: string(name='timeZone', example='+0800'),
  }(name='sink'),
  toTime?: long(name='toTime', example='1714357112'),
}

model OSSIngestion {
  configuration?: OSSIngestionConfiguration(name='configuration', description='This parameter is required.'),
  createTime?: long(name='createTime', example='1714360481'),
  description?: string(name='description', example='oss ingestion'),
  displayName?: string(name='displayName', description='This parameter is required.', example='oss ingestion'),
  lastModifiedTime?: long(name='lastModifiedTime', example='1714360481'),
  name?: string(name='name', description='This parameter is required.', example='ingest-oss-123456'),
  schedule?: Schedule(name='schedule', description='This parameter is required.'),
  scheduleId?: string(name='scheduleId', example='c7f01719d9feb105fc9d8df92af62010'),
  status?: string(name='status', example='RUNNING'),
}

model OSSIngestionConfiguration {
  logstore?: string(name='logstore', description='This parameter is required.', example='myLogstore'),
  source?: OSSIngestionConfigurationSource(name='source', description='This parameter is required.'),
}

model OSSIngestionConfigurationSource {
  bucket?: string(name='bucket', description='This parameter is required.', example='ossbucket'),
  compressionCodec?: string(name='compressionCodec', description='This parameter is required.', example='none'),
  encoding?: string(name='encoding', description='This parameter is required.', example='UTF-8'),
  endTime?: long(name='endTime', example='1714360481'),
  endpoint?: string(name='endpoint', description='This parameter is required.', example='oss-cn-hangzhou.aliyuncs.com'),
  format?: map[string]any(name='format', description='This parameter is required.'),
  interval?: string(name='interval', description='This parameter is required.', example='never'),
  pattern?: string(name='pattern', example='.*'),
  prefix?: string(name='prefix', example='prefix'),
  restoreObjectEnabled?: boolean(name='restoreObjectEnabled', example='true'),
  roleARN?: string(name='roleARN', example='acs:ram::12345:role/aliyunlogdefaultrole'),
  startTime?: long(name='startTime', example='1714274081'),
  timeField?: string(name='timeField', example='__time__'),
  timeFormat?: string(name='timeFormat', example='yyyy-MM-dd HH:mm:ss'),
  timePattern?: string(name='timePattern', example='[0-9]{0,2}\\/[0-9a-zA-Z]+\\/[0-9:,]+'),
  timeZone?: string(name='timeZone', example='GMT+08:00'),
  useMetaIndex?: boolean(name='useMetaIndex', description='This parameter is required.', example='false'),
}

model PolicyConfiguration {
  actionPolicyId?: string(name='actionPolicyId', example='example_action_policy'),
  alertPolicyId?: string(name='alertPolicyId', example='sls.builtin.dynamic'),
  repeatInterval?: string(name='repeatInterval', example='10m'),
}

model ProcessorAssociate {
  processorId?: string(name='processorId', description='This parameter is required.', example='ingest-processor-1'),
}

model ProjectSummary {
  createTime?: long(name='createTime', description='This parameter is required.'),
  description?: string(name='description', description='This parameter is required.'),
  projectName?: string(name='projectName', description='This parameter is required.'),
  region?: string(name='region', description='This parameter is required.'),
  resourceGroupId?: string(name='resourceGroupId', description='This parameter is required.'),
  updateTime?: long(name='updateTime', description='This parameter is required.'),
}

model S3Ingestion {
  configuration?: S3IngestionConfigurationSource(name='configuration', description='This parameter is required.'),
  createTime?: long(name='createTime', example='1714360481'),
  description?: string(name='description', example='s3 ingestion'),
  displayName?: string(name='displayName', description='This parameter is required.', example='s3 ingestion'),
  lastModifiedTime?: long(name='lastModifiedTime', example='1714360481'),
  name?: string(name='name', description='This parameter is required.', example='ingest-s3-123456'),
  schedule?: Schedule(name='schedule', description='This parameter is required.'),
  scheduleId?: string(name='scheduleId', example='c7f01719d9feb105fc9d8df92af62010'),
  status?: string(name='status', example='RUNNING'),
}

model S3IngestionConfiguration {
  logstore?: string(name='logstore', example='myLogstore'),
  source?: S3IngestionConfigurationSource(name='source'),
}

model S3IngestionConfigurationSource {
  awsAccessKey?: string(name='awsAccessKey', description='This parameter is required.', example='AKIxxxxxxxxxxYJE'),
  awsAccessKeySecret?: string(name='awsAccessKeySecret', description='This parameter is required.', example='123xxxxxxxxxxfjf'),
  awsRegion?: string(name='awsRegion', description='This parameter is required.', example='ap-northeast-1'),
  awsSQSQueueUrl?: string(name='awsSQSQueueUrl', example='https://sqs.ap-northeast-1.amazonaws.com/123456788/chifan'),
  awsUseSQS?: boolean(name='awsUseSQS', example='false'),
  bucket?: string(name='bucket', description='This parameter is required.', example='s3bucket'),
  compressionCodec?: string(name='compressionCodec', description='This parameter is required.', example='none'),
  encoding?: string(name='encoding', description='This parameter is required.', example='UTF-8'),
  endTime?: long(name='endTime', example='1714360481'),
  format?: map[string]any(name='format', description='This parameter is required.'),
  interval?: string(name='interval', description='This parameter is required.', example='30m'),
  pattern?: string(name='pattern', example='.*'),
  prefix?: string(name='prefix', example='prefix'),
  startTime?: long(name='startTime', example='1714274081'),
  tagPackId?: boolean(name='tagPackId', example='false'),
  timeField?: string(name='timeField', example='__time__'),
  timeFormat?: string(name='timeFormat', example='yyyy-MM-dd HH:mm:ss'),
  timePattern?: string(name='timePattern', example='[0-9]{0,2}\\/[0-9a-zA-Z]+\\/[0-9:,]+'),
  timeZone?: string(name='timeZone', example='GMT+08:00'),
  useAwsSQSOnly?: boolean(name='useAwsSQSOnly', example='false'),
}

model SavedSearch {
  displayName?: string(name='displayName', description='This parameter is required.'),
  logstore?: string(name='logstore', description='This parameter is required.'),
  savedsearchName?: string(name='savedsearchName', description='This parameter is required.'),
  searchQuery?: string(name='searchQuery', description='This parameter is required.'),
  topic?: string(name='topic'),
}

model Schedule {
  cronExpression?: string(name='cronExpression', example='0/5 * * * *'),
  delay?: int32(name='delay', example='4'),
  interval?: string(name='interval', example='60s'),
  runImmediately?: boolean(name='runImmediately', example='false'),
  timeZone?: string(name='timeZone', example='+0800'),
  type?: string(name='type', description='This parameter is required.', example='FixedRate'),
}

model ScheduledSQL {
  configuration?: ScheduledSQLConfiguration(name='configuration', description='This parameter is required.'),
  createTime?: long(name='createTime', example='1714123644'),
  description?: string(name='description', example='schedule-sql-test'),
  displayName?: string(name='displayName', description='This parameter is required.', example='scheduleSqlTest'),
  lastModifiedTime?: long(name='lastModifiedTime', example='1714123644'),
  name?: string(name='name', description='This parameter is required.', example='sql-1714123463-225223'),
  schedule?: Schedule(name='schedule', description='This parameter is required.'),
  scheduleId?: string(name='scheduleId', example='e73f43732852064ad5d091914e39342f'),
  status?: string(name='status', example='ENABLED'),
}

model ScheduledSQLConfiguration {
  dataFormat?: string(name='dataFormat', description='This parameter is required.', example='log2log'),
  destEndpoint?: string(name='destEndpoint', description='This parameter is required.', example='cn-hangzhou-intranet.log.aliyuncs.com'),
  destLogstore?: string(name='destLogstore', description='This parameter is required.', example='dest-logstore-demo'),
  destProject?: string(name='destProject', description='This parameter is required.', example='project-demo'),
  destRoleArn?: string(name='destRoleArn', description='This parameter is required.', example='acs:ram::123456789:role/aliyunlogetlrole'),
  fromTime?: long(name='fromTime', description='This parameter is required.', example='1712592000'),
  fromTimeExpr?: string(name='fromTimeExpr', description='This parameter is required.', example='@m-1m'),
  maxRetries?: long(name='maxRetries', description='This parameter is required.', example='20'),
  maxRunTimeInSeconds?: long(name='maxRunTimeInSeconds', description='This parameter is required.', example='600'),
  parameters?: map[string]any(name='parameters', description='This parameter is required.'),
  resourcePool?: string(name='resourcePool', description='This parameter is required.', example='enhanced'),
  roleArn?: string(name='roleArn', description='This parameter is required.', example='acs:ram::123456789:role/aliyunlogetlrole'),
  script?: string(name='script', description='This parameter is required.', example='* | select *'),
  sourceLogstore?: string(name='sourceLogstore', description='This parameter is required.', example='source-logstore-demo'),
  sqlType?: string(name='sqlType', description='This parameter is required.', example='searchQuery'),
  toTime?: long(name='toTime', description='This parameter is required.', example='0'),
  toTimeExpr?: string(name='toTimeExpr', description='This parameter is required.', example='@m'),
}

model SeverityConfiguration {
  evalCondition?: ConditionConfiguration(name='evalCondition'),
  severity?: int32(name='severity', example='8'),
}

model SinkAlerthubConfiguration {
  enabled?: boolean(name='enabled', example='true'),
}

model SinkCmsConfiguration {
  enabled?: boolean(name='enabled', example='true'),
}

model SinkEventStoreConfiguration {
  enabled?: boolean(name='enabled', example='true'),
  endpoint?: string(name='endpoint', example='cn-shanghai-intranet.log.aliyuncs.com'),
  eventStore?: string(name='eventStore', example='exampleStore'),
  project?: string(name='project', example='exampleProject'),
  roleArn?: string(name='roleArn', example='acs:ram::123456789:role/aliyunlogetlrole'),
}

model StoreViewStore {
  project?: string(name='project', description='This parameter is required.'),
  query?: string(name='query'),
  storeName?: string(name='storeName', description='This parameter is required.'),
}

model TemplateConfiguration {
  aonotations?: map[string]any(name='aonotations'),
  id?: string(name='id', description='This parameter is required.', example='sls.app.ack.ip.not_enough'),
  lang?: string(name='lang', example='cn'),
  tokens?: map[string]any(name='tokens'),
  type?: string(name='type', description='This parameter is required.', example='sys'),
  version?: string(name='version', example='1'),
}

model Ticket {
  callerUid?: long(name='callerUid', example='1000000000'),
  createDate?: string(name='createDate', example='2023-09-06 14:57:07'),
  expirationTime?: long(name='expirationTime', example='100'),
  expireDate?: string(name='expireDate', example='2023-09-06 14:58:07'),
  extra?: string(name='extra', example='{"xx":"yy"}'),
  name?: string(name='name', example='测试'),
  number?: int32(name='number', example='1'),
  sharingTo?: string(name='sharingTo', example='{"type":"aliyun","ids":[1,2]}'),
  ticket?: string(name='ticket', example='xxxxx'),
  ticketId?: string(name='ticketId', example='xxxxx'),
  usedNumber?: int32(name='usedNumber', example='1'),
  valid?: boolean(name='valid', example='false'),
}

model Chart {
  action?: map[string]any(name='action', description='This parameter is required.'),
  display?: map[string]any(name='display', description='This parameter is required.'),
  search?: map[string]any(name='search', description='This parameter is required.'),
  title?: string(name='title', description='This parameter is required.', example='my-chart'),
  type?: string(name='type', description='This parameter is required.', example='linepro'),
}

model Dashboard {
  attribute?: map[string]string(name='attribute'),
  charts?: [
    Chart
  ](name='charts', description='This parameter is required.'),
  dashboardName?: string(name='dashboardName', description='This parameter is required.', example='dashboard-1609294922657-434834'),
  description?: string(name='description', example='这是一个仪表盘。'),
  displayName?: string(name='displayName', description='This parameter is required.', example='test-alert'),
}

model ExternalStore {
  externalStoreName?: string(name='externalStoreName', description='This parameter is required.', example='rds_store'),
  parameter?: map[string]any(name='parameter', description='This parameter is required.'),
  storeType?: string(name='storeType', description='This parameter is required.', example='rds-vpc'),
}

model Index {
  keys?: map[string]IndexKey(name='keys'),
  line?: {
    caseSensitive?: boolean(name='caseSensitive', example='true'),
    chn?: boolean(name='chn', example='true'),
    excludeKeys?: [ string ](name='exclude_keys'),
    includeKeys?: [ string ](name='include_keys'),
    token?: [ string ](name='token', description='This parameter is required.'),
  }(name='line'),
  logReduce?: boolean(name='log_reduce', example='true'),
  logReduceBlackList?: [ string ](name='log_reduce_black_list'),
  logReduceWhiteList?: [ string ](name='log_reduce_white_list'),
  maxTextLen?: int32(name='max_text_len', example='2048'),
}

model Logging {
  loggingDetails?: [ 
    {
      logstore?: string(name='logstore', description='This parameter is required.', example='my-logstore'),
      type?: string(name='type', description='This parameter is required.', example='consumergroup_log'),
    }
  ](name='loggingDetails', description='This parameter is required.'),
  loggingProject?: string(name='loggingProject', description='This parameter is required.', example='my-project'),
}

model Logstore {
  appendMeta?: boolean(name='appendMeta', example='true'),
  autoSplit?: boolean(name='autoSplit', example='true'),
  createTime?: int32(name='createTime'),
  enableTracking?: boolean(name='enable_tracking', example='false'),
  encryptConf?: EncryptConf(name='encrypt_conf'),
  hotTtl?: int32(name='hot_ttl'),
  infrequentAccessTTL?: int32(name='infrequentAccessTTL', example='30'),
  lastModifyTime?: int32(name='lastModifyTime'),
  logstoreName?: string(name='logstoreName', description='This parameter is required.', example='my-logstore'),
  maxSplitShard?: int32(name='maxSplitShard', example='2'),
  mode?: string(name='mode', example='standard'),
  processorId?: string(name='processorId'),
  productType?: string(name='productType'),
  shardCount?: int32(name='shardCount', description='This parameter is required.', example='2'),
  telemetryType?: string(name='telemetryType'),
  ttl?: int32(name='ttl', description='This parameter is required.', example='30'),
}

model Machine {
  hostId?: string(name='host-id', example='test'),
  ip?: string(name='ip', example='192.168.x.x'),
  lastHeartbeatTime?: long(name='lastHeartbeatTime', example='1657509674'),
  machineUniqueid?: string(name='machine-uniqueid', example='3B70F4F1-80F7-46C4-A6C1-100D66C***47'),
  userdefinedId?: string(name='userdefined-id', example='test'),
}

model MachineGroup {
  groupAttribute?: {
    externalName?: string(name='externalName', example='test-group'),
    groupTopic?: string(name='groupTopic', example='test-topic'),
  }(name='groupAttribute'),
  groupName?: string(name='groupName', description='This parameter is required.', example='test-group'),
  groupType?: string(name='groupType'),
  machineIdentifyType?: string(name='machineIdentifyType', description='This parameter is required.', example='ip'),
  machineList?: [ string ](name='machineList', description='This parameter is required.'),
}

model Project {
  createTime?: string(name='createTime'),
  dataRedundancyType?: string(name='dataRedundancyType', example='LRS'),
  description?: string(name='description', description='This parameter is required.'),
  lastModifyTime?: string(name='lastModifyTime'),
  location?: string(name='location'),
  owner?: string(name='owner'),
  projectName?: string(name='projectName', description='This parameter is required.'),
  quota?: map[string]any(name='quota'),
  recycleBinEnabled?: boolean(name='recycleBinEnabled', example='false'),
  region?: string(name='region'),
  resourceGroupId?: string(name='resourceGroupId'),
  status?: string(name='status'),
}

model ServiceStatus {
  enabled?: boolean(name='enabled', example='false'),
  status?: string(name='status', example='NotExist'),
}

model Shard {
  createTime?: int32(name='createTime', example='1453949705'),
  exclusiveEndKey?: string(name='exclusiveEndKey', example='8000000000000000000000000000000'),
  inclusiveBeginKey?: string(name='inclusiveBeginKey', example='00000000000000000000000000000000'),
  shardID?: int32(name='shardID', example='0'),
  status?: string(name='status', example='readwrite'),
}

model MLDataParamAnnotationsValue = {
  annotatedBy?: string(name='annotatedBy', example='xxxx'),
  updateTime?: long(name='updateTime', example='1694761550'),
  results?: [ map[string]string ](name='results'),
}

model MLDataParamPredictionsValue = {
  annotatedBy?: string(name='annotatedBy', example='xxx'),
  updateTime?: long(name='updateTime', example='1694761550'),
  results?: [ map[string]string ](name='results'),
}

model ApplyConfigToMachineGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Applies a Logtail configuration to a machine group.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ApplyConfigToMachineGroupResponse
 */
async function applyConfigToMachineGroupWithOptions(project: string, machineGroup: string, configName: string, headers: map[string]string, runtime: Util.RuntimeOptions): ApplyConfigToMachineGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ApplyConfigToMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}/configs/${configName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Applies a Logtail configuration to a machine group.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @return ApplyConfigToMachineGroupResponse
 */
async function applyConfigToMachineGroup(project: string, machineGroup: string, configName: string): ApplyConfigToMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return applyConfigToMachineGroupWithOptions(project, machineGroup, configName, headers, runtime);
}

model CallAiToolsRequest {
  params?: map[string]string(name='params'),
  regionId?: string(name='regionId'),
  toolName?: string(name='toolName', description='This parameter is required.'),
}

model CallAiToolsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: string(name='body'),
}

/**
 * @summary 调用 ai 工具
 *
 * @param request CallAiToolsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CallAiToolsResponse
 */
async function callAiToolsWithOptions(request: CallAiToolsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CallAiToolsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.params)) {
    body['params'] = request.params;
  }
  if (!Util.isUnset(request.regionId)) {
    body['regionId'] = request.regionId;
  }
  if (!Util.isUnset(request.toolName)) {
    body['toolName'] = request.toolName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CallAiTools',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/tool/call`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'string',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 调用 ai 工具
 *
 * @param request CallAiToolsRequest
 * @return CallAiToolsResponse
 */
async function callAiTools(request: CallAiToolsRequest): CallAiToolsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return callAiToolsWithOptions(request, headers, runtime);
}

model ChangeResourceGroupRequest {
  resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group.

This parameter is required.', example='rg-aek2i7nhaxifxey'),
  resourceId?: string(name='resourceId', description='The ID of the resource.

This parameter is required.', example='ali-test-project'),
  resourceType?: string(name='resourceType', description='The type of the resource. Only PROJECT is supported. Set the value to PROJECT.', example='PROJECT'),
}

model ChangeResourceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Changes the resource group to which a resource belongs.
 *
 * @param request ChangeResourceGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeResourceGroupResponse
 */
async function changeResourceGroupWithOptions(project: string, request: ChangeResourceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ChangeResourceGroupResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceId)) {
    body['resourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['resourceType'] = request.resourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ChangeResourceGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/resourcegroup`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Changes the resource group to which a resource belongs.
 *
 * @param request ChangeResourceGroupRequest
 * @return ChangeResourceGroupResponse
 */
async function changeResourceGroup(project: string, request: ChangeResourceGroupRequest): ChangeResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return changeResourceGroupWithOptions(project, request, headers, runtime);
}

model ConsumerGroupHeartBeatRequest {
  body?: [ int32 ](name='body', description='The IDs of shards whose data is being consumed.

This parameter is required.'),
  consumer?: string(name='consumer', description='The consumer.

This parameter is required.', example='consumer_1'),
}

model ConsumerGroupHeartBeatResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [ int32 ](name='body'),
}

/**
 * @summary Sends heartbeats to a server from a consumer.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * Connections between consumers and Simple Log Service are established by sending heartbeat messages at regular intervals. If Simple Log Service does not receive heartbeat messages from a consumer on schedule, Simple Log Service deletes the consumer.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 * * The name of the consumer group is obtained. For more information, see [ListConsumerGroup](https://help.aliyun.com/document_detail/74964.html).
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:ConsumerGroupHeartBeat`|`acs:log:${regionId}:${accountId}:project/{#ProjectName}/logstore/{#LogstoreName}/consumergroup/{#ConsumerGroupName}`|
 *
 * @param request ConsumerGroupHeartBeatRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConsumerGroupHeartBeatResponse
 */
async function consumerGroupHeartBeatWithOptions(project: string, logstore: string, consumerGroup: string, request: ConsumerGroupHeartBeatRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ConsumerGroupHeartBeatResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.consumer)) {
    query['consumer'] = request.consumer;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ConsumerGroupHeartBeat',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups/${consumerGroup}?type=heartbeat`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Sends heartbeats to a server from a consumer.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * Connections between consumers and Simple Log Service are established by sending heartbeat messages at regular intervals. If Simple Log Service does not receive heartbeat messages from a consumer on schedule, Simple Log Service deletes the consumer.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 * * The name of the consumer group is obtained. For more information, see [ListConsumerGroup](https://help.aliyun.com/document_detail/74964.html).
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:ConsumerGroupHeartBeat`|`acs:log:${regionId}:${accountId}:project/{#ProjectName}/logstore/{#LogstoreName}/consumergroup/{#ConsumerGroupName}`|
 *
 * @param request ConsumerGroupHeartBeatRequest
 * @return ConsumerGroupHeartBeatResponse
 */
async function consumerGroupHeartBeat(project: string, logstore: string, consumerGroup: string, request: ConsumerGroupHeartBeatRequest): ConsumerGroupHeartBeatResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return consumerGroupHeartBeatWithOptions(project, logstore, consumerGroup, request, headers, runtime);
}

model ConsumerGroupUpdateCheckPointRequest {
  checkpoint?: string(name='checkpoint', description='The value of the checkpoint.

This parameter is required.', example='MTUyNDE1NTM3OTM3MzkwODQ5Ng=='),
  shard?: int32(name='shard', description='The ID of the shard.

This parameter is required.', example='0'),
  consumer?: string(name='consumer', description='The consumer.

This parameter is required.', example='consumer_1'),
  forceSuccess?: boolean(name='forceSuccess', description='Specifies whether to enable forceful updates. Valid values:

*   true
*   false', example='False'),
}

model ConsumerGroupUpdateCheckPointResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates the checkpoint of a shard for a consumer group.
 *
 * @description *   If you do not specify a consumer, you must set **forceSuccess** to **true**. Otherwise, the checkpoint cannot be updated.
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 *
 * @param request ConsumerGroupUpdateCheckPointRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConsumerGroupUpdateCheckPointResponse
 */
async function consumerGroupUpdateCheckPointWithOptions(project: string, logstore: string, consumerGroup: string, request: ConsumerGroupUpdateCheckPointRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ConsumerGroupUpdateCheckPointResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.consumer)) {
    query['consumer'] = request.consumer;
  }
  if (!Util.isUnset(request.forceSuccess)) {
    query['forceSuccess'] = request.forceSuccess;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.checkpoint)) {
    body['checkpoint'] = request.checkpoint;
  }
  if (!Util.isUnset(request.shard)) {
    body['shard'] = request.shard;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ConsumerGroupUpdateCheckPoint',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups/${consumerGroup}?type=checkpoint`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates the checkpoint of a shard for a consumer group.
 *
 * @description *   If you do not specify a consumer, you must set **forceSuccess** to **true**. Otherwise, the checkpoint cannot be updated.
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 *
 * @param request ConsumerGroupUpdateCheckPointRequest
 * @return ConsumerGroupUpdateCheckPointResponse
 */
async function consumerGroupUpdateCheckPoint(project: string, logstore: string, consumerGroup: string, request: ConsumerGroupUpdateCheckPointRequest): ConsumerGroupUpdateCheckPointResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return consumerGroupUpdateCheckPointWithOptions(project, logstore, consumerGroup, request, headers, runtime);
}

model CreateAgentInstanceConfigRequest {
  config?: string(name='config', description='This parameter is required.'),
  configMatcher?: string(name='configMatcher', description='This parameter is required.'),
  configName?: string(name='configName', description='This parameter is required.'),
  isGray?: boolean(name='isGray'),
}

model CreateAgentInstanceConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary CreateAgentInstanceConfig
 *
 * @param request CreateAgentInstanceConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAgentInstanceConfigResponse
 */
async function createAgentInstanceConfigWithOptions(request: CreateAgentInstanceConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAgentInstanceConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.config)) {
    body['config'] = request.config;
  }
  if (!Util.isUnset(request.configMatcher)) {
    body['configMatcher'] = request.configMatcher;
  }
  if (!Util.isUnset(request.configName)) {
    body['configName'] = request.configName;
  }
  if (!Util.isUnset(request.isGray)) {
    body['isGray'] = request.isGray;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAgentInstanceConfig',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/agentinstanceconfigs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary CreateAgentInstanceConfig
 *
 * @param request CreateAgentInstanceConfigRequest
 * @return CreateAgentInstanceConfigResponse
 */
async function createAgentInstanceConfig(request: CreateAgentInstanceConfigRequest): CreateAgentInstanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAgentInstanceConfigWithOptions(request, headers, runtime);
}

model CreateAlertRequest {
  configuration?: AlertConfiguration(name='configuration', description='The detailed configurations of the alert rule.

This parameter is required.'),
  description?: string(name='description', description='The description of the alert rule.', example='An alert rule'),
  displayName?: string(name='displayName', description='The display name of the alert rule.

This parameter is required.', example='test-alert'),
  name?: string(name='name', description='The name of the alert rule. Make sure that the name is unique in a project.

This parameter is required.', example='alert-123456'),
  schedule?: Schedule(name='schedule', description='The scheduling configurations of the alert rule.

This parameter is required.'),
}

model CreateAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary CreateAlert
 *
 * @param request CreateAlertRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAlertResponse
 */
async function createAlertWithOptions(project: string, request: CreateAlertRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAlertResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.schedule)) {
    body['schedule'] = request.schedule;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAlert',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/alerts`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary CreateAlert
 *
 * @param request CreateAlertRequest
 * @return CreateAlertResponse
 */
async function createAlert(project: string, request: CreateAlertRequest): CreateAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAlertWithOptions(project, request, headers, runtime);
}

model CreateAnnotationDataSetRequest {
  body?: MLDataSetParam(name='body', description='The data structure of the request.'),
  datasetId?: string(name='datasetId', description='The unique identifier of the dataset.', example='cb8cc4eb51a85e823471cdb368fae9be'),
}

model CreateAnnotationDataSetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates a dataset.
 *
 * @param request CreateAnnotationDataSetRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAnnotationDataSetResponse
 */
async function createAnnotationDataSetWithOptions(request: CreateAnnotationDataSetRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAnnotationDataSetResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.datasetId)) {
    query['datasetId'] = request.datasetId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAnnotationDataSet',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationdataset`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates a dataset.
 *
 * @param request CreateAnnotationDataSetRequest
 * @return CreateAnnotationDataSetResponse
 */
async function createAnnotationDataSet(request: CreateAnnotationDataSetRequest): CreateAnnotationDataSetResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAnnotationDataSetWithOptions(request, headers, runtime);
}

model CreateAnnotationLabelRequest {
  body?: MLLabelParam(name='body', description='The data structure of the request.'),
}

model CreateAnnotationLabelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates a tag table.
 *
 * @param request CreateAnnotationLabelRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAnnotationLabelResponse
 */
async function createAnnotationLabelWithOptions(request: CreateAnnotationLabelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAnnotationLabelResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAnnotationLabel',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationlabel`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates a tag table.
 *
 * @param request CreateAnnotationLabelRequest
 * @return CreateAnnotationLabelResponse
 */
async function createAnnotationLabel(request: CreateAnnotationLabelRequest): CreateAnnotationLabelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAnnotationLabelWithOptions(request, headers, runtime);
}

model CreateConfigRequest {
  body?: LogtailConfig(name='body', description='The body of the request.'),
}

model CreateConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates a Logtail configuration.
 *
 * @description ### [](#)Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 * *   You can create up to 100 Logtail configurations in a project.
 * *   The Logtail configuration is planned out. For more information, see [Logtail configurations](https://help.aliyun.com/document_detail/29058.html).
 *
 * @param request CreateConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateConfigResponse
 */
async function createConfigWithOptions(project: string, request: CreateConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateConfigResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateConfig',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/configs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates a Logtail configuration.
 *
 * @description ### [](#)Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 * *   You can create up to 100 Logtail configurations in a project.
 * *   The Logtail configuration is planned out. For more information, see [Logtail configurations](https://help.aliyun.com/document_detail/29058.html).
 *
 * @param request CreateConfigRequest
 * @return CreateConfigResponse
 */
async function createConfig(project: string, request: CreateConfigRequest): CreateConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createConfigWithOptions(project, request, headers, runtime);
}

model CreateConsumerGroupRequest {
  consumerGroup?: string(name='consumerGroup', description='The name of the consumer group. The name must be unique in a project.

This parameter is required.', example='consumerGroupX'),
  order?: boolean(name='order', description='Specifies whether to consume data in sequence. Valid values:

*   true

    *   In a shard, data is consumed in ascending order based on the value of the \\\\*\\\\*__tag__:__receive_time__\\\\*\\\\* field.
    *   If a shard is split, data in the original shard is consumed first. Then, data in the new shards is consumed at the same time.
    *   If shards are merged, data in the original shards is consumed first. Then, data in the new shard is consumed.

*   false Data in all shards is consumed at the same time. If a new shard is generated after a shard is split or after shards are merged, data in the new shard is immediately consumed.

This parameter is required.', example='true'),
  timeout?: int32(name='timeout', description='The timeout period. If the server does not receive heartbeats from a consumer within the timeout period, the server deletes the consumer. Unit: seconds.

This parameter is required.', example='300'),
}

model CreateConsumerGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates a consumer group for a Logstore.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * You can create up to 30 consumer groups for a Logstore. The name of a consumer group must be unique in a project.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 * * Simple Log Service provides examples of both regular log consumption and consumer group-based log consumption by using Simple Log Service SDK for Java. For more information, see [Consume log data](https://help.aliyun.com/document_detail/120035.html) and [Use consumer groups to consume data](https://help.aliyun.com/document_detail/28998.html).
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:CreateConsumerGroup`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#logstoreName}/consumergroup/{#ConsumerGroup}`|
 *
 * @param request CreateConsumerGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateConsumerGroupResponse
 */
async function createConsumerGroupWithOptions(project: string, logstore: string, request: CreateConsumerGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateConsumerGroupResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.consumerGroup)) {
    body['consumerGroup'] = request.consumerGroup;
  }
  if (!Util.isUnset(request.order)) {
    body['order'] = request.order;
  }
  if (!Util.isUnset(request.timeout)) {
    body['timeout'] = request.timeout;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateConsumerGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates a consumer group for a Logstore.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * You can create up to 30 consumer groups for a Logstore. The name of a consumer group must be unique in a project.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 * * Simple Log Service provides examples of both regular log consumption and consumer group-based log consumption by using Simple Log Service SDK for Java. For more information, see [Consume log data](https://help.aliyun.com/document_detail/120035.html) and [Use consumer groups to consume data](https://help.aliyun.com/document_detail/28998.html).
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:CreateConsumerGroup`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#logstoreName}/consumergroup/{#ConsumerGroup}`|
 *
 * @param request CreateConsumerGroupRequest
 * @return CreateConsumerGroupResponse
 */
async function createConsumerGroup(project: string, logstore: string, request: CreateConsumerGroupRequest): CreateConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createConsumerGroupWithOptions(project, logstore, request, headers, runtime);
}

model CreateDashboardRequest {
  body?: Dashboard(name='body', description='The data structure of the dashboard.

This parameter is required.'),
}

model CreateDashboardResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates a dashboard.
 *
 * @description ### [](#)Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 *
 * @param request CreateDashboardRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDashboardResponse
 */
async function createDashboardWithOptions(project: string, request: CreateDashboardRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDashboardResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDashboard',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/dashboards`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates a dashboard.
 *
 * @description ### [](#)Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 *
 * @param request CreateDashboardRequest
 * @return CreateDashboardResponse
 */
async function createDashboard(project: string, request: CreateDashboardRequest): CreateDashboardResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDashboardWithOptions(project, request, headers, runtime);
}

model CreateDomainRequest {
  domainName?: string(name='domainName', description='The domain name.

This parameter is required.', example='example.com'),
}

model CreateDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Binds a new custom domain name to a project.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request CreateDomainRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDomainResponse
 */
async function createDomainWithOptions(project: string, request: CreateDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDomainResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.domainName)) {
    body['domainName'] = request.domainName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDomain',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/domains`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Binds a new custom domain name to a project.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request CreateDomainRequest
 * @return CreateDomainResponse
 */
async function createDomain(project: string, request: CreateDomainRequest): CreateDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDomainWithOptions(project, request, headers, runtime);
}

model CreateDownloadJobRequest {
  configuration?: {
    allowInComplete?: boolean(name='allowInComplete', description='This parameter is required.', example='false'),
    fromTime?: long(name='fromTime', description='起点时间戳（精确到秒）

This parameter is required.', example='1722406260'),
    logstore?: string(name='logstore', description='源logstore

This parameter is required.', example='test-logstore'),
    powerSql?: boolean(name='powerSql', description='是否启用powerSql', example='true'),
    query?: string(name='query', description='查询语句

This parameter is required.', example='* | select *'),
    sink?: {
      bucket?: string(name='bucket', description='对象存储桶', example='oss-test-bucket'),
      compressionType?: string(name='compressionType', description='压缩格式

This parameter is required.', example='none'),
      contentType?: string(name='contentType', description='下载文件格式

This parameter is required.', example='csv'),
      prefix?: string(name='prefix', example='download/'),
      roleArn?: string(name='roleArn', description='下载使用roleArn', example='acs:ram::0123456789:role/aliyunlogdefaultrole'),
      type?: string(name='type', description='This parameter is required.', example='AliyunOSS'),
    }(name='sink', description='导出配置

This parameter is required.'),
    toTime?: long(name='toTime', description='结束时间戳（精确到秒）

This parameter is required.', example='1722409860'),
  }(name='configuration', description='下载配置

This parameter is required.'),
  description?: string(name='description', description='任务描述'),
  displayName?: string(name='displayName', description='任务显示名称

This parameter is required.', example='download-123456789'),
  name?: string(name='name', description='代表资源名称的资源属性字段

This parameter is required.', example='download-123'),
}

model CreateDownloadJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 创建下载任务
 *
 * @param request CreateDownloadJobRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDownloadJobResponse
 */
async function createDownloadJobWithOptions(project: string, request: CreateDownloadJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDownloadJobResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDownloadJob',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/downloadjobs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 创建下载任务
 *
 * @param request CreateDownloadJobRequest
 * @return CreateDownloadJobResponse
 */
async function createDownloadJob(project: string, request: CreateDownloadJobRequest): CreateDownloadJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDownloadJobWithOptions(project, request, headers, runtime);
}

model CreateETLRequest {
  configuration?: ETLConfiguration(name='configuration', description='This parameter is required.'),
  description?: string(name='description', example='this is ETL'),
  displayName?: string(name='displayName', description='This parameter is required.', example='sls-test-etl'),
  name?: string(name='name', description='This parameter is required.', example='etl-123456'),
}

model CreateETLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 创建数据加工任务
 *
 * @param request CreateETLRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateETLResponse
 */
async function createETLWithOptions(project: string, request: CreateETLRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateETLResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateETL',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/etls`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 创建数据加工任务
 *
 * @param request CreateETLRequest
 * @return CreateETLResponse
 */
async function createETL(project: string, request: CreateETLRequest): CreateETLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createETLWithOptions(project, request, headers, runtime);
}

model CreateIndexRequest {
  body?: Index(name='body', description='The request body.'),
}

model CreateIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates indexes for a Logstore.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request CreateIndexRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateIndexResponse
 */
async function createIndexWithOptions(project: string, logstore: string, request: CreateIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateIndexResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateIndex',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/index`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates indexes for a Logstore.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request CreateIndexRequest
 * @return CreateIndexResponse
 */
async function createIndex(project: string, logstore: string, request: CreateIndexRequest): CreateIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createIndexWithOptions(project, logstore, request, headers, runtime);
}

model CreateLogStoreRequest {
  appendMeta?: boolean(name='appendMeta', description='Specifies whether to record the **public IP address** and **log receiving time**. Default value: false. Valid values:

*   true********
*   false********', example='false'),
  autoSplit?: boolean(name='autoSplit', description='Specifies whether to enable automatic sharding. Valid values:

*   true
*   false', example='true'),
  enableTracking?: boolean(name='enable_tracking', description='Specifies whether to enable the web tracking feature. Default value: false. Valid values:

*   true
*   false', example='false'),
  encryptConf?: EncryptConf(name='encrypt_conf', description='The data structure of the encryption configuration. The following parameters are included: `enable`, `encrypt_type`, and `user_cmk_info`. For more information, see [EncryptConf](https://help.aliyun.com/document_detail/409461.html).'),
  hotTtl?: int32(name='hot_ttl', description='The retention period of data in the hot storage tier of the Logstore. Valid values: 7 to 3000. Unit: days.

After the retention period that is specified for the hot storage tier elapses, the data is moved to the Infrequent Access (IA) storage tier. For more information, see [Enable hot and cold-tiered storage for a Logstore](https://help.aliyun.com/document_detail/308645.html).', example='60'),
  infrequentAccessTTL?: int32(name='infrequentAccessTTL', description='The retention period of data in the IA storage tier of the Logstore. You must set this parameter to at least 30 days. After the data retention period that you specify for the IA storage tier elapses, the data is moved to the Archive storage tier.', example='30'),
  logstoreName?: string(name='logstoreName', description='The name of the Logstore. The name must meet the following requirements:

*   The name must be unique in a project.
*   The name can contain only lowercase letters, digits, hyphens (-), and underscores (_).
*   The name must start and end with a lowercase letter or a digit.
*   The name must be 2 to 63 characters in length.

This parameter is required.', example='my-logstore'),
  maxSplitShard?: int32(name='maxSplitShard', description='The maximum number of shards into which existing shards can be automatically split. Valid values: 1 to 256.

>  If you set autoSplit to true, you must specify this parameter.', example='64'),
  mode?: string(name='mode', description='The type of the Logstore. Simple Log Service provides two types of Logstores: Standard Logstores and Query Logstores. Valid values:

*   **standard**: Standard Logstore. This type of Logstore supports the log analysis feature and is suitable for scenarios such as real-time monitoring and interactive analysis. You can also use this type of Logstore to build a comprehensive observability system.
*   **query**: Query Logstore. This type of Logstore supports high-performance queries. The index traffic fee of a Query Logstore is approximately half that of a Standard Logstore. Query Logstores do not support SQL analysis. Query Logstores are suitable for scenarios in which the amount of data is large, the log retention period is long, or log analysis is not required. If logs are stored for weeks or months, the log retention period is considered long.', example='standard'),
  processorId?: string(name='processorId', description='IngestProcessor ID'),
  shardCount?: int32(name='shardCount', description='The number of shards.

>  You cannot call the CreateLogStore operation to change the number of shards. You can call the SplitShard or MergeShards operation to change the number of shards.

This parameter is required.', example='2'),
  telemetryType?: string(name='telemetryType', description='The type of the observable data. Valid values:

*   **None** (default): log data
*   **Metrics**: metric data', example='None'),
  ttl?: int32(name='ttl', description='The retention period of data. Unit: days. Valid values: 1 to 3000. If you set this parameter to 3650, data is permanently stored.

This parameter is required.', example='1'),
}

model CreateLogStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates a Logstore.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 * * You can create up to 200 Logstores in each project.
 * * If the retention period of a log reaches the data retention period that you specified for the Logstore, the log is deleted.
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:CreateLogStore`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#LogstoreName}`|
 *
 * @param request CreateLogStoreRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLogStoreResponse
 */
async function createLogStoreWithOptions(project: string, request: CreateLogStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLogStoreResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.appendMeta)) {
    body['appendMeta'] = request.appendMeta;
  }
  if (!Util.isUnset(request.autoSplit)) {
    body['autoSplit'] = request.autoSplit;
  }
  if (!Util.isUnset(request.enableTracking)) {
    body['enable_tracking'] = request.enableTracking;
  }
  if (!Util.isUnset(request.encryptConf)) {
    body['encrypt_conf'] = request.encryptConf;
  }
  if (!Util.isUnset(request.hotTtl)) {
    body['hot_ttl'] = request.hotTtl;
  }
  if (!Util.isUnset(request.infrequentAccessTTL)) {
    body['infrequentAccessTTL'] = request.infrequentAccessTTL;
  }
  if (!Util.isUnset(request.logstoreName)) {
    body['logstoreName'] = request.logstoreName;
  }
  if (!Util.isUnset(request.maxSplitShard)) {
    body['maxSplitShard'] = request.maxSplitShard;
  }
  if (!Util.isUnset(request.mode)) {
    body['mode'] = request.mode;
  }
  if (!Util.isUnset(request.processorId)) {
    body['processorId'] = request.processorId;
  }
  if (!Util.isUnset(request.shardCount)) {
    body['shardCount'] = request.shardCount;
  }
  if (!Util.isUnset(request.telemetryType)) {
    body['telemetryType'] = request.telemetryType;
  }
  if (!Util.isUnset(request.ttl)) {
    body['ttl'] = request.ttl;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLogStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates a Logstore.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 * * You can create up to 200 Logstores in each project.
 * * If the retention period of a log reaches the data retention period that you specified for the Logstore, the log is deleted.
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:CreateLogStore`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#LogstoreName}`|
 *
 * @param request CreateLogStoreRequest
 * @return CreateLogStoreResponse
 */
async function createLogStore(project: string, request: CreateLogStoreRequest): CreateLogStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLogStoreWithOptions(project, request, headers, runtime);
}

model CreateLoggingRequest {
  loggingDetails?: [ 
    {
      logstore?: string(name='logstore', description='The name of the Logstore to which service logs of the type are stored.

This parameter is required.', example='my-logstore'),
      type?: string(name='type', description='The type of service logs. Valid values:

*   consumergroup_log: the consumption delay logs of consumer groups.
*   logtail_alarm: the alert logs of Logtail.
*   operation_log: the operation logs.
*   logtail_profile: the collection logs of Logtail.
*   metering: the metering logs.
*   logtail_status: the status logs of Logtail.
*   scheduledsqlalert: the run logs of Scheduled SQL jobs.
*   etl_alert: the run logs of data transformation jobs.

This parameter is required.', example='consumergroup_log'),
    }
  ](name='loggingDetails', description='The configurations of service logs.

This parameter is required.'),
  loggingProject?: string(name='loggingProject', description='The name of the project to which service logs are stored.

This parameter is required.', example='my-project'),
}

model CreateLoggingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Enables the service log feature for a project.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request CreateLoggingRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLoggingResponse
 */
async function createLoggingWithOptions(project: string, request: CreateLoggingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLoggingResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.loggingDetails)) {
    body['loggingDetails'] = request.loggingDetails;
  }
  if (!Util.isUnset(request.loggingProject)) {
    body['loggingProject'] = request.loggingProject;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLogging',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logging`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Enables the service log feature for a project.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request CreateLoggingRequest
 * @return CreateLoggingResponse
 */
async function createLogging(project: string, request: CreateLoggingRequest): CreateLoggingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLoggingWithOptions(project, request, headers, runtime);
}

model CreateLogtailPipelineConfigRequest {
  aggregators?: [  map[string]any ](name='aggregators', description='The aggregation plug-ins.

>  This parameter takes effect only when extended plug-ins are used. You can use only one aggregation plug-in.'),
  configName?: string(name='configName', description='The name of the configuration.

>  The name of the configuration must be unique in the project to which the configuration belongs. After the configuration is created, you cannot change the name of the configuration. The name must meet the following requirements:

*   The name can contain only lowercase letters, digits, hyphens (-), and underscores (_).

*   The name must start and end with a lowercase letter or a digit.

*   The name must be 2 to 128 characters in length.

This parameter is required.', example='test-config'),
  flushers?: [  map[string]any ](name='flushers', description='The output plug-ins.

>  You can configure only one output plug-in.

This parameter is required.'),
  global?: map[string]any(name='global', description='The global settings.'),
  inputs?: [  map[string]any ](name='inputs', description='The input plug-ins.

>  You can configure only one input plug-in.

This parameter is required.'),
  logSample?: string(name='logSample', description='The sample log. You can specify multiple sample logs.', example='2022-06-14 11:13:29.796 | DEBUG    | __main__:<module>:1 - hello world'),
  processors?: [  map[string]any ](name='processors', description='The processing plug-ins.

>  Logtail plug-ins for data processing are classified into native plug-ins and extended plug-ins. For more information, see [Overview of Logtail plug-ins for data processing](https://help.aliyun.com/document_detail/64957.html).

> 

*   You can use native plug-ins only to collect text logs.

*   You cannot add native plug-ins and extended plug-ins at a time.

*   When you add native plug-ins, take note of the following items:

    *   You must add one of the following Logtail plug-ins for data processing as the first plug-in: Data Parsing (Regex Mode), Data Parsing (Delimiter Mode), Data Parsing (JSON Mode), Data Parsing (NGINX Mode), Data Parsing (Apache Mode), and Data Parsing (IIS Mode).
    *   After you add the first plug-in, you can add one Time Parsing plug-in, one Data Filtering plug-in, and multiple Data Masking plug-ins.'),
}

model CreateLogtailPipelineConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates a Logtail pipeline configuration.
 *
 * @description The UK (London) region is supported. Supported regions are constantly updated.
 *
 * @param request CreateLogtailPipelineConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLogtailPipelineConfigResponse
 */
async function createLogtailPipelineConfigWithOptions(project: string, request: CreateLogtailPipelineConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLogtailPipelineConfigResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.aggregators)) {
    body['aggregators'] = request.aggregators;
  }
  if (!Util.isUnset(request.configName)) {
    body['configName'] = request.configName;
  }
  if (!Util.isUnset(request.flushers)) {
    body['flushers'] = request.flushers;
  }
  if (!Util.isUnset(request.global)) {
    body['global'] = request.global;
  }
  if (!Util.isUnset(request.inputs)) {
    body['inputs'] = request.inputs;
  }
  if (!Util.isUnset(request.logSample)) {
    body['logSample'] = request.logSample;
  }
  if (!Util.isUnset(request.processors)) {
    body['processors'] = request.processors;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLogtailPipelineConfig',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/pipelineconfigs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates a Logtail pipeline configuration.
 *
 * @description The UK (London) region is supported. Supported regions are constantly updated.
 *
 * @param request CreateLogtailPipelineConfigRequest
 * @return CreateLogtailPipelineConfigResponse
 */
async function createLogtailPipelineConfig(project: string, request: CreateLogtailPipelineConfigRequest): CreateLogtailPipelineConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLogtailPipelineConfigWithOptions(project, request, headers, runtime);
}

model CreateMachineGroupRequest {
  groupAttribute?: {
    externalName?: string(name='externalName', description='The identifier of the external management system on which the machine group depends.', example='testgroup'),
    groupTopic?: string(name='groupTopic', description='The log topic of the machine group.', example='testtopic'),
  }(name='groupAttribute', description='The attributes of the machine group.'),
  groupName?: string(name='groupName', description='The name of the machine group. The name must meet the following requirements:

*   The name of each machine group in a project must be unique.
*   It can contain only lowercase letters, digits, hyphens (-), and underscores (_).
*   It must start and end with a lowercase letter or a digit.
*   It must be 3 to 128 characters in length.

This parameter is required.', example='test-machine-group'),
  groupType?: string(name='groupType', description='The type of the machine group. The parameter can be left empty.', example='""'),
  machineIdentifyType?: string(name='machineIdentifyType', description='The type of the machine group identifier. Valid values:

*   ip: The machine group uses IP addresses as identifiers.
*   userdefined: The machine group uses custom identifiers.

This parameter is required.', example='ip'),
  machineList?: [ string ](name='machineList', description='The identifiers of machine group.

*   If you set machineIdentifyType to ip, enter the IP address of the machine.
*   If you set machineIdentifyType to userdefined, enter a custom identifier.

This parameter is required.'),
}

model CreateMachineGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates a machine group.
 *
 * @description ### Usage notes
 * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request CreateMachineGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMachineGroupResponse
 */
async function createMachineGroupWithOptions(project: string, request: CreateMachineGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMachineGroupResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupAttribute)) {
    body['groupAttribute'] = request.groupAttribute;
  }
  if (!Util.isUnset(request.groupName)) {
    body['groupName'] = request.groupName;
  }
  if (!Util.isUnset(request.groupType)) {
    body['groupType'] = request.groupType;
  }
  if (!Util.isUnset(request.machineIdentifyType)) {
    body['machineIdentifyType'] = request.machineIdentifyType;
  }
  if (!Util.isUnset(request.machineList)) {
    body['machineList'] = request.machineList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates a machine group.
 *
 * @description ### Usage notes
 * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request CreateMachineGroupRequest
 * @return CreateMachineGroupResponse
 */
async function createMachineGroup(project: string, request: CreateMachineGroupRequest): CreateMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMachineGroupWithOptions(project, request, headers, runtime);
}

model CreateMaxComputeExportRequest {
  configuration?: MaxComputeExportConfiguration(name='configuration', description='The setting of the MaxCompute data shipping job.

This parameter is required.'),
  description?: string(name='description', description='The description of the MaxCompute data shipping job.'),
  displayName?: string(name='displayName', description='The display name of the MaxCompute data shipping job.

This parameter is required.', example='my-mc-job'),
  name?: string(name='name', description='The unique identifier of the MaxCompute data shipping job.

This parameter is required.', example='export-mc-1234567890-123456'),
}

model CreateMaxComputeExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates a MaxCompute data shipping job.
 *
 * @description *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 *
 * @param request CreateMaxComputeExportRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMaxComputeExportResponse
 */
async function createMaxComputeExportWithOptions(project: string, request: CreateMaxComputeExportRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMaxComputeExportResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMaxComputeExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/maxcomputeexports`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates a MaxCompute data shipping job.
 *
 * @description *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 *
 * @param request CreateMaxComputeExportRequest
 * @return CreateMaxComputeExportResponse
 */
async function createMaxComputeExport(project: string, request: CreateMaxComputeExportRequest): CreateMaxComputeExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMaxComputeExportWithOptions(project, request, headers, runtime);
}

model CreateMetricStoreRequest {
  autoSplit?: boolean(name='autoSplit', description='Specifies whether to enable automatic sharding.', example='true'),
  hotTtl?: int32(name='hot_ttl'),
  infrequentAccessTTL?: int32(name='infrequentAccessTTL'),
  maxSplitShard?: int32(name='maxSplitShard', description='The maximum number of shards into which existing shards can be automatically split. This parameter is valid only when you set the autoSplit parameter to true.', example='64'),
  metricType?: string(name='metricType', description='The type of the metric data. Example: prometheus.', example='prometheus'),
  mode?: string(name='mode', description='The type of the Metricstore. For example, you can set the parameter to standard to query Standard Metricstores.', example='standard'),
  name?: string(name='name', description='The name of the Metricstore.

This parameter is required.', example='my_metric_store'),
  shardCount?: int32(name='shardCount', description='The number of shards in the Metricstore.

This parameter is required.', example='2'),
  ttl?: int32(name='ttl', description='The retention period of the metric data in the Metricstore. Unit: days.

This parameter is required.', example='7'),
}

model CreateMetricStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates a Metricstore to store metric data.
 *
 * @description Metricstores are used to store metric data. For more information, see [Metric data](https://help.aliyun.com/document_detail/174965.html).
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query metric data is obtained. The information includes the name of the project to which the metric data belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 * *   You can create up to 200 Logstores or Metricstores in a project.
 * *   Metric data is automatically deleted when the retention period of the metric data ends.
 *
 * @param request CreateMetricStoreRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMetricStoreResponse
 */
async function createMetricStoreWithOptions(project: string, request: CreateMetricStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMetricStoreResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoSplit)) {
    body['autoSplit'] = request.autoSplit;
  }
  if (!Util.isUnset(request.hotTtl)) {
    body['hot_ttl'] = request.hotTtl;
  }
  if (!Util.isUnset(request.infrequentAccessTTL)) {
    body['infrequentAccessTTL'] = request.infrequentAccessTTL;
  }
  if (!Util.isUnset(request.maxSplitShard)) {
    body['maxSplitShard'] = request.maxSplitShard;
  }
  if (!Util.isUnset(request.metricType)) {
    body['metricType'] = request.metricType;
  }
  if (!Util.isUnset(request.mode)) {
    body['mode'] = request.mode;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.shardCount)) {
    body['shardCount'] = request.shardCount;
  }
  if (!Util.isUnset(request.ttl)) {
    body['ttl'] = request.ttl;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMetricStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/metricstores`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates a Metricstore to store metric data.
 *
 * @description Metricstores are used to store metric data. For more information, see [Metric data](https://help.aliyun.com/document_detail/174965.html).
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query metric data is obtained. The information includes the name of the project to which the metric data belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 * *   You can create up to 200 Logstores or Metricstores in a project.
 * *   Metric data is automatically deleted when the retention period of the metric data ends.
 *
 * @param request CreateMetricStoreRequest
 * @return CreateMetricStoreResponse
 */
async function createMetricStore(project: string, request: CreateMetricStoreRequest): CreateMetricStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMetricStoreWithOptions(project, request, headers, runtime);
}

model CreateOSSExportRequest {
  configuration?: OSSExportConfiguration(name='configuration', description='The configuration details of the job.

This parameter is required.'),
  description?: string(name='description', description='The description of the job.'),
  displayName?: string(name='displayName', description='The display name of the job.

This parameter is required.', example='ali-test-oss-job'),
  name?: string(name='name', description='The unique identifier of the OSS data shipping job.

This parameter is required.', example='job-123456789-123456'),
}

model CreateOSSExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Ships logs from a Simple Log Service Logstore to an Object Storage Service (OSS) bucket.
 *
 * @param request CreateOSSExportRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOSSExportResponse
 */
async function createOSSExportWithOptions(project: string, request: CreateOSSExportRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateOSSExportResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOSSExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossexports`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Ships logs from a Simple Log Service Logstore to an Object Storage Service (OSS) bucket.
 *
 * @param request CreateOSSExportRequest
 * @return CreateOSSExportResponse
 */
async function createOSSExport(project: string, request: CreateOSSExportRequest): CreateOSSExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createOSSExportWithOptions(project, request, headers, runtime);
}

model CreateOSSHDFSExportRequest {
  configuration?: OSSExportConfiguration(name='configuration', description='The configuration details of the job.

This parameter is required.'),
  description?: string(name='description', description='The description of the job.'),
  displayName?: string(name='displayName', description='The display name of the job.

This parameter is required.', example='ali-test-oss-hdfs-job'),
  name?: string(name='name', description='The unique identifier of the OSS data shipping job.

This parameter is required.', example='job-123456789-123456'),
}

model CreateOSSHDFSExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates an OSS-HDFS data shipping job in a project.
 *
 * @param request CreateOSSHDFSExportRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOSSHDFSExportResponse
 */
async function createOSSHDFSExportWithOptions(project: string, request: CreateOSSHDFSExportRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateOSSHDFSExportResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOSSHDFSExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/osshdfsexports`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates an OSS-HDFS data shipping job in a project.
 *
 * @param request CreateOSSHDFSExportRequest
 * @return CreateOSSHDFSExportResponse
 */
async function createOSSHDFSExport(project: string, request: CreateOSSHDFSExportRequest): CreateOSSHDFSExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createOSSHDFSExportWithOptions(project, request, headers, runtime);
}

model CreateOSSIngestionRequest {
  configuration?: OSSIngestionConfiguration(name='configuration', description='The configurations of the OSS data import job.

This parameter is required.'),
  description?: string(name='description', description='The description of the job.'),
  displayName?: string(name='displayName', description='The display name.

This parameter is required.'),
  name?: string(name='name', description='The name of the OSS data import job.

This parameter is required.', example='ingest-oss-123456'),
  schedule?: Schedule(name='schedule', description='The scheduling type. By default, you do not need to specify this parameter. If you want to import data at regular intervals, such as importing data every Monday at 08: 00., you can specify a cron expression.'),
}

model CreateOSSIngestionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates an Object Storage Service (OSS) data import job in a project.
 *
 * @param request CreateOSSIngestionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOSSIngestionResponse
 */
async function createOSSIngestionWithOptions(project: string, request: CreateOSSIngestionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateOSSIngestionResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.schedule)) {
    body['schedule'] = request.schedule;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOSSIngestion',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossingestions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates an Object Storage Service (OSS) data import job in a project.
 *
 * @param request CreateOSSIngestionRequest
 * @return CreateOSSIngestionResponse
 */
async function createOSSIngestion(project: string, request: CreateOSSIngestionRequest): CreateOSSIngestionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createOSSIngestionWithOptions(project, request, headers, runtime);
}

model CreateOssExternalStoreRequest {
  externalStoreName?: string(name='externalStoreName', description='The name of the external store.

This parameter is required.', example='test_oss_store'),
  parameter?: {
    accessid?: string(name='accessid', description='The AccessKey ID.

This parameter is required.', example='LTAI5tFsHGGeYry*****1Sz'),
    accesskey?: string(name='accesskey', description='The AccessKey secret.

This parameter is required.', example='GyviCLDVHkHrOztdkxuE6******Rp6'),
    bucket?: string(name='bucket', description='The name of the OSS bucket.

This parameter is required.', example='my-bucket'),
    columns?: [ 
      {
        name?: string(name='name', description='The name of the field.

This parameter is required.', example='auto-test'),
        type?: string(name='type', description='The data type of the field.

This parameter is required.', example='sls'),
      }
    ](name='columns', description='The associated fields.

This parameter is required.'),
    endpoint?: string(name='endpoint', description='The OSS endpoint. For more information, see [Regions and endpoints](https://help.aliyun.com/document_detail/31837.html).

This parameter is required.', example='oss-cn-hangzhou.aliyuncs.com'),
    objects?: [ string ](name='objects', description='The associated OSS objects. Valid values of n: 1 to 100.

This parameter is required.'),
  }(name='parameter', description='The parameters of the external store.

This parameter is required.'),
  storeType?: string(name='storeType', description='The type of the external store. Set the value to oss.

This parameter is required.', example='oss'),
}

model CreateOssExternalStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates an Object Storage Service (OSS) external store.
 *
 * @description ### [](#)Usage notes
 * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request CreateOssExternalStoreRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOssExternalStoreResponse
 */
async function createOssExternalStoreWithOptions(project: string, request: CreateOssExternalStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateOssExternalStoreResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.externalStoreName)) {
    body['externalStoreName'] = request.externalStoreName;
  }
  if (!Util.isUnset(request.parameter)) {
    body['parameter'] = request.parameter;
  }
  if (!Util.isUnset(request.storeType)) {
    body['storeType'] = request.storeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOssExternalStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/externalstores`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates an Object Storage Service (OSS) external store.
 *
 * @description ### [](#)Usage notes
 * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request CreateOssExternalStoreRequest
 * @return CreateOssExternalStoreResponse
 */
async function createOssExternalStore(project: string, request: CreateOssExternalStoreRequest): CreateOssExternalStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createOssExternalStoreWithOptions(project, request, headers, runtime);
}

model CreateProjectRequest {
  dataRedundancyType?: string(name='dataRedundancyType', description='The disaster recovery type. Valid values:

*   LRS: locally redundant storage
*   ZRS: zone-redundant storage', example='LRS'),
  description?: string(name='description', description='The description of the project.

This parameter is required.', example='this is test'),
  projectName?: string(name='projectName', description='The project name must be unique in a region. You cannot change the name after you create the project. The name must meet the following requirements:

*   The name must be globally unique.
*   The name can contain only lowercase letters, digits, and hyphens (-).
*   The name must start and end with a lowercase letter or a digit.
*   The name must be 3 to 63 characters in length.

This parameter is required.', example='test-project'),
  recycleBinEnabled?: boolean(name='recycleBinEnabled', description='Specifies whether to enable the recycle bin feature.

Valid values:

*   true
*   false', example='true'),
  resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group.', example='rg-aekzf******sxby'),
}

model CreateProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates a project.
 *
 * @param request CreateProjectRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateProjectResponse
 */
async function createProjectWithOptions(request: CreateProjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dataRedundancyType)) {
    body['dataRedundancyType'] = request.dataRedundancyType;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.projectName)) {
    body['projectName'] = request.projectName;
  }
  if (!Util.isUnset(request.recycleBinEnabled)) {
    body['recycleBinEnabled'] = request.recycleBinEnabled;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates a project.
 *
 * @param request CreateProjectRequest
 * @return CreateProjectResponse
 */
async function createProject(request: CreateProjectRequest): CreateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createProjectWithOptions(request, headers, runtime);
}

model CreateRdsExternalStoreRequest {
  externalStoreName?: string(name='externalStoreName', description='The name of the external store. The name must be unique in a project and must be different from Logstore names.

This parameter is required.', example='rds_store'),
  parameter?: {
    db?: string(name='db', description='The name of the database in the ApsaraDB RDS for MySQL instance.

This parameter is required.', example='meta'),
    host?: string(name='host', description='The internal or public endpoint of the ApsaraDB RDS for MySQL instance.', example='192.168.XX.XX'),
    instanceId?: string(name='instance-id', description='The ID of the ApsaraDB RDS for MySQL instance.', example='i-bp1b6c719dfa08exf****'),
    password?: string(name='password', description='The password that is used to log on to the ApsaraDB RDS for MySQL instance.

This parameter is required.', example='sfdsfldsfksfls****'),
    port?: string(name='port', description='The internal or public port of the ApsaraDB RDS for MySQL instance.

This parameter is required.', example='3306'),
    region?: string(name='region', description='The region where the ApsaraDB RDS for MySQL instance resides. Valid values: cn-qingdao, cn-beijing, and cn-hangzhou.

This parameter is required.', example='cn-qingdao'),
    table?: string(name='table', description='The name of the database table in the ApsaraDB RDS for MySQL instance.

This parameter is required.', example='join_meta'),
    username?: string(name='username', description='The username that is used to log on to the ApsaraDB RDS for MySQL instance.

This parameter is required.', example='root'),
    vpcId?: string(name='vpc-id', description='The ID of the VPC to which the ApsaraDB RDS for MySQL instance belongs.', example='vpc-bp1aevy8sofi8mh1q****'),
  }(name='parameter', description='The parameter struct.

This parameter is required.'),
  storeType?: string(name='storeType', description='The storage type. Set the value to rds-vpc, which indicates an ApsaraDB RDS for MySQL database in a virtual private cloud (VPC).

This parameter is required.', example='rds-vpc'),
}

model CreateRdsExternalStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates an ApsaraDB RDS external store.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request CreateRdsExternalStoreRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRdsExternalStoreResponse
 */
async function createRdsExternalStoreWithOptions(project: string, request: CreateRdsExternalStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRdsExternalStoreResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.externalStoreName)) {
    body['externalStoreName'] = request.externalStoreName;
  }
  if (!Util.isUnset(request.parameter)) {
    body['parameter'] = request.parameter;
  }
  if (!Util.isUnset(request.storeType)) {
    body['storeType'] = request.storeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateRdsExternalStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/externalstores`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates an ApsaraDB RDS external store.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request CreateRdsExternalStoreRequest
 * @return CreateRdsExternalStoreResponse
 */
async function createRdsExternalStore(project: string, request: CreateRdsExternalStoreRequest): CreateRdsExternalStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRdsExternalStoreWithOptions(project, request, headers, runtime);
}

model CreateSavedSearchRequest {
  displayName?: string(name='displayName', description='The display name.

This parameter is required.', example='displayname'),
  logstore?: string(name='logstore', description='The name of the Logstore to which the saved search belongs.

This parameter is required.', example='aliyun-test-logstore'),
  savedsearchName?: string(name='savedsearchName', description='The name of the saved search. The name must be 3 to 63 characters in length.

This parameter is required.', example='pv in minutes'),
  searchQuery?: string(name='searchQuery', description='The query statement of the saved search. A query statement consists of a search statement and an analytic statement in the `Search statement|Analytic statement` format. For more information, see [Log search overview](https://help.aliyun.com/document_detail/43772.html) and [Log analysis overview](https://help.aliyun.com/document_detail/53608.html).

This parameter is required.', example='*|select date_format(__time__-__time__%60, \\\\"%H:%i:%s\\\\") as time, COUNT(*) as pv group by time'),
  topic?: string(name='topic', description='The topic of the logs.

This parameter is required.', example='theme'),
}

model CreateSavedSearchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates a saved search.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 * * Limits are imposed when you use Simple Log Service to query logs. We recommend that you specify query statements and query time ranges based on the limits. For more information, see [Log search overview](https://help.aliyun.com/document_detail/43772.html) and [Log analysis overview](https://help.aliyun.com/document_detail/53608.html).
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:CreateSavedSearch`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/savedsearch/{#SavedSearchName}`|
 *
 * @param request CreateSavedSearchRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSavedSearchResponse
 */
async function createSavedSearchWithOptions(project: string, request: CreateSavedSearchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSavedSearchResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.logstore)) {
    body['logstore'] = request.logstore;
  }
  if (!Util.isUnset(request.savedsearchName)) {
    body['savedsearchName'] = request.savedsearchName;
  }
  if (!Util.isUnset(request.searchQuery)) {
    body['searchQuery'] = request.searchQuery;
  }
  if (!Util.isUnset(request.topic)) {
    body['topic'] = request.topic;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSavedSearch',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/savedsearches`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates a saved search.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 * * Limits are imposed when you use Simple Log Service to query logs. We recommend that you specify query statements and query time ranges based on the limits. For more information, see [Log search overview](https://help.aliyun.com/document_detail/43772.html) and [Log analysis overview](https://help.aliyun.com/document_detail/53608.html).
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:CreateSavedSearch`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/savedsearch/{#SavedSearchName}`|
 *
 * @param request CreateSavedSearchRequest
 * @return CreateSavedSearchResponse
 */
async function createSavedSearch(project: string, request: CreateSavedSearchRequest): CreateSavedSearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSavedSearchWithOptions(project, request, headers, runtime);
}

model CreateScheduledSQLRequest {
  configuration?: ScheduledSQLConfiguration(name='configuration', description='This parameter is required.'),
  description?: string(name='description'),
  displayName?: string(name='displayName', description='This parameter is required.', example='ali-test-scheduled-sql'),
  name?: string(name='name', description='This parameter is required.', example='sql-123456789-123456'),
  schedule?: Schedule(name='schedule', description='This parameter is required.'),
}

model CreateScheduledSQLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates a Scheduled SQL job in a project.
 *
 * @param request CreateScheduledSQLRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateScheduledSQLResponse
 */
async function createScheduledSQLWithOptions(project: string, request: CreateScheduledSQLRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateScheduledSQLResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.schedule)) {
    body['schedule'] = request.schedule;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateScheduledSQL',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/scheduledsqls`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates a Scheduled SQL job in a project.
 *
 * @param request CreateScheduledSQLRequest
 * @return CreateScheduledSQLResponse
 */
async function createScheduledSQL(project: string, request: CreateScheduledSQLRequest): CreateScheduledSQLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createScheduledSQLWithOptions(project, request, headers, runtime);
}

model CreateSqlInstanceRequest {
  cu?: int32(name='cu', description='The number of compute units (CUs). When you use the Dedicated SQL feature, CUs are used in parallel.

This parameter is required.', example='2'),
  useAsDefault?: boolean(name='useAsDefault', description='Specifies whether to enable the Dedicated SQL feature for the project. If you set this parameter to true, the Dedicated SQL feature is enabled for the specified project and takes effect for all query statements that you execute in the project, including the query statements for alerts and dashboards.

This parameter is required.'),
}

model CreateSqlInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary If you use the Standard SQL feature to analyze a large amount of data, the logs within the specified time range cannot be fully scanned in a single query request. In this case, the returned results may not contain all matched data. You can increase the number of shards to improve data read and write capabilities. However, this method takes effect only for incremental data. You can enable the Dedicated SQL feature to increase computing resources and the amount of data that can be analyzed in a single query request.
 *
 * @description **Before you call this operation, make sure that you fully understand the [billing](https://help.aliyun.com/document_detail/223777.html) of Dedicated SQL.
 *
 * @param request CreateSqlInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSqlInstanceResponse
 */
async function createSqlInstanceWithOptions(project: string, request: CreateSqlInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSqlInstanceResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.cu)) {
    body['cu'] = request.cu;
  }
  if (!Util.isUnset(request.useAsDefault)) {
    body['useAsDefault'] = request.useAsDefault;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSqlInstance',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/sqlinstance`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary If you use the Standard SQL feature to analyze a large amount of data, the logs within the specified time range cannot be fully scanned in a single query request. In this case, the returned results may not contain all matched data. You can increase the number of shards to improve data read and write capabilities. However, this method takes effect only for incremental data. You can enable the Dedicated SQL feature to increase computing resources and the amount of data that can be analyzed in a single query request.
 *
 * @description **Before you call this operation, make sure that you fully understand the [billing](https://help.aliyun.com/document_detail/223777.html) of Dedicated SQL.
 *
 * @param request CreateSqlInstanceRequest
 * @return CreateSqlInstanceResponse
 */
async function createSqlInstance(project: string, request: CreateSqlInstanceRequest): CreateSqlInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSqlInstanceWithOptions(project, request, headers, runtime);
}

model CreateStoreViewRequest {
  name?: string(name='name', description='The name of the dataset.

*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a lowercase letter.
*   The name must be 3 to 62 characters in length.

This parameter is required.', example='my_storeview'),
  storeType?: string(name='storeType', description='The type of the dataset. Valid values: metricstore and logstore.

This parameter is required.', example='logstore'),
  stores?: [
    StoreViewStore
  ](name='stores', description='The Logstores or Metricstores.

This parameter is required.'),
}

model CreateStoreViewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 创建StoreView
 *
 * @param request CreateStoreViewRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateStoreViewResponse
 */
async function createStoreViewWithOptions(project: string, request: CreateStoreViewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateStoreViewResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.storeType)) {
    body['storeType'] = request.storeType;
  }
  if (!Util.isUnset(request.stores)) {
    body['stores'] = request.stores;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateStoreView',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/storeviews`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 创建StoreView
 *
 * @param request CreateStoreViewRequest
 * @return CreateStoreViewResponse
 */
async function createStoreView(project: string, request: CreateStoreViewRequest): CreateStoreViewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createStoreViewWithOptions(project, request, headers, runtime);
}

model CreateTicketRequest {
  accessTokenExpirationTime?: long(name='accessTokenExpirationTime', description='*   The validity period of the access token. Unit: seconds. Default value: 86400, which specifies one day. Valid values: 0 to 86400.
*   The validity period of the access token is the smaller value between accessTokenExpirationTime and expirationTime.
*   If you use a Security Token Service (STS) token to call this operation, the validity period of the access token is the smallest value among accessTokenExpirationTime, expirationTime, and the validity period of the STS token.', example='600'),
  expirationTime?: long(name='expirationTime', description='*   You must use the Simple Log Service endpoint for the China (Shanghai) or Singapore region to call the CreateTicket operation. After you obtain the ticket, you can use the ticket regardless of the region.
*   The validity period for the URL of the console page that you want to embed. Unit: seconds. Default value: 86400, which specifies one day. Valid values: 0 to 2592000. The value 2592000 specifies 30 days.', example='86400'),
}

model CreateTicketResponseBody = {
  ticket?: string(name='ticket', description='The ticket that is used for logon-free access.', example='eyJ***************.eyJ******************.KUT****************'),
}

model CreateTicketResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateTicketResponseBody(name='body'),
}

/**
 * @summary Obtains a ticket. Simple Log Service allows you to share the query and analysis pages and dashboard pages with other users and embed the console pages into third-party systems. This way, other users can view your logs in password-free mode. The URLs of the shared pages are referred to as password-free URLs. You can call the CreateTicket operation to obtain a ticket and generate a password-free URL based on the ticket and the URL of the console page that you want to share.
 *
 * @param request CreateTicketRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTicketResponse
 */
async function createTicketWithOptions(request: CreateTicketRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTicketResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessTokenExpirationTime)) {
    query['accessTokenExpirationTime'] = request.accessTokenExpirationTime;
  }
  if (!Util.isUnset(request.expirationTime)) {
    query['expirationTime'] = request.expirationTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateTicket',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/tickets`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Obtains a ticket. Simple Log Service allows you to share the query and analysis pages and dashboard pages with other users and embed the console pages into third-party systems. This way, other users can view your logs in password-free mode. The URLs of the shared pages are referred to as password-free URLs. You can call the CreateTicket operation to obtain a ticket and generate a password-free URL based on the ticket and the URL of the console page that you want to share.
 *
 * @param request CreateTicketRequest
 * @return CreateTicketResponse
 */
async function createTicket(request: CreateTicketRequest): CreateTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTicketWithOptions(request, headers, runtime);
}

model DeleteAgentInstanceConfigRequest {
  isGray?: boolean(name='isGray'),
}

model DeleteAgentInstanceConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary DeleteAgentInstanceConfig
 *
 * @param request DeleteAgentInstanceConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAgentInstanceConfigResponse
 */
async function deleteAgentInstanceConfigWithOptions(configName: string, request: DeleteAgentInstanceConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAgentInstanceConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.isGray)) {
    query['isGray'] = request.isGray;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAgentInstanceConfig',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/agentinstanceconfigs/${configName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary DeleteAgentInstanceConfig
 *
 * @param request DeleteAgentInstanceConfigRequest
 * @return DeleteAgentInstanceConfigResponse
 */
async function deleteAgentInstanceConfig(configName: string, request: DeleteAgentInstanceConfigRequest): DeleteAgentInstanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAgentInstanceConfigWithOptions(configName, request, headers, runtime);
}

model DeleteAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes an alert rule.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAlertResponse
 */
async function deleteAlertWithOptions(project: string, alertName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAlertResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteAlert',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/alerts/${alertName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes an alert rule.
 *
 * @return DeleteAlertResponse
 */
async function deleteAlert(project: string, alertName: string): DeleteAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAlertWithOptions(project, alertName, headers, runtime);
}

model DeleteAnnotationDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Removes data from a dataset.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAnnotationDataResponse
 */
async function deleteAnnotationDataWithOptions(datasetId: string, annotationdataId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAnnotationDataResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteAnnotationData',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationdataset/${datasetId}/annotationdata/${annotationdataId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Removes data from a dataset.
 *
 * @return DeleteAnnotationDataResponse
 */
async function deleteAnnotationData(datasetId: string, annotationdataId: string): DeleteAnnotationDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAnnotationDataWithOptions(datasetId, annotationdataId, headers, runtime);
}

model DeleteAnnotationDataSetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a dataset.
 *
 * @description You can delete a dataset only if no data exists in the dataset.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAnnotationDataSetResponse
 */
async function deleteAnnotationDataSetWithOptions(datasetId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAnnotationDataSetResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteAnnotationDataSet',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationdataset/${datasetId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a dataset.
 *
 * @description You can delete a dataset only if no data exists in the dataset.
 *
 * @return DeleteAnnotationDataSetResponse
 */
async function deleteAnnotationDataSet(datasetId: string): DeleteAnnotationDataSetResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAnnotationDataSetWithOptions(datasetId, headers, runtime);
}

model DeleteAnnotationLabelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a tag table.
 *
 * @description Only non-built-in tags can be deleted.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAnnotationLabelResponse
 */
async function deleteAnnotationLabelWithOptions(labelId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAnnotationLabelResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteAnnotationLabel',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationlabel/${labelId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a tag table.
 *
 * @description Only non-built-in tags can be deleted.
 *
 * @return DeleteAnnotationLabelResponse
 */
async function deleteAnnotationLabel(labelId: string): DeleteAnnotationLabelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAnnotationLabelWithOptions(labelId, headers, runtime);
}

model DeleteCollectionPolicyRequest {
  dataCode?: string(name='dataCode', example='access_log'),
  productCode?: string(name='productCode', example='oss'),
}

model DeleteCollectionPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a log collection policy from a cloud service.
 *
 * @description You must use the Simple Log Service endpoint for the China (Shanghai), Singapore, or Heyuan ACDR Auto region to call the operation.
 *
 * @param request DeleteCollectionPolicyRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCollectionPolicyResponse
 */
async function deleteCollectionPolicyWithOptions(policyName: string, request: DeleteCollectionPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteCollectionPolicyResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dataCode)) {
    query['dataCode'] = request.dataCode;
  }
  if (!Util.isUnset(request.productCode)) {
    query['productCode'] = request.productCode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCollectionPolicy',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/collectionpolicy/${policyName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a log collection policy from a cloud service.
 *
 * @description You must use the Simple Log Service endpoint for the China (Shanghai), Singapore, or Heyuan ACDR Auto region to call the operation.
 *
 * @param request DeleteCollectionPolicyRequest
 * @return DeleteCollectionPolicyResponse
 */
async function deleteCollectionPolicy(policyName: string, request: DeleteCollectionPolicyRequest): DeleteCollectionPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteCollectionPolicyWithOptions(policyName, request, headers, runtime);
}

model DeleteConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a Logtail configuration.
 *
 * @description ### [](#)Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   If a Logtail configuration is applied to a machine group, you cannot collect data from the machine group after you delete the Logtail configuration.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 * *   The name of the required Logtail configuration is obtained. For more information, see [ListConfig](https://help.aliyun.com/document_detail/29043.html).
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteConfigResponse
 */
async function deleteConfigWithOptions(project: string, configName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteConfigResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteConfig',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/configs/${configName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a Logtail configuration.
 *
 * @description ### [](#)Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   If a Logtail configuration is applied to a machine group, you cannot collect data from the machine group after you delete the Logtail configuration.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 * *   The name of the required Logtail configuration is obtained. For more information, see [ListConfig](https://help.aliyun.com/document_detail/29043.html).
 *
 * @return DeleteConfigResponse
 */
async function deleteConfig(project: string, configName: string): DeleteConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConfigWithOptions(project, configName, headers, runtime);
}

model DeleteConsumerGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a consumer group.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 * * The name of the consumer group is obtained. For more information, see [ListConsumerGroup](https://help.aliyun.com/document_detail/74964.html).
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:DeleteConsumerGroup`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#logstoreName}/consumergroup/{#ConsumerGroup}`|
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteConsumerGroupResponse
 */
async function deleteConsumerGroupWithOptions(project: string, logstore: string, consumerGroup: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteConsumerGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteConsumerGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups/${consumerGroup}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a consumer group.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 * * The name of the consumer group is obtained. For more information, see [ListConsumerGroup](https://help.aliyun.com/document_detail/74964.html).
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:DeleteConsumerGroup`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#logstoreName}/consumergroup/{#ConsumerGroup}`|
 *
 * @return DeleteConsumerGroupResponse
 */
async function deleteConsumerGroup(project: string, logstore: string, consumerGroup: string): DeleteConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConsumerGroupWithOptions(project, logstore, consumerGroup, headers, runtime);
}

model DeleteDashboardResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a dashboard.
 *
 * @description ### [](#)Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDashboardResponse
 */
async function deleteDashboardWithOptions(project: string, dashboardName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDashboardResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteDashboard',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/dashboards/${dashboardName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a dashboard.
 *
 * @description ### [](#)Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 *
 * @return DeleteDashboardResponse
 */
async function deleteDashboard(project: string, dashboardName: string): DeleteDashboardResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDashboardWithOptions(project, dashboardName, headers, runtime);
}

model DeleteDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a custom domain name that is bound to a project.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDomainResponse
 */
async function deleteDomainWithOptions(project: string, domainName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDomainResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteDomain',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/domains/${domainName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a custom domain name that is bound to a project.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @return DeleteDomainResponse
 */
async function deleteDomain(project: string, domainName: string): DeleteDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDomainWithOptions(project, domainName, headers, runtime);
}

model DeleteDownloadJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a download task.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDownloadJobResponse
 */
async function deleteDownloadJobWithOptions(project: string, downloadJobName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDownloadJobResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteDownloadJob',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/downloadjobs/${downloadJobName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a download task.
 *
 * @return DeleteDownloadJobResponse
 */
async function deleteDownloadJob(project: string, downloadJobName: string): DeleteDownloadJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDownloadJobWithOptions(project, downloadJobName, headers, runtime);
}

model DeleteETLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 删除数据加工任务
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteETLResponse
 */
async function deleteETLWithOptions(project: string, etlName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteETLResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteETL',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/etls/${etlName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 删除数据加工任务
 *
 * @return DeleteETLResponse
 */
async function deleteETL(project: string, etlName: string): DeleteETLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteETLWithOptions(project, etlName, headers, runtime);
}

model DeleteExternalStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes an external store.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteExternalStoreResponse
 */
async function deleteExternalStoreWithOptions(project: string, externalStoreName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteExternalStoreResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteExternalStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/externalstores/${externalStoreName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes an external store.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @return DeleteExternalStoreResponse
 */
async function deleteExternalStore(project: string, externalStoreName: string): DeleteExternalStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteExternalStoreWithOptions(project, externalStoreName, headers, runtime);
}

model DeleteIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes an index of a Logstore.
 *
 * @description ### Usage notes
 * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIndexResponse
 */
async function deleteIndexWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteIndexResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteIndex',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/index`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes an index of a Logstore.
 *
 * @description ### Usage notes
 * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @return DeleteIndexResponse
 */
async function deleteIndex(project: string, logstore: string): DeleteIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteIndexWithOptions(project, logstore, headers, runtime);
}

model DeleteIngestProcessorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes an ingest processor.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIngestProcessorResponse
 */
async function deleteIngestProcessorWithOptions(project: string, processorName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteIngestProcessorResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteIngestProcessor',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ingestprocessors/${processorName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes an ingest processor.
 *
 * @return DeleteIngestProcessorResponse
 */
async function deleteIngestProcessor(project: string, processorName: string): DeleteIngestProcessorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteIngestProcessorWithOptions(project, processorName, headers, runtime);
}

model DeleteLogStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a Logstore, including all shards and indexes in the Logstore.
 *
 * @description ### Usage notes
 * Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteLogStoreResponse
 */
async function deleteLogStoreWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLogStoreResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteLogStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a Logstore, including all shards and indexes in the Logstore.
 *
 * @description ### Usage notes
 * Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
 *
 * @return DeleteLogStoreResponse
 */
async function deleteLogStore(project: string, logstore: string): DeleteLogStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLogStoreWithOptions(project, logstore, headers, runtime);
}

model DeleteLoggingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 关闭项目的服务日志记录。
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteLoggingResponse
 */
async function deleteLoggingWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLoggingResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteLogging',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logging`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 关闭项目的服务日志记录。
 *
 * @return DeleteLoggingResponse
 */
async function deleteLogging(project: string): DeleteLoggingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLoggingWithOptions(project, headers, runtime);
}

model DeleteLogtailPipelineConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a Logtail pipeline configuration.
 *
 * @description The UK (London) region is supported. Supported regions are constantly updated.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteLogtailPipelineConfigResponse
 */
async function deleteLogtailPipelineConfigWithOptions(project: string, configName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLogtailPipelineConfigResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteLogtailPipelineConfig',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/pipelineconfigs/${configName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a Logtail pipeline configuration.
 *
 * @description The UK (London) region is supported. Supported regions are constantly updated.
 *
 * @return DeleteLogtailPipelineConfigResponse
 */
async function deleteLogtailPipelineConfig(project: string, configName: string): DeleteLogtailPipelineConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLogtailPipelineConfigWithOptions(project, configName, headers, runtime);
}

model DeleteMachineGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a machine group. If the Logtail configurations for log collection are applied to a machine group, the configurations are disassociated from the machine group after the machine group is deleted.
 *
 * @description ### Usage notes
 * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMachineGroupResponse
 */
async function deleteMachineGroupWithOptions(project: string, machineGroup: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteMachineGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a machine group. If the Logtail configurations for log collection are applied to a machine group, the configurations are disassociated from the machine group after the machine group is deleted.
 *
 * @description ### Usage notes
 * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @return DeleteMachineGroupResponse
 */
async function deleteMachineGroup(project: string, machineGroup: string): DeleteMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteMachineGroupWithOptions(project, machineGroup, headers, runtime);
}

model DeleteMaxComputeExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a MaxCompute data shipping job.
 *
 * @description *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMaxComputeExportResponse
 */
async function deleteMaxComputeExportWithOptions(project: string, mcExportName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteMaxComputeExportResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteMaxComputeExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/maxcomputeexports/${mcExportName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a MaxCompute data shipping job.
 *
 * @description *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
 *
 * @return DeleteMaxComputeExportResponse
 */
async function deleteMaxComputeExport(project: string, mcExportName: string): DeleteMaxComputeExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteMaxComputeExportWithOptions(project, mcExportName, headers, runtime);
}

model DeleteMetricStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes an existing Metricstore. When you delete a Metricstore, the metric data stored in the Metricstore and associated resources such as associated collection settings and transformation settings are also deleted.
 *
 * @description Metricstores are used to store metric data. For more information, see [Metric data](https://help.aliyun.com/document_detail/174965.html).
 * *   You must specify an existing Metricstore.
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query metric data is obtained. The information includes the name of the project to which the metric data belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 * *   You can create up to 200 Logstores or Metricstores in a project.
 * *   Metric data is automatically deleted when the retention period of the metric data ends.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMetricStoreResponse
 */
async function deleteMetricStoreWithOptions(project: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteMetricStoreResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteMetricStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/metricstores/${name}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'none',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes an existing Metricstore. When you delete a Metricstore, the metric data stored in the Metricstore and associated resources such as associated collection settings and transformation settings are also deleted.
 *
 * @description Metricstores are used to store metric data. For more information, see [Metric data](https://help.aliyun.com/document_detail/174965.html).
 * *   You must specify an existing Metricstore.
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query metric data is obtained. The information includes the name of the project to which the metric data belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 * *   You can create up to 200 Logstores or Metricstores in a project.
 * *   Metric data is automatically deleted when the retention period of the metric data ends.
 *
 * @return DeleteMetricStoreResponse
 */
async function deleteMetricStore(project: string, name: string): DeleteMetricStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteMetricStoreWithOptions(project, name, headers, runtime);
}

model DeleteOSSExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes an Object Storage Service (OSS) data shipping job.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteOSSExportResponse
 */
async function deleteOSSExportWithOptions(project: string, ossExportName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteOSSExportResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteOSSExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossexports/${ossExportName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes an Object Storage Service (OSS) data shipping job.
 *
 * @return DeleteOSSExportResponse
 */
async function deleteOSSExport(project: string, ossExportName: string): DeleteOSSExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteOSSExportWithOptions(project, ossExportName, headers, runtime);
}

model DeleteOSSHDFSExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 删除OSSHDFS投递任务
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteOSSHDFSExportResponse
 */
async function deleteOSSHDFSExportWithOptions(project: string, ossExportName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteOSSHDFSExportResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteOSSHDFSExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/osshdfsexports/${ossExportName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 删除OSSHDFS投递任务
 *
 * @return DeleteOSSHDFSExportResponse
 */
async function deleteOSSHDFSExport(project: string, ossExportName: string): DeleteOSSHDFSExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteOSSHDFSExportWithOptions(project, ossExportName, headers, runtime);
}

model DeleteOSSIngestionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes an Object Storage Service (OSS) data import job.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteOSSIngestionResponse
 */
async function deleteOSSIngestionWithOptions(project: string, ossIngestionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteOSSIngestionResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteOSSIngestion',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossingestions/${ossIngestionName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes an Object Storage Service (OSS) data import job.
 *
 * @return DeleteOSSIngestionResponse
 */
async function deleteOSSIngestion(project: string, ossIngestionName: string): DeleteOSSIngestionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteOSSIngestionWithOptions(project, ossIngestionName, headers, runtime);
}

model DeleteProjectRequest {
  forceDelete?: boolean(name='forceDelete'),
}

model DeleteProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a project.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * After you delete a project, all logs stored in the project and the configurations of the project are deleted and cannot be restored. Proceed with caution.
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:DeleteProject`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}`|
 *
 * @param request DeleteProjectRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteProjectResponse
 */
async function deleteProjectWithOptions(project: string, request: DeleteProjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProjectResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.forceDelete)) {
    query['forceDelete'] = request.forceDelete;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a project.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * After you delete a project, all logs stored in the project and the configurations of the project are deleted and cannot be restored. Proceed with caution.
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:DeleteProject`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}`|
 *
 * @param request DeleteProjectRequest
 * @return DeleteProjectResponse
 */
async function deleteProject(project: string, request: DeleteProjectRequest): DeleteProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProjectWithOptions(project, request, headers, runtime);
}

model DeleteProjectPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a project policy.
 *
 * @description ### [](#)Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteProjectPolicyResponse
 */
async function deleteProjectPolicyWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProjectPolicyResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteProjectPolicy',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/policy`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a project policy.
 *
 * @description ### [](#)Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
 *
 * @return DeleteProjectPolicyResponse
 */
async function deleteProjectPolicy(project: string): DeleteProjectPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProjectPolicyWithOptions(project, headers, runtime);
}

model DeleteSavedSearchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a saved search.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 * * After you delete a saved search, it cannot be restored. Proceed with caution.
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:DeleteSavedSearch`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/savedsearch/{#SavedSearchName}`|
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSavedSearchResponse
 */
async function deleteSavedSearchWithOptions(project: string, savedsearchName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteSavedSearchResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteSavedSearch',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/savedsearches/${savedsearchName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a saved search.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 * * After you delete a saved search, it cannot be restored. Proceed with caution.
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:DeleteSavedSearch`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/savedsearch/{#SavedSearchName}`|
 *
 * @return DeleteSavedSearchResponse
 */
async function deleteSavedSearch(project: string, savedsearchName: string): DeleteSavedSearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSavedSearchWithOptions(project, savedsearchName, headers, runtime);
}

model DeleteScheduledSQLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a Scheduled SQL job.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteScheduledSQLResponse
 */
async function deleteScheduledSQLWithOptions(project: string, scheduledSQLName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteScheduledSQLResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteScheduledSQL',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/scheduledsqls/${scheduledSQLName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a Scheduled SQL job.
 *
 * @return DeleteScheduledSQLResponse
 */
async function deleteScheduledSQL(project: string, scheduledSQLName: string): DeleteScheduledSQLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteScheduledSQLWithOptions(project, scheduledSQLName, headers, runtime);
}

model DeleteStoreViewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a dataset by using the name of the dataset.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteStoreViewResponse
 */
async function deleteStoreViewWithOptions(project: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteStoreViewResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteStoreView',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/storeviews/${name}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a dataset by using the name of the dataset.
 *
 * @return DeleteStoreViewResponse
 */
async function deleteStoreView(project: string, name: string): DeleteStoreViewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteStoreViewWithOptions(project, name, headers, runtime);
}

model DescribeRegionsRequest {
  language?: string(name='language', description='The language of the localName parameter that is returned.

Valid values:

*   ja
*   en
*   zh', example='zh'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      internetEndpoint?: string(name='internetEndpoint', description='The public endpoint of Simple Log Service.'),
      intranetEndpoint?: string(name='intranetEndpoint', description='The internal endpoint of Simple Log Service.'),
      localName?: string(name='localName', description='The name of the Simple Log Service region.'),
      region?: string(name='region', description='SLS region'),
    }
  ](name='regions'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

/**
 * @summary Queries supported regions.
 *
 * @param request DescribeRegionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRegionsResponse
 */
async function describeRegionsWithOptions(request: DescribeRegionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.language)) {
    query['language'] = request.language;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/regions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries supported regions.
 *
 * @param request DescribeRegionsRequest
 * @return DescribeRegionsResponse
 */
async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeRegionsWithOptions(request, headers, runtime);
}

model DisableAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Disables an alert rule.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableAlertResponse
 */
async function disableAlertWithOptions(project: string, alertName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DisableAlertResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DisableAlert',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/alerts/${alertName}?action=disable`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Disables an alert rule.
 *
 * @return DisableAlertResponse
 */
async function disableAlert(project: string, alertName: string): DisableAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return disableAlertWithOptions(project, alertName, headers, runtime);
}

model DisableScheduledSQLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Disables the Scheduled SQL feature.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableScheduledSQLResponse
 */
async function disableScheduledSQLWithOptions(project: string, scheduledSQLName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DisableScheduledSQLResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DisableScheduledSQL',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/scheduledsqls/${scheduledSQLName}?action=disable`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Disables the Scheduled SQL feature.
 *
 * @return DisableScheduledSQLResponse
 */
async function disableScheduledSQL(project: string, scheduledSQLName: string): DisableScheduledSQLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return disableScheduledSQLWithOptions(project, scheduledSQLName, headers, runtime);
}

model EnableAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Enables an alert rule.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableAlertResponse
 */
async function enableAlertWithOptions(project: string, alertName: string, headers: map[string]string, runtime: Util.RuntimeOptions): EnableAlertResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'EnableAlert',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/alerts/${alertName}?action=enable`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Enables an alert rule.
 *
 * @return EnableAlertResponse
 */
async function enableAlert(project: string, alertName: string): EnableAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return enableAlertWithOptions(project, alertName, headers, runtime);
}

model EnableScheduledSQLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Enables the Scheduled SQL feature.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableScheduledSQLResponse
 */
async function enableScheduledSQLWithOptions(project: string, scheduledSQLName: string, headers: map[string]string, runtime: Util.RuntimeOptions): EnableScheduledSQLResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'EnableScheduledSQL',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/scheduledsqls/${scheduledSQLName}?action=enable`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Enables the Scheduled SQL feature.
 *
 * @return EnableScheduledSQLResponse
 */
async function enableScheduledSQL(project: string, scheduledSQLName: string): EnableScheduledSQLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return enableScheduledSQLWithOptions(project, scheduledSQLName, headers, runtime);
}

model GetAgentInstanceConfigResponseBody = {
  config?: string(name='config'),
  configMatcher?: string(name='configMatcher'),
  configName?: string(name='configName'),
  createTime?: long(name='createTime'),
  isGray?: boolean(name='isGray'),
  lastModifyTime?: long(name='lastModifyTime'),
}

model GetAgentInstanceConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAgentInstanceConfigResponseBody(name='body'),
}

/**
 * @summary GetAgentInstanceConfig
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAgentInstanceConfigResponse
 */
async function getAgentInstanceConfigWithOptions(configName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAgentInstanceConfigResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAgentInstanceConfig',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/agentinstanceconfigs/${configName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary GetAgentInstanceConfig
 *
 * @return GetAgentInstanceConfigResponse
 */
async function getAgentInstanceConfig(configName: string): GetAgentInstanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAgentInstanceConfigWithOptions(configName, headers, runtime);
}

model GetAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Alert  
}

/**
 * @summary Queries the information about an alert rule.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAlertResponse
 */
async function getAlertWithOptions(project: string, alertName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAlertResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAlert',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/alerts/${alertName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the information about an alert rule.
 *
 * @return GetAlertResponse
 */
async function getAlert(project: string, alertName: string): GetAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAlertWithOptions(project, alertName, headers, runtime);
}

model GetAnnotationDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MLDataParam  
}

/**
 * @summary Queries data in datasets based on the unique identifier of the data.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAnnotationDataResponse
 */
async function getAnnotationDataWithOptions(datasetId: string, annotationdataId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAnnotationDataResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAnnotationData',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationdataset/${datasetId}/annotationdata/${annotationdataId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries data in datasets based on the unique identifier of the data.
 *
 * @return GetAnnotationDataResponse
 */
async function getAnnotationData(datasetId: string, annotationdataId: string): GetAnnotationDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAnnotationDataWithOptions(datasetId, annotationdataId, headers, runtime);
}

model GetAnnotationDataSetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MLDataSetParam  
}

/**
 * @summary Queries a dataset.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAnnotationDataSetResponse
 */
async function getAnnotationDataSetWithOptions(datasetId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAnnotationDataSetResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAnnotationDataSet',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationdataset/${datasetId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a dataset.
 *
 * @return GetAnnotationDataSetResponse
 */
async function getAnnotationDataSet(datasetId: string): GetAnnotationDataSetResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAnnotationDataSetWithOptions(datasetId, headers, runtime);
}

model GetAnnotationLabelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MLLabelParam  
}

/**
 * @summary Queries a tag table by using a label ID.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAnnotationLabelResponse
 */
async function getAnnotationLabelWithOptions(labelId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAnnotationLabelResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAnnotationLabel',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationlabel/${labelId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a tag table by using a label ID.
 *
 * @return GetAnnotationLabelResponse
 */
async function getAnnotationLabel(labelId: string): GetAnnotationLabelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAnnotationLabelWithOptions(labelId, headers, runtime);
}

model GetAppliedConfigsResponseBody = {
  configs?: [ string ](name='configs', description='The names of the Logtail configurations.'),
  count?: int32(name='count', description='The number of Logtail configurations.', example='2'),
}

model GetAppliedConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAppliedConfigsResponseBody(name='body'),
}

/**
 * @summary Queries the Logtail configurations that are applied to a machine group.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAppliedConfigsResponse
 */
async function getAppliedConfigsWithOptions(project: string, machineGroup: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAppliedConfigsResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAppliedConfigs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}/configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the Logtail configurations that are applied to a machine group.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @return GetAppliedConfigsResponse
 */
async function getAppliedConfigs(project: string, machineGroup: string): GetAppliedConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAppliedConfigsWithOptions(project, machineGroup, headers, runtime);
}

model GetAppliedMachineGroupsResponseBody = {
  count?: int32(name='count', description='The number of returned machine groups.', example='2'),
  machinegroups?: [ string ](name='machinegroups', description='The names of the returned machine groups.', example='[ "sample-group1","sample-group2" ]'),
}

model GetAppliedMachineGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAppliedMachineGroupsResponseBody(name='body'),
}

/**
 * @summary Queries the machine groups to which a Logtail configuration is bound.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAppliedMachineGroupsResponse
 */
async function getAppliedMachineGroupsWithOptions(project: string, configName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAppliedMachineGroupsResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAppliedMachineGroups',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/configs/${configName}/machinegroups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the machine groups to which a Logtail configuration is bound.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @return GetAppliedMachineGroupsResponse
 */
async function getAppliedMachineGroups(project: string, configName: string): GetAppliedMachineGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAppliedMachineGroupsWithOptions(project, configName, headers, runtime);
}

model GetCheckPointRequest {
  shard?: int32(name='shard', description='The shard ID.

*   If the specified shard does not exist, an empty list is returned.
*   If no shard ID is specified, the checkpoints of all shards are returned.', example='1'),
}

model GetCheckPointResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [ 
    {
      shard?: int32(name='shard', description='The shard ID.', example='0'),
      checkpoint?: string(name='checkpoint', description='The value of the checkpoint.', example='MTUyNDE1NTM3OTM3MzkwODQ5Ng=='),
      updateTime?: long(name='updateTime', description='The time when the checkpoint was last updated. The value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1524224984800922'),
      consumer?: string(name='consumer', description='The consumer at the checkpoint.', example='consumer_1'),
    }
  ](name='body'),
}

/**
 * @summary Queries the checkpoints of a shard from which data is consumed by a consumer group.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request GetCheckPointRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCheckPointResponse
 */
async function getCheckPointWithOptions(project: string, logstore: string, consumerGroup: string, request: GetCheckPointRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCheckPointResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.shard)) {
    query['shard'] = request.shard;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCheckPoint',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups/${consumerGroup}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the checkpoints of a shard from which data is consumed by a consumer group.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request GetCheckPointRequest
 * @return GetCheckPointResponse
 */
async function getCheckPoint(project: string, logstore: string, consumerGroup: string, request: GetCheckPointRequest): GetCheckPointResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCheckPointWithOptions(project, logstore, consumerGroup, request, headers, runtime);
}

model GetCollectionPolicyRequest {
  dataCode?: string(name='dataCode', example='access_log'),
  productCode?: string(name='productCode', example='oss'),
}

model GetCollectionPolicyResponseBody = {
  collectionPolicy?: {
    centralizeConfig?: {
      destLogstore?: string(name='destLogstore', example='your-sls-logstore-in-beijing'),
      destProject?: string(name='destProject', example='your-sls-project-in-beijing'),
      destRegion?: string(name='destRegion', example='cn-beijing'),
      destTTL?: int32(name='destTTL', example='your-sls-logstore-ttl'),
    }(name='centralizeConfig'),
    centralizeEnabled?: boolean(name='centralizeEnabled', example='false'),
    dataCode?: string(name='dataCode', example='access_log'),
    dataConfig?: {
      dataProject?: string(name='dataProject', example='""'),
      dataRegion?: string(name='dataRegion', example='cn-beijing'),
    }(name='dataConfig'),
    enabled?: boolean(name='enabled', example='true'),
    internalPolicy?: boolean(name='internalPolicy', example='false'),
    policyConfig?: {
      instanceIds?: [ string ](name='instanceIds'),
      regions?: [ string ](name='regions'),
      resourceMode?: string(name='resourceMode', example='all'),
      resourceTags?: map[string]any(name='resourceTags', example='{"tag1":"value1","tag2":"value2"}'),
    }(name='policyConfig'),
    policyName?: string(name='policyName', example='your_log_policy'),
    policyUid?: string(name='policyUid', example='148***********50'),
    productCode?: string(name='productCode', example='oss'),
    resourceDirectory?: {
      accountGroupType?: string(name='accountGroupType', example='all,custom'),
      members?: [ string ](name='members'),
    }(name='resourceDirectory'),
  }(name='collectionPolicy'),
}

model GetCollectionPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCollectionPolicyResponseBody(name='body'),
}

/**
 * @summary 调用GetCollectionPolicy获取对应的规则
 *
 * @description You must use the Simple Log Service endpoint for the China (Shanghai), Singapore, or Heyuan ACDR Auto region to call the operation.
 *
 * @param request GetCollectionPolicyRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCollectionPolicyResponse
 */
async function getCollectionPolicyWithOptions(policyName: string, request: GetCollectionPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCollectionPolicyResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dataCode)) {
    query['dataCode'] = request.dataCode;
  }
  if (!Util.isUnset(request.productCode)) {
    query['productCode'] = request.productCode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCollectionPolicy',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/collectionpolicy/${policyName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 调用GetCollectionPolicy获取对应的规则
 *
 * @description You must use the Simple Log Service endpoint for the China (Shanghai), Singapore, or Heyuan ACDR Auto region to call the operation.
 *
 * @param request GetCollectionPolicyRequest
 * @return GetCollectionPolicyResponse
 */
async function getCollectionPolicy(policyName: string, request: GetCollectionPolicyRequest): GetCollectionPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCollectionPolicyWithOptions(policyName, request, headers, runtime);
}

model GetConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: LogtailConfig  
}

/**
 * @summary Queries the details of a Logtail configuration.
 *
 * @description ### [](#)Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 * *   The name of the required Logtail configuration is obtained. For more information, see [ListConfig](https://help.aliyun.com/document_detail/29043.html).
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetConfigResponse
 */
async function getConfigWithOptions(project: string, configName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetConfigResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetConfig',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/configs/${configName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the details of a Logtail configuration.
 *
 * @description ### [](#)Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 * *   The name of the required Logtail configuration is obtained. For more information, see [ListConfig](https://help.aliyun.com/document_detail/29043.html).
 *
 * @return GetConfigResponse
 */
async function getConfig(project: string, configName: string): GetConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getConfigWithOptions(project, configName, headers, runtime);
}

model GetContextLogsRequest {
  backLines?: long(name='back_lines', description='The number of logs that you want to obtain and are generated before the generation time of the start log. Valid values: `(0,100]`.

This parameter is required.', example='10'),
  forwardLines?: long(name='forward_lines', description='The number of logs that you want to obtain and are generated after the generation time of the start log. Valid values: `(0,100]`.

This parameter is required.', example='10'),
  packId?: string(name='pack_id', description='The unique identifier of the log group to which the start log belongs.

This parameter is required.', example='85C897C740352DC6-808'),
  packMeta?: string(name='pack_meta', description='The unique context identifier of the start log in the log group.

This parameter is required.', example='2|MTY1NTcwNTUzODY5MTY0MDk1Mg==|3|0'),
}

model GetContextLogsResponseBody = {
  backLines?: long(name='back_lines', description='The number of logs that are generated before the generation time of the start log.', example='100'),
  forwardLines?: long(name='forward_lines', description='The number of logs that are generated after the generation time of the start log.', example='100'),
  logs?: [  map[string]any ](name='logs', description='The logs that are returned.'),
  progress?: string(name='progress', description='Indicates whether the query and analysis results are complete. Valid values:

*   Complete: The query is successful, and the complete query and analysis results are returned.
*   Incomplete: The query is successful, but the query and analysis results are incomplete. To obtain the complete results, you must repeat the request.', example='Complete'),
  totalLines?: long(name='total_lines', description='The total number of logs that are returned. The logs include the start log that is specified in the request.', example='201'),
}

model GetContextLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetContextLogsResponseBody(name='body'),
}

/**
 * @summary Queries the contextual logs of a specified log.
 *
 * @description ### Usage notes
 * * You can specify a log as the start log. The time range of a contextual query is one day before and one day after the generation time of the start log.
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 * * Indexes are configured before you query logs. For more information, see [Create indexes](https://help.aliyun.com/document_detail/90732.html).
 * * The values of the pack_id and pack_meta fields are obtained before you query logs. The fields are internal fields, and you can obtain the values by using the debugging feature of your browser in the Simple Log Service console.
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:GetLogStoreContextLogs`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#LogstoreName}`|
 *
 * @param request GetContextLogsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetContextLogsResponse
 */
async function getContextLogsWithOptions(project: string, logstore: string, request: GetContextLogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetContextLogsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.backLines)) {
    query['back_lines'] = request.backLines;
  }
  if (!Util.isUnset(request.forwardLines)) {
    query['forward_lines'] = request.forwardLines;
  }
  if (!Util.isUnset(request.packId)) {
    query['pack_id'] = request.packId;
  }
  if (!Util.isUnset(request.packMeta)) {
    query['pack_meta'] = request.packMeta;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetContextLogs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}?type=context_log`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the contextual logs of a specified log.
 *
 * @description ### Usage notes
 * * You can specify a log as the start log. The time range of a contextual query is one day before and one day after the generation time of the start log.
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 * * Indexes are configured before you query logs. For more information, see [Create indexes](https://help.aliyun.com/document_detail/90732.html).
 * * The values of the pack_id and pack_meta fields are obtained before you query logs. The fields are internal fields, and you can obtain the values by using the debugging feature of your browser in the Simple Log Service console.
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:GetLogStoreContextLogs`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#LogstoreName}`|
 *
 * @param request GetContextLogsRequest
 * @return GetContextLogsResponse
 */
async function getContextLogs(project: string, logstore: string, request: GetContextLogsRequest): GetContextLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getContextLogsWithOptions(project, logstore, request, headers, runtime);
}

model GetCursorRequest {
  from?: string(name='from', description='The point in time that you want to use to query a cursor. Set the value to a UNIX timestamp or a string such as `begin` and `end`.

This parameter is required.', example='begin'),
}

model GetCursorResponseBody = {
  cursor?: string(name='cursor', description='The value of the cursor.', example='MTQ0NzI5OTYwNjg5NjYzMjM1Ng=='),
}

model GetCursorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCursorResponseBody(name='body'),
}

/**
 * @summary Queries a cursor based on a point in time.
 *
 * @description ### Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   The following content describes the relationships among a cursor, project, Logstore, and shard:
 *     *   A project can have multiple Logstores.
 *     *   A Logstore can have multiple shards.
 *     *   You can use a cursor to obtain a log in a shard.
 *
 * @param request GetCursorRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCursorResponse
 */
async function getCursorWithOptions(project: string, logstore: string, shardId: string, request: GetCursorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCursorResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.from)) {
    query['from'] = request.from;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCursor',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shards/${shardId}?type=cursor`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a cursor based on a point in time.
 *
 * @description ### Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   The following content describes the relationships among a cursor, project, Logstore, and shard:
 *     *   A project can have multiple Logstores.
 *     *   A Logstore can have multiple shards.
 *     *   You can use a cursor to obtain a log in a shard.
 *
 * @param request GetCursorRequest
 * @return GetCursorResponse
 */
async function getCursor(project: string, logstore: string, shardId: string, request: GetCursorRequest): GetCursorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCursorWithOptions(project, logstore, shardId, request, headers, runtime);
}

model GetCursorTimeRequest {
  cursor?: string(name='cursor', description='The cursor.

This parameter is required.', example='MTU0NzQ3MDY4MjM3NjUxMzQ0Ng=='),
}

model GetCursorTimeResponseBody = {
  cursorTime?: string(name='cursor_time', description='The server time that is queried based on the cursor. The value is a UNIX timestamp representing the number of seconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1554260243'),
}

model GetCursorTimeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCursorTimeResponseBody(name='body'),
}

/**
 * @summary Queries the server time of a cursor.
 *
 * @param request GetCursorTimeRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCursorTimeResponse
 */
async function getCursorTimeWithOptions(project: string, logstore: string, shardId: string, request: GetCursorTimeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCursorTimeResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.cursor)) {
    query['cursor'] = request.cursor;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCursorTime',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shards/${shardId}?type=cursor_time`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the server time of a cursor.
 *
 * @param request GetCursorTimeRequest
 * @return GetCursorTimeResponse
 */
async function getCursorTime(project: string, logstore: string, shardId: string, request: GetCursorTimeRequest): GetCursorTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCursorTimeWithOptions(project, logstore, shardId, request, headers, runtime);
}

model GetDashboardResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Dashboard  
}

/**
 * @summary Queries a dashboard.
 *
 * @description ### [](#)Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDashboardResponse
 */
async function getDashboardWithOptions(project: string, dashboardName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetDashboardResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetDashboard',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/dashboards/${dashboardName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a dashboard.
 *
 * @description ### [](#)Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 *
 * @return GetDashboardResponse
 */
async function getDashboard(project: string, dashboardName: string): GetDashboardResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDashboardWithOptions(project, dashboardName, headers, runtime);
}

model GetDownloadJobResponseBody = {
  configuration?: {
    allowInComplete?: boolean(name='allowInComplete', example='true'),
    fromTime?: long(name='fromTime', description='起点时间戳（精确到秒）', example='1722409860'),
    logstore?: string(name='logstore', description='源logstore', example='ali-test-logstore'),
    powerSql?: boolean(name='powerSql', description='是否启用powerSql', example='false'),
    query?: string(name='query', description='查询语句', example='* | select *'),
    sink?: {
      bucket?: string(name='bucket', description='对象存储桶', example='ali-test-oss-bucket'),
      compressionType?: string(name='compressionType', description='压缩格式', example='none'),
      contentType?: string(name='contentType', description='下载文件格式', example='csv'),
      prefix?: string(name='prefix', example='download/'),
      roleArn?: string(name='roleArn', description='下载使用roleArn', example='acs:ram::0123456789:role/aliyunlogdefaultrole'),
      type?: string(name='type', example='AliyunOSS'),
    }(name='sink', description='导出配置'),
    toTime?: long(name='toTime', description='结束时间戳（精确到秒）', example='1722411060'),
  }(name='configuration', description='下载配置'),
  createTime?: string(name='createTime', description='代表创建时间的资源属性字段', example='1722411060'),
  description?: string(name='description', description='任务描述', example='a download job'),
  displayName?: string(name='displayName', description='任务显示名称', example='download-123456'),
  executionDetails?: {
    checkSum?: string(name='checkSum', example='EXSFGSDASDASDG123ASD'),
    errorMessage?: string(name='errorMessage', description='下载错误信息', example='timeout'),
    executeTime?: long(name='executeTime', description='下载执行时间', example='123'),
    filePath?: string(name='filePath', description='下载结果链接', example='https://xxx.csv.zst?xxx'),
    fileSize?: long(name='fileSize', description='下载文件大小', example='123456'),
    logCount?: long(name='logCount', description='下载日志条数', example='123'),
    notice?: string(name='notice'),
    progress?: long(name='progress', description='下载进度', example='100'),
  }(name='executionDetails', description='任务执行细节'),
  name?: string(name='name', description='代表资源名称的资源属性字段', example='download-123'),
  status?: string(name='status', description='The status of the log download task.', example='running'),
}

model GetDownloadJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDownloadJobResponseBody(name='body'),
}

/**
 * @summary Queries the information about a download task.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDownloadJobResponse
 */
async function getDownloadJobWithOptions(project: string, downloadJobName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetDownloadJobResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetDownloadJob',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/downloadjobs/${downloadJobName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the information about a download task.
 *
 * @return GetDownloadJobResponse
 */
async function getDownloadJob(project: string, downloadJobName: string): GetDownloadJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDownloadJobWithOptions(project, downloadJobName, headers, runtime);
}

model GetETLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ETL  
}

/**
 * @summary 获取数据加工任务信息
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetETLResponse
 */
async function getETLWithOptions(project: string, etlName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetETLResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetETL',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/etls/${etlName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 获取数据加工任务信息
 *
 * @return GetETLResponse
 */
async function getETL(project: string, etlName: string): GetETLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getETLWithOptions(project, etlName, headers, runtime);
}

model GetExternalStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExternalStore  
}

/**
 * @summary Queries the details of an external store.
 *
 * @description *   The supported data sources of external stores include Object Storage Service (OSS) buckets and ApsaraDB RDS for MySQL databases in a virtual private cloud (VPC).
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetExternalStoreResponse
 */
async function getExternalStoreWithOptions(project: string, externalStoreName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetExternalStoreResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetExternalStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/externalstores/${externalStoreName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the details of an external store.
 *
 * @description *   The supported data sources of external stores include Object Storage Service (OSS) buckets and ApsaraDB RDS for MySQL databases in a virtual private cloud (VPC).
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @return GetExternalStoreResponse
 */
async function getExternalStore(project: string, externalStoreName: string): GetExternalStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExternalStoreWithOptions(project, externalStoreName, headers, runtime);
}

model GetHistogramsRequest {
  from?: long(name='from', description='The start time of the subinterval. The value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.

This parameter is required.', example='1409529600'),
  query?: string(name='query', description='The search statement. Only search statements are supported. Analytic statements are not supported. For more information about the syntax of search statements, see [Log search overview](https://help.aliyun.com/document_detail/43772.html).', example='with_pack_meta'),
  to?: long(name='to', description='The end time of the subinterval. The value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.

This parameter is required.', example='1409569200'),
  topic?: string(name='topic', description='The topic of the logs.', example='topic'),
}

model GetHistogramsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [ 
    {
      from?: long(name='from', description='The start time of the subinterval. The value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.

The time range that is specified in this operation is a left-closed, right-open interval. The interval includes the start time specified by the from parameter, but does not include the end time specified by the to parameter. If you specify the same value for the from and to parameters, the interval is invalid, and an error message is returned.', example='1409529600'),
      to?: long(name='to', description='The end time of the subinterval. The value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.

The time range that is specified in this operation is a left-closed, right-open interval. The interval includes the start time specified by the from parameter, but does not include the end time specified by the to parameter. If you specify the same value for the from and to parameters, the interval is invalid, and an error message is returned.', example='1409569200'),
      count?: long(name='count', description='The number of logs that are generated within the subinterval.', example='2'),
      progress?: string(name='progress', description='Indicates whether the query and analysis results in the subinterval is complete. Valid values:

Complete: The query is successful, and the complete query and analysis results are returned.

Incomplete: The query is successful, but the query and analysis results are incomplete. To obtain the complete results, you must repeat the request.', example='Complete'),
    }
  ](name='body'),
}

/**
 * @summary Queries the distribution of logs that meet the specified search conditions in a Logstore.
 *
 * @description ### Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   The time range is evenly divided into subintervals in the responses. If the time range that is specified in the request remains unchanged, the subintervals in the responses also remain unchanged.
 * *   If the number of logs in a Logstore significantly changes, Simple Log Service cannot predict the number of times that you must call this operation to obtain the complete result. In this case, you must check the value of the progress parameter in the response of each request and determine whether to call this operation one more time to obtain the complete result. Each time you call this operation, the same number of charge units (CUs) are consumed.
 * *   After a log is written to a Logstore, you can call the GetHistograms or GetLogs operation to query the log after a short latency. The latency of a query varies based on the type of the log. Simple Log Service classifies logs into the following types based on the log time:
 *     *   Real-time data: The difference between the time record in a log and the current time on Simple Log Service is within the interval (-180 seconds,900 seconds]. For example, if a log was generated at 12:03:00, September 25, 2014 (UTC) and Simple Log Service received the log at 12:05:00, September 25, 2014 (UTC), Simple Log Service processes the log as real-time data. After real-time data is written to a Logstore, the data can be queried with a maximum latency of 3 seconds.
 *     *   Historical data: The difference between the time record in a log and the current time on Simple Log Service is within the interval [-604,800 seconds,-180 seconds). For example, if a log was generated at 12:00:00, September 25, 2014 (UTC) and Simple Log Service received the log at 12:05:00, September 25, 2014 (UTC), Simple Log Service processes the log as historical data. This type of log is usually generated in data backfill scenarios.
 *     After real-time data is written to a Logstore, the data can be queried with a maximum latency of 3 seconds. For 99.9% of queries, the latency is no more than 1 second.
 * > Simple Log Service calculates the difference between the log time that is specified by the __time__ field and the receiving time that is specified by the __tag__:__receive_time__ field for each log. The receiving time indicates the time at which Simple Log Service receives the log. If the difference is within the interval (-180 seconds,900 seconds], Simple Log Service processes the log as real-time data. If the difference is within the interval [-604,800 seconds,-180 seconds), Simple Log Service processes the log as historical data.
 * *   Simple Log Service provides examples on how to call the GetHistograms operation by using Simple Log Service SDK for Java. For more information, see [Use GetHistograms to query the distribution of logs](https://help.aliyun.com/document_detail/462234.html).
 *
 * @param request GetHistogramsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetHistogramsResponse
 */
async function getHistogramsWithOptions(project: string, logstore: string, request: GetHistogramsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetHistogramsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.from)) {
    query['from'] = request.from;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }
  if (!Util.isUnset(request.to)) {
    query['to'] = request.to;
  }
  if (!Util.isUnset(request.topic)) {
    query['topic'] = request.topic;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHistograms',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/index?type=histogram`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the distribution of logs that meet the specified search conditions in a Logstore.
 *
 * @description ### Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   The time range is evenly divided into subintervals in the responses. If the time range that is specified in the request remains unchanged, the subintervals in the responses also remain unchanged.
 * *   If the number of logs in a Logstore significantly changes, Simple Log Service cannot predict the number of times that you must call this operation to obtain the complete result. In this case, you must check the value of the progress parameter in the response of each request and determine whether to call this operation one more time to obtain the complete result. Each time you call this operation, the same number of charge units (CUs) are consumed.
 * *   After a log is written to a Logstore, you can call the GetHistograms or GetLogs operation to query the log after a short latency. The latency of a query varies based on the type of the log. Simple Log Service classifies logs into the following types based on the log time:
 *     *   Real-time data: The difference between the time record in a log and the current time on Simple Log Service is within the interval (-180 seconds,900 seconds]. For example, if a log was generated at 12:03:00, September 25, 2014 (UTC) and Simple Log Service received the log at 12:05:00, September 25, 2014 (UTC), Simple Log Service processes the log as real-time data. After real-time data is written to a Logstore, the data can be queried with a maximum latency of 3 seconds.
 *     *   Historical data: The difference between the time record in a log and the current time on Simple Log Service is within the interval [-604,800 seconds,-180 seconds). For example, if a log was generated at 12:00:00, September 25, 2014 (UTC) and Simple Log Service received the log at 12:05:00, September 25, 2014 (UTC), Simple Log Service processes the log as historical data. This type of log is usually generated in data backfill scenarios.
 *     After real-time data is written to a Logstore, the data can be queried with a maximum latency of 3 seconds. For 99.9% of queries, the latency is no more than 1 second.
 * > Simple Log Service calculates the difference between the log time that is specified by the __time__ field and the receiving time that is specified by the __tag__:__receive_time__ field for each log. The receiving time indicates the time at which Simple Log Service receives the log. If the difference is within the interval (-180 seconds,900 seconds], Simple Log Service processes the log as real-time data. If the difference is within the interval [-604,800 seconds,-180 seconds), Simple Log Service processes the log as historical data.
 * *   Simple Log Service provides examples on how to call the GetHistograms operation by using Simple Log Service SDK for Java. For more information, see [Use GetHistograms to query the distribution of logs](https://help.aliyun.com/document_detail/462234.html).
 *
 * @param request GetHistogramsRequest
 * @return GetHistogramsResponse
 */
async function getHistograms(project: string, logstore: string, request: GetHistogramsRequest): GetHistogramsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getHistogramsWithOptions(project, logstore, request, headers, runtime);
}

model GetIndexResponseBody = {
  indexMode?: string(name='index_mode', description='The type of the index.', example='v2'),
  keys?: map[string]IndexKey(name='keys', description='The configurations of field indexes. A field index is in the key-value format in which the key specifies the name of the field and the value specifies the index configuration of the field.'),
  lastModifyTime?: long(name='lastModifyTime', description='The time when the index configurations were last updated. The value is a UNIX timestamp representing the number of seconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1524155379'),
  line?: {
    caseSensitive?: boolean(name='caseSensitive', description='Indicates whether case sensitivity is enabled. Valid values:

*   true
*   false', example='false'),
    chn?: boolean(name='chn', description='Indicates whether Chinese characters are included. Valid values:

*   true
*   false', example='false'),
    excludeKeys?: [ string ](name='exclude_keys', description='The excluded fields.'),
    includeKeys?: [ string ](name='include_keys', description='The included fields.'),
    token?: [ string ](name='token', description='The delimiters.

This parameter is required.'),
  }(name='line', description='The configurations of full-text indexes.'),
  logReduce?: boolean(name='log_reduce', description='Indicates whether the log clustering feature is enabled.', example='false'),
  logReduceBlackList?: [ string ](name='log_reduce_black_list', description='The fields in the blacklist that are used to cluster logs. This parameter is valid only if the log clustering feature is enabled.'),
  logReduceWhiteList?: [ string ](name='log_reduce_white_list', description='The fields in the whitelist that are used to cluster logs. This parameter is valid only if the log clustering feature is enabled.'),
  maxTextLen?: int32(name='max_text_len', description='The maximum length of a field value that can be retained. Default value: 2048. Unit: bytes. The default value is equal to 2 KB. You can change the value of the max_text_len parameter. Valid values: 64 to 16384. Unit: bytes.', example='2048'),
  storage?: string(name='storage', description='The storage type. The value is fixed as pg.', example='pg'),
  ttl?: int32(name='ttl', description='The lifecycle of the index file. Valid values: 7, 30, and 90. Unit: day.

This parameter is required.', example='30'),
}

model GetIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetIndexResponseBody(name='body'),
}

/**
 * @summary Queries the index of a Logstore.
 *
 * @description ### Usage notes
 * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetIndexResponse
 */
async function getIndexWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetIndexResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetIndex',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/index`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the index of a Logstore.
 *
 * @description ### Usage notes
 * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @return GetIndexResponse
 */
async function getIndex(project: string, logstore: string): GetIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getIndexWithOptions(project, logstore, headers, runtime);
}

model GetIngestProcessorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: IngestProcessor  
}

/**
 * @summary Queries an ingest processor.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetIngestProcessorResponse
 */
async function getIngestProcessorWithOptions(project: string, processorName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetIngestProcessorResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetIngestProcessor',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ingestprocessors/${processorName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries an ingest processor.
 *
 * @return GetIngestProcessorResponse
 */
async function getIngestProcessor(project: string, processorName: string): GetIngestProcessorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getIngestProcessorWithOptions(project, processorName, headers, runtime);
}

model GetLogStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Logstore  
}

/**
 * @summary Queries the details of a Logstore.
 *
 * @description ### Usage notes
 * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLogStoreResponse
 */
async function getLogStoreWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLogStoreResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLogStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the details of a Logstore.
 *
 * @description ### Usage notes
 * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @return GetLogStoreResponse
 */
async function getLogStore(project: string, logstore: string): GetLogStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLogStoreWithOptions(project, logstore, headers, runtime);
}

model GetLogStoreMeteringModeResponseBody = {
  meteringMode?: string(name='meteringMode', description='The billing mode. Default value: ChargeByFunction. Valid values: ChargeByFunction and ChargeByDataIngest.', example='ChargeByFunction'),
}

model GetLogStoreMeteringModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLogStoreMeteringModeResponseBody(name='body'),
}

/**
 * @summary Queries the billing mode of a Logstore.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLogStoreMeteringModeResponse
 */
async function getLogStoreMeteringModeWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLogStoreMeteringModeResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLogStoreMeteringMode',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/meteringmode`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the billing mode of a Logstore.
 *
 * @return GetLogStoreMeteringModeResponse
 */
async function getLogStoreMeteringMode(project: string, logstore: string): GetLogStoreMeteringModeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLogStoreMeteringModeWithOptions(project, logstore, headers, runtime);
}

model GetLoggingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Logging  
}

/**
 * @summary Queries the service log configuration of a project.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLoggingResponse
 */
async function getLoggingWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLoggingResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLogging',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logging`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the service log configuration of a project.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @return GetLoggingResponse
 */
async function getLogging(project: string): GetLoggingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLoggingWithOptions(project, headers, runtime);
}

model GetLogsRequest {
  from?: int32(name='from', description='The beginning of the time range to query. The value is the log time that is specified when log data is written.

*   The time range that is specified in this operation is a left-closed, right-open interval. The interval includes the start time specified by the **from** parameter, but does not include the end time specified by the **to** parameter. If you specify the same value for the **from** and **to** parameters, the interval is invalid, and an error message is returned.
*   The value is a UNIX timestamp representing the number of seconds that have elapsed since January 1, 1970, 00:00:00 UTC.

> To ensure that full data can be queried, specify a query time range that is accurate to the minute. If you also specify a time range in an analytic statement, Simple Log Service uses the time range specified in the analytic statement for query and analysis.

If you want to specify a time range that is accurate to the second in your analytic statement, you must use the from_unixtime or to_unixtime function to convert the time format. For more information about the functions, see [from_unixtime function](https://help.aliyun.com/document_detail/63451.html) and [to_unixtime function](https://help.aliyun.com/document_detail/63451.html). Examples:

*   `* | SELECT * FROM log WHERE from_unixtime(__time__) > from_unixtime(1664186624) AND from_unixtime(__time__) < now()`
*   `* | SELECT * FROM log WHERE __time__ > to_unixtime(date_parse(\\\\"2022-10-19 15:46:05\\\\", \\\\"%Y-%m-%d %H:%i:%s\\\\")) AND __time__ < to_unixtime(now())`

This parameter is required.', example='1627268185'),
  line?: long(name='line', description='The maximum number of logs to return for the request. This parameter takes effect only when the query parameter is set to a search statement. Minimum value: 0. Maximum value: 100. Default value: 100. For more information, see [Perform paged queries](https://help.aliyun.com/document_detail/89994.html).', example='100'),
  offset?: long(name='offset', description='The line from which the query starts. This parameter takes effect only when the query parameter is set to a search statement. Default value: 0. For more information, see [Perform paged queries](https://help.aliyun.com/document_detail/89994.html).', example='0'),
  powerSql?: boolean(name='powerSql', description='Specifies whether to enable the Dedicated SQL feature. For more information, see [Enable Dedicated SQL](https://help.aliyun.com/document_detail/223777.html). Valid values:

*   true: enables the Dedicated SQL feature.
*   false (default): enables the Standard SQL feature.

You can use the powerSql or **query** parameter to configure Dedicated SQL.', example='false'),
  query?: string(name='query', description='The search statement or the query statement. For more information, see [Log search overview](https://help.aliyun.com/document_detail/43772.html) and [Log analysis overview](https://help.aliyun.com/document_detail/53608.html). If you add `set session parallel_sql=true;` to the analytic statement in the query parameter, Dedicated SQL is used. For example, you can set the query parameter to `* | set session parallel_sql=true; select count(*) as pv`. For more information about common errors that may occur during log query and analysis, see [How do I resolve common errors that occur when I query and analyze logs?](https://help.aliyun.com/document_detail/61628.html)

> If you specify an analytic statement in the value of the query parameter, the line and offset parameters do not take effect. In this case, we recommend that you set the line and offset parameters to 0 and use the LIMIT clause to limit the number of logs to return on each page. For more information, see [Paged query](https://help.aliyun.com/document_detail/89994.html).', example='status: 401 | SELECT remote_addr,COUNT(*) as pv GROUP by remote_addr ORDER by pv desc limit 5'),
  reverse?: boolean(name='reverse', description='Specifies whether to return logs in reverse chronological order of log timestamps. The log timestamps are accurate to the minute. Valid values:

*   true: returns logs in reverse chronological order of log timestamps.
*   false (default): returns logs in chronological order of log timestamps.

> 

*   The reverse parameter takes effect only when the query parameter is set to a search statement. The reverse parameter specifies the method used to sort returned logs.
*   If the query parameter is set to a query statement, the reverse parameter does not take effect. The method used to sort returned logs is specified by the ORDER BY clause in the analytic statement. If you use the keyword asc in the ORDER BY clause, the logs are sorted in chronological order. If you use the keyword desc in the ORDER BY clause, the logs are sorted in reverse chronological order. By default, asc is used in the ORDER BY clause.', example='false'),
  to?: int32(name='to', description='The end of the time range to query. The value is the log time that is specified when log data is written.

*   The time range that is specified in this operation is a left-closed, right-open interval. The interval includes the start time specified by the **from** parameter, but does not include the end time specified by the **to** parameter. If you specify the same value for the **from** and **to** parameters, the interval is invalid, and an error message is returned.
*   The value is a UNIX timestamp representing the number of seconds that have elapsed since January 1, 1970, 00:00:00 UTC.

> To ensure that full data can be queried, specify a query time range that is accurate to the minute. If you also specify a time range in an analytic statement, Simple Log Service uses the time range specified in the analytic statement for query and analysis.

If you want to specify a time range that is accurate to the second in your analytic statement, you must use the from_unixtime or to_unixtime function to convert the time format. For more information about the functions, see [from_unixtime function](https://help.aliyun.com/document_detail/63451.html) and [to_unixtime function](https://help.aliyun.com/document_detail/63451.html). Examples:

*   `* | SELECT * FROM log WHERE from_unixtime(__time__) > from_unixtime(1664186624) AND from_unixtime(__time__) < now()`
*   `* | SELECT * FROM log WHERE __time__ > to_unixtime(date_parse(\\\\"2022-10-19 15:46:05\\\\", \\\\"%Y-%m-%d %H:%i:%s\\\\")) AND __time__ < to_unixtime(now())`

This parameter is required.', example='1627269085'),
  topic?: string(name='topic', description='The topic of the logs. The default value is an empty string. For more information, see [Topic](https://help.aliyun.com/document_detail/48881.html).', example='topic'),
}

model GetLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [  map[string]any ](name='body'),
}

/**
 * @summary Queries the logs of a Logstore in a project.
 *
 * @description ### Usage notes
 * **Note** Simple Log Service allows you to create a Scheduled SQL job. For more information, see [Create a scheduled SQL job](https://help.aliyun.com/document_detail/286457.html).
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 * * Limits are imposed when you use Simple Log Service to query logs. We recommend that you specify query statements and query time ranges based on the limits. For more information, see [Log search overview](https://help.aliyun.com/document_detail/43772.html) and [Log analysis overview](https://help.aliyun.com/document_detail/53608.html).
 * * Indexes are configured before you query logs. For more information, see [Create indexes](https://help.aliyun.com/document_detail/90732.html).
 * * If the number of logs in a Logstore significantly changes, Simple Log Service cannot predict the number of times that you must call this operation to obtain the complete results. In this case, you must check the value of the x-log-progress parameter in the response of each request and determine whether to call this operation one more time to obtain the complete results. Each time you call this operation, the same number of charge units (CUs) are consumed.
 * * After a log is written to a Logstore, you can call the GetHistograms or the GetLogs operation to query the log. The latency of the query varies based on the type of the log. Simple Log Service classifies logs into the following types based on log timestamps:
 *   * Real-time data: The difference between the time record in a log of this type and the current time on Simple Log Service is within the interval (-180 seconds,900 seconds\\]. For example, if a log was generated at 12:03:00, September 25, 2014 (UTC) and Simple Log Service received the log at 12:05:00, September 25, 2014 (UTC), Simple Log Service processes the log as real-time data. This type of log is usually generated in common scenarios.
 *   * Historical data: The difference between the time record in a log of this type and the current time on Simple Log Service is within the interval [-604,800 seconds,-180 seconds). For example, if a log was generated at 12:00:00, September 25, 2014 (UTC) and Simple Log Service received the log at 12:05:00, September 25, 2014 (UTC), Simple Log Service processes the log as historical data. This type of log is usually generated in data backfill scenarios. After real-time data is written to a Logstore, the data can be queried with an approximate latency of 3 seconds.
 * **Note** Simple Log Service calculates the difference between the log time that is specified by the __time__ field and the receiving time that is specified by the __tag__:**receive_time** field for each log. The receiving time indicates when Simple Log Service receives the log. If the difference is within the interval (-180 seconds,900 seconds\\], Simple Log Service processes the log as real-time data. If the difference is within the interval [-604,800 seconds,-180 seconds), Simple Log Service processes the log as historical data.
 * * Simple Log Service provides examples on how to call the GetLogs operation by using Simple Log Service SDK for Java and Simple Log Service SDK for Python. For more information, see [Examples of calling the GetLogs operation by using Simple Log Service SDK for Java](https://help.aliyun.com/document_detail/407683.html) and [Examples of calling the GetLogs operation by using Simple Log Service SDK for Python](https://help.aliyun.com/document_detail/407684.html).
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:GetLogStoreLogs`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#LogstoreName}`|
 *
 * @param request GetLogsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLogsResponse
 */
async function getLogsWithOptions(project: string, logstore: string, request: GetLogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetLogsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.from)) {
    query['from'] = request.from;
  }
  if (!Util.isUnset(request.line)) {
    query['line'] = request.line;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.powerSql)) {
    query['powerSql'] = request.powerSql;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }
  if (!Util.isUnset(request.reverse)) {
    query['reverse'] = request.reverse;
  }
  if (!Util.isUnset(request.to)) {
    query['to'] = request.to;
  }
  if (!Util.isUnset(request.topic)) {
    query['topic'] = request.topic;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLogs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}?type=log`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the logs of a Logstore in a project.
 *
 * @description ### Usage notes
 * **Note** Simple Log Service allows you to create a Scheduled SQL job. For more information, see [Create a scheduled SQL job](https://help.aliyun.com/document_detail/286457.html).
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 * * Limits are imposed when you use Simple Log Service to query logs. We recommend that you specify query statements and query time ranges based on the limits. For more information, see [Log search overview](https://help.aliyun.com/document_detail/43772.html) and [Log analysis overview](https://help.aliyun.com/document_detail/53608.html).
 * * Indexes are configured before you query logs. For more information, see [Create indexes](https://help.aliyun.com/document_detail/90732.html).
 * * If the number of logs in a Logstore significantly changes, Simple Log Service cannot predict the number of times that you must call this operation to obtain the complete results. In this case, you must check the value of the x-log-progress parameter in the response of each request and determine whether to call this operation one more time to obtain the complete results. Each time you call this operation, the same number of charge units (CUs) are consumed.
 * * After a log is written to a Logstore, you can call the GetHistograms or the GetLogs operation to query the log. The latency of the query varies based on the type of the log. Simple Log Service classifies logs into the following types based on log timestamps:
 *   * Real-time data: The difference between the time record in a log of this type and the current time on Simple Log Service is within the interval (-180 seconds,900 seconds\\]. For example, if a log was generated at 12:03:00, September 25, 2014 (UTC) and Simple Log Service received the log at 12:05:00, September 25, 2014 (UTC), Simple Log Service processes the log as real-time data. This type of log is usually generated in common scenarios.
 *   * Historical data: The difference between the time record in a log of this type and the current time on Simple Log Service is within the interval [-604,800 seconds,-180 seconds). For example, if a log was generated at 12:00:00, September 25, 2014 (UTC) and Simple Log Service received the log at 12:05:00, September 25, 2014 (UTC), Simple Log Service processes the log as historical data. This type of log is usually generated in data backfill scenarios. After real-time data is written to a Logstore, the data can be queried with an approximate latency of 3 seconds.
 * **Note** Simple Log Service calculates the difference between the log time that is specified by the __time__ field and the receiving time that is specified by the __tag__:**receive_time** field for each log. The receiving time indicates when Simple Log Service receives the log. If the difference is within the interval (-180 seconds,900 seconds\\], Simple Log Service processes the log as real-time data. If the difference is within the interval [-604,800 seconds,-180 seconds), Simple Log Service processes the log as historical data.
 * * Simple Log Service provides examples on how to call the GetLogs operation by using Simple Log Service SDK for Java and Simple Log Service SDK for Python. For more information, see [Examples of calling the GetLogs operation by using Simple Log Service SDK for Java](https://help.aliyun.com/document_detail/407683.html) and [Examples of calling the GetLogs operation by using Simple Log Service SDK for Python](https://help.aliyun.com/document_detail/407684.html).
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:GetLogStoreLogs`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#LogstoreName}`|
 *
 * @param request GetLogsRequest
 * @return GetLogsResponse
 */
async function getLogs(project: string, logstore: string, request: GetLogsRequest): GetLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLogsWithOptions(project, logstore, request, headers, runtime);
}

model GetLogsV2Headers {
  commonHeaders?: map[string]string,
  acceptEncoding?: string(name='Accept-Encoding', description='The compression format.

*   For Java, Python, and Go, only the lz4 and gzip algorithms are supported for decompression.
*   For PHP, JavaScript, and C#, only the gzip algorithm is supported for decompression.

This parameter is required.', example='lz4'),
}

model GetLogsV2Request {
  forward?: boolean(name='forward', description='Specifies whether to page forward or backward for the scan-based query or phrase search.', example='false'),
  from?: int32(name='from', description='The beginning of the time range to query. The value is the log time that is specified when log data is written.

The time range that is specified in this operation is a left-closed, right-open interval. The interval includes the start time specified by the from parameter, but does not include the end time specified by the to parameter. If you specify the same value for the from and to parameters, the interval is invalid, and an error message is returned. The value is a timestamp that follows the UNIX time format. It is the number of seconds that have elapsed since January 1, 1970, 00:00:00 UTC.

This parameter is required.', example='1627268185'),
  highlight?: boolean(name='highlight', description='Specifies whether to highlight the returned result.', example='false'),
  line?: long(name='line', description='The maximum number of logs to return for the request. This parameter takes effect only when the query parameter is set to a search statement. Valid values: 0 to 100. Default value: 100.', example='100'),
  offset?: long(name='offset', description='The line from which the query starts. This parameter takes effect only when the query parameter is set to a search statement. Default value: 0.', example='0'),
  powerSql?: boolean(name='powerSql', description='Specifies whether to enable the SQL enhancement feature. By default, the feature is disabled.', example='false'),
  query?: string(name='query', description='The search statement or query statement. For more information, see the "Log search overview" and "Log analysis overview" topics.

If you add set session parallel_sql=true; to the analytic statement in the query parameter, Dedicated SQL is used. Example: \\\\* | set session parallel_sql=true; select count(\\\\*) as pv.

Note: If you specify an analytic statement in the query parameter, the line and offset parameters do not take effect in this operation. In this case, we recommend that you set the line and offset parameters to 0 and use the LIMIT clause to specify the number of logs to return on each page. For more information, see the "Perform paged queries" topic.', example='status: 401 | SELECT remote_addr,COUNT(*) as pv GROUP by remote_addr ORDER by pv desc limit 5'),
  reverse?: boolean(name='reverse', description='Specifies whether to return logs in reverse chronological order of log timestamps. The log timestamps are accurate to minutes. Valid values:

true: Logs are returned in reverse chronological order of log timestamps. false (default): Logs are returned in chronological order of log timestamps. Note: The reverse parameter takes effect only when the query parameter is set to a search statement. The reverse parameter specifies the method used to sort returned logs. If the query parameter is set to a query statement, the reverse parameter does not take effect. The method used to sort returned logs is specified by the ORDER BY clause in the analytic statement. If you use the keyword asc in the ORDER BY clause, the logs are sorted in chronological order. If you use the keyword desc in the ORDER BY clause, the logs are sorted in reverse chronological order. By default, asc is used in the ORDER BY clause.', example='false'),
  session?: string(name='session', description='The parameter that is used to query data.', example='mode=scan'),
  to?: int32(name='to', description='The end of the time range to query. The value is the log time that is specified when log data is written.

The time range that is specified in this operation is a left-closed, right-open interval. The interval includes the start time specified by the from parameter, but does not include the end time specified by the to parameter. If you specify the same value for the from and to parameters, the interval is invalid, and an error message is returned. The value is a timestamp that follows the UNIX time format. It is the number of seconds that have elapsed since January 1, 1970, 00:00:00 UTC.

This parameter is required.', example='1627268185'),
  topic?: string(name='topic', description='The topic of the logs. Default value: double quotation marks ("").', example='""'),
}

model GetLogsV2ResponseBody = {
  data?: [ map[string]string ](name='data', description='The returned result.'),
  meta?: {
    aggQuery?: string(name='aggQuery', description='The SQL statement after | in the query statement.', example='select *'),
    columnTypes?: [ string ](name='columnTypes'),
    count?: int32(name='count', description='The number of rows that are returned.', example='1'),
    cpuCores?: int32(name='cpuCores', example='3'),
    cpuSec?: double(name='cpuSec', example='0.002'),
    elapsedMillisecond?: long(name='elapsedMillisecond', description='The amount of time that is consumed by the request. Unit: milliseconds.', example='5'),
    hasSQL?: boolean(name='hasSQL', description='Indicates whether the query is an SQL query.', example='false'),
    highlights?: [[
      LogContent
    ]    ](name='highlights'),
    isAccurate?: boolean(name='isAccurate', description='Indicates whether the returned result is accurate to seconds.', example='true'),
    keys?: [ string ](name='keys', description='All keys in the query result.'),
    limited?: int32(name='limited', example='100'),
    mode?: int32(name='mode', example='0'),
    phraseQueryInfo?: {
      beginOffset?: long(name='beginOffset', example='0'),
      endOffset?: long(name='endOffset', example='0'),
      endTime?: long(name='endTime', example='1'),
      scanAll?: boolean(name='scanAll', example='true'),
    }(name='phraseQueryInfo'),
    processedBytes?: long(name='processedBytes', description='The number of logs that are processed in the request.', example='10000'),
    processedRows?: long(name='processedRows', description='The number of rows that are processed in the request.', example='10000'),
    progress?: string(name='progress', description='Indicates whether the query result is complete. Valid values:

*   Complete: The query was successful, and the complete result is returned.
*   Incomplete: The query was successful, but the query result is incomplete. To obtain the complete result, you must call the operation again.', example='Complete'),
    scanBytes?: long(name='scanBytes', example='1024'),
    telementryType?: string(name='telementryType', description='The type of observable data.', example='None'),
    terms?: [  map[string]any ](name='terms', description='All terms in the query statement.'),
    whereQuery?: string(name='whereQuery', description='The part before | in the query statement.', example='*'),
  }(name='meta', description='The metadata of the returned data.'),
}

model GetLogsV2Response = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLogsV2ResponseBody(name='body'),
}

/**
 * @summary Queries the raw log data in a Logstore of a project. The returned result contains the raw log data within a specific time range. The returned result is compressed before transmission.
 *
 * @description *   You can call this operation by using Alibaba Cloud SDK for Go, Java, TypeScript, or Python.
 * *   You can call this operation by using Simple Log Service SDK for Go or Java.
 * *   For more information, see [GetLogs](https://help.aliyun.com/document_detail/29029.html).
 *
 * @param request GetLogsV2Request
 * @param headers GetLogsV2Headers
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLogsV2Response
 */
async function getLogsV2WithOptions(project: string, logstore: string, request: GetLogsV2Request, headers: GetLogsV2Headers, runtime: Util.RuntimeOptions): GetLogsV2Response {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.forward)) {
    body['forward'] = request.forward;
  }
  if (!Util.isUnset(request.from)) {
    body['from'] = request.from;
  }
  if (!Util.isUnset(request.highlight)) {
    body['highlight'] = request.highlight;
  }
  if (!Util.isUnset(request.line)) {
    body['line'] = request.line;
  }
  if (!Util.isUnset(request.offset)) {
    body['offset'] = request.offset;
  }
  if (!Util.isUnset(request.powerSql)) {
    body['powerSql'] = request.powerSql;
  }
  if (!Util.isUnset(request.query)) {
    body['query'] = request.query;
  }
  if (!Util.isUnset(request.reverse)) {
    body['reverse'] = request.reverse;
  }
  if (!Util.isUnset(request.session)) {
    body['session'] = request.session;
  }
  if (!Util.isUnset(request.to)) {
    body['to'] = request.to;
  }
  if (!Util.isUnset(request.topic)) {
    body['topic'] = request.topic;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.acceptEncoding)) {
    realHeaders['Accept-Encoding'] = Util.toJSONString(headers.acceptEncoding);
  }
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetLogsV2',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/logs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the raw log data in a Logstore of a project. The returned result contains the raw log data within a specific time range. The returned result is compressed before transmission.
 *
 * @description *   You can call this operation by using Alibaba Cloud SDK for Go, Java, TypeScript, or Python.
 * *   You can call this operation by using Simple Log Service SDK for Go or Java.
 * *   For more information, see [GetLogs](https://help.aliyun.com/document_detail/29029.html).
 *
 * @param request GetLogsV2Request
 * @return GetLogsV2Response
 */
async function getLogsV2(project: string, logstore: string, request: GetLogsV2Request): GetLogsV2Response {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetLogsV2Headers{};
  return getLogsV2WithOptions(project, logstore, request, headers, runtime);
}

model GetLogtailPipelineConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: LogtailPipelineConfig  
}

/**
 * @summary Queries the information about a Logtail pipeline configuration.
 *
 * @description The UK (London) region is supported. Supported regions are constantly updated.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLogtailPipelineConfigResponse
 */
async function getLogtailPipelineConfigWithOptions(project: string, configName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLogtailPipelineConfigResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLogtailPipelineConfig',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/pipelineconfigs/${configName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the information about a Logtail pipeline configuration.
 *
 * @description The UK (London) region is supported. Supported regions are constantly updated.
 *
 * @return GetLogtailPipelineConfigResponse
 */
async function getLogtailPipelineConfig(project: string, configName: string): GetLogtailPipelineConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLogtailPipelineConfigWithOptions(project, configName, headers, runtime);
}

model GetMLServiceResultsRequest {
  allowBuiltin?: boolean(name='allowBuiltin', example='true'),
  body?: MLServiceAnalysisParam(name='body'),
  version?: string(name='version', description='The version of the algorithm. The algorithm varies based on the version.', example='v1'),
}

model GetMLServiceResultsResponseBody = {
  data?: [ map[string]string ](name='data'),
  status?: map[string]string(name='status'),
}

model GetMLServiceResultsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMLServiceResultsResponseBody(name='body'),
}

/**
 * @summary Simple Log Service provides intelligent analysis capabilities that can be used to analyze basic data such as logs, metrics, and traces. You can call the GetMLServiceResults operation to obtain the analysis results of a model. You can call the operation in the following scenarios: Named Entity Recognition (NER) tasks on logs, anomaly detection on time series, and root cause analysis on high-latency traces.
 *
 * @description You must obtain the following basic permissions before you call this operation:
 *     {
 *         "Version": "1",
 *         "Statement": [
 *             {
 *                 "Action": [
 *                     "log:Get*"
 *                 ],
 *                 "Resource": [
 *                     "acs:log:*:*:mlservice/sls_builtin_*"
 *                 ],
 *                 "Effect": "Allow"
 *             }
 *         ]
 *     }
 *
 * @param request GetMLServiceResultsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMLServiceResultsResponse
 */
async function getMLServiceResultsWithOptions(serviceName: string, request: GetMLServiceResultsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetMLServiceResultsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.allowBuiltin)) {
    query['allowBuiltin'] = request.allowBuiltin;
  }
  if (!Util.isUnset(request.version)) {
    query['version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'GetMLServiceResults',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/service/${serviceName}/analysis`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Simple Log Service provides intelligent analysis capabilities that can be used to analyze basic data such as logs, metrics, and traces. You can call the GetMLServiceResults operation to obtain the analysis results of a model. You can call the operation in the following scenarios: Named Entity Recognition (NER) tasks on logs, anomaly detection on time series, and root cause analysis on high-latency traces.
 *
 * @description You must obtain the following basic permissions before you call this operation:
 *     {
 *         "Version": "1",
 *         "Statement": [
 *             {
 *                 "Action": [
 *                     "log:Get*"
 *                 ],
 *                 "Resource": [
 *                     "acs:log:*:*:mlservice/sls_builtin_*"
 *                 ],
 *                 "Effect": "Allow"
 *             }
 *         ]
 *     }
 *
 * @param request GetMLServiceResultsRequest
 * @return GetMLServiceResultsResponse
 */
async function getMLServiceResults(serviceName: string, request: GetMLServiceResultsRequest): GetMLServiceResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMLServiceResultsWithOptions(serviceName, request, headers, runtime);
}

model GetMachineGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MachineGroup  
}

/**
 * @summary Queries the details of a machine group.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMachineGroupResponse
 */
async function getMachineGroupWithOptions(project: string, machineGroup: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetMachineGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the details of a machine group.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @return GetMachineGroupResponse
 */
async function getMachineGroup(project: string, machineGroup: string): GetMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMachineGroupWithOptions(project, machineGroup, headers, runtime);
}

model GetMaxComputeExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MaxComputeExport  
}

/**
 * @summary Queries a MaxCompute data shipping job.
 *
 * @description *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMaxComputeExportResponse
 */
async function getMaxComputeExportWithOptions(project: string, mcExportName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetMaxComputeExportResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetMaxComputeExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/maxcomputeexports/${mcExportName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a MaxCompute data shipping job.
 *
 * @description *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
 *
 * @return GetMaxComputeExportResponse
 */
async function getMaxComputeExport(project: string, mcExportName: string): GetMaxComputeExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMaxComputeExportWithOptions(project, mcExportName, headers, runtime);
}

model GetMetricStoreResponseBody = {
  autoSplit?: boolean(name='autoSplit', description='Indicates whether the automatic sharding feature is enabled.', example='true'),
  createTime?: long(name='createTime', description='The creation time. The value is a UNIX timestamp.', example='1698933894'),
  hotTtl?: int32(name='hot_ttl'),
  infrequentAccessTTL?: int32(name='infrequentAccessTTL'),
  lastModifyTime?: long(name='lastModifyTime', description='The last update time. The value is a UNIX timestamp.', example='1712023974'),
  maxSplitShard?: int32(name='maxSplitShard', description='The maximum number of shards into which existing shards can be automatically split.', example='64'),
  metricType?: string(name='metricType', description='The metric type of the Metricstore. Example: prometheus.', example='prometheus'),
  mode?: string(name='mode', description='The specification type of the Metricstore. Example: standard.', example='standard'),
  name?: string(name='name', description='The name of the Metricstore.', example='my_metric_store'),
  shardCount?: int32(name='shardCount', description='The number of shards.', example='2'),
  ttl?: int32(name='ttl', description='The retention period. Unit: days.', example='7'),
}

model GetMetricStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMetricStoreResponseBody(name='body'),
}

/**
 * @summary Queries a Metricstore.
 *
 * @description Metricstores are used to store metric data. For more information about Metricstores, see [Metricstores](https://help.aliyun.com/document_detail/171723.html). For more information about metric data, see [Metric data](https://help.aliyun.com/document_detail/174965.html). You can call this operation to query the settings of a Metricstore. To query the metric data in a Metricstore, see [Query and analysis](https://help.aliyun.com/document_detail/174968.html) and [GetLogsV2](https://help.aliyun.com/document_detail/2771318.html).
 * *   You must specify an existing Metricstore.
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query metric data is obtained. The information includes the name of the project to which the metric data belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 * *   You can create up to 200 Logstores or Metricstores in a project.
 * *   Metric data is automatically deleted when the retention period of the metric data ends.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMetricStoreResponse
 */
async function getMetricStoreWithOptions(project: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetMetricStoreResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetMetricStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/metricstores/${name}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'none',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a Metricstore.
 *
 * @description Metricstores are used to store metric data. For more information about Metricstores, see [Metricstores](https://help.aliyun.com/document_detail/171723.html). For more information about metric data, see [Metric data](https://help.aliyun.com/document_detail/174965.html). You can call this operation to query the settings of a Metricstore. To query the metric data in a Metricstore, see [Query and analysis](https://help.aliyun.com/document_detail/174968.html) and [GetLogsV2](https://help.aliyun.com/document_detail/2771318.html).
 * *   You must specify an existing Metricstore.
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query metric data is obtained. The information includes the name of the project to which the metric data belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 * *   You can create up to 200 Logstores or Metricstores in a project.
 * *   Metric data is automatically deleted when the retention period of the metric data ends.
 *
 * @return GetMetricStoreResponse
 */
async function getMetricStore(project: string, name: string): GetMetricStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMetricStoreWithOptions(project, name, headers, runtime);
}

model GetMetricStoreMeteringModeResponseBody = {
  meteringMode?: string(name='meteringMode', description='The billing mode. Default value: ChargeByFunction. Valid values: ChargeByFunction and ChargeByDataIngest.', example='ChargeByFunction'),
}

model GetMetricStoreMeteringModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMetricStoreMeteringModeResponseBody(name='body'),
}

/**
 * @summary Queries the billing mode of a Metricstore.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMetricStoreMeteringModeResponse
 */
async function getMetricStoreMeteringModeWithOptions(project: string, metricStore: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetMetricStoreMeteringModeResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetMetricStoreMeteringMode',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/metricstores/${metricStore}/meteringmode`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the billing mode of a Metricstore.
 *
 * @return GetMetricStoreMeteringModeResponse
 */
async function getMetricStoreMeteringMode(project: string, metricStore: string): GetMetricStoreMeteringModeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMetricStoreMeteringModeWithOptions(project, metricStore, headers, runtime);
}

model GetOSSExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OSSExport  
}

/**
 * @summary 获取OSS投递任务
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOSSExportResponse
 */
async function getOSSExportWithOptions(project: string, ossExportName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetOSSExportResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetOSSExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossexports/${ossExportName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 获取OSS投递任务
 *
 * @return GetOSSExportResponse
 */
async function getOSSExport(project: string, ossExportName: string): GetOSSExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getOSSExportWithOptions(project, ossExportName, headers, runtime);
}

model GetOSSHDFSExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OSSExport  
}

/**
 * @summary Get OSSHDFS Exports
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOSSHDFSExportResponse
 */
async function getOSSHDFSExportWithOptions(project: string, ossExportName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetOSSHDFSExportResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetOSSHDFSExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/osshdfsexports/${ossExportName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Get OSSHDFS Exports
 *
 * @return GetOSSHDFSExportResponse
 */
async function getOSSHDFSExport(project: string, ossExportName: string): GetOSSHDFSExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getOSSHDFSExportWithOptions(project, ossExportName, headers, runtime);
}

model GetOSSIngestionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OSSIngestion  
}

/**
 * @summary Queries the information about an Object Storage Service (OSS) data import job.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOSSIngestionResponse
 */
async function getOSSIngestionWithOptions(project: string, ossIngestionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetOSSIngestionResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetOSSIngestion',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossingestions/${ossIngestionName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the information about an Object Storage Service (OSS) data import job.
 *
 * @return GetOSSIngestionResponse
 */
async function getOSSIngestion(project: string, ossIngestionName: string): GetOSSIngestionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getOSSIngestionWithOptions(project, ossIngestionName, headers, runtime);
}

model GetProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Project  
}

/**
 * @summary Queries the details of a project.
 *
 * @description ### Usage notes
 * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetProjectResponse
 */
async function getProjectWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetProjectResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the details of a project.
 *
 * @description ### Usage notes
 * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @return GetProjectResponse
 */
async function getProject(project: string): GetProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProjectWithOptions(project, headers, runtime);
}

model GetProjectLogsRequest {
  powerSql?: boolean(name='powerSql', description='Specifies whether to enable the Dedicated SQL feature. For more information, see [Enable Dedicated SQL](https://help.aliyun.com/document_detail/223777.html). Valid values:

*   true
*   false (default): enables the Standard SQL feature.

You can use the powerSql or **query** parameter to configure Dedicated SQL.', example='false'),
  query?: string(name='query', description='The standard SQL statement. In this example, the SQL statement queries the number of page views (PVs) from 2022-03-01 10:41:40 to 2022-03-01 10:56:40 in a Logstore whose name is nginx-moni.

This parameter is required.', example='SELECT COUNT(*) as pv FROM nginx-moni where __time__ &gt; 1646102500 and __time__ &lt; 1646103400'),
}

model GetProjectLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [ map[string]string ](name='body'),
}

/**
 * @summary Queries logs in a project. You can use this operation to query logs at the project level.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 * * Indexes are configured before you query logs. For more information, see [Create indexes](https://help.aliyun.com/document_detail/90732.html).
 * * Limits are imposed when you use Simple Log Service to query logs. We recommend that you specify query statements and query time ranges based on the limits. For more information, see [Log search overview](https://help.aliyun.com/document_detail/43772.html) and [Log analysis overview](https://help.aliyun.com/document_detail/53608.html).
 * * You must set query to a standard SQL statement.
 * * You must specify a Logstore in the FROM clause of an SQL statement. A Logstore can be used as an SQL table.
 * * You must specify a time range in an SQL statement by using the __date__ or __time__ parameter. The value of the __date__ parameter is a timestamp. The value of the __time__ parameter is an integer, and the unit of the value is seconds.
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:GetProjectLogs`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}`|
 *
 * @param request GetProjectLogsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetProjectLogsResponse
 */
async function getProjectLogsWithOptions(project: string, request: GetProjectLogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProjectLogsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.powerSql)) {
    query['powerSql'] = request.powerSql;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProjectLogs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries logs in a project. You can use this operation to query logs at the project level.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 * * Indexes are configured before you query logs. For more information, see [Create indexes](https://help.aliyun.com/document_detail/90732.html).
 * * Limits are imposed when you use Simple Log Service to query logs. We recommend that you specify query statements and query time ranges based on the limits. For more information, see [Log search overview](https://help.aliyun.com/document_detail/43772.html) and [Log analysis overview](https://help.aliyun.com/document_detail/53608.html).
 * * You must set query to a standard SQL statement.
 * * You must specify a Logstore in the FROM clause of an SQL statement. A Logstore can be used as an SQL table.
 * * You must specify a time range in an SQL statement by using the __date__ or __time__ parameter. The value of the __date__ parameter is a timestamp. The value of the __time__ parameter is an integer, and the unit of the value is seconds.
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:GetProjectLogs`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}`|
 *
 * @param request GetProjectLogsRequest
 * @return GetProjectLogsResponse
 */
async function getProjectLogs(project: string, request: GetProjectLogsRequest): GetProjectLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProjectLogsWithOptions(project, request, headers, runtime);
}

model GetProjectPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: string(name='body'),
}

/**
 * @summary Queries a project policy.
 *
 * @description ### [](#)Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetProjectPolicyResponse
 */
async function getProjectPolicyWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetProjectPolicyResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetProjectPolicy',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/policy`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'string',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a project policy.
 *
 * @description ### [](#)Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
 *
 * @return GetProjectPolicyResponse
 */
async function getProjectPolicy(project: string): GetProjectPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProjectPolicyWithOptions(project, headers, runtime);
}

model GetSavedSearchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SavedSearch  
}

/**
 * @summary Queries a saved search.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 * * You can call the ListSavedSearch operation to query the name of a saved search.
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:GetSavedSearch`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/savedsearch/{#SavedSearchName}`|
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSavedSearchResponse
 */
async function getSavedSearchWithOptions(project: string, savedsearchName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetSavedSearchResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetSavedSearch',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/savedsearches/${savedsearchName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a saved search.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 * * You can call the ListSavedSearch operation to query the name of a saved search.
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:GetSavedSearch`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/savedsearch/{#SavedSearchName}`|
 *
 * @return GetSavedSearchResponse
 */
async function getSavedSearch(project: string, savedsearchName: string): GetSavedSearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSavedSearchWithOptions(project, savedsearchName, headers, runtime);
}

model GetScheduledSQLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ScheduledSQL  
}

/**
 * @summary Queries the information about a Scheduled SQL job.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetScheduledSQLResponse
 */
async function getScheduledSQLWithOptions(project: string, scheduledSQLName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetScheduledSQLResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetScheduledSQL',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/scheduledsqls/${scheduledSQLName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the information about a Scheduled SQL job.
 *
 * @return GetScheduledSQLResponse
 */
async function getScheduledSQL(project: string, scheduledSQLName: string): GetScheduledSQLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getScheduledSQLWithOptions(project, scheduledSQLName, headers, runtime);
}

model GetSlsServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ServiceStatus  
}

/**
 * @summary Queries the activation status of Simple Log Service. You must use the endpoint for Simple Log Service only in the China (Shanghai) or Singapore region.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSlsServiceResponse
 */
async function getSlsServiceWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): GetSlsServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetSlsService',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/slsservice`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the activation status of Simple Log Service. You must use the endpoint for Simple Log Service only in the China (Shanghai) or Singapore region.
 *
 * @return GetSlsServiceResponse
 */
async function getSlsService(): GetSlsServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSlsServiceWithOptions(headers, runtime);
}

model GetSqlInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [ 
    {
      name?: string(name='name', example='project_name'),
      cu?: int32(name='cu', example='2'),
      createTime?: int32(name='createTime', example='1710230272'),
      updateTime?: int32(name='updateTime', example='1710230272'),
      useAsDefault?: boolean(name='useAsDefault', example='true'),
    }
  ](name='body'),
}

/**
 * @summary Queries the configurations of the Dedicated SQL feature.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSqlInstanceResponse
 */
async function getSqlInstanceWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetSqlInstanceResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetSqlInstance',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/sqlinstance`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the configurations of the Dedicated SQL feature.
 *
 * @return GetSqlInstanceResponse
 */
async function getSqlInstance(project: string): GetSqlInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSqlInstanceWithOptions(project, headers, runtime);
}

model GetStoreViewResponseBody = {
  storeType?: string(name='storeType', description='The type of the dataset.

Valid values:

*   metricstore

    <!-- -->

    <!-- -->

    <!-- -->

*   logstore

    <!-- -->

    <!-- -->

    <!-- -->', example='logstore'),
  stores?: [
    StoreViewStore
  ](name='stores', description='The Logstores or Metricstores.'),
}

model GetStoreViewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetStoreViewResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of a dataset by using the name of the dataset.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetStoreViewResponse
 */
async function getStoreViewWithOptions(project: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetStoreViewResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetStoreView',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/storeviews/${name}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the configurations of a dataset by using the name of the dataset.
 *
 * @return GetStoreViewResponse
 */
async function getStoreView(project: string, name: string): GetStoreViewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getStoreViewWithOptions(project, name, headers, runtime);
}

model GetStoreViewIndexResponseBody = {
  indexes?: [ 
    {
      index?: Index(name='index', description='The index configurations of the Logstore.'),
      logstore?: string(name='logstore', description='The name of the Logstore.', example='my-logstore'),
      project?: string(name='project', description='The name of the project to which the Logstore belongs.', example='example-project'),
    }
  ](name='indexes', description='The index configurations.'),
}

model GetStoreViewIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetStoreViewIndexResponseBody(name='body'),
}

/**
 * @summary Queries the indexes of a dataset by using the name of the dataset. Only datasets of the logstore type are supported.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetStoreViewIndexResponse
 */
async function getStoreViewIndexWithOptions(project: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetStoreViewIndexResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetStoreViewIndex',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/storeviews/${name}/index`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the indexes of a dataset by using the name of the dataset. Only datasets of the logstore type are supported.
 *
 * @return GetStoreViewIndexResponse
 */
async function getStoreViewIndex(project: string, name: string): GetStoreViewIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getStoreViewIndexWithOptions(project, name, headers, runtime);
}

model ListAgentInstanceConfigsRequest {
  offset?: long(name='offset'),
  size?: long(name='size'),
}

model ListAgentInstanceConfigsResponseBody = {
  configs?: [ string ](name='configs'),
  size?: long(name='size'),
  total?: long(name='total'),
}

model ListAgentInstanceConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAgentInstanceConfigsResponseBody(name='body'),
}

/**
 * @summary ListAgentInstanceConfigs
 *
 * @param request ListAgentInstanceConfigsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAgentInstanceConfigsResponse
 */
async function listAgentInstanceConfigsWithOptions(request: ListAgentInstanceConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAgentInstanceConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAgentInstanceConfigs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/agentinstanceconfigs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary ListAgentInstanceConfigs
 *
 * @param request ListAgentInstanceConfigsRequest
 * @return ListAgentInstanceConfigsResponse
 */
async function listAgentInstanceConfigs(request: ListAgentInstanceConfigsRequest): ListAgentInstanceConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAgentInstanceConfigsWithOptions(request, headers, runtime);
}

model ListAiToolsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [ 
    {
      fields?: [ 
        {
          name?: string(name='name'),
          option?: [ string ](name='option'),
          required?: boolean(name='required'),
          type?: string(name='type'),
          example?: string(name='example'),
          description?: string(name='description'),
        }
      ](name='fields'),
      name?: string(name='name'),
      description?: string(name='description'),
    }
  ](name='body'),
}

/**
 * @summary 获取 ai 工具列表
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAiToolsResponse
 */
async function listAiToolsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListAiToolsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListAiTools',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/tool/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 获取 ai 工具列表
 *
 * @return ListAiToolsResponse
 */
async function listAiTools(): ListAiToolsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAiToolsWithOptions(headers, runtime);
}

model ListAlertsRequest {
  logstore?: string(name='logstore', example='ali-test-logstore'),
  offset?: int32(name='offset', example='0'),
  size?: int32(name='size', description='The number of entries per page. Maximum value: 200. Default value: 10.', example='10'),
}

model ListAlertsResponseBody = {
  count?: int32(name='count', description='The number of alert rules that are returned.', example='10'),
  results?: [
    Alert
  ](name='results', description='The alert rules.'),
  total?: int32(name='total', description='The total number of alert rules in the project.', example='80'),
}

model ListAlertsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAlertsResponseBody(name='body'),
}

/**
 * @summary Queries a list of alert rules in a project.
 *
 * @param request ListAlertsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAlertsResponse
 */
async function listAlertsWithOptions(project: string, request: ListAlertsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAlertsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.logstore)) {
    query['logstore'] = request.logstore;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAlerts',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/alerts`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a list of alert rules in a project.
 *
 * @param request ListAlertsRequest
 * @return ListAlertsResponse
 */
async function listAlerts(project: string, request: ListAlertsRequest): ListAlertsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAlertsWithOptions(project, request, headers, runtime);
}

model ListAnnotationDataRequest {
  offset?: int32(name='offset', description='The line from which the query starts.', example='0'),
  size?: int32(name='size', description='The number of entries per page.', example='100'),
}

model ListAnnotationDataResponseBody = {
  data?: [
    MLDataParam
  ](name='data', description='The data returned.'),
  total?: int32(name='total', description='The total number of entries returned.', example='20'),
}

model ListAnnotationDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAnnotationDataResponseBody(name='body'),
}

/**
 * @summary Queries data in datasets.
 *
 * @param request ListAnnotationDataRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAnnotationDataResponse
 */
async function listAnnotationDataWithOptions(datasetId: string, request: ListAnnotationDataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAnnotationDataResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAnnotationData',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationdataset/${datasetId}/annotationdata`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries data in datasets.
 *
 * @param request ListAnnotationDataRequest
 * @return ListAnnotationDataResponse
 */
async function listAnnotationData(datasetId: string, request: ListAnnotationDataRequest): ListAnnotationDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAnnotationDataWithOptions(datasetId, request, headers, runtime);
}

model ListAnnotationDataSetsRequest {
  offset?: int32(name='offset', description='The line from which the query starts.', example='0'),
  size?: int32(name='size', description='The number of entries per page.', example='100'),
}

model ListAnnotationDataSetsResponseBody = {
  data?: [
    MLDataSetParam
  ](name='data', description='The data returned.'),
  total?: int32(name='total', description='The total number of entries returned.', example='20'),
}

model ListAnnotationDataSetsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAnnotationDataSetsResponseBody(name='body'),
}

/**
 * @summary Queries a list of datasets.
 *
 * @param request ListAnnotationDataSetsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAnnotationDataSetsResponse
 */
async function listAnnotationDataSetsWithOptions(request: ListAnnotationDataSetsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAnnotationDataSetsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAnnotationDataSets',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationdataset`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a list of datasets.
 *
 * @param request ListAnnotationDataSetsRequest
 * @return ListAnnotationDataSetsResponse
 */
async function listAnnotationDataSets(request: ListAnnotationDataSetsRequest): ListAnnotationDataSetsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAnnotationDataSetsWithOptions(request, headers, runtime);
}

model ListAnnotationLabelsRequest {
  offset?: int32(name='offset', description='The line from which the query starts.', example='0'),
  size?: int32(name='size', description='The number of entries per page.', example='100'),
}

model ListAnnotationLabelsResponseBody = {
  data?: [
    MLLabelParam
  ](name='data', description='The data returned.'),
  total?: int32(name='total', description='The total number of tags that meet the query conditions.', example='20'),
}

model ListAnnotationLabelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAnnotationLabelsResponseBody(name='body'),
}

/**
 * @summary Queries a list of tag tables.
 *
 * @param request ListAnnotationLabelsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAnnotationLabelsResponse
 */
async function listAnnotationLabelsWithOptions(request: ListAnnotationLabelsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAnnotationLabelsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAnnotationLabels',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationlabel`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a list of tag tables.
 *
 * @param request ListAnnotationLabelsRequest
 * @return ListAnnotationLabelsResponse
 */
async function listAnnotationLabels(request: ListAnnotationLabelsRequest): ListAnnotationLabelsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAnnotationLabelsWithOptions(request, headers, runtime);
}

model ListCollectionPoliciesRequest {
  centralProject?: string(name='centralProject', example='your-central-project1'),
  dataCode?: string(name='dataCode', example='access_log'),
  instanceId?: string(name='instanceId', example='your-test-bucket1'),
  offset?: int32(name='offset', example='0'),
  policyName?: string(name='policyName', example='your_log_policy'),
  productCode?: string(name='productCode', description='The code of the service.', example='oss'),
  size?: int32(name='size', example='50'),
}

model ListCollectionPoliciesResponseBody = {
  currentCount?: int32(name='currentCount', example='1'),
  data?: [ 
    {
      centralizeConfig?: {
        destLogstore?: string(name='destLogstore', example='your-sls-logstore-in-beijing'),
        destProject?: string(name='destProject', example='your-sls-project-in-beijing'),
        destRegion?: string(name='destRegion', example='cn-beijing'),
        destTTL?: int32(name='destTTL', description='The data retention period for centralized storage. Unit: days.', example='your-sls-logstore-ttl'),
      }(name='centralizeConfig', description='The configuration for centralized storage.'),
      centralizeEnabled?: boolean(name='centralizeEnabled', example='false'),
      dataCode?: string(name='dataCode', example='access_log'),
      dataConfig?: {
        dataProject?: string(name='dataProject', example='""'),
        dataRegion?: string(name='dataRegion', example='cn-hangzhou'),
      }(name='dataConfig'),
      enabled?: boolean(name='enabled', example='true'),
      internalPolicy?: boolean(name='internalPolicy', example='false'),
      policyConfig?: {
        instanceIds?: [ string ](name='instanceIds'),
        regions?: [ string ](name='regions'),
        resourceMode?: string(name='resourceMode', example='all'),
        resourceTags?: map[string]any(name='resourceTags', example='{"tag1":"value1","tag2":"value2"}'),
      }(name='policyConfig'),
      policyName?: string(name='policyName', example='your_log_policy'),
      policyUid?: string(name='policyUid', example='148***********50'),
      productCode?: string(name='productCode', example='oss'),
      resourceDirectory?: {
        accountGroupType?: string(name='accountGroupType', example='all,custom'),
        members?: [ string ](name='members'),
      }(name='resourceDirectory'),
    }
  ](name='data', description='The data of the policies that are matched against the query conditions. The data is returned based on paginated results.'),
  statistics?: [ 
    {
      policySourceList?: [ 
        {
          policyName?: string(name='policyName', example='policy_name1_from148'),
          policyUid?: string(name='policyUid', example='148***********50'),
        }
      ](name='policySourceList'),
      productCode?: string(name='productCode', example='oss'),
    }
  ](name='statistics'),
  totalCount?: int32(name='totalCount', example='1'),
}

model ListCollectionPoliciesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCollectionPoliciesResponseBody(name='body'),
}

/**
 * @summary Queries a list of log collection policies for cloud services.
 *
 * @description You must use the Simple Log Service endpoint for the China (Shanghai), Singapore, or Heyuan ACDR Auto region to call the operation.
 *
 * @param request ListCollectionPoliciesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCollectionPoliciesResponse
 */
async function listCollectionPoliciesWithOptions(request: ListCollectionPoliciesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListCollectionPoliciesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.centralProject)) {
    query['centralProject'] = request.centralProject;
  }
  if (!Util.isUnset(request.dataCode)) {
    query['dataCode'] = request.dataCode;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.policyName)) {
    query['policyName'] = request.policyName;
  }
  if (!Util.isUnset(request.productCode)) {
    query['productCode'] = request.productCode;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCollectionPolicies',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/collectionpolicy`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a list of log collection policies for cloud services.
 *
 * @description You must use the Simple Log Service endpoint for the China (Shanghai), Singapore, or Heyuan ACDR Auto region to call the operation.
 *
 * @param request ListCollectionPoliciesRequest
 * @return ListCollectionPoliciesResponse
 */
async function listCollectionPolicies(request: ListCollectionPoliciesRequest): ListCollectionPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listCollectionPoliciesWithOptions(request, headers, runtime);
}

model ListConfigRequest {
  configName?: string(name='configName', description='The name of the Logtail configuration, which is used for fuzzy match.', example='logtail-config-sample'),
  logstoreName?: string(name='logstoreName', description='The name of the Logstore.

This parameter is required.', example='ali-test-logstore'),
  offset?: long(name='offset', description='The line from which the query starts. Default value: 0.

This parameter is required.', example='0'),
  size?: long(name='size', description='The number of entries per page. Maximum value: 500.

This parameter is required.', example='10'),
}

model ListConfigResponseBody = {
  configs?: [ string ](name='configs', description='The Logtail configurations that are returned on the current page.'),
  count?: int32(name='count', description='The number of Logtail configurations that are returned on the current page.', example='3'),
  total?: int32(name='total', description='The total number of Logtail configurations that meet the query conditions.', example='2'),
}

model ListConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListConfigResponseBody(name='body'),
}

/**
 * @summary Queries all Logtail configurations in a project.
 *
 * @description ### [](#)Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 *
 * @param request ListConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListConfigResponse
 */
async function listConfigWithOptions(project: string, request: ListConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListConfigResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.configName)) {
    query['configName'] = request.configName;
  }
  if (!Util.isUnset(request.logstoreName)) {
    query['logstoreName'] = request.logstoreName;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListConfig',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries all Logtail configurations in a project.
 *
 * @description ### [](#)Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 *
 * @param request ListConfigRequest
 * @return ListConfigResponse
 */
async function listConfig(project: string, request: ListConfigRequest): ListConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConfigWithOptions(project, request, headers, runtime);
}

model ListConsumerGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [
    ConsumerGroup
  ](name='body'),
}

/**
 * @summary Queries all consumer groups of a Logstore.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:ListConsumerGroup`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#LogstoreName}/consumergroup/*`|
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListConsumerGroupResponse
 */
async function listConsumerGroupWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListConsumerGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListConsumerGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries all consumer groups of a Logstore.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:ListConsumerGroup`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#LogstoreName}/consumergroup/*`|
 *
 * @return ListConsumerGroupResponse
 */
async function listConsumerGroup(project: string, logstore: string): ListConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConsumerGroupWithOptions(project, logstore, headers, runtime);
}

model ListDashboardRequest {
  offset?: int32(name='offset', description='The line from which the query starts. Default value: 0.', example='0'),
  size?: int32(name='size', description='The number of entries per page. Maximum value: 500. Default value: 500.', example='10'),
}

model ListDashboardResponseBody = {
  dashboardItems?: [ 
    {
      dashboardName?: string(name='dashboardName', description='The dashboard ID. The ID must be unique in a project. Fuzzy search is supported. For example, if you enter da, all dashboards whose IDs start with da are queried.', example='dashboard-1609294922657-434834'),
      displayName?: string(name='displayName', description='The display name of the dashboard.', example='data-ingest'),
    }
  ](name='dashboardItems', description='The details of the dashboard.'),
  dashboards?: [ string ](name='dashboards', description='The queried dashboards. Each dashboard in the array is specified by dashboardName.'),
}

model ListDashboardResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDashboardResponseBody(name='body'),
}

/**
 * @summary Queries a list of dashboards.
 *
 * @description ### [](#)Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 *
 * @param request ListDashboardRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDashboardResponse
 */
async function listDashboardWithOptions(project: string, request: ListDashboardRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDashboardResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDashboard',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/dashboards`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a list of dashboards.
 *
 * @description ### [](#)Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 *
 * @param request ListDashboardRequest
 * @return ListDashboardResponse
 */
async function listDashboard(project: string, request: ListDashboardRequest): ListDashboardResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDashboardWithOptions(project, request, headers, runtime);
}

model ListDomainsRequest {
  domainName?: string(name='domainName', description='The domain name that is used to match custom domain names. For example, if you set domainName to `example.com`, the matched domain names are `a.example.com` and `b.example.com`.', example='example.com'),
  offset?: int32(name='offset', description='The line from which the query starts. Default value: 0.', example='0'),
  size?: int32(name='size', description='The number of entries per page. Default value: 500. Maximum value: 500.', example='10'),
}

model ListDomainsResponseBody = {
  count?: long(name='count', description='The number of domain names that are returned on the current page.', example='1'),
  domains?: [ string ](name='domains', description='The domain names.'),
  total?: long(name='total', description='The total number of domain names that are returned.', example='1'),
}

model ListDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDomainsResponseBody(name='body'),
}

/**
 * @summary Queries the custom domain names that are bound to projects.
 *
 * @description *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   Only one custom domain name can be bound to each project.
 *
 * @param request ListDomainsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDomainsResponse
 */
async function listDomainsWithOptions(project: string, request: ListDomainsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDomainsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.domainName)) {
    query['domainName'] = request.domainName;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDomains',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/domains`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the custom domain names that are bound to projects.
 *
 * @description *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   Only one custom domain name can be bound to each project.
 *
 * @param request ListDomainsRequest
 * @return ListDomainsResponse
 */
async function listDomains(project: string, request: ListDomainsRequest): ListDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDomainsWithOptions(project, request, headers, runtime);
}

model ListDownloadJobsRequest {
  logstore?: string(name='logstore', example='ali-test-logstore'),
  offset?: long(name='offset', example='0'),
  size?: long(name='size', example='10'),
}

model ListDownloadJobsResponseBody = {
  count?: int32(name='count', example='10'),
  results?: [ 
    {
      configuration?: {
        allowInComplete?: string(name='allowInComplete', example='false'),
        fromTime?: long(name='fromTime', description='起点时间戳（精确到秒）', example='1722409260'),
        logstore?: string(name='logstore', description='源logstore', example='ali-test-logstore'),
        powerSql?: boolean(name='powerSql', description='是否启用powerSql', example='true'),
        query?: string(name='query', description='查询语句', example='* | select *'),
        sink?: {
          bucket?: string(name='bucket', description='对象存储桶', example='ali-test-oss-bucket'),
          compressionType?: string(name='compressionType', description='压缩格式', example='none'),
          contentType?: string(name='contentType', description='下载文件格式', example='csv'),
          prefix?: string(name='prefix', example='download/'),
          roleArn?: string(name='roleArn', description='下载使用roleArn', example='acs:ram::123456:role/aliyunlogimportossrole'),
          type?: string(name='type', example='AliyunOSS'),
        }(name='sink', description='导出配置'),
        toTime?: long(name='toTime', description='结束时间戳（精确到秒）', example='1722411060'),
      }(name='configuration', description='下载配置'),
      createTime?: string(name='createTime', example='1722411060'),
      description?: string(name='description', description='任务描述', example='a download job'),
      displayName?: string(name='displayName', description='任务显示名称', example='download-123'),
      executionDetails?: {
        checkSum?: string(name='checkSum', example='ETASFGASDASQWDasd'),
        errorMessage?: string(name='errorMessage', description='下载错误信息', example='timeout'),
        executeTime?: long(name='executeTime', description='下载执行时间', example='123'),
        filePath?: string(name='filePath', description='下载结果链接', example='https://sls-downloaded-xxxx.csv.gzip?Expiresxxx'),
        fileSize?: long(name='fileSize', description='下载文件大小', example='123456'),
        logCount?: long(name='logCount', description='下载日志条数', example='123'),
        notice?: string(name='notice'),
        progress?: long(name='progress', description='下载进度', example='100'),
      }(name='executionDetails', description='任务执行细节'),
      name?: string(name='name', description='代表资源名称的资源属性字段', example='download-123'),
      status?: string(name='status', description='The task status.', example='running'),
    }
  ](name='results', description='The log download tasks.'),
  total?: int32(name='total', example='10'),
}

model ListDownloadJobsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDownloadJobsResponseBody(name='body'),
}

/**
 * @summary 列举下载任务
 *
 * @param request ListDownloadJobsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDownloadJobsResponse
 */
async function listDownloadJobsWithOptions(project: string, request: ListDownloadJobsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDownloadJobsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.logstore)) {
    query['logstore'] = request.logstore;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDownloadJobs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/downloadjobs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 列举下载任务
 *
 * @param request ListDownloadJobsRequest
 * @return ListDownloadJobsResponse
 */
async function listDownloadJobs(project: string, request: ListDownloadJobsRequest): ListDownloadJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDownloadJobsWithOptions(project, request, headers, runtime);
}

model ListETLsRequest {
  logstore?: string(name='logstore'),
  offset?: int32(name='offset', example='0'),
  size?: int32(name='size', example='10'),
}

model ListETLsResponseBody = {
  count?: int32(name='count'),
  results?: [
    ETL
  ](name='results'),
  total?: int32(name='total'),
}

model ListETLsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListETLsResponseBody(name='body'),
}

/**
 * @summary 列出数据加工任务
 *
 * @param request ListETLsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListETLsResponse
 */
async function listETLsWithOptions(project: string, request: ListETLsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListETLsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.logstore)) {
    query['logstore'] = request.logstore;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListETLs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/etls`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 列出数据加工任务
 *
 * @param request ListETLsRequest
 * @return ListETLsResponse
 */
async function listETLs(project: string, request: ListETLsRequest): ListETLsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listETLsWithOptions(project, request, headers, runtime);
}

model ListIngestProcessorsRequest {
  displayName?: string(name='displayName', description='The display name of the ingest processor.'),
  offset?: int32(name='offset', description='The offset. Default value: 0.', example='0'),
  processorName?: string(name='processorName', description='The identifier of the ingest processor.', example='parse-nginx-log'),
  size?: int32(name='size', description='The number of entries. Default value: 200.', example='200'),
}

model ListIngestProcessorsResponseBody = {
  count?: int32(name='count', description='The number of entries returned.', example='5'),
  processors?: [
    IngestProcessor
  ](name='processors', description='The ingest processors that are returned.'),
  total?: int32(name='total', description='The total number of entries returned.', example='10'),
}

model ListIngestProcessorsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListIngestProcessorsResponseBody(name='body'),
}

/**
 * @summary Queries a list of ingest processors that meet specific conditions.
 *
 * @param request ListIngestProcessorsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListIngestProcessorsResponse
 */
async function listIngestProcessorsWithOptions(project: string, request: ListIngestProcessorsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListIngestProcessorsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.displayName)) {
    query['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.processorName)) {
    query['processorName'] = request.processorName;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListIngestProcessors',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ingestprocessors`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a list of ingest processors that meet specific conditions.
 *
 * @param request ListIngestProcessorsRequest
 * @return ListIngestProcessorsResponse
 */
async function listIngestProcessors(project: string, request: ListIngestProcessorsRequest): ListIngestProcessorsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIngestProcessorsWithOptions(project, request, headers, runtime);
}

model ListLogStoresRequest {
  logstoreName?: string(name='logstoreName', description='The name of the Logstore. Fuzzy match is supported. For example, if you enter test, Logstores whose name contains test are returned.', example='my-logstore'),
  mode?: string(name='mode', description='The type of the Logstore. Valid values: standard and query.

*   **standard**: Standard Logstore. This type of Logstore supports the log analysis feature and is suitable for scenarios such as real-time monitoring and interactive analysis. You can also use this type of Logstore to build a comprehensive observability system.
*   **query**: Query Logstore. This type of Logstore supports high-performance queries. The index traffic fee of a Query Logstore is approximately half that of a Standard Logstore. Query Logstores do not support SQL analysis. Query Logstores are suitable for scenarios in which the volume of data is large, the log retention period is long, or log analysis is not required. Log retention periods of weeks or months are considered long.', example='standard'),
  offset?: int32(name='offset', description='The line from which the query starts. Default value: 0.', example='0'),
  size?: int32(name='size', description='The number of entries per page. Maximum value: 500. Default value: 200.', example='10'),
  telemetryType?: string(name='telemetryType', description='The type of the data that you want to query. Valid values:

*   None: logs
*   Metrics: metrics', example='None'),
}

model ListLogStoresResponseBody = {
  count?: int32(name='count', description='The number of entries returned on the current page.', example='2'),
  logstores?: [ string ](name='logstores', description='The Logstores that meet the query conditions.', example='["test-1","test-2"]'),
  total?: int32(name='total', description='The number of the Logstores that meet the query conditions.', example='2'),
}

model ListLogStoresResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLogStoresResponseBody(name='body'),
}

/**
 * @summary Queries all Logstores or Logstores that match specific conditions in a project.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:ListLogStores`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/*`|
 *
 * @param request ListLogStoresRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListLogStoresResponse
 */
async function listLogStoresWithOptions(project: string, request: ListLogStoresRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLogStoresResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.logstoreName)) {
    query['logstoreName'] = request.logstoreName;
  }
  if (!Util.isUnset(request.mode)) {
    query['mode'] = request.mode;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.telemetryType)) {
    query['telemetryType'] = request.telemetryType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLogStores',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries all Logstores or Logstores that match specific conditions in a project.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:ListLogStores`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/*`|
 *
 * @param request ListLogStoresRequest
 * @return ListLogStoresResponse
 */
async function listLogStores(project: string, request: ListLogStoresRequest): ListLogStoresResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLogStoresWithOptions(project, request, headers, runtime);
}

model ListLogtailPipelineConfigRequest {
  configName?: string(name='configName', description='The name of the Logtail pipeline configuration.', example='logtail-config-sample'),
  logstoreName?: string(name='logstoreName', description='The name of the Logstore.', example='test-logstore'),
  offset?: long(name='offset', description='The line from which the query starts.', example='0'),
  size?: long(name='size', description='The number of Logtail pipeline configurations per page.', example='20'),
}

model ListLogtailPipelineConfigResponseBody = {
  configs?: [ string ](name='configs', description='The Logtail pipeline configurations that are returned on the current page.'),
  count?: int32(name='count', description='The number of Logtail pipeline configurations that are returned on the current page.', example='10'),
  total?: int32(name='total', description='The total number of Logtail pipeline configurations in the current project.', example='20'),
}

model ListLogtailPipelineConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLogtailPipelineConfigResponseBody(name='body'),
}

/**
 * @summary Queries a list of Logtail pipeline configurations that meet the specified conditions.
 *
 * @description The UK (London) region is supported. Supported regions are constantly updated.
 *
 * @param request ListLogtailPipelineConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListLogtailPipelineConfigResponse
 */
async function listLogtailPipelineConfigWithOptions(project: string, request: ListLogtailPipelineConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLogtailPipelineConfigResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.configName)) {
    query['configName'] = request.configName;
  }
  if (!Util.isUnset(request.logstoreName)) {
    query['logstoreName'] = request.logstoreName;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLogtailPipelineConfig',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/pipelineconfigs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a list of Logtail pipeline configurations that meet the specified conditions.
 *
 * @description The UK (London) region is supported. Supported regions are constantly updated.
 *
 * @param request ListLogtailPipelineConfigRequest
 * @return ListLogtailPipelineConfigResponse
 */
async function listLogtailPipelineConfig(project: string, request: ListLogtailPipelineConfigRequest): ListLogtailPipelineConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLogtailPipelineConfigWithOptions(project, request, headers, runtime);
}

model ListMachineGroupRequest {
  groupName?: string(name='groupName', description='The name of the machine group. This parameter is used to filter machine groups. Partial match is supported.', example='test-machine-group'),
  offset?: int32(name='offset', description='The line from which the query starts. Default value: 0.', example='1'),
  size?: int32(name='size', description='The number of entries per page. Maximum value: 500.', example='10'),
}

model ListMachineGroupResponseBody = {
  count?: int32(name='count', description='The number of machine groups that are returned on the current page.', example='2'),
  machinegroups?: [ string ](name='machinegroups', description='The machine groups that meet the query conditions.', example='[ "test-machine-group-1", "test-machine-group-2" ]'),
  total?: int32(name='total', description='The total number of machine groups that meet the query conditions.', example='2'),
}

model ListMachineGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMachineGroupResponseBody(name='body'),
}

/**
 * @summary Queries the machine groups of a project.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request ListMachineGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMachineGroupResponse
 */
async function listMachineGroupWithOptions(project: string, request: ListMachineGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMachineGroupResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.groupName)) {
    query['groupName'] = request.groupName;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the machine groups of a project.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request ListMachineGroupRequest
 * @return ListMachineGroupResponse
 */
async function listMachineGroup(project: string, request: ListMachineGroupRequest): ListMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMachineGroupWithOptions(project, request, headers, runtime);
}

model ListMachinesRequest {
  offset?: int32(name='offset', description='The line from which the query starts. Default value: 0.', example='0'),
  size?: int32(name='size', description='The number of entries per page. Default value: 100. Maximum value: 500.', example='10'),
}

model ListMachinesResponseBody = {
  count?: int32(name='count', description='The number of machines that are returned on the current page.', example='3'),
  machines?: [
    Machine
  ](name='machines', description='The machines that are returned.'),
  total?: int32(name='total', description='The total number of machines.', example='8'),
}

model ListMachinesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMachinesResponseBody(name='body'),
}

/**
 * @summary Queries a list of machines that are connected to Simple Log Service in a specified machine group.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request ListMachinesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMachinesResponse
 */
async function listMachinesWithOptions(project: string, machineGroup: string, request: ListMachinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMachinesResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMachines',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}/machines`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a list of machines that are connected to Simple Log Service in a specified machine group.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request ListMachinesRequest
 * @return ListMachinesResponse
 */
async function listMachines(project: string, machineGroup: string, request: ListMachinesRequest): ListMachinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMachinesWithOptions(project, machineGroup, request, headers, runtime);
}

model ListMaxComputeExportsRequest {
  logstore?: string(name='logstore', example='my-logstore'),
  offset?: int32(name='offset', example='0'),
  size?: int32(name='size', description='The number of entries to return. Default value: 10.', example='100'),
}

model ListMaxComputeExportsResponseBody = {
  count?: int32(name='count', example='2'),
  results?: [
    MaxComputeExport
  ](name='results'),
  total?: int32(name='total', example='10'),
}

model ListMaxComputeExportsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMaxComputeExportsResponseBody(name='body'),
}

/**
 * @summary Queries a list of MaxCompute data shipping jobs.
 *
 * @description *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
 *
 * @param request ListMaxComputeExportsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMaxComputeExportsResponse
 */
async function listMaxComputeExportsWithOptions(project: string, request: ListMaxComputeExportsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMaxComputeExportsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.logstore)) {
    query['logstore'] = request.logstore;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMaxComputeExports',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/maxcomputeexports`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a list of MaxCompute data shipping jobs.
 *
 * @description *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
 *
 * @param request ListMaxComputeExportsRequest
 * @return ListMaxComputeExportsResponse
 */
async function listMaxComputeExports(project: string, request: ListMaxComputeExportsRequest): ListMaxComputeExportsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMaxComputeExportsWithOptions(project, request, headers, runtime);
}

model ListMetricStoresRequest {
  mode?: string(name='mode', description='The type of the Metricstore. For example, you can set the parameter to standard to query Standard Metricstores.', example='standard'),
  name?: string(name='name', description='The name of the Metricstore. Fuzzy search is supported. If you do not specify this parameter, all Metricstores are involved.', example='metric_store'),
  offset?: int32(name='offset', description='The start position of the query.', example='0'),
  size?: int32(name='size', description='The number of entries per page.', example='500'),
}

model ListMetricStoresResponseBody = {
  count?: int32(name='count', description='The total number of entries returned.', example='10'),
  metricstores?: [ string ](name='metricstores', description='The names of the Metricstores.'),
  total?: int32(name='total', description='The total number of queried Metricstores.', example='100'),
}

model ListMetricStoresResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMetricStoresResponseBody(name='body'),
}

/**
 * @summary Queries the list of Metricstores in a project. You can use fuzzy search to query the Metricstores by Metricstore name.
 *
 * @description *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query metric data is obtained. The information includes the name of the project to which the metric data belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 *
 * @param request ListMetricStoresRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMetricStoresResponse
 */
async function listMetricStoresWithOptions(project: string, request: ListMetricStoresRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMetricStoresResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.mode)) {
    query['mode'] = request.mode;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMetricStores',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/metricstores`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'none',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the list of Metricstores in a project. You can use fuzzy search to query the Metricstores by Metricstore name.
 *
 * @description *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query metric data is obtained. The information includes the name of the project to which the metric data belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 *
 * @param request ListMetricStoresRequest
 * @return ListMetricStoresResponse
 */
async function listMetricStores(project: string, request: ListMetricStoresRequest): ListMetricStoresResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMetricStoresWithOptions(project, request, headers, runtime);
}

model ListOSSExportsRequest {
  logstore?: string(name='logstore'),
  offset?: int32(name='offset', example='0'),
  size?: int32(name='size', description='The number of entries to return. Default value: 10.', example='100'),
}

model ListOSSExportsResponseBody = {
  count?: int32(name='count', example='2'),
  results?: [
    OSSExport
  ](name='results'),
  total?: int32(name='total', example='10'),
}

model ListOSSExportsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOSSExportsResponseBody(name='body'),
}

/**
 * @summary 列出OSS投递任务
 *
 * @param request ListOSSExportsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOSSExportsResponse
 */
async function listOSSExportsWithOptions(project: string, request: ListOSSExportsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListOSSExportsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.logstore)) {
    query['logstore'] = request.logstore;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOSSExports',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossexports`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 列出OSS投递任务
 *
 * @param request ListOSSExportsRequest
 * @return ListOSSExportsResponse
 */
async function listOSSExports(project: string, request: ListOSSExportsRequest): ListOSSExportsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listOSSExportsWithOptions(project, request, headers, runtime);
}

model ListOSSHDFSExportsRequest {
  logstore?: string(name='logstore'),
  offset?: int32(name='offset', example='0'),
  size?: int32(name='size', description='The number of entries to return. Default value: 10.', example='100'),
}

model ListOSSHDFSExportsResponseBody = {
  count?: int32(name='count', example='2'),
  results?: [
    OSSExport
  ](name='results'),
  total?: int32(name='total', example='10'),
}

model ListOSSHDFSExportsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOSSHDFSExportsResponseBody(name='body'),
}

/**
 * @summary 列举OSSHDFS投递任务
 *
 * @param request ListOSSHDFSExportsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOSSHDFSExportsResponse
 */
async function listOSSHDFSExportsWithOptions(project: string, request: ListOSSHDFSExportsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListOSSHDFSExportsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.logstore)) {
    query['logstore'] = request.logstore;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOSSHDFSExports',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/osshdfsexports`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 列举OSSHDFS投递任务
 *
 * @param request ListOSSHDFSExportsRequest
 * @return ListOSSHDFSExportsResponse
 */
async function listOSSHDFSExports(project: string, request: ListOSSHDFSExportsRequest): ListOSSHDFSExportsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listOSSHDFSExportsWithOptions(project, request, headers, runtime);
}

model ListOSSIngestionsRequest {
  logstore?: string(name='logstore'),
  offset?: int32(name='offset', example='0'),
  size?: int32(name='size', example='10'),
}

model ListOSSIngestionsResponseBody = {
  count?: int32(name='count', description='The number of OSS data import jobs that are returned.', example='10'),
  results?: [
    OSSIngestion
  ](name='results', description='The OSS data import jobs.'),
  total?: int32(name='total', description='The total number of OSS data import jobs in the project.', example='80'),
}

model ListOSSIngestionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOSSIngestionsResponseBody(name='body'),
}

/**
 * @summary Queries a list of Object Storage Service (OSS) data import jobs in a project.
 *
 * @param request ListOSSIngestionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOSSIngestionsResponse
 */
async function listOSSIngestionsWithOptions(project: string, request: ListOSSIngestionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListOSSIngestionsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.logstore)) {
    query['logstore'] = request.logstore;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOSSIngestions',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossingestions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a list of Object Storage Service (OSS) data import jobs in a project.
 *
 * @param request ListOSSIngestionsRequest
 * @return ListOSSIngestionsResponse
 */
async function listOSSIngestions(project: string, request: ListOSSIngestionsRequest): ListOSSIngestionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listOSSIngestionsWithOptions(project, request, headers, runtime);
}

model ListProjectRequest {
  fetchQuota?: boolean(name='fetchQuota'),
  offset?: int32(name='offset', description='The line from which the query starts. Default value: 0.', example='0'),
  projectName?: string(name='projectName', description='The name of the project.', example='ali-test-project'),
  resourceGroupId?: string(name='resourceGroupId'),
  size?: int32(name='size', description='The number of entries per page. Default value: 100. This operation can return up to 500 projects.', example='10'),
}

model ListProjectResponseBody = {
  count?: long(name='count', description='The number of returned projects on the current page.', example='2'),
  projects?: [
    Project
  ](name='projects', description='The projects that meet the query conditions.'),
  total?: long(name='total', description='The total number of projects that meet the query conditions.', example='11'),
}

model ListProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListProjectResponseBody(name='body'),
}

/**
 * @summary Queries the projects that meet specified conditions.
 *
 * @description ### [](#)Usage notes
 * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request ListProjectRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListProjectResponse
 */
async function listProjectWithOptions(request: ListProjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProjectResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.fetchQuota)) {
    query['fetchQuota'] = request.fetchQuota;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.projectName)) {
    query['projectName'] = request.projectName;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the projects that meet specified conditions.
 *
 * @description ### [](#)Usage notes
 * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request ListProjectRequest
 * @return ListProjectResponse
 */
async function listProject(request: ListProjectRequest): ListProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProjectWithOptions(request, headers, runtime);
}

model ListSavedSearchRequest {
  offset?: int32(name='offset', description='The line from which the query starts. Default value: 0.', example='0'),
  size?: int32(name='size', description='The number of entries per page. Maximum value: 500.', example='10'),
}

model ListSavedSearchResponseBody = {
  count?: int32(name='count', description='The number of saved searches returned on the current page.', example='4'),
  savedsearchItems?: [
    SavedSearch
  ](name='savedsearchItems', description='The saved searches.', example='[ "test-1", "test-2" ]'),
  total?: int32(name='total', description='The total number of saved searches that meet the query conditions.', example='4'),
}

model ListSavedSearchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSavedSearchResponseBody(name='body'),
}

/**
 * @summary Queries a list of saved searches.
 *
 * @description ### Usage notes
 * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request ListSavedSearchRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSavedSearchResponse
 */
async function listSavedSearchWithOptions(project: string, request: ListSavedSearchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSavedSearchResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSavedSearch',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/savedsearches`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a list of saved searches.
 *
 * @description ### Usage notes
 * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request ListSavedSearchRequest
 * @return ListSavedSearchResponse
 */
async function listSavedSearch(project: string, request: ListSavedSearchRequest): ListSavedSearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSavedSearchWithOptions(project, request, headers, runtime);
}

model ListScheduledSQLsRequest {
  logstore?: string(name='logstore', description='The name of the Logstore.', example='ali-test-logstore'),
  offset?: long(name='offset', example='0'),
  size?: long(name='size', description='The number of entries to return. Default value: 10.', example='100'),
}

model ListScheduledSQLsResponseBody = {
  count?: int32(name='count', example='10'),
  results?: [
    ScheduledSQL
  ](name='results'),
  total?: int32(name='total', example='80'),
}

model ListScheduledSQLsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListScheduledSQLsResponseBody(name='body'),
}

/**
 * @summary Queries a list of Scheduled SQL jobs in a project.
 *
 * @param request ListScheduledSQLsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListScheduledSQLsResponse
 */
async function listScheduledSQLsWithOptions(project: string, request: ListScheduledSQLsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListScheduledSQLsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.logstore)) {
    query['logstore'] = request.logstore;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListScheduledSQLs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/scheduledsqls`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a list of Scheduled SQL jobs in a project.
 *
 * @param request ListScheduledSQLsRequest
 * @return ListScheduledSQLsResponse
 */
async function listScheduledSQLs(project: string, request: ListScheduledSQLsRequest): ListScheduledSQLsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listScheduledSQLsWithOptions(project, request, headers, runtime);
}

model ListShardsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [
    Shard
  ](name='body'),
}

/**
 * @summary Queries a list of shards in a Logstore.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListShardsResponse
 */
async function listShardsWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListShardsResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListShards',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shards`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a list of shards in a Logstore.
 *
 * @return ListShardsResponse
 */
async function listShards(project: string, logstore: string): ListShardsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listShardsWithOptions(project, logstore, headers, runtime);
}

model ListStoreViewsRequest {
  name?: string(name='name', description='The dataset name that is used for fuzzy match.', example='my_storeview'),
  offset?: int32(name='offset', description='The offset of the datasets to return. Default value: 0.', example='0'),
  size?: int32(name='size', description='The number of datasets to return. Default value: 100.', example='100'),
  storeType?: string(name='storeType', description='The type of the datasets to return. By default, datasets are not filtered by type.

Valid values:

*   metricstore

    <!-- -->

    <!-- -->

    <!-- -->

*   logstore

    <!-- -->

    <!-- -->

    <!-- -->', example='logstore'),
}

model ListStoreViewsResponseBody = {
  count?: int32(name='count', description='The number of returned datasets.', example='100'),
  storeviews?: [ string ](name='storeviews', description='The dataset names.'),
  total?: int32(name='total', description='The total number of datasets in the project.', example='100'),
}

model ListStoreViewsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListStoreViewsResponseBody(name='body'),
}

/**
 * @summary Queries datasets in a project.
 *
 * @param request ListStoreViewsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListStoreViewsResponse
 */
async function listStoreViewsWithOptions(project: string, request: ListStoreViewsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListStoreViewsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.storeType)) {
    query['storeType'] = request.storeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListStoreViews',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/storeviews`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries datasets in a project.
 *
 * @param request ListStoreViewsRequest
 * @return ListStoreViewsResponse
 */
async function listStoreViews(project: string, request: ListStoreViewsRequest): ListStoreViewsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listStoreViewsWithOptions(project, request, headers, runtime);
}

model ListTagResourcesRequest {
  resourceId?: [ string ](name='resourceId', description='The IDs of the resources whose tags you want to query. You must specify at least one of resourceId and tags.'),
  resourceType?: string(name='resourceType', description='The type of the resource. Valid values:

*   project
*   logstore
*   dashboard
*   machinegroup
*   logtailconfig

This parameter is required.', example='project'),
  tags?: [ 
    {
      key?: string(name='key', description='The key of the tag that you want to use to filter resources. For example, if you set the key to `"test-key"`, only resources to which the key is added are returned.``

This parameter is required.', example='key1'),
      value?: string(name='value', description='The value of the tag that you want to use to filter resources. If you set the value to null, resources are filtered based only on the key of the tag.', example='value1', nullable=true),
    }
  ](name='tags', description='The tags that you want to use to filter resources based on exact match. Each tag is a key-value pair. You must specify at least one of resourceId and tags.

You can enter up to 20 tags.'),
}

model ListTagResourcesShrinkRequest {
  resourceIdShrink?: string(name='resourceId', description='The IDs of the resources whose tags you want to query. You must specify at least one of resourceId and tags.'),
  resourceType?: string(name='resourceType', description='The type of the resource. Valid values:

*   project
*   logstore
*   dashboard
*   machinegroup
*   logtailconfig

This parameter is required.', example='project'),
  tagsShrink?: string(name='tags', description='The tags that you want to use to filter resources based on exact match. Each tag is a key-value pair. You must specify at least one of resourceId and tags.

You can enter up to 20 tags.'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='caeba0bbb2be03f84eb48b699f0a4883'),
  tagResources?: [ 
    {
      resourceId?: string(name='resourceId', description='The ID of the resource.', example='ali-test-project'),
      resourceType?: string(name='resourceType', description='The type of the resource.', example='project'),
      tagKey?: string(name='tagKey', description='The key of the tag.', example='key1'),
      tagValue?: string(name='tagValue', description='The value of the tag.', example='value1'),
    }
  ](name='tagResources', description='The returned tags.'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesResponseBody(name='body'),
}

/**
 * @summary Queries a list of tags for one or more resources. You can query tags for resources by resource type or filter resources by tag. Each tag is a key-value pair.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
 * * For more information, see [Authorization rules](https://help.aliyun.com/document_detail/29049.html). The following types of resources are supported: project, Logstore, dashboard, machine group, and Logtail configuration.
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:ListTagResources`|The resource format varies based on the resource type.\\-`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/logstore/${logstoreName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/dashboard/${dashboardName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/machinegroup/${machineGroupName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/logtailconfig/${logtailConfigName}`|
 *
 * @param tmpReq ListTagResourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesResponse
 */
async function listTagResourcesWithOptions(tmpReq: ListTagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new ListTagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceId)) {
    request.resourceIdShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceId, 'resourceId', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'tags', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.resourceIdShrink)) {
    query['resourceId'] = request.resourceIdShrink;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['resourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['tags'] = request.tagsShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/tags`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a list of tags for one or more resources. You can query tags for resources by resource type or filter resources by tag. Each tag is a key-value pair.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
 * * For more information, see [Authorization rules](https://help.aliyun.com/document_detail/29049.html). The following types of resources are supported: project, Logstore, dashboard, machine group, and Logtail configuration.
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:ListTagResources`|The resource format varies based on the resource type.\\-`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/logstore/${logstoreName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/dashboard/${dashboardName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/machinegroup/${machineGroupName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/logtailconfig/${logtailConfigName}`|
 *
 * @param request ListTagResourcesRequest
 * @return ListTagResourcesResponse
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagResourcesWithOptions(request, headers, runtime);
}

model MergeShardResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [
    Shard
  ](name='body'),
}

/**
 * @summary 合并两个相邻的readwrite状态的Shards。在参数中指定一个shardID，服务端自动找相邻的下一个Shard进行合并。
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return MergeShardResponse
 */
async function mergeShardWithOptions(project: string, logstore: string, shard: string, headers: map[string]string, runtime: Util.RuntimeOptions): MergeShardResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'MergeShard',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shards/${shard}?action=merge`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 合并两个相邻的readwrite状态的Shards。在参数中指定一个shardID，服务端自动找相邻的下一个Shard进行合并。
 *
 * @return MergeShardResponse
 */
async function mergeShard(project: string, logstore: string, shard: string): MergeShardResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return mergeShardWithOptions(project, logstore, shard, headers, runtime);
}

model OpenSlsServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Activates Simple Log Service. You must use the endpoint for Simple Log Service only in the China (Shanghai) or Singapore region.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenSlsServiceResponse
 */
async function openSlsServiceWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): OpenSlsServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'OpenSlsService',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/slsservice`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Activates Simple Log Service. You must use the endpoint for Simple Log Service only in the China (Shanghai) or Singapore region.
 *
 * @return OpenSlsServiceResponse
 */
async function openSlsService(): OpenSlsServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return openSlsServiceWithOptions(headers, runtime);
}

model PullLogsHeaders {
  commonHeaders?: map[string]string,
  acceptEncoding?: string(name='Accept-Encoding', example='lz4'),
}

model PullLogsRequest {
  count?: int32(name='count', description='This parameter is required.', example='1000'),
  cursor?: string(name='cursor', description='This parameter is required.', example='MTQ0NzMyOTQwMTEwMjEzMDkwNA'),
  endCursor?: string(name='end_cursor', example='MTU1NzA1NzQwMTEwMjEzMDkwCg'),
  query?: string(name='query', description='The SPL statement that is used to filter data. For more information, see [SPL instructions](https://help.aliyun.com/document_detail/2536530.html).', example='* | where userId=\\\\"123\\\\"'),
}

model PullLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: LogGroupList  
}

/**
 * @summary Queries logs based on the specified cursors. You can call this operation to obtain raw logs. To query and analyze logs, you can call the GetLogsV2 operation.
 *
 * @description **
 * **Warning** You cannot call this operation in OpenAPI Explorer. You can use Simple Log Service SDK to call this operation. For more information, see SLS SDK Reference.
 * *   You must specify a shard when you query the logs.
 * *   You can query only logs in the Protocol Buffers (protobuf) format. For more information, see [Data encoding](https://help.aliyun.com/document_detail/29055.html).
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request PullLogsRequest
 * @param headers PullLogsHeaders
 * @param runtime runtime options for this request RuntimeOptions
 * @return PullLogsResponse
 */
async function pullLogsWithOptions(project: string, logStore: string, shardId: string, request: PullLogsRequest, headers: PullLogsHeaders, runtime: Util.RuntimeOptions): PullLogsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.count)) {
    query['count'] = request.count;
  }
  if (!Util.isUnset(request.cursor)) {
    query['cursor'] = request.cursor;
  }
  if (!Util.isUnset(request.endCursor)) {
    query['end_cursor'] = request.endCursor;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.acceptEncoding)) {
    realHeaders['Accept-Encoding'] = Util.toJSONString(headers.acceptEncoding);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PullLogs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logStore}/shards/${shardId}?type=log`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'none',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries logs based on the specified cursors. You can call this operation to obtain raw logs. To query and analyze logs, you can call the GetLogsV2 operation.
 *
 * @description **
 * **Warning** You cannot call this operation in OpenAPI Explorer. You can use Simple Log Service SDK to call this operation. For more information, see SLS SDK Reference.
 * *   You must specify a shard when you query the logs.
 * *   You can query only logs in the Protocol Buffers (protobuf) format. For more information, see [Data encoding](https://help.aliyun.com/document_detail/29055.html).
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request PullLogsRequest
 * @return PullLogsResponse
 */
async function pullLogs(project: string, logStore: string, shardId: string, request: PullLogsRequest): PullLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new PullLogsHeaders{};
  return pullLogsWithOptions(project, logStore, shardId, request, headers, runtime);
}

model PutAnnotationDataRequest {
  annotationdataId?: string(name='annotationdataId', description='The unique identifier of the data.', example='2156d560fc7c01420542df92cd6365ds'),
  mlDataParam?: MLDataParam(name='mlDataParam', description='The data structure of the request.'),
  rawLog?: [ map[string]string ](name='rawLog', description='The raw log data.'),
}

model PutAnnotationDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Adds data to a dataset for storage.
 *
 * @param request PutAnnotationDataRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PutAnnotationDataResponse
 */
async function putAnnotationDataWithOptions(datasetId: string, request: PutAnnotationDataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutAnnotationDataResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.annotationdataId)) {
    query['annotationdataId'] = request.annotationdataId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.mlDataParam)) {
    body['mlDataParam'] = request.mlDataParam;
  }
  if (!Util.isUnset(request.rawLog)) {
    body['rawLog'] = request.rawLog;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutAnnotationData',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationdataset/${datasetId}/annotationdata`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Adds data to a dataset for storage.
 *
 * @param request PutAnnotationDataRequest
 * @return PutAnnotationDataResponse
 */
async function putAnnotationData(datasetId: string, request: PutAnnotationDataRequest): PutAnnotationDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putAnnotationDataWithOptions(datasetId, request, headers, runtime);
}

model PutIngestProcessorRequest {
  configuration?: IngestProcessorConfiguration(name='configuration', description='The configuration of the ingest processor.

This parameter is required.'),
  description?: string(name='description', description='The description of the ingest processor.'),
  displayName?: string(name='displayName', description='The display name of the ingest processor.

This parameter is required.'),
}

model PutIngestProcessorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates or modifies an ingest processor.
 *
 * @param request PutIngestProcessorRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PutIngestProcessorResponse
 */
async function putIngestProcessorWithOptions(project: string, processorName: string, request: PutIngestProcessorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutIngestProcessorResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutIngestProcessor',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ingestprocessors/${processorName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates or modifies an ingest processor.
 *
 * @param request PutIngestProcessorRequest
 * @return PutIngestProcessorResponse
 */
async function putIngestProcessor(project: string, processorName: string, request: PutIngestProcessorRequest): PutIngestProcessorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putIngestProcessorWithOptions(project, processorName, request, headers, runtime);
}

model PutLogsHeaders {
  commonHeaders?: map[string]string,
  xLogCompresstype?: string(name='x-log-compresstype', description='The compression format. lz4 and gzip are supported.

This parameter is required.', example='lz4'),
}

model PutLogsRequest {
  body?: LogGroup(name='body', description='The compressed Protobuf data.'),
}

model PutLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Writes logs to a Logstore.
 *
 * @description **
 * **Warning** You cannot call this operation in OpenAPI Explorer. You can use Simple Log Service SDK to call this operation. For more information, see SLS SDK Reference.
 * *   When you call the PutLogs operation to write logs to Simple Log Service, Simple Log Servicechecks the format of the logs. If a log does not meet the format requirements, the request fails and no logs are written to Simple Log Service.
 * *   You can write logs only in the Protocol Buffers (Protobuf) format as log groups. For more information, see [Data encoding](https://help.aliyun.com/document_detail/29055.html).
 * *   You can write logs in one of the following modes:
 *     *   LoadBalance mode: In this mode, Log Service automatically writes logs to all writable shards in a Logstore. This mode delivers high availability for write operations and is suitable for data consumption scenarios in which you do not need to preserve the order of logs.
 *     *   KeyHash: In this mode, a key field is added in the URL parameter. Log Service writes logs to a shard based on the key field. The hash key is optional. If you do not configure the hash key, logs are written to shards in LoadBalance mode. For example, you can use the KeyHash mode to write data from a producer, such as an instance, to the shard whose hash value range includes the hash value of the producer name. This ensures that the data that is written to the shard is ordered and the data in the shard is consumed based on the order. This way, when a shard is split or when shards are merged, the data that is associated with the same hash key is stored only in one shard at a point in time. For more information, see [Shard](https://help.aliyun.com/document_detail/28976.html).
 * *   You can call the PutLogs operation to write up to 10 MB of raw logs at a time. We recommend that you keep the total size of the values for each log in a log group to or below 1 MB. Historical versions of SDKs may have different limits. We recommend that you upgrade your SDK to the latest version.
 * *   The references for Log Service SDK for Java and Log Service SDK for Python provide examples on how to call the PutLogs operation. For more information, see [Get started with Simple Log Service SDK for Java](https://help.aliyun.com/document_detail/279525.html) and [Get started with Simple Log Service SDK for Python](https://help.aliyun.com/document_detail/284638.html).
 *
 * @param request PutLogsRequest
 * @param headers PutLogsHeaders
 * @param runtime runtime options for this request RuntimeOptions
 * @return PutLogsResponse
 */
async function putLogsWithOptions(project: string, logstore: string, request: PutLogsRequest, headers: PutLogsHeaders, runtime: Util.RuntimeOptions): PutLogsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xLogCompresstype)) {
    realHeaders['x-log-compresstype'] = Util.toJSONString(headers.xLogCompresstype);
  }
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'PutLogs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shards/lb`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'protobuf',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Writes logs to a Logstore.
 *
 * @description **
 * **Warning** You cannot call this operation in OpenAPI Explorer. You can use Simple Log Service SDK to call this operation. For more information, see SLS SDK Reference.
 * *   When you call the PutLogs operation to write logs to Simple Log Service, Simple Log Servicechecks the format of the logs. If a log does not meet the format requirements, the request fails and no logs are written to Simple Log Service.
 * *   You can write logs only in the Protocol Buffers (Protobuf) format as log groups. For more information, see [Data encoding](https://help.aliyun.com/document_detail/29055.html).
 * *   You can write logs in one of the following modes:
 *     *   LoadBalance mode: In this mode, Log Service automatically writes logs to all writable shards in a Logstore. This mode delivers high availability for write operations and is suitable for data consumption scenarios in which you do not need to preserve the order of logs.
 *     *   KeyHash: In this mode, a key field is added in the URL parameter. Log Service writes logs to a shard based on the key field. The hash key is optional. If you do not configure the hash key, logs are written to shards in LoadBalance mode. For example, you can use the KeyHash mode to write data from a producer, such as an instance, to the shard whose hash value range includes the hash value of the producer name. This ensures that the data that is written to the shard is ordered and the data in the shard is consumed based on the order. This way, when a shard is split or when shards are merged, the data that is associated with the same hash key is stored only in one shard at a point in time. For more information, see [Shard](https://help.aliyun.com/document_detail/28976.html).
 * *   You can call the PutLogs operation to write up to 10 MB of raw logs at a time. We recommend that you keep the total size of the values for each log in a log group to or below 1 MB. Historical versions of SDKs may have different limits. We recommend that you upgrade your SDK to the latest version.
 * *   The references for Log Service SDK for Java and Log Service SDK for Python provide examples on how to call the PutLogs operation. For more information, see [Get started with Simple Log Service SDK for Java](https://help.aliyun.com/document_detail/279525.html) and [Get started with Simple Log Service SDK for Python](https://help.aliyun.com/document_detail/284638.html).
 *
 * @param request PutLogsRequest
 * @return PutLogsResponse
 */
async function putLogs(project: string, logstore: string, request: PutLogsRequest): PutLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new PutLogsHeaders{};
  return putLogsWithOptions(project, logstore, request, headers, runtime);
}

model PutProjectPolicyRequest {
  body?: string(name='body', description='The project policy.', example='{ 	"Version": "1", 	"Statement": [{ 		"Action": ["log:PostLogStoreLogs"], 		"Resource": "acs:log:*:*:project/exampleproject/*", 		"Effect": "Deny", 		"Condition": { 			"StringNotLike": { 				"acs:SourceVpc": ["vpc-*"] 			} 		} 	}] }'),
}

model PutProjectPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates a project policy.
 *
 * @description ### Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   Alibaba Cloud Simple Log Service allows you to configure a project policy to authorize other users to access the specified Log Service resources.
 *     *   You must configure a project policy based on policy syntax. Before you configure a project policy, you must be familiar with the Action, Resource, and Condition parameters. For more information, see [RAM](https://help.aliyun.com/document_detail/128139.html).
 *     *   If you set the Principal element to an asterisk (\\*) and do not configure the Condition element when you configure a project policy, the policy applies to all users except for the project owner. If you set the Principal element to an asterisk (\\*) and configure the Condition element when you configure a project policy, the policy applies to all users including the project owner.
 *     *   You can configure multiple project policies for a project. The total size of the policies cannot exceed 16 KB.
 *
 * @param request PutProjectPolicyRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PutProjectPolicyResponse
 */
async function putProjectPolicyWithOptions(project: string, request: PutProjectPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutProjectPolicyResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'PutProjectPolicy',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/policy`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates a project policy.
 *
 * @description ### Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   Alibaba Cloud Simple Log Service allows you to configure a project policy to authorize other users to access the specified Log Service resources.
 *     *   You must configure a project policy based on policy syntax. Before you configure a project policy, you must be familiar with the Action, Resource, and Condition parameters. For more information, see [RAM](https://help.aliyun.com/document_detail/128139.html).
 *     *   If you set the Principal element to an asterisk (\\*) and do not configure the Condition element when you configure a project policy, the policy applies to all users except for the project owner. If you set the Principal element to an asterisk (\\*) and configure the Condition element when you configure a project policy, the policy applies to all users including the project owner.
 *     *   You can configure multiple project policies for a project. The total size of the policies cannot exceed 16 KB.
 *
 * @param request PutProjectPolicyRequest
 * @return PutProjectPolicyResponse
 */
async function putProjectPolicy(project: string, request: PutProjectPolicyRequest): PutProjectPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putProjectPolicyWithOptions(project, request, headers, runtime);
}

model PutProjectTransferAccelerationRequest {
  enabled?: boolean(name='enabled', description='This parameter is required.'),
}

model PutProjectTransferAccelerationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 设置project传输加速状态
 *
 * @param request PutProjectTransferAccelerationRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PutProjectTransferAccelerationResponse
 */
async function putProjectTransferAccelerationWithOptions(project: string, request: PutProjectTransferAccelerationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutProjectTransferAccelerationResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.enabled)) {
    body['enabled'] = request.enabled;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutProjectTransferAcceleration',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/transferacceleration`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 设置project传输加速状态
 *
 * @param request PutProjectTransferAccelerationRequest
 * @return PutProjectTransferAccelerationResponse
 */
async function putProjectTransferAcceleration(project: string, request: PutProjectTransferAccelerationRequest): PutProjectTransferAccelerationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putProjectTransferAccelerationWithOptions(project, request, headers, runtime);
}

model PutWebtrackingRequest {
  logs?: [ map[string]string ](name='__logs__', description='The logs. Each element is a JSON object that indicates a log.

>  **Note**: The time in a log that is collected by using the web tracking feature is the time at which Simple Log Service receives the log. You do not need to configure the __time__ field for each log. If this field exists, it is overwritten by the time at which Simple Log Service receives the log.

This parameter is required.'),
  source?: string(name='__source__', description='The source of the logs.

This parameter is required.', example='source'),
  tags?: map[string]string(name='__tags__', description='The tags of the logs.'),
  topic?: string(name='__topic__', description='The topic of the logs.', example='topic'),
}

model PutWebtrackingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Sends multiple logs to Simple Log Service in one request.
 *
 * @description ### [](#)Usage notes
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 * *   You can call this operation to collect logs from web pages or clients.
 * *   If you use web tracking to collect logs and you do not call this operation, you can send only one log to Simple Log Service in a request. For more information, see [Use web tracking to collect logs](https://help.aliyun.com/document_detail/31752.html).
 * *   If you want to collect a large amount of log data, you can call this operation to send multiple logs to Simple Log Service in one request.
 * *   Before you can call this operation to send logs to a Logstore, you must enable web tracking for the Logstore. For more information, see [Use web tracking to collect logs](https://help.aliyun.com/document_detail/31752.html).
 * *   You cannot call this operation to send the logs of multiple topics to Simple Log Service at a time.
 * *   If you call this operation, anonymous users from the Internet are granted the write permissions on the Logstore. This may generate dirty data because AccessKey pair-based authentication is not performed.
 *
 * @param request PutWebtrackingRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PutWebtrackingResponse
 */
async function putWebtrackingWithOptions(project: string, logstoreName: string, request: PutWebtrackingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutWebtrackingResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.logs)) {
    body['__logs__'] = request.logs;
  }
  if (!Util.isUnset(request.source)) {
    body['__source__'] = request.source;
  }
  if (!Util.isUnset(request.tags)) {
    body['__tags__'] = request.tags;
  }
  if (!Util.isUnset(request.topic)) {
    body['__topic__'] = request.topic;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutWebtracking',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstoreName}/track`,
    method = 'POST',
    authType = 'Anonymous',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Sends multiple logs to Simple Log Service in one request.
 *
 * @description ### [](#)Usage notes
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 * *   You can call this operation to collect logs from web pages or clients.
 * *   If you use web tracking to collect logs and you do not call this operation, you can send only one log to Simple Log Service in a request. For more information, see [Use web tracking to collect logs](https://help.aliyun.com/document_detail/31752.html).
 * *   If you want to collect a large amount of log data, you can call this operation to send multiple logs to Simple Log Service in one request.
 * *   Before you can call this operation to send logs to a Logstore, you must enable web tracking for the Logstore. For more information, see [Use web tracking to collect logs](https://help.aliyun.com/document_detail/31752.html).
 * *   You cannot call this operation to send the logs of multiple topics to Simple Log Service at a time.
 * *   If you call this operation, anonymous users from the Internet are granted the write permissions on the Logstore. This may generate dirty data because AccessKey pair-based authentication is not performed.
 *
 * @param request PutWebtrackingRequest
 * @return PutWebtrackingResponse
 */
async function putWebtracking(project: string, logstoreName: string, request: PutWebtrackingRequest): PutWebtrackingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putWebtrackingWithOptions(project, logstoreName, request, headers, runtime);
}

model RefreshTokenRequest {
  accessTokenExpirationTime?: long(name='accessTokenExpirationTime', description='*   The validity period of the access token. Unit: seconds. Default value: 86400, which specifies one day. Valid values: 0 to 86400.
*   The validity period of the access token is the smaller value between accessTokenExpirationTime and expirationTime.
*   If you use a Security Token Service (STS) token to call this operation, the validity period of the access token is the smallest value among accessTokenExpirationTime, expirationTime, and the validity period of the STS token.', example='600'),
  ticket?: string(name='ticket', description='The ticket that is used for logon-free access.', example='eyJ***************.eyJ******************.KUT****************'),
}

model RefreshTokenResponseBody = {
  accessToken?: string(name='accessToken', example='eyJ***************.eyJ******************.KUT****************'),
}

model RefreshTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RefreshTokenResponseBody(name='body'),
}

/**
 * @summary 刷新token
 *
 * @param request RefreshTokenRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RefreshTokenResponse
 */
async function refreshTokenWithOptions(request: RefreshTokenRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RefreshTokenResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessTokenExpirationTime)) {
    query['accessTokenExpirationTime'] = request.accessTokenExpirationTime;
  }
  if (!Util.isUnset(request.ticket)) {
    query['ticket'] = request.ticket;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefreshToken',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/token/refresh`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 刷新token
 *
 * @param request RefreshTokenRequest
 * @return RefreshTokenResponse
 */
async function refreshToken(request: RefreshTokenRequest): RefreshTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return refreshTokenWithOptions(request, headers, runtime);
}

model RemoveConfigFromMachineGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Removes a Logtail configuration from a machine group.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveConfigFromMachineGroupResponse
 */
async function removeConfigFromMachineGroupWithOptions(project: string, machineGroup: string, configName: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveConfigFromMachineGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveConfigFromMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}/configs/${configName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Removes a Logtail configuration from a machine group.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @return RemoveConfigFromMachineGroupResponse
 */
async function removeConfigFromMachineGroup(project: string, machineGroup: string, configName: string): RemoveConfigFromMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeConfigFromMachineGroupWithOptions(project, machineGroup, configName, headers, runtime);
}

model SplitShardRequest {
  key?: string(name='key', description='The position where the shard is split.', example='ef000000000000000000000000000000'),
  shardCount?: int32(name='shardCount', description='The number of new shards that are generated after splitting.', example='2'),
}

model SplitShardResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [
    Shard
  ](name='body'),
}

/**
 * @summary Splits a shard in the readwrite state.
 *
 * @description ### Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   Each shard has an MD5 hash range, and each range is a left-closed, right-open interval. The interval is in the `[BeginKey,EndKey)` format. A shard can be in the readwrite or readonly state. You can split a shard and merge shards. For more information, see [Shard](https://help.aliyun.com/document_detail/28976.html).
 *
 * @param request SplitShardRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return SplitShardResponse
 */
async function splitShardWithOptions(project: string, logstore: string, shard: string, request: SplitShardRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SplitShardResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.key)) {
    query['key'] = request.key;
  }
  if (!Util.isUnset(request.shardCount)) {
    query['shardCount'] = request.shardCount;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SplitShard',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shards/${shard}?action=split`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Splits a shard in the readwrite state.
 *
 * @description ### Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   Each shard has an MD5 hash range, and each range is a left-closed, right-open interval. The interval is in the `[BeginKey,EndKey)` format. A shard can be in the readwrite or readonly state. You can split a shard and merge shards. For more information, see [Shard](https://help.aliyun.com/document_detail/28976.html).
 *
 * @param request SplitShardRequest
 * @return SplitShardResponse
 */
async function splitShard(project: string, logstore: string, shard: string, request: SplitShardRequest): SplitShardResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return splitShardWithOptions(project, logstore, shard, request, headers, runtime);
}

model StartETLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 启动数据加工任务
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartETLResponse
 */
async function startETLWithOptions(project: string, etlName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartETLResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartETL',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/etls/${etlName}?action=START`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 启动数据加工任务
 *
 * @return StartETLResponse
 */
async function startETL(project: string, etlName: string): StartETLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startETLWithOptions(project, etlName, headers, runtime);
}

model StartMaxComputeExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Starts a MaxCompute data shipping job.
 *
 * @description *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartMaxComputeExportResponse
 */
async function startMaxComputeExportWithOptions(project: string, mcExportName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartMaxComputeExportResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartMaxComputeExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/maxcomputeexports/${mcExportName}?action=START`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Starts a MaxCompute data shipping job.
 *
 * @description *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 *
 * @return StartMaxComputeExportResponse
 */
async function startMaxComputeExport(project: string, mcExportName: string): StartMaxComputeExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startMaxComputeExportWithOptions(project, mcExportName, headers, runtime);
}

model StartOSSExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 启动OSS投递任务
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartOSSExportResponse
 */
async function startOSSExportWithOptions(project: string, ossExportName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartOSSExportResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartOSSExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossexports/${ossExportName}?action=START`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 启动OSS投递任务
 *
 * @return StartOSSExportResponse
 */
async function startOSSExport(project: string, ossExportName: string): StartOSSExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startOSSExportWithOptions(project, ossExportName, headers, runtime);
}

model StartOSSHDFSExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 启动OSSHDFS投递任务
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartOSSHDFSExportResponse
 */
async function startOSSHDFSExportWithOptions(project: string, ossExportName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartOSSHDFSExportResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartOSSHDFSExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/osshdfsexports/${ossExportName}?action=START`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 启动OSSHDFS投递任务
 *
 * @return StartOSSHDFSExportResponse
 */
async function startOSSHDFSExport(project: string, ossExportName: string): StartOSSHDFSExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startOSSHDFSExportWithOptions(project, ossExportName, headers, runtime);
}

model StartOSSIngestionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Starts an Object Storage Service (OSS) data import job.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartOSSIngestionResponse
 */
async function startOSSIngestionWithOptions(project: string, ossIngestionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartOSSIngestionResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartOSSIngestion',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossingestions/${ossIngestionName}?action=START`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Starts an Object Storage Service (OSS) data import job.
 *
 * @return StartOSSIngestionResponse
 */
async function startOSSIngestion(project: string, ossIngestionName: string): StartOSSIngestionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startOSSIngestionWithOptions(project, ossIngestionName, headers, runtime);
}

model StopETLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 停止数据加工任务
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopETLResponse
 */
async function stopETLWithOptions(project: string, etlName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopETLResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopETL',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/etls/${etlName}?action=STOP`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 停止数据加工任务
 *
 * @return StopETLResponse
 */
async function stopETL(project: string, etlName: string): StopETLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopETLWithOptions(project, etlName, headers, runtime);
}

model StopMaxComputeExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Stops a MaxCompute data shipping job.
 *
 * @description *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopMaxComputeExportResponse
 */
async function stopMaxComputeExportWithOptions(project: string, mcExportName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopMaxComputeExportResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopMaxComputeExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/maxcomputeexports/${mcExportName}?action=STOP`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Stops a MaxCompute data shipping job.
 *
 * @description *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
 *
 * @return StopMaxComputeExportResponse
 */
async function stopMaxComputeExport(project: string, mcExportName: string): StopMaxComputeExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopMaxComputeExportWithOptions(project, mcExportName, headers, runtime);
}

model StopOSSExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 停止OSS投递任务
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopOSSExportResponse
 */
async function stopOSSExportWithOptions(project: string, ossExportName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopOSSExportResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopOSSExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossexports/${ossExportName}?action=STOP`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 停止OSS投递任务
 *
 * @return StopOSSExportResponse
 */
async function stopOSSExport(project: string, ossExportName: string): StopOSSExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopOSSExportWithOptions(project, ossExportName, headers, runtime);
}

model StopOSSHDFSExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 停止OSSHDFS投递任务
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopOSSHDFSExportResponse
 */
async function stopOSSHDFSExportWithOptions(project: string, ossExportName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopOSSHDFSExportResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopOSSHDFSExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/osshdfsexports/${ossExportName}?action=STOP`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 停止OSSHDFS投递任务
 *
 * @return StopOSSHDFSExportResponse
 */
async function stopOSSHDFSExport(project: string, ossExportName: string): StopOSSHDFSExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopOSSHDFSExportWithOptions(project, ossExportName, headers, runtime);
}

model StopOSSIngestionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Stops an Object Storage Service (OSS) data import job.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopOSSIngestionResponse
 */
async function stopOSSIngestionWithOptions(project: string, ossIngestionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopOSSIngestionResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopOSSIngestion',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossingestions/${ossIngestionName}?action=STOP`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Stops an Object Storage Service (OSS) data import job.
 *
 * @return StopOSSIngestionResponse
 */
async function stopOSSIngestion(project: string, ossIngestionName: string): StopOSSIngestionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopOSSIngestionWithOptions(project, ossIngestionName, headers, runtime);
}

model TagResourcesRequest {
  resourceId?: [ string ](name='resourceId', description='The resource IDs. You can specify only one resource and add tags to the resource.

This parameter is required.'),
  resourceType?: string(name='resourceType', description='The type of the resource. Valid values:

*   project
*   logstore
*   dashboard
*   machinegroup
*   logtailconfig

This parameter is required.', example='project'),
  tags?: [ 
    {
      key?: string(name='key', description='The key of the tag. The key must meet the following requirements:

*   The key must be `1 to 128` characters in length.
*   The key cannot contain `http://` or `https://`.
*   The key cannot start with `acs:` or `aliyun`.

This parameter is required.', example='key1'),
      value?: string(name='value', description='The value of the tag. The value must meet the following requirements:

*   The value must be `1 to 128` characters in length.
*   The value cannot contain `http://` or `https://`.

This parameter is required.', example='value1'),
    }
  ](name='tags', description='The tags that you want to add to the resource. You can specify up to 20 tags in each call. Each tag is a key-value pair.

This parameter is required.'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates and adds tags to a resource. You can add tags only to projects.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
 * * For more information, see [Authorization rules](https://help.aliyun.com/document_detail/29049.html). The following types of resources are supported: project, Logstore, dashboard, machine group, and Logtail configuration.
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:TagResources`|The resource format varies based on the resource type.\\-`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/logstore/${logstoreName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/dashboard/${dashboardName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/machinegroup/${machineGroupName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/logtailconfig/${logtailConfigName}`|
 *
 * @param request TagResourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesResponse
 */
async function tagResourcesWithOptions(request: TagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.resourceId)) {
    body['resourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['resourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/tag`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates and adds tags to a resource. You can add tags only to projects.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
 * * For more information, see [Authorization rules](https://help.aliyun.com/document_detail/29049.html). The following types of resources are supported: project, Logstore, dashboard, machine group, and Logtail configuration.
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:TagResources`|The resource format varies based on the resource type.\\-`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/logstore/${logstoreName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/dashboard/${dashboardName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/machinegroup/${machineGroupName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/logtailconfig/${logtailConfigName}`|
 *
 * @param request TagResourcesRequest
 * @return TagResourcesResponse
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return tagResourcesWithOptions(request, headers, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='all', description='Specifies whether to unbind all tags. Default value: false. Valid values:

*   false: unbinds only the tags that match the value of tags.
*   true: unbinds all tags that are bound to the resource.', example='false'),
  resourceId?: [ string ](name='resourceId', description='The resource IDs. Each time you call this operation, you can unbind tags only from a single resource. Therefore, you can enter only one resource ID.

This parameter is required.', example='ali-test-project'),
  resourceType?: string(name='resourceType', description='The type of the resource. Valid values:

*   project
*   logstore
*   dashboard
*   machinegroup
*   logtailconfig', example='project'),
  tags?: [ string ](name='tags', description='The tag keys. If you set all to false, only the tags that match the value of this parameter are unbound.'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Detaches one or more tags from a resource. You can detach tags only from Simple Log Service projects. You can detach multiple or all tags from a Simple Log Service project at a time.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) For more information, see [Authorization rules](https://help.aliyun.com/document_detail/29049.html). The following types of resources are supported: project, Logstore, dashboard, machine group, and Logtail configuration.
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:UntagResources`|The resource format varies based on the resource type.\\-`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/logstore/${logstoreName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/dashboard/${dashboardName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/machinegroup/${machineGroupName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/logtailconfig/${logtailConfigName}`|
 *
 * @param request UntagResourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UntagResourcesResponse
 */
async function untagResourcesWithOptions(request: UntagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.all)) {
    body['all'] = request.all;
  }
  if (!Util.isUnset(request.resourceId)) {
    body['resourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['resourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/untag`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Detaches one or more tags from a resource. You can detach tags only from Simple Log Service projects. You can detach multiple or all tags from a Simple Log Service project at a time.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) For more information, see [Authorization rules](https://help.aliyun.com/document_detail/29049.html). The following types of resources are supported: project, Logstore, dashboard, machine group, and Logtail configuration.
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:UntagResources`|The resource format varies based on the resource type.\\-`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/logstore/${logstoreName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/dashboard/${dashboardName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/machinegroup/${machineGroupName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/logtailconfig/${logtailConfigName}`|
 *
 * @param request UntagResourcesRequest
 * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return untagResourcesWithOptions(request, headers, runtime);
}

model UpdateAgentInstanceConfigRequest {
  config?: string(name='config', description='This parameter is required.'),
  configMatcher?: string(name='configMatcher', description='This parameter is required.'),
  isGray?: boolean(name='isGray'),
}

model UpdateAgentInstanceConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary UpdateAgentInstanceConfig
 *
 * @param request UpdateAgentInstanceConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAgentInstanceConfigResponse
 */
async function updateAgentInstanceConfigWithOptions(configName: string, request: UpdateAgentInstanceConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAgentInstanceConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.config)) {
    body['config'] = request.config;
  }
  if (!Util.isUnset(request.configMatcher)) {
    body['configMatcher'] = request.configMatcher;
  }
  if (!Util.isUnset(request.isGray)) {
    body['isGray'] = request.isGray;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAgentInstanceConfig',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/agentinstanceconfigs/${configName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary UpdateAgentInstanceConfig
 *
 * @param request UpdateAgentInstanceConfigRequest
 * @return UpdateAgentInstanceConfigResponse
 */
async function updateAgentInstanceConfig(configName: string, request: UpdateAgentInstanceConfigRequest): UpdateAgentInstanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAgentInstanceConfigWithOptions(configName, request, headers, runtime);
}

model UpdateAlertRequest {
  configuration?: AlertConfiguration(name='configuration', description='The detailed configurations of the alert rule.

This parameter is required.'),
  description?: string(name='description', description='The description of the alert rule.', example='this is description'),
  displayName?: string(name='displayName', description='The display name of the alert rule.

This parameter is required.', example='this is alert'),
  schedule?: Schedule(name='schedule', description='The scheduling settings of the alert rule.

This parameter is required.'),
}

model UpdateAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates an alert rule.
 *
 * @param request UpdateAlertRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAlertResponse
 */
async function updateAlertWithOptions(project: string, alertName: string, request: UpdateAlertRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAlertResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.schedule)) {
    body['schedule'] = request.schedule;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAlert',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/alerts/${alertName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates an alert rule.
 *
 * @param request UpdateAlertRequest
 * @return UpdateAlertResponse
 */
async function updateAlert(project: string, alertName: string, request: UpdateAlertRequest): UpdateAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAlertWithOptions(project, alertName, request, headers, runtime);
}

model UpdateAnnotationDataSetRequest {
  body?: MLDataSetParam(name='body', description='The data structure of the request.'),
}

model UpdateAnnotationDataSetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates a dataset.
 *
 * @param request UpdateAnnotationDataSetRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAnnotationDataSetResponse
 */
async function updateAnnotationDataSetWithOptions(datasetId: string, request: UpdateAnnotationDataSetRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAnnotationDataSetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAnnotationDataSet',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationdataset/${datasetId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates a dataset.
 *
 * @param request UpdateAnnotationDataSetRequest
 * @return UpdateAnnotationDataSetResponse
 */
async function updateAnnotationDataSet(datasetId: string, request: UpdateAnnotationDataSetRequest): UpdateAnnotationDataSetResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAnnotationDataSetWithOptions(datasetId, request, headers, runtime);
}

model UpdateAnnotationLabelRequest {
  body?: MLLabelParam(name='body', description='The data structure of the request.'),
}

model UpdateAnnotationLabelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates a tag table.
 *
 * @description You can update only the names of the tags in a tag set.
 *
 * @param request UpdateAnnotationLabelRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAnnotationLabelResponse
 */
async function updateAnnotationLabelWithOptions(request: UpdateAnnotationLabelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAnnotationLabelResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAnnotationLabel',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationlabel`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates a tag table.
 *
 * @description You can update only the names of the tags in a tag set.
 *
 * @param request UpdateAnnotationLabelRequest
 * @return UpdateAnnotationLabelResponse
 */
async function updateAnnotationLabel(request: UpdateAnnotationLabelRequest): UpdateAnnotationLabelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAnnotationLabelWithOptions(request, headers, runtime);
}

model UpdateConfigRequest {
  body?: LogtailConfig(name='body', description='The body of the request.'),
}

model UpdateConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Modifies a Logtail configuration.
 *
 * @description ### [](#)Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   After you update a Logtail configuration that is applied to a machine group, the new configuration immediately takes effect.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 * *   The Logtail configuration is planned out. For more information, see [Logtail configurations](https://help.aliyun.com/document_detail/29058.html).
 *
 * @param request UpdateConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateConfigResponse
 */
async function updateConfigWithOptions(project: string, configName: string, request: UpdateConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateConfigResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateConfig',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/configs/${configName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Modifies a Logtail configuration.
 *
 * @description ### [](#)Usage notes
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   After you update a Logtail configuration that is applied to a machine group, the new configuration immediately takes effect.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 * *   The Logtail configuration is planned out. For more information, see [Logtail configurations](https://help.aliyun.com/document_detail/29058.html).
 *
 * @param request UpdateConfigRequest
 * @return UpdateConfigResponse
 */
async function updateConfig(project: string, configName: string, request: UpdateConfigRequest): UpdateConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateConfigWithOptions(project, configName, request, headers, runtime);
}

model UpdateConsumerGroupRequest {
  order?: boolean(name='order', description='Specifies whether to consume data in sequence. Valid values:

*   true: If a shard is split, the data in the original shard is consumed first. Then, the data in the new shards is consumed at the same time. If shards are merged, the data in the original shards is consumed first. Then, the data in the new shard is consumed.
*   false: The data in all shards is consumed at the same time. If a new shard is generated after a shard is split or shards are merged, the data in the new shard is immediately consumed.', example='true'),
  timeout?: int32(name='timeout', description='The timeout period. If Simple Log Service does not receive heartbeats from a consumer within the timeout period, Simple Log Service deletes the consumer. Unit: seconds', example='300'),
}

model UpdateConsumerGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates the attributes of a consumer group.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:UpdateConsumerGroup`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#logstoreName}/consumergroup/{#ConsumerGroup}`|
 *
 * @param request UpdateConsumerGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateConsumerGroupResponse
 */
async function updateConsumerGroupWithOptions(project: string, logstore: string, consumerGroup: string, request: UpdateConsumerGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateConsumerGroupResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.order)) {
    body['order'] = request.order;
  }
  if (!Util.isUnset(request.timeout)) {
    body['timeout'] = request.timeout;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateConsumerGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups/${consumerGroup}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates the attributes of a consumer group.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:UpdateConsumerGroup`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#logstoreName}/consumergroup/{#ConsumerGroup}`|
 *
 * @param request UpdateConsumerGroupRequest
 * @return UpdateConsumerGroupResponse
 */
async function updateConsumerGroup(project: string, logstore: string, consumerGroup: string, request: UpdateConsumerGroupRequest): UpdateConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateConsumerGroupWithOptions(project, logstore, consumerGroup, request, headers, runtime);
}

model UpdateDashboardRequest {
  attribute?: map[string]string(name='attribute', description='The attribute values of the dashboard.'),
  charts?: [
    Chart
  ](name='charts', description='The charts on the dashboard.

This parameter is required.'),
  dashboardName?: string(name='dashboardName', description='The name of the dashboard.

This parameter is required.', example='dashboard-1609294922657-434834'),
  description?: string(name='description', description='The description of the dashboard.', example='test dashboard.'),
  displayName?: string(name='displayName', description='The display name of the dashboard.

This parameter is required.', example='Method pv'),
}

model UpdateDashboardResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates a dashboard.
 *
 * @description ### [](#)Usage notes
 * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request UpdateDashboardRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDashboardResponse
 */
async function updateDashboardWithOptions(project: string, dashboardName: string, request: UpdateDashboardRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDashboardResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.attribute)) {
    body['attribute'] = request.attribute;
  }
  if (!Util.isUnset(request.charts)) {
    body['charts'] = request.charts;
  }
  if (!Util.isUnset(request.dashboardName)) {
    body['dashboardName'] = request.dashboardName;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDashboard',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/dashboards/${dashboardName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates a dashboard.
 *
 * @description ### [](#)Usage notes
 * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request UpdateDashboardRequest
 * @return UpdateDashboardResponse
 */
async function updateDashboard(project: string, dashboardName: string, request: UpdateDashboardRequest): UpdateDashboardResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDashboardWithOptions(project, dashboardName, request, headers, runtime);
}

model UpdateETLRequest {
  configuration?: ETLConfiguration(name='configuration', description='This parameter is required.'),
  description?: string(name='description', example='this is description'),
  displayName?: string(name='displayName', description='This parameter is required.', example='this is update'),
}

model UpdateETLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 更新数据加工任务
 *
 * @param request UpdateETLRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateETLResponse
 */
async function updateETLWithOptions(project: string, etlName: string, request: UpdateETLRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateETLResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateETL',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/etls/${etlName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 更新数据加工任务
 *
 * @param request UpdateETLRequest
 * @return UpdateETLResponse
 */
async function updateETL(project: string, etlName: string, request: UpdateETLRequest): UpdateETLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateETLWithOptions(project, etlName, request, headers, runtime);
}

model UpdateIndexRequest {
  body?: Index(name='body', description='The request body.'),
}

model UpdateIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates the indexes of a Logstore.
 *
 * @description ### Usage notes
 * Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
 *
 * @param request UpdateIndexRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateIndexResponse
 */
async function updateIndexWithOptions(project: string, logstore: string, request: UpdateIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateIndexResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIndex',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/index`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates the indexes of a Logstore.
 *
 * @description ### Usage notes
 * Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
 *
 * @param request UpdateIndexRequest
 * @return UpdateIndexResponse
 */
async function updateIndex(project: string, logstore: string, request: UpdateIndexRequest): UpdateIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateIndexWithOptions(project, logstore, request, headers, runtime);
}

model UpdateLogStoreRequest {
  appendMeta?: boolean(name='appendMeta', description='Specifies whether to record public IP addresses. Default value: false. Valid values:

*   true
*   false', example='false'),
  autoSplit?: boolean(name='autoSplit', description='Specifies whether to enable automatic sharding. Valid values:

*   true
*   false', example='true'),
  enableTracking?: boolean(name='enable_tracking', description='Specifies whether to enable the web tracking feature. Default value: false. Valid values:

*   true
*   false', example='false'),
  encryptConf?: EncryptConf(name='encrypt_conf', description='The data structure of the encryption configuration.'),
  hotTtl?: int32(name='hot_ttl', description='The retention period of data in the hot storage tier of the Logstore. Valid values: 7 to 3000. Unit: days. After the retention period that is specified for the hot storage tier elapses, the data is moved to the Infrequent Access (IA) storage tier. For more information, see [Enable hot and cold-tiered storage for a Logstore](https://help.aliyun.com/document_detail/308645.html).', example='60'),
  infrequentAccessTTL?: int32(name='infrequentAccessTTL', description='The retention period of data in the IA storage tier of the Logstore. You must set this parameter to at least 30 days. After the data retention period that you specify for the IA storage tier elapses, the data is moved to the Archive storage tier.', example='30'),
  logstoreName?: string(name='logstoreName', description='The name of the Logstore.

This parameter is required.', example='test-logstore'),
  maxSplitShard?: int32(name='maxSplitShard', description='The maximum number of shards into which existing shards can be automatically split. Valid values: 1 to 256.

>  If you set autoSplit to true, you must specify maxSplitShard.', example='64'),
  mode?: string(name='mode', description='The type of the Logstore. Simple Log Service provides two types of Logstores: Standard Logstores and Query Logstores. Valid values:

*   **standard**: Standard Logstore. This type of Logstore supports the log analysis feature and is suitable for scenarios such as real-time monitoring and interactive analysis. You can also use this type of Logstore to build a comprehensive observability system.
*   **query**: Query Logstore. This type of Logstore supports high-performance queries. The index traffic fee of a Query Logstore is approximately half that of a Standard Logstore. Query Logstores do not support SQL analysis. Query Logstores are suitable for scenarios in which the amount of data is large, the log retention period is long, or log analysis is not required. If logs are stored for weeks or months, the log retention period is considered long.', example='standard'),
  shardCount?: int32(name='shardCount', description='The number of shards.

>  You cannot call the UpdateLogStore operation to change the number of shards. You can call the SplitShard or MergeShards operation to change the number of shards.', example='2', deprecated=true),
  telemetryType?: string(name='telemetryType', description='The type of the observable data. Valid values:

*   None (default): log data.
*   Metrics: metric data.', example='None', deprecated=true),
  ttl?: int32(name='ttl', description='The retention period of data. Unit: days. Valid values: 1 to 3650. If you set this parameter to 3650, logs are permanently stored.

This parameter is required.', example='30'),
}

model UpdateLogStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates the attributes of a Logstore.
 *
 * @description ### Usage notes
 * *   Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
 * *   You can call the UpdateLogStore operation to change only the time-to-live (TTL) attribute.
 *
 * @param request UpdateLogStoreRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateLogStoreResponse
 */
async function updateLogStoreWithOptions(project: string, logstore: string, request: UpdateLogStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogStoreResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.appendMeta)) {
    body['appendMeta'] = request.appendMeta;
  }
  if (!Util.isUnset(request.autoSplit)) {
    body['autoSplit'] = request.autoSplit;
  }
  if (!Util.isUnset(request.enableTracking)) {
    body['enable_tracking'] = request.enableTracking;
  }
  if (!Util.isUnset(request.encryptConf)) {
    body['encrypt_conf'] = request.encryptConf;
  }
  if (!Util.isUnset(request.hotTtl)) {
    body['hot_ttl'] = request.hotTtl;
  }
  if (!Util.isUnset(request.infrequentAccessTTL)) {
    body['infrequentAccessTTL'] = request.infrequentAccessTTL;
  }
  if (!Util.isUnset(request.logstoreName)) {
    body['logstoreName'] = request.logstoreName;
  }
  if (!Util.isUnset(request.maxSplitShard)) {
    body['maxSplitShard'] = request.maxSplitShard;
  }
  if (!Util.isUnset(request.mode)) {
    body['mode'] = request.mode;
  }
  if (!Util.isUnset(request.shardCount)) {
    body['shardCount'] = request.shardCount;
  }
  if (!Util.isUnset(request.telemetryType)) {
    body['telemetryType'] = request.telemetryType;
  }
  if (!Util.isUnset(request.ttl)) {
    body['ttl'] = request.ttl;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates the attributes of a Logstore.
 *
 * @description ### Usage notes
 * *   Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
 * *   You can call the UpdateLogStore operation to change only the time-to-live (TTL) attribute.
 *
 * @param request UpdateLogStoreRequest
 * @return UpdateLogStoreResponse
 */
async function updateLogStore(project: string, logstore: string, request: UpdateLogStoreRequest): UpdateLogStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogStoreWithOptions(project, logstore, request, headers, runtime);
}

model UpdateLogStoreEncryptionRequest {
  enable?: boolean(name='enable', description='Specifies whether to enable the encryption feature. After you update the encryption configuration of the Logstore, you can modify only the enable parameter in subsequent update requests. You cannot modify the encryptType or userCmkInfo parameters.

This parameter is required.', example='true'),
  encryptType?: string(name='encryptType', description='The encryption algorithm. Valid values: default, m4, sm4_ecb, sm4_cbc, sm4_gcm, aes_ecb, aes_cbc, aes_cfb, aes_ofb, and aes_gcm.', example='default'),
  userCmkInfo?: {
    keyId?: string(name='keyId', description='The ID of the CMK to which the BYOK key belongs. You can create a CMK in KMS. The CMK must be in the same region as the endpoint of Simple Log Service.', example='f5136b95-2420-ab31-xxxxxxxxx'),
    regionId?: string(name='regionId', description='The region ID. Example: cn-hangzhou.', example='cn-hangzhou'),
    roleArn?: string(name='roleArn', description='The Alibaba Cloud Resource Name (ARN) of the Resource Access Management (RAM) role.The value is in the acs:ram::12344\\\\*\\\\*\\\\*:role/xxxxx format. To use a BYOK key to encrypt logs, you must create a RAM role and grant the AliyunKMSReadOnlyAccess and AliyunKMSCryptoUserAccess permissions to the RAM role. You must grant the API caller the PassRole permission on the RAM role.', example='acs:ram::12344***:role/xxxxx'),
  }(name='userCmkInfo', description='Optional. If you use a BYOK key to encrypt logs, you must specify this parameter. If you use the service key of Simple Log Service to encrypt logs, you do not need to specify this parameter.'),
}

model UpdateLogStoreEncryptionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates the encryption configuration of a Logstore. You can create encryption configurations for the Logstore and enable or disable the encryption feature.
 *
 * @description ## [](#)Limits
 * If you specify a data encryption method when you configure data encryption settings, you cannot switch to the other method after the configuration. In addition, you cannot change the encryption algorithm or the encryption type. You can only enable or disable the encryption feature by using the enable parameter. If you specify the encryption method by using the service key of Simple Log Service when you configure data encryption settings, you cannot switch to the encryption method by using Bring Your Own Key (BYOK) keys after the configuration.
 * ## [](#)Create encryption configurations
 * ### [](#)Encryption by using service keys
 * Simple Log Service is fully responsible for data encryption and key management. No additional operations are required. When you create encryption configurations for the Logstore, you must specify the enable and encryptType parameters.
 * ### [](#byok)Encryption by using BYOK keys
 * You must create a customer master key (CMK) in Key Management Service (KMS). Then, Simple Log Service encrypts logs by using the CMK. When you create encryption configurations for the Logstore, you must specify the enable, encryptType, and userCmkInfo parameters.
 * ## [](#)Enable or disable the encryption feature
 * After you create encryption configurations for the Logstore, you cannot modify the encryptType or userCmkInfo parameters. However, you can enable and disable the encryption feature by using the enable parameter.
 *
 * @param request UpdateLogStoreEncryptionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateLogStoreEncryptionResponse
 */
async function updateLogStoreEncryptionWithOptions(project: string, logstore: string, request: UpdateLogStoreEncryptionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogStoreEncryptionResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.enable)) {
    body['enable'] = request.enable;
  }
  if (!Util.isUnset(request.encryptType)) {
    body['encryptType'] = request.encryptType;
  }
  if (!Util.isUnset(request.userCmkInfo)) {
    body['userCmkInfo'] = request.userCmkInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogStoreEncryption',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/encryption`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates the encryption configuration of a Logstore. You can create encryption configurations for the Logstore and enable or disable the encryption feature.
 *
 * @description ## [](#)Limits
 * If you specify a data encryption method when you configure data encryption settings, you cannot switch to the other method after the configuration. In addition, you cannot change the encryption algorithm or the encryption type. You can only enable or disable the encryption feature by using the enable parameter. If you specify the encryption method by using the service key of Simple Log Service when you configure data encryption settings, you cannot switch to the encryption method by using Bring Your Own Key (BYOK) keys after the configuration.
 * ## [](#)Create encryption configurations
 * ### [](#)Encryption by using service keys
 * Simple Log Service is fully responsible for data encryption and key management. No additional operations are required. When you create encryption configurations for the Logstore, you must specify the enable and encryptType parameters.
 * ### [](#byok)Encryption by using BYOK keys
 * You must create a customer master key (CMK) in Key Management Service (KMS). Then, Simple Log Service encrypts logs by using the CMK. When you create encryption configurations for the Logstore, you must specify the enable, encryptType, and userCmkInfo parameters.
 * ## [](#)Enable or disable the encryption feature
 * After you create encryption configurations for the Logstore, you cannot modify the encryptType or userCmkInfo parameters. However, you can enable and disable the encryption feature by using the enable parameter.
 *
 * @param request UpdateLogStoreEncryptionRequest
 * @return UpdateLogStoreEncryptionResponse
 */
async function updateLogStoreEncryption(project: string, logstore: string, request: UpdateLogStoreEncryptionRequest): UpdateLogStoreEncryptionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogStoreEncryptionWithOptions(project, logstore, request, headers, runtime);
}

model UpdateLogStoreMeteringModeRequest {
  meteringMode?: string(name='meteringMode', description='The billing mode. Valid values: ChargeByFunction and ChargeByDataIngest. Default value: ChargeByFunction. The value ChargeByFunction specifies the pay-by-feature billing mode. The value ChargeByDataIngest specifies the pay-by-ingested-data billing mode.

This parameter is required.', example='ChargeByFunction'),
}

model UpdateLogStoreMeteringModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Changes the billing mode of a Logstore.
 *
 * @param request UpdateLogStoreMeteringModeRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateLogStoreMeteringModeResponse
 */
async function updateLogStoreMeteringModeWithOptions(project: string, logstore: string, request: UpdateLogStoreMeteringModeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogStoreMeteringModeResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.meteringMode)) {
    body['meteringMode'] = request.meteringMode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogStoreMeteringMode',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/meteringmode`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Changes the billing mode of a Logstore.
 *
 * @param request UpdateLogStoreMeteringModeRequest
 * @return UpdateLogStoreMeteringModeResponse
 */
async function updateLogStoreMeteringMode(project: string, logstore: string, request: UpdateLogStoreMeteringModeRequest): UpdateLogStoreMeteringModeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogStoreMeteringModeWithOptions(project, logstore, request, headers, runtime);
}

model UpdateLogStoreProcessorRequest {
  processorName?: string(name='processorName', description='The identifier of the ingest processor.

This parameter is required.', example='parse-nginx-log'),
}

model UpdateLogStoreProcessorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Modifies the ingest processor that is associated with a Logstore.
 *
 * @param request UpdateLogStoreProcessorRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateLogStoreProcessorResponse
 */
async function updateLogStoreProcessorWithOptions(project: string, logstore: string, request: UpdateLogStoreProcessorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogStoreProcessorResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.processorName)) {
    body['processorName'] = request.processorName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogStoreProcessor',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/processor`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Modifies the ingest processor that is associated with a Logstore.
 *
 * @param request UpdateLogStoreProcessorRequest
 * @return UpdateLogStoreProcessorResponse
 */
async function updateLogStoreProcessor(project: string, logstore: string, request: UpdateLogStoreProcessorRequest): UpdateLogStoreProcessorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogStoreProcessorWithOptions(project, logstore, request, headers, runtime);
}

model UpdateLoggingRequest {
  loggingDetails?: [ 
    {
      logstore?: string(name='logstore', description='The name of the Logstore to which you want to save service logs.

This parameter is required.', example='my-logstore'),
      type?: string(name='type', description='The type of service logs. Valid values:

*   consumergroup_log: the consumption delay logs of consumer groups.
*   logtail_alarm: the alert logs of Logtail.
*   operation_log: the operation logs.
*   logtail_profile: the collection logs of Logtail.
*   metering: the metering logs.
*   logtail_status: the status logs of Logtail.
*   scheduledsqlalert: the operational logs of Scheduled SQL jobs.
*   etl_alert: the operational logs of data transformation jobs.

This parameter is required.', example='consumergroup_log'),
    }
  ](name='loggingDetails', description='The configurations of service logs.

This parameter is required.'),
  loggingProject?: string(name='loggingProject', description='The name of the project to which you want to save service logs.

This parameter is required.', example='my-project'),
}

model UpdateLoggingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates the service log configurations of a project.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request UpdateLoggingRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateLoggingResponse
 */
async function updateLoggingWithOptions(project: string, request: UpdateLoggingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLoggingResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.loggingDetails)) {
    body['loggingDetails'] = request.loggingDetails;
  }
  if (!Util.isUnset(request.loggingProject)) {
    body['loggingProject'] = request.loggingProject;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogging',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logging`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates the service log configurations of a project.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request UpdateLoggingRequest
 * @return UpdateLoggingResponse
 */
async function updateLogging(project: string, request: UpdateLoggingRequest): UpdateLoggingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLoggingWithOptions(project, request, headers, runtime);
}

model UpdateLogtailPipelineConfigRequest {
  aggregators?: [  map[string]any ](name='aggregators', description='The aggregation plug-ins.

>  This parameter takes effect only when extended plug-ins are used. You can use only one aggregation plug-in.'),
  configName?: string(name='configName', description='The name of the configuration.

>  The value of this parameter must be the same as the value of configName in the outer layer.

This parameter is required.', example='test-config'),
  flushers?: [  map[string]any ](name='flushers', description='The output plug-ins.

>  You can configure only one output plug-in.

This parameter is required.'),
  global?: map[string]any(name='global', description='The global settings.'),
  inputs?: [  map[string]any ](name='inputs', description='The input plug-ins.

>  You can configure only one input plug-in.

This parameter is required.'),
  logSample?: string(name='logSample', description='The sample log. You can specify multiple sample logs.', example='2022-06-14 11:13:29.796 | DEBUG    | __main__:<module>:1 - hello world'),
  processors?: [  map[string]any ](name='processors', description='The processing plug-ins.

>  Logtail plug-ins for data processing are classified into native plug-ins and extended plug-ins. For more information, see [Overview of Logtail plug-ins for data processing](https://help.aliyun.com/document_detail/64957.html).

> 

*   You can use native plug-ins only to collect text logs.

*   You cannot add native plug-ins and extended plug-ins at a time.

*   When you add native plug-ins, take note of the following items:

    *   You must add one of the following Logtail plug-ins for data processing as the first plug-in: Data Parsing (Regex Mode), Data Parsing (Delimiter Mode), Data Parsing (JSON Mode), Data Parsing (NGINX Mode), Data Parsing (Apache Mode), and Data Parsing (IIS Mode).
    *   After you add the first plug-in, you can add one Time Parsing plug-in, one Data Filtering plug-in, and multiple Data Masking plug-ins.'),
}

model UpdateLogtailPipelineConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates a Logtail pipeline configuration.
 *
 * @description The UK (London) region is supported. Supported regions are constantly updated.
 *
 * @param request UpdateLogtailPipelineConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateLogtailPipelineConfigResponse
 */
async function updateLogtailPipelineConfigWithOptions(project: string, configName: string, request: UpdateLogtailPipelineConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogtailPipelineConfigResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.aggregators)) {
    body['aggregators'] = request.aggregators;
  }
  if (!Util.isUnset(request.configName)) {
    body['configName'] = request.configName;
  }
  if (!Util.isUnset(request.flushers)) {
    body['flushers'] = request.flushers;
  }
  if (!Util.isUnset(request.global)) {
    body['global'] = request.global;
  }
  if (!Util.isUnset(request.inputs)) {
    body['inputs'] = request.inputs;
  }
  if (!Util.isUnset(request.logSample)) {
    body['logSample'] = request.logSample;
  }
  if (!Util.isUnset(request.processors)) {
    body['processors'] = request.processors;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogtailPipelineConfig',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/pipelineconfigs/${configName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates a Logtail pipeline configuration.
 *
 * @description The UK (London) region is supported. Supported regions are constantly updated.
 *
 * @param request UpdateLogtailPipelineConfigRequest
 * @return UpdateLogtailPipelineConfigResponse
 */
async function updateLogtailPipelineConfig(project: string, configName: string, request: UpdateLogtailPipelineConfigRequest): UpdateLogtailPipelineConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogtailPipelineConfigWithOptions(project, configName, request, headers, runtime);
}

model UpdateMachineGroupRequest {
  groupAttribute?: {
    externalName?: string(name='externalName', description='The identifier of the external management system on which the machine group depends. This parameter is empty by default.', example='testgroup2'),
    groupTopic?: string(name='groupTopic', description='The topic of the machine group. This parameter is empty by default.', example='testtopic2'),
  }(name='groupAttribute', description='The attribute of the machine group. This parameter is empty by default.'),
  groupName?: string(name='groupName', description='The name of the machine group.

This parameter is required.', example='test-machine-group'),
  groupType?: string(name='groupType', description='The type of the machine group. Set the value to an empty string.', example='""'),
  machineIdentifyType?: string(name='machineIdentifyType', description='The identifier type of the machine group. Valid values:

*   ip: The machine group uses IP addresses as identifiers.
*   userdefined: The machine group uses custom identifiers.

This parameter is required.', example='userdefined'),
  machineList?: [ string ](name='machineList', description='The identifiers of the machines in the machine group.

*   If you set machineIdentifyType to ip, enter the IP addresses of the machines.
*   If you set machineIdentifyType to userdefined, enter a custom identifier.

This parameter is required.', example='[uu_id_1，uu_id_2]'),
}

model UpdateMachineGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Modifies the configuration of a machine group.
 *
 * @description Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
 *
 * @param request UpdateMachineGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateMachineGroupResponse
 */
async function updateMachineGroupWithOptions(project: string, groupName: string, request: UpdateMachineGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMachineGroupResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupAttribute)) {
    body['groupAttribute'] = request.groupAttribute;
  }
  if (!Util.isUnset(request.groupName)) {
    body['groupName'] = request.groupName;
  }
  if (!Util.isUnset(request.groupType)) {
    body['groupType'] = request.groupType;
  }
  if (!Util.isUnset(request.machineIdentifyType)) {
    body['machineIdentifyType'] = request.machineIdentifyType;
  }
  if (!Util.isUnset(request.machineList)) {
    body['machineList'] = request.machineList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${groupName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Modifies the configuration of a machine group.
 *
 * @description Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
 *
 * @param request UpdateMachineGroupRequest
 * @return UpdateMachineGroupResponse
 */
async function updateMachineGroup(project: string, groupName: string, request: UpdateMachineGroupRequest): UpdateMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMachineGroupWithOptions(project, groupName, request, headers, runtime);
}

model UpdateMachineGroupMachineRequest {
  action?: string(name='action', description='The operation on the machine. Valid values: add and delete. A value of add specifies to add the machine to the machine group. A value of delete specifies to remove the machine from the machine group.', example='add'),
  body?: [ string ](name='body', description='The machines to be added or removed.

This parameter is required.'),
}

model UpdateMachineGroupMachineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Modifies the machines in a machine group. You can add machine to or remove machines from the machine group.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request UpdateMachineGroupMachineRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateMachineGroupMachineResponse
 */
async function updateMachineGroupMachineWithOptions(project: string, machineGroup: string, request: UpdateMachineGroupMachineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMachineGroupMachineResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.action)) {
    query['action'] = request.action;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateMachineGroupMachine',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}/machines`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Modifies the machines in a machine group. You can add machine to or remove machines from the machine group.
 *
 * @description Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request UpdateMachineGroupMachineRequest
 * @return UpdateMachineGroupMachineResponse
 */
async function updateMachineGroupMachine(project: string, machineGroup: string, request: UpdateMachineGroupMachineRequest): UpdateMachineGroupMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMachineGroupMachineWithOptions(project, machineGroup, request, headers, runtime);
}

model UpdateMaxComputeExportRequest {
  configuration?: MaxComputeExportConfiguration(name='configuration', description='The setting of the MaxCompute data shipping job.

This parameter is required.'),
  description?: string(name='description', description='The description of the MaxCompute data shipping job.'),
  displayName?: string(name='displayName', description='The display name of the MaxCompute data shipping job.

This parameter is required.', example='my-mc-job'),
}

model UpdateMaxComputeExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates a MaxCompute data shipping job.
 *
 * @description *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
 *
 * @param request UpdateMaxComputeExportRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateMaxComputeExportResponse
 */
async function updateMaxComputeExportWithOptions(project: string, mcExportName: string, request: UpdateMaxComputeExportRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMaxComputeExportResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMaxComputeExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/maxcomputeexports/${mcExportName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates a MaxCompute data shipping job.
 *
 * @description *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
 *
 * @param request UpdateMaxComputeExportRequest
 * @return UpdateMaxComputeExportResponse
 */
async function updateMaxComputeExport(project: string, mcExportName: string, request: UpdateMaxComputeExportRequest): UpdateMaxComputeExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMaxComputeExportWithOptions(project, mcExportName, request, headers, runtime);
}

model UpdateMetricStoreRequest {
  autoSplit?: boolean(name='autoSplit', description='Specifies whether to enable automatic sharding.', example='true'),
  hotTtl?: int32(name='hot_ttl'),
  infrequentAccessTTL?: int32(name='infrequentAccessTTL'),
  maxSplitShard?: int32(name='maxSplitShard', description='The maximum number of shards into which existing shards can be automatically split. This parameter is valid only when you set the autoSplit parameter to true.', example='64'),
  mode?: string(name='mode', description='The type of the Metricstore.', example='standard'),
  ttl?: int32(name='ttl', description='The retention period of the metric data. Unit: days.', example='7'),
}

model UpdateMetricStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates the settings of an existing Metricstore. Metricstores are used to store metric data.
 *
 * @description Metricstores are used to store metric data. For more information, see [Metric data](https://help.aliyun.com/document_detail/174965.html).
 * *   You must specify an existing Metricstore.
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query metric data is obtained. The information includes the name of the project to which the metric data belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 * *   You can create up to 200 Logstores or Metricstores in a project.
 * *   Metric data is automatically deleted when the retention period of the metric data ends.
 *
 * @param request UpdateMetricStoreRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateMetricStoreResponse
 */
async function updateMetricStoreWithOptions(project: string, name: string, request: UpdateMetricStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMetricStoreResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoSplit)) {
    body['autoSplit'] = request.autoSplit;
  }
  if (!Util.isUnset(request.hotTtl)) {
    body['hot_ttl'] = request.hotTtl;
  }
  if (!Util.isUnset(request.infrequentAccessTTL)) {
    body['infrequentAccessTTL'] = request.infrequentAccessTTL;
  }
  if (!Util.isUnset(request.maxSplitShard)) {
    body['maxSplitShard'] = request.maxSplitShard;
  }
  if (!Util.isUnset(request.mode)) {
    body['mode'] = request.mode;
  }
  if (!Util.isUnset(request.ttl)) {
    body['ttl'] = request.ttl;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMetricStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/metricstores/${name}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates the settings of an existing Metricstore. Metricstores are used to store metric data.
 *
 * @description Metricstores are used to store metric data. For more information, see [Metric data](https://help.aliyun.com/document_detail/174965.html).
 * *   You must specify an existing Metricstore.
 * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * *   The information that is required to query metric data is obtained. The information includes the name of the project to which the metric data belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
 * *   You can create up to 200 Logstores or Metricstores in a project.
 * *   Metric data is automatically deleted when the retention period of the metric data ends.
 *
 * @param request UpdateMetricStoreRequest
 * @return UpdateMetricStoreResponse
 */
async function updateMetricStore(project: string, name: string, request: UpdateMetricStoreRequest): UpdateMetricStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMetricStoreWithOptions(project, name, request, headers, runtime);
}

model UpdateMetricStoreMeteringModeRequest {
  meteringMode?: string(name='meteringMode', description='This parameter is required.', example='ChargeByFunction'),
}

model UpdateMetricStoreMeteringModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 更新 MetricStore 计量模式
 *
 * @param request UpdateMetricStoreMeteringModeRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateMetricStoreMeteringModeResponse
 */
async function updateMetricStoreMeteringModeWithOptions(project: string, metricStore: string, request: UpdateMetricStoreMeteringModeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMetricStoreMeteringModeResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.meteringMode)) {
    body['meteringMode'] = request.meteringMode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMetricStoreMeteringMode',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/metricstores/${metricStore}/meteringmode`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 更新 MetricStore 计量模式
 *
 * @param request UpdateMetricStoreMeteringModeRequest
 * @return UpdateMetricStoreMeteringModeResponse
 */
async function updateMetricStoreMeteringMode(project: string, metricStore: string, request: UpdateMetricStoreMeteringModeRequest): UpdateMetricStoreMeteringModeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMetricStoreMeteringModeWithOptions(project, metricStore, request, headers, runtime);
}

model UpdateMetricStoreProcessorRequest {
  processorName?: string(name='processorName', description='The identifier of the ingest processor.

This parameter is required.', example='filter-metrics'),
}

model UpdateMetricStoreProcessorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates the ingest processor that is associated with a Metricstore.
 *
 * @param request UpdateMetricStoreProcessorRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateMetricStoreProcessorResponse
 */
async function updateMetricStoreProcessorWithOptions(project: string, metricstore: string, request: UpdateMetricStoreProcessorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMetricStoreProcessorResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.processorName)) {
    body['processorName'] = request.processorName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMetricStoreProcessor',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/metricstores/${metricstore}/processor`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates the ingest processor that is associated with a Metricstore.
 *
 * @param request UpdateMetricStoreProcessorRequest
 * @return UpdateMetricStoreProcessorResponse
 */
async function updateMetricStoreProcessor(project: string, metricstore: string, request: UpdateMetricStoreProcessorRequest): UpdateMetricStoreProcessorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMetricStoreProcessorWithOptions(project, metricstore, request, headers, runtime);
}

model UpdateOSSExportRequest {
  configuration?: OSSExportConfiguration(name='configuration', description='The configuration details of the job.'),
  description?: string(name='description', description='The description of the job.'),
  displayName?: string(name='displayName', description='The display name of the job.', example='ali-test-oss-job'),
}

model UpdateOSSExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 更新OSS投递任务
 *
 * @param request UpdateOSSExportRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateOSSExportResponse
 */
async function updateOSSExportWithOptions(project: string, ossExportName: string, request: UpdateOSSExportRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateOSSExportResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOSSExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossexports/${ossExportName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 更新OSS投递任务
 *
 * @param request UpdateOSSExportRequest
 * @return UpdateOSSExportResponse
 */
async function updateOSSExport(project: string, ossExportName: string, request: UpdateOSSExportRequest): UpdateOSSExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateOSSExportWithOptions(project, ossExportName, request, headers, runtime);
}

model UpdateOSSHDFSExportRequest {
  configuration?: OSSExportConfiguration(name='configuration', description='The configuration details of the job.

This parameter is required.'),
  description?: string(name='description', description='The description of the job.'),
  displayName?: string(name='displayName', description='The display name of the job.

This parameter is required.', example='ali-test-oss-hdfs-job'),
}

model UpdateOSSHDFSExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 更新OSSHDFS投递任务
 *
 * @param request UpdateOSSHDFSExportRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateOSSHDFSExportResponse
 */
async function updateOSSHDFSExportWithOptions(project: string, ossExportName: string, request: UpdateOSSHDFSExportRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateOSSHDFSExportResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOSSHDFSExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/osshdfsexports/${ossExportName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 更新OSSHDFS投递任务
 *
 * @param request UpdateOSSHDFSExportRequest
 * @return UpdateOSSHDFSExportResponse
 */
async function updateOSSHDFSExport(project: string, ossExportName: string, request: UpdateOSSHDFSExportRequest): UpdateOSSHDFSExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateOSSHDFSExportWithOptions(project, ossExportName, request, headers, runtime);
}

model UpdateOSSIngestionRequest {
  configuration?: OSSIngestionConfiguration(name='configuration', description='The configurations of the OSS data import job.

This parameter is required.'),
  description?: string(name='description', description='The description of the OSS data import job.'),
  displayName?: string(name='displayName', description='The display name of the OSS data import job.

This parameter is required.'),
  schedule?: Schedule(name='schedule', description='The scheduling type. By default, you do not need to specify this parameter. If you want to import data at regular intervals, such as importing data every Monday at 08: 00., you can specify a cron expression.'),
}

model UpdateOSSIngestionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates an Object Storage Service (OSS) data import job.
 *
 * @param request UpdateOSSIngestionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateOSSIngestionResponse
 */
async function updateOSSIngestionWithOptions(project: string, ossIngestionName: string, request: UpdateOSSIngestionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateOSSIngestionResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.schedule)) {
    body['schedule'] = request.schedule;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOSSIngestion',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossingestions/${ossIngestionName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates an Object Storage Service (OSS) data import job.
 *
 * @param request UpdateOSSIngestionRequest
 * @return UpdateOSSIngestionResponse
 */
async function updateOSSIngestion(project: string, ossIngestionName: string, request: UpdateOSSIngestionRequest): UpdateOSSIngestionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateOSSIngestionWithOptions(project, ossIngestionName, request, headers, runtime);
}

model UpdateOssExternalStoreRequest {
  externalStoreName?: string(name='externalStoreName', description='The name of the external store.

This parameter is required.', example='test-oss-store'),
  parameter?: {
    accessid?: string(name='accessid', description='The AccessKey ID of your account.

This parameter is required.', example='LTAI5tFsHGGeYry*****1Sz'),
    accesskey?: string(name='accesskey', description='The AccessKey secret of your account.

This parameter is required.', example='GyviCLDVHkHrOztdkxuE6******Rp6'),
    bucket?: string(name='bucket', description='The name of the OSS bucket.

This parameter is required.', example='my-bucket'),
    columns?: [ 
      {
        name?: string(name='name', description='The name of the field.

This parameter is required.', example='test'),
        type?: string(name='type', description='The type of the field.

This parameter is required.', example='varchar'),
      }
    ](name='columns', description='The fields that are associated to the external store.

This parameter is required.'),
    endpoint?: string(name='endpoint', description='The Object Storage Service (OSS) endpoint.

This parameter is required.', example='oss-cn-hangzhou.aliyuncs.com'),
    objects?: [ string ](name='objects', description='The names of the OSS objects that are associated to the external store.

This parameter is required.'),
  }(name='parameter', description='The parameters that are configured for the external store.

This parameter is required.'),
  storeType?: string(name='storeType', description='The type of the external store. Set the value to oss.

This parameter is required.', example='oss'),
}

model UpdateOssExternalStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates an Object Storage Service (OSS) external store.
 *
 * @description ### [](#)Usage notes
 * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request UpdateOssExternalStoreRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateOssExternalStoreResponse
 */
async function updateOssExternalStoreWithOptions(project: string, externalStoreName: string, request: UpdateOssExternalStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateOssExternalStoreResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.externalStoreName)) {
    body['externalStoreName'] = request.externalStoreName;
  }
  if (!Util.isUnset(request.parameter)) {
    body['parameter'] = request.parameter;
  }
  if (!Util.isUnset(request.storeType)) {
    body['storeType'] = request.storeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOssExternalStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/externalstores/${externalStoreName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates an Object Storage Service (OSS) external store.
 *
 * @description ### [](#)Usage notes
 * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 *
 * @param request UpdateOssExternalStoreRequest
 * @return UpdateOssExternalStoreResponse
 */
async function updateOssExternalStore(project: string, externalStoreName: string, request: UpdateOssExternalStoreRequest): UpdateOssExternalStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateOssExternalStoreWithOptions(project, externalStoreName, request, headers, runtime);
}

model UpdateProjectRequest {
  description?: string(name='description', description='The description of the project. The default value is an empty string.

This parameter is required.', example='Description of my-project-test'),
  recycleBinEnabled?: boolean(name='recycleBinEnabled'),
}

model UpdateProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates a project.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:UpdateProject`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}`|
 *
 * @param request UpdateProjectRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateProjectResponse
 */
async function updateProjectWithOptions(project: string, request: UpdateProjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProjectResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.recycleBinEnabled)) {
    body['recycleBinEnabled'] = request.recycleBinEnabled;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates a project.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:UpdateProject`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}`|
 *
 * @param request UpdateProjectRequest
 * @return UpdateProjectResponse
 */
async function updateProject(project: string, request: UpdateProjectRequest): UpdateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProjectWithOptions(project, request, headers, runtime);
}

model UpdateRdsExternalStoreRequest {
  externalStoreName?: string(name='externalStoreName', description='The name of the external store.

This parameter is required.', example='rds_store'),
  parameter?: {
    db?: string(name='db', description='The name of the database in the ApsaraDB RDS for MySQL instance.

This parameter is required.', example='meta'),
    host?: string(name='host', description='The internal or public endpoint of the ApsaraDB RDS for MySQL instance.', example='192.168.XX.XX'),
    instanceId?: string(name='instance-id', description='The ID of the ApsaraDB RDS for MySQL instance.', example='i-bp1b6c719dfa08exf****'),
    password?: string(name='password', description='The password that is used to log on to the ApsaraDB RDS for MySQL instance.

This parameter is required.', example='sfdsfldsfksfls****'),
    port?: string(name='port', description='The internal or public port of the ApsaraDB RDS for MySQL instance.

This parameter is required.', example='3306'),
    region?: string(name='region', description='The region where the ApsaraDB RDS for MySQL instance resides. Valid values: cn-qingdao, cn-beijing, and cn-hangzhou.

This parameter is required.', example='cn-qingdao'),
    table?: string(name='table', description='The name of the database table in the ApsaraDB RDS for MySQL instance.

This parameter is required.', example='join_meta'),
    username?: string(name='username', description='The username that is used to log on to the ApsaraDB RDS for MySQL instance.

This parameter is required.', example='root'),
    vpcId?: string(name='vpc-id', description='The ID of the VPC to which the ApsaraDB RDS for MySQL instance belongs.', example='vpc-bp1aevy8sofi8mh1q****'),
  }(name='parameter', description='The parameter struct.

This parameter is required.'),
  storeType?: string(name='storeType', description='The storage type. Set the value to rds-vpc, which indicates an ApsaraDB RDS for MySQL database in a virtual private cloud (VPC).

This parameter is required.', example='rds-vpc'),
}

model UpdateRdsExternalStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates an ApsaraDB RDS external store.
 *
 * @description Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
 *
 * @param request UpdateRdsExternalStoreRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateRdsExternalStoreResponse
 */
async function updateRdsExternalStoreWithOptions(project: string, externalStoreName: string, request: UpdateRdsExternalStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRdsExternalStoreResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.externalStoreName)) {
    body['externalStoreName'] = request.externalStoreName;
  }
  if (!Util.isUnset(request.parameter)) {
    body['parameter'] = request.parameter;
  }
  if (!Util.isUnset(request.storeType)) {
    body['storeType'] = request.storeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRdsExternalStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/externalstores/${externalStoreName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates an ApsaraDB RDS external store.
 *
 * @description Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
 *
 * @param request UpdateRdsExternalStoreRequest
 * @return UpdateRdsExternalStoreResponse
 */
async function updateRdsExternalStore(project: string, externalStoreName: string, request: UpdateRdsExternalStoreRequest): UpdateRdsExternalStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRdsExternalStoreWithOptions(project, externalStoreName, request, headers, runtime);
}

model UpdateSavedSearchRequest {
  displayName?: string(name='displayName', description='The display name.

This parameter is required.', example='displayname'),
  logstore?: string(name='logstore', description='The name of the Logstore to which the saved search belongs.

This parameter is required.', example='aliyun-test-logstore'),
  savedsearchName?: string(name='savedsearchName', description='The name of the saved search. The name must be 3 to 63 characters in length.

This parameter is required.', example='savedsearch-name'),
  searchQuery?: string(name='searchQuery', description='The query statement of the saved search. A query statement consists of a search statement and an analytic statement in the Search statement|Analytic statement format. For more information, see [Log search overview](https://help.aliyun.com/document_detail/43772.html) and [Log analysis overview](https://help.aliyun.com/document_detail/53608.html).

This parameter is required.', example='*|select date_format(__time__-__time__%60, \\\\"%H:%i:%s\\\\") as time, COUNT(*) as pv group by time'),
  topic?: string(name='topic', description='The topic of the logs.', example='theme'),
}

model UpdateSavedSearchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates a saved search.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 * * Limits are imposed when you use Simple Log Service to query logs. We recommend that you specify query statements and query time ranges based on the limits. For more information, see [Log search overview](https://help.aliyun.com/document_detail/43772.html) and [Log analysis overview](https://help.aliyun.com/document_detail/53608.html).
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:UpdateSavedSearch`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/savedsearch/{#SavedSearchName}`|
 *
 * @param request UpdateSavedSearchRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSavedSearchResponse
 */
async function updateSavedSearchWithOptions(project: string, savedsearchName: string, request: UpdateSavedSearchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSavedSearchResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.logstore)) {
    body['logstore'] = request.logstore;
  }
  if (!Util.isUnset(request.savedsearchName)) {
    body['savedsearchName'] = request.savedsearchName;
  }
  if (!Util.isUnset(request.searchQuery)) {
    body['searchQuery'] = request.searchQuery;
  }
  if (!Util.isUnset(request.topic)) {
    body['topic'] = request.topic;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSavedSearch',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/savedsearches/${savedsearchName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates a saved search.
 *
 * @description ### Usage notes
 * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
 * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
 * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
 * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
 * * Limits are imposed when you use Simple Log Service to query logs. We recommend that you specify query statements and query time ranges based on the limits. For more information, see [Log search overview](https://help.aliyun.com/document_detail/43772.html) and [Log analysis overview](https://help.aliyun.com/document_detail/53608.html).
 * ### Authentication resources
 * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
 * |Action|Resource|
 * |:---|:---|
 * |`log:UpdateSavedSearch`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/savedsearch/{#SavedSearchName}`|
 *
 * @param request UpdateSavedSearchRequest
 * @return UpdateSavedSearchResponse
 */
async function updateSavedSearch(project: string, savedsearchName: string, request: UpdateSavedSearchRequest): UpdateSavedSearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSavedSearchWithOptions(project, savedsearchName, request, headers, runtime);
}

model UpdateScheduledSQLRequest {
  configuration?: ScheduledSQLConfiguration(name='configuration', description='This parameter is required.'),
  description?: string(name='description'),
  displayName?: string(name='displayName', description='This parameter is required.', example='ali-test-scheduled-sql'),
  schedule?: Schedule(name='schedule', description='This parameter is required.'),
}

model UpdateScheduledSQLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates a Scheduled SQL job.
 *
 * @param request UpdateScheduledSQLRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateScheduledSQLResponse
 */
async function updateScheduledSQLWithOptions(project: string, scheduledSQLName: string, request: UpdateScheduledSQLRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateScheduledSQLResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.schedule)) {
    body['schedule'] = request.schedule;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateScheduledSQL',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/scheduledsqls/${scheduledSQLName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates a Scheduled SQL job.
 *
 * @param request UpdateScheduledSQLRequest
 * @return UpdateScheduledSQLResponse
 */
async function updateScheduledSQL(project: string, scheduledSQLName: string, request: UpdateScheduledSQLRequest): UpdateScheduledSQLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateScheduledSQLWithOptions(project, scheduledSQLName, request, headers, runtime);
}

model UpdateSqlInstanceRequest {
  cu?: int32(name='cu', description='This parameter is required.', example='2'),
  useAsDefault?: boolean(name='useAsDefault', description='This parameter is required.'),
}

model UpdateSqlInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates the configurations of the Dedicated SQL feature.
 *
 * @param request UpdateSqlInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSqlInstanceResponse
 */
async function updateSqlInstanceWithOptions(project: string, request: UpdateSqlInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSqlInstanceResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.cu)) {
    body['cu'] = request.cu;
  }
  if (!Util.isUnset(request.useAsDefault)) {
    body['useAsDefault'] = request.useAsDefault;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSqlInstance',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/sqlinstance`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates the configurations of the Dedicated SQL feature.
 *
 * @param request UpdateSqlInstanceRequest
 * @return UpdateSqlInstanceResponse
 */
async function updateSqlInstance(project: string, request: UpdateSqlInstanceRequest): UpdateSqlInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSqlInstanceWithOptions(project, request, headers, runtime);
}

model UpdateStoreViewRequest {
  storeType?: string(name='storeType', description='The type of the dataset.

Valid values:

*   metricstore

    <!-- -->

    <!-- -->

    <!-- -->

*   logstore

    <!-- -->

    <!-- -->

    <!-- -->

This parameter is required.', example='logstore'),
  stores?: [
    StoreViewStore
  ](name='stores', description='The Logstores or Metricstores.

This parameter is required.'),
}

model UpdateStoreViewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates the configurations of a dataset.
 *
 * @param request UpdateStoreViewRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateStoreViewResponse
 */
async function updateStoreViewWithOptions(project: string, name: string, request: UpdateStoreViewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateStoreViewResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.storeType)) {
    body['storeType'] = request.storeType;
  }
  if (!Util.isUnset(request.stores)) {
    body['stores'] = request.stores;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateStoreView',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/storeviews/${name}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates the configurations of a dataset.
 *
 * @param request UpdateStoreViewRequest
 * @return UpdateStoreViewResponse
 */
async function updateStoreView(project: string, name: string, request: UpdateStoreViewRequest): UpdateStoreViewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateStoreViewWithOptions(project, name, request, headers, runtime);
}

model UpsertCollectionPolicyRequest {
  centralizeConfig?: {
    destLogstore?: string(name='destLogstore', description='The destination logstore for centralized storage. Make sure that the region of the destination logstore is consistent with the region specified by destRegion and the destination logstore belongs to the destination project specified by destProject.', example='your-sls-logstore-in-beijing'),
    destProject?: string(name='destProject', description='The destination project for centralized storage. Make sure that the region of the destination project is consistent with the region specified by destRegion.', example='your-sls-project-in-beijing'),
    destRegion?: string(name='destRegion', description='The destination region for centralized storage.', example='cn-beijing'),
    destTTL?: int32(name='destTTL', description='The data retention period for centralized storage. Unit: days. This parameter takes effect only when you use an existing logstore for centralized storage.', example='your-sls-logstore-ttl'),
  }(name='centralizeConfig', description='The configurations of centralized storage.'),
  centralizeEnabled?: boolean(name='centralizeEnabled', description='Specifies whether to enable centralized storage. Default value: false.', example='false'),
  dataCode?: string(name='dataCode', description='The code of the log type.

This parameter is required.', example='access_log'),
  dataConfig?: {
    dataRegion?: string(name='dataRegion', description='The region for storing the global logs that are collected for the first time.', example='cn-beijing'),
  }(name='dataConfig', description='The data configurations. The configuration is returned only for global logs. For example, if productCode is set to sls, the configuration is returned.'),
  enabled?: boolean(name='enabled', description='Specifies whether to enable the policy.

This parameter is required.', example='true'),
  policyConfig?: {
    instanceIds?: [ string ](name='instanceIds', description='The IDs of the instances. This parameter takes effect only when resourceMode is set to instanceMode. Logs are collected only from instances that use the specified IDs.'),
    regions?: [ string ](name='regions', description='The regions of the instances. This parameter takes effect only when resourceMode is set to attributeMode. Wildcard characters are supported. If you leave this parameter empty, region-based filtering is not performed. The system considers that all instances are matched. If you specify a value for this parameter, logs of instances that reside in the specified regions are collected. Logs are collected from an instance only if the resource tags and region of the instance match the specified conditions.'),
    resourceMode?: string(name='resourceMode', description='The resource collection mode. Valid values: all, attributeMode, and instanceMode. The value all specifies that logs of all instances within your account are collected to the default logstore. The value attributeMode specifies that logs are collected based on the regions of instances and resource tags. The value instanceMode specifies that logs are collected based on instance IDs.

This parameter is required.', example='all'),
    resourceTags?: map[string]any(name='resourceTags', description='The resource tags. This parameter takes effect only when resourceMode is set to attributeMode. If you leave this parameter empty, resource tag-based filtering is not performed. The system considers that all instances are matched. If you specify a value for this parameter, logs of instances that use the specified resource tags are collected. Logs are collected from an instance only if the resource tags and region of the instance match the specified conditions.', example='{"tag1":"value1",“tag2":"value2"}'),
  }(name='policyConfig', description='The configurations of the policy.

This parameter is required.'),
  policyName?: string(name='policyName', description='The name must meet the following requirements:

*   The name can contain only lowercase letters, digits, hyphens (-), and underscores (_).
*   The name must start with a letter.
*   The name must be 3 to 63 characters in length.

This parameter is required.', example='your_log_policy'),
  productCode?: string(name='productCode', description='The code of the service.

This parameter is required.', example='oss'),
  resourceDirectory?: {
    accountGroupType?: string(name='accountGroupType', description='The mode of the resource directory. Valid values: all and custom.', example='all,custom'),
    members?: [ string ](name='members', description='The members. If accountGroupType is set to custom, the members are returned.'),
  }(name='resourceDirectory', description='The configurations of the resource directory. The account must have activated the resource directory and be a management account or a delegated administrator of the resource directory.'),
}

model UpsertCollectionPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 调用UpsertCollectionPolicy接口创建或更新日志采集规则
 *
 * @param request UpsertCollectionPolicyRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpsertCollectionPolicyResponse
 */
async function upsertCollectionPolicyWithOptions(request: UpsertCollectionPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpsertCollectionPolicyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.centralizeConfig)) {
    body['centralizeConfig'] = request.centralizeConfig;
  }
  if (!Util.isUnset(request.centralizeEnabled)) {
    body['centralizeEnabled'] = request.centralizeEnabled;
  }
  if (!Util.isUnset(request.dataCode)) {
    body['dataCode'] = request.dataCode;
  }
  if (!Util.isUnset(request.dataConfig)) {
    body['dataConfig'] = request.dataConfig;
  }
  if (!Util.isUnset(request.enabled)) {
    body['enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.policyConfig)) {
    body['policyConfig'] = request.policyConfig;
  }
  if (!Util.isUnset(request.policyName)) {
    body['policyName'] = request.policyName;
  }
  if (!Util.isUnset(request.productCode)) {
    body['productCode'] = request.productCode;
  }
  if (!Util.isUnset(request.resourceDirectory)) {
    body['resourceDirectory'] = request.resourceDirectory;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpsertCollectionPolicy',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/collectionpolicy`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 调用UpsertCollectionPolicy接口创建或更新日志采集规则
 *
 * @param request UpsertCollectionPolicyRequest
 * @return UpsertCollectionPolicyResponse
 */
async function upsertCollectionPolicy(request: UpsertCollectionPolicyRequest): UpsertCollectionPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return upsertCollectionPolicyWithOptions(request, headers, runtime);
}

