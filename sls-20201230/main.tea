/**
 *
 */
import Util;
import SPI;
import GatewayClient;
import OpenApi;
import OpenApiUtil;

extends OpenApi;

type @client = SPI

init(config: OpenApi.Config){
  super(config);
  @client = new GatewayClient();
  @spi = @client;
  @endpointRule = 'central';
  }

model ConsumerGroup {
  name?: string(name='name'),
  order?: boolean(name='order'),
  timeout?: int32(name='timeout'),
}

model EncryptConf {
  enable?: boolean(name='enable'),
  encryptType?: string(name='encrypt_type'),
  userCmkInfo?: EncryptUserCmkConf(name='user_cmk_info'),
}

model EncryptUserCmkConf {
  arn?: string(name='arn'),
  cmkKeyId?: string(name='cmk_key_id'),
  regionId?: string(name='region_id'),
}

model Histogram {
  count?: long(name='count'),
  from?: int32(name='from'),
  progress?: string(name='progress'),
  to?: int32(name='to'),
}

model LogtailConfig {
  configName?: string(name='configName'),
  createTime?: long(name='createTime'),
  inputDetail?: map[string]any(name='inputDetail'),
  inputType?: string(name='inputType'),
  lastModifyTime?: long(name='lastModifyTime'),
  logSample?: string(name='logSample'),
  outputDetail?: {
    endpoint?: string(name='endpoint'),
    logstoreName?: string(name='logstoreName'),
    region?: string(name='region'),
  }(name='outputDetail'),
  outputType?: string(name='outputType'),
}

model SavedSearch {
  displayName?: string(name='displayName'),
  logstore?: string(name='logstore'),
  savedsearchName?: string(name='savedsearchName'),
  searchQuery?: string(name='searchQuery'),
  topic?: string(name='topic'),
}

model Chart {
  action?: map[string]any(name='action'),
  display?: map[string]any(name='display'),
  search?: map[string]any(name='search'),
  title?: string(name='title'),
  type?: string(name='type'),
}

model Dashboard {
  attribute?: map[string]string(name='attribute'),
  charts?: [
    Chart
  ](name='charts'),
  dashboardName?: string(name='dashboardName'),
  description?: string(name='description'),
  displayName?: string(name='displayName'),
}

model EtlJob {
  enable?: boolean(name='enable'),
  etlJobName?: string(name='etlJobName'),
  functionConfig?: {
    accountId?: string(name='accountId'),
    endpoint?: string(name='endpoint'),
    functionName?: string(name='functionName'),
    functionProvider?: string(name='functionProvider'),
    regionName?: string(name='regionName'),
    roleArn?: string(name='roleArn'),
    serviceName?: string(name='serviceName'),
  }(name='functionConfig'),
  functionParameter?: map[string]any(name='functionParameter'),
  logConfig?: {
    endpoint?: string(name='endpoint'),
    logstoreName?: string(name='logstoreName'),
    projectName?: string(name='projectName'),
  }(name='logConfig'),
  sourceConfig?: {
    logstoreName?: string(name='logstoreName'),
  }(name='sourceConfig'),
  triggerConfig?: {
    maxRetryTime?: int32(name='maxRetryTime'),
    roleArn?: string(name='roleArn'),
    startingPosition?: string(name='startingPosition'),
    startingUnixtime?: long(name='startingUnixtime'),
    triggerInterval?: int32(name='triggerInterval'),
  }(name='triggerConfig'),
}

model EtlMeta {
  enable?: boolean(name='enable'),
  etlMetaKey?: string(name='etlMetaKey'),
  etlMetaName?: string(name='etlMetaName'),
  etlMetaTag?: string(name='etlMetaTag'),
  etlMetaValue?: string(name='etlMetaValue'),
}

model ExternalStore {
  externalStoreName?: string(name='externalStoreName'),
  parameter?: map[string]any(name='parameter'),
  storeType?: string(name='storeType'),
}

model Index {
  keys?: map[string]IndexKeysValue(name='keys'),
  lastModifyTime?: long(name='lastModifyTime'),
  line?: {
    caseSensitive?: boolean(name='caseSensitive'),
    chn?: boolean(name='chn'),
    excludeKeys?: [ string ](name='exclude_keys'),
    includeKeys?: [ string ](name='include_keys'),
    token?: [ string ](name='token'),
  }(name='line'),
  logReduce?: boolean(name='log_reduce'),
  logReduceBlackList?: [ string ](name='log_reduce_black_list'),
  logReduceWhiteList?: [ string ](name='log_reduce_white_list'),
  maxTextLen?: int32(name='max_text_len'),
  ttl?: int32(name='ttl'),
}

model Logging {
  loggingDetails?: [ 
    {
      logstore?: string(name='logstore'),
      type?: string(name='type'),
    }
  ](name='loggingDetails'),
  loggingProject?: string(name='loggingProject'),
}

model Logstore {
  appendMeta?: boolean(name='appendMeta'),
  autoSplit?: boolean(name='autoSplit'),
  createTime?: int32(name='createTime'),
  enableTracking?: boolean(name='enable_tracking'),
  encryptConf?: EncryptConf(name='encrypt_conf'),
  hotTtl?: int32(name='hot_ttl'),
  lastModifyTime?: int32(name='lastModifyTime'),
  logstoreName?: string(name='logstoreName'),
  maxSplitShard?: int32(name='maxSplitShard'),
  mode?: string(name='mode'),
  productType?: string(name='productType'),
  shardCount?: int32(name='shardCount'),
  telemetryType?: string(name='telemetryType'),
  ttl?: int32(name='ttl'),
}

model Machine {
  ip?: string(name='ip'),
  lastHeartbeatTime?: long(name='lastHeartbeatTime'),
  machineUniqueid?: string(name='machine-uniqueid'),
  userdefinedId?: string(name='userdefined-id'),
}

model MachineGroup {
  groupAttribute?: {
    externalName?: string(name='externalName'),
    groupTopic?: string(name='groupTopic'),
  }(name='groupAttribute'),
  groupName?: string(name='groupName'),
  groupType?: string(name='groupType'),
  machineIdentifyType?: string(name='machineIdentifyType'),
  machineList?: [ string ](name='machineList'),
}

model Project {
  createTime?: string(name='createTime'),
  description?: string(name='description'),
  lastModifyTime?: string(name='lastModifyTime'),
  owner?: string(name='owner'),
  projectName?: string(name='projectName'),
  region?: string(name='region'),
  status?: string(name='status'),
}

model Shard {
  createTime?: int32(name='createTime'),
  exclusiveEndKey?: string(name='exclusiveEndKey'),
  inclusiveBeginKey?: string(name='inclusiveBeginKey'),
  shardID?: int32(name='shardID'),
  status?: string(name='status'),
}

model IndexKeysValue = {
  chn?: boolean(name='chn'),
  caseSensitive?: boolean(name='caseSensitive'),
  token?: [ string ](name='token'),
  alias?: string(name='alias'),
  type?: string(name='type'),
  docValue?: boolean(name='doc_value'),
}

model KeysValue = {
  caseSensitive?: boolean(name='caseSensitive'),
  chn?: boolean(name='chn'),
  type?: string(name='type'),
  alias?: string(name='alias'),
  token?: [ string ](name='token'),
  docValue?: boolean(name='doc_value'),
}

model ApplyConfigToMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function applyConfigToMachineGroup(project: string, machineGroup: string, configName: string): ApplyConfigToMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return applyConfigToMachineGroupWithOptions(project, machineGroup, configName, headers, runtime);
}

async function applyConfigToMachineGroupWithOptions(project: string, machineGroup: string, configName: string, headers: map[string]string, runtime: Util.RuntimeOptions): ApplyConfigToMachineGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ApplyConfigToMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}/configs/${configName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model CreateConsumerGroupRequest {
  consumerGroup?: string(name='consumerGroup'),
  order?: boolean(name='order'),
  timeout?: int32(name='timeout'),
}

model CreateConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createConsumerGroup(project: string, logstore: string, request: CreateConsumerGroupRequest): CreateConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createConsumerGroupWithOptions(project, logstore, request, headers, runtime);
}

async function createConsumerGroupWithOptions(project: string, logstore: string, request: CreateConsumerGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateConsumerGroupResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.consumerGroup)) {
    body['consumerGroup'] = request.consumerGroup;
  }
  if (!Util.isUnset(request.order)) {
    body['order'] = request.order;
  }
  if (!Util.isUnset(request.timeout)) {
    body['timeout'] = request.timeout;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateConsumerGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model CreateDomainRequest {
  domainName?: string(name='domainName'),
}

model CreateDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createDomain(project: string, request: CreateDomainRequest): CreateDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDomainWithOptions(project, request, headers, runtime);
}

async function createDomainWithOptions(project: string, request: CreateDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDomainResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.domainName)) {
    body['domainName'] = request.domainName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDomain',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/domains`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model CreateIndexRequest {
  keys?: map[string]KeysValue(name='keys'),
  line?: {
    caseSensitive?: boolean(name='caseSensitive'),
    chn?: boolean(name='chn'),
    excludeKeys?: [ string ](name='exclude_keys'),
    includeKeys?: [ string ](name='include_keys'),
    token?: [ string ](name='token'),
  }(name='line'),
  logReduce?: boolean(name='log_reduce'),
  logReduceBlackList?: [ string ](name='log_reduce_black_list'),
  logReduceWhiteList?: [ string ](name='log_reduce_white_list'),
  maxTextLen?: int32(name='max_text_len'),
  ttl?: int32(name='ttl'),
}

model CreateIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createIndex(project: string, logstore: string, request: CreateIndexRequest): CreateIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createIndexWithOptions(project, logstore, request, headers, runtime);
}

async function createIndexWithOptions(project: string, logstore: string, request: CreateIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateIndexResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.keys)) {
    body['keys'] = request.keys;
  }
  if (!Util.isUnset(request.line)) {
    body['line'] = request.line;
  }
  if (!Util.isUnset(request.logReduce)) {
    body['log_reduce'] = request.logReduce;
  }
  if (!Util.isUnset(request.logReduceBlackList)) {
    body['log_reduce_black_list'] = request.logReduceBlackList;
  }
  if (!Util.isUnset(request.logReduceWhiteList)) {
    body['log_reduce_white_list'] = request.logReduceWhiteList;
  }
  if (!Util.isUnset(request.maxTextLen)) {
    body['max_text_len'] = request.maxTextLen;
  }
  if (!Util.isUnset(request.ttl)) {
    body['ttl'] = request.ttl;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateIndex',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/index`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model CreateLogStoreRequest {
  appendMeta?: boolean(name='appendMeta'),
  autoSplit?: boolean(name='autoSplit'),
  enableTracking?: boolean(name='enable_tracking'),
  encryptConf?: EncryptConf(name='encrypt_conf'),
  hotTtl?: int32(name='hot_ttl'),
  logstoreName?: string(name='logstoreName'),
  maxSplitShard?: int32(name='maxSplitShard'),
  mode?: string(name='mode'),
  shardCount?: int32(name='shardCount'),
  telemetryType?: string(name='telemetryType'),
  ttl?: int32(name='ttl'),
}

model CreateLogStoreResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createLogStore(project: string, request: CreateLogStoreRequest): CreateLogStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLogStoreWithOptions(project, request, headers, runtime);
}

async function createLogStoreWithOptions(project: string, request: CreateLogStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLogStoreResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.appendMeta)) {
    body['appendMeta'] = request.appendMeta;
  }
  if (!Util.isUnset(request.autoSplit)) {
    body['autoSplit'] = request.autoSplit;
  }
  if (!Util.isUnset(request.enableTracking)) {
    body['enable_tracking'] = request.enableTracking;
  }
  if (!Util.isUnset(request.encryptConf)) {
    body['encrypt_conf'] = request.encryptConf;
  }
  if (!Util.isUnset(request.hotTtl)) {
    body['hot_ttl'] = request.hotTtl;
  }
  if (!Util.isUnset(request.logstoreName)) {
    body['logstoreName'] = request.logstoreName;
  }
  if (!Util.isUnset(request.maxSplitShard)) {
    body['maxSplitShard'] = request.maxSplitShard;
  }
  if (!Util.isUnset(request.mode)) {
    body['mode'] = request.mode;
  }
  if (!Util.isUnset(request.shardCount)) {
    body['shardCount'] = request.shardCount;
  }
  if (!Util.isUnset(request.telemetryType)) {
    body['telemetryType'] = request.telemetryType;
  }
  if (!Util.isUnset(request.ttl)) {
    body['ttl'] = request.ttl;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLogStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model CreateLoggingRequest {
  loggingDetails?: [ 
    {
      logstore?: string(name='logstore'),
      type?: string(name='type'),
    }
  ](name='loggingDetails'),
  loggingProject?: string(name='loggingProject'),
}

model CreateLoggingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createLogging(project: string, request: CreateLoggingRequest): CreateLoggingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLoggingWithOptions(project, request, headers, runtime);
}

async function createLoggingWithOptions(project: string, request: CreateLoggingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLoggingResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.loggingDetails)) {
    body['loggingDetails'] = request.loggingDetails;
  }
  if (!Util.isUnset(request.loggingProject)) {
    body['loggingProject'] = request.loggingProject;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLogging',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logging`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model CreateMachineGroupRequest {
  groupAttribute?: {
    externalName?: string(name='externalName'),
    groupTopic?: string(name='groupTopic'),
  }(name='groupAttribute'),
  groupName?: string(name='groupName'),
  groupType?: string(name='groupType'),
  machineIdentifyType?: string(name='machineIdentifyType'),
  machineList?: [ string ](name='machineList'),
}

model CreateMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createMachineGroup(project: string, request: CreateMachineGroupRequest): CreateMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMachineGroupWithOptions(project, request, headers, runtime);
}

async function createMachineGroupWithOptions(project: string, request: CreateMachineGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMachineGroupResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupAttribute)) {
    body['groupAttribute'] = request.groupAttribute;
  }
  if (!Util.isUnset(request.groupName)) {
    body['groupName'] = request.groupName;
  }
  if (!Util.isUnset(request.groupType)) {
    body['groupType'] = request.groupType;
  }
  if (!Util.isUnset(request.machineIdentifyType)) {
    body['machineIdentifyType'] = request.machineIdentifyType;
  }
  if (!Util.isUnset(request.machineList)) {
    body['machineList'] = request.machineList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model CreateOdpsShipperRequest {
  shipperName?: string(name='shipperName'),
  targetConfiguration?: {
    bufferInterval?: int32(name='bufferInterval'),
    enable?: boolean(name='enable'),
    fields?: [ string ](name='fields'),
    odpsEndpoint?: string(name='odpsEndpoint'),
    odpsProject?: string(name='odpsProject'),
    odpsTable?: string(name='odpsTable'),
    partitionColumn?: [ string ](name='partitionColumn'),
    partitionTimeFormat?: string(name='partitionTimeFormat'),
  }(name='targetConfiguration'),
  targetType?: string(name='targetType'),
}

model CreateOdpsShipperResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createOdpsShipper(project: string, logstore: string, request: CreateOdpsShipperRequest): CreateOdpsShipperResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createOdpsShipperWithOptions(project, logstore, request, headers, runtime);
}

async function createOdpsShipperWithOptions(project: string, logstore: string, request: CreateOdpsShipperRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateOdpsShipperResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.shipperName)) {
    body['shipperName'] = request.shipperName;
  }
  if (!Util.isUnset(request.targetConfiguration)) {
    body['targetConfiguration'] = request.targetConfiguration;
  }
  if (!Util.isUnset(request.targetType)) {
    body['targetType'] = request.targetType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOdpsShipper',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shipper`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model CreateOssExternalStoreRequest {
  externalStoreName?: string(name='externalStoreName'),
  parameter?: {
    accessid?: string(name='accessid'),
    accesskey?: string(name='accesskey'),
    bucket?: string(name='bucket'),
    columns?: [ 
      {
        name?: string(name='name'),
        type?: string(name='type'),
      }
    ](name='columns'),
    endpoint?: string(name='endpoint'),
    objects?: [ string ](name='objects'),
  }(name='parameter'),
  storeType?: string(name='storeType'),
}

model CreateOssExternalStoreResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createOssExternalStore(project: string, request: CreateOssExternalStoreRequest): CreateOssExternalStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createOssExternalStoreWithOptions(project, request, headers, runtime);
}

async function createOssExternalStoreWithOptions(project: string, request: CreateOssExternalStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateOssExternalStoreResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.externalStoreName)) {
    body['externalStoreName'] = request.externalStoreName;
  }
  if (!Util.isUnset(request.parameter)) {
    body['parameter'] = request.parameter;
  }
  if (!Util.isUnset(request.storeType)) {
    body['storeType'] = request.storeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOssExternalStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/externalstores`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model CreateOssShipperRequest {
  shipperName?: string(name='shipperName'),
  targetConfiguration?: {
    bufferInterval?: int32(name='bufferInterval'),
    bufferSize?: int32(name='bufferSize'),
    compressType?: string(name='compressType'),
    enable?: boolean(name='enable'),
    ossBucket?: string(name='ossBucket'),
    ossPrefix?: string(name='ossPrefix'),
    pathFormat?: string(name='pathFormat'),
    roleArn?: string(name='roleArn'),
    storage?: {
      detail?: map[string]any(name='detail'),
      format?: string(name='format'),
    }(name='storage'),
    timeZone?: string(name='timeZone'),
  }(name='targetConfiguration'),
  targetType?: string(name='targetType'),
}

model CreateOssShipperResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createOssShipper(project: string, logstore: string, request: CreateOssShipperRequest): CreateOssShipperResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createOssShipperWithOptions(project, logstore, request, headers, runtime);
}

async function createOssShipperWithOptions(project: string, logstore: string, request: CreateOssShipperRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateOssShipperResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.shipperName)) {
    body['shipperName'] = request.shipperName;
  }
  if (!Util.isUnset(request.targetConfiguration)) {
    body['targetConfiguration'] = request.targetConfiguration;
  }
  if (!Util.isUnset(request.targetType)) {
    body['targetType'] = request.targetType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOssShipper',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shipper`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model CreateProjectRequest {
  description?: string(name='description'),
  projectName?: string(name='projectName'),
}

model CreateProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createProject(request: CreateProjectRequest): CreateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createProjectWithOptions(request, headers, runtime);
}

async function createProjectWithOptions(request: CreateProjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.projectName)) {
    body['projectName'] = request.projectName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model CreateRdsExternalStoreRequest {
  externalStoreName?: string(name='externalStoreName'),
  parameter?: {
    db?: string(name='db'),
    host?: string(name='host'),
    instanceId?: string(name='instance-id'),
    password?: string(name='password'),
    port?: string(name='port'),
    region?: string(name='region'),
    table?: string(name='table'),
    username?: string(name='username'),
    vpcId?: string(name='vpc-id'),
  }(name='parameter'),
  storeType?: string(name='storeType'),
}

model CreateRdsExternalStoreResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createRdsExternalStore(project: string, request: CreateRdsExternalStoreRequest): CreateRdsExternalStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRdsExternalStoreWithOptions(project, request, headers, runtime);
}

async function createRdsExternalStoreWithOptions(project: string, request: CreateRdsExternalStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRdsExternalStoreResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.externalStoreName)) {
    body['externalStoreName'] = request.externalStoreName;
  }
  if (!Util.isUnset(request.parameter)) {
    body['parameter'] = request.parameter;
  }
  if (!Util.isUnset(request.storeType)) {
    body['storeType'] = request.storeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateRdsExternalStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/externalstores`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model CreateSavedSearchRequest {
  displayName?: string(name='displayName'),
  logstore?: string(name='logstore'),
  savedsearchName?: string(name='savedsearchName'),
  searchQuery?: string(name='searchQuery'),
  topic?: string(name='topic'),
}

model CreateSavedSearchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createSavedSearch(project: string, request: CreateSavedSearchRequest): CreateSavedSearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSavedSearchWithOptions(project, request, headers, runtime);
}

async function createSavedSearchWithOptions(project: string, request: CreateSavedSearchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSavedSearchResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.logstore)) {
    body['logstore'] = request.logstore;
  }
  if (!Util.isUnset(request.savedsearchName)) {
    body['savedsearchName'] = request.savedsearchName;
  }
  if (!Util.isUnset(request.searchQuery)) {
    body['searchQuery'] = request.searchQuery;
  }
  if (!Util.isUnset(request.topic)) {
    body['topic'] = request.topic;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSavedSearch',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/savedsearches`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model DeleteConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteConsumerGroup(project: string, logstore: string, consumerGroup: string): DeleteConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConsumerGroupWithOptions(project, logstore, consumerGroup, headers, runtime);
}

async function deleteConsumerGroupWithOptions(project: string, logstore: string, consumerGroup: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteConsumerGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteConsumerGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups/${consumerGroup}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model DeleteDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteDomain(project: string, domainName: string): DeleteDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDomainWithOptions(project, domainName, headers, runtime);
}

async function deleteDomainWithOptions(project: string, domainName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDomainResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteDomain',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/domains/${domainName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model DeleteExternalStoreResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteExternalStore(project: string, externalStoreName: string): DeleteExternalStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteExternalStoreWithOptions(project, externalStoreName, headers, runtime);
}

async function deleteExternalStoreWithOptions(project: string, externalStoreName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteExternalStoreResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteExternalStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/externalstores/${externalStoreName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model DeleteIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteIndex(project: string, logstore: string): DeleteIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteIndexWithOptions(project, logstore, headers, runtime);
}

async function deleteIndexWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteIndexResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteIndex',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/index`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model DeleteLogStoreResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteLogStore(project: string, logstore: string): DeleteLogStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLogStoreWithOptions(project, logstore, headers, runtime);
}

async function deleteLogStoreWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLogStoreResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteLogStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model DeleteLoggingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteLogging(project: string): DeleteLoggingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLoggingWithOptions(project, headers, runtime);
}

async function deleteLoggingWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLoggingResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteLogging',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logging`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model DeleteMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteMachineGroup(project: string, machineGroup: string): DeleteMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteMachineGroupWithOptions(project, machineGroup, headers, runtime);
}

async function deleteMachineGroupWithOptions(project: string, machineGroup: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteMachineGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model DeleteProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteProject(project: string): DeleteProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProjectWithOptions(project, headers, runtime);
}

async function deleteProjectWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProjectResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model DeleteProjectPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteProjectPolicy(project: string): DeleteProjectPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProjectPolicyWithOptions(project, headers, runtime);
}

async function deleteProjectPolicyWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProjectPolicyResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteProjectPolicy',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/policy`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model DeleteSavedSearchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteSavedSearch(project: string, savedsearchName: string): DeleteSavedSearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSavedSearchWithOptions(project, savedsearchName, headers, runtime);
}

async function deleteSavedSearchWithOptions(project: string, savedsearchName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteSavedSearchResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteSavedSearch',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/savedsearches/${savedsearchName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model DeleteShipperResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteShipper(project: string, logstore: string, shipperName: string): DeleteShipperResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteShipperWithOptions(project, logstore, shipperName, headers, runtime);
}

async function deleteShipperWithOptions(project: string, logstore: string, shipperName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteShipperResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteShipper',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shipper/${shipperName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model GetAppliedConfigsResponseBody = {
  configs?: [ string ](name='configs'),
  count?: int32(name='count'),
}

model GetAppliedConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAppliedConfigsResponseBody(name='body'),
}

async function getAppliedConfigs(project: string, machineGroup: string): GetAppliedConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAppliedConfigsWithOptions(project, machineGroup, headers, runtime);
}

async function getAppliedConfigsWithOptions(project: string, machineGroup: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAppliedConfigsResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAppliedConfigs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}/configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetAppliedMachineGroupsResponseBody = {
  count?: int32(name='count'),
  machinegroups?: [ string ](name='machinegroups'),
}

model GetAppliedMachineGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAppliedMachineGroupsResponseBody(name='body'),
}

async function getAppliedMachineGroups(project: string, configName: string): GetAppliedMachineGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAppliedMachineGroupsWithOptions(project, configName, headers, runtime);
}

async function getAppliedMachineGroupsWithOptions(project: string, configName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAppliedMachineGroupsResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAppliedMachineGroups',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/configs/${configName}/machinegroups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetCheckPointRequest {
  shard?: int32(name='shard'),
}

model GetCheckPointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [ 
    {
      shard?: int32(name='shard'),
      checkpoint?: string(name='checkpoint'),
      updateTime?: long(name='updateTime'),
      consumer?: string(name='consumer'),
    }
  ](name='body'),
}

async function getCheckPoint(project: string, logstore: string, consumerGroup: string, request: GetCheckPointRequest): GetCheckPointResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCheckPointWithOptions(project, logstore, consumerGroup, request, headers, runtime);
}

async function getCheckPointWithOptions(project: string, logstore: string, consumerGroup: string, request: GetCheckPointRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCheckPointResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.shard)) {
    query['shard'] = request.shard;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCheckPoint',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups/${consumerGroup}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

model GetContextLogsRequest {
  backLines?: long(name='back_lines'),
  forwardLines?: long(name='forward_lines'),
  packId?: string(name='pack_id'),
  packMeta?: string(name='pack_meta'),
  type?: string(name='type'),
}

model GetContextLogsResponseBody = {
  backLines?: long(name='back_lines'),
  forwardLines?: long(name='forward_lines'),
  logs?: [  map[string]any ](name='logs'),
  progress?: string(name='progress'),
  totalLines?: long(name='total_lines'),
}

model GetContextLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetContextLogsResponseBody(name='body'),
}

async function getContextLogs(project: string, logstore: string, request: GetContextLogsRequest): GetContextLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getContextLogsWithOptions(project, logstore, request, headers, runtime);
}

async function getContextLogsWithOptions(project: string, logstore: string, request: GetContextLogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetContextLogsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.backLines)) {
    query['back_lines'] = request.backLines;
  }
  if (!Util.isUnset(request.forwardLines)) {
    query['forward_lines'] = request.forwardLines;
  }
  if (!Util.isUnset(request.packId)) {
    query['pack_id'] = request.packId;
  }
  if (!Util.isUnset(request.packMeta)) {
    query['pack_meta'] = request.packMeta;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetContextLogs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetCursorRequest {
  from?: string(name='from'),
}

model GetCursorResponseBody = {
  cursor?: string(name='cursor'),
}

model GetCursorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCursorResponseBody(name='body'),
}

async function getCursor(project: string, logstore: string, shardId: string, request: GetCursorRequest): GetCursorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCursorWithOptions(project, logstore, shardId, request, headers, runtime);
}

async function getCursorWithOptions(project: string, logstore: string, shardId: string, request: GetCursorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCursorResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.from)) {
    query['from'] = request.from;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCursor',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shards/${shardId}?type=cursor`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetCursorTimeRequest {
  cursor?: string(name='cursor'),
}

model GetCursorTimeResponseBody = {
  cursorTime?: string(name='cursor_time'),
}

model GetCursorTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCursorTimeResponseBody(name='body'),
}

async function getCursorTime(project: string, logstore: string, shardId: string, request: GetCursorTimeRequest): GetCursorTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCursorTimeWithOptions(project, logstore, shardId, request, headers, runtime);
}

async function getCursorTimeWithOptions(project: string, logstore: string, shardId: string, request: GetCursorTimeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCursorTimeResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.cursor)) {
    query['cursor'] = request.cursor;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCursorTime',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shards/${shardId}?type=cursor_time`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetExternalStoreResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExternalStore  
}

async function getExternalStore(project: string, externalStoreName: string): GetExternalStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExternalStoreWithOptions(project, externalStoreName, headers, runtime);
}

async function getExternalStoreWithOptions(project: string, externalStoreName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetExternalStoreResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetExternalStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/externalstores/${externalStoreName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetHistogramsRequest {
  from?: long(name='from'),
  query?: string(name='query'),
  to?: long(name='to'),
  topic?: string(name='topic'),
}

model GetHistogramsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [ 
    {
      from?: long(name='from'),
      to?: long(name='to'),
      count?: long(name='count'),
      progress?: string(name='progress'),
    }
  ](name='body'),
}

async function getHistograms(project: string, logstore: string, request: GetHistogramsRequest): GetHistogramsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getHistogramsWithOptions(project, logstore, request, headers, runtime);
}

async function getHistogramsWithOptions(project: string, logstore: string, request: GetHistogramsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetHistogramsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.from)) {
    query['from'] = request.from;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }
  if (!Util.isUnset(request.to)) {
    query['to'] = request.to;
  }
  if (!Util.isUnset(request.topic)) {
    query['topic'] = request.topic;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHistograms',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/index?type=histogram`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

model GetIndexResponseBody = {
  indexMode?: string(name='index_mode'),
  keys?: map[string]KeysValue(name='keys'),
  lastModifyTime?: long(name='lastModifyTime'),
  line?: {
    caseSensitive?: boolean(name='caseSensitive'),
    chn?: boolean(name='chn'),
    excludeKeys?: [ string ](name='exclude_keys'),
    includeKeys?: [ string ](name='include_keys'),
    token?: [ string ](name='token'),
  }(name='line'),
  logReduce?: boolean(name='log_reduce'),
  logReduceBlackList?: [ string ](name='log_reduce_black_list'),
  logReduceWhiteList?: [ string ](name='log_reduce_white_list'),
  maxTextLen?: int32(name='max_text_len'),
  storage?: string(name='storage'),
  ttl?: int32(name='ttl'),
}

model GetIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetIndexResponseBody(name='body'),
}

async function getIndex(project: string, logstore: string): GetIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getIndexWithOptions(project, logstore, headers, runtime);
}

async function getIndexWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetIndexResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetIndex',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/index`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetLogStoreResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Logstore  
}

async function getLogStore(project: string, logstore: string): GetLogStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLogStoreWithOptions(project, logstore, headers, runtime);
}

async function getLogStoreWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLogStoreResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLogStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetLoggingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Logging  
}

async function getLogging(project: string): GetLoggingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLoggingWithOptions(project, headers, runtime);
}

async function getLoggingWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLoggingResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLogging',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logging`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetLogsRequest {
  from?: long(name='from'),
  line?: long(name='line'),
  offset?: long(name='offset'),
  powerSql?: boolean(name='powerSql'),
  query?: string(name='query'),
  reverse?: boolean(name='reverse'),
  to?: long(name='to'),
  topic?: string(name='topic'),
}

model GetLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [  map[string]any ](name='body'),
}

async function getLogs(project: string, logstore: string, request: GetLogsRequest): GetLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLogsWithOptions(project, logstore, request, headers, runtime);
}

async function getLogsWithOptions(project: string, logstore: string, request: GetLogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetLogsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.from)) {
    query['from'] = request.from;
  }
  if (!Util.isUnset(request.line)) {
    query['line'] = request.line;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.powerSql)) {
    query['powerSql'] = request.powerSql;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }
  if (!Util.isUnset(request.reverse)) {
    query['reverse'] = request.reverse;
  }
  if (!Util.isUnset(request.to)) {
    query['to'] = request.to;
  }
  if (!Util.isUnset(request.topic)) {
    query['topic'] = request.topic;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLogs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}?type=log`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

model GetMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MachineGroup  
}

async function getMachineGroup(project: string, machineGroup: string): GetMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMachineGroupWithOptions(project, machineGroup, headers, runtime);
}

async function getMachineGroupWithOptions(project: string, machineGroup: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetMachineGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Project  
}

async function getProject(project: string): GetProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProjectWithOptions(project, headers, runtime);
}

async function getProjectWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetProjectResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetProjectLogsRequest {
  powerSql?: boolean(name='powerSql'),
  query?: string(name='query'),
}

model GetProjectLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [ map[string]string ](name='body'),
}

async function getProjectLogs(project: string, request: GetProjectLogsRequest): GetProjectLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProjectLogsWithOptions(project, request, headers, runtime);
}

async function getProjectLogsWithOptions(project: string, request: GetProjectLogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProjectLogsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.powerSql)) {
    query['powerSql'] = request.powerSql;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProjectLogs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

model GetProjectPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function getProjectPolicy(project: string): GetProjectPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProjectPolicyWithOptions(project, headers, runtime);
}

async function getProjectPolicyWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetProjectPolicyResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetProjectPolicy',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/policy`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetSavedSearchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SavedSearch  
}

async function getSavedSearch(project: string, savedsearchName: string): GetSavedSearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSavedSearchWithOptions(project, savedsearchName, headers, runtime);
}

async function getSavedSearchWithOptions(project: string, savedsearchName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetSavedSearchResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetSavedSearch',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/savedsearches/${savedsearchName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetShipperStatusRequest {
  from?: long(name='from'),
  offset?: int32(name='offset'),
  size?: int32(name='size'),
  status?: string(name='status'),
  to?: long(name='to'),
}

model GetShipperStatusResponseBody = {
  count?: long(name='count'),
  statistics?: {
    fail?: long(name='fail'),
    running?: long(name='running'),
    success?: long(name='success'),
  }(name='statistics'),
  tasks?: {
    id?: string(name='id'),
    taskCode?: string(name='taskCode'),
    taskCreateTime?: long(name='taskCreateTime'),
    taskDataLines?: int32(name='taskDataLines'),
    taskFinishTime?: long(name='taskFinishTime'),
    taskLastDataReceiveTime?: long(name='taskLastDataReceiveTime'),
    taskMessage?: string(name='taskMessage'),
    taskStatus?: string(name='taskStatus'),
  }(name='tasks'),
  total?: long(name='total'),
}

model GetShipperStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetShipperStatusResponseBody(name='body'),
}

async function getShipperStatus(project: string, logstore: string, shipperName: string, request: GetShipperStatusRequest): GetShipperStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getShipperStatusWithOptions(project, logstore, shipperName, request, headers, runtime);
}

async function getShipperStatusWithOptions(project: string, logstore: string, shipperName: string, request: GetShipperStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetShipperStatusResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.from)) {
    query['from'] = request.from;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.status)) {
    query['status'] = request.status;
  }
  if (!Util.isUnset(request.to)) {
    query['to'] = request.to;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetShipperStatus',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shipper/${shipperName}/tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [
    ConsumerGroup
  ](name='body'),
}

async function listConsumerGroup(project: string, logstore: string): ListConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConsumerGroupWithOptions(project, logstore, headers, runtime);
}

async function listConsumerGroupWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListConsumerGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListConsumerGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

model ListDomainsRequest {
  domainName?: string(name='domainName'),
  offset?: int32(name='offset'),
  size?: int32(name='size'),
}

model ListDomainsResponseBody = {
  count?: long(name='count'),
  domains?: [ string ](name='domains'),
  total?: long(name='total'),
}

model ListDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDomainsResponseBody(name='body'),
}

async function listDomains(project: string, request: ListDomainsRequest): ListDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDomainsWithOptions(project, request, headers, runtime);
}

async function listDomainsWithOptions(project: string, request: ListDomainsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDomainsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.domainName)) {
    query['domainName'] = request.domainName;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDomains',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/domains`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListExternalStoreRequest {
  externalStoreName?: string(name='externalStoreName'),
  offset?: int32(name='offset'),
  sizs?: int32(name='sizs'),
}

model ListExternalStoreResponseBody = {
  count?: int32(name='count'),
  externalstores?: [
    ExternalStore
  ](name='externalstores'),
  total?: int32(name='total'),
}

model ListExternalStoreResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListExternalStoreResponseBody(name='body'),
}

async function listExternalStore(project: string, request: ListExternalStoreRequest): ListExternalStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listExternalStoreWithOptions(project, request, headers, runtime);
}

async function listExternalStoreWithOptions(project: string, request: ListExternalStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListExternalStoreResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.externalStoreName)) {
    query['externalStoreName'] = request.externalStoreName;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.sizs)) {
    query['sizs'] = request.sizs;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListExternalStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/externalstores`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListLogStoresRequest {
  logstoreName?: string(name='logstoreName'),
  mode?: string(name='mode'),
  offset?: int32(name='offset'),
  size?: int32(name='size'),
  telemetryType?: string(name='telemetryType'),
}

model ListLogStoresResponseBody = {
  logstores?: [ string ](name='logstores'),
  total?: int32(name='total'),
}

model ListLogStoresResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLogStoresResponseBody(name='body'),
}

async function listLogStores(project: string, request: ListLogStoresRequest): ListLogStoresResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLogStoresWithOptions(project, request, headers, runtime);
}

async function listLogStoresWithOptions(project: string, request: ListLogStoresRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLogStoresResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.logstoreName)) {
    query['logstoreName'] = request.logstoreName;
  }
  if (!Util.isUnset(request.mode)) {
    query['mode'] = request.mode;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.telemetryType)) {
    query['telemetryType'] = request.telemetryType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLogStores',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListMachineGroupRequest {
  groupName?: string(name='groupName'),
  offset?: int32(name='offset'),
  size?: int32(name='size'),
}

model ListMachineGroupResponseBody = {
  count?: int32(name='count'),
  machinegroups?: [ string ](name='machinegroups'),
  total?: int32(name='total'),
}

model ListMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMachineGroupResponseBody(name='body'),
}

async function listMachineGroup(project: string, request: ListMachineGroupRequest): ListMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMachineGroupWithOptions(project, request, headers, runtime);
}

async function listMachineGroupWithOptions(project: string, request: ListMachineGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMachineGroupResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.groupName)) {
    query['groupName'] = request.groupName;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListMachinesRequest {
  offset?: int32(name='offset'),
  size?: int32(name='size'),
}

model ListMachinesResponseBody = {
  count?: int32(name='count'),
  machines?: [
    Machine
  ](name='machines'),
  total?: int32(name='total'),
}

model ListMachinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMachinesResponseBody(name='body'),
}

async function listMachines(project: string, machineGroup: string, request: ListMachinesRequest): ListMachinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMachinesWithOptions(project, machineGroup, request, headers, runtime);
}

async function listMachinesWithOptions(project: string, machineGroup: string, request: ListMachinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMachinesResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMachines',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}/machines`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListProjectRequest {
  offset?: int32(name='offset'),
  projectName?: string(name='projectName'),
  size?: int32(name='size'),
}

model ListProjectResponseBody = {
  count?: long(name='count'),
  projects?: [
    Project
  ](name='projects'),
  total?: long(name='total'),
}

model ListProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProjectResponseBody(name='body'),
}

async function listProject(request: ListProjectRequest): ListProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProjectWithOptions(request, headers, runtime);
}

async function listProjectWithOptions(request: ListProjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProjectResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.projectName)) {
    query['projectName'] = request.projectName;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListSavedSearchRequest {
  offset?: int32(name='offset'),
  size?: int32(name='size'),
}

model ListSavedSearchResponseBody = {
  count?: int32(name='count'),
  savedsearchItems?: [
    SavedSearch
  ](name='savedsearchItems'),
  total?: int32(name='total'),
}

model ListSavedSearchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSavedSearchResponseBody(name='body'),
}

async function listSavedSearch(project: string, request: ListSavedSearchRequest): ListSavedSearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSavedSearchWithOptions(project, request, headers, runtime);
}

async function listSavedSearchWithOptions(project: string, request: ListSavedSearchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSavedSearchResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSavedSearch',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/savedsearches`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListShardsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [
    Shard
  ](name='body'),
}

async function listShards(project: string, logstore: string): ListShardsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listShardsWithOptions(project, logstore, headers, runtime);
}

async function listShardsWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListShardsResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListShards',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shards`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

model ListShipperResponseBody = {
  count?: long(name='count'),
  shipper?: [ string ](name='shipper'),
  total?: long(name='total'),
}

model ListShipperResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListShipperResponseBody(name='body'),
}

async function listShipper(project: string, logstore: string): ListShipperResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listShipperWithOptions(project, logstore, headers, runtime);
}

async function listShipperWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListShipperResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListShipper',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shipper`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListTagResourcesRequest {
  resourceId?: [ string ](name='resourceId'),
  resourceType?: string(name='resourceType'),
  tags?: [ 
    {
      key?: string(name='key'),
      value?: string(name='value'),
    }
  ](name='tags'),
}

model ListTagResourcesShrinkRequest {
  resourceIdShrink?: string(name='resourceId'),
  resourceType?: string(name='resourceType'),
  tagsShrink?: string(name='tags'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='nextToken'),
  tagResources?: [ 
    {
      resourceId?: string(name='resourceId'),
      resourceType?: string(name='resourceType'),
      tagKey?: string(name='tagKey'),
      tagValue?: string(name='tagValue'),
    }
  ](name='tagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagResourcesWithOptions(request, headers, runtime);
}

async function listTagResourcesWithOptions(tmpReq: ListTagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new ListTagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceId)) {
    request.resourceIdShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceId, 'resourceId', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'tags', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.resourceIdShrink)) {
    query['resourceId'] = request.resourceIdShrink;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['resourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['tags'] = request.tagsShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/tags`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model PullDataRequest {
  count?: string(name='count'),
  cursor?: string(name='cursor'),
  endCursor?: string(name='endCursor'),
}

model PullDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function pullData(project: string, logstore: string, shard: string, request: PullDataRequest): PullDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return pullDataWithOptions(project, logstore, shard, request, headers, runtime);
}

async function pullDataWithOptions(project: string, logstore: string, shard: string, request: PullDataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PullDataResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.count)) {
    query['count'] = request.count;
  }
  if (!Util.isUnset(request.cursor)) {
    query['cursor'] = request.cursor;
  }
  if (!Util.isUnset(request.endCursor)) {
    query['endCursor'] = request.endCursor;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PullData',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shards/${shard}?type=log`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model PutProjectPolicyRequest {
  body?: string(name='body'),
}

model PutProjectPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function putProjectPolicy(project: string, request: PutProjectPolicyRequest): PutProjectPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putProjectPolicyWithOptions(project, request, headers, runtime);
}

async function putProjectPolicyWithOptions(project: string, request: PutProjectPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutProjectPolicyResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'PutProjectPolicy',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/policy`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model PutWebtrackingRequest {
  logs?: [ map[string]string ](name='__logs__'),
  source?: string(name='__source__'),
  tags?: map[string]string(name='__tags__'),
  topic?: string(name='__topic__'),
}

model PutWebtrackingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function putWebtracking(project: string, logstoreName: string, request: PutWebtrackingRequest): PutWebtrackingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putWebtrackingWithOptions(project, logstoreName, request, headers, runtime);
}

async function putWebtrackingWithOptions(project: string, logstoreName: string, request: PutWebtrackingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutWebtrackingResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.logs)) {
    body['__logs__'] = request.logs;
  }
  if (!Util.isUnset(request.source)) {
    body['__source__'] = request.source;
  }
  if (!Util.isUnset(request.tags)) {
    body['__tags__'] = request.tags;
  }
  if (!Util.isUnset(request.topic)) {
    body['__topic__'] = request.topic;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutWebtracking',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstoreName}/track`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model RemoveConfigFromMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function removeConfigFromMachineGroup(project: string, machineGroup: string, configName: string): RemoveConfigFromMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeConfigFromMachineGroupWithOptions(project, machineGroup, configName, headers, runtime);
}

async function removeConfigFromMachineGroupWithOptions(project: string, machineGroup: string, configName: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveConfigFromMachineGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveConfigFromMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}/configs/${configName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model SplitShardRequest {
  key?: string(name='key'),
  shardCount?: int32(name='shardCount'),
}

model SplitShardResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [
    Shard
  ](name='body'),
}

async function splitShard(project: string, logstore: string, shard: string, request: SplitShardRequest): SplitShardResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return splitShardWithOptions(project, logstore, shard, request, headers, runtime);
}

async function splitShardWithOptions(project: string, logstore: string, shard: string, request: SplitShardRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SplitShardResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.key)) {
    query['key'] = request.key;
  }
  if (!Util.isUnset(request.shardCount)) {
    query['shardCount'] = request.shardCount;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SplitShard',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shards/${shard}?action=split`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

model TagResourcesRequest {
  resourceId?: [ string ](name='resourceId'),
  resourceType?: string(name='resourceType'),
  tags?: [ 
    {
      key?: string(name='key'),
      value?: string(name='value'),
    }
  ](name='tags'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return tagResourcesWithOptions(request, headers, runtime);
}

async function tagResourcesWithOptions(request: TagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.resourceId)) {
    body['resourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['resourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/tag`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='all'),
  resourceId?: string(name='resourceId'),
  resourceType?: string(name='resourceType'),
  tags?: [ string ](name='tags'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return untagResourcesWithOptions(request, headers, runtime);
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.all)) {
    body['all'] = request.all;
  }
  if (!Util.isUnset(request.resourceId)) {
    body['resourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['resourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/untag`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model UpdateConsumerGroupRequest {
  order?: boolean(name='order'),
  timeout?: int32(name='timeout'),
}

model UpdateConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateConsumerGroup(project: string, logstore: string, consumerGroup: string, request: UpdateConsumerGroupRequest): UpdateConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateConsumerGroupWithOptions(project, logstore, consumerGroup, request, headers, runtime);
}

async function updateConsumerGroupWithOptions(project: string, logstore: string, consumerGroup: string, request: UpdateConsumerGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateConsumerGroupResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.order)) {
    body['order'] = request.order;
  }
  if (!Util.isUnset(request.timeout)) {
    body['timeout'] = request.timeout;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateConsumerGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups/${consumerGroup}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model UpdateIndexRequest {
  keys?: map[string]KeysValue(name='keys'),
  line?: {
    caseSensitive?: boolean(name='caseSensitive'),
    chn?: boolean(name='chn'),
    excludeKeys?: [ string ](name='exclude_keys'),
    includeKeys?: [ string ](name='include_keys'),
    token?: [ string ](name='token'),
  }(name='line'),
  logReduce?: boolean(name='log_reduce'),
  logReduceBlackList?: [ string ](name='log_reduce_black_list'),
  logReduceWhiteList?: [ string ](name='log_reduce_white_list'),
  maxTextLen?: int32(name='max_text_len'),
  ttl?: int32(name='ttl'),
}

model UpdateIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateIndex(project: string, logstore: string, request: UpdateIndexRequest): UpdateIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateIndexWithOptions(project, logstore, request, headers, runtime);
}

async function updateIndexWithOptions(project: string, logstore: string, request: UpdateIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateIndexResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.keys)) {
    body['keys'] = request.keys;
  }
  if (!Util.isUnset(request.line)) {
    body['line'] = request.line;
  }
  if (!Util.isUnset(request.logReduce)) {
    body['log_reduce'] = request.logReduce;
  }
  if (!Util.isUnset(request.logReduceBlackList)) {
    body['log_reduce_black_list'] = request.logReduceBlackList;
  }
  if (!Util.isUnset(request.logReduceWhiteList)) {
    body['log_reduce_white_list'] = request.logReduceWhiteList;
  }
  if (!Util.isUnset(request.maxTextLen)) {
    body['max_text_len'] = request.maxTextLen;
  }
  if (!Util.isUnset(request.ttl)) {
    body['ttl'] = request.ttl;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIndex',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/index`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model UpdateLogStoreRequest {
  appendMeta?: boolean(name='appendMeta'),
  autoSplit?: boolean(name='autoSplit'),
  enableTracking?: boolean(name='enable_tracking'),
  encryptConf?: EncryptConf(name='encrypt_conf'),
  hotTtl?: int32(name='hot_ttl'),
  logstoreName?: string(name='logstoreName'),
  maxSplitShard?: int32(name='maxSplitShard'),
  mode?: string(name='mode'),
  shardCount?: int32(name='shardCount'),
  telemetryType?: string(name='telemetryType'),
  ttl?: int32(name='ttl'),
}

model UpdateLogStoreResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateLogStore(project: string, logstore: string, request: UpdateLogStoreRequest): UpdateLogStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogStoreWithOptions(project, logstore, request, headers, runtime);
}

async function updateLogStoreWithOptions(project: string, logstore: string, request: UpdateLogStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogStoreResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.appendMeta)) {
    body['appendMeta'] = request.appendMeta;
  }
  if (!Util.isUnset(request.autoSplit)) {
    body['autoSplit'] = request.autoSplit;
  }
  if (!Util.isUnset(request.enableTracking)) {
    body['enable_tracking'] = request.enableTracking;
  }
  if (!Util.isUnset(request.encryptConf)) {
    body['encrypt_conf'] = request.encryptConf;
  }
  if (!Util.isUnset(request.hotTtl)) {
    body['hot_ttl'] = request.hotTtl;
  }
  if (!Util.isUnset(request.logstoreName)) {
    body['logstoreName'] = request.logstoreName;
  }
  if (!Util.isUnset(request.maxSplitShard)) {
    body['maxSplitShard'] = request.maxSplitShard;
  }
  if (!Util.isUnset(request.mode)) {
    body['mode'] = request.mode;
  }
  if (!Util.isUnset(request.shardCount)) {
    body['shardCount'] = request.shardCount;
  }
  if (!Util.isUnset(request.telemetryType)) {
    body['telemetryType'] = request.telemetryType;
  }
  if (!Util.isUnset(request.ttl)) {
    body['ttl'] = request.ttl;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model UpdateLoggingRequest {
  loggingDetails?: [ 
    {
      logstore?: string(name='logstore'),
      type?: string(name='type'),
    }
  ](name='loggingDetails'),
  loggingProject?: string(name='loggingProject'),
}

model UpdateLoggingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateLogging(project: string, request: UpdateLoggingRequest): UpdateLoggingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLoggingWithOptions(project, request, headers, runtime);
}

async function updateLoggingWithOptions(project: string, request: UpdateLoggingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLoggingResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.loggingDetails)) {
    body['loggingDetails'] = request.loggingDetails;
  }
  if (!Util.isUnset(request.loggingProject)) {
    body['loggingProject'] = request.loggingProject;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogging',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logging`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model UpdateMachineGroupRequest {
  groupAttribute?: {
    externalName?: string(name='externalName'),
    groupTopic?: string(name='groupTopic'),
  }(name='groupAttribute'),
  groupName?: string(name='groupName'),
  groupType?: string(name='groupType'),
  machineIdentifyType?: string(name='machineIdentifyType'),
  machineList?: [ string ](name='machineList'),
}

model UpdateMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateMachineGroup(project: string, groupName: string, request: UpdateMachineGroupRequest): UpdateMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMachineGroupWithOptions(project, groupName, request, headers, runtime);
}

async function updateMachineGroupWithOptions(project: string, groupName: string, request: UpdateMachineGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMachineGroupResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupAttribute)) {
    body['groupAttribute'] = request.groupAttribute;
  }
  if (!Util.isUnset(request.groupName)) {
    body['groupName'] = request.groupName;
  }
  if (!Util.isUnset(request.groupType)) {
    body['groupType'] = request.groupType;
  }
  if (!Util.isUnset(request.machineIdentifyType)) {
    body['machineIdentifyType'] = request.machineIdentifyType;
  }
  if (!Util.isUnset(request.machineList)) {
    body['machineList'] = request.machineList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${groupName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model UpdateMachineGroupMachineRequest {
  action?: string(name='action'),
  body?: [ string ](name='body'),
}

model UpdateMachineGroupMachineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateMachineGroupMachine(project: string, machineGroup: string, request: UpdateMachineGroupMachineRequest): UpdateMachineGroupMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMachineGroupMachineWithOptions(project, machineGroup, request, headers, runtime);
}

async function updateMachineGroupMachineWithOptions(project: string, machineGroup: string, request: UpdateMachineGroupMachineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMachineGroupMachineResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.action)) {
    query['action'] = request.action;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateMachineGroupMachine',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}/machines`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model UpdateOdpsShipperRequest {
  shipperName?: string(name='shipperName'),
  targetConfiguration?: {
    bufferInterval?: int32(name='bufferInterval'),
    enable?: boolean(name='enable'),
    fields?: [ string ](name='fields'),
    odpsEndpoint?: string(name='odpsEndpoint'),
    odpsProject?: string(name='odpsProject'),
    odpsTable?: string(name='odpsTable'),
    partitionColumn?: [ string ](name='partitionColumn'),
    partitionTimeFormat?: string(name='partitionTimeFormat'),
  }(name='targetConfiguration'),
  targetType?: string(name='targetType'),
}

model UpdateOdpsShipperResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateOdpsShipper(project: string, logstore: string, shipperName: string, request: UpdateOdpsShipperRequest): UpdateOdpsShipperResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateOdpsShipperWithOptions(project, logstore, shipperName, request, headers, runtime);
}

async function updateOdpsShipperWithOptions(project: string, logstore: string, shipperName: string, request: UpdateOdpsShipperRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateOdpsShipperResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.shipperName)) {
    body['shipperName'] = request.shipperName;
  }
  if (!Util.isUnset(request.targetConfiguration)) {
    body['targetConfiguration'] = request.targetConfiguration;
  }
  if (!Util.isUnset(request.targetType)) {
    body['targetType'] = request.targetType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOdpsShipper',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shipper/${shipperName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model UpdateOssExternalStoreRequest {
  externalStoreName?: string(name='externalStoreName'),
  parameter?: {
    accessid?: string(name='accessid'),
    accesskey?: string(name='accesskey'),
    bucket?: string(name='bucket'),
    columns?: [ 
      {
        name?: string(name='name'),
        type?: string(name='type'),
      }
    ](name='columns'),
    endpoint?: string(name='endpoint'),
    objects?: [ string ](name='objects'),
  }(name='parameter'),
  storeType?: string(name='storeType'),
}

model UpdateOssExternalStoreResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateOssExternalStore(project: string, externalStoreName: string, request: UpdateOssExternalStoreRequest): UpdateOssExternalStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateOssExternalStoreWithOptions(project, externalStoreName, request, headers, runtime);
}

async function updateOssExternalStoreWithOptions(project: string, externalStoreName: string, request: UpdateOssExternalStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateOssExternalStoreResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.externalStoreName)) {
    body['externalStoreName'] = request.externalStoreName;
  }
  if (!Util.isUnset(request.parameter)) {
    body['parameter'] = request.parameter;
  }
  if (!Util.isUnset(request.storeType)) {
    body['storeType'] = request.storeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOssExternalStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/externalstores/${externalStoreName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model UpdateOssShipperRequest {
  shipperName?: string(name='shipperName'),
  targetConfiguration?: {
    bufferInterval?: int32(name='bufferInterval'),
    bufferSize?: int32(name='bufferSize'),
    compressType?: string(name='compressType'),
    enable?: boolean(name='enable'),
    ossBucket?: string(name='ossBucket'),
    ossPrefix?: string(name='ossPrefix'),
    pathFormat?: string(name='pathFormat'),
    roleArn?: string(name='roleArn'),
    storage?: {
      detail?: map[string]any(name='detail'),
      format?: string(name='format'),
    }(name='storage'),
    timeZone?: string(name='timeZone'),
  }(name='targetConfiguration'),
  targetType?: string(name='targetType'),
}

model UpdateOssShipperResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateOssShipper(project: string, logstore: string, shipperName: string, request: UpdateOssShipperRequest): UpdateOssShipperResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateOssShipperWithOptions(project, logstore, shipperName, request, headers, runtime);
}

async function updateOssShipperWithOptions(project: string, logstore: string, shipperName: string, request: UpdateOssShipperRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateOssShipperResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.shipperName)) {
    body['shipperName'] = request.shipperName;
  }
  if (!Util.isUnset(request.targetConfiguration)) {
    body['targetConfiguration'] = request.targetConfiguration;
  }
  if (!Util.isUnset(request.targetType)) {
    body['targetType'] = request.targetType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOssShipper',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shipper/${shipperName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model UpdateProjectRequest {
  description?: string(name='description'),
}

model UpdateProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateProject(project: string, request: UpdateProjectRequest): UpdateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProjectWithOptions(project, request, headers, runtime);
}

async function updateProjectWithOptions(project: string, request: UpdateProjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProjectResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model UpdateRdsExternalStoreRequest {
  externalStoreName?: string(name='externalStoreName'),
  parameter?: {
    db?: string(name='db'),
    host?: string(name='host'),
    instanceId?: string(name='instance-id'),
    password?: string(name='password'),
    port?: string(name='port'),
    region?: string(name='region'),
    table?: string(name='table'),
    username?: string(name='username'),
    vpcId?: string(name='vpc-id'),
  }(name='parameter'),
  storeType?: string(name='storeType'),
}

model UpdateRdsExternalStoreResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateRdsExternalStore(project: string, externalStoreName: string, request: UpdateRdsExternalStoreRequest): UpdateRdsExternalStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRdsExternalStoreWithOptions(project, externalStoreName, request, headers, runtime);
}

async function updateRdsExternalStoreWithOptions(project: string, externalStoreName: string, request: UpdateRdsExternalStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRdsExternalStoreResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.externalStoreName)) {
    body['externalStoreName'] = request.externalStoreName;
  }
  if (!Util.isUnset(request.parameter)) {
    body['parameter'] = request.parameter;
  }
  if (!Util.isUnset(request.storeType)) {
    body['storeType'] = request.storeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRdsExternalStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/externalstores/${externalStoreName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model UpdateSavedSearchRequest {
  displayName?: string(name='displayName'),
  logstore?: string(name='logstore'),
  savedsearchName?: string(name='savedsearchName'),
  searchQuery?: string(name='searchQuery'),
  topic?: string(name='topic'),
}

model UpdateSavedSearchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateSavedSearch(project: string, savedsearchName: string, request: UpdateSavedSearchRequest): UpdateSavedSearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSavedSearchWithOptions(project, savedsearchName, request, headers, runtime);
}

async function updateSavedSearchWithOptions(project: string, savedsearchName: string, request: UpdateSavedSearchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSavedSearchResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.logstore)) {
    body['logstore'] = request.logstore;
  }
  if (!Util.isUnset(request.savedsearchName)) {
    body['savedsearchName'] = request.savedsearchName;
  }
  if (!Util.isUnset(request.searchQuery)) {
    body['searchQuery'] = request.searchQuery;
  }
  if (!Util.isUnset(request.topic)) {
    body['topic'] = request.topic;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSavedSearch',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/savedsearches/${savedsearchName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

