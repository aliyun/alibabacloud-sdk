/**
 *
 */
import Util;
import SPI;
import GatewayClient;
import OpenApi;
import OpenApiUtil;

extends OpenApi;

type @client = SPI

init(config: OpenApi.Config){
  super(config);
  @client = new GatewayClient();
  @spi = @client;
  @endpointRule = 'central';
  }

model ConsumerGroup {
  name?: string(name='name', description='消费者名称。'),
  order?: boolean(name='order', description='是否有序消费'),
  timeout?: int32(name='timeout', description='消费超时时长，单位为妙'),
}

model EncryptConf {
  enable?: boolean(name='enable', description='enable'),
  encryptType?: string(name='encrypt_type', description='加密算法，只支持default和m4。当 enable 为 true 时，此项必选。'),
  userCmkInfo?: EncryptUserCmkConf(name='user_cmk_info'),
}

model EncryptUserCmkConf {
  arn?: string(name='arn', description='arn'),
  cmkKeyId?: string(name='cmk_key_id', description='cmk_key_id'),
  regionId?: string(name='region_id', description='region_id'),
}

model LogtailConfig {
  configName?: string(name='configName', description='logtail 配置的名称。'),
  createTime?: long(name='createTime', description='创建时间，unix 时间戳。'),
  inputDetail?: map[string]any(name='inputDetail', description='logtail 输入的详细配置。'),
  inputType?: string(name='inputType', description='logtail 读取日志的输入类型。'),
  lastModifyTime?: long(name='lastModifyTime', description='最后一次修改时间，unix 时间戳。'),
  logSample?: string(name='logSample', description='日志样例，可以用于自动生成正则捕获字段。'),
  outputDetail?: {
    endpoint?: string(name='endpoint', description='日志项目的 endpoint。'),
    logstoreName?: string(name='logstoreName', description='输出的目标 logstore 名称。'),
    region?: string(name='region', description='地域。'),
  }(name='outputDetail', description='logtail 输出的详细配置。'),
  outputType?: string(name='outputType', description='logtail 输出的目标类型。这里固定选择 LogService。'),
}

model SavedSearch {
  displayName?: string(name='displayName', description='displayName'),
  logstore?: string(name='logstore', description='logstore'),
  savedsearchName?: string(name='savedsearchName', description='savedsearchName'),
  searchQuery?: string(name='searchQuery', description='searchQuery'),
  topic?: string(name='topic', description='topic'),
}

model Chart {
  action?: map[string]any(name='action', description='action'),
  display?: {
    height?: long(name='height', description='高度'),
    width?: long(name='width', description='宽度'),
    xAxis?: [ string ](name='xAxis', description='x 轴'),
    xPos?: long(name='xPos', description='x 坐标'),
    yAxis?: [ string ](name='yAxis', description='y 轴'),
    yPos?: long(name='yPos', description='y 坐标'),
  }(name='display', description='图表的显示配置'),
  search?: {
    end?: string(name='end', description='结束时间'),
    logstore?: string(name='logstore', description='logstore 名称'),
    query?: string(name='query', description='查询语句'),
    start?: string(name='start', description='开始时间'),
    topic?: string(name='topic', description='topic'),
  }(name='search', description='查询配置'),
  title?: string(name='title', description='图表标题。支持大小写英文字母、数字、下划线_、连字符-，连字符与下划线不能作为名称开头与结尾，长度必须在[2,64] 之间。'),
  type?: string(name='type', description='图表的类型。'),
}

model Dashboard {
  attribute?: map[string]string(name='attribute', description='属性值，可用于修改仪表盘的布局等属性，例如 "type": "free" 自由布局， "type":"grid" 网格布局。'),
  charts?: [
    Chart
  ](name='charts', description='仪表盘内包含的图表。'),
  dashboardName?: string(name='dashboardName', description='仪表盘ID。同一个Project下，仪表盘ID唯一，不可重复。'),
  description?: string(name='description', description='描述信息。'),
  displayName?: string(name='displayName', description='仪表盘的展示名称。'),
}

model EtlJob {
  enable?: boolean(name='enable', description='是否启用'),
  etlJobName?: string(name='etlJobName', description='任务名称'),
  functionConfig?: {
    accountId?: string(name='accountId', description='账户 id'),
    endpoint?: string(name='endpoint', description='endpoint'),
    functionName?: string(name='functionName', description='函数名'),
    functionProvider?: string(name='functionProvider', description='函数 provider，可选值为 FunctionCompute 、CloudProdLogDispatch。当值为 FunctionCompute 时，endpoint、accountid 、regionName 、serviceName 、functionName 必选。'),
    regionName?: string(name='regionName', description='地域'),
    roleArn?: string(name='roleArn', description='角色授权'),
    serviceName?: string(name='serviceName', description='服务名'),
  }(name='functionConfig', description='运行函数配置'),
  functionParameter?: map[string]any(name='functionParameter', description='参数列表'),
  logConfig?: {
    endpoint?: string(name='endpoint', description='endpoint'),
    logstoreName?: string(name='logstoreName', description='logstore 名称'),
    projectName?: string(name='projectName', description='project 名称'),
  }(name='logConfig', description='日志配置'),
  sourceConfig?: {
    logstoreName?: string(name='logstoreName', description='logstore 名称'),
  }(name='sourceConfig', description='配置数据来源'),
  triggerConfig?: {
    maxRetryTime?: int32(name='maxRetryTime', description='最大重试次数，必须在[0,100] 之间'),
    roleArn?: string(name='roleArn', description='角色授权配置'),
    startingPosition?: string(name='startingPosition', description='开始位置，可选 latest、at-unixtime， 默认 latest。'),
    startingUnixtime?: long(name='startingUnixtime', description='开始时间'),
    triggerInterval?: int32(name='triggerInterval', description='触发间隔，单位为秒，必须在 [3,600] 之间'),
  }(name='triggerConfig', description='触发器配置'),
}

model EtlMeta {
  enable?: boolean(name='enable', description='是否启用'),
  etlMetaKey?: string(name='etlMetaKey', description='key'),
  etlMetaName?: string(name='etlMetaName', description='名字'),
  etlMetaTag?: string(name='etlMetaTag', description='tag'),
  etlMetaValue?: string(name='etlMetaValue', description='value'),
}

model ExternalStore {
  externalStoreName?: string(name='externalStoreName', description='外部存储的名称。'),
  parameter?: map[string]any(name='parameter', description='参数'),
  storeType?: string(name='storeType', description='类型。可选 rds-vpc 或者 oss'),
}

model Logging {
  loggingDetails?: [ 
    {
      logstore?: string(name='logstore', description='logstore 名称。'),
      type?: string(name='type', description='logging 类型。'),
    }
  ](name='loggingDetails', description='logging 配置项'),
  loggingProject?: string(name='loggingProject', description='project 名称。'),
}

model Logstore {
  appendMeta?: boolean(name='appendMeta', description='接收日志后，自动添加客户端外网IP和日志到达时间'),
  autoSplit?: boolean(name='autoSplit', description='是否开启 shard 自动分裂。当写入数据量超过已有分区（Shard）写入服务能力且持续5分钟以上时，开启自动分裂功能可自动根据数据量增加分区数量'),
  createTime?: int32(name='createTime', description='创建时间。'),
  enableTracking?: boolean(name='enable_tracking', description='WebTracking功能支持快速采集各种浏览器以及iOS/Android/APP访问信息，默认关闭'),
  encryptConf?: EncryptConf(name='encrypt_conf', description='Encrypt configuration'),
  hotTtl?: int32(name='hot_ttl', description='必须在 (30, ttl) 之间'),
  lastModifyTime?: int32(name='lastModifyTime', description='最后修改时间。'),
  logstoreName?: string(name='logstoreName', description='logstore 的名称。'),
  maxSplitShard?: int32(name='maxSplitShard', description='最大 shard 数量。'),
  shardCount?: int32(name='shardCount', description='shard 数量。'),
  telemetryType?: string(name='telemetryType', description='telemetryType'),
  ttl?: int32(name='ttl', description='数据保存的天数。'),
}

model Machine {
  ip?: string(name='ip', description='机器 ip 地址。'),
  lastHeartbeatTime?: long(name='lastHeartbeatTime', description='最后一次心跳时间。Unix时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。'),
  machineUniqueid?: string(name='machine-uniqueid', description='机器的唯一标识。'),
  userdefinedId?: string(name='userdefined-id', description='机器的用户自定义标识。'),
}

model MachineGroup {
  groupAttribute?: {
    externalName?: string(name='externalName', description='机器组所依赖的外部管理系统标识。'),
    groupTopic?: string(name='groupTopic', description='机器组的日志主题。'),
  }(name='groupAttribute', description='机器组属性。'),
  groupName?: string(name='groupName', description='机器组名称。'),
  groupType?: string(name='groupType', description='机器组种类。目前固定为空字符串。'),
  machineIdentifyType?: string(name='machineIdentifyType', description='机器组标识种类，支持 IP 标识或者用户自定义标识，即 ip 、userdefined。'),
  machineList?: [ string ](name='machineList', description='机器组标识列表。'),
}

model Project {
  createTime?: string(name='createTime', description='创建时间'),
  description?: string(name='description', description='描述'),
  lastModifyTime?: string(name='lastModifyTime', description='最后更新时间'),
  owner?: string(name='owner', description='owner'),
  projectName?: string(name='projectName', description='Project名称'),
  region?: string(name='region', description='所在区域'),
  status?: string(name='status', description='状态'),
}

model Shard {
  createTime?: int32(name='createTime', description='Shard的创建时间。Unix时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。'),
  exclusiveEndKey?: string(name='exclusiveEndKey', description='指定Shard范围的结束值，Shard范围中不包含该值。即 shard 包含MD5值在 [inclusiveBeginKey, exclusiveEndKey) 之间的日志。'),
  inclusiveBeginKey?: string(name='inclusiveBeginKey', description='指定Shard范围的起始值，Shard范围中包含该值。即 shard 包含MD5值在 [inclusiveBeginKey, exclusiveEndKey) 之间的日志。'),
  shardID?: int32(name='shardID', description='shard id'),
  status?: string(name='status', description='shard 的读写状态，readwrite 或者 readonly。'),
}

model ApplyConfigToMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function applyConfigToMachineGroup(project: string, machineGroup: string, configName: string): ApplyConfigToMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return applyConfigToMachineGroupWithOptions(project, machineGroup, configName, headers, runtime);
}

async function applyConfigToMachineGroupWithOptions(project: string, machineGroup: string, configName: string, headers: map[string]string, runtime: Util.RuntimeOptions): ApplyConfigToMachineGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  machineGroup = OpenApiUtil.getEncodeParam(machineGroup);
  configName = OpenApiUtil.getEncodeParam(configName);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ApplyConfigToMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}/configs/${configName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model BatchCreateEtlMetaRequest {
  etlMetaList?: [ 
    {
      enable?: boolean(name='enable', description='是否启用'),
      etlMetaKey?: string(name='etlMetaKey', description='key。由 ascii 可打印字符组成，包括数字、英文大小写字母、下划线、连字符、英文标点符号等组成，长度在[1,255]之间。'),
      etlMetaName?: string(name='etlMetaName', description='名字。由数字、大小写字母、下划线_、连字符-组成，长度需要在[2,64]之间。'),
      etlMetaTag?: string(name='etlMetaTag', description='key。由 ascii 可打印字符组成，包括数字、英文大小写字母、下划线、连字符、英文标点符号等组成，长度在[1,128]之间。'),
      etlMetaValue?: map[string]any(name='etlMetaValue'),
    }
  ](name='etlMetaList'),
}

model BatchCreateEtlMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function batchCreateEtlMeta(project: string, request: BatchCreateEtlMetaRequest): BatchCreateEtlMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchCreateEtlMetaWithOptions(project, request, headers, runtime);
}

async function batchCreateEtlMetaWithOptions(project: string, request: BatchCreateEtlMetaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchCreateEtlMetaResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any= {};
  if (!Util.isUnset(request.etlMetaList)) {
    body['etlMetaList'] = request.etlMetaList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchCreateEtlMeta',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/etlmetas`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model BatchModifyEtlMetaStatusRequest {
  etlMetaKeyList?: [ string ](name='etlMetaKeyList', description='当 range 的值为 "list" 时有效，匹配list中的 metaKey'),
  etlMetaName?: string(name='etlMetaName'),
  etlMetaTag?: string(name='etlMetaTag', description='匹配的 tag，当 tag 为 "__all_etl_meta_tag_match__" 时表示全部匹配。'),
  range?: string(name='range', description='操作作用的范围，可选 all 代表匹配全部，list 按名单列表匹配 key 两种模式。'),
  type?: string(name='type', description='操作类型，支持启用、禁用、删除三种，即 batch_enable、batch_disable、batch_delete。'),
}

model BatchModifyEtlMetaStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function batchModifyEtlMetaStatus(project: string, request: BatchModifyEtlMetaStatusRequest): BatchModifyEtlMetaStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchModifyEtlMetaStatusWithOptions(project, request, headers, runtime);
}

async function batchModifyEtlMetaStatusWithOptions(project: string, request: BatchModifyEtlMetaStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchModifyEtlMetaStatusResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any= {};
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var body : map[string]any= {};
  if (!Util.isUnset(request.etlMetaKeyList)) {
    body['etlMetaKeyList'] = request.etlMetaKeyList;
  }
  if (!Util.isUnset(request.etlMetaName)) {
    body['etlMetaName'] = request.etlMetaName;
  }
  if (!Util.isUnset(request.etlMetaTag)) {
    body['etlMetaTag'] = request.etlMetaTag;
  }
  if (!Util.isUnset(request.range)) {
    body['range'] = request.range;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchModifyEtlMetaStatus',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/etlmetas`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model BatchUpdateEtlMetaRequest {
  etlMetaList?: {
    enable?: boolean(name='enable', description='是否启用。etlMetaTag、etlMetaValue、enable 至少需要存在一个。'),
    etlMetaKey?: string(name='etlMetaKey', description='key。由 ascii 可打印字符组成，包括数字、英文大小写字母、下划线、连字符、英文标点符号等组成，长度在[1,255]之间。'),
    etlMetaName?: string(name='etlMetaName', description='名字。由数字、大小写字母、下划线_、连字符-组成，长度需要在[2,64]之间。'),
    etlMetaTag?: string(name='etlMetaTag', description='key。由 ascii 可打印字符组成，包括数字、英文大小写字母、下划线、连字符、英文标点符号等组成，长度在[1,128]之间。'),
    etlMetaValue?: map[string]any(name='etlMetaValue'),
  }(name='etlMetaList'),
}

model BatchUpdateEtlMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function batchUpdateEtlMeta(project: string, request: BatchUpdateEtlMetaRequest): BatchUpdateEtlMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchUpdateEtlMetaWithOptions(project, request, headers, runtime);
}

async function batchUpdateEtlMetaWithOptions(project: string, request: BatchUpdateEtlMetaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchUpdateEtlMetaResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any= {};
  if (!Util.isUnset(request.etlMetaList)) {
    body['etlMetaList'] = request.etlMetaList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchUpdateEtlMeta',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/etlmetas`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model CreateConsumerGroupRequest {
  consumerGroup?: string(name='consumerGroup'),
  order?: boolean(name='order'),
  timeout?: int32(name='timeout'),
}

model CreateConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createConsumerGroup(project: string, logstore: string, request: CreateConsumerGroupRequest): CreateConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createConsumerGroupWithOptions(project, logstore, request, headers, runtime);
}

async function createConsumerGroupWithOptions(project: string, logstore: string, request: CreateConsumerGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateConsumerGroupResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  var body : map[string]any= {};
  if (!Util.isUnset(request.consumerGroup)) {
    body['consumerGroup'] = request.consumerGroup;
  }
  if (!Util.isUnset(request.order)) {
    body['order'] = request.order;
  }
  if (!Util.isUnset(request.timeout)) {
    body['timeout'] = request.timeout;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateConsumerGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model CreateDomainRequest {
  domainName?: string(name='domainName'),
}

model CreateDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createDomain(project: string, request: CreateDomainRequest): CreateDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDomainWithOptions(project, request, headers, runtime);
}

async function createDomainWithOptions(project: string, request: CreateDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDomainResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any= {};
  if (!Util.isUnset(request.domainName)) {
    body['domainName'] = request.domainName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDomain',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/domains`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model CreateEtlMetaRequest {
  enable?: boolean(name='enable', description='是否启用'),
  etlMetaKey?: string(name='etlMetaKey', description='key。由 ascii 可打印字符组成，包括数字、英文大小写字母、下划线、连字符、英文标点符号等组成，长度在[1,255]之间。'),
  etlMetaName?: string(name='etlMetaName', description='名字。由数字、大小写字母、下划线_、连字符-组成，长度需要在[2,64]之间。'),
  etlMetaTag?: string(name='etlMetaTag', description='key。由 ascii 可打印字符组成，包括数字、英文大小写字母、下划线、连字符、英文标点符号等组成，长度在[1,128]之间。'),
  etlMetaValue?: map[string]any(name='etlMetaValue'),
}

model CreateEtlMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createEtlMeta(project: string, request: CreateEtlMetaRequest): CreateEtlMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createEtlMetaWithOptions(project, request, headers, runtime);
}

async function createEtlMetaWithOptions(project: string, request: CreateEtlMetaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateEtlMetaResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any= {};
  if (!Util.isUnset(request.enable)) {
    body['enable'] = request.enable;
  }
  if (!Util.isUnset(request.etlMetaKey)) {
    body['etlMetaKey'] = request.etlMetaKey;
  }
  if (!Util.isUnset(request.etlMetaName)) {
    body['etlMetaName'] = request.etlMetaName;
  }
  if (!Util.isUnset(request.etlMetaTag)) {
    body['etlMetaTag'] = request.etlMetaTag;
  }
  if (!Util.isUnset(request.etlMetaValue)) {
    body['etlMetaValue'] = request.etlMetaValue;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateEtlMeta',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/etlmetas`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model CreateIndexRequest {
  keys?: map[string]KeysValue(name='keys'),
  line?: {
    caseSensitive?: boolean(name='caseSensitive', description='大小写敏感'),
    chn?: boolean(name='chn', description='包含中文'),
    excludeKeys?: [ string ](name='exclude_keys', description='排除的字段列表，不能与include_keys同时指定。'),
    includeKeys?: [ string ](name='include_keys', description='包含的字段列表，不能与exclude_keys同时指定。'),
    token?: [ string ](name='token', description='分词符列表。可以设置一个分词参数，指定这个字段按照哪一种方式分词。'),
  }(name='line', description='配置全文索引'),
  logReduce?: boolean(name='log_reduce', description='开启日志聚类，开启后白名单与黑名单至多生效其中一个。'),
  logReduceBlackList?: [ string ](name='log_reduce_black_list', description='日志聚类的聚类字段黑名单'),
  logReduceWhiteList?: [ string ](name='log_reduce_white_list', description='日志聚类的聚类字段白名单'),
  maxTextLen?: int32(name='max_text_len', description='统计字段的最大长度'),
  ttl?: int32(name='ttl', description='保存时间，单位为天'),
}

model CreateIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createIndex(project: string, logstore: string, request: CreateIndexRequest): CreateIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createIndexWithOptions(project, logstore, request, headers, runtime);
}

async function createIndexWithOptions(project: string, logstore: string, request: CreateIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateIndexResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  var body : map[string]any= {};
  if (!Util.isUnset(request.keys)) {
    body['keys'] = request.keys;
  }
  if (!Util.isUnset(request.line)) {
    body['line'] = request.line;
  }
  if (!Util.isUnset(request.logReduce)) {
    body['log_reduce'] = request.logReduce;
  }
  if (!Util.isUnset(request.logReduceBlackList)) {
    body['log_reduce_black_list'] = request.logReduceBlackList;
  }
  if (!Util.isUnset(request.logReduceWhiteList)) {
    body['log_reduce_white_list'] = request.logReduceWhiteList;
  }
  if (!Util.isUnset(request.maxTextLen)) {
    body['max_text_len'] = request.maxTextLen;
  }
  if (!Util.isUnset(request.ttl)) {
    body['ttl'] = request.ttl;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateIndex',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/index`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model CreateLogStoreRequest {
  appendMeta?: boolean(name='appendMeta'),
  autoSplit?: boolean(name='autoSplit'),
  enableTracking?: boolean(name='enable_tracking'),
  encryptConf?: EncryptConf(name='encrypt_conf'),
  hotTtl?: int32(name='hot_ttl'),
  logstoreName?: string(name='logstoreName'),
  maxSplitShard?: int32(name='maxSplitShard'),
  shardCount?: int32(name='shardCount'),
  telemetryType?: string(name='telemetryType'),
  ttl?: int32(name='ttl'),
}

model CreateLogStoreResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createLogStore(project: string, request: CreateLogStoreRequest): CreateLogStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLogStoreWithOptions(project, request, headers, runtime);
}

async function createLogStoreWithOptions(project: string, request: CreateLogStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLogStoreResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any= {};
  if (!Util.isUnset(request.appendMeta)) {
    body['appendMeta'] = request.appendMeta;
  }
  if (!Util.isUnset(request.autoSplit)) {
    body['autoSplit'] = request.autoSplit;
  }
  if (!Util.isUnset(request.enableTracking)) {
    body['enable_tracking'] = request.enableTracking;
  }
  if (!Util.isUnset(request.encryptConf)) {
    body['encrypt_conf'] = request.encryptConf;
  }
  if (!Util.isUnset(request.hotTtl)) {
    body['hot_ttl'] = request.hotTtl;
  }
  if (!Util.isUnset(request.logstoreName)) {
    body['logstoreName'] = request.logstoreName;
  }
  if (!Util.isUnset(request.maxSplitShard)) {
    body['maxSplitShard'] = request.maxSplitShard;
  }
  if (!Util.isUnset(request.shardCount)) {
    body['shardCount'] = request.shardCount;
  }
  if (!Util.isUnset(request.telemetryType)) {
    body['telemetryType'] = request.telemetryType;
  }
  if (!Util.isUnset(request.ttl)) {
    body['ttl'] = request.ttl;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLogStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model CreateLoggingRequest {
  loggingDetails?: [ 
    {
      logstore?: string(name='logstore', description='该种类服务日志要保存到的 logstore 名称。'),
      type?: string(name='type', description='服务日志的种类。可选 "consumergroup_log"、 "logtail_alarm"、"operation_log"、"logtail_profile"、"metering"、"logtail_status"、"scheduled_sql_alert"、 "etl_alert" 等。'),
    }
  ](name='loggingDetails', description='服务日志配置列表。'),
  loggingProject?: string(name='loggingProject', description='服务日志要保存到的 project 名称。'),
}

model CreateLoggingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createLogging(project: string, request: CreateLoggingRequest): CreateLoggingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLoggingWithOptions(project, request, headers, runtime);
}

async function createLoggingWithOptions(project: string, request: CreateLoggingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLoggingResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any= {};
  if (!Util.isUnset(request.loggingDetails)) {
    body['loggingDetails'] = request.loggingDetails;
  }
  if (!Util.isUnset(request.loggingProject)) {
    body['loggingProject'] = request.loggingProject;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLogging',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logging`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model CreateMachineGroupRequest {
  groupAttribute?: {
    externalName?: string(name='externalName', description='机器组所依赖的外部管理系统标识。'),
    groupTopic?: string(name='groupTopic', description='机器组的日志主题。'),
  }(name='groupAttribute', description='机器组属性。'),
  groupName?: string(name='groupName', description='机器组名称。'),
  groupType?: string(name='groupType', description='机器组类型，可选值，默认为空。'),
  machineIdentifyType?: string(name='machineIdentifyType', description='机器组标识种类，支持 ip 、userdefined 两种。'),
  machineList?: [ string ](name='machineList', description='机器列表。'),
}

model CreateMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createMachineGroup(project: string, request: CreateMachineGroupRequest): CreateMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMachineGroupWithOptions(project, request, headers, runtime);
}

async function createMachineGroupWithOptions(project: string, request: CreateMachineGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMachineGroupResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any= {};
  if (!Util.isUnset(request.groupAttribute)) {
    body['groupAttribute'] = request.groupAttribute;
  }
  if (!Util.isUnset(request.groupName)) {
    body['groupName'] = request.groupName;
  }
  if (!Util.isUnset(request.groupType)) {
    body['groupType'] = request.groupType;
  }
  if (!Util.isUnset(request.machineIdentifyType)) {
    body['machineIdentifyType'] = request.machineIdentifyType;
  }
  if (!Util.isUnset(request.machineList)) {
    body['machineList'] = request.machineList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model CreateProjectRequest {
  description?: string(name='description'),
  projectName?: string(name='projectName'),
}

model CreateProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createProject(request: CreateProjectRequest): CreateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createProjectWithOptions(request, headers, runtime);
}

async function createProjectWithOptions(request: CreateProjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateProjectResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.projectName)) {
    body['projectName'] = request.projectName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model CreateSavedSearchRequest {
  displayName?: string(name='displayName'),
  logstore?: string(name='logstore'),
  savedsearchName?: string(name='savedsearchName'),
  searchQuery?: string(name='searchQuery'),
  topic?: string(name='topic'),
}

model CreateSavedSearchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createSavedSearch(project: string, request: CreateSavedSearchRequest): CreateSavedSearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSavedSearchWithOptions(project, request, headers, runtime);
}

async function createSavedSearchWithOptions(project: string, request: CreateSavedSearchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSavedSearchResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any= {};
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.logstore)) {
    body['logstore'] = request.logstore;
  }
  if (!Util.isUnset(request.savedsearchName)) {
    body['savedsearchName'] = request.savedsearchName;
  }
  if (!Util.isUnset(request.searchQuery)) {
    body['searchQuery'] = request.searchQuery;
  }
  if (!Util.isUnset(request.topic)) {
    body['topic'] = request.topic;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSavedSearch',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/savedsearches`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model DeleteConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteConsumerGroup(project: string, logstore: string, consumerGroup: string): DeleteConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConsumerGroupWithOptions(project, logstore, consumerGroup, headers, runtime);
}

async function deleteConsumerGroupWithOptions(project: string, logstore: string, consumerGroup: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteConsumerGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  consumerGroup = OpenApiUtil.getEncodeParam(consumerGroup);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteConsumerGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups/${consumerGroup}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model DeleteDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteDomain(project: string, domainName: string): DeleteDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDomainWithOptions(project, domainName, headers, runtime);
}

async function deleteDomainWithOptions(project: string, domainName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDomainResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  domainName = OpenApiUtil.getEncodeParam(domainName);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteDomain',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/domains/${domainName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model DeleteEtlMetaRequest {
  etlMetaKey?: string(name='etlMetaKey', description='key。由 ascii 可打印字符组成，包括数字、英文大小写字母、下划线、连字符、英文标点符号等组成，长度在[1,255]之间。'),
  etlMetaName?: string(name='etlMetaName', description='名字。由数字、大小写字母、下划线_、连字符-组成，长度需要在[2,64]之间。'),
  etlMetaTag?: string(name='etlMetaTag', description='此处固定为 "__all_etl_meta_tag_match__"'),
}

model DeleteEtlMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteEtlMeta(project: string, request: DeleteEtlMetaRequest): DeleteEtlMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteEtlMetaWithOptions(project, request, headers, runtime);
}

async function deleteEtlMetaWithOptions(project: string, request: DeleteEtlMetaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteEtlMetaResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any= {};
  if (!Util.isUnset(request.etlMetaKey)) {
    query['etlMetaKey'] = request.etlMetaKey;
  }
  if (!Util.isUnset(request.etlMetaName)) {
    query['etlMetaName'] = request.etlMetaName;
  }
  if (!Util.isUnset(request.etlMetaTag)) {
    query['etlMetaTag'] = request.etlMetaTag;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEtlMeta',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/etlmetas`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model DeleteIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteIndex(project: string, logstore: string): DeleteIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteIndexWithOptions(project, logstore, headers, runtime);
}

async function deleteIndexWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteIndexResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteIndex',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/index`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model DeleteLogStoreResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteLogStore(project: string, logstore: string): DeleteLogStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLogStoreWithOptions(project, logstore, headers, runtime);
}

async function deleteLogStoreWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLogStoreResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteLogStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model DeleteLoggingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteLogging(project: string): DeleteLoggingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLoggingWithOptions(project, headers, runtime);
}

async function deleteLoggingWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLoggingResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteLogging',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logging`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model DeleteMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteMachineGroup(project: string, machineGroup: string): DeleteMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteMachineGroupWithOptions(project, machineGroup, headers, runtime);
}

async function deleteMachineGroupWithOptions(project: string, machineGroup: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteMachineGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  machineGroup = OpenApiUtil.getEncodeParam(machineGroup);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model DeleteProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteProject(project: string): DeleteProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProjectWithOptions(project, headers, runtime);
}

async function deleteProjectWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProjectResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model DeleteSavedSearchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteSavedSearch(project: string, savedsearchName: string): DeleteSavedSearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSavedSearchWithOptions(project, savedsearchName, headers, runtime);
}

async function deleteSavedSearchWithOptions(project: string, savedsearchName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteSavedSearchResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  savedsearchName = OpenApiUtil.getEncodeParam(savedsearchName);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteSavedSearch',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/savedsearches/${savedsearchName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model GetAppliedConfigsResponseBody = {
  configs?: [ string ](name='configs', description='Logtail配置名称列表。'),
  count?: int32(name='count', description='Logtail配置数量。'),
}

model GetAppliedConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAppliedConfigsResponseBody(name='body'),
}

async function getAppliedConfigs(project: string, machineGroup: string): GetAppliedConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAppliedConfigsWithOptions(project, machineGroup, headers, runtime);
}

async function getAppliedConfigsWithOptions(project: string, machineGroup: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAppliedConfigsResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  machineGroup = OpenApiUtil.getEncodeParam(machineGroup);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAppliedConfigs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}/configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetCheckPointRequest {
  shard?: int32(name='shard', description='Shard ID。
如果指定的Shard不存在，则返回空列表。
如果不指定Shard，则返回所有Shard的checkpoint。'),
}

model GetCheckPointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [ 
    {
      shard?: int32(name='shard', description='shard id。'),
      checkpoint?: string(name='checkpoint', description='checkpoint 值。'),
      updateTime?: long(name='updateTime', description='checkpoint最后的更新时间。Unix时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。'),
      consumer?: string(name='consumer', description='消费者。'),
    }
  ](name='body'),
}

async function getCheckPoint(project: string, logstore: string, consumerGroup: string, request: GetCheckPointRequest): GetCheckPointResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCheckPointWithOptions(project, logstore, consumerGroup, request, headers, runtime);
}

async function getCheckPointWithOptions(project: string, logstore: string, consumerGroup: string, request: GetCheckPointRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCheckPointResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  consumerGroup = OpenApiUtil.getEncodeParam(consumerGroup);
  var query : map[string]any= {};
  if (!Util.isUnset(request.shard)) {
    query['shard'] = request.shard;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCheckPoint',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups/${consumerGroup}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

model GetContextLogsRequest {
  backLines?: long(name='back_lines', description='指定起始日志往前（上文）的日志条数，取值范围为(0,100]。'),
  forwardLines?: long(name='forward_lines', description='指定起始日志往后（下文）的日志条数，取值范围为(0,100]。'),
  packId?: string(name='pack_id', description='起始日志所属的LogGroup的唯一身份标识。'),
  packMeta?: string(name='pack_meta', description='起始日志在对应LogGroup内的唯一上下文结构标识。'),
  type?: string(name='type', description='Logstore中数据的类型。该接口中该参数固定为context_log。'),
}

model GetContextLogsResponseBody = {
  backLines?: long(name='back_lines', description='向前查询到的日志条数。'),
  forwardLines?: long(name='forward_lines', description='向后查询到的日志条数。'),
  logs?: [  map[string]any ](name='logs', description='获取到的日志，按上下文顺序排列。当根据指定起始日志查询不到上下文日志时，此参数为空。'),
  progress?: string(name='progress', description='查询的结果是否完整。
Complete：查询已经完成，返回结果为完整结果。
Incomplete：查询已经完成，返回结果为不完整结果，需要重复请求以获得完整结果。'),
  totalLines?: long(name='total_lines', description='返回的总日志条数，包含请求参数中所指定的起始日志。'),
}

model GetContextLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetContextLogsResponseBody(name='body'),
}

async function getContextLogs(project: string, logstore: string, request: GetContextLogsRequest): GetContextLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getContextLogsWithOptions(project, logstore, request, headers, runtime);
}

async function getContextLogsWithOptions(project: string, logstore: string, request: GetContextLogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetContextLogsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  var query : map[string]any= {};
  if (!Util.isUnset(request.backLines)) {
    query['back_lines'] = request.backLines;
  }
  if (!Util.isUnset(request.forwardLines)) {
    query['forward_lines'] = request.forwardLines;
  }
  if (!Util.isUnset(request.packId)) {
    query['pack_id'] = request.packId;
  }
  if (!Util.isUnset(request.packMeta)) {
    query['pack_meta'] = request.packMeta;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetContextLogs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetCursorRequest {
  from?: string(name='from', description='时间点（Unix时间戳）或者字符串begin、end。'),
  type?: string(name='type', description='这里固定为 cursor。'),
}

model GetCursorResponseBody = {
  cursor?: string(name='cursor', description='游标位置。'),
}

model GetCursorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCursorResponseBody(name='body'),
}

async function getCursor(project: string, logstore: string, shardId: string, request: GetCursorRequest): GetCursorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCursorWithOptions(project, logstore, shardId, request, headers, runtime);
}

async function getCursorWithOptions(project: string, logstore: string, shardId: string, request: GetCursorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCursorResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  shardId = OpenApiUtil.getEncodeParam(shardId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.from)) {
    query['from'] = request.from;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCursor',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shards/${shardId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetCursorTimeRequest {
  cursor?: string(name='cursor', description='游标。'),
  type?: string(name='type', description='固定为 cursor_time 。'),
}

model GetCursorTimeResponseBody = {
  cursorTime?: string(name='cursor_time', description='Cursor的服务端时间。Unix时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。'),
}

model GetCursorTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCursorTimeResponseBody(name='body'),
}

async function getCursorTime(project: string, logstore: string, shardId: string, request: GetCursorTimeRequest): GetCursorTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCursorTimeWithOptions(project, logstore, shardId, request, headers, runtime);
}

async function getCursorTimeWithOptions(project: string, logstore: string, shardId: string, request: GetCursorTimeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCursorTimeResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  shardId = OpenApiUtil.getEncodeParam(shardId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.cursor)) {
    query['cursor'] = request.cursor;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCursorTime',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shards/${shardId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetEtlMetaRequest {
  elMetaName?: string(name='elMetaName'),
  etlMetaKey?: string(name='etlMetaKey'),
  etlMetaTag?: string(name='etlMetaTag', description='此处固定为 "__all_etl_meta_tag_match__"。'),
}

model GetEtlMetaResponseBody = {
  etlMetaList?: [
    EtlMeta
  ](name='etlMetaList'),
  total?: int32(name='total'),
}

model GetEtlMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEtlMetaResponseBody(name='body'),
}

async function getEtlMeta(project: string, request: GetEtlMetaRequest): GetEtlMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEtlMetaWithOptions(project, request, headers, runtime);
}

async function getEtlMetaWithOptions(project: string, request: GetEtlMetaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetEtlMetaResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any= {};
  if (!Util.isUnset(request.elMetaName)) {
    query['elMetaName'] = request.elMetaName;
  }
  if (!Util.isUnset(request.etlMetaKey)) {
    query['etlMetaKey'] = request.etlMetaKey;
  }
  if (!Util.isUnset(request.etlMetaTag)) {
    query['etlMetaTag'] = request.etlMetaTag;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetEtlMeta',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/etlmetas`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetHistogramsRequest {
  from?: long(name='from', description='查询开始时间点。UNIX时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。

时间区间遵循“左闭右开”原则，即该时间区间包括区间开始时间点，但不包括区间结束时间点。如果from和to的值相同，则为无效区间，函数直接返回错误。'),
  query?: string(name='query', description='查询语句。仅支持查询语句，不支持分析语句。关于查询语句的详细语法，请参见查询语法。'),
  to?: long(name='to', description='查询结束时间点。UNIX时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。

时间区间遵循“左闭右开”原则，即该时间区间包括区间开始时间点，但不包括区间结束时间点。如果from和to的值相同，则为无效区间，函数直接返回错误。'),
  topic?: string(name='topic', description='日志主题。'),
  type?: string(name='type', description='Logstore中数据的类型。该接口中固定取值为histogram。'),
}

model GetHistogramsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [ 
    {
      from?: long(name='from', description='子时间区间的开始时间点。UNIX时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。

时间区间遵循“左闭右开”原则，即该时间区间包括区间开始时间点，但不包括区间结束时间点。如果from和to的值相同，则为无效区间，函数直接返回错误。'),
      to?: long(name='to', description='子时间区间的结束时间点。UNIX时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。

时间区间遵循“左闭右开”原则，即该时间区间包括区间开始时间点，但不包括区间结束时间点。如果from和to的值相同，则为无效区间，函数直接返回错误。'),
      count?: long(name='count', description='该子时间区间内查询到的日志条数。'),
      progress?: string(name='progress', description='当前查询结果在该子时间区间内的结果是否完整。

Complete：查询已经完成，返回结果为完整结果。

Incomplete：查询已经完成，返回结果为不完整结果，需要重复请求以获得完整结果。'),
    }
  ](name='body'),
}

async function getHistograms(project: string, logstore: string, request: GetHistogramsRequest): GetHistogramsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getHistogramsWithOptions(project, logstore, request, headers, runtime);
}

async function getHistogramsWithOptions(project: string, logstore: string, request: GetHistogramsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetHistogramsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  var query : map[string]any= {};
  if (!Util.isUnset(request.from)) {
    query['from'] = request.from;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }
  if (!Util.isUnset(request.to)) {
    query['to'] = request.to;
  }
  if (!Util.isUnset(request.topic)) {
    query['topic'] = request.topic;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHistograms',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/index`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

model GetIndexResponseBody = {
  indexMode?: string(name='index_mode', description='索引模式'),
  keys?: map[string]KeysValue(name='keys', description='字段索引配置。key为字段名称，value为索引配置。'),
  lastModifyTime?: long(name='lastModifyTime', description='上次修改时间'),
  line?: {
    caseSensitive?: boolean(name='caseSensitive', description='大小写敏感'),
    chn?: boolean(name='chn', description='是否包含中文。'),
    excludeKeys?: [ string ](name='exclude_keys', description='排除的字段列表。'),
    includeKeys?: [ string ](name='include_keys', description='包含的字段列表。'),
    token?: [ string ](name='token', description='分词符列表。'),
  }(name='line', description='配置全文索引。'),
  logReduce?: boolean(name='log_reduce', description='是否开启日志聚类.'),
  logReduceBlackList?: [ string ](name='log_reduce_black_list', description='日志聚类的聚类字段过滤黑名单，仅当日志聚类开启时有效。'),
  logReduceWhiteList?: [ string ](name='log_reduce_white_list', description='日志聚类的聚类字段过滤白名单，仅当日志聚类开启时有效。'),
  maxTextLen?: int32(name='max_text_len', description='日志服务默认字段值的最大长度为2048字节，即2 KB。如果您需要修改字段值的最大长度，可设置统计字段（text）最大长度，取值范围为64~16384字节。'),
  storage?: string(name='storage', description='存储类型，目前固定取值为pg。'),
  ttl?: int32(name='ttl', description='索引文件生命周期，支持7天、30天、90天。'),
}

model GetIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetIndexResponseBody(name='body'),
}

async function getIndex(project: string, logstore: string): GetIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getIndexWithOptions(project, logstore, headers, runtime);
}

async function getIndexWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetIndexResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetIndex',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/index`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetLogStoreResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Logstore  
}

async function getLogStore(project: string, logstore: string): GetLogStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLogStoreWithOptions(project, logstore, headers, runtime);
}

async function getLogStoreWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLogStoreResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLogStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetLoggingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Logging  
}

async function getLogging(project: string): GetLoggingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLoggingWithOptions(project, headers, runtime);
}

async function getLoggingWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLoggingResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLogging',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logging`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetLogsRequest {
  from?: long(name='from', description='查询开始时间点。该时间是指写入日志数据时指定的日志时间。

请求参数from和to定义的时间区间遵循左闭右开原则，即该时间区间包括区间开始时间点，但不包括区间结束时间点。如果from和to的值相同，则为无效区间，函数直接返回错误。
Unix时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。'),
  line?: long(name='line', description='仅当query参数为查询语句时，该参数有效，表示请求返回的最大日志条数。最小值为0，最大值为100，默认值为100。'),
  offset?: long(name='offset', description='仅当query参数为查询语句时，该参数有效，表示查询开始行。默认值为0。'),
  powerSql?: boolean(name='powerSql', description='用于指定返回结果是否按日志时间戳降序返回日志，精确到分钟级别。

true：按照日志时间戳降序返回日志。
false（默认值）：按照日志时间戳升序返回日志。
注意
当query参数为查询语句时，参数reverse有效，用于指定返回日志排序方式。
当query参数为查询和分析语句时，参数reverse无效，由SQL分析语句中order by语法指定排序方式。如果order by为asc（默认），则为升序；如果order by为desc，则为降序。'),
  query?: string(name='query', description='查询语句或者分析语句。更多信息，请参见查询概述和分析概述。

在query参数的分析语句中加上set session parallel_sql=true;，表示使用SQL独享版。例如* | set session parallel_sql=true; select count(*) as pv 。

说明 当query参数中有分析语句（SQL语句）时，该接口的line参数和offset参数无效，建议设置为0，需通过SQL语句的LIMIT语法实现翻页。更多信息，请参见分页显示查询分析结果。'),
  reverse?: boolean(name='reverse', description='用于指定返回结果是否按日志时间戳降序返回日志，精确到分钟级别。

true：按照日志时间戳降序返回日志。
false（默认值）：按照日志时间戳升序返回日志。
注意
当query参数为查询语句时，参数reverse有效，用于指定返回日志排序方式。
当query参数为查询和分析语句时，参数reverse无效，由SQL分析语句中order by语法指定排序方式。如果order by为asc（默认），则为升序；如果order by为desc，则为降序。'),
  to?: long(name='to', description='查询结束时间点。该时间是指写入日志数据时指定的日志时间。

请求参数from和to定义的时间区间遵循左闭右开原则，即该时间区间包括区间开始时间点，但不包括区间结束时间点。如果from和to的值相同，则为无效区间，函数直接返回错误。
Unix时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。'),
  topic?: string(name='topic', description='status: 401 | SELECT remote_addr,COUNT(*) as pv GROUP by remote_addr ORDER by pv desc limit 5'),
  type?: string(name='type', description='查询Logstore数据的类型。在该接口中固定取值为log。'),
}

model GetLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [  map[string]any ](name='body'),
}

async function getLogs(project: string, logstore: string, request: GetLogsRequest): GetLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLogsWithOptions(project, logstore, request, headers, runtime);
}

async function getLogsWithOptions(project: string, logstore: string, request: GetLogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetLogsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  var query : map[string]any= {};
  if (!Util.isUnset(request.from)) {
    query['from'] = request.from;
  }
  if (!Util.isUnset(request.line)) {
    query['line'] = request.line;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.powerSql)) {
    query['powerSql'] = request.powerSql;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }
  if (!Util.isUnset(request.reverse)) {
    query['reverse'] = request.reverse;
  }
  if (!Util.isUnset(request.to)) {
    query['to'] = request.to;
  }
  if (!Util.isUnset(request.topic)) {
    query['topic'] = request.topic;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLogs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/index`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

model GetMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MachineGroup  
}

async function getMachineGroup(project: string, machineGroup: string): GetMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMachineGroupWithOptions(project, machineGroup, headers, runtime);
}

async function getMachineGroupWithOptions(project: string, machineGroup: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetMachineGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  machineGroup = OpenApiUtil.getEncodeParam(machineGroup);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Project  
}

async function getProject(project: string): GetProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProjectWithOptions(project, headers, runtime);
}

async function getProjectWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetProjectResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetProjectLogsRequest {
  powerSql?: boolean(name='powerSql', description='是否使用SQL独享版。更多信息，请参见开启SQL独享版。

true：使用SQL独享版。
false（默认值）：使用SQL普通版。
除通过powerSql参数配置SQL独享版外，您还可以使用query参数。'),
  query?: string(name='query', description='标准SQL语句。例如日志库名称为nginx-moni，查询时间区间在2022-03-01 10:41:40到2022-03-01 10:56:40之间的访问数量。'),
}

model GetProjectLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [ map[string]string ](name='body'),
}

async function getProjectLogs(project: string, request: GetProjectLogsRequest): GetProjectLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProjectLogsWithOptions(project, request, headers, runtime);
}

async function getProjectLogsWithOptions(project: string, request: GetProjectLogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProjectLogsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any= {};
  if (!Util.isUnset(request.powerSql)) {
    query['powerSql'] = request.powerSql;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProjectLogs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

model GetSavedSearchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SavedSearch  
}

async function getSavedSearch(project: string, savedsearchName: string): GetSavedSearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSavedSearchWithOptions(project, savedsearchName, headers, runtime);
}

async function getSavedSearchWithOptions(project: string, savedsearchName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetSavedSearchResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  savedsearchName = OpenApiUtil.getEncodeParam(savedsearchName);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetSavedSearch',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/savedsearches/${savedsearchName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [
    ConsumerGroup
  ](name='body'),
}

async function listConsumerGroup(project: string, logstore: string): ListConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConsumerGroupWithOptions(project, logstore, headers, runtime);
}

async function listConsumerGroupWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListConsumerGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListConsumerGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

model ListDomainsRequest {
  domainName?: string(name='domainName', description='用于搜索匹配的自定义域名'),
  offset?: int32(name='offset'),
  size?: int32(name='size'),
}

model ListDomainsResponseBody = {
  count?: long(name='count'),
  domains?: [ string ](name='domains'),
  total?: long(name='total'),
}

model ListDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDomainsResponseBody(name='body'),
}

async function listDomains(project: string, request: ListDomainsRequest): ListDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDomainsWithOptions(project, request, headers, runtime);
}

async function listDomainsWithOptions(project: string, request: ListDomainsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDomainsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any= {};
  if (!Util.isUnset(request.domainName)) {
    query['domainName'] = request.domainName;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDomains',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/domains`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListEtlMetaRequest {
  etlMetaKey?: string(name='etlMetaKey'),
  etlMetaName?: string(name='etlMetaName'),
  etlMetaTag?: string(name='etlMetaTag'),
  offset?: int32(name='offset', description='默认值 0。'),
  size?: int32(name='size', description='默认值 200.'),
}

model ListEtlMetaResponseBody = {
  etlMetaList?: [
    EtlMeta
  ](name='etlMetaList'),
  total?: int32(name='total'),
}

model ListEtlMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEtlMetaResponseBody(name='body'),
}

async function listEtlMeta(project: string, request: ListEtlMetaRequest): ListEtlMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEtlMetaWithOptions(project, request, headers, runtime);
}

async function listEtlMetaWithOptions(project: string, request: ListEtlMetaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListEtlMetaResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any= {};
  if (!Util.isUnset(request.etlMetaKey)) {
    query['etlMetaKey'] = request.etlMetaKey;
  }
  if (!Util.isUnset(request.etlMetaName)) {
    query['etlMetaName'] = request.etlMetaName;
  }
  if (!Util.isUnset(request.etlMetaTag)) {
    query['etlMetaTag'] = request.etlMetaTag;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEtlMeta',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/etlmetas`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListEtlMetaNameRequest {
  offset?: int32(name='offset', description='默认值为 0。'),
  size?: int32(name='size', description='默认值 200。'),
}

model ListEtlMetaNameResponseBody = {
  count?: int32(name='count'),
  etlMetaNameList?: [ string ](name='etlMetaNameList'),
  total?: int32(name='total'),
}

model ListEtlMetaNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEtlMetaNameResponseBody(name='body'),
}

async function listEtlMetaName(project: string, request: ListEtlMetaNameRequest): ListEtlMetaNameResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEtlMetaNameWithOptions(project, request, headers, runtime);
}

async function listEtlMetaNameWithOptions(project: string, request: ListEtlMetaNameRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListEtlMetaNameResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any= {};
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEtlMetaName',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/etlmetanames`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListLogStoresRequest {
  logstoreName?: string(name='logstoreName'),
  offset?: int32(name='offset'),
  size?: int32(name='size', description='默认值为 500。'),
  telemetryType?: string(name='telemetryType'),
}

model ListLogStoresResponseBody = {
  logstores?: [ string ](name='logstores'),
  total?: int32(name='total'),
}

model ListLogStoresResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLogStoresResponseBody(name='body'),
}

async function listLogStores(project: string, request: ListLogStoresRequest): ListLogStoresResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLogStoresWithOptions(project, request, headers, runtime);
}

async function listLogStoresWithOptions(project: string, request: ListLogStoresRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLogStoresResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any= {};
  if (!Util.isUnset(request.logstoreName)) {
    query['logstoreName'] = request.logstoreName;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.telemetryType)) {
    query['telemetryType'] = request.telemetryType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLogStores',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListMachineGroupRequest {
  groupName?: string(name='groupName', description='可将 groupName 作为 pattern 匹配名称，只会返回匹配的机器组。例如 test 可以匹配机器组 test-group。'),
  offset?: int32(name='offset', description='分页请求的起始位置。默认为0。'),
  size?: int32(name='size', description='分页查询时，设置的每页行数。默认值为2000。'),
}

model ListMachineGroupResponseBody = {
  count?: int32(name='count', description='当前页返回的机器组数量。'),
  machinegroups?: [ string ](name='machinegroups', description='机器组名称列表。'),
  total?: int32(name='total', description='机器组总数量。'),
}

model ListMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMachineGroupResponseBody(name='body'),
}

async function listMachineGroup(project: string, request: ListMachineGroupRequest): ListMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMachineGroupWithOptions(project, request, headers, runtime);
}

async function listMachineGroupWithOptions(project: string, request: ListMachineGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMachineGroupResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any= {};
  if (!Util.isUnset(request.groupName)) {
    query['groupName'] = request.groupName;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListMachinesRequest {
  offset?: int32(name='offset', description='查询开始行。默认值为0。'),
  size?: int32(name='size', description='分页查询时，设置的每页行数。默认值为2000。'),
}

model ListMachinesResponseBody = {
  count?: int32(name='count', description='当前页返回的机器数目。'),
  machines?: [
    Machine
  ](name='machines', description='返回的机器信息列表。'),
  total?: int32(name='total', description='机器总数。'),
}

model ListMachinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMachinesResponseBody(name='body'),
}

async function listMachines(project: string, machineGroup: string, request: ListMachinesRequest): ListMachinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMachinesWithOptions(project, machineGroup, request, headers, runtime);
}

async function listMachinesWithOptions(project: string, machineGroup: string, request: ListMachinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMachinesResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  machineGroup = OpenApiUtil.getEncodeParam(machineGroup);
  var query : map[string]any= {};
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMachines',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}/machines`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListProjectRequest {
  offset?: int32(name='offset'),
  projectName?: string(name='projectName'),
  size?: int32(name='size', description='默认值为 500。'),
}

model ListProjectResponseBody = {
  count?: long(name='count'),
  projects?: [
    Project
  ](name='projects'),
  total?: long(name='total'),
}

model ListProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProjectResponseBody(name='body'),
}

async function listProject(request: ListProjectRequest): ListProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProjectWithOptions(request, headers, runtime);
}

async function listProjectWithOptions(request: ListProjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProjectResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.projectName)) {
    query['projectName'] = request.projectName;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListSavedSearchRequest {
  offset?: int32(name='offset'),
  size?: int32(name='size', description='默认值为 500。'),
}

model ListSavedSearchResponseBody = {
  count?: int32(name='count'),
  savedsearchItems?: [
    SavedSearch
  ](name='savedsearchItems'),
  total?: int32(name='total'),
}

model ListSavedSearchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSavedSearchResponseBody(name='body'),
}

async function listSavedSearch(project: string, request: ListSavedSearchRequest): ListSavedSearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSavedSearchWithOptions(project, request, headers, runtime);
}

async function listSavedSearchWithOptions(project: string, request: ListSavedSearchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSavedSearchResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any= {};
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSavedSearch',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/savedsearches`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListShardsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [
    Shard
  ](name='body'),
}

async function listShards(project: string, logstore: string): ListShardsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listShardsWithOptions(project, logstore, headers, runtime);
}

async function listShardsWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListShardsResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListShards',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shards`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

model ListTagResourcesRequest {
  resourceId?: [ string ](name='resourceId', description='查询的资源的 id 列表。resource id 与 tags 应至少存在一个。'),
  resourceType?: string(name='resourceType', description='资源类型。目前取值范围：project。'),
  tags?: [ 
    {
      key?: string(name='key', description='精确过滤的标签的键。'),
      value?: string(name='value', description='精确过滤的标签的值。'),
    }
  ](name='tags', description='精确查找时过滤的标签键值对。resource id 与 tags 应至少存在一个。'),
}

model ListTagResourcesShrinkRequest {
  resourceIdShrink?: string(name='resourceId', description='查询的资源的 id 列表。resource id 与 tags 应至少存在一个。'),
  resourceType?: string(name='resourceType', description='资源类型。目前取值范围：project。'),
  tagsShrink?: string(name='tags', description='精确查找时过滤的标签键值对。resource id 与 tags 应至少存在一个。'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='nextToken', description='下一个查询开始Token。'),
  tagResources?: [ 
    {
      resourceId?: string(name='resourceId', description='资源 id。'),
      resourceType?: string(name='resourceType', description='资源类型。'),
      tagKey?: string(name='tagKey', description='标签的键。'),
      tagValue?: string(name='tagValue', description='标签的值。'),
    }
  ](name='tagResources', description='返回的标签列表。'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagResourcesWithOptions(request, headers, runtime);
}

async function listTagResourcesWithOptions(tmpReq: ListTagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new ListTagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceId)) {
    request.resourceIdShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceId, 'resourceId', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'tags', 'json');
  }
  var query : map[string]any= {};
  if (!Util.isUnset(request.resourceIdShrink)) {
    query['resourceId'] = request.resourceIdShrink;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['resourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['tags'] = request.tagsShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/tags`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model MergeShardsRequest {
  action?: string(name='action', description='固定为 merge。'),
}

model MergeShardsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [
    Shard
  ](name='body'),
}

async function mergeShards(project: string, logstore: string, shardID: string, request: MergeShardsRequest): MergeShardsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return mergeShardsWithOptions(project, logstore, shardID, request, headers, runtime);
}

async function mergeShardsWithOptions(project: string, logstore: string, shardID: string, request: MergeShardsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): MergeShardsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  shardID = OpenApiUtil.getEncodeParam(shardID);
  var query : map[string]any= {};
  if (!Util.isUnset(request.action)) {
    query['action'] = request.action;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MergeShards',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shards/${shardID}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

model RemoveConfigFromMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function removeConfigFromMachineGroup(project: string, machineGroup: string, configName: string): RemoveConfigFromMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeConfigFromMachineGroupWithOptions(project, machineGroup, configName, headers, runtime);
}

async function removeConfigFromMachineGroupWithOptions(project: string, machineGroup: string, configName: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveConfigFromMachineGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  machineGroup = OpenApiUtil.getEncodeParam(machineGroup);
  configName = OpenApiUtil.getEncodeParam(configName);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveConfigFromMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}/configs/${configName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model SplitShardRequest {
  action?: string(name='action', description='这里固定为 split。'),
  key?: string(name='key', description='分裂的位置。'),
  shardCount?: int32(name='shardCount', description='要分裂成的 shard 数量，默认为 2。'),
}

model SplitShardResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [
    Shard
  ](name='body'),
}

async function splitShard(project: string, logstore: string, shardID: string, request: SplitShardRequest): SplitShardResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return splitShardWithOptions(project, logstore, shardID, request, headers, runtime);
}

async function splitShardWithOptions(project: string, logstore: string, shardID: string, request: SplitShardRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SplitShardResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  shardID = OpenApiUtil.getEncodeParam(shardID);
  var query : map[string]any= {};
  if (!Util.isUnset(request.action)) {
    query['action'] = request.action;
  }
  if (!Util.isUnset(request.key)) {
    query['key'] = request.key;
  }
  if (!Util.isUnset(request.shardCount)) {
    query['shardCount'] = request.shardCount;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SplitShard',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shards/${shardID}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

model TagResourcesRequest {
  resourceId?: [ string ](name='resourceId', description='资源的 id 列表，可以一次为多个同类型资源打上相同的标签。'),
  resourceType?: string(name='resourceType', description='资源的类型。目前取值范围：project。'),
  tags?: [ 
    {
      key?: string(name='key', description='标签的 key。'),
      value?: string(name='value', description='标签的 value。'),
    }
  ](name='tags', description='标签列表。'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return tagResourcesWithOptions(request, headers, runtime);
}

async function tagResourcesWithOptions(request: TagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.resourceId)) {
    body['resourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['resourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/tag`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model UnTagResourcesRequest {
  all?: boolean(name='all', description='是否删除所有标签，默认为 false，表示仅删除 tags 列表中的标签项。值为 true 时删除资源上绑定的所有标签。'),
  resourceId?: [ string ](name='resourceId', description='资源的 id 列表，可以一次为多个同类型资源删除相同的标签。当 all 为 false 时生效。'),
  resourceType?: string(name='resourceType', description='资源的类型。目前取值范围 ： project。'),
  tags?: [ string ](name='tags', description='标签 key 列表。当 all 为 false 时，仅删除列表中的标签。'),
}

model UnTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function unTagResources(request: UnTagResourcesRequest): UnTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return unTagResourcesWithOptions(request, headers, runtime);
}

async function unTagResourcesWithOptions(request: UnTagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UnTagResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.all)) {
    body['all'] = request.all;
  }
  if (!Util.isUnset(request.resourceId)) {
    body['resourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['resourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UnTagResources',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/untag`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model UpdateCheckPointRequest {
  checkpoint?: string(name='checkpoint', description='checkpoint值。'),
  shard?: int32(name='shard', description='shard 的 id。'),
  consumer?: string(name='consumer', description='消费者。'),
  forceSuccess?: boolean(name='forceSuccess', description='当不指定消费者时，必须指定forceSuccess为true才能更新checkpoint。'),
  type?: string(name='type', description='固定为 checkpoint。'),
}

model UpdateCheckPointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateCheckPoint(project: string, logstore: string, consumerGroup: string, request: UpdateCheckPointRequest): UpdateCheckPointResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateCheckPointWithOptions(project, logstore, consumerGroup, request, headers, runtime);
}

async function updateCheckPointWithOptions(project: string, logstore: string, consumerGroup: string, request: UpdateCheckPointRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateCheckPointResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  consumerGroup = OpenApiUtil.getEncodeParam(consumerGroup);
  var query : map[string]any= {};
  if (!Util.isUnset(request.consumer)) {
    query['consumer'] = request.consumer;
  }
  if (!Util.isUnset(request.forceSuccess)) {
    query['forceSuccess'] = request.forceSuccess;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var body : map[string]any= {};
  if (!Util.isUnset(request.checkpoint)) {
    body['checkpoint'] = request.checkpoint;
  }
  if (!Util.isUnset(request.shard)) {
    body['shard'] = request.shard;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCheckPoint',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups/${consumerGroup}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model UpdateConsumerGroupRequest {
  order?: boolean(name='order'),
  timeout?: int32(name='timeout'),
}

model UpdateConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateConsumerGroup(project: string, logstore: string, consumerGroup: string, request: UpdateConsumerGroupRequest): UpdateConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateConsumerGroupWithOptions(project, logstore, consumerGroup, request, headers, runtime);
}

async function updateConsumerGroupWithOptions(project: string, logstore: string, consumerGroup: string, request: UpdateConsumerGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateConsumerGroupResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  consumerGroup = OpenApiUtil.getEncodeParam(consumerGroup);
  var body : map[string]any= {};
  if (!Util.isUnset(request.order)) {
    body['order'] = request.order;
  }
  if (!Util.isUnset(request.timeout)) {
    body['timeout'] = request.timeout;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateConsumerGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups/${consumerGroup}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model UpdateEtlMetaRequest {
  enable?: boolean(name='enable', description='是否启用。etlMetaTag、etlMetaValue、enable 至少需要存在一个。'),
  etlMetaKey?: string(name='etlMetaKey', description='key。由 ascii 可打印字符组成，包括数字、英文大小写字母、下划线、连字符、英文标点符号等组成，长度在[1,255]之间。'),
  etlMetaName?: string(name='etlMetaName', description='名字。由数字、大小写字母、下划线_、连字符-组成，长度需要在[2,64]之间。'),
  etlMetaTag?: string(name='etlMetaTag', description='key。由 ascii 可打印字符组成，包括数字、英文大小写字母、下划线、连字符、英文标点符号等组成，长度在[1,128]之间。'),
  etlMetaValue?: map[string]any(name='etlMetaValue'),
}

model UpdateEtlMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateEtlMeta(project: string, request: UpdateEtlMetaRequest): UpdateEtlMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateEtlMetaWithOptions(project, request, headers, runtime);
}

async function updateEtlMetaWithOptions(project: string, request: UpdateEtlMetaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateEtlMetaResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any= {};
  if (!Util.isUnset(request.enable)) {
    body['enable'] = request.enable;
  }
  if (!Util.isUnset(request.etlMetaKey)) {
    body['etlMetaKey'] = request.etlMetaKey;
  }
  if (!Util.isUnset(request.etlMetaName)) {
    body['etlMetaName'] = request.etlMetaName;
  }
  if (!Util.isUnset(request.etlMetaTag)) {
    body['etlMetaTag'] = request.etlMetaTag;
  }
  if (!Util.isUnset(request.etlMetaValue)) {
    body['etlMetaValue'] = request.etlMetaValue;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEtlMeta',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/etlmetas`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model UpdateIndexRequest {
  keys?: map[string]KeysValue(name='keys', description='字段索引配置，key为字段名称，value为字段索引配置。'),
  line?: {
    caseSensitive?: boolean(name='caseSensitive', description='大小写敏感'),
    chn?: boolean(name='chn', description='包含中文'),
    excludeKeys?: [ string ](name='exclude_keys', description='排除的字段列表，不能与include_keys同时指定。'),
    includeKeys?: [ string ](name='include_keys', description='包含的字段列表，不能与exclude_keys同时指定。'),
    token?: [ string ](name='token', description='分词符列表。可以设置一个分词参数，指定这个字段按照哪一种方式分词。'),
  }(name='line', description='配置全文索引。'),
  logReduce?: boolean(name='log_reduce', description='开启日志聚类，开启后白名单与黑名单至多生效其中一个。'),
  logReduceBlackList?: [ string ](name='log_reduce_black_list', description='日志聚类的聚类字段黑名单'),
  logReduceWhiteList?: [ string ](name='log_reduce_white_list', description='日志聚类的聚类字段白名单'),
  maxTextLen?: int32(name='max_text_len', description='统计字段的最大长度'),
  ttl?: int32(name='ttl', description='保存时间，单位为天'),
}

model UpdateIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateIndex(project: string, logstore: string, request: UpdateIndexRequest): UpdateIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateIndexWithOptions(project, logstore, request, headers, runtime);
}

async function updateIndexWithOptions(project: string, logstore: string, request: UpdateIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateIndexResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  var body : map[string]any= {};
  if (!Util.isUnset(request.keys)) {
    body['keys'] = request.keys;
  }
  if (!Util.isUnset(request.line)) {
    body['line'] = request.line;
  }
  if (!Util.isUnset(request.logReduce)) {
    body['log_reduce'] = request.logReduce;
  }
  if (!Util.isUnset(request.logReduceBlackList)) {
    body['log_reduce_black_list'] = request.logReduceBlackList;
  }
  if (!Util.isUnset(request.logReduceWhiteList)) {
    body['log_reduce_white_list'] = request.logReduceWhiteList;
  }
  if (!Util.isUnset(request.maxTextLen)) {
    body['max_text_len'] = request.maxTextLen;
  }
  if (!Util.isUnset(request.ttl)) {
    body['ttl'] = request.ttl;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIndex',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/index`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model UpdateLogStoreRequest {
  appendMeta?: boolean(name='appendMeta'),
  autoSplit?: boolean(name='autoSplit'),
  enableTracking?: boolean(name='enable_tracking'),
  encryptConf?: EncryptConf(name='encrypt_conf'),
  hotTtl?: int32(name='hot_ttl'),
  logstoreName?: string(name='logstoreName'),
  maxSplitShard?: int32(name='maxSplitShard'),
  shardCount?: int32(name='shardCount'),
  telemetryType?: string(name='telemetryType'),
  ttl?: int32(name='ttl'),
}

model UpdateLogStoreResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateLogStore(project: string, logstore: string, request: UpdateLogStoreRequest): UpdateLogStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogStoreWithOptions(project, logstore, request, headers, runtime);
}

async function updateLogStoreWithOptions(project: string, logstore: string, request: UpdateLogStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogStoreResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  var body : map[string]any= {};
  if (!Util.isUnset(request.appendMeta)) {
    body['appendMeta'] = request.appendMeta;
  }
  if (!Util.isUnset(request.autoSplit)) {
    body['autoSplit'] = request.autoSplit;
  }
  if (!Util.isUnset(request.enableTracking)) {
    body['enable_tracking'] = request.enableTracking;
  }
  if (!Util.isUnset(request.encryptConf)) {
    body['encrypt_conf'] = request.encryptConf;
  }
  if (!Util.isUnset(request.hotTtl)) {
    body['hot_ttl'] = request.hotTtl;
  }
  if (!Util.isUnset(request.logstoreName)) {
    body['logstoreName'] = request.logstoreName;
  }
  if (!Util.isUnset(request.maxSplitShard)) {
    body['maxSplitShard'] = request.maxSplitShard;
  }
  if (!Util.isUnset(request.shardCount)) {
    body['shardCount'] = request.shardCount;
  }
  if (!Util.isUnset(request.telemetryType)) {
    body['telemetryType'] = request.telemetryType;
  }
  if (!Util.isUnset(request.ttl)) {
    body['ttl'] = request.ttl;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model UpdateLoggingRequest {
  loggingDetails?: [ 
    {
      logstore?: string(name='logstore', description='该种类服务日志要保存到的 logstore 名称。'),
      type?: string(name='type', description='服务日志的种类。可选 "consumergroup_log"、 "logtail_alarm"、"operation_log"、"logtail_profile"、"metering"、"logtail_status"、"scheduled_sql_alert"、 "etl_alert" 等。'),
    }
  ](name='loggingDetails', description='服务日志配置列表。'),
  loggingProject?: string(name='loggingProject', description='服务日志要保存到的 project 名称。'),
}

model UpdateLoggingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateLogging(project: string, request: UpdateLoggingRequest): UpdateLoggingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLoggingWithOptions(project, request, headers, runtime);
}

async function updateLoggingWithOptions(project: string, request: UpdateLoggingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLoggingResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any= {};
  if (!Util.isUnset(request.loggingDetails)) {
    body['loggingDetails'] = request.loggingDetails;
  }
  if (!Util.isUnset(request.loggingProject)) {
    body['loggingProject'] = request.loggingProject;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogging',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logging`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model UpdateMachineGroupRequest {
  groupAttribute?: {
    externalName?: string(name='externalName', description='机器组所依赖的外部管理系统标识。'),
    groupTopic?: string(name='groupTopic', description='机器组的日志主题。'),
  }(name='groupAttribute', description='机器组属性。'),
  groupName?: string(name='groupName', description='机器组名称。'),
  groupType?: string(name='groupType', description='机器组类型，可选值，默认为空。'),
  machineIdentifyType?: string(name='machineIdentifyType', description='机器组标识种类，支持 ip 、userdefined 两种。'),
  machineList?: [ string ](name='machineList', description='机器列表。'),
}

model UpdateMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateMachineGroup(project: string, groupName: string, request: UpdateMachineGroupRequest): UpdateMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMachineGroupWithOptions(project, groupName, request, headers, runtime);
}

async function updateMachineGroupWithOptions(project: string, groupName: string, request: UpdateMachineGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMachineGroupResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  groupName = OpenApiUtil.getEncodeParam(groupName);
  var body : map[string]any= {};
  if (!Util.isUnset(request.groupAttribute)) {
    body['groupAttribute'] = request.groupAttribute;
  }
  if (!Util.isUnset(request.groupName)) {
    body['groupName'] = request.groupName;
  }
  if (!Util.isUnset(request.groupType)) {
    body['groupType'] = request.groupType;
  }
  if (!Util.isUnset(request.machineIdentifyType)) {
    body['machineIdentifyType'] = request.machineIdentifyType;
  }
  if (!Util.isUnset(request.machineList)) {
    body['machineList'] = request.machineList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${groupName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model UpdateProjectRequest {
  description?: string(name='description', description='Project description'),
}

model UpdateProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateProject(project: string, request: UpdateProjectRequest): UpdateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProjectWithOptions(project, request, headers, runtime);
}

async function updateProjectWithOptions(project: string, request: UpdateProjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProjectResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model UpdateSavedSearchRequest {
  displayName?: string(name='displayName'),
  logstore?: string(name='logstore'),
  savedsearchName?: string(name='savedsearchName'),
  searchQuery?: string(name='searchQuery'),
  topic?: string(name='topic'),
}

model UpdateSavedSearchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateSavedSearch(project: string, savedsearchName: string, request: UpdateSavedSearchRequest): UpdateSavedSearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSavedSearchWithOptions(project, savedsearchName, request, headers, runtime);
}

async function updateSavedSearchWithOptions(project: string, savedsearchName: string, request: UpdateSavedSearchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSavedSearchResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  savedsearchName = OpenApiUtil.getEncodeParam(savedsearchName);
  var body : map[string]any= {};
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.logstore)) {
    body['logstore'] = request.logstore;
  }
  if (!Util.isUnset(request.savedsearchName)) {
    body['savedsearchName'] = request.savedsearchName;
  }
  if (!Util.isUnset(request.searchQuery)) {
    body['searchQuery'] = request.searchQuery;
  }
  if (!Util.isUnset(request.topic)) {
    body['topic'] = request.topic;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSavedSearch',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/savedsearches/${savedsearchName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model KeysValue = {
  caseSensitive?: boolean(name='caseSensitive', description='大小写敏感'),
  chn?: boolean(name='chn', description='包含中文'),
  type?: string(name='type', description='字段的索引类型'),
  alias?: string(name='alias', description='别名'),
  token?: [ string ](name='token', description='分词符列表。仅当type参数取值为text时，必须设置。'),
  docValue?: boolean(name='doc_value', description='开启统计'),
}

