/**
 *
 */
import Util;
import SPI;
import GatewayClient;
import OpenApi;
import OpenApiUtil;

extends OpenApi;

type @client = SPI

init(config: OpenApi.Config){
  super(config);
  @client = new GatewayClient();
  @spi = @client;
  @endpointRule = 'central';
  @endpointMap = {
    ap-southeast-1 = 'sls.ap-southeast-1.aliyuncs.com',
    cn-hangzhou = 'sls.cn-hangzhou.aliyuncs.com',
    cn-hongkong = 'sls.cn-hongkong.aliyuncs.com',
    cn-huhehaote = 'sls.cn-huhehaote.aliyuncs.com',
    cn-shanghai = 'sls.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'sls.cn-shenzhen.aliyuncs.com',
    cn-zhangjiakou = 'sls.cn-zhangjiakou.aliyuncs.com',
    eu-central-1 = 'sls.eu-central-1.aliyuncs.com',
  };
}

model ConsumerGroup {
  name?: string(name='name', description='consumerGroup'),
  order?: boolean(name='order', description='order'),
  timeout?: int32(name='timeout', description='timeout'),
}

model EncryptConf {
  enable?: boolean(name='enable', description='enable'),
  encryptType?: string(name='encrypt_type', description='encrypt_type'),
  userCmkInfo?: EncryptUserCmkConf(name='user_cmk_info'),
}

model EncryptUserCmkConf {
  arn?: string(name='arn', description='arn'),
  cmkKeyId?: string(name='cmk_key_id', description='cmk_key_id'),
  regionId?: string(name='region_id', description='region_id'),
}

model SavedSearch {
  displayName?: string(name='displayName', description='displayName'),
  logstore?: string(name='logstore', description='logstore'),
  savedsearchName?: string(name='savedsearchName', description='savedsearchName'),
  searchQuery?: string(name='searchQuery', description='searchQuery'),
  topic?: string(name='topic', description='topic'),
}

model Logstore {
  appendMeta?: boolean(name='appendMeta', description='append client ip and receive time'),
  autoSplit?: boolean(name='autoSplit', description='auto spilt shard'),
  createTime?: int32(name='createTime', description='create time'),
  enableTracking?: boolean(name='enable_tracking', description='enable web tracking'),
  encryptConf?: EncryptConf(name='encrypt_conf', description='Encrypt configuration'),
  lastModifyTime?: int32(name='lastModifyTime', description='last modify time'),
  logstoreName?: string(name='logstoreName', description='logstore name'),
  maxSplitShard?: int32(name='maxSplitShard', description='max split shard'),
  shardCount?: int32(name='shardCount', description='shard count'),
  telemetryType?: string(name='telemetryType', description='telemetryType'),
  ttl?: int32(name='ttl', description='ttl'),
}

model Project {
  createTime?: string(name='createTime', description='创建时间'),
  description?: string(name='description', description='描述'),
  lastModifyTime?: string(name='lastModifyTime', description='最后更新时间'),
  owner?: string(name='owner', description='owner'),
  projectName?: string(name='projectName', description='Project名称'),
  region?: string(name='region', description='所在区域'),
  status?: string(name='status', description='状态'),
}

model Shard {
  createTime?: int32(name='createTime', description='createTime'),
  exclusiveEndKey?: string(name='exclusiveEndKey', description='exclusiveEndKey'),
  inclusiveBeginKey?: string(name='inclusiveBeginKey', description='inclusiveBeginKey'),
  serverIp?: string(name='serverIp', description='serverIp'),
  shardId?: int32(name='shardId', description='shard id'),
  status?: string(name='status', description='status'),
}

model CreateConsumerGroupRequest {
  consumerGroup?: string(name='consumerGroup'),
  order?: boolean(name='order'),
  timeout?: int32(name='timeout'),
}

model CreateConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
}

async function createConsumerGroup(project: string, logstore: string, request: CreateConsumerGroupRequest): CreateConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createConsumerGroupWithOptions(project, logstore, request, headers, runtime);
}

async function createConsumerGroupWithOptions(project: string, logstore: string, request: CreateConsumerGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateConsumerGroupResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  var body : map[string]any= {};
  if (!Util.isUnset(request.consumerGroup)) {
    body['consumerGroup'] = request.consumerGroup;
  }
  if (!Util.isUnset(request.order)) {
    body['order'] = request.order;
  }
  if (!Util.isUnset(request.timeout)) {
    body['timeout'] = request.timeout;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateConsumerGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model CreateLogStoreRequest {
  appendMeta?: boolean(name='appendMeta'),
  autoSplit?: boolean(name='autoSplit'),
  enableTracking?: boolean(name='enable_tracking'),
  encryptConf?: EncryptConf(name='encrypt_conf'),
  logstoreName?: string(name='logstoreName'),
  maxSplitShard?: int32(name='maxSplitShard'),
  shardCount?: int32(name='shardCount'),
  ttl?: int32(name='ttl'),
}

model CreateLogStoreShrinkRequest {
  appendMeta?: boolean(name='appendMeta'),
  autoSplit?: boolean(name='autoSplit'),
  enableTracking?: boolean(name='enable_tracking'),
  encryptConfShrink?: string(name='encrypt_conf'),
  logstoreName?: string(name='logstoreName'),
  maxSplitShard?: int32(name='maxSplitShard'),
  shardCount?: int32(name='shardCount'),
  ttl?: int32(name='ttl'),
}

model CreateLogStoreResponse = {
  headers: map[string]string(name='headers'),
}

async function createLogStore(project: string, request: CreateLogStoreRequest): CreateLogStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLogStoreWithOptions(project, request, headers, runtime);
}

async function createLogStoreWithOptions(project: string, tmpReq: CreateLogStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLogStoreResponse {
  Util.validateModel(tmpReq);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var request = new CreateLogStoreShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.encryptConf)) {
    request.encryptConfShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.encryptConf, 'encrypt_conf', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.appendMeta)) {
    body['appendMeta'] = request.appendMeta;
  }
  if (!Util.isUnset(request.autoSplit)) {
    body['autoSplit'] = request.autoSplit;
  }
  if (!Util.isUnset(request.enableTracking)) {
    body['enable_tracking'] = request.enableTracking;
  }
  if (!Util.isUnset(request.encryptConfShrink)) {
    body['encrypt_conf'] = request.encryptConfShrink;
  }
  if (!Util.isUnset(request.logstoreName)) {
    body['logstoreName'] = request.logstoreName;
  }
  if (!Util.isUnset(request.maxSplitShard)) {
    body['maxSplitShard'] = request.maxSplitShard;
  }
  if (!Util.isUnset(request.shardCount)) {
    body['shardCount'] = request.shardCount;
  }
  if (!Util.isUnset(request.ttl)) {
    body['ttl'] = request.ttl;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLogStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model CreateProjectRequest {
  description?: string(name='description'),
  projectName?: string(name='projectName'),
}

model CreateProjectResponse = {
  headers: map[string]string(name='headers'),
}

async function createProject(request: CreateProjectRequest): CreateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createProjectWithOptions(request, headers, runtime);
}

async function createProjectWithOptions(request: CreateProjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateProjectResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.projectName)) {
    body['projectName'] = request.projectName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model CreateSavedSearchRequest {
  displayName?: string(name='displayName'),
  logstore?: string(name='logstore'),
  savedsearchName?: string(name='savedsearchName'),
  searchQuery?: string(name='searchQuery'),
  topic?: string(name='topic'),
}

model CreateSavedSearchResponse = {
  headers: map[string]string(name='headers'),
}

async function createSavedSearch(request: CreateSavedSearchRequest): CreateSavedSearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSavedSearchWithOptions(request, headers, runtime);
}

async function createSavedSearchWithOptions(request: CreateSavedSearchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSavedSearchResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.logstore)) {
    body['logstore'] = request.logstore;
  }
  if (!Util.isUnset(request.savedsearchName)) {
    body['savedsearchName'] = request.savedsearchName;
  }
  if (!Util.isUnset(request.searchQuery)) {
    body['searchQuery'] = request.searchQuery;
  }
  if (!Util.isUnset(request.topic)) {
    body['topic'] = request.topic;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSavedSearch',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/savedsearches`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model DeleteConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteConsumerGroup(project: string, logstore: string, consumerGroup: string): DeleteConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConsumerGroupWithOptions(project, logstore, consumerGroup, headers, runtime);
}

async function deleteConsumerGroupWithOptions(project: string, logstore: string, consumerGroup: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteConsumerGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  consumerGroup = OpenApiUtil.getEncodeParam(consumerGroup);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteConsumerGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups/${consumerGroup}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model DeleteProjectResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteProject(project: string): DeleteProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProjectWithOptions(project, headers, runtime);
}

async function deleteProjectWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProjectResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model DeleteSavedSearchResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteSavedSearch(project: string, savedsearchName: string): DeleteSavedSearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSavedSearchWithOptions(project, savedsearchName, headers, runtime);
}

async function deleteSavedSearchWithOptions(project: string, savedsearchName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteSavedSearchResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  savedsearchName = OpenApiUtil.getEncodeParam(savedsearchName);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteSavedSearch',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/savedsearches/${savedsearchName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model GetLogStoreResponse = {
  headers: map[string]string(name='headers'),
  body: Logstore  
}

async function getLogStore(project: string, logstore: string): GetLogStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLogStoreWithOptions(project, logstore, headers, runtime);
}

async function getLogStoreWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLogStoreResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLogStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetProjectResponse = {
  headers: map[string]string(name='headers'),
  body: Project  
}

async function getProject(project: string): GetProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProjectWithOptions(project, headers, runtime);
}

async function getProjectWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetProjectResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetSavedSearchResponse = {
  headers: map[string]string(name='headers'),
  body: SavedSearch  
}

async function getSavedSearch(project: string, savedsearchName: string): GetSavedSearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSavedSearchWithOptions(project, savedsearchName, headers, runtime);
}

async function getSavedSearchWithOptions(project: string, savedsearchName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetSavedSearchResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  savedsearchName = OpenApiUtil.getEncodeParam(savedsearchName);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetSavedSearch',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/savedsearches/${savedsearchName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
  body: [
    ConsumerGroup
  ](name='body'),
}

async function listConsumerGroup(project: string, logstore: string): ListConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConsumerGroupWithOptions(project, logstore, headers, runtime);
}

async function listConsumerGroupWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListConsumerGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListConsumerGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

model ListLogStoresRequest {
  logstoreName?: string(name='logstoreName'),
  offset?: int32(name='offset'),
  size?: int32(name='size'),
  telemetryType?: string(name='telemetryType'),
}

model ListLogStoresResponseBody = {
  logstores?: [ string ](name='logstores'),
  total?: int32(name='total'),
}

model ListLogStoresResponse = {
  headers: map[string]string(name='headers'),
  body: ListLogStoresResponseBody(name='body'),
}

async function listLogStores(project: string, request: ListLogStoresRequest): ListLogStoresResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLogStoresWithOptions(project, request, headers, runtime);
}

async function listLogStoresWithOptions(project: string, request: ListLogStoresRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLogStoresResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any= {};
  if (!Util.isUnset(request.logstoreName)) {
    query['logstoreName'] = request.logstoreName;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.telemetryType)) {
    query['telemetryType'] = request.telemetryType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLogStores',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListProjectRequest {
  offset?: int32(name='offset'),
  projectName?: string(name='projectName'),
  size?: int32(name='size'),
}

model ListProjectResponseBody = {
  count?: long(name='count'),
  projects?: [
    Project
  ](name='projects'),
  total?: long(name='total'),
}

model ListProjectResponse = {
  headers: map[string]string(name='headers'),
  body: ListProjectResponseBody(name='body'),
}

async function listProject(request: ListProjectRequest): ListProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProjectWithOptions(request, headers, runtime);
}

async function listProjectWithOptions(request: ListProjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProjectResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.projectName)) {
    query['projectName'] = request.projectName;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListSavedSearchRequest {
  offset?: int32(name='offset'),
  size?: int32(name='size'),
}

model ListSavedSearchResponseBody = {
  count?: int32(name='count'),
  savedsearchItems?: [
    SavedSearch
  ](name='savedsearchItems'),
  total?: int32(name='total'),
}

model ListSavedSearchResponse = {
  headers: map[string]string(name='headers'),
  body: ListSavedSearchResponseBody(name='body'),
}

async function listSavedSearch(project: string, request: ListSavedSearchRequest): ListSavedSearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSavedSearchWithOptions(project, request, headers, runtime);
}

async function listSavedSearchWithOptions(project: string, request: ListSavedSearchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSavedSearchResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any= {};
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSavedSearch',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/savedsearches`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model UpdateConsumerGroupRequest {
  order?: boolean(name='order'),
  timeout?: int32(name='timeout'),
}

model UpdateConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
}

async function updateConsumerGroup(project: string, logstore: string, consumerGroup: string, request: UpdateConsumerGroupRequest): UpdateConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateConsumerGroupWithOptions(project, logstore, consumerGroup, request, headers, runtime);
}

async function updateConsumerGroupWithOptions(project: string, logstore: string, consumerGroup: string, request: UpdateConsumerGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateConsumerGroupResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  consumerGroup = OpenApiUtil.getEncodeParam(consumerGroup);
  var body : map[string]any= {};
  if (!Util.isUnset(request.order)) {
    body['order'] = request.order;
  }
  if (!Util.isUnset(request.timeout)) {
    body['timeout'] = request.timeout;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateConsumerGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups/${consumerGroup}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model UpdateLogStoreRequest {
  appendMeta?: boolean(name='appendMeta'),
  autoSplit?: boolean(name='autoSplit'),
  enableTracking?: boolean(name='enable_tracking'),
  encryptConf?: EncryptConf(name='encrypt_conf'),
  logstoreName?: string(name='logstoreName'),
  maxSplitShard?: int32(name='maxSplitShard'),
  shardCount?: int32(name='shardCount'),
  ttl?: int32(name='ttl'),
}

model UpdateLogStoreShrinkRequest {
  appendMeta?: boolean(name='appendMeta'),
  autoSplit?: boolean(name='autoSplit'),
  enableTracking?: boolean(name='enable_tracking'),
  encryptConfShrink?: string(name='encrypt_conf'),
  logstoreName?: string(name='logstoreName'),
  maxSplitShard?: int32(name='maxSplitShard'),
  shardCount?: int32(name='shardCount'),
  ttl?: int32(name='ttl'),
}

model UpdateLogStoreResponse = {
  headers: map[string]string(name='headers'),
}

async function updateLogStore(project: string, logstore: string, request: UpdateLogStoreRequest): UpdateLogStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogStoreWithOptions(project, logstore, request, headers, runtime);
}

async function updateLogStoreWithOptions(project: string, logstore: string, tmpReq: UpdateLogStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogStoreResponse {
  Util.validateModel(tmpReq);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  logstore = OpenApiUtil.getEncodeParam(logstore);
  var request = new UpdateLogStoreShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.encryptConf)) {
    request.encryptConfShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.encryptConf, 'encrypt_conf', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.appendMeta)) {
    body['appendMeta'] = request.appendMeta;
  }
  if (!Util.isUnset(request.autoSplit)) {
    body['autoSplit'] = request.autoSplit;
  }
  if (!Util.isUnset(request.enableTracking)) {
    body['enable_tracking'] = request.enableTracking;
  }
  if (!Util.isUnset(request.encryptConfShrink)) {
    body['encrypt_conf'] = request.encryptConfShrink;
  }
  if (!Util.isUnset(request.logstoreName)) {
    body['logstoreName'] = request.logstoreName;
  }
  if (!Util.isUnset(request.maxSplitShard)) {
    body['maxSplitShard'] = request.maxSplitShard;
  }
  if (!Util.isUnset(request.shardCount)) {
    body['shardCount'] = request.shardCount;
  }
  if (!Util.isUnset(request.ttl)) {
    body['ttl'] = request.ttl;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model UpdateProjectRequest {
  description?: string(name='description', description='Project description'),
}

model UpdateProjectResponse = {
  headers: map[string]string(name='headers'),
}

async function updateProject(project: string, request: UpdateProjectRequest): UpdateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProjectWithOptions(project, request, headers, runtime);
}

async function updateProjectWithOptions(project: string, request: UpdateProjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProjectResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

