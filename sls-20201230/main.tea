/**
 *
 */
import Util;
import SPI;
import GatewayClient;
import OpenApi;
import OpenApiUtil;

extends OpenApi;

type @client = SPI

init(config: OpenApi.Config){
  super(config);
  @client = new GatewayClient();
  @spi = @client;
  @signatureAlgorithm = 'v2';
  @endpointRule = 'central';
  }

model Alert {
  configuration?: AlertConfiguration(name='configuration'),
  createTime?: long(name='createTime'),
  description?: string(name='description', example='Alert Desc'),
  displayName?: string(name='displayName', example='alertNameExample'),
  lastModifiedTime?: long(name='lastModifiedTime'),
  name?: string(name='name', example='alert-123456'),
  schedule?: Schedule(name='schedule'),
  status?: string(name='status', example='ENABLED/DISABLED'),
}

model AlertConfiguration {
  annotations?: [
    AlertTag
  ](name='annotations'),
  autoAnnotation?: boolean(name='autoAnnotation', example='false'),
  conditionConfiguration?: ConditionConfiguration(name='conditionConfiguration'),
  dashboard?: string(name='dashboard', example='dasnboardExample'),
  groupConfiguration?: GroupConfiguration(name='groupConfiguration'),
  joinConfigurations?: [
    JoinConfiguration
  ](name='joinConfigurations'),
  labels?: [
    AlertTag
  ](name='labels'),
  muteUntil?: long(name='muteUntil', example='1698907508'),
  noDataFire?: boolean(name='noDataFire', example='false'),
  noDataSeverity?: int32(name='noDataSeverity', example='6'),
  policyConfiguration?: PolicyConfiguration(name='policyConfiguration'),
  queryList?: [
    AlertQuery
  ](name='queryList'),
  sendResolved?: boolean(name='sendResolved', example='false'),
  severityConfigurations?: [
    SeverityConfiguration
  ](name='severityConfigurations'),
  sinkAlerthub?: SinkAlerthubConfiguration(name='sinkAlerthub'),
  sinkCms?: SinkCmsConfiguration(name='sinkCms'),
  sinkEventStore?: SinkEventStoreConfiguration(name='sinkEventStore'),
  tags?: [ string ](name='tags'),
  templateConfiguration?: TemplateConfiguration(name='templateConfiguration'),
  threshold?: int32(name='threshold', example='1'),
  type?: string(name='type', example='default'),
  version?: string(name='version', example='2.0'),
}

model AlertQuery {
  chartTitle?: string(name='chartTitle', example='chartExmaple'),
  dashboardId?: string(name='dashboardId', example='dashboardExample'),
  end?: string(name='end', example='now'),
  powerSqlMode?: string(name='powerSqlMode', example='auto'),
  project?: string(name='project', example='projectExample'),
  query?: string(name='query', example='* | select *'),
  region?: string(name='region', example='cn-hangzhou'),
  roleArn?: string(name='roleArn'),
  start?: string(name='start', example='-5m'),
  store?: string(name='store', example='store Example'),
  storeType?: string(name='storeType', example='log'),
  timeSpanType?: string(name='timeSpanType', example='Relative'),
  ui?: string(name='ui'),
}

model AlertTag {
  key?: string(name='key', example='title'),
  value?: string(name='value', example='example value'),
}

model ConditionConfiguration {
  condition?: string(name='condition', example='cnt > 100'),
  countCondition?: string(name='countCondition', example='__count__ > 5'),
}

model ConsumerGroup {
  name?: string(name='name', example='test-group'),
  order?: boolean(name='order', example='false'),
  timeout?: int32(name='timeout', example='300'),
}

model CreateAlertReq {
  configuration?: AlertConfiguration(name='configuration'),
  description?: string(name='description', example='Alert Desc'),
  displayName?: string(name='displayName', example='alertNameExample'),
  name?: string(name='name', example='alertExample'),
  schedule?: Schedule(name='schedule'),
}

model CreateOSSExportReq {
  configuration?: OSSExportConfiguration(name='configuration'),
  description?: string(name='description', example='This is a oss export'),
  displayName?: string(name='displayName', example='This is a oss export'),
  name?: string(name='name', example='test-oss-export'),
}

model CreateOSSIngestionReq {
  configuration?: OSSIngestionConfiguration(name='configuration'),
  description?: string(name='description', example='oss ingestion'),
  displayName?: string(name='displayName', example='oss ingestion'),
  name?: string(name='name', example='test-oss-ingestion'),
  schedule?: Schedule(name='schedule'),
}

model ETL {
  configuration?: ETLConfiguration(name='configuration'),
  createTime?: long(name='createTime'),
  description?: string(name='description', example='ETL'),
  displayName?: string(name='displayName', example='ETL'),
  lastModifiedTime?: long(name='lastModifiedTime'),
  name?: string(name='name', example='ETL'),
  scheduleId?: string(name='scheduleId'),
  status?: string(name='status', example='RUNNING'),
}

model ETLConfiguration {
  accessKeyId?: string(name='accessKeyId', deprecated='true'),
  accessKeySecret?: string(name='accessKeySecret', deprecated='true'),
  fromTime?: long(name='fromTime', example='0'),
  logstore?: string(name='logstore'),
  parameters?: map[string]any(name='parameters'),
  roleArn?: string(name='roleArn'),
  script?: string(name='script'),
  sinks?: [
    ETLConfigurationSink
  ](name='sinks'),
  toTime?: long(name='toTime', example='0'),
}

model ETLConfigurationSink {
  accessKeyId?: string(name='accessKeyId', deprecated='true'),
  accessKeySecret?: string(name='accessKeySecret', deprecated='true'),
  endpoint?: string(name='endpoint'),
  logstore?: string(name='logstore'),
  name?: string(name='name'),
  project?: string(name='project'),
  roleArn?: string(name='roleArn'),
}

model EncryptConf {
  enable?: boolean(name='enable'),
  encryptType?: string(name='encrypt_type', example='default'),
  userCmkInfo?: EncryptUserCmkConf(name='user_cmk_info'),
}

model EncryptUserCmkConf {
  arn?: string(name='arn'),
  cmkKeyId?: string(name='cmk_key_id'),
  regionId?: string(name='region_id'),
}

model GroupConfiguration {
  fields?: [ string ](name='fields'),
  type?: string(name='type', example='custom'),
}

model Histogram {
  count?: long(name='count'),
  from?: int32(name='from'),
  progress?: string(name='progress'),
  to?: int32(name='to'),
}

model JoinConfiguration {
  condition?: string(name='condition', example='$0.id == $1.id'),
  type?: string(name='type', example='left_join'),
}

model LogContent {
  key?: string(name='Key', example='key-test'),
  value?: string(name='Value', example='value-test'),
}

model LogGroup {
  logTags?: [
    LogTag
  ](name='LogTags'),
  logs?: [
    LogItem
  ](name='Logs'),
  source?: string(name='Source', example='192.1.1.1'),
  topic?: string(name='Topic', example='topic-test'),
}

model LogItem {
  contents?: [
    LogContent
  ](name='Contents'),
  time?: int32(name='Time', example='1690254376'),
}

model LogTag {
  key?: string(name='Key', example='key-test'),
  value?: string(name='Value', example='value-test'),
}

model LogtailConfig {
  configName?: string(name='configName', example='test-config'),
  createTime?: long(name='createTime', example='1655176807'),
  inputDetail?: map[string]any(name='inputDetail'),
  inputType?: string(name='inputType', example='file'),
  lastModifyTime?: long(name='lastModifyTime', example='1655176807'),
  logSample?: string(name='logSample', example='2022-06-14 11:13:29.796 | DEBUG    | __main__:<module>:1 - hello world'),
  outputDetail?: {
    endpoint?: string(name='endpoint', example='cn-hangzhou-intranet.log.aliyuncs.com'),
    logstoreName?: string(name='logstoreName', example='test-logstore'),
    region?: string(name='region', example='cn-hangzhou'),
  }(name='outputDetail'),
  outputType?: string(name='outputType', example='LogService'),
}

model LogtailPipelineConfig {
  aggregators?: [  map[string]any ](name='aggregators'),
  configName?: string(name='configName', example='test-config'),
  createTime?: long(name='createTime', example='1655176807'),
  flushers?: [  map[string]any ](name='flushers'),
  global?: map[string]any(name='global'),
  inputs?: [  map[string]any ](name='inputs'),
  lastModifyTime?: long(name='lastModifyTime', example='1655176807'),
  logSample?: string(name='logSample', example='127.0.0.1 - - [10/Jun/2022:12:36:49 +0800] "GET /index.html HTTP/1.1" 200'),
  processors?: [  map[string]any ](name='processors'),
}

model MLDataParam {
  annotationdataId?: string(name='annotationdataId', example='dc74b0f569126bb310e1ba6454c351ac'),
  annotations?: map[string]MLDataParamAnnotationsValue(name='annotations'),
  config?: map[string]string(name='config'),
  createTime?: long(name='createTime', example='1695094335'),
  dataHash?: string(name='dataHash', example='59db060bd89468245d76416a68a510ac'),
  datasetId?: string(name='datasetId', example='a9bd488f6dd42d294495fb780858e83d'),
  lastModifyTime?: long(name='lastModifyTime', example='1695094335'),
  predictions?: map[string]MLDataParamPredictionsValue(name='predictions'),
  value?: string(name='value', example='xxx/xxx/xxx/'),
  valueType?: string(name='valueType', example='oss'),
}

model MLDataSetParam {
  createBy?: string(name='createBy', example='sls-console'),
  createTime?: long(name='createTime', example='1695090077'),
  dataType?: string(name='dataType', example='Metric'),
  datasetId?: string(name='datasetId', example='d9bd488f6dd42d294495fb780858e83d'),
  description?: string(name='description', example='数据集A'),
  labelId?: string(name='labelId', example='a191ae4ca615b0ccb93c211fc8a998af'),
  lastModifyTime?: long(name='lastModifyTime', example='1695090077'),
  name?: string(name='name', example='sls_builtin_dataset_metric.shapeclassification.anomalydetection'),
  settingType?: string(name='settingType', example='Metric.ShapeClassification.AnomalyDetection'),
}

model MLLabelParam {
  createTime?: long(name='createTime', example='1695090077'),
  description?: string(name='description', example='默认表'),
  labelId?: string(name='labelId', example='abbd488f6dd42d294495fb780858e83d'),
  lastModifyTime?: long(name='lastModifyTime', example='1695090077'),
  name?: string(name='name', example='标签表'),
  settings?: [ 
    {
      config?: string(name='config', example='""'),
      mode?: string(name='mode', example='builtin'),
      type?: string(name='type', example='Trace.RCA'),
      version?: string(name='version', example='0.01'),
    }
  ](name='settings'),
  type?: string(name='type', example='xxx'),
}

model MLServiceAnalysisParam {
  input?: [ map[string]string ](name='input'),
  parameter?: map[string]string(name='parameter'),
}

model MLServiceParam {
  description?: string(name='description', example='某某服务'),
  model?: {
    modelResourceId?: string(name='modelResourceId', example='xxxx'),
    modelResourceType?: string(name='modelResourceType', example='xxx_type'),
  }(name='model'),
  name?: string(name='name', example='service_name'),
  resource?: {
    cpuLimit?: int32(name='cpuLimit', example='2'),
    gpu?: int32(name='gpu', example='20'),
    memoryLimit?: int32(name='memoryLimit', example='64'),
    replica?: int32(name='replica', example='2'),
  }(name='resource'),
  serviceType?: string(name='serviceType', example='sls_builtin'),
  status?: string(name='status', example='running'),
  updateTimestamp?: long(name='updateTimestamp', example='1695090077'),
}

model MaxComputeExport {
  configuration?: MaxComputeExportConfiguration(name='configuration'),
  createTime?: long(name='createTime'),
  description?: string(name='description', example='MaxComputeExport'),
  displayName?: string(name='displayName', example='MaxComputeExport'),
  lastModifiedTime?: long(name='lastModifiedTime'),
  name?: string(name='name', example='MaxComputeExport'),
  status?: string(name='status', example='RUNNING'),
}

model MaxComputeExportConfiguration {
  fromTime?: long(name='fromTime'),
  logstore?: string(name='logstore'),
  roleArn?: string(name='roleArn'),
  sink?: MaxComputeExportConfigurationSink(name='sink'),
  toTime?: long(name='toTime'),
}

model MaxComputeExportConfigurationSink {
  fields?: [ string ](name='fields'),
  odpsAccessKeyId?: string(name='odpsAccessKeyId', deprecated='true'),
  odpsAccessSecret?: string(name='odpsAccessSecret', deprecated='true'),
  odpsEndpoint?: string(name='odpsEndpoint', example='http://xxxxxxxx'),
  odpsProject?: string(name='odpsProject', example='demo_project'),
  odpsRolearn?: string(name='odpsRolearn', example='acs:ram::xxxxxxx'),
  odpsTable?: string(name='odpsTable', example='demo_table'),
  odpsTunnelEndpoint?: string(name='odpsTunnelEndpoint'),
  partitionColumn?: [ string ](name='partitionColumn'),
  partitionTimeFormat?: string(name='partitionTimeFormat', example='%Y_%m_%d'),
  timeZone?: string(name='timeZone', example='+0800'),
}

model OSSExport {
  configuration?: OSSExportConfiguration(name='configuration'),
  createTime?: long(name='createTime', example='123456789'),
  description?: string(name='description', example='This is a oss export'),
  displayName?: string(name='displayName', example='This is a oss export'),
  lastModifiedTime?: long(name='lastModifiedTime', example='123456789'),
  name?: string(name='name', example='myossexportjob'),
  status?: string(name='status', example='RUNNING'),
}

model OSSExportConfiguration {
  fromTime?: long(name='fromTime', example='123456789'),
  logstore?: string(name='logstore'),
  roleArn?: string(name='roleArn'),
  sink?: {
    bucket?: string(name='bucket'),
    bufferInterval?: long(name='bufferInterval', example='300'),
    bufferSize?: long(name='bufferSize', example='256'),
    compressionType?: string(name='compressionType', example='snappy/gizp/zstd/none'),
    contentDetail?: map[string]any(name='contentDetail'),
    contentType?: string(name='contentType', example='json/parquet/csv/orc'),
    delaySec?: long(name='delaySec', example='123'),
    endpoint?: string(name='endpoint', example='http://xxxxxxxx'),
    pathFormat?: string(name='pathFormat', example='%Y_%m_%d/good/bad'),
    pathFormatType?: string(name='pathFormatType', example='only support time'),
    prefix?: string(name='prefix', example='prefixxxx/'),
    roleArn?: string(name='roleArn', example='acs:ram::xxxxxxx'),
    suffix?: string(name='suffix', example='.json'),
    timeZone?: string(name='timeZone', example='+0800'),
  }(name='sink'),
  toTime?: long(name='toTime', example='123456789'),
}

model OSSIngestion {
  configuration?: OSSIngestionConfiguration(name='configuration'),
  createTime?: long(name='createTime'),
  description?: string(name='description', example='oss ingestion'),
  displayName?: string(name='displayName', example='oss ingestion'),
  lastModifiedTime?: long(name='lastModifiedTime'),
  name?: string(name='name', example='ingest-oss-123456'),
  schedule?: Schedule(name='schedule'),
  status?: string(name='status', example='RUNNING'),
}

model OSSIngestionConfiguration {
  logstore?: string(name='logstore'),
  source?: OSSIngestionConfigurationSource(name='source'),
}

model OSSIngestionConfigurationSource {
  bucket?: string(name='bucket', example='ossbucket'),
  compressionCodec?: string(name='compressionCodec', example='none,snappy,gzip'),
  encoding?: string(name='encoding', example='UTF-8'),
  endTime?: long(name='endTime'),
  endpoint?: string(name='endpoint', example='oss-cn-hangzhou.aliyuncs.com'),
  format?: map[string]any(name='format'),
  interval?: string(name='interval', example='never'),
  pattern?: string(name='pattern'),
  prefix?: string(name='prefix'),
  restoreObjectEnabled?: boolean(name='restoreObjectEnabled'),
  roleARN?: string(name='roleARN'),
  startTime?: long(name='startTime'),
  timeField?: string(name='timeField'),
  timeFormat?: string(name='timeFormat'),
  timePattern?: string(name='timePattern'),
  timeZone?: string(name='timeZone'),
  useMetaIndex?: boolean(name='useMetaIndex'),
}

model PolicyConfiguration {
  actionPolicyId?: string(name='actionPolicyId', example='example_action_policy'),
  alertPolicyId?: string(name='alertPolicyId', example='sls.builtin.dynamic'),
  repeatInterval?: string(name='repeatInterval', example='10m'),
}

model SavedSearch {
  displayName?: string(name='displayName'),
  logstore?: string(name='logstore'),
  savedsearchName?: string(name='savedsearchName'),
  searchQuery?: string(name='searchQuery'),
  topic?: string(name='topic'),
}

model Schedule {
  cronExpression?: string(name='cronExpression', example='0/5 * * * *'),
  delay?: int32(name='delay', example='4'),
  interval?: string(name='interval', example='1m/1h'),
  runImmediately?: boolean(name='runImmediately', example='false'),
  timeZone?: string(name='timeZone', example='"+0800"'),
  type?: string(name='type', example='FixedRate、Cron'),
}

model ScheduledSQL {
  configuration?: ScheduledSQLConfiguration(name='configuration'),
  createTime?: long(name='createTime'),
  description?: string(name='description', example='This is a scheduled sql job'),
  displayName?: string(name='displayName', example='This is a scheduled sql job'),
  lastModifiedTime?: long(name='lastModifiedTime'),
  name?: string(name='name', example='test-scheduled-sql'),
  schedule?: Schedule(name='schedule'),
  scheduleId?: string(name='scheduleId'),
}

model ScheduledSQLConfiguration {
  dataFormat?: string(name='dataFormat'),
  destEndpoint?: string(name='destEndpoint'),
  destLogstore?: string(name='destLogstore'),
  destProject?: string(name='destProject'),
  destRoleArn?: string(name='destRoleArn'),
  fromTime?: long(name='fromTime'),
  fromTimeExpr?: string(name='fromTimeExpr'),
  maxRetries?: long(name='maxRetries'),
  maxRunTimeInSeconds?: long(name='maxRunTimeInSeconds'),
  parameters?: map[string]any(name='parameters'),
  resourcePool?: string(name='resourcePool'),
  roleArn?: string(name='roleArn'),
  script?: string(name='script'),
  sourceLogstore?: string(name='sourceLogstore'),
  sqlType?: string(name='sqlType'),
  toTime?: long(name='toTime'),
  toTimeExpr?: string(name='toTimeExpr'),
}

model SeverityConfiguration {
  evalCondition?: ConditionConfiguration(name='evalCondition'),
  severity?: int32(name='severity', example='8'),
}

model SinkAlerthubConfiguration {
  enabled?: boolean(name='enabled', example='true'),
}

model SinkCmsConfiguration {
  enabled?: boolean(name='enabled', example='true'),
}

model SinkEventStoreConfiguration {
  enabled?: boolean(name='enabled', example='true'),
  endpoint?: string(name='endpoint', example='cn-shanghai-intranet.log.aliyuncs.com'),
  eventStore?: string(name='eventStore', example='exampleStore'),
  project?: string(name='project', example='exampleProject'),
  roleArn?: string(name='roleArn', example='acs:ram::123456789:role/aliyunlogetlrole'),
}

model StoreViewStore {
  project?: string(name='project'),
  query?: string(name='query'),
  storeName?: string(name='storeName'),
}

model TemplateConfiguration {
  aonotations?: map[string]any(name='aonotations'),
  id?: string(name='id', example='sls.app.ack.ip.not_enough'),
  lang?: string(name='lang', example='cn'),
  tokens?: map[string]any(name='tokens'),
  type?: string(name='type', example='sys'),
  version?: string(name='version', example='1'),
}

model Ticket {
  callerUid?: long(name='callerUid', example='1000000000'),
  createDate?: string(name='createDate', example='2023-09-06 14:57:07'),
  expirationTime?: long(name='expirationTime', example='100'),
  expireDate?: string(name='expireDate', example='2023-09-06 14:58:07'),
  extra?: string(name='extra', example='{"xx":"yy"}'),
  name?: string(name='name', example='测试'),
  number?: int32(name='number', example='1'),
  sharingTo?: string(name='sharingTo', example='{"type":"aliyun","ids":[1,2]}'),
  ticket?: string(name='ticket', example='xxxxx'),
  ticketId?: string(name='ticketId', example='xxxxx'),
  usedNumber?: int32(name='usedNumber', example='1'),
  valid?: boolean(name='valid', example='false'),
}

model UpdateAlertReq {
  configuration?: AlertConfiguration(name='configuration'),
  description?: string(name='description', example='Alert Desc'),
  displayName?: string(name='displayName', example='alertNameExample'),
  schedule?: Schedule(name='schedule'),
}

model UpdateOSSExportReq {
  configuration?: OSSExportConfiguration(name='configuration'),
  description?: string(name='description', example='This is a oss export'),
  displayName?: string(name='displayName', example='This is a oss export'),
}

model UpdateOSSIngestionReq {
  configuration?: OSSIngestionConfiguration(name='configuration'),
  description?: string(name='description', example='oss ingestion'),
  displayName?: string(name='displayName', example='oss ingestion'),
  schedule?: Schedule(name='schedule'),
}

model Chart {
  action?: map[string]any(name='action'),
  display?: map[string]any(name='display'),
  search?: map[string]any(name='search'),
  title?: string(name='title', example='my-chart'),
  type?: string(name='type', example='linepro'),
}

model Dashboard {
  attribute?: map[string]string(name='attribute'),
  charts?: [
    Chart
  ](name='charts'),
  dashboardName?: string(name='dashboardName', example='dashboard-1609294922657-434834'),
  description?: string(name='description', example='这是一个仪表盘。'),
  displayName?: string(name='displayName', example='test-alert'),
}

model EtlJob {
  enable?: boolean(name='enable', example='true'),
  etlJobName?: string(name='etlJobName'),
  functionConfig?: {
    accountId?: string(name='accountId'),
    endpoint?: string(name='endpoint'),
    functionName?: string(name='functionName', example='hello-wrold'),
    functionProvider?: string(name='functionProvider', example='FunctionCompute'),
    regionName?: string(name='regionName', example='cn-hangzhou'),
    roleArn?: string(name='roleArn'),
    serviceName?: string(name='serviceName', example='my-service'),
  }(name='functionConfig'),
  functionParameter?: map[string]any(name='functionParameter'),
  logConfig?: {
    endpoint?: string(name='endpoint'),
    logstoreName?: string(name='logstoreName'),
    projectName?: string(name='projectName'),
  }(name='logConfig'),
  sourceConfig?: {
    logstoreName?: string(name='logstoreName', example='my-logstore'),
  }(name='sourceConfig'),
  triggerConfig?: {
    maxRetryTime?: int32(name='maxRetryTime'),
    roleArn?: string(name='roleArn'),
    startingPosition?: string(name='startingPosition', example='at-unixtime'),
    startingUnixtime?: long(name='startingUnixtime', example='当 strtingPosition 为 at-unixtime 时生效'),
    triggerInterval?: int32(name='triggerInterval'),
  }(name='triggerConfig'),
}

model EtlMeta {
  enable?: boolean(name='enable'),
  etlMetaKey?: string(name='etlMetaKey'),
  etlMetaName?: string(name='etlMetaName'),
  etlMetaTag?: string(name='etlMetaTag'),
  etlMetaValue?: string(name='etlMetaValue'),
}

model ExternalStore {
  externalStoreName?: string(name='externalStoreName', example='rds_store'),
  parameter?: map[string]any(name='parameter'),
  storeType?: string(name='storeType', example='rds-vpc'),
}

model Index {
  keys?: map[string]IndexKeysValue(name='keys'),
  lastModifyTime?: long(name='lastModifyTime', example='1622186280'),
  line?: {
    caseSensitive?: boolean(name='caseSensitive', example='true'),
    chn?: boolean(name='chn', example='true'),
    excludeKeys?: [ string ](name='exclude_keys'),
    includeKeys?: [ string ](name='include_keys'),
    token?: [ string ](name='token'),
  }(name='line'),
  logReduce?: boolean(name='log_reduce', example='true'),
  logReduceBlackList?: [ string ](name='log_reduce_black_list'),
  logReduceWhiteList?: [ string ](name='log_reduce_white_list'),
  maxTextLen?: int32(name='max_text_len', example='2048'),
  ttl?: int32(name='ttl', example='30'),
}

model Logging {
  loggingDetails?: [ 
    {
      logstore?: string(name='logstore', example='my-logstore'),
      type?: string(name='type', example='consumergroup_log'),
    }
  ](name='loggingDetails'),
  loggingProject?: string(name='loggingProject', example='my-project'),
}

model Logstore {
  appendMeta?: boolean(name='appendMeta', example='true'),
  autoSplit?: boolean(name='autoSplit', example='true'),
  createTime?: int32(name='createTime'),
  enableTracking?: boolean(name='enable_tracking', example='false'),
  encryptConf?: EncryptConf(name='encrypt_conf'),
  hotTtl?: int32(name='hot_ttl'),
  infrequentAccessTTL?: int32(name='infrequentAccessTTL', example='30'),
  lastModifyTime?: int32(name='lastModifyTime'),
  logstoreName?: string(name='logstoreName', example='my-logstore'),
  maxSplitShard?: int32(name='maxSplitShard', example='2'),
  mode?: string(name='mode', example='standard'),
  productType?: string(name='productType'),
  shardCount?: int32(name='shardCount', example='2'),
  telemetryType?: string(name='telemetryType'),
  ttl?: int32(name='ttl', example='30'),
}

model Machine {
  ip?: string(name='ip', example='192.168.x.x'),
  lastHeartbeatTime?: long(name='lastHeartbeatTime', example='1657509674'),
  machineUniqueid?: string(name='machine-uniqueid', example='3B70F4F1-80F7-46C4-A6C1-100D66C***47'),
  userdefinedId?: string(name='userdefined-id', example='test'),
}

model MachineGroup {
  groupAttribute?: {
    externalName?: string(name='externalName', example='test-group'),
    groupTopic?: string(name='groupTopic', example='test-topic'),
  }(name='groupAttribute'),
  groupName?: string(name='groupName', example='test-group'),
  groupType?: string(name='groupType'),
  machineIdentifyType?: string(name='machineIdentifyType', example='ip'),
  machineList?: [ string ](name='machineList'),
}

model Project {
  createTime?: string(name='createTime'),
  description?: string(name='description'),
  lastModifyTime?: string(name='lastModifyTime'),
  owner?: string(name='owner'),
  projectName?: string(name='projectName'),
  region?: string(name='region'),
  resourceGroupId?: string(name='resourceGroupId'),
  status?: string(name='status'),
}

model ServiceStatus {
  enabled?: boolean(name='enabled', example='false'),
  status?: string(name='status', example='NotExist'),
}

model Shard {
  createTime?: int32(name='createTime', example='1453949705'),
  exclusiveEndKey?: string(name='exclusiveEndKey', example='8000000000000000000000000000000'),
  inclusiveBeginKey?: string(name='inclusiveBeginKey', example='00000000000000000000000000000000'),
  shardID?: int32(name='shardID', example='0'),
  status?: string(name='status', example='readwrite'),
}

model MLDataParamAnnotationsValue = {
  annotatedBy?: string(name='annotatedBy', example='xxxx'),
  updateTime?: long(name='updateTime', example='1694761550'),
  results?: [ map[string]string ](name='results'),
}

model MLDataParamPredictionsValue = {
  annotatedBy?: string(name='annotatedBy', example='xxx'),
  updateTime?: long(name='updateTime', example='1694761550'),
  results?: [ map[string]string ](name='results'),
}

model IndexKeysValue = {
  chn?: boolean(name='chn', example='true'),
  caseSensitive?: boolean(name='caseSensitive', example='true'),
  token?: [ string ](name='token'),
  alias?: string(name='alias', example='myAlias'),
  type?: string(name='type', example='text'),
  docValue?: boolean(name='doc_value', example='true'),
}

model KeysValue = {
  caseSensitive?: boolean(name='caseSensitive', description='Specifies whether to enable case sensitivity. This parameter is required only when **type** is set to **text**. Valid values:

*   true
*   false (default)', example='false'),
  chn?: boolean(name='chn', description='Specifies whether to include Chinese characters. This parameter is required only when **type** is set to **text**. Valid values:

*   true
*   false (default)', example='false'),
  type?: string(name='type', description='The data type of the field value. Valid values: text, json, double, and long.', example='text'),
  alias?: string(name='alias', description='The alias of the field.', example='myAlias'),
  token?: [ string ](name='token', description='The delimiters that are used to split text.'),
  docValue?: boolean(name='doc_value', description='Specifies whether to turn on Enable Analytics for the field.', example='false'),
}

model ApplyConfigToMachineGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ApplyConfigToMachineGroupResponse
 */
async function applyConfigToMachineGroupWithOptions(project: string, machineGroup: string, configName: string, headers: map[string]string, runtime: Util.RuntimeOptions): ApplyConfigToMachineGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ApplyConfigToMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}/configs/${configName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @return ApplyConfigToMachineGroupResponse
 */
async function applyConfigToMachineGroup(project: string, machineGroup: string, configName: string): ApplyConfigToMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return applyConfigToMachineGroupWithOptions(project, machineGroup, configName, headers, runtime);
}

model ChangeResourceGroupRequest {
  resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group.', example='rg-aek2i7nhaxifxey'),
  resourceId?: string(name='resourceId', description='The ID of the resource.', example='ali-test-project'),
  resourceType?: string(name='resourceType', description='The type of the resource. Only PROJECT is supported. Set the value to PROJECT.', example='PROJECT'),
}

model ChangeResourceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function changeResourceGroupWithOptions(project: string, request: ChangeResourceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ChangeResourceGroupResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceId)) {
    body['resourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['resourceType'] = request.resourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ChangeResourceGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/resourcegroup`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function changeResourceGroup(project: string, request: ChangeResourceGroupRequest): ChangeResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return changeResourceGroupWithOptions(project, request, headers, runtime);
}

model ConsumerGroupHeartBeatRequest {
  body?: [ int32 ](name='body', description='The IDs of shards whose data is being consumed.'),
  consumer?: string(name='consumer', description='The consumer.', example='consumer_1'),
}

model ConsumerGroupHeartBeatResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [ int32 ](name='body'),
}

/**
  * ### Usage notes
  * *   Connections between consumers and servers are established by sending heartbeats at regular intervals. If a server does not receive heartbeats from a consumer on schedule, the server deletes the consumer.
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request ConsumerGroupHeartBeatRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ConsumerGroupHeartBeatResponse
 */
async function consumerGroupHeartBeatWithOptions(project: string, logstore: string, consumerGroup: string, request: ConsumerGroupHeartBeatRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ConsumerGroupHeartBeatResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.consumer)) {
    query['consumer'] = request.consumer;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ConsumerGroupHeartBeat',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups/${consumerGroup}?type=heartbeat`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * *   Connections between consumers and servers are established by sending heartbeats at regular intervals. If a server does not receive heartbeats from a consumer on schedule, the server deletes the consumer.
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request ConsumerGroupHeartBeatRequest
  * @return ConsumerGroupHeartBeatResponse
 */
async function consumerGroupHeartBeat(project: string, logstore: string, consumerGroup: string, request: ConsumerGroupHeartBeatRequest): ConsumerGroupHeartBeatResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return consumerGroupHeartBeatWithOptions(project, logstore, consumerGroup, request, headers, runtime);
}

model ConsumerGroupUpdateCheckPointRequest {
  body?: [ 
    {
      checkpoint?: string(name='checkpoint', example='MTUyNDE1NTM3OTM3MzkwODQ5Ng=='),
      shard?: int32(name='shard', description='Shard ID。', example='0'),
    }
  ](name='body', description='Shard ID。'),
  consumer?: string(name='consumer', example='consumer_1'),
  forceSuccess?: boolean(name='forceSuccess', example='False'),
}

model ConsumerGroupUpdateCheckPointResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function consumerGroupUpdateCheckPointWithOptions(project: string, logstore: string, consumerGroup: string, request: ConsumerGroupUpdateCheckPointRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ConsumerGroupUpdateCheckPointResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.consumer)) {
    query['consumer'] = request.consumer;
  }
  if (!Util.isUnset(request.forceSuccess)) {
    query['forceSuccess'] = request.forceSuccess;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ConsumerGroupUpdateCheckPoint',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups/${consumerGroup}?type=checkpoint`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function consumerGroupUpdateCheckPoint(project: string, logstore: string, consumerGroup: string, request: ConsumerGroupUpdateCheckPointRequest): ConsumerGroupUpdateCheckPointResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return consumerGroupUpdateCheckPointWithOptions(project, logstore, consumerGroup, request, headers, runtime);
}

model CreateAlertRequest {
  configuration?: AlertConfiguration(name='configuration'),
  description?: string(name='description'),
  displayName?: string(name='displayName'),
  name?: string(name='name'),
  schedule?: Schedule(name='schedule'),
}

model CreateAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function createAlertWithOptions(project: string, request: CreateAlertRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAlertResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.schedule)) {
    body['schedule'] = request.schedule;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAlert',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/alerts`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function createAlert(project: string, request: CreateAlertRequest): CreateAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAlertWithOptions(project, request, headers, runtime);
}

model CreateAnnotationDataSetRequest {
  body?: MLDataSetParam(name='body', description='The data structure of the request.'),
  datasetId?: string(name='datasetId', description='The unique identifier of the dataset.', example='cb8cc4eb51a85e823471cdb368fae9be'),
}

model CreateAnnotationDataSetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function createAnnotationDataSetWithOptions(request: CreateAnnotationDataSetRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAnnotationDataSetResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.datasetId)) {
    query['datasetId'] = request.datasetId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAnnotationDataSet',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationdataset`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function createAnnotationDataSet(request: CreateAnnotationDataSetRequest): CreateAnnotationDataSetResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAnnotationDataSetWithOptions(request, headers, runtime);
}

model CreateAnnotationLabelRequest {
  body?: MLLabelParam(name='body', description='The data structure of the request.'),
}

model CreateAnnotationLabelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function createAnnotationLabelWithOptions(request: CreateAnnotationLabelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAnnotationLabelResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAnnotationLabel',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationlabel`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function createAnnotationLabel(request: CreateAnnotationLabelRequest): CreateAnnotationLabelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAnnotationLabelWithOptions(request, headers, runtime);
}

model CreateConfigRequest {
  body?: LogtailConfig(name='body', description='The body of the request.'),
}

model CreateConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### [](#)Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](~~29009~~).
  * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Log Service](~~47664~~).
  * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](~~48984~~).
  * *   You can create up to 100 Logtail configurations in a project.
  * *   The Logtail configuration is planned out. For more information, see [Logtail configurations](~~29058~~).
  *
  * @param request CreateConfigRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateConfigResponse
 */
async function createConfigWithOptions(project: string, request: CreateConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateConfigResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateConfig',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/configs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### [](#)Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](~~29009~~).
  * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Log Service](~~47664~~).
  * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](~~48984~~).
  * *   You can create up to 100 Logtail configurations in a project.
  * *   The Logtail configuration is planned out. For more information, see [Logtail configurations](~~29058~~).
  *
  * @param request CreateConfigRequest
  * @return CreateConfigResponse
 */
async function createConfig(project: string, request: CreateConfigRequest): CreateConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createConfigWithOptions(project, request, headers, runtime);
}

model CreateConsumerGroupRequest {
  consumerGroup?: string(name='consumerGroup', description='The name of the consumer group. The name must be unique in a project.', example='consumerGroupX'),
  order?: boolean(name='order', description='Specifies whether to consume data in sequence. Valid values:

*   true

    *   In a shard, data is consumed in ascending order based on the value of the \\*\\*\\__tag\\_\\_:\\__receive_time\\_\\_\\*\\* field.
    *   If a shard is split, data in the original shard is consumed first. Then, data in the new shards is consumed at the same time.
    *   If shards are merged, data in the original shards is consumed first. Then, data in the new shard is consumed.

*   false Data in all shards is consumed at the same time. If a new shard is generated after a shard is split or after shards are merged, data in the new shard is immediately consumed.', example='true'),
  timeout?: int32(name='timeout', description='The timeout period. If the server does not receive heartbeats from a consumer within the timeout period, the server deletes the consumer. Unit: seconds.', example='300'),
}

model CreateConsumerGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   You can create up to 30 consumer groups for a Logstore.
  * *   Simple Log Service provides examples of both regular log consumption and consumer group-based log consumption by using Simple Log Service SDKs for Java. For more information, see [Consume log data](~~120035~~) and [Use consumer groups to consume data](~~28998~~).
  *
  * @param request CreateConsumerGroupRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateConsumerGroupResponse
 */
async function createConsumerGroupWithOptions(project: string, logstore: string, request: CreateConsumerGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateConsumerGroupResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.consumerGroup)) {
    body['consumerGroup'] = request.consumerGroup;
  }
  if (!Util.isUnset(request.order)) {
    body['order'] = request.order;
  }
  if (!Util.isUnset(request.timeout)) {
    body['timeout'] = request.timeout;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateConsumerGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   You can create up to 30 consumer groups for a Logstore.
  * *   Simple Log Service provides examples of both regular log consumption and consumer group-based log consumption by using Simple Log Service SDKs for Java. For more information, see [Consume log data](~~120035~~) and [Use consumer groups to consume data](~~28998~~).
  *
  * @param request CreateConsumerGroupRequest
  * @return CreateConsumerGroupResponse
 */
async function createConsumerGroup(project: string, logstore: string, request: CreateConsumerGroupRequest): CreateConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createConsumerGroupWithOptions(project, logstore, request, headers, runtime);
}

model CreateDashboardRequest {
  body?: Dashboard(name='body', description='The data structure of the dashboard.'),
}

model CreateDashboardResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### [](#)Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](~~29009~~).
  * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](~~47664~~).
  * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](~~48984~~).
  *
  * @param request CreateDashboardRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateDashboardResponse
 */
async function createDashboardWithOptions(project: string, request: CreateDashboardRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDashboardResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDashboard',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/dashboards`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### [](#)Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](~~29009~~).
  * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](~~47664~~).
  * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](~~48984~~).
  *
  * @param request CreateDashboardRequest
  * @return CreateDashboardResponse
 */
async function createDashboard(project: string, request: CreateDashboardRequest): CreateDashboardResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDashboardWithOptions(project, request, headers, runtime);
}

model CreateDomainRequest {
  domainName?: string(name='domainName', description='The domain name.', example='example.com'),
}

model CreateDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request CreateDomainRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateDomainResponse
 */
async function createDomainWithOptions(project: string, request: CreateDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDomainResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.domainName)) {
    body['domainName'] = request.domainName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDomain',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/domains`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request CreateDomainRequest
  * @return CreateDomainResponse
 */
async function createDomain(project: string, request: CreateDomainRequest): CreateDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDomainWithOptions(project, request, headers, runtime);
}

model CreateETLRequest {
  configuration?: ETLConfiguration(name='configuration'),
  description?: string(name='description', example='this is ETL'),
  displayName?: string(name='displayName', example='sls-test-etl'),
  name?: string(name='name', example='etl-123456'),
}

model CreateETLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function createETLWithOptions(project: string, request: CreateETLRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateETLResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateETL',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/etls`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function createETL(project: string, request: CreateETLRequest): CreateETLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createETLWithOptions(project, request, headers, runtime);
}

model CreateIndexRequest {
  keys?: map[string]KeysValue(name='keys', description='The configuration of field indexes. A field index is a key-value pair in which the key specifies the name of the field and the value specifies the index configuration of the field. You must specify this parameter, the line parameter, or both parameters. For more information, see Example.'),
  line?: {
    caseSensitive?: boolean(name='caseSensitive', description='Specifies whether to enable case sensitivity. Valid values:

*   true
*   false (default)', example='false'),
    chn?: boolean(name='chn', description='Specifies whether to include Chinese characters. Valid values:

*   true
*   false (default)', example='false'),
    excludeKeys?: [ string ](name='exclude_keys', description='The excluded fields. You cannot specify both include_keys and exclude_keys.'),
    includeKeys?: [ string ](name='include_keys', description='The included fields. You cannot specify both include_keys and exclude_keys.'),
    token?: [ string ](name='token', description='The delimiters. You can specify a delimiter to delimit the content of a field value. For more information about delimiters, see Example.'),
  }(name='line', description='The configuration of full-text indexes. You must specify this parameter, the keys parameter, or both parameters. For more information, see Example.'),
  logReduce?: boolean(name='log_reduce', description='Specifies whether to turn on LogReduce. After you turn on LogReduce, either the whitelist or blacklist takes effect.', example='false'),
  logReduceBlackList?: [ string ](name='log_reduce_black_list', description='The fields in the blacklist that you want to use to cluster logs.'),
  logReduceWhiteList?: [ string ](name='log_reduce_white_list', description='The fields in the whitelist that you want to use to cluster logs.'),
  maxTextLen?: int32(name='max_text_len', description='The maximum length of a field value that can be retained. Default value: 2048. Unit: bytes. The default value is equal to 2 KB. You can change the value of max_text_len. Valid values: 64 to 16384.', example='2048'),
  ttl?: int32(name='ttl', description='The retention period of logs. Unit: days. Valid values: 7, 30, and 90.', example='30'),
}

model CreateIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request CreateIndexRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateIndexResponse
 */
async function createIndexWithOptions(project: string, logstore: string, request: CreateIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateIndexResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.keys)) {
    body['keys'] = request.keys;
  }
  if (!Util.isUnset(request.line)) {
    body['line'] = request.line;
  }
  if (!Util.isUnset(request.logReduce)) {
    body['log_reduce'] = request.logReduce;
  }
  if (!Util.isUnset(request.logReduceBlackList)) {
    body['log_reduce_black_list'] = request.logReduceBlackList;
  }
  if (!Util.isUnset(request.logReduceWhiteList)) {
    body['log_reduce_white_list'] = request.logReduceWhiteList;
  }
  if (!Util.isUnset(request.maxTextLen)) {
    body['max_text_len'] = request.maxTextLen;
  }
  if (!Util.isUnset(request.ttl)) {
    body['ttl'] = request.ttl;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateIndex',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/index`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request CreateIndexRequest
  * @return CreateIndexResponse
 */
async function createIndex(project: string, logstore: string, request: CreateIndexRequest): CreateIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createIndexWithOptions(project, logstore, request, headers, runtime);
}

model CreateLogStoreRequest {
  appendMeta?: boolean(name='appendMeta', description='Specifies whether to record public IP addresses. Default value: false. Valid values:

*   true
*   false', example='false'),
  autoSplit?: boolean(name='autoSplit', description='Specifies whether to enable automatic sharding. Valid values:

*   true
*   false', example='true'),
  enableTracking?: boolean(name='enable_tracking', description='Specifies whether to enable the web tracking feature. Default value: false. Valid values:

*   true
*   false', example='false'),
  encryptConf?: EncryptConf(name='encrypt_conf', description='The data structure of the encryption configuration.'),
  hotTtl?: int32(name='hot_ttl', description='The retention period of data in the hot storage tier of the Logstore. Unit: days. You can specify a value that ranges from 30 to the value of ttl.

Hot data that is stored for longer than the period specified by hot_ttl is converted to cold data. For more information, see [Enable hot and cold-tiered storage for a Logstore](~~308645~~).', example='60'),
  infrequentAccessTTL?: int32(name='infrequentAccessTTL'),
  logstoreName?: string(name='logstoreName', description='The name of the Logstore. The name must meet the following requirements:

*   The name must be unique in a project.
*   The name can contain only lowercase letters, digits, hyphens (-), and underscores (\\_).
*   The name must start and end with a lowercase letter or a digit.
*   The name must be 3 to 63 characters in length.', example='my-logstore'),
  maxSplitShard?: int32(name='maxSplitShard', description='The maximum number of shards into which existing shards can be automatically split. Valid values: 1 to 64.

> If you set autoSplit to true, you must configure this parameter.', example='64'),
  mode?: string(name='mode', description='The type of the Logstore. Log Service provides the following types of Logstores: Standard Logstores and Query Logstores. Valid values:

*   **standard**: Standard Logstore. This type of Logstore supports the log analysis feature and is suitable for scenarios such as real-time monitoring and interactive analysis. You can also use this type of Logstore to build a comprehensive observability system.
*   **query**: Query Logstore. This type of Logstore supports high-performance queries. The index traffic fee of a Query Logstore is approximately half that of a Standard Logstore. Query Logstores do not support SQL analysis. Query Logstores are suitable for scenarios in which the amount of data is large, the log retention period is long, or log analysis is not required. Log retention periods of weeks or months are considered long.', example='standard'),
  shardCount?: int32(name='shardCount', description='The number of shards.

> You cannot call the CreateLogStore operation to change the number of shards. You can call the SplitShard or MergeShards operation to change the number of shards.', example='2'),
  telemetryType?: string(name='telemetryType', description='The type of the observable data. Valid values:

*   None: logs
*   Metrics: metrics', example='None'),
  ttl?: int32(name='ttl', description='The retention period of data. Unit: days. Valid values: 1 to 3000. If you set this parameter to 3650, data is permanently stored.', example='1'),
}

model CreateLogStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### Usage notes
  * Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
  *
  * @param request CreateLogStoreRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateLogStoreResponse
 */
async function createLogStoreWithOptions(project: string, request: CreateLogStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLogStoreResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.appendMeta)) {
    body['appendMeta'] = request.appendMeta;
  }
  if (!Util.isUnset(request.autoSplit)) {
    body['autoSplit'] = request.autoSplit;
  }
  if (!Util.isUnset(request.enableTracking)) {
    body['enable_tracking'] = request.enableTracking;
  }
  if (!Util.isUnset(request.encryptConf)) {
    body['encrypt_conf'] = request.encryptConf;
  }
  if (!Util.isUnset(request.hotTtl)) {
    body['hot_ttl'] = request.hotTtl;
  }
  if (!Util.isUnset(request.infrequentAccessTTL)) {
    body['infrequentAccessTTL'] = request.infrequentAccessTTL;
  }
  if (!Util.isUnset(request.logstoreName)) {
    body['logstoreName'] = request.logstoreName;
  }
  if (!Util.isUnset(request.maxSplitShard)) {
    body['maxSplitShard'] = request.maxSplitShard;
  }
  if (!Util.isUnset(request.mode)) {
    body['mode'] = request.mode;
  }
  if (!Util.isUnset(request.shardCount)) {
    body['shardCount'] = request.shardCount;
  }
  if (!Util.isUnset(request.telemetryType)) {
    body['telemetryType'] = request.telemetryType;
  }
  if (!Util.isUnset(request.ttl)) {
    body['ttl'] = request.ttl;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLogStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
  *
  * @param request CreateLogStoreRequest
  * @return CreateLogStoreResponse
 */
async function createLogStore(project: string, request: CreateLogStoreRequest): CreateLogStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLogStoreWithOptions(project, request, headers, runtime);
}

model CreateLoggingRequest {
  loggingDetails?: [ 
    {
      logstore?: string(name='logstore', description='The name of the Logstore to which service logs of the type are stored.', example='my-logstore'),
      type?: string(name='type', description='The type of service logs. Valid values:

*   consumergroup_log: the consumption delay logs of consumer groups.
*   logtail_alarm: the alert logs of Logtail.
*   operation_log: the operation logs.
*   logtail_profile: the collection logs of Logtail.
*   metering: the metering logs.
*   logtail_status: the status logs of Logtail.
*   scheduledsqlalert: the run logs of Scheduled SQL jobs.
*   etl_alert: the run logs of data transformation jobs.', example='consumergroup_log'),
    }
  ](name='loggingDetails', description='The configurations of service logs.'),
  loggingProject?: string(name='loggingProject', description='The name of the project to which service logs are stored.', example='my-project'),
}

model CreateLoggingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request CreateLoggingRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateLoggingResponse
 */
async function createLoggingWithOptions(project: string, request: CreateLoggingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLoggingResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.loggingDetails)) {
    body['loggingDetails'] = request.loggingDetails;
  }
  if (!Util.isUnset(request.loggingProject)) {
    body['loggingProject'] = request.loggingProject;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLogging',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logging`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request CreateLoggingRequest
  * @return CreateLoggingResponse
 */
async function createLogging(project: string, request: CreateLoggingRequest): CreateLoggingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLoggingWithOptions(project, request, headers, runtime);
}

model CreateLogtailPipelineConfigRequest {
  aggregators?: [  map[string]any ](name='aggregators', description='The aggregation plug-ins.'),
  configName?: string(name='configName', description='The name of the configuration.', example='test-config'),
  flushers?: [  map[string]any ](name='flushers', description='The data output plug-ins.'),
  global?: map[string]any(name='global', description='The global configuration.'),
  inputs?: [  map[string]any ](name='inputs', description='The data source plug-ins.'),
  logSample?: string(name='logSample', description='The sample log.', example='2022-06-14 11:13:29.796 | DEBUG    | __main__:<module>:1 - hello world'),
  processors?: [  map[string]any ](name='processors', description='The processing plug-ins.'),
}

model CreateLogtailPipelineConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * The UK (London) region is supported. Supported regions are constantly updated.
  *
  * @param request CreateLogtailPipelineConfigRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateLogtailPipelineConfigResponse
 */
async function createLogtailPipelineConfigWithOptions(project: string, request: CreateLogtailPipelineConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLogtailPipelineConfigResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.aggregators)) {
    body['aggregators'] = request.aggregators;
  }
  if (!Util.isUnset(request.configName)) {
    body['configName'] = request.configName;
  }
  if (!Util.isUnset(request.flushers)) {
    body['flushers'] = request.flushers;
  }
  if (!Util.isUnset(request.global)) {
    body['global'] = request.global;
  }
  if (!Util.isUnset(request.inputs)) {
    body['inputs'] = request.inputs;
  }
  if (!Util.isUnset(request.logSample)) {
    body['logSample'] = request.logSample;
  }
  if (!Util.isUnset(request.processors)) {
    body['processors'] = request.processors;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLogtailPipelineConfig',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/pipelineconfigs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * The UK (London) region is supported. Supported regions are constantly updated.
  *
  * @param request CreateLogtailPipelineConfigRequest
  * @return CreateLogtailPipelineConfigResponse
 */
async function createLogtailPipelineConfig(project: string, request: CreateLogtailPipelineConfigRequest): CreateLogtailPipelineConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLogtailPipelineConfigWithOptions(project, request, headers, runtime);
}

model CreateMachineGroupRequest {
  groupAttribute?: {
    externalName?: string(name='externalName', description='The identifier of the external management system on which the machine group depends.', example='testgroup'),
    groupTopic?: string(name='groupTopic', description='The log topic of the machine group.', example='testtopic'),
  }(name='groupAttribute', description='The attributes of the machine group.'),
  groupName?: string(name='groupName', description='The name of the machine group. The name must meet the following requirements:

*   The name of each machine group in a project must be unique.
*   It can contain only lowercase letters, digits, hyphens (-), and underscores (\\_).
*   It must start and end with a lowercase letter or a digit.
*   It must be 3 to 128 characters in length.', example='test-machine-group'),
  groupType?: string(name='groupType', description='The type of the machine group. The parameter can be left empty.', example='""'),
  machineIdentifyType?: string(name='machineIdentifyType', description='The type of the machine group identifier. Valid values:

*   ip: The machine group uses IP addresses as identifiers.
*   userdefined: The machine group uses custom identifiers.', example='ip'),
  machineList?: [ string ](name='machineList', description='The identifiers of machine group.

*   If you set machineIdentifyType to ip, enter the IP address of the machine.
*   If you set machineIdentifyType to userdefined, enter a custom identifier.'),
}

model CreateMachineGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request CreateMachineGroupRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateMachineGroupResponse
 */
async function createMachineGroupWithOptions(project: string, request: CreateMachineGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMachineGroupResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupAttribute)) {
    body['groupAttribute'] = request.groupAttribute;
  }
  if (!Util.isUnset(request.groupName)) {
    body['groupName'] = request.groupName;
  }
  if (!Util.isUnset(request.groupType)) {
    body['groupType'] = request.groupType;
  }
  if (!Util.isUnset(request.machineIdentifyType)) {
    body['machineIdentifyType'] = request.machineIdentifyType;
  }
  if (!Util.isUnset(request.machineList)) {
    body['machineList'] = request.machineList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request CreateMachineGroupRequest
  * @return CreateMachineGroupResponse
 */
async function createMachineGroup(project: string, request: CreateMachineGroupRequest): CreateMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMachineGroupWithOptions(project, request, headers, runtime);
}

model CreateOSSExportRequest {
  configuration?: OSSExportConfiguration(name='configuration'),
  description?: string(name='description'),
  displayName?: string(name='displayName', example='ali-test-oss-job'),
  name?: string(name='name', example='job-123456789-123456'),
}

model CreateOSSExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function createOSSExportWithOptions(project: string, request: CreateOSSExportRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateOSSExportResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOSSExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossexports`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function createOSSExport(project: string, request: CreateOSSExportRequest): CreateOSSExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createOSSExportWithOptions(project, request, headers, runtime);
}

model CreateOSSHDFSExportRequest {
  configuration?: OSSExportConfiguration(name='configuration'),
  description?: string(name='description'),
  displayName?: string(name='displayName', example='ali-test-oss-hdfs-job'),
  name?: string(name='name', example='job-123456789-123456'),
}

model CreateOSSHDFSExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function createOSSHDFSExportWithOptions(project: string, request: CreateOSSHDFSExportRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateOSSHDFSExportResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOSSHDFSExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/osshdfsexports`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function createOSSHDFSExport(project: string, request: CreateOSSHDFSExportRequest): CreateOSSHDFSExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createOSSHDFSExportWithOptions(project, request, headers, runtime);
}

model CreateOSSIngestionRequest {
  configuration?: OSSIngestionConfiguration(name='configuration'),
  description?: string(name='description'),
  displayName?: string(name='displayName'),
  name?: string(name='name', example='ingest-oss-123456'),
  schedule?: Schedule(name='schedule'),
}

model CreateOSSIngestionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function createOSSIngestionWithOptions(project: string, request: CreateOSSIngestionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateOSSIngestionResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.schedule)) {
    body['schedule'] = request.schedule;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOSSIngestion',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossingestions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function createOSSIngestion(project: string, request: CreateOSSIngestionRequest): CreateOSSIngestionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createOSSIngestionWithOptions(project, request, headers, runtime);
}

model CreateOssExternalStoreRequest {
  externalStoreName?: string(name='externalStoreName', description='The name of the external store.', example='test_oss_store'),
  parameter?: {
    accessid?: string(name='accessid', description='The AccessKey ID of your account.', example='LTAI5tFsHGGeYry*****1Sz'),
    accesskey?: string(name='accesskey', description='The AccessKey secret of your account.', example='GyviCLDVHkHrOztdkxuE6******Rp6'),
    bucket?: string(name='bucket', description='The name of the OSS bucket.', example='my-bucket'),
    columns?: [ 
      {
        name?: string(name='name', description='The name of the field.', example='auto-test'),
        type?: string(name='type', description='The type of the field.', example='sls'),
      }
    ](name='columns', description='The fields that are associated to the external store.'),
    endpoint?: string(name='endpoint', description='The Object Storage Service (OSS) endpoint.', example='oss-cn-hangzhou.aliyuncs.com'),
    objects?: [ string ](name='objects', description='The names of the OSS objects that are associated to the external store.'),
  }(name='parameter', description='The parameters that are configured for the external store.'),
  storeType?: string(name='storeType', description='The type of the external store. Set the value to oss.', example='oss'),
}

model CreateOssExternalStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### [](#)Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request CreateOssExternalStoreRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateOssExternalStoreResponse
 */
async function createOssExternalStoreWithOptions(project: string, request: CreateOssExternalStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateOssExternalStoreResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.externalStoreName)) {
    body['externalStoreName'] = request.externalStoreName;
  }
  if (!Util.isUnset(request.parameter)) {
    body['parameter'] = request.parameter;
  }
  if (!Util.isUnset(request.storeType)) {
    body['storeType'] = request.storeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOssExternalStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/externalstores`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### [](#)Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request CreateOssExternalStoreRequest
  * @return CreateOssExternalStoreResponse
 */
async function createOssExternalStore(project: string, request: CreateOssExternalStoreRequest): CreateOssExternalStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createOssExternalStoreWithOptions(project, request, headers, runtime);
}

model CreateProjectRequest {
  dataRedundancyType?: string(name='dataRedundancyType', description='Data redundancy type', example='LRS'),
  description?: string(name='description', description='The description of the project.', example='this is test'),
  projectName?: string(name='projectName', description='The name of the project. The name must be unique in a region. You cannot change the name after you create the project. The name must meet the following requirements:

*   The name must be unique.
*   It can contain only lowercase letters, digits, and hyphens (-).
*   It must start and end with a lowercase letter or a digit.
*   It must be 3 to 63 characters in length.', example='test-project'),
  resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group.', example='rg-aekzf******sxby'),
}

model CreateProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function createProjectWithOptions(request: CreateProjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dataRedundancyType)) {
    body['dataRedundancyType'] = request.dataRedundancyType;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.projectName)) {
    body['projectName'] = request.projectName;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function createProject(request: CreateProjectRequest): CreateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createProjectWithOptions(request, headers, runtime);
}

model CreateRdsExternalStoreRequest {
  externalStoreName?: string(name='externalStoreName', description='The name of the external store. The name must be unique in a project and must be different from Logstore names.', example='rds_store'),
  parameter?: {
    db?: string(name='db', description='The name of the database in the ApsaraDB RDS for MySQL instance.', example='meta'),
    host?: string(name='host', description='The internal or public endpoint of the ApsaraDB RDS for MySQL instance.', example='192.168.XX.XX'),
    instanceId?: string(name='instance-id', description='The ID of the ApsaraDB RDS for MySQL instance.', example='i-bp1b6c719dfa08exf****'),
    password?: string(name='password', description='The password that is used to log on to the ApsaraDB RDS for MySQL instance.', example='sfdsfldsfksfls****'),
    port?: string(name='port', description='The internal or public port of the ApsaraDB RDS for MySQL instance.', example='3306'),
    region?: string(name='region', description='The region where the ApsaraDB RDS for MySQL instance resides. Valid values: cn-qingdao, cn-beijing, and cn-hangzhou.', example='cn-qingdao'),
    table?: string(name='table', description='The name of the database table in the ApsaraDB RDS for MySQL instance.', example='join_meta'),
    username?: string(name='username', description='The username that is used to log on to the ApsaraDB RDS for MySQL instance.', example='root'),
    vpcId?: string(name='vpc-id', description='The ID of the VPC to which the ApsaraDB RDS for MySQL instance belongs.', example='vpc-bp1aevy8sofi8mh1q****'),
  }(name='parameter', description='The parameter struct.'),
  storeType?: string(name='storeType', description='The storage type. Set the value to rds-vpc, which indicates an ApsaraDB RDS for MySQL database in a virtual private cloud (VPC).', example='rds-vpc'),
}

model CreateRdsExternalStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request CreateRdsExternalStoreRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateRdsExternalStoreResponse
 */
async function createRdsExternalStoreWithOptions(project: string, request: CreateRdsExternalStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRdsExternalStoreResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.externalStoreName)) {
    body['externalStoreName'] = request.externalStoreName;
  }
  if (!Util.isUnset(request.parameter)) {
    body['parameter'] = request.parameter;
  }
  if (!Util.isUnset(request.storeType)) {
    body['storeType'] = request.storeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateRdsExternalStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/externalstores`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request CreateRdsExternalStoreRequest
  * @return CreateRdsExternalStoreResponse
 */
async function createRdsExternalStore(project: string, request: CreateRdsExternalStoreRequest): CreateRdsExternalStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRdsExternalStoreWithOptions(project, request, headers, runtime);
}

model CreateSavedSearchRequest {
  displayName?: string(name='displayName', description='The display name.', example='displayname'),
  logstore?: string(name='logstore', description='The name of the Logstore to which the saved search belongs.', example='aliyun-test-logstore'),
  savedsearchName?: string(name='savedsearchName', description='The name of the saved search. The name must be 3 to 63 characters in length.', example='pv in minutes'),
  searchQuery?: string(name='searchQuery', description='The query statement of the saved search. A query statement consists of a search statement and an analytic statement in the `Search statement|Analytic statement` format. For more information about search statements and analytic statements, see [Log search overview](~~43772~~) and [Log analysis overview](~~53608~~).', example='*|select date_format(__time__-__time__%60, \\"%H:%i:%s\\") as time, COUNT(*) as pv group by time'),
  topic?: string(name='topic', description='The topic of the log.', example='theme'),
}

model CreateSavedSearchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request CreateSavedSearchRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateSavedSearchResponse
 */
async function createSavedSearchWithOptions(project: string, request: CreateSavedSearchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSavedSearchResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.logstore)) {
    body['logstore'] = request.logstore;
  }
  if (!Util.isUnset(request.savedsearchName)) {
    body['savedsearchName'] = request.savedsearchName;
  }
  if (!Util.isUnset(request.searchQuery)) {
    body['searchQuery'] = request.searchQuery;
  }
  if (!Util.isUnset(request.topic)) {
    body['topic'] = request.topic;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSavedSearch',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/savedsearches`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request CreateSavedSearchRequest
  * @return CreateSavedSearchResponse
 */
async function createSavedSearch(project: string, request: CreateSavedSearchRequest): CreateSavedSearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSavedSearchWithOptions(project, request, headers, runtime);
}

model CreateScheduledSQLRequest {
  configuration?: ScheduledSQLConfiguration(name='configuration'),
  description?: string(name='description'),
  displayName?: string(name='displayName', example='ali-test-scheduled-sql'),
  name?: string(name='name', example='sql-123456789-123456'),
  schedule?: Schedule(name='schedule'),
}

model CreateScheduledSQLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function createScheduledSQLWithOptions(project: string, request: CreateScheduledSQLRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateScheduledSQLResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.schedule)) {
    body['schedule'] = request.schedule;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateScheduledSQL',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/scheduledsqls`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function createScheduledSQL(project: string, request: CreateScheduledSQLRequest): CreateScheduledSQLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createScheduledSQLWithOptions(project, request, headers, runtime);
}

model CreateSqlInstanceRequest {
  cu?: int32(name='cu', example='2'),
  useAsDefault?: boolean(name='useAsDefault'),
}

model CreateSqlInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function createSqlInstanceWithOptions(project: string, request: CreateSqlInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSqlInstanceResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.cu)) {
    body['cu'] = request.cu;
  }
  if (!Util.isUnset(request.useAsDefault)) {
    body['useAsDefault'] = request.useAsDefault;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSqlInstance',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/sqlinstance`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function createSqlInstance(project: string, request: CreateSqlInstanceRequest): CreateSqlInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSqlInstanceWithOptions(project, request, headers, runtime);
}

model CreateStoreViewRequest {
  name?: string(name='name', example='my_storeview'),
  storeType?: string(name='storeType', example='logstore'),
  stores?: [
    StoreViewStore
  ](name='stores'),
}

model CreateStoreViewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function createStoreViewWithOptions(project: string, request: CreateStoreViewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateStoreViewResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.storeType)) {
    body['storeType'] = request.storeType;
  }
  if (!Util.isUnset(request.stores)) {
    body['stores'] = request.stores;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateStoreView',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/storeviews`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function createStoreView(project: string, request: CreateStoreViewRequest): CreateStoreViewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createStoreViewWithOptions(project, request, headers, runtime);
}

model CreateTicketRequest {
  accessTokenExpirationTime?: long(name='accessTokenExpirationTime'),
  expirationTime?: long(name='expirationTime'),
}

model CreateTicketResponseBody = {
  ticket?: string(name='ticket', example='eyJ***************.eyJ******************.KUT****************'),
}

model CreateTicketResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateTicketResponseBody(name='body'),
}

async function createTicketWithOptions(request: CreateTicketRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTicketResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessTokenExpirationTime)) {
    query['accessTokenExpirationTime'] = request.accessTokenExpirationTime;
  }
  if (!Util.isUnset(request.expirationTime)) {
    query['expirationTime'] = request.expirationTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateTicket',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/tickets`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function createTicket(request: CreateTicketRequest): CreateTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTicketWithOptions(request, headers, runtime);
}

model DeleteAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteAlertWithOptions(project: string, alertName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAlertResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteAlert',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/alerts/${alertName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function deleteAlert(project: string, alertName: string): DeleteAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAlertWithOptions(project, alertName, headers, runtime);
}

model DeleteAnnotationDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteAnnotationDataWithOptions(datasetId: string, annotationdataId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAnnotationDataResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteAnnotationData',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationdataset/${datasetId}/annotationdata/${annotationdataId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function deleteAnnotationData(datasetId: string, annotationdataId: string): DeleteAnnotationDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAnnotationDataWithOptions(datasetId, annotationdataId, headers, runtime);
}

model DeleteAnnotationDataSetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * You can delete a dataset only if no data exists in the dataset.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteAnnotationDataSetResponse
 */
async function deleteAnnotationDataSetWithOptions(datasetId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAnnotationDataSetResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteAnnotationDataSet',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationdataset/${datasetId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * You can delete a dataset only if no data exists in the dataset.
  *
  * @return DeleteAnnotationDataSetResponse
 */
async function deleteAnnotationDataSet(datasetId: string): DeleteAnnotationDataSetResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAnnotationDataSetWithOptions(datasetId, headers, runtime);
}

model DeleteAnnotationLabelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * Only non-built-in tags can be deleted.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteAnnotationLabelResponse
 */
async function deleteAnnotationLabelWithOptions(labelId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAnnotationLabelResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteAnnotationLabel',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationlabel/${labelId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * Only non-built-in tags can be deleted.
  *
  * @return DeleteAnnotationLabelResponse
 */
async function deleteAnnotationLabel(labelId: string): DeleteAnnotationLabelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAnnotationLabelWithOptions(labelId, headers, runtime);
}

model DeleteCollectionPolicyRequest {
  dataCode?: string(name='dataCode', example='access_log'),
  productCode?: string(name='productCode', example='oss'),
}

model DeleteCollectionPolicyResponseBody = {
  message?: string(name='message', example='successful'),
}

model DeleteCollectionPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCollectionPolicyResponseBody(name='body'),
}

async function deleteCollectionPolicyWithOptions(policyName: string, request: DeleteCollectionPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteCollectionPolicyResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dataCode)) {
    query['dataCode'] = request.dataCode;
  }
  if (!Util.isUnset(request.productCode)) {
    query['productCode'] = request.productCode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCollectionPolicy',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/collectionpolicy/${policyName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function deleteCollectionPolicy(policyName: string, request: DeleteCollectionPolicyRequest): DeleteCollectionPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteCollectionPolicyWithOptions(policyName, request, headers, runtime);
}

model DeleteConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### [](#)Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   If a Logtail configuration is applied to a machine group, you cannot collect data from the machine group after you delete the Logtail configuration.
  * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](~~29009~~).
  * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](~~47664~~).
  * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](~~48984~~).
  * *   The name of the required Logtail configuration is obtained. For more information, see [ListConfig](~~29043~~).
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteConfigResponse
 */
async function deleteConfigWithOptions(project: string, configName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteConfigResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteConfig',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/configs/${configName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### [](#)Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   If a Logtail configuration is applied to a machine group, you cannot collect data from the machine group after you delete the Logtail configuration.
  * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](~~29009~~).
  * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](~~47664~~).
  * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](~~48984~~).
  * *   The name of the required Logtail configuration is obtained. For more information, see [ListConfig](~~29043~~).
  *
  * @return DeleteConfigResponse
 */
async function deleteConfig(project: string, configName: string): DeleteConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConfigWithOptions(project, configName, headers, runtime);
}

model DeleteConsumerGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteConsumerGroupResponse
 */
async function deleteConsumerGroupWithOptions(project: string, logstore: string, consumerGroup: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteConsumerGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteConsumerGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups/${consumerGroup}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @return DeleteConsumerGroupResponse
 */
async function deleteConsumerGroup(project: string, logstore: string, consumerGroup: string): DeleteConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConsumerGroupWithOptions(project, logstore, consumerGroup, headers, runtime);
}

model DeleteDashboardResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### [](#)Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](~~29009~~).
  * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](~~47664~~).
  * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](~~48984~~).
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteDashboardResponse
 */
async function deleteDashboardWithOptions(project: string, dashboardName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDashboardResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteDashboard',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/dashboards/${dashboardName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### [](#)Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](~~29009~~).
  * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](~~47664~~).
  * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](~~48984~~).
  *
  * @return DeleteDashboardResponse
 */
async function deleteDashboard(project: string, dashboardName: string): DeleteDashboardResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDashboardWithOptions(project, dashboardName, headers, runtime);
}

model DeleteDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteDomainResponse
 */
async function deleteDomainWithOptions(project: string, domainName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDomainResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteDomain',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/domains/${domainName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @return DeleteDomainResponse
 */
async function deleteDomain(project: string, domainName: string): DeleteDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDomainWithOptions(project, domainName, headers, runtime);
}

model DeleteETLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteETLWithOptions(project: string, etlName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteETLResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteETL',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/etls/${etlName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function deleteETL(project: string, etlName: string): DeleteETLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteETLWithOptions(project, etlName, headers, runtime);
}

model DeleteExternalStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteExternalStoreResponse
 */
async function deleteExternalStoreWithOptions(project: string, externalStoreName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteExternalStoreResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteExternalStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/externalstores/${externalStoreName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @return DeleteExternalStoreResponse
 */
async function deleteExternalStore(project: string, externalStoreName: string): DeleteExternalStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteExternalStoreWithOptions(project, externalStoreName, headers, runtime);
}

model DeleteIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteIndexResponse
 */
async function deleteIndexWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteIndexResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteIndex',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/index`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @return DeleteIndexResponse
 */
async function deleteIndex(project: string, logstore: string): DeleteIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteIndexWithOptions(project, logstore, headers, runtime);
}

model DeleteLogStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### Usage notes
  * Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteLogStoreResponse
 */
async function deleteLogStoreWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLogStoreResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteLogStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
  *
  * @return DeleteLogStoreResponse
 */
async function deleteLogStore(project: string, logstore: string): DeleteLogStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLogStoreWithOptions(project, logstore, headers, runtime);
}

model DeleteLoggingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteLoggingWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLoggingResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteLogging',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logging`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function deleteLogging(project: string): DeleteLoggingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLoggingWithOptions(project, headers, runtime);
}

model DeleteLogtailPipelineConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * The UK (London) region is supported. Supported regions are constantly updated.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteLogtailPipelineConfigResponse
 */
async function deleteLogtailPipelineConfigWithOptions(project: string, configName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLogtailPipelineConfigResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteLogtailPipelineConfig',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/pipelineconfigs/${configName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * The UK (London) region is supported. Supported regions are constantly updated.
  *
  * @return DeleteLogtailPipelineConfigResponse
 */
async function deleteLogtailPipelineConfig(project: string, configName: string): DeleteLogtailPipelineConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLogtailPipelineConfigWithOptions(project, configName, headers, runtime);
}

model DeleteMachineGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteMachineGroupResponse
 */
async function deleteMachineGroupWithOptions(project: string, machineGroup: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteMachineGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @return DeleteMachineGroupResponse
 */
async function deleteMachineGroup(project: string, machineGroup: string): DeleteMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteMachineGroupWithOptions(project, machineGroup, headers, runtime);
}

model DeleteOSSExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteOSSExportWithOptions(project: string, ossExportName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteOSSExportResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteOSSExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossexports/${ossExportName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function deleteOSSExport(project: string, ossExportName: string): DeleteOSSExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteOSSExportWithOptions(project, ossExportName, headers, runtime);
}

model DeleteOSSHDFSExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteOSSHDFSExportWithOptions(project: string, ossExportName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteOSSHDFSExportResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteOSSHDFSExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/osshdfsexports/${ossExportName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function deleteOSSHDFSExport(project: string, ossExportName: string): DeleteOSSHDFSExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteOSSHDFSExportWithOptions(project, ossExportName, headers, runtime);
}

model DeleteOSSIngestionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteOSSIngestionWithOptions(project: string, ossIngestionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteOSSIngestionResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteOSSIngestion',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossingestions/${ossIngestionName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function deleteOSSIngestion(project: string, ossIngestionName: string): DeleteOSSIngestionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteOSSIngestionWithOptions(project, ossIngestionName, headers, runtime);
}

model DeleteProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteProjectWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProjectResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function deleteProject(project: string): DeleteProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProjectWithOptions(project, headers, runtime);
}

model DeleteProjectPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteProjectPolicyResponse
 */
async function deleteProjectPolicyWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProjectPolicyResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteProjectPolicy',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/policy`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @return DeleteProjectPolicyResponse
 */
async function deleteProjectPolicy(project: string): DeleteProjectPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProjectPolicyWithOptions(project, headers, runtime);
}

model DeleteSavedSearchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteSavedSearchResponse
 */
async function deleteSavedSearchWithOptions(project: string, savedsearchName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteSavedSearchResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteSavedSearch',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/savedsearches/${savedsearchName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @return DeleteSavedSearchResponse
 */
async function deleteSavedSearch(project: string, savedsearchName: string): DeleteSavedSearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSavedSearchWithOptions(project, savedsearchName, headers, runtime);
}

model DeleteScheduledSQLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteScheduledSQLWithOptions(project: string, scheduledSQLName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteScheduledSQLResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteScheduledSQL',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/scheduledsqls/${scheduledSQLName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function deleteScheduledSQL(project: string, scheduledSQLName: string): DeleteScheduledSQLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteScheduledSQLWithOptions(project, scheduledSQLName, headers, runtime);
}

model DeleteShipperResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @deprecated
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteShipperResponse
 */
// Deprecated
async function deleteShipperWithOptions(project: string, logstore: string, shipperName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteShipperResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteShipper',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shipper/${shipperName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * @deprecated
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @return DeleteShipperResponse
 */
// Deprecated
async function deleteShipper(project: string, logstore: string, shipperName: string): DeleteShipperResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteShipperWithOptions(project, logstore, shipperName, headers, runtime);
}

model DeleteStoreViewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteStoreViewWithOptions(project: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteStoreViewResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteStoreView',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/storeviews/${name}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function deleteStoreView(project: string, name: string): DeleteStoreViewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteStoreViewWithOptions(project, name, headers, runtime);
}

model DisableAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function disableAlertWithOptions(project: string, alertName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DisableAlertResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DisableAlert',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/alerts/${alertName}?action=disable`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function disableAlert(project: string, alertName: string): DisableAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return disableAlertWithOptions(project, alertName, headers, runtime);
}

model DisableScheduledSQLResponseBody = {
  requestId?: string(name='requestId'),
}

model DisableScheduledSQLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableScheduledSQLResponseBody(name='body'),
}

async function disableScheduledSQLWithOptions(project: string, scheduledSQLName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DisableScheduledSQLResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DisableScheduledSQL',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/scheduledsqls/${scheduledSQLName}?action=disable`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function disableScheduledSQL(project: string, scheduledSQLName: string): DisableScheduledSQLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return disableScheduledSQLWithOptions(project, scheduledSQLName, headers, runtime);
}

model EnableAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function enableAlertWithOptions(project: string, alertName: string, headers: map[string]string, runtime: Util.RuntimeOptions): EnableAlertResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'EnableAlert',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/alerts/${alertName}?action=enable`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function enableAlert(project: string, alertName: string): EnableAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return enableAlertWithOptions(project, alertName, headers, runtime);
}

model GetAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Alert  
}

async function getAlertWithOptions(project: string, alertName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAlertResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAlert',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/alerts/${alertName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getAlert(project: string, alertName: string): GetAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAlertWithOptions(project, alertName, headers, runtime);
}

model GetAnnotationDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MLDataParam  
}

async function getAnnotationDataWithOptions(datasetId: string, annotationdataId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAnnotationDataResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAnnotationData',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationdataset/${datasetId}/annotationdata/${annotationdataId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getAnnotationData(datasetId: string, annotationdataId: string): GetAnnotationDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAnnotationDataWithOptions(datasetId, annotationdataId, headers, runtime);
}

model GetAnnotationDataSetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MLDataSetParam  
}

async function getAnnotationDataSetWithOptions(datasetId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAnnotationDataSetResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAnnotationDataSet',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationdataset/${datasetId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getAnnotationDataSet(datasetId: string): GetAnnotationDataSetResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAnnotationDataSetWithOptions(datasetId, headers, runtime);
}

model GetAnnotationLabelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MLLabelParam  
}

async function getAnnotationLabelWithOptions(labelId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAnnotationLabelResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAnnotationLabel',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationlabel/${labelId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getAnnotationLabel(labelId: string): GetAnnotationLabelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAnnotationLabelWithOptions(labelId, headers, runtime);
}

model GetAppliedConfigsResponseBody = {
  configs?: [ string ](name='configs', description='The names of the Logtail configurations.'),
  count?: int32(name='count', description='The number of Logtail configurations.', example='2'),
}

model GetAppliedConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAppliedConfigsResponseBody(name='body'),
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetAppliedConfigsResponse
 */
async function getAppliedConfigsWithOptions(project: string, machineGroup: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAppliedConfigsResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAppliedConfigs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}/configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @return GetAppliedConfigsResponse
 */
async function getAppliedConfigs(project: string, machineGroup: string): GetAppliedConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAppliedConfigsWithOptions(project, machineGroup, headers, runtime);
}

model GetAppliedMachineGroupsResponseBody = {
  count?: int32(name='count', description='The number of returned machine groups.', example='2'),
  machinegroups?: [ string ](name='machinegroups', description='The names of the returned machine groups.', example='[ "sample-group1","sample-group2" ]'),
}

model GetAppliedMachineGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAppliedMachineGroupsResponseBody(name='body'),
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetAppliedMachineGroupsResponse
 */
async function getAppliedMachineGroupsWithOptions(project: string, configName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAppliedMachineGroupsResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAppliedMachineGroups',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/configs/${configName}/machinegroups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @return GetAppliedMachineGroupsResponse
 */
async function getAppliedMachineGroups(project: string, configName: string): GetAppliedMachineGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAppliedMachineGroupsWithOptions(project, configName, headers, runtime);
}

model GetCheckPointRequest {
  shard?: int32(name='shard', description='The shard ID.

*   If the specified shard does not exist, an empty list is returned.
*   If no shard ID is specified, the checkpoints of all shards are returned.', example='1'),
}

model GetCheckPointResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [ 
    {
      shard?: int32(name='shard', description='The shard ID.', example='0'),
      checkpoint?: string(name='checkpoint', description='The value of the checkpoint.', example='MTUyNDE1NTM3OTM3MzkwODQ5Ng=='),
      updateTime?: long(name='updateTime', description='The time when the checkpoint was last updated. The value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1524224984800922'),
      consumer?: string(name='consumer', description='The consumer at the checkpoint.', example='consumer_1'),
    }
  ](name='body'),
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request GetCheckPointRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetCheckPointResponse
 */
async function getCheckPointWithOptions(project: string, logstore: string, consumerGroup: string, request: GetCheckPointRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCheckPointResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.shard)) {
    query['shard'] = request.shard;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCheckPoint',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups/${consumerGroup}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request GetCheckPointRequest
  * @return GetCheckPointResponse
 */
async function getCheckPoint(project: string, logstore: string, consumerGroup: string, request: GetCheckPointRequest): GetCheckPointResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCheckPointWithOptions(project, logstore, consumerGroup, request, headers, runtime);
}

model GetCollectionPolicyRequest {
  dataCode?: string(name='dataCode', example='access_log'),
  productCode?: string(name='productCode', example='oss'),
}

model GetCollectionPolicyResponseBody = {
  collectionPolicy?: {
    attribute?: {
      app?: string(name='app', example='your-app-name'),
      policyGroup?: string(name='policyGroup', example='your-policy-group'),
    }(name='attribute'),
    centralizeConfig?: {
      destLogstore?: string(name='destLogstore', example='your-sls-logstore-in-beijing'),
      destProject?: string(name='destProject', example='your-sls-project-in-beijing'),
      destRegion?: string(name='destRegion', example='cn-beijing'),
      destTTL?: int32(name='destTTL', example='your-sls-logstore-ttl'),
    }(name='centralizeConfig'),
    centralizeEnabled?: boolean(name='centralizeEnabled', example='false'),
    dataCode?: string(name='dataCode', example='access_log'),
    enabled?: string(name='enabled', example='true'),
    policyConfig?: {
      instanceIds?: [ string ](name='instanceIds'),
      regions?: [ string ](name='regions'),
      resourceMode?: string(name='resourceMode', example='all'),
      resourceTags?: map[string]any(name='resourceTags'),
    }(name='policyConfig'),
    policyName?: string(name='policyName', example='your_log_policy'),
    productCode?: string(name='productCode', example='oss'),
  }(name='collectionPolicy'),
}

model GetCollectionPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCollectionPolicyResponseBody(name='body'),
}

async function getCollectionPolicyWithOptions(policyName: string, request: GetCollectionPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCollectionPolicyResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dataCode)) {
    query['dataCode'] = request.dataCode;
  }
  if (!Util.isUnset(request.productCode)) {
    query['productCode'] = request.productCode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCollectionPolicy',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/collectionpolicy/${policyName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getCollectionPolicy(policyName: string, request: GetCollectionPolicyRequest): GetCollectionPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCollectionPolicyWithOptions(policyName, request, headers, runtime);
}

model GetConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: LogtailConfig  
}

/**
  * ### [](#)Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](~~29009~~).
  * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](~~47664~~).
  * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](~~48984~~).
  * *   The name of the required Logtail configuration is obtained. For more information, see [ListConfig](~~29043~~).
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetConfigResponse
 */
async function getConfigWithOptions(project: string, configName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetConfigResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetConfig',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/configs/${configName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * ### [](#)Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](~~29009~~).
  * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](~~47664~~).
  * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](~~48984~~).
  * *   The name of the required Logtail configuration is obtained. For more information, see [ListConfig](~~29043~~).
  *
  * @return GetConfigResponse
 */
async function getConfig(project: string, configName: string): GetConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getConfigWithOptions(project, configName, headers, runtime);
}

model GetContextLogsRequest {
  backLines?: long(name='back_lines', description='The number of logs that you want to obtain and are generated before the generation time of the start log. Valid values: (0,100].', example='10'),
  forwardLines?: long(name='forward_lines', description='The number of logs that you want to obtain and are generated after the generation time of the start log. Valid values: (0,100].', example='10'),
  packId?: string(name='pack_id', description='The unique identifier of the log group to which the start log belongs.', example='85C897C740352DC6-808'),
  packMeta?: string(name='pack_meta', description='The unique context identifier of the start log in the log group.', example='2|MTY1NTcwNTUzODY5MTY0MDk1Mg==|3|0'),
  type?: string(name='type', description='The type of the data in the Logstore. Set the value to context_log.', example='context_log'),
}

model GetContextLogsResponseBody = {
  backLines?: long(name='back_lines', description='The number of logs that are generated before the generation time of the start log.', example='100'),
  forwardLines?: long(name='forward_lines', description='The number of logs that are generated after the generation time of the start log.', example='100'),
  logs?: [  map[string]any ](name='logs', description='The logs that are returned.'),
  progress?: string(name='progress', description='Indicates whether the query and analysis results are complete. Valid values:

*   Complete: The query is successful, and the complete query and analysis results are returned.
*   Incomplete: The query is successful, but the query and analysis results are incomplete. To obtain the complete results, you must repeat the request.', example='Complete'),
  totalLines?: long(name='total_lines', description='The total number of logs that are returned. The logs include the start log that is specified in the request.', example='201'),
}

model GetContextLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetContextLogsResponseBody(name='body'),
}

/**
  * *   You can specify a log as the start log. The time range of a contextual query is one day before and one day after the generation time of the start log.
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request GetContextLogsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetContextLogsResponse
 */
async function getContextLogsWithOptions(project: string, logstore: string, request: GetContextLogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetContextLogsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.backLines)) {
    query['back_lines'] = request.backLines;
  }
  if (!Util.isUnset(request.forwardLines)) {
    query['forward_lines'] = request.forwardLines;
  }
  if (!Util.isUnset(request.packId)) {
    query['pack_id'] = request.packId;
  }
  if (!Util.isUnset(request.packMeta)) {
    query['pack_meta'] = request.packMeta;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetContextLogs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * *   You can specify a log as the start log. The time range of a contextual query is one day before and one day after the generation time of the start log.
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request GetContextLogsRequest
  * @return GetContextLogsResponse
 */
async function getContextLogs(project: string, logstore: string, request: GetContextLogsRequest): GetContextLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getContextLogsWithOptions(project, logstore, request, headers, runtime);
}

model GetCursorRequest {
  from?: string(name='from', description='The point in time that you want to use to query a cursor. Set the value to a UNIX timestamp or a string such as `begin` and `end`.', example='begin'),
}

model GetCursorResponseBody = {
  cursor?: string(name='cursor', description='The value of the cursor.', example='MTQ0NzI5OTYwNjg5NjYzMjM1Ng=='),
}

model GetCursorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCursorResponseBody(name='body'),
}

/**
  * ### Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   The following content describes the relationships among a cursor, project, Logstore, and shard:
  *     *   A project can have multiple Logstores.
  *     *   A Logstore can have multiple shards.
  *     *   You can use a cursor to obtain a log in a shard.
  *
  * @param request GetCursorRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetCursorResponse
 */
async function getCursorWithOptions(project: string, logstore: string, shardId: string, request: GetCursorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCursorResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.from)) {
    query['from'] = request.from;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCursor',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shards/${shardId}?type=cursor`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   The following content describes the relationships among a cursor, project, Logstore, and shard:
  *     *   A project can have multiple Logstores.
  *     *   A Logstore can have multiple shards.
  *     *   You can use a cursor to obtain a log in a shard.
  *
  * @param request GetCursorRequest
  * @return GetCursorResponse
 */
async function getCursor(project: string, logstore: string, shardId: string, request: GetCursorRequest): GetCursorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCursorWithOptions(project, logstore, shardId, request, headers, runtime);
}

model GetCursorTimeRequest {
  cursor?: string(name='cursor', description='The cursor.', example='MTU0NzQ3MDY4MjM3NjUxMzQ0Ng=='),
}

model GetCursorTimeResponseBody = {
  cursorTime?: string(name='cursor_time', description='The server time that is queried based on the cursor. The value is a UNIX timestamp representing the number of seconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1554260243'),
}

model GetCursorTimeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCursorTimeResponseBody(name='body'),
}

async function getCursorTimeWithOptions(project: string, logstore: string, shardId: string, request: GetCursorTimeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCursorTimeResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.cursor)) {
    query['cursor'] = request.cursor;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCursorTime',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shards/${shardId}?type=cursor_time`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getCursorTime(project: string, logstore: string, shardId: string, request: GetCursorTimeRequest): GetCursorTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCursorTimeWithOptions(project, logstore, shardId, request, headers, runtime);
}

model GetDashboardResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Dashboard  
}

/**
  * ### [](#)Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](~~29009~~).
  * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](~~47664~~).
  * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](~~48984~~).
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetDashboardResponse
 */
async function getDashboardWithOptions(project: string, dashboardName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetDashboardResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetDashboard',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/dashboards/${dashboardName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * ### [](#)Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](~~29009~~).
  * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](~~47664~~).
  * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](~~48984~~).
  *
  * @return GetDashboardResponse
 */
async function getDashboard(project: string, dashboardName: string): GetDashboardResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDashboardWithOptions(project, dashboardName, headers, runtime);
}

model GetETLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ETL  
}

async function getETLWithOptions(project: string, etlName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetETLResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetETL',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/etls/${etlName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getETL(project: string, etlName: string): GetETLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getETLWithOptions(project, etlName, headers, runtime);
}

model GetExternalStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExternalStore  
}

/**
  * *   The supported data sources of external stores include Object Storage Service (OSS) buckets and ApsaraDB RDS for MySQL databases in a virtual private cloud (VPC).
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetExternalStoreResponse
 */
async function getExternalStoreWithOptions(project: string, externalStoreName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetExternalStoreResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetExternalStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/externalstores/${externalStoreName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * *   The supported data sources of external stores include Object Storage Service (OSS) buckets and ApsaraDB RDS for MySQL databases in a virtual private cloud (VPC).
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @return GetExternalStoreResponse
 */
async function getExternalStore(project: string, externalStoreName: string): GetExternalStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExternalStoreWithOptions(project, externalStoreName, headers, runtime);
}

model GetHistogramsRequest {
  from?: long(name='from', description='The start time of the subinterval. The value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1409529600'),
  query?: string(name='query', description='The search statement. Only search statements are supported. Analytic statements are not supported. For more information about the syntax of search statements, see [Log search overview](~~43772~~).', example='with_pack_meta'),
  to?: long(name='to', description='The end time of the subinterval. The value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1409569200'),
  topic?: string(name='topic', description='The topic of the logs.', example='topic'),
}

model GetHistogramsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [ 
    {
      from?: long(name='from', description='The start time of the subinterval. The value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.

The time range that is specified in this operation is a left-closed, right-open interval. The interval includes the start time specified by the from parameter, but does not include the end time specified by the to parameter. If you specify the same value for the from and to parameters, the interval is invalid, and an error message is returned.', example='1409529600'),
      to?: long(name='to', description='The end time of the subinterval. The value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.

The time range that is specified in this operation is a left-closed, right-open interval. The interval includes the start time specified by the from parameter, but does not include the end time specified by the to parameter. If you specify the same value for the from and to parameters, the interval is invalid, and an error message is returned.', example='1409569200'),
      count?: long(name='count', description='The number of logs that are generated within the subinterval.', example='2'),
      progress?: string(name='progress', description='Indicates whether the query and analysis results in the subinterval is complete. Valid values:

Complete: The query is successful, and the complete query and analysis results are returned.

Incomplete: The query is successful, but the query and analysis results are incomplete. To obtain the complete results, you must repeat the request.', example='Complete'),
    }
  ](name='body'),
}

/**
  * ### Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   The time range is evenly divided into subintervals in the responses. If the time range that is specified in the request remains unchanged, the subintervals in the responses also remain unchanged.
  * *   If the number of logs in a Logstore significantly changes, Simple Log Service cannot predict the number of times that you must call this operation to obtain the complete result. In this case, you must check the value of the progress parameter in the response of each request and determine whether to call this operation one more time to obtain the complete result. Each time you call this operation, the same number of charge units (CUs) are consumed.
  * *   After a log is written to a Logstore, you can call the GetHistograms or GetLogs operation to query the log after a short latency. The latency of a query varies based on the type of the log. Simple Log Service classifies logs into the following types based on the log time:
  *     *   Real-time data: The difference between the time record in a log and the current time on Simple Log Service is within the interval (-180 seconds,900 seconds]. For example, if a log was generated at 12:03:00, September 25, 2014 (UTC) and Simple Log Service received the log at 12:05:00, September 25, 2014 (UTC), Simple Log Service processes the log as real-time data. After real-time data is written to a Logstore, the data can be queried with a maximum latency of 3 seconds.
  *     *   Historical data: The difference between the time record in a log and the current time on Simple Log Service is within the interval \\[-604,800 seconds,-180 seconds). For example, if a log was generated at 12:00:00, September 25, 2014 (UTC) and Simple Log Service received the log at 12:05:00, September 25, 2014 (UTC), Simple Log Service processes the log as historical data. This type of log is usually generated in data backfill scenarios.
  *     After real-time data is written to a Logstore, the data can be queried with a maximum latency of 3 seconds. For 99.9% of queries, the latency is no more than 1 second.
  * > Simple Log Service calculates the difference between the log time that is specified by the \\__time\\_\\_ field and the receiving time that is specified by the \\__tag\\_\\_:\\__receive_time\\_\\_ field for each log. The receiving time indicates the time at which Simple Log Service receives the log. If the difference is within the interval (-180 seconds,900 seconds], Simple Log Service processes the log as real-time data. If the difference is within the interval \\[-604,800 seconds,-180 seconds), Simple Log Service processes the log as historical data.
  * *   Simple Log Service provides examples on how to call the GetHistograms operation by using Simple Log Service SDK for Java. For more information, see [Use GetHistograms to query the distribution of logs](~~462234~~).
  *
  * @param request GetHistogramsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetHistogramsResponse
 */
async function getHistogramsWithOptions(project: string, logstore: string, request: GetHistogramsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetHistogramsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.from)) {
    query['from'] = request.from;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }
  if (!Util.isUnset(request.to)) {
    query['to'] = request.to;
  }
  if (!Util.isUnset(request.topic)) {
    query['topic'] = request.topic;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHistograms',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/index?type=histogram`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   The time range is evenly divided into subintervals in the responses. If the time range that is specified in the request remains unchanged, the subintervals in the responses also remain unchanged.
  * *   If the number of logs in a Logstore significantly changes, Simple Log Service cannot predict the number of times that you must call this operation to obtain the complete result. In this case, you must check the value of the progress parameter in the response of each request and determine whether to call this operation one more time to obtain the complete result. Each time you call this operation, the same number of charge units (CUs) are consumed.
  * *   After a log is written to a Logstore, you can call the GetHistograms or GetLogs operation to query the log after a short latency. The latency of a query varies based on the type of the log. Simple Log Service classifies logs into the following types based on the log time:
  *     *   Real-time data: The difference between the time record in a log and the current time on Simple Log Service is within the interval (-180 seconds,900 seconds]. For example, if a log was generated at 12:03:00, September 25, 2014 (UTC) and Simple Log Service received the log at 12:05:00, September 25, 2014 (UTC), Simple Log Service processes the log as real-time data. After real-time data is written to a Logstore, the data can be queried with a maximum latency of 3 seconds.
  *     *   Historical data: The difference between the time record in a log and the current time on Simple Log Service is within the interval \\[-604,800 seconds,-180 seconds). For example, if a log was generated at 12:00:00, September 25, 2014 (UTC) and Simple Log Service received the log at 12:05:00, September 25, 2014 (UTC), Simple Log Service processes the log as historical data. This type of log is usually generated in data backfill scenarios.
  *     After real-time data is written to a Logstore, the data can be queried with a maximum latency of 3 seconds. For 99.9% of queries, the latency is no more than 1 second.
  * > Simple Log Service calculates the difference between the log time that is specified by the \\__time\\_\\_ field and the receiving time that is specified by the \\__tag\\_\\_:\\__receive_time\\_\\_ field for each log. The receiving time indicates the time at which Simple Log Service receives the log. If the difference is within the interval (-180 seconds,900 seconds], Simple Log Service processes the log as real-time data. If the difference is within the interval \\[-604,800 seconds,-180 seconds), Simple Log Service processes the log as historical data.
  * *   Simple Log Service provides examples on how to call the GetHistograms operation by using Simple Log Service SDK for Java. For more information, see [Use GetHistograms to query the distribution of logs](~~462234~~).
  *
  * @param request GetHistogramsRequest
  * @return GetHistogramsResponse
 */
async function getHistograms(project: string, logstore: string, request: GetHistogramsRequest): GetHistogramsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getHistogramsWithOptions(project, logstore, request, headers, runtime);
}

model GetIndexResponseBody = {
  indexMode?: string(name='index_mode', description='The type of the index.', example='v2'),
  keys?: map[string]KeysValue(name='keys', description='The configurations of field indexes. A field index is in the key-value format in which the key specifies the name of the field and the value specifies the index configuration of the field.'),
  lastModifyTime?: long(name='lastModifyTime', description='The time when the index configurations were last updated. The value is a UNIX timestamp representing the number of seconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1524155379'),
  line?: {
    caseSensitive?: boolean(name='caseSensitive', description='Indicates whether case sensitivity is enabled. Valid values:

*   true
*   false', example='false'),
    chn?: boolean(name='chn', description='Indicates whether Chinese characters are included. Valid values:

*   true
*   false', example='false'),
    excludeKeys?: [ string ](name='exclude_keys', description='The excluded fields.'),
    includeKeys?: [ string ](name='include_keys', description='The included fields.'),
    token?: [ string ](name='token', description='The delimiters.'),
  }(name='line', description='The configurations of full-text indexes.'),
  logReduce?: boolean(name='log_reduce', description='Indicates whether the log clustering feature is enabled.', example='false'),
  logReduceBlackList?: [ string ](name='log_reduce_black_list', description='The fields in the blacklist that are used to cluster logs. This parameter is valid only if the log clustering feature is enabled.'),
  logReduceWhiteList?: [ string ](name='log_reduce_white_list', description='The fields in the whitelist that are used to cluster logs. This parameter is valid only if the log clustering feature is enabled.'),
  maxTextLen?: int32(name='max_text_len', description='The maximum length of a field value that can be retained. Default value: 2048. Unit: bytes. The default value is equal to 2 KB. You can change the value of the max_text_len parameter. Valid values: 64 to 16384. Unit: bytes.', example='2048'),
  storage?: string(name='storage', description='The storage type. The value is fixed as pg.', example='pg'),
  ttl?: int32(name='ttl', description='The lifecycle of the index file. Valid values: 7, 30, and 90. Unit: day.', example='30'),
}

model GetIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetIndexResponseBody(name='body'),
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetIndexResponse
 */
async function getIndexWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetIndexResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetIndex',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/index`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @return GetIndexResponse
 */
async function getIndex(project: string, logstore: string): GetIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getIndexWithOptions(project, logstore, headers, runtime);
}

model GetLogStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Logstore  
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetLogStoreResponse
 */
async function getLogStoreWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLogStoreResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLogStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @return GetLogStoreResponse
 */
async function getLogStore(project: string, logstore: string): GetLogStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLogStoreWithOptions(project, logstore, headers, runtime);
}

model GetLogStoreMeteringModeResponseBody = {
  meteringMode?: string(name='meteringMode'),
}

model GetLogStoreMeteringModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLogStoreMeteringModeResponseBody(name='body'),
}

async function getLogStoreMeteringModeWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLogStoreMeteringModeResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLogStoreMeteringMode',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/meteringmode`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getLogStoreMeteringMode(project: string, logstore: string): GetLogStoreMeteringModeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLogStoreMeteringModeWithOptions(project, logstore, headers, runtime);
}

model GetLoggingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Logging  
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetLoggingResponse
 */
async function getLoggingWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLoggingResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLogging',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logging`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @return GetLoggingResponse
 */
async function getLogging(project: string): GetLoggingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLoggingWithOptions(project, headers, runtime);
}

model GetLogsRequest {
  from?: int32(name='from', description='The beginning of the time range to query. The value is the log time that is specified when log data is written.

*   The time range that is specified in this operation is a left-closed, right-open interval. The interval includes the start time specified by the **from** parameter, but does not include the end time specified by the **to** parameter. If you specify the same value for the **from** and **to** parameters, the interval is invalid, and an error message is returned.
*   The value is a UNIX timestamp representing the number of seconds that have elapsed since January 1, 1970, 00:00:00 UTC.

> To ensure that full data can be queried, specify a query time range that is accurate to the minute. If you also specify a time range in an analytic statement, Simple Log Service uses the time range specified in the analytic statement for query and analysis.

If you want to specify a time range that is accurate to the second in your analytic statement, you must use the from_unixtime or to_unixtime function to convert the time format. For more information about the functions, see [from_unixtime function](~~63451~~) and [to_unixtime function](~~63451~~). Examples:

*   `* | SELECT * FROM log WHERE from_unixtime(__time__) > from_unixtime(1664186624) AND from_unixtime(__time__) < now()`
*   `* | SELECT * FROM log WHERE __time__ > to_unixtime(date_parse(\\"2022-10-19 15:46:05\\", \\"%Y-%m-%d %H:%i:%s\\")) AND __time__ < to_unixtime(now())`', example='1627268185'),
  line?: long(name='line', description='The maximum number of logs to return for the request. This parameter takes effect only when the query parameter is set to a search statement. Minimum value: 0. Maximum value: 100. Default value: 100.', example='100'),
  offset?: long(name='offset', description='The line from which the query starts. This parameter takes effect only when the query parameter is set to a search statement. Default value: 0.', example='0'),
  powerSql?: boolean(name='powerSql', description='Specifies whether to enable the Dedicated SQL feature. For more information, see [Enable Dedicated SQL](~~223777~~). Valid values:

*   true: enables the Dedicated SQL feature.
*   false (default): enables the Standard SQL feature.

You can use the powerSql or **query** parameter to configure Dedicated SQL.', example='false'),
  query?: string(name='query', description='The search statement or the query statement. For more information, see [Log search overview](~~43772~~) and [Log analysis overview](~~53608~~). If you add `set session parallel_sql=true;` to the analytic statement in the query parameter, Dedicated SQL is used. For example, you can set the query parameter to `* | set session parallel_sql=true; select count(*) as pv`. For more information about common errors that may occur during log query and analysis, see [How do I resolve common errors that occur when I query and analyze logs?](~~61628~~)

> If you specify an analytic statement in the value of the query parameter, the line and offset parameters do not take effect. In this case, we recommend that you set the line and offset parameters to 0 and use the LIMIT clause to limit the number of logs to return on each page. For more information, see [Paged query](~~89994~~).', example='status: 401 | SELECT remote_addr,COUNT(*) as pv GROUP by remote_addr ORDER by pv desc limit 5'),
  reverse?: boolean(name='reverse', description='Specifies whether to return logs in reverse chronological order of log timestamps. The log timestamps are accurate to the minute. Valid values:

*   true: returns logs in reverse chronological order of log timestamps.
*   false (default): returns logs in chronological order of log timestamps.

> 

*   The reverse parameter takes effect only when the query parameter is set to a search statement. The reverse parameter specifies the method used to sort returned logs.
*   If the query parameter is set to a query statement, the reverse parameter does not take effect. The method used to sort returned logs is specified by the ORDER BY clause in the analytic statement. If you use the keyword asc in the ORDER BY clause, the logs are sorted in chronological order. If you use the keyword desc in the ORDER BY clause, the logs are sorted in reverse chronological order. By default, asc is used in the ORDER BY clause.', example='false'),
  to?: int32(name='to', description='The end of the time range to query. The value is the log time that is specified when log data is written.

*   The time range that is specified in this operation is a left-closed, right-open interval. The interval includes the start time specified by the **from** parameter, but does not include the end time specified by the **to** parameter. If you specify the same value for the **from** and **to** parameters, the interval is invalid, and an error message is returned.
*   The value is a UNIX timestamp representing the number of seconds that have elapsed since January 1, 1970, 00:00:00 UTC.

> To ensure that full data can be queried, specify a query time range that is accurate to the minute. If you also specify a time range in an analytic statement, Simple Log Service uses the time range specified in the analytic statement for query and analysis.

If you want to specify a time range that is accurate to the second in your analytic statement, you must use the from_unixtime or to_unixtime function to convert the time format. For more information about the functions, see [from_unixtime function](~~63451~~) and [to_unixtime function](~~63451~~). Examples:

*   `* | SELECT * FROM log WHERE from_unixtime(__time__) > from_unixtime(1664186624) AND from_unixtime(__time__) < now()`
*   `* | SELECT * FROM log WHERE __time__ > to_unixtime(date_parse(\\"2022-10-19 15:46:05\\", \\"%Y-%m-%d %H:%i:%s\\")) AND __time__ < to_unixtime(now())`', example='1627269085'),
  topic?: string(name='topic', description='The topic of the logs. The default value is double quotation marks (""). For more information, see [Topic](~~48881~~).', example='topic'),
}

model GetLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [  map[string]any ](name='body'),
}

/**
  * ### Usage notes
  * > Simple Log Service allows you to create a Scheduled SQL job. For more information, see [Create a Scheduled SQL job](~~286457~~).
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   If the number of logs in a Logstore significantly changes, Simple Log Service cannot forecast the number of times that you must call this operation to obtain the complete result. In this case, you must check the value of the x-log-progress parameter in the response of each request and determine whether to call this operation one more time to obtain the complete result. Each time you call this operation, the same number of charge units (CUs) are consumed.
  * *   After a log is written to a Logstore, you can call the GetHistograms or GetLogs operation to query the log after a short latency. The latency of a query varies based on the type of the log. Simple Log Service classifies logs into the following types based on the log time:
  *         Real-time data: The difference between the time record in a log and the current time on Simple Log Service is within the interval (-180 seconds,900 seconds]. For example, if a log was generated at 12:03:00, September 25, 2014 (UTC) and Simple Log Service received the log at 12:05:00, September 25, 2014 (UTC), Simple Log Service processes the log as real-time data. This type of log is usually generated in common scenarios. 
  *     *   Historical data: The difference between the time record in a log and the current time on Simple Log Service is within the interval \\[-604,800 seconds,-180 seconds). For example, if a log was generated at 12:00:00, September 25, 2014 (UTC) and Simple Log Service received the log at 12:05:00, September 25, 2014 (UTC), Simple Log Service processes the log as historical data. This type of log is usually generated in data backfill scenarios.
  *     After real-time data is written to a Logstore, the data can be queried with a maximum latency of 3 seconds. For 99.9% of queries, the latency is no more than 1 second.
  * > Simple Log Service calculates the difference between the log time that is specified by the \\__time\\_\\_ field and the receiving time that is specified by the \\__tag\\_\\_:**receive_time** field for each log. The receiving time indicates the time at which Simple Log Service receives the log. If the difference is within the interval (-180 seconds,900 seconds], Simple Log Service processes the log as real-time data. If the difference is within the interval \\[-604,800 seconds,-180 seconds), Simple Log Service processes the log as historical data.
  * *   Simple Log Service provides examples on how to call the GetLogs operation by using Simple Log Service SDK for Java and Simple Log Service SDK for Python. For more information, see [Examples of calling the GetLogs operation by using Simple Log Service SDK for Java](~~407683~~) and [Examples of calling the GetLogs operation by using Simple Log Service SDK for Python](~~407684~~).
  *
  * @param request GetLogsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetLogsResponse
 */
async function getLogsWithOptions(project: string, logstore: string, request: GetLogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetLogsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.from)) {
    query['from'] = request.from;
  }
  if (!Util.isUnset(request.line)) {
    query['line'] = request.line;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.powerSql)) {
    query['powerSql'] = request.powerSql;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }
  if (!Util.isUnset(request.reverse)) {
    query['reverse'] = request.reverse;
  }
  if (!Util.isUnset(request.to)) {
    query['to'] = request.to;
  }
  if (!Util.isUnset(request.topic)) {
    query['topic'] = request.topic;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLogs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}?type=log`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * > Simple Log Service allows you to create a Scheduled SQL job. For more information, see [Create a Scheduled SQL job](~~286457~~).
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   If the number of logs in a Logstore significantly changes, Simple Log Service cannot forecast the number of times that you must call this operation to obtain the complete result. In this case, you must check the value of the x-log-progress parameter in the response of each request and determine whether to call this operation one more time to obtain the complete result. Each time you call this operation, the same number of charge units (CUs) are consumed.
  * *   After a log is written to a Logstore, you can call the GetHistograms or GetLogs operation to query the log after a short latency. The latency of a query varies based on the type of the log. Simple Log Service classifies logs into the following types based on the log time:
  *         Real-time data: The difference between the time record in a log and the current time on Simple Log Service is within the interval (-180 seconds,900 seconds]. For example, if a log was generated at 12:03:00, September 25, 2014 (UTC) and Simple Log Service received the log at 12:05:00, September 25, 2014 (UTC), Simple Log Service processes the log as real-time data. This type of log is usually generated in common scenarios. 
  *     *   Historical data: The difference between the time record in a log and the current time on Simple Log Service is within the interval \\[-604,800 seconds,-180 seconds). For example, if a log was generated at 12:00:00, September 25, 2014 (UTC) and Simple Log Service received the log at 12:05:00, September 25, 2014 (UTC), Simple Log Service processes the log as historical data. This type of log is usually generated in data backfill scenarios.
  *     After real-time data is written to a Logstore, the data can be queried with a maximum latency of 3 seconds. For 99.9% of queries, the latency is no more than 1 second.
  * > Simple Log Service calculates the difference between the log time that is specified by the \\__time\\_\\_ field and the receiving time that is specified by the \\__tag\\_\\_:**receive_time** field for each log. The receiving time indicates the time at which Simple Log Service receives the log. If the difference is within the interval (-180 seconds,900 seconds], Simple Log Service processes the log as real-time data. If the difference is within the interval \\[-604,800 seconds,-180 seconds), Simple Log Service processes the log as historical data.
  * *   Simple Log Service provides examples on how to call the GetLogs operation by using Simple Log Service SDK for Java and Simple Log Service SDK for Python. For more information, see [Examples of calling the GetLogs operation by using Simple Log Service SDK for Java](~~407683~~) and [Examples of calling the GetLogs operation by using Simple Log Service SDK for Python](~~407684~~).
  *
  * @param request GetLogsRequest
  * @return GetLogsResponse
 */
async function getLogs(project: string, logstore: string, request: GetLogsRequest): GetLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLogsWithOptions(project, logstore, request, headers, runtime);
}

model GetLogsV2Headers {
  commonHeaders?: map[string]string,
  acceptEncoding?: string(name='Accept-Encoding', description='The compression method.', example='lz4'),
}

model GetLogsV2Request {
  forward?: boolean(name='forward', description='Specifies whether to page forward or backward for the scan-based query or the phrase search.', example='false'),
  from?: int32(name='from', description='The beginning of the time range to query. The value is the log time that is specified when log data is written.

The time range that is specified in this operation is a left-closed, right-open interval. The interval includes the start time specified by the from parameter, but does not include the end time specified by the to parameter. If you specify the same value for the from and to parameters, the interval is invalid, and an error message is returned. The value is a UNIX timestamp representing the number of seconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1627268185'),
  highlight?: boolean(name='highlight'),
  line?: long(name='line', description='The maximum number of logs to return for the request. This parameter takes effect only when the query parameter is set to a search statement. Minimum value: 0. Maximum value: 100. Default value: 100.', example='100'),
  offset?: long(name='offset', description='The line from which the query starts. This parameter takes effect only when the query parameter is set to a search statement. Default value: 0.', example='0'),
  powerSql?: boolean(name='powerSql', description='Specifies whether to enable the SQL enhancement feature. By default, the feature is disabled.', example='false'),
  query?: string(name='query', description='The search statement or the query statement. For more information, see the "Log search overview" and "Log analysis overview" topics.

If you add set session parallel_sql=true; to the analytic statement in the query parameter, Dedicated SQL is used. For example, you can set the query parameter to \\* | set session parallel_sql=true; select count(\\*) as pv.

Note: If you specify an analytic statement in the query parameter, the line and offset parameters do not take effect in this operation. In this case, we recommend that you set the line and offset parameters to 0 and use the LIMIT clause to limit the number of logs to return on each page. For more information, see the "Perform paged queries" topic.', example='status: 401 | SELECT remote_addr,COUNT(*) as pv GROUP by remote_addr ORDER by pv desc limit 5'),
  reverse?: boolean(name='reverse', description='Specifies whether to return logs in reverse chronological order of log timestamps. The log timestamps are accurate to the minute. Valid values:

true: Logs are returned in reverse chronological order of log timestamps. false (default): Logs are returned in chronological order of log timestamps. Note: The reverse parameter takes effect only when the query parameter is set to a search statement. The reverse parameter specifies the method used to sort returned logs. If the query parameter is set to a query statement, the reverse parameter does not take effect. The method used to sort returned logs is specified by the ORDER BY clause in the analytic statement. If you use the keyword asc in the ORDER BY clause, the logs are sorted in chronological order. If you use the keyword desc in the ORDER BY clause, the logs are sorted in reverse chronological order. By default, asc is used in the ORDER BY clause.', example='false'),
  session?: string(name='session', description='The parameter that is used to query data.', example='mode=scan'),
  to?: int32(name='to', description='The end of the time range to query. The value is the log time that is specified when log data is written.

The time range that is specified in this operation is a left-closed, right-open interval. The interval includes the start time specified by the from parameter, but does not include the end time specified by the to parameter. If you specify the same value for the from and to parameters, the interval is invalid, and an error message is returned. The value is a UNIX timestamp representing the number of seconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1627268185'),
  topic?: string(name='topic', description='The topic of the logs. Default value: double quotation marks ("").', example='""'),
}

model GetLogsV2ResponseBody = {
  data?: [ map[string]string ](name='data', description='The returned result.'),
  meta?: {
    aggQuery?: string(name='aggQuery', description='The SQL statement after | in the query statement.', example='select *'),
    columnTypes?: [ string ](name='columnTypes'),
    count?: int32(name='count', description='The number of rows that are returned.', example='1'),
    cpuCores?: int32(name='cpuCores'),
    cpuSec?: double(name='cpuSec'),
    elapsedMillisecond?: long(name='elapsedMillisecond', description='The amount of time that is consumed by the request. Unit: milliseconds.', example='5'),
    hasSQL?: boolean(name='hasSQL', description='Indicates whether the query is an SQL query.', example='false'),
    highlights?: [[
      LogContent
    ]    ](name='highlights'),
    isAccurate?: boolean(name='isAccurate', description='Indicates whether the returned result is accurate.', example='true'),
    keys?: [ string ](name='keys', description='All keys in the query result.'),
    limited?: int32(name='limited'),
    mode?: int32(name='mode'),
    phraseQueryInfo?: {
      beginOffset?: long(name='beginOffset'),
      endOffset?: long(name='endOffset'),
      endTime?: long(name='endTime'),
      scanAll?: boolean(name='scanAll'),
    }(name='phraseQueryInfo'),
    processedBytes?: long(name='processedBytes', description='The number of logs that are processed in the request.', example='10000'),
    processedRows?: int32(name='processedRows', description='The number of rows that are processed in the request.', example='10000'),
    progress?: string(name='progress', description='Indicates whether the query result is complete. Valid values:

*   Complete: The query was successful, and the complete result is returned.
*   Incomplete: The query was successful, but the query result is incomplete. To obtain the complete result, you must call the operation again.', example='Complete'),
    scanBytes?: long(name='scanBytes'),
    telementryType?: string(name='telementryType', description='The type of observable data.', example='None'),
    terms?: [  map[string]any ](name='terms', description='All terms in the query statement.'),
    whereQuery?: string(name='whereQuery', description='The part before | in the query statement.', example='*'),
  }(name='meta', description='The metadata that is returned.'),
}

model GetLogsV2Response = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLogsV2ResponseBody(name='body'),
}

/**
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   If the number of logs in a Logstore significantly changes, Simple Log Service cannot predict the number of times you must call this API operation to obtain a complete result. In this case, you must check the value of the progress parameter in the response of each request and determine whether to call this operation again to obtain the complete result. Each time you call this operation, the same number of charge units (CUs) are consumed.
  * *   After a log is written to a Logstore, you can call the GetHistograms or GetLogs operation to query the log. The latency of the query varies based on the type of the log. Simple Log Service classifies logs into the following types based on log timestamps:
  * 1.  1.  Real-time data: The difference between the time record in the log and the current server time is within the interval (-180 seconds,900 seconds]. For example, if a log was generated at 12:03:00, September 25, 2014 (UTC) and the server received the log at 12:05:00, September 25, 2014 (UTC), the server processes the log as real-time data. This type of log is usually generated in common scenarios.
  * 2.  2.  Historical data: The difference between the time record in the log and the current server time is within the interval \\[-604,800 seconds,-180 seconds). For example, if a log was generated at 12:00:00, September 25, 2014 (UTC) and the server received the log at 12:05:00, September 25, 2014 (UTC), the server processes the log as historical data. This type of log is usually generated in data backfill scenarios. After real-time data is written to a Logstore, the data can be queried with a maximum latency of 3 seconds. For 99.9% of queries, the latency is no more than 1 second.
  *
  * @param request GetLogsV2Request
  * @param headers GetLogsV2Headers
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetLogsV2Response
 */
async function getLogsV2WithOptions(project: string, logstore: string, request: GetLogsV2Request, headers: GetLogsV2Headers, runtime: Util.RuntimeOptions): GetLogsV2Response {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.forward)) {
    body['forward'] = request.forward;
  }
  if (!Util.isUnset(request.from)) {
    body['from'] = request.from;
  }
  if (!Util.isUnset(request.highlight)) {
    body['highlight'] = request.highlight;
  }
  if (!Util.isUnset(request.line)) {
    body['line'] = request.line;
  }
  if (!Util.isUnset(request.offset)) {
    body['offset'] = request.offset;
  }
  if (!Util.isUnset(request.powerSql)) {
    body['powerSql'] = request.powerSql;
  }
  if (!Util.isUnset(request.query)) {
    body['query'] = request.query;
  }
  if (!Util.isUnset(request.reverse)) {
    body['reverse'] = request.reverse;
  }
  if (!Util.isUnset(request.session)) {
    body['session'] = request.session;
  }
  if (!Util.isUnset(request.to)) {
    body['to'] = request.to;
  }
  if (!Util.isUnset(request.topic)) {
    body['topic'] = request.topic;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.acceptEncoding)) {
    realHeaders['Accept-Encoding'] = Util.toJSONString(headers.acceptEncoding);
  }
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetLogsV2',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/logs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   If the number of logs in a Logstore significantly changes, Simple Log Service cannot predict the number of times you must call this API operation to obtain a complete result. In this case, you must check the value of the progress parameter in the response of each request and determine whether to call this operation again to obtain the complete result. Each time you call this operation, the same number of charge units (CUs) are consumed.
  * *   After a log is written to a Logstore, you can call the GetHistograms or GetLogs operation to query the log. The latency of the query varies based on the type of the log. Simple Log Service classifies logs into the following types based on log timestamps:
  * 1.  1.  Real-time data: The difference between the time record in the log and the current server time is within the interval (-180 seconds,900 seconds]. For example, if a log was generated at 12:03:00, September 25, 2014 (UTC) and the server received the log at 12:05:00, September 25, 2014 (UTC), the server processes the log as real-time data. This type of log is usually generated in common scenarios.
  * 2.  2.  Historical data: The difference between the time record in the log and the current server time is within the interval \\[-604,800 seconds,-180 seconds). For example, if a log was generated at 12:00:00, September 25, 2014 (UTC) and the server received the log at 12:05:00, September 25, 2014 (UTC), the server processes the log as historical data. This type of log is usually generated in data backfill scenarios. After real-time data is written to a Logstore, the data can be queried with a maximum latency of 3 seconds. For 99.9% of queries, the latency is no more than 1 second.
  *
  * @param request GetLogsV2Request
  * @return GetLogsV2Response
 */
async function getLogsV2(project: string, logstore: string, request: GetLogsV2Request): GetLogsV2Response {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetLogsV2Headers{};
  return getLogsV2WithOptions(project, logstore, request, headers, runtime);
}

model GetLogtailPipelineConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: LogtailPipelineConfig  
}

/**
  * The UK (London) region is supported. Supported regions are constantly updated.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetLogtailPipelineConfigResponse
 */
async function getLogtailPipelineConfigWithOptions(project: string, configName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLogtailPipelineConfigResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLogtailPipelineConfig',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/pipelineconfigs/${configName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * The UK (London) region is supported. Supported regions are constantly updated.
  *
  * @return GetLogtailPipelineConfigResponse
 */
async function getLogtailPipelineConfig(project: string, configName: string): GetLogtailPipelineConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLogtailPipelineConfigWithOptions(project, configName, headers, runtime);
}

model GetMLServiceResultsRequest {
  allowBuiltin?: boolean(name='allowBuiltin', example='true'),
  body?: MLServiceAnalysisParam(name='body'),
  version?: string(name='version'),
}

model GetMLServiceResultsResponseBody = {
  data?: [ map[string]string ](name='data'),
  status?: map[string]string(name='status'),
}

model GetMLServiceResultsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMLServiceResultsResponseBody(name='body'),
}

async function getMLServiceResultsWithOptions(serviceName: string, request: GetMLServiceResultsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetMLServiceResultsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.allowBuiltin)) {
    query['allowBuiltin'] = request.allowBuiltin;
  }
  if (!Util.isUnset(request.version)) {
    query['version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'GetMLServiceResults',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/service/${serviceName}/analysis`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getMLServiceResults(serviceName: string, request: GetMLServiceResultsRequest): GetMLServiceResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMLServiceResultsWithOptions(serviceName, request, headers, runtime);
}

model GetMachineGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MachineGroup  
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetMachineGroupResponse
 */
async function getMachineGroupWithOptions(project: string, machineGroup: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetMachineGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @return GetMachineGroupResponse
 */
async function getMachineGroup(project: string, machineGroup: string): GetMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMachineGroupWithOptions(project, machineGroup, headers, runtime);
}

model GetMetricStoreMeteringModeResponseBody = {
  meteringMode?: string(name='meteringMode'),
}

model GetMetricStoreMeteringModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMetricStoreMeteringModeResponseBody(name='body'),
}

async function getMetricStoreMeteringModeWithOptions(project: string, metricStore: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetMetricStoreMeteringModeResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetMetricStoreMeteringMode',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/metricstores/${metricStore}/meteringmode`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'none',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getMetricStoreMeteringMode(project: string, metricStore: string): GetMetricStoreMeteringModeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMetricStoreMeteringModeWithOptions(project, metricStore, headers, runtime);
}

model GetOSSExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OSSExport  
}

async function getOSSExportWithOptions(project: string, ossExportName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetOSSExportResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetOSSExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossexports/${ossExportName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getOSSExport(project: string, ossExportName: string): GetOSSExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getOSSExportWithOptions(project, ossExportName, headers, runtime);
}

model GetOSSHDFSExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OSSExport  
}

async function getOSSHDFSExportWithOptions(project: string, ossExportName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetOSSHDFSExportResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetOSSHDFSExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/osshdfsexports/${ossExportName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getOSSHDFSExport(project: string, ossExportName: string): GetOSSHDFSExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getOSSHDFSExportWithOptions(project, ossExportName, headers, runtime);
}

model GetOSSIngestionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OSSIngestion  
}

async function getOSSIngestionWithOptions(project: string, ossIngestionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetOSSIngestionResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetOSSIngestion',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossingestions/${ossIngestionName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getOSSIngestion(project: string, ossIngestionName: string): GetOSSIngestionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getOSSIngestionWithOptions(project, ossIngestionName, headers, runtime);
}

model GetProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Project  
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetProjectResponse
 */
async function getProjectWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetProjectResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @return GetProjectResponse
 */
async function getProject(project: string): GetProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProjectWithOptions(project, headers, runtime);
}

model GetProjectLogsRequest {
  powerSql?: boolean(name='powerSql', description='Specifies whether to enable the Dedicated SQL feature. For more information, see [Enable Dedicated SQL](~~223777~~). Valid values:

*   true
*   false (default): enables the Standard SQL feature.

You can use the powerSql or **query** parameter to configure Dedicated SQL.', example='false'),
  query?: string(name='query', description='The standard SQL statement. In this example, the SQL statement queries the number of page views (PVs) from 2022-03-01 10:41:40 to 2022-03-01 10:56:40 in a Logstore whose name is nginx-moni.', example='SELECT COUNT(*) as pv FROM nginx-moni where __time__ &gt; 1646102500 and __time__ &lt; 1646103400'),
}

model GetProjectLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [ map[string]string ](name='body'),
}

/**
  * ### Usage notes
  * *   You can use the query parameter to specify a standard SQL statement.
  * *   You must specify a project in the domain name of the request.
  * *   You must specify a Logstore in the FROM clause of the SQL statement. A Logstore can be used as an SQL table.
  * *   You must specify a time range in the SQL statement by using the \\__date\\_\\_ parameter or \\__time\\_\\_ parameter. The value of the \\__date\\_\\_ parameter is a timestamp, and the value of the \\__time\\_\\_ parameter is an integer. The unit of the \\__time\\_\\_ parameter is seconds.
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request GetProjectLogsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetProjectLogsResponse
 */
async function getProjectLogsWithOptions(project: string, request: GetProjectLogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProjectLogsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.powerSql)) {
    query['powerSql'] = request.powerSql;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProjectLogs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * *   You can use the query parameter to specify a standard SQL statement.
  * *   You must specify a project in the domain name of the request.
  * *   You must specify a Logstore in the FROM clause of the SQL statement. A Logstore can be used as an SQL table.
  * *   You must specify a time range in the SQL statement by using the \\__date\\_\\_ parameter or \\__time\\_\\_ parameter. The value of the \\__date\\_\\_ parameter is a timestamp, and the value of the \\__time\\_\\_ parameter is an integer. The unit of the \\__time\\_\\_ parameter is seconds.
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request GetProjectLogsRequest
  * @return GetProjectLogsResponse
 */
async function getProjectLogs(project: string, request: GetProjectLogsRequest): GetProjectLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProjectLogsWithOptions(project, request, headers, runtime);
}

model GetProjectPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: string(name='body'),
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetProjectPolicyResponse
 */
async function getProjectPolicyWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetProjectPolicyResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetProjectPolicy',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/policy`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'string',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @return GetProjectPolicyResponse
 */
async function getProjectPolicy(project: string): GetProjectPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProjectPolicyWithOptions(project, headers, runtime);
}

model GetSavedSearchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SavedSearch  
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetSavedSearchResponse
 */
async function getSavedSearchWithOptions(project: string, savedsearchName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetSavedSearchResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetSavedSearch',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/savedsearches/${savedsearchName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @return GetSavedSearchResponse
 */
async function getSavedSearch(project: string, savedsearchName: string): GetSavedSearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSavedSearchWithOptions(project, savedsearchName, headers, runtime);
}

model GetScheduledSQLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ScheduledSQL  
}

async function getScheduledSQLWithOptions(project: string, scheduledSQLName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetScheduledSQLResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetScheduledSQL',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/scheduledsqls/${scheduledSQLName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getScheduledSQL(project: string, scheduledSQLName: string): GetScheduledSQLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getScheduledSQLWithOptions(project, scheduledSQLName, headers, runtime);
}

model GetShipperStatusRequest {
  from?: long(name='from', description='The start time of the log shipping job. The value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1409529600'),
  offset?: int32(name='offset', description='The line from which the query starts. Default value: 0.', example='0'),
  size?: int32(name='size', description='The number of entries per page. Default value: 100. Maximum value: 500.', example='100'),
  status?: string(name='status', description='The status of the log shipping job. This parameter is empty by default, which indicates that log shipping jobs in all states are returned. Valid values: success, fail, and running.', example='success'),
  to?: long(name='to', description='The end time of the log shipping job. The value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1627269085'),
}

model GetShipperStatusResponseBody = {
  count?: long(name='count', description='The number of log shipping jobs returned on the current page.', example='10'),
  statistics?: {
    fail?: long(name='fail', description='The number of log shipping jobs that are in the fail state.', example='0'),
    running?: long(name='running', description='The number of log shipping jobs that are in the running state.', example='0'),
    success?: long(name='success', description='The number of log shipping jobs that are in the success state.', example='20'),
  }(name='statistics', description='The statistics about log shipping jobs.'),
  tasks?: {
    id?: string(name='id', description='The ID of the log shipping job.', example='abcdefghijk'),
    taskCode?: string(name='taskCode', description='The error code of the log shipping job.', example='UnAuthorized'),
    taskCreateTime?: long(name='taskCreateTime', description='The start time of the log shipping job. The value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1448925013'),
    taskDataLines?: int32(name='taskDataLines', description='The number of logs that are shipped in the log shipping job.', example='0'),
    taskFinishTime?: long(name='taskFinishTime', description='The end time of the log shipping job. The value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1448926013'),
    taskLastDataReceiveTime?: long(name='taskLastDataReceiveTime', description='The time when Simple Log Service receives the most recent log of the log shipping job. The value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1448915013'),
    taskMessage?: string(name='taskMessage', description='The error message of the log shipping job.', example='Internal server error'),
    taskStatus?: string(name='taskStatus', description='The status of the log shipping job. Valid values: running, success, and fail.', example='success'),
  }(name='tasks', description='The details of log shipping jobs.'),
  total?: long(name='total', description='The total number of log shipping jobs.', example='20'),
}

model GetShipperStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetShipperStatusResponseBody(name='body'),
}

/**
  * @deprecated
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request GetShipperStatusRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetShipperStatusResponse
 */
// Deprecated
async function getShipperStatusWithOptions(project: string, logstore: string, shipperName: string, request: GetShipperStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetShipperStatusResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.from)) {
    query['from'] = request.from;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.status)) {
    query['status'] = request.status;
  }
  if (!Util.isUnset(request.to)) {
    query['to'] = request.to;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetShipperStatus',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shipper/${shipperName}/tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * @deprecated
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request GetShipperStatusRequest
  * @return GetShipperStatusResponse
 */
// Deprecated
async function getShipperStatus(project: string, logstore: string, shipperName: string, request: GetShipperStatusRequest): GetShipperStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getShipperStatusWithOptions(project, logstore, shipperName, request, headers, runtime);
}

model GetSlsServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ServiceStatus  
}

async function getSlsServiceWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): GetSlsServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetSlsService',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/slsservice`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getSlsService(): GetSlsServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSlsServiceWithOptions(headers, runtime);
}

model GetSqlInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [ 
    {
      name?: string(name='name', example='project_name'),
      cu?: int32(name='cu', example='2'),
      createTime?: int32(name='createTime', example='1710230272'),
      updateTime?: int32(name='updateTime', example='1710230272'),
      useAsDefault?: boolean(name='useAsDefault', example='true'),
    }
  ](name='body'),
}

async function getSqlInstanceWithOptions(project: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetSqlInstanceResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetSqlInstance',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/sqlinstance`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

async function getSqlInstance(project: string): GetSqlInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSqlInstanceWithOptions(project, headers, runtime);
}

model GetStoreViewResponseBody = {
  storeType?: string(name='storeType', example='logstore'),
  stores?: [
    StoreViewStore
  ](name='stores'),
}

model GetStoreViewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetStoreViewResponseBody(name='body'),
}

async function getStoreViewWithOptions(project: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetStoreViewResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetStoreView',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/storeviews/${name}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getStoreView(project: string, name: string): GetStoreViewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getStoreViewWithOptions(project, name, headers, runtime);
}

model GetStoreViewIndexResponseBody = {
  indexes?: [ 
    {
      index?: Index(name='index'),
      logstore?: string(name='logstore', example='my-logstore'),
      project?: string(name='project', example='example-project'),
    }
  ](name='indexes'),
}

model GetStoreViewIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetStoreViewIndexResponseBody(name='body'),
}

async function getStoreViewIndexWithOptions(project: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetStoreViewIndexResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetStoreViewIndex',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/storeviews/${name}/index`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getStoreViewIndex(project: string, name: string): GetStoreViewIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getStoreViewIndexWithOptions(project, name, headers, runtime);
}

model ListAlertsRequest {
  logstore?: string(name='logstore', example='ali-test-logstore'),
  offset?: int32(name='offset', example='0'),
  size?: int32(name='size', example='10'),
}

model ListAlertsResponseBody = {
  count?: int32(name='count'),
  results?: [
    Alert
  ](name='results'),
  total?: int32(name='total'),
}

model ListAlertsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAlertsResponseBody(name='body'),
}

async function listAlertsWithOptions(project: string, request: ListAlertsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAlertsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.logstore)) {
    query['logstore'] = request.logstore;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAlerts',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/alerts`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listAlerts(project: string, request: ListAlertsRequest): ListAlertsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAlertsWithOptions(project, request, headers, runtime);
}

model ListAnnotationDataRequest {
  offset?: int32(name='offset', description='The line from which the query starts.', example='0'),
  size?: int32(name='size', description='The number of entries per page.', example='100'),
}

model ListAnnotationDataResponseBody = {
  data?: [
    MLDataParam
  ](name='data', description='The data returned.'),
  total?: int32(name='total', description='The total number of entries returned.', example='20'),
}

model ListAnnotationDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAnnotationDataResponseBody(name='body'),
}

async function listAnnotationDataWithOptions(datasetId: string, request: ListAnnotationDataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAnnotationDataResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAnnotationData',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationdataset/${datasetId}/annotationdata`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listAnnotationData(datasetId: string, request: ListAnnotationDataRequest): ListAnnotationDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAnnotationDataWithOptions(datasetId, request, headers, runtime);
}

model ListAnnotationDataSetsRequest {
  offset?: int32(name='offset', description='The line from which the query starts.', example='0'),
  size?: int32(name='size', description='The number of entries per page.', example='100'),
}

model ListAnnotationDataSetsResponseBody = {
  data?: [
    MLDataSetParam
  ](name='data', description='The data returned.'),
  total?: int32(name='total', description='The total number of entries returned.', example='20'),
}

model ListAnnotationDataSetsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAnnotationDataSetsResponseBody(name='body'),
}

async function listAnnotationDataSetsWithOptions(request: ListAnnotationDataSetsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAnnotationDataSetsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAnnotationDataSets',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationdataset`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listAnnotationDataSets(request: ListAnnotationDataSetsRequest): ListAnnotationDataSetsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAnnotationDataSetsWithOptions(request, headers, runtime);
}

model ListAnnotationLabelsRequest {
  offset?: int32(name='offset', description='The line from which the query starts.', example='0'),
  size?: int32(name='size', description='The number of entries per page.', example='100'),
}

model ListAnnotationLabelsResponseBody = {
  data?: [
    MLLabelParam
  ](name='data', description='The data returned.'),
  total?: int32(name='total', description='The total number of tags that meet the query conditions.', example='20'),
}

model ListAnnotationLabelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAnnotationLabelsResponseBody(name='body'),
}

async function listAnnotationLabelsWithOptions(request: ListAnnotationLabelsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAnnotationLabelsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAnnotationLabels',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationlabel`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listAnnotationLabels(request: ListAnnotationLabelsRequest): ListAnnotationLabelsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAnnotationLabelsWithOptions(request, headers, runtime);
}

model ListCollectionPoliciesRequest {
  attribute?: {
    app?: string(name='app', example='your-app-name'),
    policyGroup?: string(name='policyGroup', example='your-policy-group'),
  }(name='attribute'),
  dataCode?: string(name='dataCode', example='access_log'),
  instanceId?: string(name='instanceId', example='your-test-bucket1'),
  pageNum?: int32(name='pageNum', example='1'),
  pageSize?: int32(name='pageSize', example='10'),
  policyName?: string(name='policyName', example='your_log_policy'),
  productCode?: string(name='productCode', example='oss'),
}

model ListCollectionPoliciesShrinkRequest {
  attributeShrink?: string(name='attribute'),
  dataCode?: string(name='dataCode', example='access_log'),
  instanceId?: string(name='instanceId', example='your-test-bucket1'),
  pageNum?: int32(name='pageNum', example='1'),
  pageSize?: int32(name='pageSize', example='10'),
  policyName?: string(name='policyName', example='your_log_policy'),
  productCode?: string(name='productCode', example='oss'),
}

model ListCollectionPoliciesResponseBody = {
  currentCount?: int32(name='currentCount', example='1'),
  data?: [ 
    {
      attribute?: {
        app?: string(name='app', example='your-app-name'),
        policyGroup?: string(name='policyGroup', example='your-policy-group'),
      }(name='attribute'),
      centralizeConfig?: {
        destLogstore?: string(name='destLogstore', example='your-sls-logstore-in-beijing'),
        destProject?: string(name='destProject', example='your-sls-project-in-beijing'),
        destRegion?: string(name='destRegion', example='cn-beijing'),
        destTTL?: int32(name='destTTL', example='your-sls-logstore-ttl'),
      }(name='centralizeConfig'),
      centralizeEnabled?: boolean(name='centralizeEnabled', example='false'),
      dataCode?: string(name='dataCode', example='access_log'),
      enabled?: boolean(name='enabled', example='true'),
      policyConfig?: {
        instanceIds?: [ string ](name='instanceIds'),
        regions?: [ string ](name='regions'),
        resourceMode?: string(name='resourceMode', example='all'),
        resourceTags?: map[string]any(name='resourceTags'),
      }(name='policyConfig'),
      policyName?: string(name='policyName', example='your_log_policy'),
      productCode?: string(name='productCode', example='oss'),
    }
  ](name='data'),
  totalCount?: int32(name='totalCount', example='1'),
}

model ListCollectionPoliciesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCollectionPoliciesResponseBody(name='body'),
}

async function listCollectionPoliciesWithOptions(tmpReq: ListCollectionPoliciesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListCollectionPoliciesResponse {
  Util.validateModel(tmpReq);
  var request = new ListCollectionPoliciesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.attribute)) {
    request.attributeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.attribute, 'attribute', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.attributeShrink)) {
    query['attribute'] = request.attributeShrink;
  }
  if (!Util.isUnset(request.dataCode)) {
    query['dataCode'] = request.dataCode;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.policyName)) {
    query['policyName'] = request.policyName;
  }
  if (!Util.isUnset(request.productCode)) {
    query['productCode'] = request.productCode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCollectionPolicies',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/collectionpolicy`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listCollectionPolicies(request: ListCollectionPoliciesRequest): ListCollectionPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listCollectionPoliciesWithOptions(request, headers, runtime);
}

model ListConfigRequest {
  configName?: string(name='configName', description='The name of the Logtail configuration.', example='logtail-config-sample'),
  logstoreName?: string(name='logstoreName', description='The name of the Logstore.', example='ali-test-logstore'),
  offset?: long(name='offset', description='The line from which the query starts. Default value: 0.', example='0'),
  size?: long(name='size', description='The number of entries per page. Maximum value: 500.', example='10'),
}

model ListConfigResponseBody = {
  configs?: [ string ](name='configs', description='The Logtail configurations that are returned on the current page.'),
  count?: int32(name='count', description='The number of Logtail configurations that are returned on the current page.', example='3'),
  total?: int32(name='total', description='The total number of Logtail configurations that meet the query conditions.', example='2'),
}

model ListConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListConfigResponseBody(name='body'),
}

/**
  * ### [](#)Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](~~29009~~).
  * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](~~47664~~).
  * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](~~48984~~).
  *
  * @param request ListConfigRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListConfigResponse
 */
async function listConfigWithOptions(project: string, request: ListConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListConfigResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.configName)) {
    query['configName'] = request.configName;
  }
  if (!Util.isUnset(request.logstoreName)) {
    query['logstoreName'] = request.logstoreName;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListConfig',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * ### [](#)Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](~~29009~~).
  * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](~~47664~~).
  * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](~~48984~~).
  *
  * @param request ListConfigRequest
  * @return ListConfigResponse
 */
async function listConfig(project: string, request: ListConfigRequest): ListConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConfigWithOptions(project, request, headers, runtime);
}

model ListConsumerGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [
    ConsumerGroup
  ](name='body'),
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListConsumerGroupResponse
 */
async function listConsumerGroupWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListConsumerGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListConsumerGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @return ListConsumerGroupResponse
 */
async function listConsumerGroup(project: string, logstore: string): ListConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConsumerGroupWithOptions(project, logstore, headers, runtime);
}

model ListDashboardRequest {
  offset?: int32(name='offset', description='The line from which the query starts. Default value: 0.', example='0'),
  size?: int32(name='size', description='The number of entries per page. Maximum value: 500. Default value: 500.', example='10'),
}

model ListDashboardResponseBody = {
  dashboardItems?: [ 
    {
      dashboardName?: string(name='dashboardName', description='The dashboard ID. The ID must be unique in a project. Fuzzy search is supported. For example, if you enter da, all dashboards whose IDs start with da are queried.', example='dashboard-1609294922657-434834'),
      displayName?: string(name='displayName', description='The display name of the dashboard.', example='data-ingest'),
    }
  ](name='dashboardItems', description='The details of the dashboard.'),
  dashboards?: [ string ](name='dashboards', description='The queried dashboards. Each dashboard in the array is specified by dashboardName.'),
}

model ListDashboardResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDashboardResponseBody(name='body'),
}

/**
  * ### [](#)Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](~~29009~~).
  * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](~~47664~~).
  * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](~~48984~~).
  *
  * @param request ListDashboardRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListDashboardResponse
 */
async function listDashboardWithOptions(project: string, request: ListDashboardRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDashboardResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDashboard',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/dashboards`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * ### [](#)Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](~~29009~~).
  * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](~~47664~~).
  * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](~~48984~~).
  *
  * @param request ListDashboardRequest
  * @return ListDashboardResponse
 */
async function listDashboard(project: string, request: ListDashboardRequest): ListDashboardResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDashboardWithOptions(project, request, headers, runtime);
}

model ListDomainsRequest {
  domainName?: string(name='domainName', description='The domain name that is used to match custom domain names. For example, if you set domainName to `example.com`, the matched domain names are `a.example.com` and `b.example.com`.', example='example.com'),
  offset?: int32(name='offset', description='The line from which the query starts. Default value: 0.', example='0'),
  size?: int32(name='size', description='The number of entries per page. Default value: 500. Maximum value: 500.', example='10'),
}

model ListDomainsResponseBody = {
  count?: long(name='count', description='The number of domain names that are returned on the current page.', example='1'),
  domains?: [ string ](name='domains', description='The domain names.'),
  total?: long(name='total', description='The total number of domain names that are returned.', example='1'),
}

model ListDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDomainsResponseBody(name='body'),
}

/**
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   Only one custom domain name can be bound to each project.
  *
  * @param request ListDomainsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListDomainsResponse
 */
async function listDomainsWithOptions(project: string, request: ListDomainsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDomainsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.domainName)) {
    query['domainName'] = request.domainName;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDomains',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/domains`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   Only one custom domain name can be bound to each project.
  *
  * @param request ListDomainsRequest
  * @return ListDomainsResponse
 */
async function listDomains(project: string, request: ListDomainsRequest): ListDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDomainsWithOptions(project, request, headers, runtime);
}

model ListETLsRequest {
  logstore?: string(name='logstore'),
  offset?: int32(name='offset', example='0'),
  size?: int32(name='size', example='10'),
}

model ListETLsResponseBody = {
  count?: int32(name='count'),
  results?: [
    ETL
  ](name='results'),
  total?: int32(name='total'),
}

model ListETLsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListETLsResponseBody(name='body'),
}

async function listETLsWithOptions(project: string, request: ListETLsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListETLsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.logstore)) {
    query['logstore'] = request.logstore;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListETLs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/etls`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listETLs(project: string, request: ListETLsRequest): ListETLsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listETLsWithOptions(project, request, headers, runtime);
}

model ListExternalStoreRequest {
  externalStoreName?: string(name='externalStoreName', description='The name of the external store. You can query external stores that contain a specified string.', example='store'),
  offset?: int32(name='offset', description='The line from which the query starts. Default value: 0.', example='0'),
  sizs?: int32(name='sizs', description='The number of entries per page. Maximum value: 500.', example='10'),
}

model ListExternalStoreResponseBody = {
  count?: int32(name='count', description='The number of external stores returned on the current page.', example='3'),
  externalstores?: [ string ](name='externalstores', description='The names of the external stores.'),
  total?: int32(name='total', description='The number of external stores that meet the query conditions.', example='3'),
}

model ListExternalStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListExternalStoreResponseBody(name='body'),
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request ListExternalStoreRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListExternalStoreResponse
 */
async function listExternalStoreWithOptions(project: string, request: ListExternalStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListExternalStoreResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.externalStoreName)) {
    query['externalStoreName'] = request.externalStoreName;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.sizs)) {
    query['sizs'] = request.sizs;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListExternalStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/externalstores`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request ListExternalStoreRequest
  * @return ListExternalStoreResponse
 */
async function listExternalStore(project: string, request: ListExternalStoreRequest): ListExternalStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listExternalStoreWithOptions(project, request, headers, runtime);
}

model ListLogStoresRequest {
  logstoreName?: string(name='logstoreName', description='The name of the Logstore. Fuzzy match is supported. For example, if you enter test, Logstores whose name contains test are returned.', example='my-logstore'),
  mode?: string(name='mode', description='The type of the Logstore. Valid values: standard and query.

*   **standard**: Standard Logstore. This type of Logstore supports the log analysis feature and is suitable for scenarios such as real-time monitoring and interactive analysis. You can also use this type of Logstore to build a comprehensive observability system.
*   **query**: Query Logstore. This type of Logstore supports high-performance queries. The index traffic fee of a Query Logstore is approximately half that of a Standard Logstore. Query Logstores do not support SQL analysis. Query Logstores are suitable for scenarios in which the volume of data is large, the log retention period is long, or log analysis is not required. Log retention periods of weeks or months are considered long.', example='standard'),
  offset?: int32(name='offset', description='The line from which the query starts. Default value: 0.', example='0'),
  size?: int32(name='size', description='The number of entries per page. Maximum value: 500. Default value: 500.', example='10'),
  telemetryType?: string(name='telemetryType', description='The type of the data that you want to query. Valid values:

*   None: logs
*   Metrics: metrics', example='None'),
}

model ListLogStoresResponseBody = {
  count?: int32(name='count', description='The number of entries returned on the current page.', example='2'),
  logstores?: [ string ](name='logstores', description='The Logstores that meet the query conditions.', example='["test-1","test-2"]'),
  total?: int32(name='total', description='The number of the Logstores that meet the query conditions.', example='2'),
}

model ListLogStoresResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLogStoresResponseBody(name='body'),
}

/**
  * ### Usage notes
  * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](~~29009~~).
  * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](~~47664~~).
  * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](~~48984~~).
  * ### Authentication resources
  * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
  * |Action|Resource|
  * |:---|:---|
  * |`log:ListLogStores`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/*`|
  *
  * @param request ListLogStoresRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListLogStoresResponse
 */
async function listLogStoresWithOptions(project: string, request: ListLogStoresRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLogStoresResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.logstoreName)) {
    query['logstoreName'] = request.logstoreName;
  }
  if (!Util.isUnset(request.mode)) {
    query['mode'] = request.mode;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.telemetryType)) {
    query['telemetryType'] = request.telemetryType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLogStores',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * * An AccessKey pair is created and obtained. For more information, see [AccessKey pair](~~29009~~).
  * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](~~47664~~).
  * * The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](~~48984~~).
  * ### Authentication resources
  * The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
  * |Action|Resource|
  * |:---|:---|
  * |`log:ListLogStores`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/*`|
  *
  * @param request ListLogStoresRequest
  * @return ListLogStoresResponse
 */
async function listLogStores(project: string, request: ListLogStoresRequest): ListLogStoresResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLogStoresWithOptions(project, request, headers, runtime);
}

model ListLogtailPipelineConfigRequest {
  configName?: string(name='configName', description='The name of the Logtail pipeline configuration.', example='logtail-config-sample'),
  logstoreName?: string(name='logstoreName', description='The name of the Logstore.', example='test-logstore'),
  offset?: long(name='offset', description='The line from which the query starts.', example='0'),
  size?: long(name='size', description='The number of Logtail pipeline configurations per page.', example='20'),
}

model ListLogtailPipelineConfigResponseBody = {
  configs?: [ string ](name='configs', description='The Logtail pipeline configurations that are returned on the current page.'),
  count?: int32(name='count', description='The number of Logtail pipeline configurations that are returned on the current page.', example='10'),
  total?: int32(name='total', description='The total number of Logtail pipeline configurations in the current project.', example='20'),
}

model ListLogtailPipelineConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLogtailPipelineConfigResponseBody(name='body'),
}

/**
  * The UK (London) region is supported. Supported regions are constantly updated.
  *
  * @param request ListLogtailPipelineConfigRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListLogtailPipelineConfigResponse
 */
async function listLogtailPipelineConfigWithOptions(project: string, request: ListLogtailPipelineConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLogtailPipelineConfigResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.configName)) {
    query['configName'] = request.configName;
  }
  if (!Util.isUnset(request.logstoreName)) {
    query['logstoreName'] = request.logstoreName;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLogtailPipelineConfig',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/pipelineconfigs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * The UK (London) region is supported. Supported regions are constantly updated.
  *
  * @param request ListLogtailPipelineConfigRequest
  * @return ListLogtailPipelineConfigResponse
 */
async function listLogtailPipelineConfig(project: string, request: ListLogtailPipelineConfigRequest): ListLogtailPipelineConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLogtailPipelineConfigWithOptions(project, request, headers, runtime);
}

model ListMachineGroupRequest {
  groupName?: string(name='groupName', description='The name of the machine group. This parameter is used to filter machine groups. Partial match is supported.', example='test-machine-group'),
  offset?: int32(name='offset', description='The line from which the query starts. Default value: 0.', example='1'),
  size?: int32(name='size', description='The number of entries per page. Maximum value: 500.', example='10'),
}

model ListMachineGroupResponseBody = {
  count?: int32(name='count', description='The number of machine groups that are returned on the current page.', example='2'),
  machinegroups?: [ string ](name='machinegroups', description='The machine groups that meet the query conditions.', example='[ "test-machine-group-1", "test-machine-group-2" ]'),
  total?: int32(name='total', description='The total number of machine groups that meet the query conditions.', example='2'),
}

model ListMachineGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMachineGroupResponseBody(name='body'),
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request ListMachineGroupRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListMachineGroupResponse
 */
async function listMachineGroupWithOptions(project: string, request: ListMachineGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMachineGroupResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.groupName)) {
    query['groupName'] = request.groupName;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request ListMachineGroupRequest
  * @return ListMachineGroupResponse
 */
async function listMachineGroup(project: string, request: ListMachineGroupRequest): ListMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMachineGroupWithOptions(project, request, headers, runtime);
}

model ListMachinesRequest {
  offset?: int32(name='offset', description='The line from which the query starts. Default value: 0.', example='0'),
  size?: int32(name='size', description='The number of entries per page. Default value: 100. Maximum value: 500.', example='10'),
}

model ListMachinesResponseBody = {
  count?: int32(name='count', description='The number of machines that are returned on the current page.', example='3'),
  machines?: [
    Machine
  ](name='machines', description='The machines that are returned.'),
  total?: int32(name='total', description='The total number of machines.', example='8'),
}

model ListMachinesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMachinesResponseBody(name='body'),
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request ListMachinesRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListMachinesResponse
 */
async function listMachinesWithOptions(project: string, machineGroup: string, request: ListMachinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMachinesResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMachines',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}/machines`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request ListMachinesRequest
  * @return ListMachinesResponse
 */
async function listMachines(project: string, machineGroup: string, request: ListMachinesRequest): ListMachinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMachinesWithOptions(project, machineGroup, request, headers, runtime);
}

model ListOSSExportsRequest {
  logstore?: string(name='logstore'),
  offset?: int32(name='offset', example='0'),
  size?: int32(name='size', example='100'),
}

model ListOSSExportsResponseBody = {
  count?: int32(name='count', example='2'),
  results?: [
    OSSExport
  ](name='results'),
  total?: int32(name='total', example='10'),
}

model ListOSSExportsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOSSExportsResponseBody(name='body'),
}

async function listOSSExportsWithOptions(project: string, request: ListOSSExportsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListOSSExportsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.logstore)) {
    query['logstore'] = request.logstore;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOSSExports',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossexports`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listOSSExports(project: string, request: ListOSSExportsRequest): ListOSSExportsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listOSSExportsWithOptions(project, request, headers, runtime);
}

model ListOSSHDFSExportsRequest {
  logstore?: string(name='logstore'),
  offset?: int32(name='offset', example='0'),
  size?: int32(name='size', example='100'),
}

model ListOSSHDFSExportsResponseBody = {
  count?: int32(name='count', example='2'),
  results?: [
    OSSExport
  ](name='results'),
  total?: int32(name='total', example='10'),
}

model ListOSSHDFSExportsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOSSHDFSExportsResponseBody(name='body'),
}

async function listOSSHDFSExportsWithOptions(project: string, request: ListOSSHDFSExportsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListOSSHDFSExportsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.logstore)) {
    query['logstore'] = request.logstore;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOSSHDFSExports',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/osshdfsexports`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listOSSHDFSExports(project: string, request: ListOSSHDFSExportsRequest): ListOSSHDFSExportsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listOSSHDFSExportsWithOptions(project, request, headers, runtime);
}

model ListOSSIngestionsRequest {
  logstore?: string(name='logstore'),
  offset?: int32(name='offset', example='0'),
  size?: int32(name='size', example='10'),
}

model ListOSSIngestionsResponseBody = {
  count?: int32(name='count'),
  results?: [
    OSSIngestion
  ](name='results'),
  total?: int32(name='total'),
}

model ListOSSIngestionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOSSIngestionsResponseBody(name='body'),
}

async function listOSSIngestionsWithOptions(project: string, request: ListOSSIngestionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListOSSIngestionsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.logstore)) {
    query['logstore'] = request.logstore;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOSSIngestions',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossingestions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listOSSIngestions(project: string, request: ListOSSIngestionsRequest): ListOSSIngestionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listOSSIngestionsWithOptions(project, request, headers, runtime);
}

model ListProjectRequest {
  offset?: int32(name='offset', description='The line from which the query starts. Default value: 0.', example='0'),
  projectName?: string(name='projectName', description='The name of the project.', example='ali-test-project'),
  resourceGroupId?: string(name='resourceGroupId'),
  size?: int32(name='size', description='The number of entries per page. Default value: 100. This operation can return up to 500 projects.', example='10'),
}

model ListProjectResponseBody = {
  count?: long(name='count', description='The number of returned projects on the current page.', example='2'),
  projects?: [
    Project
  ](name='projects', description='The projects that meet the query conditions.'),
  total?: long(name='total', description='The total number of projects that meet the query conditions.', example='11'),
}

model ListProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListProjectResponseBody(name='body'),
}

/**
  * ### [](#)Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request ListProjectRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListProjectResponse
 */
async function listProjectWithOptions(request: ListProjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProjectResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.projectName)) {
    query['projectName'] = request.projectName;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * ### [](#)Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request ListProjectRequest
  * @return ListProjectResponse
 */
async function listProject(request: ListProjectRequest): ListProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProjectWithOptions(request, headers, runtime);
}

model ListSavedSearchRequest {
  offset?: int32(name='offset', description='The line from which the query starts. Default value: 0.', example='0'),
  size?: int32(name='size', description='The number of entries per page. Maximum value: 500.', example='10'),
}

model ListSavedSearchResponseBody = {
  count?: int32(name='count', description='The number of saved searches returned on the current page.', example='4'),
  savedsearchItems?: [
    SavedSearch
  ](name='savedsearchItems', description='The saved searches.', example='[ "test-1", "test-2" ]'),
  total?: int32(name='total', description='The total number of saved searches that meet the query conditions.', example='4'),
}

model ListSavedSearchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSavedSearchResponseBody(name='body'),
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request ListSavedSearchRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListSavedSearchResponse
 */
async function listSavedSearchWithOptions(project: string, request: ListSavedSearchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSavedSearchResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSavedSearch',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/savedsearches`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request ListSavedSearchRequest
  * @return ListSavedSearchResponse
 */
async function listSavedSearch(project: string, request: ListSavedSearchRequest): ListSavedSearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSavedSearchWithOptions(project, request, headers, runtime);
}

model ListScheduledSQLsRequest {
  logstore?: string(name='logstore'),
  offset?: long(name='offset', example='0'),
  size?: long(name='size', example='100'),
}

model ListScheduledSQLsResponseBody = {
  count?: int32(name='count', example='10'),
  results?: [
    ScheduledSQL
  ](name='results'),
  total?: int32(name='total', example='80'),
}

model ListScheduledSQLsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListScheduledSQLsResponseBody(name='body'),
}

async function listScheduledSQLsWithOptions(project: string, request: ListScheduledSQLsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListScheduledSQLsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.logstore)) {
    query['logstore'] = request.logstore;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListScheduledSQLs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/scheduledsqls`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listScheduledSQLs(project: string, request: ListScheduledSQLsRequest): ListScheduledSQLsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listScheduledSQLsWithOptions(project, request, headers, runtime);
}

model ListShardsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [
    Shard
  ](name='body'),
}

async function listShardsWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListShardsResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListShards',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shards`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

async function listShards(project: string, logstore: string): ListShardsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listShardsWithOptions(project, logstore, headers, runtime);
}

model ListShipperResponseBody = {
  count?: long(name='count', description='The number of log shipping jobs returned.', example='3'),
  shipper?: [ string ](name='shipper', description='The names of the log shipping jobs.'),
  total?: long(name='total', description='The total number of log shipping jobs.', example='5'),
}

model ListShipperResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListShipperResponseBody(name='body'),
}

/**
  * @deprecated
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListShipperResponse
 */
// Deprecated
async function listShipperWithOptions(project: string, logstore: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListShipperResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListShipper',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shipper`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * @deprecated
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @return ListShipperResponse
 */
// Deprecated
async function listShipper(project: string, logstore: string): ListShipperResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listShipperWithOptions(project, logstore, headers, runtime);
}

model ListStoreViewsRequest {
  name?: string(name='name', example='my_storeview'),
  offset?: int32(name='offset', example='0'),
  size?: int32(name='size', example='100'),
  storeType?: string(name='storeType', example='logstore'),
}

model ListStoreViewsResponseBody = {
  count?: int32(name='count', example='100'),
  storeviews?: [ string ](name='storeviews'),
  total?: int32(name='total', example='100'),
}

model ListStoreViewsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListStoreViewsResponseBody(name='body'),
}

async function listStoreViewsWithOptions(project: string, request: ListStoreViewsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListStoreViewsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.storeType)) {
    query['storeType'] = request.storeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListStoreViews',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/storeviews`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listStoreViews(project: string, request: ListStoreViewsRequest): ListStoreViewsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listStoreViewsWithOptions(project, request, headers, runtime);
}

model ListTagResourcesRequest {
  resourceId?: [ string ](name='resourceId', description='The IDs of the resources for which you want to query tags. You must specify at least one of resourceId and tags.'),
  resourceType?: string(name='resourceType', description='The type of the resource. Set the value to project.', example='project'),
  tags?: [ 
    {
      key?: string(name='key', description='The key of the tag that you want to use to filter resources. For example, if you set the key to `"test-key"`, only resources to which the key is added are returned.``', example='key1'),
      value?: string(name='value', description='The value of the tag that you want to use to filter resources. If you set the value to null, resources are filtered based only on the key of the tag.', example='value1'),
    }
  ](name='tags', description='The tags that you want to use to filter resources based on exact match. Each tag is a key-value pair. You must specify at least one of resourceId and tags.

You can enter up to 20 tags.'),
}

model ListTagResourcesShrinkRequest {
  resourceIdShrink?: string(name='resourceId', description='The IDs of the resources for which you want to query tags. You must specify at least one of resourceId and tags.'),
  resourceType?: string(name='resourceType', description='The type of the resource. Set the value to project.', example='project'),
  tagsShrink?: string(name='tags', description='The tags that you want to use to filter resources based on exact match. Each tag is a key-value pair. You must specify at least one of resourceId and tags.

You can enter up to 20 tags.'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='caeba0bbb2be03f84eb48b699f0a4883'),
  tagResources?: [ 
    {
      resourceId?: string(name='resourceId', description='The ID of the resource.', example='ali-test-project'),
      resourceType?: string(name='resourceType', description='The type of the resource.', example='project'),
      tagKey?: string(name='tagKey', description='The key of the tag.', example='key1'),
      tagValue?: string(name='tagValue', description='The value of the tag.', example='value1'),
    }
  ](name='tagResources', description='The returned tags.'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesResponseBody(name='body'),
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param tmpReq ListTagResourcesRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListTagResourcesResponse
 */
async function listTagResourcesWithOptions(tmpReq: ListTagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new ListTagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceId)) {
    request.resourceIdShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceId, 'resourceId', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'tags', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.resourceIdShrink)) {
    query['resourceId'] = request.resourceIdShrink;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['resourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['tags'] = request.tagsShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/tags`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request ListTagResourcesRequest
  * @return ListTagResourcesResponse
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagResourcesWithOptions(request, headers, runtime);
}

model MergeShardResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [
    Shard
  ](name='body'),
}

async function mergeShardWithOptions(project: string, logstore: string, shard: string, headers: map[string]string, runtime: Util.RuntimeOptions): MergeShardResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'MergeShard',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shards/${shard}?action=merge`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

async function mergeShard(project: string, logstore: string, shard: string): MergeShardResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return mergeShardWithOptions(project, logstore, shard, headers, runtime);
}

model OpenSlsServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function openSlsServiceWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): OpenSlsServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'OpenSlsService',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/slsservice`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function openSlsService(): OpenSlsServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return openSlsServiceWithOptions(headers, runtime);
}

model PutAnnotationDataRequest {
  annotationdataId?: string(name='annotationdataId', description='The unique identifier of the data.', example='2156d560fc7c01420542df92cd6365ds'),
  mlDataParam?: MLDataParam(name='mlDataParam', description='The data structure of the request.'),
  rawLog?: [ map[string]string ](name='rawLog', description='The raw log data.'),
}

model PutAnnotationDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function putAnnotationDataWithOptions(datasetId: string, request: PutAnnotationDataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutAnnotationDataResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.annotationdataId)) {
    query['annotationdataId'] = request.annotationdataId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.mlDataParam)) {
    body['mlDataParam'] = request.mlDataParam;
  }
  if (!Util.isUnset(request.rawLog)) {
    body['rawLog'] = request.rawLog;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutAnnotationData',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationdataset/${datasetId}/annotationdata`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function putAnnotationData(datasetId: string, request: PutAnnotationDataRequest): PutAnnotationDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putAnnotationDataWithOptions(datasetId, request, headers, runtime);
}

model PutProjectPolicyRequest {
  body?: string(name='body', description='The project policy.', example='{ 	"Version": "1", 	"Statement": [{ 		"Action": ["log:PostLogStoreLogs"], 		"Resource": "acs:log:*:*:project/exampleproject/*", 		"Effect": "Deny", 		"Condition": { 			"StringNotLike": { 				"acs:SourceVpc": ["vpc-*"] 			} 		} 	}] }'),
}

model PutProjectPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   Alibaba Cloud Simple Log Service allows you to configure a project policy to authorize other users to access the specified Log Service resources.
  *     *   You must configure a project policy based on policy syntax. Before you configure a project policy, you must be familiar with the Action, Resource, and Condition parameters. For more information, see [RAM](~~128139~~).
  *     *   If you set the Principal element to an asterisk (\\*) and do not configure the Condition element when you configure a project policy, the policy applies to all users except for the project owner. If you set the Principal element to an asterisk (\\*) and configure the Condition element when you configure a project policy, the policy applies to all users including the project owner.
  *     *   You can configure multiple project policies for a project. The total size of the policies cannot exceed 16 KB.
  *
  * @param request PutProjectPolicyRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return PutProjectPolicyResponse
 */
async function putProjectPolicyWithOptions(project: string, request: PutProjectPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutProjectPolicyResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'PutProjectPolicy',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/policy`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   Alibaba Cloud Simple Log Service allows you to configure a project policy to authorize other users to access the specified Log Service resources.
  *     *   You must configure a project policy based on policy syntax. Before you configure a project policy, you must be familiar with the Action, Resource, and Condition parameters. For more information, see [RAM](~~128139~~).
  *     *   If you set the Principal element to an asterisk (\\*) and do not configure the Condition element when you configure a project policy, the policy applies to all users except for the project owner. If you set the Principal element to an asterisk (\\*) and configure the Condition element when you configure a project policy, the policy applies to all users including the project owner.
  *     *   You can configure multiple project policies for a project. The total size of the policies cannot exceed 16 KB.
  *
  * @param request PutProjectPolicyRequest
  * @return PutProjectPolicyResponse
 */
async function putProjectPolicy(project: string, request: PutProjectPolicyRequest): PutProjectPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putProjectPolicyWithOptions(project, request, headers, runtime);
}

model PutProjectTransferAccelerationRequest {
  enabled?: boolean(name='enabled'),
}

model PutProjectTransferAccelerationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function putProjectTransferAccelerationWithOptions(project: string, request: PutProjectTransferAccelerationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutProjectTransferAccelerationResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.enabled)) {
    body['enabled'] = request.enabled;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutProjectTransferAcceleration',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/transferacceleration`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function putProjectTransferAcceleration(project: string, request: PutProjectTransferAccelerationRequest): PutProjectTransferAccelerationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putProjectTransferAccelerationWithOptions(project, request, headers, runtime);
}

model PutWebtrackingRequest {
  logs?: [ map[string]string ](name='__logs__', description='The logs. Each element is a JSON object that indicates a log.

>  **Note**: The time in a log that is collected by using the web tracking feature is the time at which Simple Log Service receives the log. You do not need to configure the \\__time\\_\\_ field for each log. If this field exists, it is overwritten by the time at which Simple Log Service receives the log.'),
  source?: string(name='__source__', description='The source of the logs.', example='source'),
  tags?: map[string]string(name='__tags__', description='The tags of the logs.'),
  topic?: string(name='__topic__', description='The topic of the logs.', example='topic'),
}

model PutWebtrackingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### [](#)Usage notes
  * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](~~48984~~) and [Manage a Logstore](~~48990~~).
  * *   You can call this operation to collect logs from web pages or clients.
  * *   If you use web tracking to collect logs and you do not call this operation, you can send only one log to Simple Log Service in a request. For more information, see [Use web tracking to collect logs](~~31752~~).
  * *   If you want to collect a large amount of log data, you can call this operation to send multiple logs to Simple Log Service in one request.
  * *   Before you can call this operation to send logs to a Logstore, you must enable web tracking for the Logstore. For more information, see [Use web tracking to collect logs](~~31752~~).
  * *   You cannot call this operation to send the logs of multiple topics to Simple Log Service at a time.
  * *   If you call this operation, anonymous users from the Internet are granted the write permissions on the Logstore. This may generate dirty data because AccessKey pair-based authentication is not performed.
  *
  * @param request PutWebtrackingRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return PutWebtrackingResponse
 */
async function putWebtrackingWithOptions(project: string, logstoreName: string, request: PutWebtrackingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutWebtrackingResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.logs)) {
    body['__logs__'] = request.logs;
  }
  if (!Util.isUnset(request.source)) {
    body['__source__'] = request.source;
  }
  if (!Util.isUnset(request.tags)) {
    body['__tags__'] = request.tags;
  }
  if (!Util.isUnset(request.topic)) {
    body['__topic__'] = request.topic;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutWebtracking',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstoreName}/track`,
    method = 'POST',
    authType = 'Anonymous',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### [](#)Usage notes
  * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](~~48984~~) and [Manage a Logstore](~~48990~~).
  * *   You can call this operation to collect logs from web pages or clients.
  * *   If you use web tracking to collect logs and you do not call this operation, you can send only one log to Simple Log Service in a request. For more information, see [Use web tracking to collect logs](~~31752~~).
  * *   If you want to collect a large amount of log data, you can call this operation to send multiple logs to Simple Log Service in one request.
  * *   Before you can call this operation to send logs to a Logstore, you must enable web tracking for the Logstore. For more information, see [Use web tracking to collect logs](~~31752~~).
  * *   You cannot call this operation to send the logs of multiple topics to Simple Log Service at a time.
  * *   If you call this operation, anonymous users from the Internet are granted the write permissions on the Logstore. This may generate dirty data because AccessKey pair-based authentication is not performed.
  *
  * @param request PutWebtrackingRequest
  * @return PutWebtrackingResponse
 */
async function putWebtracking(project: string, logstoreName: string, request: PutWebtrackingRequest): PutWebtrackingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putWebtrackingWithOptions(project, logstoreName, request, headers, runtime);
}

model QueryMLServiceResultsRequest {
  allowBuiltin?: boolean(name='allowBuiltin'),
  body?: MLServiceAnalysisParam(name='body'),
}

model QueryMLServiceResultsResponseBody = {
  data?: [ map[string]string ](name='data'),
  status?: map[string]string(name='status'),
}

model QueryMLServiceResultsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMLServiceResultsResponseBody(name='body'),
}

/**
  * @deprecated
  *
  * @param request QueryMLServiceResultsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return QueryMLServiceResultsResponse
 */
// Deprecated
async function queryMLServiceResultsWithOptions(serviceName: string, request: QueryMLServiceResultsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryMLServiceResultsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.allowBuiltin)) {
    query['allowBuiltin'] = request.allowBuiltin;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'QueryMLServiceResults',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/service/${serviceName}/analysis`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * @deprecated
  *
  * @param request QueryMLServiceResultsRequest
  * @return QueryMLServiceResultsResponse
 */
// Deprecated
async function queryMLServiceResults(serviceName: string, request: QueryMLServiceResultsRequest): QueryMLServiceResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryMLServiceResultsWithOptions(serviceName, request, headers, runtime);
}

model RefreshTokenRequest {
  accessTokenExpirationTime?: long(name='accessTokenExpirationTime', example='600'),
  ticket?: string(name='ticket', example='eyJ***************.eyJ******************.KUT****************'),
}

model RefreshTokenResponseBody = {
  accessToken?: string(name='accessToken', example='eyJ***************.eyJ******************.KUT****************'),
}

model RefreshTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RefreshTokenResponseBody(name='body'),
}

async function refreshTokenWithOptions(request: RefreshTokenRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RefreshTokenResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessTokenExpirationTime)) {
    query['accessTokenExpirationTime'] = request.accessTokenExpirationTime;
  }
  if (!Util.isUnset(request.ticket)) {
    query['ticket'] = request.ticket;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefreshToken',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/token/refresh`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function refreshToken(request: RefreshTokenRequest): RefreshTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return refreshTokenWithOptions(request, headers, runtime);
}

model RemoveConfigFromMachineGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return RemoveConfigFromMachineGroupResponse
 */
async function removeConfigFromMachineGroupWithOptions(project: string, machineGroup: string, configName: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveConfigFromMachineGroupResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveConfigFromMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}/configs/${configName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @return RemoveConfigFromMachineGroupResponse
 */
async function removeConfigFromMachineGroup(project: string, machineGroup: string, configName: string): RemoveConfigFromMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeConfigFromMachineGroupWithOptions(project, machineGroup, configName, headers, runtime);
}

model SplitShardRequest {
  key?: string(name='key', description='The position where the shard is split.', example='ef000000000000000000000000000000'),
  shardCount?: int32(name='shardCount', description='The number of new shards that are generated after splitting.', example='2'),
}

model SplitShardResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [
    Shard
  ](name='body'),
}

/**
  * ### Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   Each shard has an MD5 hash range, and each range is a left-closed, right-open interval. The interval is in the `[BeginKey,EndKey)` format. A shard can be in the readwrite or readonly state. You can split a shard and merge shards. For more information, see [Shard](~~28976~~).
  *
  * @param request SplitShardRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return SplitShardResponse
 */
async function splitShardWithOptions(project: string, logstore: string, shard: string, request: SplitShardRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SplitShardResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.key)) {
    query['key'] = request.key;
  }
  if (!Util.isUnset(request.shardCount)) {
    query['shardCount'] = request.shardCount;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SplitShard',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/shards/${shard}?action=split`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   Each shard has an MD5 hash range, and each range is a left-closed, right-open interval. The interval is in the `[BeginKey,EndKey)` format. A shard can be in the readwrite or readonly state. You can split a shard and merge shards. For more information, see [Shard](~~28976~~).
  *
  * @param request SplitShardRequest
  * @return SplitShardResponse
 */
async function splitShard(project: string, logstore: string, shard: string, request: SplitShardRequest): SplitShardResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return splitShardWithOptions(project, logstore, shard, request, headers, runtime);
}

model StartETLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function startETLWithOptions(project: string, etlName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartETLResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartETL',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/etls/${etlName}?action=START`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function startETL(project: string, etlName: string): StartETLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startETLWithOptions(project, etlName, headers, runtime);
}

model StartOSSExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function startOSSExportWithOptions(project: string, ossExportName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartOSSExportResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartOSSExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossexports/${ossExportName}?action=START`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function startOSSExport(project: string, ossExportName: string): StartOSSExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startOSSExportWithOptions(project, ossExportName, headers, runtime);
}

model StartOSSHDFSExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function startOSSHDFSExportWithOptions(project: string, ossExportName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartOSSHDFSExportResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartOSSHDFSExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/osshdfsexports/${ossExportName}?action=START`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function startOSSHDFSExport(project: string, ossExportName: string): StartOSSHDFSExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startOSSHDFSExportWithOptions(project, ossExportName, headers, runtime);
}

model StartOSSIngestionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function startOSSIngestionWithOptions(project: string, ossIngestionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartOSSIngestionResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartOSSIngestion',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossingestions/${ossIngestionName}?action=START`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function startOSSIngestion(project: string, ossIngestionName: string): StartOSSIngestionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startOSSIngestionWithOptions(project, ossIngestionName, headers, runtime);
}

model StopETLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function stopETLWithOptions(project: string, etlName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopETLResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopETL',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/etls/${etlName}?action=STOP`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function stopETL(project: string, etlName: string): StopETLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopETLWithOptions(project, etlName, headers, runtime);
}

model StopOSSExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function stopOSSExportWithOptions(project: string, ossExportName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopOSSExportResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopOSSExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossexports/${ossExportName}?action=STOP`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function stopOSSExport(project: string, ossExportName: string): StopOSSExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopOSSExportWithOptions(project, ossExportName, headers, runtime);
}

model StopOSSHDFSExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function stopOSSHDFSExportWithOptions(project: string, ossExportName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopOSSHDFSExportResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopOSSHDFSExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/osshdfsexports/${ossExportName}?action=STOP`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function stopOSSHDFSExport(project: string, ossExportName: string): StopOSSHDFSExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopOSSHDFSExportWithOptions(project, ossExportName, headers, runtime);
}

model StopOSSIngestionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function stopOSSIngestionWithOptions(project: string, ossIngestionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopOSSIngestionResponse {
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopOSSIngestion',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossingestions/${ossIngestionName}?action=STOP`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function stopOSSIngestion(project: string, ossIngestionName: string): StopOSSIngestionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopOSSIngestionWithOptions(project, ossIngestionName, headers, runtime);
}

model TagResourcesRequest {
  resourceId?: [ string ](name='resourceId', description='The resource IDs. You can specify only one resource and add tags to the resource.'),
  resourceType?: string(name='resourceType', description='The type of the resource. Set the value to project.', example='project'),
  tags?: [ 
    {
      key?: string(name='key', description='The key of the tag. The key must meet the following requirements:

*   The key must be `1 to 128` characters in length.
*   The key cannot contain `"http://"` or `"https://"`.
*   The key cannot start with `"acs:"` or `"aliyun"`.', example='key1'),
      value?: string(name='value', description='The value of the tag. The value must meet the following requirements:

*   The value must be `1 to 128` characters in length.
*   The value cannot contain `"http://"` or `"https://"`.', example='value1'),
    }
  ](name='tags', description='The tags that you want to add to the resource. Up to 20 tags are supported at a time. Each tag is a key-value pair.'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### Usage notes
  * Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
  *
  * @param request TagResourcesRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return TagResourcesResponse
 */
async function tagResourcesWithOptions(request: TagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.resourceId)) {
    body['resourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['resourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/tag`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
  *
  * @param request TagResourcesRequest
  * @return TagResourcesResponse
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return tagResourcesWithOptions(request, headers, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='all', example='false'),
  resourceId?: [ string ](name='resourceId', example='ali-test-project'),
  resourceType?: string(name='resourceType', example='project'),
  tags?: [ string ](name='tags'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### Usage notes
  * Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
  *
  * @param request UntagResourcesRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UntagResourcesResponse
 */
async function untagResourcesWithOptions(request: UntagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.all)) {
    body['all'] = request.all;
  }
  if (!Util.isUnset(request.resourceId)) {
    body['resourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['resourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/untag`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
  *
  * @param request UntagResourcesRequest
  * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return untagResourcesWithOptions(request, headers, runtime);
}

model UpdateAlertRequest {
  configuration?: AlertConfiguration(name='configuration'),
  description?: string(name='description'),
  displayName?: string(name='displayName'),
  schedule?: Schedule(name='schedule'),
}

model UpdateAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function updateAlertWithOptions(project: string, alertName: string, request: UpdateAlertRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAlertResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.schedule)) {
    body['schedule'] = request.schedule;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAlert',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/alerts/${alertName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function updateAlert(project: string, alertName: string, request: UpdateAlertRequest): UpdateAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAlertWithOptions(project, alertName, request, headers, runtime);
}

model UpdateAnnotationDataSetRequest {
  body?: MLDataSetParam(name='body', description='The data structure of the request.'),
}

model UpdateAnnotationDataSetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function updateAnnotationDataSetWithOptions(datasetId: string, request: UpdateAnnotationDataSetRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAnnotationDataSetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAnnotationDataSet',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationdataset/${datasetId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function updateAnnotationDataSet(datasetId: string, request: UpdateAnnotationDataSetRequest): UpdateAnnotationDataSetResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAnnotationDataSetWithOptions(datasetId, request, headers, runtime);
}

model UpdateAnnotationLabelRequest {
  body?: MLLabelParam(name='body', description='The data structure of the request.'),
}

model UpdateAnnotationLabelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * You can update only the names of the tags in a tag set.
  *
  * @param request UpdateAnnotationLabelRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateAnnotationLabelResponse
 */
async function updateAnnotationLabelWithOptions(request: UpdateAnnotationLabelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAnnotationLabelResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAnnotationLabel',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ml/annotationlabel`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * You can update only the names of the tags in a tag set.
  *
  * @param request UpdateAnnotationLabelRequest
  * @return UpdateAnnotationLabelResponse
 */
async function updateAnnotationLabel(request: UpdateAnnotationLabelRequest): UpdateAnnotationLabelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAnnotationLabelWithOptions(request, headers, runtime);
}

model UpdateConfigRequest {
  body?: LogtailConfig(name='body', description='The body of the request.'),
}

model UpdateConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### [](#)Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   After you update a Logtail configuration that is applied to a machine group, the new configuration immediately takes effect.
  * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](~~29009~~).
  * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](~~47664~~).
  * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](~~48984~~).
  * *   The Logtail configuration is planned out. For more information, see [Logtail configurations](~~29058~~).
  *
  * @param request UpdateConfigRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateConfigResponse
 */
async function updateConfigWithOptions(project: string, configName: string, request: UpdateConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateConfigResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateConfig',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/configs/${configName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### [](#)Usage notes
  * *   Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  * *   After you update a Logtail configuration that is applied to a machine group, the new configuration immediately takes effect.
  * *   An AccessKey pair is created and obtained. For more information, see [AccessKey pair](~~29009~~).
  * The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](~~47664~~).
  * *   The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](~~48984~~).
  * *   The Logtail configuration is planned out. For more information, see [Logtail configurations](~~29058~~).
  *
  * @param request UpdateConfigRequest
  * @return UpdateConfigResponse
 */
async function updateConfig(project: string, configName: string, request: UpdateConfigRequest): UpdateConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateConfigWithOptions(project, configName, request, headers, runtime);
}

model UpdateConsumerGroupRequest {
  order?: boolean(name='order', description='Specifies whether to consume data in sequence. Valid values:

*   true: If a shard is split, the data in the original shard is consumed first. Then, the data in the new shards is consumed at the same time. If shards are merged, the data in the original shards is consumed first. Then, the data in the new shard is consumed.
*   false: The data in all shards is consumed at the same time. If a new shard is generated after a shard is split or shards are merged, the data in the new shard is immediately consumed.', example='true'),
  timeout?: int32(name='timeout', description='The timeout period. If Simple Log Service does not receive heartbeats from a consumer within the timeout period, Simple Log Service deletes the consumer. Unit: seconds.', example='300'),
}

model UpdateConsumerGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request UpdateConsumerGroupRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateConsumerGroupResponse
 */
async function updateConsumerGroupWithOptions(project: string, logstore: string, consumerGroup: string, request: UpdateConsumerGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateConsumerGroupResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.order)) {
    body['order'] = request.order;
  }
  if (!Util.isUnset(request.timeout)) {
    body['timeout'] = request.timeout;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateConsumerGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/consumergroups/${consumerGroup}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request UpdateConsumerGroupRequest
  * @return UpdateConsumerGroupResponse
 */
async function updateConsumerGroup(project: string, logstore: string, consumerGroup: string, request: UpdateConsumerGroupRequest): UpdateConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateConsumerGroupWithOptions(project, logstore, consumerGroup, request, headers, runtime);
}

model UpdateDashboardRequest {
  attribute?: map[string]string(name='attribute', description='The attributes of the dashboard.'),
  charts?: [
    Chart
  ](name='charts', description='The charts on the dashboard.'),
  dashboardName?: string(name='dashboardName', description='The name of the dashboard.', example='dashboard-1609294922657-434834'),
  description?: string(name='description', description='The description of the dashboard.', example='test dashboard.'),
  displayName?: string(name='displayName', description='The display name of the dashboard.', example='Method pv'),
}

model UpdateDashboardResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### [](#)Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request UpdateDashboardRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateDashboardResponse
 */
async function updateDashboardWithOptions(project: string, dashboardName: string, request: UpdateDashboardRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDashboardResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.attribute)) {
    body['attribute'] = request.attribute;
  }
  if (!Util.isUnset(request.charts)) {
    body['charts'] = request.charts;
  }
  if (!Util.isUnset(request.dashboardName)) {
    body['dashboardName'] = request.dashboardName;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDashboard',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/dashboards/${dashboardName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### [](#)Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request UpdateDashboardRequest
  * @return UpdateDashboardResponse
 */
async function updateDashboard(project: string, dashboardName: string, request: UpdateDashboardRequest): UpdateDashboardResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDashboardWithOptions(project, dashboardName, request, headers, runtime);
}

model UpdateETLRequest {
  configuration?: ETLConfiguration(name='configuration'),
  description?: string(name='description', example='this is description'),
  displayName?: string(name='displayName', example='this is update'),
}

model UpdateETLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function updateETLWithOptions(project: string, etlName: string, request: UpdateETLRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateETLResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateETL',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/etls/${etlName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function updateETL(project: string, etlName: string, request: UpdateETLRequest): UpdateETLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateETLWithOptions(project, etlName, request, headers, runtime);
}

model UpdateIndexRequest {
  keys?: map[string]KeysValue(name='keys', description='The configuration of field indexes. A field index is a key-value pair in which the key specifies the name of the field and the value specifies the index configuration of the field.'),
  line?: {
    caseSensitive?: boolean(name='caseSensitive', description='Specifies whether to enable case sensitivity. Valid values:

*   true
*   false', example='true'),
    chn?: boolean(name='chn', description='Specifies whether to include Chinese characters. Valid values:

*   true
*   false', example='false'),
    excludeKeys?: [ string ](name='exclude_keys', description='The excluded fields. You cannot specify both include_keys and exclude_keys.'),
    includeKeys?: [ string ](name='include_keys', description='The included fields. You cannot specify both include_keys and exclude_keys.'),
    token?: [ string ](name='token', description='The delimiters that are used to split text.'),
  }(name='line', description='The configuration of full-text indexes.'),
  logReduce?: boolean(name='log_reduce', description='Specifies whether to turn on LogReduce. If you turn on LogReduce, only one of `log_reduce_white_list` and `log_reduce_black_list` takes effect.', example='false'),
  logReduceBlackList?: [ string ](name='log_reduce_black_list', description='The fields in the blacklist that you want to use to cluster logs.'),
  logReduceWhiteList?: [ string ](name='log_reduce_white_list', description='The fields in the whitelist that you want to use to cluster logs.'),
  maxTextLen?: int32(name='max_text_len', description='The maximum length of a field value that can be retained.', example='2048'),
  ttl?: int32(name='ttl', description='The retention period of data. Unit: days. Valid values: 7, 30, and 90.', example='30'),
}

model UpdateIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### Usage notes
  * Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
  *
  * @param request UpdateIndexRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateIndexResponse
 */
async function updateIndexWithOptions(project: string, logstore: string, request: UpdateIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateIndexResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.keys)) {
    body['keys'] = request.keys;
  }
  if (!Util.isUnset(request.line)) {
    body['line'] = request.line;
  }
  if (!Util.isUnset(request.logReduce)) {
    body['log_reduce'] = request.logReduce;
  }
  if (!Util.isUnset(request.logReduceBlackList)) {
    body['log_reduce_black_list'] = request.logReduceBlackList;
  }
  if (!Util.isUnset(request.logReduceWhiteList)) {
    body['log_reduce_white_list'] = request.logReduceWhiteList;
  }
  if (!Util.isUnset(request.maxTextLen)) {
    body['max_text_len'] = request.maxTextLen;
  }
  if (!Util.isUnset(request.ttl)) {
    body['ttl'] = request.ttl;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIndex',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/index`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
  *
  * @param request UpdateIndexRequest
  * @return UpdateIndexResponse
 */
async function updateIndex(project: string, logstore: string, request: UpdateIndexRequest): UpdateIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateIndexWithOptions(project, logstore, request, headers, runtime);
}

model UpdateLogStoreRequest {
  appendMeta?: boolean(name='appendMeta', description='Specifies whether to record public IP addresses. Default value: false. Valid values:

*   true
*   false', example='false'),
  autoSplit?: boolean(name='autoSplit', description='Specifies whether to enable automatic sharding. Valid values:

*   true
*   false', example='true'),
  enableTracking?: boolean(name='enable_tracking', description='Specifies whether to enable the web tracking feature. Default value: false. Valid values:

*   true
*   false', example='false'),
  encryptConf?: EncryptConf(name='encrypt_conf', description='The data structure of the encryption configuration.'),
  hotTtl?: int32(name='hot_ttl', description='The retention period of data in the hot storage tier of the Logstore. Minimum value: 30. Unit: day. You can specify a value that ranges from 30 to the value of ttl. Hot data that is stored for longer than the period specified by hot_ttl is converted to cold data. For more information, see [Enable hot and cold-tiered storage for a Logstore](~~308645~~).', example='60'),
  infrequentAccessTTL?: int32(name='infrequentAccessTTL'),
  logstoreName?: string(name='logstoreName', description='The name of the Logstore.', example='test-logstore'),
  maxSplitShard?: int32(name='maxSplitShard', description='The maximum number of shards into which existing shards can be automatically split. Valid values: 1 to 64.

> If you set autoSplit to true, you must specify maxSplitShard.', example='64'),
  mode?: string(name='mode', description='The type of the Logstore. Simple Log Service provides two types of Logstores: Standard Logstores and Query Logstores.

*   **standard**: Standard Logstore. This type of Logstore supports the log analysis feature and is suitable for scenarios such as real-time monitoring and interactive analysis. You can also use this type of Logstore to build a comprehensive observability system.
*   **query**: Query Logstore. This type of Logstore supports high-performance queries. The index traffic fee of a Query Logstore is approximately half that of a Standard Logstore. Query Logstores do not support SQL analysis. Query Logstores are suitable for scenarios in which the volume of data is large, the log retention period is long, or log analysis is not required. Log retention periods of weeks or months are considered long.', example='standard'),
  shardCount?: int32(name='shardCount', description='The number of shards.

> You cannot call the UpdateLogstore operation to change the number of shards. You can call the SplitShard or MergeShards operation to change the number of shards.', example='2', deprecated='true'),
  telemetryType?: string(name='telemetryType', description='The type of the log that you want to query. Valid values:

*   None: all types of logs.
*   Metrics: metrics.', example='None', deprecated='true'),
  ttl?: int32(name='ttl', description='The retention period of data. Unit: day. Valid values: 1 to 3650. If you set ttl to 3650, data is permanently stored.', example='30'),
}

model UpdateLogStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### Usage notes
  * *   Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
  * *   You can call the UpdateLogStore operation to change only the time-to-live (TTL) attribute.
  *
  * @param request UpdateLogStoreRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateLogStoreResponse
 */
async function updateLogStoreWithOptions(project: string, logstore: string, request: UpdateLogStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogStoreResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.appendMeta)) {
    body['appendMeta'] = request.appendMeta;
  }
  if (!Util.isUnset(request.autoSplit)) {
    body['autoSplit'] = request.autoSplit;
  }
  if (!Util.isUnset(request.enableTracking)) {
    body['enable_tracking'] = request.enableTracking;
  }
  if (!Util.isUnset(request.encryptConf)) {
    body['encrypt_conf'] = request.encryptConf;
  }
  if (!Util.isUnset(request.hotTtl)) {
    body['hot_ttl'] = request.hotTtl;
  }
  if (!Util.isUnset(request.infrequentAccessTTL)) {
    body['infrequentAccessTTL'] = request.infrequentAccessTTL;
  }
  if (!Util.isUnset(request.logstoreName)) {
    body['logstoreName'] = request.logstoreName;
  }
  if (!Util.isUnset(request.maxSplitShard)) {
    body['maxSplitShard'] = request.maxSplitShard;
  }
  if (!Util.isUnset(request.mode)) {
    body['mode'] = request.mode;
  }
  if (!Util.isUnset(request.shardCount)) {
    body['shardCount'] = request.shardCount;
  }
  if (!Util.isUnset(request.telemetryType)) {
    body['telemetryType'] = request.telemetryType;
  }
  if (!Util.isUnset(request.ttl)) {
    body['ttl'] = request.ttl;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * *   Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
  * *   You can call the UpdateLogStore operation to change only the time-to-live (TTL) attribute.
  *
  * @param request UpdateLogStoreRequest
  * @return UpdateLogStoreResponse
 */
async function updateLogStore(project: string, logstore: string, request: UpdateLogStoreRequest): UpdateLogStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogStoreWithOptions(project, logstore, request, headers, runtime);
}

model UpdateLogStoreMeteringModeRequest {
  meteringMode?: string(name='meteringMode', example='ChargeByFunction'),
}

model UpdateLogStoreMeteringModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function updateLogStoreMeteringModeWithOptions(project: string, logstore: string, request: UpdateLogStoreMeteringModeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogStoreMeteringModeResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.meteringMode)) {
    body['meteringMode'] = request.meteringMode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogStoreMeteringMode',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logstores/${logstore}/meteringmode`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function updateLogStoreMeteringMode(project: string, logstore: string, request: UpdateLogStoreMeteringModeRequest): UpdateLogStoreMeteringModeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogStoreMeteringModeWithOptions(project, logstore, request, headers, runtime);
}

model UpdateLoggingRequest {
  loggingDetails?: [ 
    {
      logstore?: string(name='logstore', description='The name of the Logstore to which you want to save service logs.', example='my-logstore'),
      type?: string(name='type', description='The type of service logs. Valid values:

*   consumergroup_log: the consumption delay logs of consumer groups.
*   logtail_alarm: the alert logs of Logtail.
*   operation_log: the operation logs.
*   logtail_profile: the collection logs of Logtail.
*   metering: the metering logs.
*   logtail_status: the status logs of Logtail.
*   scheduledsqlalert: the operational logs of Scheduled SQL jobs.
*   etl_alert: the operational logs of data transformation jobs.', example='consumergroup_log'),
    }
  ](name='loggingDetails', description='The configurations of service logs.'),
  loggingProject?: string(name='loggingProject', description='The name of the project to which you want to save service logs.', example='my-project'),
}

model UpdateLoggingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request UpdateLoggingRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateLoggingResponse
 */
async function updateLoggingWithOptions(project: string, request: UpdateLoggingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLoggingResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.loggingDetails)) {
    body['loggingDetails'] = request.loggingDetails;
  }
  if (!Util.isUnset(request.loggingProject)) {
    body['loggingProject'] = request.loggingProject;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogging',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/logging`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request UpdateLoggingRequest
  * @return UpdateLoggingResponse
 */
async function updateLogging(project: string, request: UpdateLoggingRequest): UpdateLoggingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLoggingWithOptions(project, request, headers, runtime);
}

model UpdateLogtailPipelineConfigRequest {
  aggregators?: [  map[string]any ](name='aggregators', description='The aggregation plug-ins.'),
  configName?: string(name='configName', description='The name of the configuration.', example='test-config'),
  flushers?: [  map[string]any ](name='flushers', description='The data output plug-ins.'),
  global?: map[string]any(name='global', description='The global configuration.'),
  inputs?: [  map[string]any ](name='inputs', description='The data source plug-ins.'),
  logSample?: string(name='logSample', description='The sample log.', example='2022-06-14 11:13:29.796 | DEBUG    | __main__:<module>:1 - hello world'),
  processors?: [  map[string]any ](name='processors', description='The processing plug-ins.'),
}

model UpdateLogtailPipelineConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * The UK (London) region is supported. Supported regions are constantly updated.
  *
  * @param request UpdateLogtailPipelineConfigRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateLogtailPipelineConfigResponse
 */
async function updateLogtailPipelineConfigWithOptions(project: string, configName: string, request: UpdateLogtailPipelineConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogtailPipelineConfigResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.aggregators)) {
    body['aggregators'] = request.aggregators;
  }
  if (!Util.isUnset(request.configName)) {
    body['configName'] = request.configName;
  }
  if (!Util.isUnset(request.flushers)) {
    body['flushers'] = request.flushers;
  }
  if (!Util.isUnset(request.global)) {
    body['global'] = request.global;
  }
  if (!Util.isUnset(request.inputs)) {
    body['inputs'] = request.inputs;
  }
  if (!Util.isUnset(request.logSample)) {
    body['logSample'] = request.logSample;
  }
  if (!Util.isUnset(request.processors)) {
    body['processors'] = request.processors;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogtailPipelineConfig',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/pipelineconfigs/${configName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * The UK (London) region is supported. Supported regions are constantly updated.
  *
  * @param request UpdateLogtailPipelineConfigRequest
  * @return UpdateLogtailPipelineConfigResponse
 */
async function updateLogtailPipelineConfig(project: string, configName: string, request: UpdateLogtailPipelineConfigRequest): UpdateLogtailPipelineConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogtailPipelineConfigWithOptions(project, configName, request, headers, runtime);
}

model UpdateMachineGroupRequest {
  groupAttribute?: {
    externalName?: string(name='externalName', description='The identifier of the external management system on which the machine group depends. This parameter is empty by default.', example='testgroup2'),
    groupTopic?: string(name='groupTopic', description='The topic of the machine group. This parameter is empty by default.', example='testtopic2'),
  }(name='groupAttribute', description='The attribute of the machine group. This parameter is empty by default.'),
  groupName?: string(name='groupName', description='The name of the machine group.', example='test-machine-group'),
  groupType?: string(name='groupType', description='The type of the machine group. Set the value to an empty string.', example='""'),
  machineIdentifyType?: string(name='machineIdentifyType', description='The identifier type of the machine group. Valid values:

*   ip: The machine group uses IP addresses as identifiers.
*   userdefined: The machine group uses custom identifiers.', example='userdefined'),
  machineList?: [ string ](name='machineList', description='The identifiers of the machines in the machine group.

*   If you set machineIdentifyType to ip, enter the IP addresses of the machines.
*   If you set machineIdentifyType to userdefined, enter a custom identifier.', example='[uu_id_1，uu_id_2]'),
}

model UpdateMachineGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
  *
  * @param request UpdateMachineGroupRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateMachineGroupResponse
 */
async function updateMachineGroupWithOptions(project: string, groupName: string, request: UpdateMachineGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMachineGroupResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupAttribute)) {
    body['groupAttribute'] = request.groupAttribute;
  }
  if (!Util.isUnset(request.groupName)) {
    body['groupName'] = request.groupName;
  }
  if (!Util.isUnset(request.groupType)) {
    body['groupType'] = request.groupType;
  }
  if (!Util.isUnset(request.machineIdentifyType)) {
    body['machineIdentifyType'] = request.machineIdentifyType;
  }
  if (!Util.isUnset(request.machineList)) {
    body['machineList'] = request.machineList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMachineGroup',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${groupName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
  *
  * @param request UpdateMachineGroupRequest
  * @return UpdateMachineGroupResponse
 */
async function updateMachineGroup(project: string, groupName: string, request: UpdateMachineGroupRequest): UpdateMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMachineGroupWithOptions(project, groupName, request, headers, runtime);
}

model UpdateMachineGroupMachineRequest {
  action?: string(name='action', description='The operation on the machine. Valid values: add and delete. A value of add specifies to add the machine to the machine group. A value of delete specifies to remove the machine from the machine group.', example='add'),
  body?: [ string ](name='body', description='The machines to be added or removed.'),
}

model UpdateMachineGroupMachineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request UpdateMachineGroupMachineRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateMachineGroupMachineResponse
 */
async function updateMachineGroupMachineWithOptions(project: string, machineGroup: string, request: UpdateMachineGroupMachineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMachineGroupMachineResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var query : map[string]any = {};
  if (!Util.isUnset(request.action)) {
    query['action'] = request.action;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateMachineGroupMachine',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/machinegroups/${machineGroup}/machines`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request UpdateMachineGroupMachineRequest
  * @return UpdateMachineGroupMachineResponse
 */
async function updateMachineGroupMachine(project: string, machineGroup: string, request: UpdateMachineGroupMachineRequest): UpdateMachineGroupMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMachineGroupMachineWithOptions(project, machineGroup, request, headers, runtime);
}

model UpdateMetricStoreMeteringModeRequest {
  meteringMode?: string(name='meteringMode', example='ChargeByFunction'),
}

model UpdateMetricStoreMeteringModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function updateMetricStoreMeteringModeWithOptions(project: string, metricStore: string, request: UpdateMetricStoreMeteringModeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMetricStoreMeteringModeResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.meteringMode)) {
    body['meteringMode'] = request.meteringMode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMetricStoreMeteringMode',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/metricstores/${metricStore}/meteringmode`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function updateMetricStoreMeteringMode(project: string, metricStore: string, request: UpdateMetricStoreMeteringModeRequest): UpdateMetricStoreMeteringModeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMetricStoreMeteringModeWithOptions(project, metricStore, request, headers, runtime);
}

model UpdateOSSExportRequest {
  configuration?: OSSExportConfiguration(name='configuration'),
  description?: string(name='description'),
  displayName?: string(name='displayName', example='ali-test-oss-job'),
}

model UpdateOSSExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function updateOSSExportWithOptions(project: string, ossExportName: string, request: UpdateOSSExportRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateOSSExportResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOSSExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossexports/${ossExportName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function updateOSSExport(project: string, ossExportName: string, request: UpdateOSSExportRequest): UpdateOSSExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateOSSExportWithOptions(project, ossExportName, request, headers, runtime);
}

model UpdateOSSHDFSExportRequest {
  configuration?: OSSExportConfiguration(name='configuration'),
  description?: string(name='description'),
  displayName?: string(name='displayName', example='ali-test-oss-hdfs-job'),
}

model UpdateOSSHDFSExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function updateOSSHDFSExportWithOptions(project: string, ossExportName: string, request: UpdateOSSHDFSExportRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateOSSHDFSExportResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOSSHDFSExport',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/osshdfsexports/${ossExportName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function updateOSSHDFSExport(project: string, ossExportName: string, request: UpdateOSSHDFSExportRequest): UpdateOSSHDFSExportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateOSSHDFSExportWithOptions(project, ossExportName, request, headers, runtime);
}

model UpdateOSSIngestionRequest {
  configuration?: OSSIngestionConfiguration(name='configuration'),
  description?: string(name='description'),
  displayName?: string(name='displayName'),
  schedule?: Schedule(name='schedule'),
}

model UpdateOSSIngestionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function updateOSSIngestionWithOptions(project: string, ossIngestionName: string, request: UpdateOSSIngestionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateOSSIngestionResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.schedule)) {
    body['schedule'] = request.schedule;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOSSIngestion',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/ossingestions/${ossIngestionName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function updateOSSIngestion(project: string, ossIngestionName: string, request: UpdateOSSIngestionRequest): UpdateOSSIngestionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateOSSIngestionWithOptions(project, ossIngestionName, request, headers, runtime);
}

model UpdateOssExternalStoreRequest {
  externalStoreName?: string(name='externalStoreName', description='The name of the external store.', example='test-oss-store'),
  parameter?: {
    accessid?: string(name='accessid', description='The AccessKey ID of your account.', example='LTAI5tFsHGGeYry*****1Sz'),
    accesskey?: string(name='accesskey', description='The AccessKey secret of your account.', example='GyviCLDVHkHrOztdkxuE6******Rp6'),
    bucket?: string(name='bucket', description='The name of the OSS bucket.', example='my-bucket'),
    columns?: [ 
      {
        name?: string(name='name', description='The name of the field.', example='test'),
        type?: string(name='type', description='The type of the field.', example='varchar'),
      }
    ](name='columns', description='The fields that are associated to the external store.'),
    endpoint?: string(name='endpoint', description='The Object Storage Service (OSS) endpoint.', example='oss-cn-hangzhou.aliyuncs.com'),
    objects?: [ string ](name='objects', description='The names of the OSS objects that are associated to the external store.'),
  }(name='parameter', description='The parameters that are configured for the external store.'),
  storeType?: string(name='storeType', description='The type of the external store. Set the value to oss.', example='oss'),
}

model UpdateOssExternalStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### [](#)Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request UpdateOssExternalStoreRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateOssExternalStoreResponse
 */
async function updateOssExternalStoreWithOptions(project: string, externalStoreName: string, request: UpdateOssExternalStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateOssExternalStoreResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.externalStoreName)) {
    body['externalStoreName'] = request.externalStoreName;
  }
  if (!Util.isUnset(request.parameter)) {
    body['parameter'] = request.parameter;
  }
  if (!Util.isUnset(request.storeType)) {
    body['storeType'] = request.storeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOssExternalStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/externalstores/${externalStoreName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### [](#)Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request UpdateOssExternalStoreRequest
  * @return UpdateOssExternalStoreResponse
 */
async function updateOssExternalStore(project: string, externalStoreName: string, request: UpdateOssExternalStoreRequest): UpdateOssExternalStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateOssExternalStoreWithOptions(project, externalStoreName, request, headers, runtime);
}

model UpdateProjectRequest {
  description?: string(name='description', description='The description of the project. The default value is an empty string.', example='Description of my-project-test'),
}

model UpdateProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request UpdateProjectRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateProjectResponse
 */
async function updateProjectWithOptions(project: string, request: UpdateProjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProjectResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProject',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * ### Usage notes
  * Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
  *
  * @param request UpdateProjectRequest
  * @return UpdateProjectResponse
 */
async function updateProject(project: string, request: UpdateProjectRequest): UpdateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProjectWithOptions(project, request, headers, runtime);
}

model UpdateRdsExternalStoreRequest {
  externalStoreName?: string(name='externalStoreName', description='The name of the external store.', example='rds_store'),
  parameter?: {
    db?: string(name='db', description='The name of the database in the ApsaraDB RDS for MySQL instance.', example='meta'),
    host?: string(name='host', description='The internal or public endpoint of the ApsaraDB RDS for MySQL instance.', example='192.168.XX.XX'),
    instanceId?: string(name='instance-id', description='The ID of the ApsaraDB RDS for MySQL instance.', example='i-bp1b6c719dfa08exf****'),
    password?: string(name='password', description='The password that is used to log on to the ApsaraDB RDS for MySQL instance.', example='sfdsfldsfksfls****'),
    port?: string(name='port', description='The internal or public port of the ApsaraDB RDS for MySQL instance.', example='3306'),
    region?: string(name='region', description='The region where the ApsaraDB RDS for MySQL instance resides. Valid values: cn-qingdao, cn-beijing, and cn-hangzhou.', example='cn-qingdao'),
    table?: string(name='table', description='The name of the database table in the ApsaraDB RDS for MySQL instance.', example='join_meta'),
    username?: string(name='username', description='The username that is used to log on to the ApsaraDB RDS for MySQL instance.', example='root'),
    vpcId?: string(name='vpc-id', description='The ID of the VPC to which the ApsaraDB RDS for MySQL instance belongs.', example='vpc-bp1aevy8sofi8mh1q****'),
  }(name='parameter', description='The parameter struct.'),
  storeType?: string(name='storeType', description='The storage type. Set the value to rds-vpc, which indicates an ApsaraDB RDS for MySQL database in a virtual private cloud (VPC).', example='rds-vpc'),
}

model UpdateRdsExternalStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
  *
  * @param request UpdateRdsExternalStoreRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateRdsExternalStoreResponse
 */
async function updateRdsExternalStoreWithOptions(project: string, externalStoreName: string, request: UpdateRdsExternalStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRdsExternalStoreResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.externalStoreName)) {
    body['externalStoreName'] = request.externalStoreName;
  }
  if (!Util.isUnset(request.parameter)) {
    body['parameter'] = request.parameter;
  }
  if (!Util.isUnset(request.storeType)) {
    body['storeType'] = request.storeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRdsExternalStore',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/externalstores/${externalStoreName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

/**
  * Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
  *
  * @param request UpdateRdsExternalStoreRequest
  * @return UpdateRdsExternalStoreResponse
 */
async function updateRdsExternalStore(project: string, externalStoreName: string, request: UpdateRdsExternalStoreRequest): UpdateRdsExternalStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRdsExternalStoreWithOptions(project, externalStoreName, request, headers, runtime);
}

model UpdateSavedSearchRequest {
  displayName?: string(name='displayName', description='The display name.', example='displayname'),
  logstore?: string(name='logstore', description='The name of the Logstore to which the saved search belongs.', example='aliyun-test-logstore'),
  savedsearchName?: string(name='savedsearchName', description='The name of the saved search. The name must be 3 to 63 characters in length.', example='savedsearch-name'),
  searchQuery?: string(name='searchQuery', description='The search statement or the query statement of the saved search. A query statement consists of a search statement and an analytic statement in the Search statement|Analytic statement format.

For more information, see Log search overview and Log analysis overview.', example='*|select date_format(__time__-__time__%60, \\"%H:%i:%s\\") as time, COUNT(*) as pv group by time'),
  topic?: string(name='topic', description='The topic of the logs.', example='theme'),
}

model UpdateSavedSearchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function updateSavedSearchWithOptions(project: string, savedsearchName: string, request: UpdateSavedSearchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSavedSearchResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.logstore)) {
    body['logstore'] = request.logstore;
  }
  if (!Util.isUnset(request.savedsearchName)) {
    body['savedsearchName'] = request.savedsearchName;
  }
  if (!Util.isUnset(request.searchQuery)) {
    body['searchQuery'] = request.searchQuery;
  }
  if (!Util.isUnset(request.topic)) {
    body['topic'] = request.topic;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSavedSearch',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/savedsearches/${savedsearchName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function updateSavedSearch(project: string, savedsearchName: string, request: UpdateSavedSearchRequest): UpdateSavedSearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSavedSearchWithOptions(project, savedsearchName, request, headers, runtime);
}

model UpdateScheduledSQLRequest {
  configuration?: ScheduledSQLConfiguration(name='configuration'),
  description?: string(name='description'),
  displayName?: string(name='displayName', example='ali-test-scheduled-sql'),
  schedule?: Schedule(name='schedule'),
}

model UpdateScheduledSQLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function updateScheduledSQLWithOptions(project: string, scheduledSQLName: string, request: UpdateScheduledSQLRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateScheduledSQLResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.configuration)) {
    body['configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.schedule)) {
    body['schedule'] = request.schedule;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateScheduledSQL',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/scheduledsqls/${scheduledSQLName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function updateScheduledSQL(project: string, scheduledSQLName: string, request: UpdateScheduledSQLRequest): UpdateScheduledSQLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateScheduledSQLWithOptions(project, scheduledSQLName, request, headers, runtime);
}

model UpdateSqlInstanceRequest {
  cu?: int32(name='cu', example='2'),
  useAsDefault?: boolean(name='useAsDefault'),
}

model UpdateSqlInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function updateSqlInstanceWithOptions(project: string, request: UpdateSqlInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSqlInstanceResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.cu)) {
    body['cu'] = request.cu;
  }
  if (!Util.isUnset(request.useAsDefault)) {
    body['useAsDefault'] = request.useAsDefault;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSqlInstance',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/sqlinstance`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function updateSqlInstance(project: string, request: UpdateSqlInstanceRequest): UpdateSqlInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSqlInstanceWithOptions(project, request, headers, runtime);
}

model UpdateStoreViewRequest {
  storeType?: string(name='storeType', example='logstore'),
  stores?: [
    StoreViewStore
  ](name='stores'),
}

model UpdateStoreViewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function updateStoreViewWithOptions(project: string, name: string, request: UpdateStoreViewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateStoreViewResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['project'] = project;
  var body : map[string]any = {};
  if (!Util.isUnset(request.storeType)) {
    body['storeType'] = request.storeType;
  }
  if (!Util.isUnset(request.stores)) {
    body['stores'] = request.stores;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateStoreView',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/storeviews/${name}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

async function updateStoreView(project: string, name: string, request: UpdateStoreViewRequest): UpdateStoreViewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateStoreViewWithOptions(project, name, request, headers, runtime);
}

model UpsertCollectionPolicyRequest {
  attribute?: {
    app?: string(name='app', example='your-app-name'),
    policyGroup?: string(name='policyGroup', example='your-policy-group'),
  }(name='attribute'),
  centralizeConfig?: {
    destLogstore?: string(name='destLogstore', example='your-sls-logstore-in-beijing'),
    destProject?: string(name='destProject', example='your-sls-project-in-beijing'),
    destRegion?: string(name='destRegion', example='cn-beijing'),
    destTTL?: int32(name='destTTL', example='your-sls-logstore-ttl'),
  }(name='centralizeConfig'),
  centralizeEnabled?: boolean(name='centralizeEnabled', example='false'),
  dataCode?: string(name='dataCode', example='access_log'),
  enabled?: boolean(name='enabled', example='true'),
  policyConfig?: {
    instanceIds?: [ string ](name='instanceIds'),
    regions?: [ string ](name='regions'),
    resourceMode?: string(name='resourceMode', example='all'),
    resourceTags?: map[string]any(name='resourceTags'),
  }(name='policyConfig'),
  policyName?: string(name='policyName', example='your_log_policy'),
  productCode?: string(name='productCode', example='oss'),
}

model UpsertCollectionPolicyResponseBody = {
  message?: string(name='message', example='successful'),
}

model UpsertCollectionPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpsertCollectionPolicyResponseBody(name='body'),
}

async function upsertCollectionPolicyWithOptions(request: UpsertCollectionPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpsertCollectionPolicyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.attribute)) {
    body['attribute'] = request.attribute;
  }
  if (!Util.isUnset(request.centralizeConfig)) {
    body['centralizeConfig'] = request.centralizeConfig;
  }
  if (!Util.isUnset(request.centralizeEnabled)) {
    body['centralizeEnabled'] = request.centralizeEnabled;
  }
  if (!Util.isUnset(request.dataCode)) {
    body['dataCode'] = request.dataCode;
  }
  if (!Util.isUnset(request.enabled)) {
    body['enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.policyConfig)) {
    body['policyConfig'] = request.policyConfig;
  }
  if (!Util.isUnset(request.policyName)) {
    body['policyName'] = request.policyName;
  }
  if (!Util.isUnset(request.productCode)) {
    body['productCode'] = request.productCode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpsertCollectionPolicy',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = `/collectionpolicy`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function upsertCollectionPolicy(request: UpsertCollectionPolicyRequest): UpsertCollectionPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return upsertCollectionPolicyWithOptions(request, headers, runtime);
}

