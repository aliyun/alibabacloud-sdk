/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Sls';
  @version = '2020-12-30';
  @endpointRule = 'central';
  @endpointMap = {
    ap-southeast-1 = 'sls.ap-southeast-1.aliyuncs.com',
    cn-hangzhou = 'sls.cn-hangzhou.aliyuncs.com',
    cn-hongkong = 'sls.cn-hongkong.aliyuncs.com',
    cn-huhehaote = 'sls.cn-huhehaote.aliyuncs.com',
    cn-shanghai = 'sls.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'sls.cn-shenzhen.aliyuncs.com',
    cn-zhangjiakou = 'sls.cn-zhangjiakou.aliyuncs.com',
    eu-central-1 = 'sls.eu-central-1.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model ConsumerGroup {
  name?: string(name='name', description='consumerGroup'),
  order?: boolean(name='order', description='order'),
  timeout?: int32(name='timeout', description='timeout'),
}

model EncryptConf {
  enable: boolean(name='enable', description='enable'),
  encryptType?: string(name='encrypt_type', description='加密算法，只支持default和m4。当 enable 为 true 时，此项必选。'),
  userCmkInfo?: EncryptUserCmkConf(name='user_cmk_info'),
}

model EncryptUserCmkConf {
  arn: string(name='arn', description='arn'),
  cmkKeyId: string(name='cmk_key_id', description='cmk_key_id'),
  regionId: string(name='region_id', description='region_id'),
}

model SavedSearch {
  displayName: string(name='displayName', description='displayName'),
  logstore: string(name='logstore', description='logstore'),
  savedsearchName: string(name='savedsearchName', description='savedsearchName'),
  searchQuery: string(name='searchQuery', description='searchQuery'),
  topic?: string(name='topic', description='topic'),
}

model Chart {
  action?: map[string]string(name='action', description='action'),
  display: {
    height: long(name='height', description='高度'),
    width: long(name='width', description='宽度'),
    xAxis?: [ string ](name='xAxis', description='x 轴'),
    xPos: long(name='xPos', description='x 坐标'),
    yAxis?: [ string ](name='yAxis', description='y 轴'),
    yPos: long(name='yPos', description='y 坐标'),
  }(name='display', description='图表的显示配置'),
  search: {
    end: string(name='end', description='结束时间'),
    logstore: string(name='logstore', description='logstore 名称'),
    query: string(name='query', description='查询语句'),
    start: string(name='start', description='开始时间'),
    topic: string(name='topic', description='topic'),
  }(name='search', description='查询配置'),
  title: string(name='title', description='图表标题'),
  type: string(name='type', description='图标类型'),
}

model Config {
  configName: string(name='configName', description='configName'),
  createTime?: long(name='createTime', description='创建时间'),
  inputDetail: {
    adjustTimezone?: boolean(name='adjustTimezone', description='adjustTimezone'),
    delayAlarmBytes?: long(name='delayAlarmBytes', description='delayAlarmBytes'),
    enableTag: boolean(name='enableTag', description='enableTag'),
    filePattern?: string(name='filePattern', description='filePattern'),
    filterKey?: [ string ](name='filterKey', description='filterKey'),
    filterRegex?: [ string ](name='filterRegex', description='filterRegex'),
    localStorage: boolean(name='localStorage', description='localStorage'),
    logBeginRegex?: string(name='logBeginRegex', description='logBeginRegex'),
    logPath?: string(name='logPath', description='logPath'),
    logTimezone?: string(name='logTimezone', description='logTimezone'),
    logType?: string(name='logType', description='logType'),
    maxSendRate?: int32(name='maxSendRate', description='maxSendRate'),
    mergeType?: string(name='mergeType', description='mergeType'),
    priority?: int32(name='priority', description='priority'),
    sendRateExpire?: int32(name='sendRateExpire', description='sendRateExpire'),
    sensitiveKeys?: [ 
      {
        all: boolean(name='all', description='all'),
        key: string(name='key', description='key'),
        regexBegin: string(name='regex_begin', description='regex_begin'),
        regexContent: string(name='regex_content', description='regex_content'),
        type: string(name='type', description='type'),
      }
    ](name='sensitive_keys', description='sensitive_keys'),
    shardHashKey?: [ string ](name='shardHashKey', description='shardHashKey'),
    timeFormat?: string(name='timeFormat', description='timeFormat'),
    topicFormat?: string(name='topicFormat', description='topicFormat'),
  }(name='inputDetail', description='inputDetail'),
  inputType: string(name='inputType', description='inputType'),
  lastModifyTime?: long(name='lastModifyTime', description='修改时间'),
  logSample?: string(name='logSample', description='日志样例'),
  outputDetail: {
    endpoint: string(name='endpoint', description='endpoint'),
    logstore: string(name='logstore', description='logstore'),
  }(name='outputDetail', description='outputDetail'),
  outputType: string(name='outputType', description='outputType'),
}

model Dashboard {
  attribute?: map[string]string(name='attribute', description='属性值'),
  charts: [
    Chart
  ](name='charts', description='包含的图表'),
  dashboardName: string(name='dashboardName', description='内部名称'),
  description?: string(name='description', description='描述信息'),
  displayName: string(name='displayName', description='展示名称'),
}

model EtlJob {
  enable: boolean(name='enable', description='是否启用'),
  etlJobName?: string(name='etlJobName', description='任务名称'),
  functionConfig: {
    accountId?: string(name='accountId', description='账户 id'),
    endpoint?: string(name='endpoint', description='endpoint'),
    functionName?: string(name='functionName', description='函数名'),
    functionProvider: string(name='functionProvider', description='函数 provider'),
    regionName?: string(name='regionName', description='地域'),
    roleArn?: string(name='roleArn', description='角色授权'),
    serviceName?: string(name='serviceName', description='服务名'),
  }(name='functionConfig', description='运行函数配置'),
  functionParameter: map[string]string(name='functionParameter', description='参数列表'),
  logConfig: {
    endpoint: string(name='endpoint', description='endpoint'),
    logstoreName: string(name='logstoreName', description='logstore 名称'),
    projectName: string(name='projectName', description='project 名称'),
  }(name='logConfig', description='日志配置'),
  sourceConfig?: {
    logstoreName: string(name='logstoreName', description='logstore 名称'),
  }(name='sourceConfig', description='配置数据来源'),
  triggerConfig: {
    maxRetryTime: int32(name='maxRetryTime', description='最大重试次数'),
    roleArn: string(name='roleArn', description='角色授权配置'),
    startingPosition: string(name='startingPosition', description='开始位置'),
    startingUnixtime?: long(name='startingUnixtime', description='开始时间'),
    triggerInterval: int32(name='triggerInterval', description='触发间隔'),
  }(name='triggerConfig', description='触发器配置'),
}

model EtlMeta {
  enable: boolean(name='enable', description='是否启用'),
  etlMetaKey: string(name='etlMetaKey', description='key'),
  etlMetaName: string(name='etlMetaName', description='名字'),
  etlMetaTag?: string(name='etlMetaTag', description='tag'),
  etlMetaValue?: map[string]string(name='etlMetaValue', description='value'),
}

model ExternalStore {
  externalStoreName: string(name='externalStoreName', description='名称'),
  parameter: {
    db?: string(name='db', description='meta'),
    host?: string(name='host', description='192.168.XX.XX'),
    instanceId?: string(name='instance-id', description='RDS MySQL实例ID。'),
    password?: string(name='password', description='sfdsfldsfksfls****'),
    port?: string(name='port', description='3306'),
    region?: string(name='region', description='cn-qingdao'),
    table?: string(name='table', description='join_meta'),
    username?: string(name='username', description='root'),
    vpcId?: string(name='vpc-id', description='RDS MySQL实例所属的VPC ID。'),
  }(name='parameter', description='参数'),
  storeType: string(name='storeType', description='类型'),
}

model Logging {
  loggingDetails: [ 
    {
      logstore: string(name='logstore', description='logstore 名称。'),
      type: string(name='type', description='logging 类型。'),
    }
  ](name='loggingDetails', description='logging 配置项'),
  loggingProject: string(name='loggingProject', description='project 名称。'),
}

model Logstore {
  appendMeta?: boolean(name='appendMeta', description='接收日志后，自动添加客户端外网IP和日志到达时间'),
  autoSplit?: boolean(name='autoSplit', description='是否开启 shard 自动分裂。当写入数据量超过已有分区（Shard）写入服务能力且持续5分钟以上时，开启自动分裂功能可自动根据数据量增加分区数量'),
  createTime?: int32(name='createTime', description='创建时间。'),
  enableTracking?: boolean(name='enable_tracking', description='WebTracking功能支持快速采集各种浏览器以及iOS/Android/APP访问信息，默认关闭'),
  encryptConf?: EncryptConf(name='encrypt_conf', description='Encrypt configuration'),
  hotTtl?: int32(name='hot_ttl', description='必须在 (30, ttl) 之间'),
  lastModifyTime?: int32(name='lastModifyTime', description='最后修改时间。'),
  logstoreName: string(name='logstoreName', description='logstore 的名称。'),
  maxSplitShard?: int32(name='maxSplitShard', description='最大 shard 数量。'),
  shardCount: int32(name='shardCount', description='shard 数量。'),
  telemetryType?: string(name='telemetryType', description='telemetryType'),
  ttl: int32(name='ttl', description='数据保存的天数。'),
}

model Machine {
  ip: string(name='ip', description='ip 地址'),
  lastHeartbeatTime: long(name='lastHeartbeatTime', description='上次心跳时间'),
  machineUniqueid: string(name='machine-uniqueid', description='机器的唯一标识'),
  userdefinedId?: string(name='userdefined-id', description='用户自定义标识'),
}

model MachineGroup {
  groupAttribute?: {
    externalName?: string(name='externalName', description='机器组所依赖的外部管理系统标识。'),
    groupTopic?: string(name='groupTopic', description='机器组的日志主题。'),
  }(name='groupAttribute', description='机器组属性。'),
  groupName: string(name='groupName', description='机器组名称。'),
  groupType?: string(name='groupType', description='机器组种类。'),
  machineIdentifyType: string(name='machineIdentifyType', description='机器组标识种类，支持 IP 标识或者用户自定义标识，即 ip 、userdefined。'),
  machineList: [ string ](name='machineList', description='机器组标识列表。'),
}

model OssExternalStore {
  externalStoreName: string(name='externalStoreName', description='名称'),
  parameter: {
    accessKey: string(name='accessKey', description='您的AccessKey Secret。'),
    accessid: string(name='accessid', description='您的AccessKey ID。'),
    bucket: string(name='bucket', description='oss 桶名称。'),
    endpoint: string(name='endpoint', description='oss 的 endpoint 访问网址。'),
  }(name='parameter', description='参数'),
  storeType: string(name='storeType', description='类型。这里固定为 oss'),
}

model Project {
  createTime?: string(name='createTime', description='创建时间'),
  description?: string(name='description', description='描述'),
  lastModifyTime?: string(name='lastModifyTime', description='最后更新时间'),
  owner?: string(name='owner', description='owner'),
  projectName?: string(name='projectName', description='Project名称'),
  region?: string(name='region', description='所在区域'),
  status?: string(name='status', description='状态'),
}

model Shard {
  createTime?: int32(name='createTime', description='Shard的创建时间。Unix时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。'),
  exclusiveEndKey?: string(name='exclusiveEndKey', description='指定Shard范围的结束值，Shard范围中不包含该值。即 shard 包含MD5值在 [inclusiveBeginKey, exclusiveEndKey) 之间的日志。'),
  inclusiveBeginKey?: string(name='inclusiveBeginKey', description='指定Shard范围的起始值，Shard范围中包含该值。即 shard 包含MD5值在 [inclusiveBeginKey, exclusiveEndKey) 之间的日志。'),
  shardID?: int32(name='shardID', description='shard id'),
  status?: string(name='status', description='shard 的读写状态，readwrite 或者 readonly。'),
}

model CreateConsumerGroupRequest {
  logstore: string(name='logstore', position='Path'),
  consumerGroup: string(name='consumerGroup', position='Body'),
  order: boolean(name='order', position='Body'),
  timeout: int32(name='timeout', position='Body'),
  project: string(name='project', position='Host'),
}

model CreateConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
}

async function createConsumerGroup(request: CreateConsumerGroupRequest): CreateConsumerGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateConsumerGroup', 'POST', '/logstores/{logstore}/consumergroups', 'none', false, 'json', request);
}

model CreateIndexRequest {
  logstore: string(name='logstore', position='Path'),
  keys?: map[string]KeysValue(name='keys', position='Body'),
  line?: {
    caseSensitive?: boolean(name='caseSensitive', description='大小写敏感'),
    chn?: boolean(name='chn', description='包含中文'),
    excludeKeys?: [ string ](name='exclude_keys', description='排除的字段列表，不能与include_keys同时指定。'),
    includeKeys?: [ string ](name='include_keys', description='包含的字段列表，不能与exclude_keys同时指定。'),
    token: [ string ](name='token', description='分词符列表。可以设置一个分词参数，指定这个字段按照哪一种方式分词。'),
  }(name='line', description='配置全文索引', position='Body'),
  logReduce?: boolean(name='log_reduce', description='开启日志聚类，开启后白名单与黑名单至多生效其中一个。', position='Body'),
  logReduceBlackList?: [ string ](name='log_reduce_black_list', description='日志聚类的聚类字段黑名单', position='Body'),
  logReduceWhiteList?: [ string ](name='log_reduce_white_list', description='日志聚类的聚类字段白名单', position='Body'),
  maxTextLen?: int32(name='max_text_len', description='统计字段的最大长度', position='Body'),
  ttl?: int32(name='ttl', description='保存时间，单位为天', position='Body'),
  project: string(name='project', position='Host'),
}

model CreateIndexResponse = {
  headers: map[string]string(name='headers'),
}

async function createIndex(request: CreateIndexRequest): CreateIndexResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateIndex', 'POST', '/logstores/{logstore}/index', 'none', false, 'json', request);
}

model CreateLogStoreRequest {
  appendMeta?: boolean(name='appendMeta', position='Body'),
  autoSplit?: boolean(name='autoSplit', position='Body'),
  enableTracking?: boolean(name='enable_tracking', position='Body'),
  encryptConf?: EncryptConf(name='encrypt_conf', position='Body'),
  hotTtl?: int32(name='hot_ttl', position='Body'),
  logstoreName: string(name='logstoreName', position='Body'),
  maxSplitShard?: int32(name='maxSplitShard', position='Body'),
  shardCount: int32(name='shardCount', position='Body'),
  telemetryType?: string(name='telemetryType', position='Body'),
  ttl: int32(name='ttl', position='Body'),
  project: string(name='project', position='Host'),
}

model CreateLogStoreResponse = {
  headers: map[string]string(name='headers'),
}

async function createLogStore(request: CreateLogStoreRequest): CreateLogStoreResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateLogStore', 'POST', '/logstores', 'none', false, 'json', request);
}

model CreateProjectRequest {
  description: string(name='description', position='Body'),
  projectName: string(name='projectName', position='Body'),
}

model CreateProjectResponse = {
  headers: map[string]string(name='headers'),
}

async function createProject(request: CreateProjectRequest): CreateProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateProject', 'POST', '/', 'none', false, 'json', request);
}

model CreateSavedSearchRequest {
  displayName: string(name='displayName', position='Body'),
  logstore: string(name='logstore', position='Body'),
  savedsearchName: string(name='savedsearchName', position='Body'),
  searchQuery: string(name='searchQuery', position='Body'),
  topic?: string(name='topic', position='Body'),
  project: string(name='project', position='Host'),
}

model CreateSavedSearchResponse = {
  headers: map[string]string(name='headers'),
}

async function createSavedSearch(request: CreateSavedSearchRequest): CreateSavedSearchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateSavedSearch', 'POST', '/savedsearches', 'none', false, 'json', request);
}

model DeleteConsumerGroupRequest {
  logstore: string(name='logstore', description='Logstore name', position='Path'),
  consumerGroup: string(name='consumerGroup', description='Consumer group', position='Path'),
  project: string(name='project', description='Project name', position='Host'),
}

model DeleteConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteConsumerGroup(request: DeleteConsumerGroupRequest): DeleteConsumerGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteConsumerGroup', 'DELETE', '/logstores/{logstore}/consumergroups/{consumerGroup}', 'none', false, 'json', request);
}

model DeleteIndexRequest {
  logstore: string(name='logstore', description='A short description of struct', position='Path'),
  project: string(name='project', position='Host'),
}

model DeleteIndexResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteIndex(request: DeleteIndexRequest): DeleteIndexResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteIndex', 'DELETE', '/logstores/{logstore}/index', 'none', false, 'json', request);
}

model DeleteLogStoreRequest {
  logstore: string(name='logstore', description='logstore 名称', position='Path'),
  project: string(name='project', description='project 名称', position='Host'),
}

model DeleteLogStoreResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteLogStore(request: DeleteLogStoreRequest): DeleteLogStoreResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteLogStore', 'DELETE', '/logstores/{logstore}', 'none', false, 'json', request);
}

model DeleteProjectRequest {
  project: string(name='project', description='projetc 名称。', position='Host'),
}

model DeleteProjectResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteProject(request: DeleteProjectRequest): DeleteProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteProject', 'DELETE', '/', 'none', false, 'json', request);
}

model GetContextLogsRequest {
  logstore: string(name='logstore', description='logstore 名称。', position='Path'),
  backLines: long(name='back_lines', description='指定起始日志往前（上文）的日志条数，取值范围为(0,100]。', position='Query'),
  forwardLines: long(name='forward_lines', description='指定起始日志往后（下文）的日志条数，取值范围为(0,100]。', position='Query'),
  packId: string(name='pack_id', description='起始日志所属的LogGroup的唯一身份标识。', position='Query'),
  packMeta: string(name='pack_meta', description='起始日志在对应LogGroup内的唯一上下文结构标识。', position='Query'),
  project: string(name='project', description='project 名称。', position='Host'),
  type: string(name='type', description='Logstore中数据的类型。该接口中该参数固定为context_log。', position='Query'),
}

model GetContextLogsResponseBody = {
  backLines?: long(name='back_lines', description='向前查询到的日志条数。'),
  forwardLines?: long(name='forward_lines', description='向后查询到的日志条数。'),
  logs?: [  map[string]any ](name='logs', description='获取到的日志，按上下文顺序排列。当根据指定起始日志查询不到上下文日志时，此参数为空。'),
  progress?: string(name='progress', description='查询的结果是否完整。
Complete：查询已经完成，返回结果为完整结果。
Incomplete：查询已经完成，返回结果为不完整结果，需要重复请求以获得完整结果。'),
  totalLines?: long(name='total_lines', description='返回的总日志条数，包含请求参数中所指定的起始日志。'),
}

model GetContextLogsResponse = {
  headers: map[string]string(name='headers'),
  body: GetContextLogsResponseBody(name='body'),
}

async function getContextLogs(request: GetContextLogsRequest): GetContextLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetContextLogs', 'GET', '/logstores/{logstore}', 'json', false, 'json', request);
}

model GetCursorRequest {
  logstore: string(name='logstore', description='logstore 名称。', position='Path'),
  shardId: int32(name='shardId', description='shard id。', position='Path'),
  from: string(name='from', description='时间点（Unix时间戳）或者字符串begin、end。', position='Query'),
  project: string(name='project', description='project 名称。', position='Host'),
  type: string(name='type', description='这里固定为 cursor。', position='Query'),
}

model GetCursorResponseBody = {
  cursor?: string(name='cursor', description='游标位置。'),
}

model GetCursorResponse = {
  headers: map[string]string(name='headers'),
  body: GetCursorResponseBody(name='body'),
}

async function getCursor(request: GetCursorRequest): GetCursorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetCursor', 'GET', '/logstores/{logstore}/shards/{shardId}', 'json', false, 'json', request);
}

model GetCursorTimeRequest {
  logstore: string(name='logstore', description='logstore 名称。', position='Path'),
  shardId: int32(name='shardId', description='shard id。', position='Path'),
  cursor: string(name='cursor', description='游标。', position='Query'),
  project: string(name='project', description='project 名称。', position='Host'),
  type: string(name='type', description='固定为 cursor_time 。', position='Query'),
}

model GetCursorTimeResponseBody = {
  cursorTime?: string(name='cursor_time', description='Cursor的服务端时间。Unix时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。'),
}

model GetCursorTimeResponse = {
  headers: map[string]string(name='headers'),
  body: GetCursorTimeResponseBody(name='body'),
}

async function getCursorTime(request: GetCursorTimeRequest): GetCursorTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetCursorTime', 'GET', '/logstores/{logstore}/shards/{shardId}', 'json', false, 'json', request);
}

model GetHistogramsRequest {
  logstore: string(name='logstore', description='logstore 名称。', position='Path'),
  from: long(name='from', description='查询开始时间点。UNIX时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。

时间区间遵循“左闭右开”原则，即该时间区间包括区间开始时间点，但不包括区间结束时间点。如果from和to的值相同，则为无效区间，函数直接返回错误。', position='Query'),
  project: string(name='project', description='project 名称。', position='Host'),
  query?: string(name='query', description='查询语句。仅支持查询语句，不支持分析语句。关于查询语句的详细语法，请参见查询语法。', position='Query'),
  to: long(name='to', description='查询结束时间点。UNIX时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。

时间区间遵循“左闭右开”原则，即该时间区间包括区间开始时间点，但不包括区间结束时间点。如果from和to的值相同，则为无效区间，函数直接返回错误。', position='Query'),
  topic?: string(name='topic', description='日志主题。', position='Query'),
  type: string(name='type', description='Logstore中数据的类型。该接口中固定取值为histogram。', position='Query'),
}

model GetHistogramsResponse = {
  headers: map[string]string(name='headers'),
  body: [ 
    {
      from?: long(name='from', description='子时间区间的开始时间点。UNIX时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。

时间区间遵循“左闭右开”原则，即该时间区间包括区间开始时间点，但不包括区间结束时间点。如果from和to的值相同，则为无效区间，函数直接返回错误。'),
      to?: long(name='to', description='子时间区间的结束时间点。UNIX时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。

时间区间遵循“左闭右开”原则，即该时间区间包括区间开始时间点，但不包括区间结束时间点。如果from和to的值相同，则为无效区间，函数直接返回错误。'),
      count?: long(name='count', description='该子时间区间内查询到的日志条数。'),
      progress?: string(name='progress', description='当前查询结果在该子时间区间内的结果是否完整。

Complete：查询已经完成，返回结果为完整结果。

Incomplete：查询已经完成，返回结果为不完整结果，需要重复请求以获得完整结果。'),
    }
  ](name='body'),
}

async function getHistograms(request: GetHistogramsRequest): GetHistogramsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetHistograms', 'GET', '/logstores/{logstore}/index', 'json', false, 'json', request);
}

model GetIndexRequest {
  logstore: string(name='logstore', description='logstore 名称。', position='Path'),
  project: string(name='project', description='project 名称。', position='Host'),
}

model GetIndexResponseBody = {
  indexMode?: string(name='index_mode', description='索引模式'),
  keys?: map[string]KeysValue(name='keys', description='字段索引配置。key为字段名称，value为索引配置。'),
  lastModifyTime?: long(name='lastModifyTime', description='上次修改时间'),
  line?: {
    caseSensitive?: boolean(name='caseSensitive', description='大小写敏感'),
    chn?: boolean(name='chn', description='是否包含中文。'),
    excludeKeys?: [ string ](name='exclude_keys', description='排除的字段列表。'),
    includeKeys?: [ string ](name='include_keys', description='包含的字段列表。'),
    token?: [ string ](name='token', description='分词符列表。'),
  }(name='line', description='配置全文索引。'),
  logReduce?: boolean(name='log_reduce', description='是否开启日志聚类.'),
  logReduceBlackList?: [ string ](name='log_reduce_black_list', description='日志聚类的聚类字段过滤黑名单，仅当日志聚类开启时有效。'),
  logReduceWhiteList?: [ string ](name='log_reduce_white_list', description='日志聚类的聚类字段过滤白名单，仅当日志聚类开启时有效。'),
  maxTextLen?: int32(name='max_text_len', description='日志服务默认字段值的最大长度为2048字节，即2 KB。如果您需要修改字段值的最大长度，可设置统计字段（text）最大长度，取值范围为64~16384字节。'),
  storage?: string(name='storage', description='存储类型，目前固定取值为pg。'),
  ttl?: int32(name='ttl', description='索引文件生命周期，支持7天、30天、90天。'),
}

model GetIndexResponse = {
  headers: map[string]string(name='headers'),
  body: GetIndexResponseBody(name='body'),
}

async function getIndex(request: GetIndexRequest): GetIndexResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetIndex', 'GET', '/logstores/{logstore}/index', 'json', false, 'json', request);
}

model GetLogStoreRequest {
  logstore: string(name='logstore', description='The logstore name.', position='Path'),
  project: string(name='project', position='Host'),
}

model GetLogStoreResponse = {
  headers: map[string]string(name='headers'),
  body: Logstore  
}

async function getLogStore(request: GetLogStoreRequest): GetLogStoreResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetLogStore', 'GET', '/logstores/{logstore}', 'json', false, 'json', request);
}

model GetLogsRequest {
  logstore: string(name='logstore', description='logstore 名称。', position='Path'),
  from: long(name='from', description='查询开始时间点。该时间是指写入日志数据时指定的日志时间。

请求参数from和to定义的时间区间遵循左闭右开原则，即该时间区间包括区间开始时间点，但不包括区间结束时间点。如果from和to的值相同，则为无效区间，函数直接返回错误。
Unix时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。', position='Query'),
  line?: long(name='line', description='仅当query参数为查询语句时，该参数有效，表示请求返回的最大日志条数。最小值为0，最大值为100，默认值为100。', minimum=0, maximum=100, position='Query'),
  offset?: long(name='offset', description='仅当query参数为查询语句时，该参数有效，表示查询开始行。默认值为0。', position='Query'),
  powerSql?: boolean(name='powerSql', description='用于指定返回结果是否按日志时间戳降序返回日志，精确到分钟级别。

true：按照日志时间戳降序返回日志。
false（默认值）：按照日志时间戳升序返回日志。
注意
当query参数为查询语句时，参数reverse有效，用于指定返回日志排序方式。
当query参数为查询和分析语句时，参数reverse无效，由SQL分析语句中order by语法指定排序方式。如果order by为asc（默认），则为升序；如果order by为desc，则为降序。', position='Query'),
  project: string(name='project', description='project 名称。', position='Host'),
  query: string(name='query', description='查询语句或者分析语句。更多信息，请参见查询概述和分析概述。

在query参数的分析语句中加上set session parallel_sql=true;，表示使用SQL独享版。例如* | set session parallel_sql=true; select count(*) as pv 。

说明 当query参数中有分析语句（SQL语句）时，该接口的line参数和offset参数无效，建议设置为0，需通过SQL语句的LIMIT语法实现翻页。更多信息，请参见分页显示查询分析结果。', position='Query'),
  reverse?: boolean(name='reverse', description='用于指定返回结果是否按日志时间戳降序返回日志，精确到分钟级别。

true：按照日志时间戳降序返回日志。
false（默认值）：按照日志时间戳升序返回日志。
注意
当query参数为查询语句时，参数reverse有效，用于指定返回日志排序方式。
当query参数为查询和分析语句时，参数reverse无效，由SQL分析语句中order by语法指定排序方式。如果order by为asc（默认），则为升序；如果order by为desc，则为降序。', position='Query'),
  to: long(name='to', description='查询结束时间点。该时间是指写入日志数据时指定的日志时间。

请求参数from和to定义的时间区间遵循左闭右开原则，即该时间区间包括区间开始时间点，但不包括区间结束时间点。如果from和to的值相同，则为无效区间，函数直接返回错误。
Unix时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。', position='Query'),
  topic?: string(name='topic', description='status: 401 | SELECT remote_addr,COUNT(*) as pv GROUP by remote_addr ORDER by pv desc limit 5', position='Query'),
  type: string(name='type', description='查询Logstore数据的类型。在该接口中固定取值为log。', position='Query'),
}

model GetLogsResponse = {
  headers: map[string]string(name='headers'),
  body: [  map[string]any ](name='body'),
}

async function getLogs(request: GetLogsRequest): GetLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetLogs', 'GET', '/logstores/{logstore}/index', 'json', false, 'json', request);
}

model GetProjectRequest {
  project: string(name='project', position='Host'),
}

model GetProjectResponse = {
  headers: map[string]string(name='headers'),
  body: Project  
}

async function getProject(request: GetProjectRequest): GetProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetProject', 'GET', '/', 'json', false, 'json', request);
}

model GetProjectLogsRequest {
  powerSql?: boolean(name='powerSql', description='是否使用SQL独享版。更多信息，请参见开启SQL独享版。

true：使用SQL独享版。
false（默认值）：使用SQL普通版。
除通过powerSql参数配置SQL独享版外，您还可以使用query参数。', position='Query'),
  project: string(name='project', description='project 名称。', position='Host'),
  query: string(name='query', description='标准SQL语句。例如日志库名称为nginx-moni，查询时间区间在2022-03-01 10:41:40到2022-03-01 10:56:40之间的访问数量。', position='Query'),
}

model GetProjectLogsResponse = {
  headers: map[string]string(name='headers'),
  body: [ map[string]string ](name='body'),
}

async function getProjectLogs(request: GetProjectLogsRequest): GetProjectLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetProjectLogs', 'GET', '/logs', 'json', false, 'json', request);
}

model GetSavedSearchRequest {
  savedsearchName: string(name='savedsearchName', position='Path'),
  project: string(name='project', description='A short description of struct', position='Host'),
}

model GetSavedSearchResponse = {
  headers: map[string]string(name='headers'),
  body: SavedSearch  
}

async function getSavedSearch(request: GetSavedSearchRequest): GetSavedSearchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetSavedSearch', 'GET', '/savedsearches/{savedsearchName}', 'json', false, 'json', request);
}

model ListConsumerGroupRequest {
  logstore: string(name='logstore', description='Logstore name', position='Path'),
  project: string(name='project', description='Project name', position='Host'),
}

model ListConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
  body: [
    ConsumerGroup
  ](name='body'),
}

async function listConsumerGroup(request: ListConsumerGroupRequest): ListConsumerGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListConsumerGroup', 'GET', '/logstores/{logstore}/consumergroups', 'json', false, 'json', request);
}

model ListLogStoresRequest {
  logstoreName?: string(name='logstoreName', position='Query'),
  offset?: int32(name='offset', position='Query'),
  project: string(name='project', position='Host'),
  size?: int32(name='size', position='Query'),
  telemetryType?: string(name='telemetryType', position='Query'),
}

model ListLogStoresResponseBody = {
  logstores?: [ string ](name='logstores'),
  total?: int32(name='total'),
}

model ListLogStoresResponse = {
  headers: map[string]string(name='headers'),
  body: ListLogStoresResponseBody(name='body'),
}

async function listLogStores(request: ListLogStoresRequest): ListLogStoresResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListLogStores', 'GET', '/logstores', 'json', false, 'json', request);
}

model ListProjectRequest {
  offset?: int32(name='offset', position='Query'),
  projectName?: string(name='projectName', position='Query'),
  size?: int32(name='size', position='Query'),
}

model ListProjectResponseBody = {
  count?: long(name='count'),
  projects?: [
    Project
  ](name='projects'),
  total?: long(name='total'),
}

model ListProjectResponse = {
  headers: map[string]string(name='headers'),
  body: ListProjectResponseBody(name='body'),
}

async function listProject(request: ListProjectRequest): ListProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListProject', 'GET', '/', 'json', false, 'json', request);
}

model ListSavedSearchRequest {
  offset?: int32(name='offset', position='Query'),
  project: string(name='project', description='A short description of struct', position='Host'),
  size?: int32(name='size', position='Query'),
}

model ListSavedSearchResponseBody = {
  count?: int32(name='count'),
  savedsearchItems?: [
    SavedSearch
  ](name='savedsearchItems'),
  total?: int32(name='total'),
}

model ListSavedSearchResponse = {
  headers: map[string]string(name='headers'),
  body: ListSavedSearchResponseBody(name='body'),
}

async function listSavedSearch(request: ListSavedSearchRequest): ListSavedSearchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListSavedSearch', 'GET', '/savedsearches', 'json', false, 'json', request);
}

model ListShardsRequest {
  logstore: string(name='logstore', description='logstore 名称。', position='Path'),
  project: string(name='project', description='A short description of struct', position='Host'),
}

model ListShardsResponse = {
  headers: map[string]string(name='headers'),
  body: [
    Shard
  ](name='body'),
}

async function listShards(request: ListShardsRequest): ListShardsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListShards', 'GET', '/logstores/{logstore}/shards', 'json', false, 'json', request);
}

model MergeShardsRequest {
  logstore: string(name='logstore', description='Logstore 名称。', position='Path'),
  shardID: int32(name='shardID', description='必须是readwrite状态的 shard，且其下一个相邻的 shard 也必须是 readwrite。', position='Path'),
  action: string(name='action', description='固定为 merge。', position='Query'),
  project: string(name='project', description='Project 名称。', position='Host'),
}

model MergeShardsResponse = {
  headers: map[string]string(name='headers'),
  body: [
    Shard
  ](name='body'),
}

async function mergeShards(request: MergeShardsRequest): MergeShardsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'MergeShards', 'POST', '/logstores/{logstore}/shards/{shardID}', 'json', false, 'json', request);
}

model SplitShardRequest {
  logstore: string(name='logstore', description='Logstore 名称。', position='Path'),
  shardID: int32(name='shardID', description='必须是一个 readwrite 状态的 shard 的 id。', position='Path'),
  action: string(name='action', description='这里固定为 split。', position='Query'),
  key?: string(name='key', description='分裂的位置。', position='Query'),
  project: string(name='project', description='Project 名称。', position='Host'),
  shardCount?: int32(name='shardCount', description='要分裂成的 shard 数量，默认为 2。', position='Query'),
}

model SplitShardResponse = {
  headers: map[string]string(name='headers'),
  body: [
    Shard
  ](name='body'),
}

async function splitShard(request: SplitShardRequest): SplitShardResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'SplitShard', 'POST', '/logstores/{logstore}/shards/{shardID}', 'json', false, 'json', request);
}

model UpdateConsumerGroupRequest {
  logstore: string(name='logstore', position='Path'),
  consumerGroup: string(name='consumerGroup', position='Path'),
  order?: boolean(name='order', position='Body'),
  timeout?: int32(name='timeout', position='Body'),
  project: string(name='project', position='Host'),
}

model UpdateConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
}

async function updateConsumerGroup(request: UpdateConsumerGroupRequest): UpdateConsumerGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateConsumerGroup', 'PUT', '/logstores/{logstore}/consumergroups/{consumerGroup}', 'none', false, 'json', request);
}

model UpdateIndexRequest {
  logstore: string(name='logstore', description='logstore 名称。', position='Path'),
  keys?: map[string]KeysValue(name='keys', description='字段索引配置，key为字段名称，value为字段索引配置。', position='Body'),
  line?: {
    caseSensitive: boolean(name='caseSensitive', description='大小写敏感'),
    chn: boolean(name='chn', description='包含中文'),
    excludeKeys?: [ string ](name='exclude_keys', description='排除的字段列表，不能与include_keys同时指定。'),
    includeKeys?: [ string ](name='include_keys', description='包含的字段列表，不能与exclude_keys同时指定。'),
    token: [ string ](name='token', description='分词符列表。可以设置一个分词参数，指定这个字段按照哪一种方式分词。'),
  }(name='line', description='配置全文索引。', position='Body'),
  logReduce?: boolean(name='log_reduce', description='开启日志聚类，开启后白名单与黑名单至多生效其中一个。', position='Body'),
  logReduceBlackList?: [ string ](name='log_reduce_black_list', description='日志聚类的聚类字段黑名单', position='Body'),
  logReduceWhiteList?: [ string ](name='log_reduce_white_list', description='日志聚类的聚类字段白名单', position='Body'),
  maxTextLen?: int32(name='max_text_len', description='统计字段的最大长度', position='Body'),
  ttl: int32(name='ttl', description='保存时间，单位为天', position='Body'),
  project: string(name='project', description='project 名称。', position='Host'),
}

model UpdateIndexResponse = {
  headers: map[string]string(name='headers'),
}

async function updateIndex(request: UpdateIndexRequest): UpdateIndexResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateIndex', 'PUT', '/logstores/{logstore}/index', 'none', false, 'json', request);
}

model UpdateLogStoreRequest {
  logstore: string(name='logstore', position='Path'),
  appendMeta?: boolean(name='appendMeta', position='Body'),
  autoSplit?: boolean(name='autoSplit', position='Body'),
  enableTracking?: boolean(name='enable_tracking', position='Body'),
  encryptConf?: EncryptConf(name='encrypt_conf', position='Body'),
  hotTtl?: int32(name='hot_ttl', position='Body'),
  logstoreName: string(name='logstoreName', position='Body'),
  maxSplitShard?: int32(name='maxSplitShard', position='Body'),
  shardCount: int32(name='shardCount', position='Body'),
  telemetryType?: string(name='telemetryType', position='Body'),
  ttl: int32(name='ttl', position='Body'),
  project: string(name='project', position='Host'),
}

model UpdateLogStoreResponse = {
  headers: map[string]string(name='headers'),
}

async function updateLogStore(request: UpdateLogStoreRequest): UpdateLogStoreResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateLogStore', 'PUT', '/logstores/{logstore}', 'none', false, 'json', request);
}

model UpdateProjectRequest {
  description: string(name='description', description='Project description', position='Body'),
  project: string(name='project', description='Project name', position='Host'),
}

model UpdateProjectResponse = {
  headers: map[string]string(name='headers'),
}

async function updateProject(request: UpdateProjectRequest): UpdateProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateProject', 'PUT', '/', 'none', false, 'json', request);
}

model UpdateSavedSearchRequest {
  savedsearchName: string(name='savedsearchName', position='Path,Body'),
  displayName: string(name='displayName', position='Body'),
  logstore: string(name='logstore', position='Body'),
  searchQuery: string(name='searchQuery', position='Body'),
  topic?: string(name='topic', position='Body'),
  project: string(name='project', description='Project 名称。', position='Host'),
}

model UpdateSavedSearchResponse = {
  headers: map[string]string(name='headers'),
}

async function updateSavedSearch(request: UpdateSavedSearchRequest): UpdateSavedSearchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateSavedSearch', 'PUT', '/savedsearches/{savedsearchName}', 'none', false, 'json', request);
}

model KeysValue = {
  caseSensitive?: boolean(name='caseSensitive', description='大小写敏感'),
  chn?: boolean(name='chn', description='包含中文'),
  type: string(name='type', description='字段的索引类型'),
  alias?: string(name='alias', description='别名'),
  token?: [ string ](name='token', description='分词符列表。仅当type参数取值为text时，必须设置。'),
  docValue?: boolean(name='doc_value', description='开启统计'),
}

