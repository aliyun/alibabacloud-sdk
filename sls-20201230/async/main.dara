/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Sls';
  @version = '2020-12-30';
  @endpointRule = 'central';
  @endpointMap = {
    ap-southeast-1 = 'sls.ap-southeast-1.aliyuncs.com',
    cn-hangzhou = 'sls.cn-hangzhou.aliyuncs.com',
    cn-hongkong = 'sls.cn-hongkong.aliyuncs.com',
    cn-huhehaote = 'sls.cn-huhehaote.aliyuncs.com',
    cn-shanghai = 'sls.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'sls.cn-shenzhen.aliyuncs.com',
    cn-zhangjiakou = 'sls.cn-zhangjiakou.aliyuncs.com',
    eu-central-1 = 'sls.eu-central-1.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model ConsumerGroup {
  name?: string(name='name', description='consumerGroup'),
  order?: boolean(name='order', description='order'),
  timeout?: int32(name='timeout', description='timeout'),
}

model EncryptConf {
  enable: boolean(name='enable', description='enable'),
  encryptType: string(name='encrypt_type', description='encrypt_type'),
  userCmkInfo?: EncryptUserCmkConf(name='user_cmk_info'),
}

model EncryptUserCmkConf {
  arn: string(name='arn', description='arn'),
  cmkKeyId: string(name='cmk_key_id', description='cmk_key_id'),
  regionId: string(name='region_id', description='region_id'),
}

model SavedSearch {
  displayName: string(name='displayName', description='displayName'),
  logstore: string(name='logstore', description='logstore'),
  savedsearchName: string(name='savedsearchName', description='savedsearchName'),
  searchQuery: string(name='searchQuery', description='searchQuery'),
  topic?: string(name='topic', description='topic'),
}

model Logstore {
  appendMeta?: boolean(name='appendMeta', description='append client ip and receive time'),
  autoSplit?: boolean(name='autoSplit', description='auto spilt shard'),
  createTime?: int32(name='createTime', description='create time'),
  enableTracking?: boolean(name='enable_tracking', description='enable web tracking'),
  encryptConf?: EncryptConf(name='encrypt_conf', description='Encrypt configuration'),
  hotTtl?: int32(name='hot_ttl', description='hot ttl'),
  lastModifyTime?: int32(name='lastModifyTime', description='last modify time'),
  logstoreName: string(name='logstoreName', description='logstore name'),
  maxSplitShard?: int32(name='maxSplitShard', description='max split shard'),
  shardCount?: int32(name='shardCount', description='shard count'),
  telemetryType?: string(name='telemetryType', description='telemetryType'),
  ttl: int32(name='ttl', description='ttl'),
}

model Project {
  createTime?: string(name='createTime', description='创建时间'),
  description?: string(name='description', description='描述'),
  lastModifyTime?: string(name='lastModifyTime', description='最后更新时间'),
  owner?: string(name='owner', description='owner'),
  projectName?: string(name='projectName', description='Project名称'),
  region?: string(name='region', description='所在区域'),
  status?: string(name='status', description='状态'),
}

model Shard {
  createTime?: int32(name='createTime', description='createTime'),
  exclusiveEndKey?: string(name='exclusiveEndKey', description='exclusiveEndKey'),
  inclusiveBeginKey?: string(name='inclusiveBeginKey', description='inclusiveBeginKey'),
  shardId?: int32(name='shardId', description='shard id'),
  status?: string(name='status', description='status'),
}

model CreateConsumerGroupRequest {
  logstore: string(name='logstore', position='Path'),
  consumerGroup: string(name='consumerGroup', position='Body'),
  order: boolean(name='order', position='Body'),
  timeout: int32(name='timeout', position='Body'),
  project: string(name='project', position='Host'),
}

model CreateConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
}

async function createConsumerGroup(request: CreateConsumerGroupRequest): CreateConsumerGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateConsumerGroup', 'POST', '/logstores/{logstore}/consumergroups', 'json', false, 'json', request);
}

model CreateLogStoreRequest {
  appendMeta?: boolean(name='appendMeta', position='Body'),
  autoSplit?: boolean(name='autoSplit', position='Body'),
  enableTracking?: boolean(name='enable_tracking', position='Body'),
  encryptConf?: EncryptConf(name='encrypt_conf', position='Body'),
  hotTtl?: int32(name='hot_ttl', position='Body'),
  logstoreName: string(name='logstoreName', position='Body'),
  maxSplitShard?: int32(name='maxSplitShard', position='Body'),
  shardCount: int32(name='shardCount', position='Body'),
  telemetryType?: string(name='telemetryType', position='Body'),
  ttl: int32(name='ttl', position='Body'),
  project: string(name='project', position='Host'),
}

model CreateLogStoreResponse = {
  headers: map[string]string(name='headers'),
}

async function createLogStore(request: CreateLogStoreRequest): CreateLogStoreResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateLogStore', 'POST', '/logstores', 'json', false, 'json', request);
}

model CreateProjectRequest {
  description: string(name='description', position='Body'),
  projectName: string(name='projectName', position='Body'),
}

model CreateProjectResponse = {
  headers: map[string]string(name='headers'),
}

async function createProject(request: CreateProjectRequest): CreateProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateProject', 'POST', '/', 'json', false, 'json', request);
}

model CreateSavedSearchRequest {
  displayName: string(name='displayName', position='Body'),
  logstore: string(name='logstore', position='Body'),
  savedsearchName: string(name='savedsearchName', position='Body'),
  searchQuery: string(name='searchQuery', position='Body'),
  topic?: string(name='topic', position='Body'),
  project: string(name='project', position='Host'),
}

model CreateSavedSearchResponse = {
  headers: map[string]string(name='headers'),
}

async function createSavedSearch(request: CreateSavedSearchRequest): CreateSavedSearchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateSavedSearch', 'POST', '/savedsearches', 'json', false, 'json', request);
}

model DeleteConsumerGroupRequest {
  logstore: string(name='logstore', description='Logstore name', position='Path'),
  consumerGroup: string(name='consumerGroup', description='Consumer group', position='Path'),
  project: string(name='project', description='Project name', position='Host'),
}

model DeleteConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteConsumerGroup(request: DeleteConsumerGroupRequest): DeleteConsumerGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteConsumerGroup', 'DELETE', '/logstores/{logstore}/consumergroups/{consumerGroup}', 'json', false, 'json', request);
}

model DeleteProjectRequest {
  project: string(name='project', position='Host'),
}

model DeleteProjectResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteProject(request: DeleteProjectRequest): DeleteProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteProject', 'DELETE', '/', 'json', false, 'json', request);
}

model DeleteSavedSearchRequest {
  savedsearchName?: string(name='savedsearchName', position='Path'),
  project?: string(name='project', description='A short description of struct', position='Host'),
}

model DeleteSavedSearchResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteSavedSearch(request: DeleteSavedSearchRequest): DeleteSavedSearchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteSavedSearch', 'DELETE', '/savedsearches/{savedsearchName}', 'json', false, 'json', request);
}

model GetLogStoreRequest {
  logstore: string(name='logstore', description='The logstore name.', position='Path'),
  project: string(name='project', position='Host'),
}

model GetLogStoreResponse = {
  headers: map[string]string(name='headers'),
  body: Logstore  
}

async function getLogStore(request: GetLogStoreRequest): GetLogStoreResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetLogStore', 'GET', '/logstores/{logstore}', 'json', false, 'json', request);
}

model GetProjectRequest {
  project: string(name='project', position='Host'),
}

model GetProjectResponse = {
  headers: map[string]string(name='headers'),
  body: Project  
}

async function getProject(request: GetProjectRequest): GetProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetProject', 'GET', '/', 'json', false, 'json', request);
}

model GetSavedSearchRequest {
  savedsearchName?: string(name='savedsearchName', position='Path'),
  project?: string(name='project', description='A short description of struct', position='Host'),
}

model GetSavedSearchResponse = {
  headers: map[string]string(name='headers'),
  body: SavedSearch  
}

async function getSavedSearch(request: GetSavedSearchRequest): GetSavedSearchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetSavedSearch', 'GET', '/savedsearches/{savedsearchName}', 'json', false, 'json', request);
}

model ListConsumerGroupRequest {
  logstore: string(name='logstore', description='Logstore name', position='Path'),
  project: string(name='project', description='Project name', position='Host'),
}

model ListConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
  body: [
    ConsumerGroup
  ](name='body'),
}

async function listConsumerGroup(request: ListConsumerGroupRequest): ListConsumerGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListConsumerGroup', 'GET', '/logstores/{logstore}/consumergroups', 'json', false, 'json', request);
}

model ListLogStoresRequest {
  logstoreName?: string(name='logstoreName', position='Query'),
  offset?: int32(name='offset', position='Query'),
  project: string(name='project', position='Host'),
  size?: int32(name='size', position='Query'),
  telemetryType?: string(name='telemetryType', position='Query'),
}

model ListLogStoresResponseBody = {
  logstores?: [ string ](name='logstores'),
  total?: int32(name='total'),
}

model ListLogStoresResponse = {
  headers: map[string]string(name='headers'),
  body: ListLogStoresResponseBody(name='body'),
}

async function listLogStores(request: ListLogStoresRequest): ListLogStoresResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListLogStores', 'GET', '/logstores', 'json', false, 'json', request);
}

model ListProjectRequest {
  offset?: int32(name='offset', position='Query'),
  projectName?: string(name='projectName', position='Query'),
  size?: int32(name='size', position='Query'),
}

model ListProjectResponseBody = {
  count?: long(name='count'),
  projects?: [
    Project
  ](name='projects'),
  total?: long(name='total'),
}

model ListProjectResponse = {
  headers: map[string]string(name='headers'),
  body: ListProjectResponseBody(name='body'),
}

async function listProject(request: ListProjectRequest): ListProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListProject', 'GET', '/', 'json', false, 'json', request);
}

model ListSavedSearchRequest {
  offset?: int32(name='offset', position='Query'),
  project: string(name='project', description='A short description of struct', position='Host'),
  size?: int32(name='size', position='Query'),
}

model ListSavedSearchResponseBody = {
  count?: int32(name='count'),
  savedsearchItems?: [
    SavedSearch
  ](name='savedsearchItems'),
  total?: int32(name='total'),
}

model ListSavedSearchResponse = {
  headers: map[string]string(name='headers'),
  body: ListSavedSearchResponseBody(name='body'),
}

async function listSavedSearch(request: ListSavedSearchRequest): ListSavedSearchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListSavedSearch', 'GET', '/savedsearches', 'json', false, 'json', request);
}

model UpdateConsumerGroupRequest {
  logstore: string(name='logstore', position='Path'),
  consumerGroup?: string(name='consumerGroup', position='Path'),
  order?: boolean(name='order', position='Body'),
  timeout?: int32(name='timeout', position='Body'),
  project: string(name='project', position='Host'),
}

model UpdateConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
}

async function updateConsumerGroup(request: UpdateConsumerGroupRequest): UpdateConsumerGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateConsumerGroup', 'PUT', '/logstores/{logstore}/consumergroups/{consumerGroup}', 'json', false, 'json', request);
}

model UpdateLogStoreRequest {
  logstore: string(name='logstore', position='Path'),
  appendMeta?: boolean(name='appendMeta', position='Body'),
  autoSplit?: boolean(name='autoSplit', position='Body'),
  enableTracking?: boolean(name='enable_tracking', position='Body'),
  encryptConf?: EncryptConf(name='encrypt_conf', position='Body'),
  hotTtl?: int32(name='hot_ttl', position='Body'),
  logstoreName: string(name='logstoreName', position='Body'),
  maxSplitShard?: int32(name='maxSplitShard', position='Body'),
  shardCount?: int32(name='shardCount', position='Body'),
  telemetryType?: string(name='telemetryType', position='Body'),
  ttl: int32(name='ttl', position='Body'),
  project: string(name='project', position='Host'),
}

model UpdateLogStoreResponse = {
  headers: map[string]string(name='headers'),
}

async function updateLogStore(request: UpdateLogStoreRequest): UpdateLogStoreResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateLogStore', 'PUT', '/logstores/{logstore}', 'json', false, 'json', request);
}

model UpdateProjectRequest {
  description?: string(name='description', description='Project description', position='Body'),
  project?: string(name='project', description='Project name', position='Host'),
}

model UpdateProjectResponse = {
  headers: map[string]string(name='headers'),
}

async function updateProject(request: UpdateProjectRequest): UpdateProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateProject', 'PUT', '/', 'json', false, 'json', request);
}

