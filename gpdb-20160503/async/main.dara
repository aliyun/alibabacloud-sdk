/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'gpdb';
  @version = '2016-05-03';
  @endpointRule = 'regional';
  @endpointMap = {
    cn-beijing = 'gpdb.aliyuncs.com',
    cn-hangzhou = 'gpdb.aliyuncs.com',
    cn-shanghai = 'gpdb.aliyuncs.com',
    cn-shenzhen = 'gpdb.aliyuncs.com',
    cn-hongkong = 'gpdb.aliyuncs.com',
    ap-southeast-1 = 'gpdb.aliyuncs.com',
    us-west-1 = 'gpdb.aliyuncs.com',
    us-east-1 = 'gpdb.aliyuncs.com',
    cn-hangzhou-finance = 'gpdb.aliyuncs.com',
    cn-shanghai-finance-1 = 'gpdb.aliyuncs.com',
    cn-shenzhen-finance-1 = 'gpdb.aliyuncs.com',
    cn-qingdao = 'gpdb.aliyuncs.com',
    cn-north-2-gov-1 = 'gpdb.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model AddBuDBInstanceRelationRequest {
  businessUnit: string(name='BusinessUnit', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
}

model AddBuDBInstanceRelationResponseBody = {
  businessUnit?: string(name='BusinessUnit'),
  DBInstanceName?: string(name='DBInstanceName'),
  requestId?: string(name='RequestId'),
}

model AddBuDBInstanceRelationResponse = {
  headers: map[string]string(name='headers'),
  body: AddBuDBInstanceRelationResponseBody(name='body'),
}

async function addBuDBInstanceRelation(request: AddBuDBInstanceRelationRequest): AddBuDBInstanceRelationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddBuDBInstanceRelation', 'POST', '/', 'json', false, 'json', request);
}

model AllocateInstancePublicConnectionRequest {
  addressType?: string(name='AddressType', position='Query'),
  connectionStringPrefix: string(name='ConnectionStringPrefix', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  port: string(name='Port', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AllocateInstancePublicConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model AllocateInstancePublicConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: AllocateInstancePublicConnectionResponseBody(name='body'),
}

async function allocateInstancePublicConnection(request: AllocateInstancePublicConnectionRequest): AllocateInstancePublicConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AllocateInstancePublicConnection', 'POST', '/', 'json', false, 'json', request);
}

model CheckServiceLinkedRoleRequest {
  regionId?: string(name='RegionId', position='Query'),
}

model CheckServiceLinkedRoleResponseBody = {
  hasServiceLinkedRole?: string(name='HasServiceLinkedRole'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
}

model CheckServiceLinkedRoleResponse = {
  headers: map[string]string(name='headers'),
  body: CheckServiceLinkedRoleResponseBody(name='body'),
}

async function checkServiceLinkedRole(request: CheckServiceLinkedRoleRequest): CheckServiceLinkedRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckServiceLinkedRole', 'POST', '/', 'json', false, 'json', request);
}

model CreateAccountRequest {
  accountDescription?: string(name='AccountDescription', position='Query'),
  accountName: string(name='AccountName', position='Query'),
  accountPassword: string(name='AccountPassword', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  databaseName?: string(name='DatabaseName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
}

model CreateAccountResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateAccountResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAccountResponseBody(name='body'),
}

async function createAccount(request: CreateAccountRequest): CreateAccountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAccount', 'POST', '/', 'json', false, 'json', request);
}

model CreateDBInstanceRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceCategory?: string(name='DBInstanceCategory', position='Query'),
  DBInstanceClass?: string(name='DBInstanceClass', position='Query'),
  DBInstanceDescription?: string(name='DBInstanceDescription', position='Query'),
  DBInstanceGroupCount?: string(name='DBInstanceGroupCount', position='Query'),
  DBInstanceMode?: string(name='DBInstanceMode', position='Query'),
  engine: string(name='Engine', position='Query'),
  engineVersion: string(name='EngineVersion', position='Query'),
  instanceNetworkType?: string(name='InstanceNetworkType', position='Query'),
  instanceSpec?: string(name='InstanceSpec', position='Query'),
  masterNodeNum?: string(name='MasterNodeNum', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  payType?: string(name='PayType', position='Query'),
  period?: string(name='Period', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  securityIPList: string(name='SecurityIPList', position='Query'),
  segNodeNum?: string(name='SegNodeNum', position='Query'),
  segStorageType?: string(name='SegStorageType', position='Query'),
  storageSize?: long(name='StorageSize', position='Query'),
  storageType?: string(name='StorageType', position='Query'),
  usedTime?: string(name='UsedTime', position='Query'),
  VPCId?: string(name='VPCId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  zoneId: string(name='ZoneId', position='Query'),
}

model CreateDBInstanceResponseBody = {
  connectionString?: string(name='ConnectionString'),
  DBInstanceId?: string(name='DBInstanceId'),
  orderId?: string(name='OrderId'),
  port?: string(name='Port'),
  requestId?: string(name='RequestId'),
}

model CreateDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDBInstanceResponseBody(name='body'),
}

async function createDBInstance(request: CreateDBInstanceRequest): CreateDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model CreateECSDBInstanceRequest {
  backupId?: string(name='BackupId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceCategory?: string(name='DBInstanceCategory', position='Query'),
  DBInstanceDescription?: string(name='DBInstanceDescription', position='Query'),
  encryptionKey?: string(name='EncryptionKey', position='Query'),
  encryptionType?: string(name='EncryptionType', position='Query'),
  engine: string(name='Engine', position='Query'),
  engineVersion: string(name='EngineVersion', position='Query'),
  instanceNetworkType?: string(name='InstanceNetworkType', position='Query'),
  instanceSpec: string(name='InstanceSpec', position='Query'),
  masterNodeNum?: int32(name='MasterNodeNum', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  payType?: string(name='PayType', position='Query'),
  period?: string(name='Period', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  securityIPList?: string(name='SecurityIPList', position='Query'),
  segNodeNum: int32(name='SegNodeNum', minimum=2, maximum=2048, position='Query'),
  segStorageType: string(name='SegStorageType', position='Query'),
  srcDbInstanceName?: string(name='SrcDbInstanceName', position='Query'),
  storageSize: int32(name='StorageSize', minimum=50, maximum=4000, position='Query'),
  usedTime?: string(name='UsedTime', position='Query'),
  VPCId?: string(name='VPCId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  zoneId: string(name='ZoneId', position='Query'),
}

model CreateECSDBInstanceResponseBody = {
  connectionString?: string(name='ConnectionString'),
  DBInstanceId?: string(name='DBInstanceId'),
  orderId?: string(name='OrderId'),
  port?: string(name='Port'),
  requestId?: string(name='RequestId'),
}

model CreateECSDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateECSDBInstanceResponseBody(name='body'),
}

async function createECSDBInstance(request: CreateECSDBInstanceRequest): CreateECSDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateECSDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model CreateServiceLinkedRoleRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model CreateServiceLinkedRoleResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateServiceLinkedRoleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateServiceLinkedRoleResponseBody(name='body'),
}

async function createServiceLinkedRole(request: CreateServiceLinkedRoleRequest): CreateServiceLinkedRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateServiceLinkedRole', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDBInstanceRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
}

model DeleteDBInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDBInstanceResponseBody(name='body'),
}

async function deleteDBInstance(request: DeleteDBInstanceRequest): DeleteDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDatabaseRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBName?: string(name='DBName', position='Query'),
}

model DeleteDatabaseResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDatabaseResponseBody(name='body'),
}

async function deleteDatabase(request: DeleteDatabaseRequest): DeleteDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDatabase', 'POST', '/', 'json', false, 'json', request);
}

model DeleteInstanceSPInfoRequest {
  DBInstanceId?: string(name='DBInstanceId', position='Query'),
  DBInstanceInfos?: string(name='DBInstanceInfos', position='Query'),
}

model DeleteInstanceSPInfoResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteInstanceSPInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteInstanceSPInfoResponseBody(name='body'),
}

async function deleteInstanceSPInfo(request: DeleteInstanceSPInfoRequest): DeleteInstanceSPInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteInstanceSPInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAccountsRequest {
  accountName?: string(name='AccountName', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
}

model DescribeAccountsResponseBody = {
  accounts?: {
    DBInstanceAccount?: [ 
    {
      accountDescription?: string(name='AccountDescription'),
      accountName?: string(name='AccountName'),
      accountStatus?: string(name='AccountStatus'),
      DBInstanceId?: string(name='DBInstanceId'),
    }
  ](name='DBInstanceAccount')
  }(name='Accounts'),
  requestId?: string(name='RequestId'),
}

model DescribeAccountsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAccountsResponseBody(name='body'),
}

async function describeAccounts(request: DescribeAccountsRequest): DescribeAccountsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAccounts', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAvailableResourcesRequest {
  chargeType?: string(name='ChargeType', position='Query'),
  region: string(name='Region', position='Query'),
  zoneId: string(name='ZoneId', position='Query'),
}

model DescribeAvailableResourcesResponseBody = {
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  resources?: [ 
    {
      supportedEngines?: [ 
        {
          mode?: string(name='Mode'),
          supportedEngineVersion?: string(name='SupportedEngineVersion'),
          supportedInstanceClasses?: [ 
            {
              description?: string(name='Description'),
              displayClass?: string(name='DisplayClass'),
              instanceClass?: string(name='InstanceClass'),
              nodeCount?: {
                maxCount?: string(name='MaxCount'),
                minCount?: string(name='MinCount'),
                step?: string(name='Step'),
              }(name='NodeCount'),
              storageSize?: {
                maxCount?: string(name='MaxCount'),
                minCount?: string(name='MinCount'),
                step?: string(name='Step'),
              }(name='StorageSize'),
              storageType?: string(name='StorageType'),
            }
          ](name='SupportedInstanceClasses'),
        }
      ](name='SupportedEngines'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Resources'),
}

model DescribeAvailableResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAvailableResourcesResponseBody(name='body'),
}

async function describeAvailableResources(request: DescribeAvailableResourcesRequest): DescribeAvailableResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAvailableResources', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBackupPolicyRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
}

model DescribeBackupPolicyResponseBody = {
  backupRetentionPeriod?: int32(name='BackupRetentionPeriod'),
  enableRecoveryPoint?: boolean(name='EnableRecoveryPoint'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod'),
  preferredBackupTime?: string(name='PreferredBackupTime'),
  recoveryPointPeriod?: string(name='RecoveryPointPeriod'),
  requestId?: string(name='RequestId'),
}

model DescribeBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBackupPolicyResponseBody(name='body'),
}

async function describeBackupPolicy(request: DescribeBackupPolicyRequest): DescribeBackupPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBackupPolicy', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBClusterNodeRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  nodeType?: string(name='NodeType', position='Query'),
}

model DescribeDBClusterNodeResponseBody = {
  DBClusterId?: string(name='DBClusterId'),
  nodes?: [ 
    {
      name?: string(name='Name'),
    }
  ](name='Nodes'),
  requestId?: string(name='RequestId'),
}

model DescribeDBClusterNodeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBClusterNodeResponseBody(name='body'),
}

async function describeDBClusterNode(request: DescribeDBClusterNodeRequest): DescribeDBClusterNodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBClusterNode', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBClusterNodesRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  nodeType: string(name='NodeType', position='Query'),
}

model DescribeDBClusterNodesResponseBody = {
  DBClusterId?: string(name='DBClusterId'),
  nodes?: [ 
    {
      name?: string(name='Name'),
    }
  ](name='Nodes'),
  requestId?: string(name='RequestId'),
}

model DescribeDBClusterNodesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBClusterNodesResponseBody(name='body'),
}

async function describeDBClusterNodes(request: DescribeDBClusterNodesRequest): DescribeDBClusterNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBClusterNodes', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBClusterPerformanceRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  key: string(name='Key', position='Query'),
  nodeType?: string(name='NodeType', position='Query'),
  nodes?: string(name='Nodes', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeDBClusterPerformanceResponseBody = {
  DBClusterId?: string(name='DBClusterId'),
  endTime?: string(name='EndTime'),
  performanceKeys?: [ 
    {
      name?: string(name='Name'),
      series?: [ 
        {
          name?: string(name='Name'),
          role?: string(name='Role'),
          values?: [ 
            {
              point?: [ string ](name='Point'),
            }
          ](name='Values'),
        }
      ](name='Series'),
      unit?: string(name='Unit'),
    }
  ](name='PerformanceKeys'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
}

model DescribeDBClusterPerformanceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBClusterPerformanceResponseBody(name='body'),
}

async function describeDBClusterPerformance(request: DescribeDBClusterPerformanceRequest): DescribeDBClusterPerformanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBClusterPerformance', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceAttributeRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
}

model DescribeDBInstanceAttributeResponseBody = {
  items?: {
    DBInstanceAttribute?: [ 
    {
      availabilityValue?: string(name='AvailabilityValue'),
      connectionMode?: string(name='ConnectionMode'),
      connectionString?: string(name='ConnectionString'),
      cpuCores?: int32(name='CpuCores'),
      cpuCoresPerNode?: int32(name='CpuCoresPerNode'),
      creationTime?: string(name='CreationTime'),
      DBInstanceCategory?: string(name='DBInstanceCategory'),
      DBInstanceClass?: string(name='DBInstanceClass'),
      DBInstanceClassType?: string(name='DBInstanceClassType'),
      DBInstanceCpuCores?: int32(name='DBInstanceCpuCores'),
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceDiskMBPS?: long(name='DBInstanceDiskMBPS'),
      DBInstanceGroupCount?: string(name='DBInstanceGroupCount'),
      DBInstanceId?: string(name='DBInstanceId'),
      DBInstanceMemory?: long(name='DBInstanceMemory'),
      DBInstanceMode?: string(name='DBInstanceMode'),
      DBInstanceNetType?: string(name='DBInstanceNetType'),
      DBInstanceStatus?: string(name='DBInstanceStatus'),
      DBInstanceStorage?: long(name='DBInstanceStorage'),
      encryptionKey?: string(name='EncryptionKey'),
      encryptionType?: string(name='EncryptionType'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      expireTime?: string(name='ExpireTime'),
      hostType?: string(name='HostType'),
      instanceNetworkType?: string(name='InstanceNetworkType'),
      lockMode?: string(name='LockMode'),
      lockReason?: string(name='LockReason'),
      maintainEndTime?: string(name='MaintainEndTime'),
      maintainStartTime?: string(name='MaintainStartTime'),
      masterNodeNum?: int32(name='MasterNodeNum'),
      maxConnections?: int32(name='MaxConnections'),
      memoryPerNode?: int32(name='MemoryPerNode'),
      memorySize?: long(name='MemorySize'),
      memoryUnit?: string(name='MemoryUnit'),
      minorVersion?: string(name='MinorVersion'),
      payType?: string(name='PayType'),
      port?: string(name='Port'),
      readDelayTime?: string(name='ReadDelayTime'),
      regionId?: string(name='RegionId'),
      securityIPList?: string(name='SecurityIPList'),
      segNodeNum?: int32(name='SegNodeNum'),
      segmentCounts?: int32(name='SegmentCounts'),
      storagePerNode?: int32(name='StoragePerNode'),
      storageSize?: long(name='StorageSize'),
      storageType?: string(name='StorageType'),
      storageUnit?: string(name='StorageUnit'),
      supportRestore?: boolean(name='SupportRestore'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      vSwitchId?: string(name='VSwitchId'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='DBInstanceAttribute')
  }(name='Items'),
  requestId?: string(name='RequestId'),
}

model DescribeDBInstanceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceAttributeResponseBody(name='body'),
}

async function describeDBInstanceAttribute(request: DescribeDBInstanceAttributeRequest): DescribeDBInstanceAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceIPArrayListRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
}

model DescribeDBInstanceIPArrayListResponseBody = {
  items?: {
    DBInstanceIPArray?: [ 
    {
      DBInstanceIPArrayAttribute?: string(name='DBInstanceIPArrayAttribute'),
      DBInstanceIPArrayName?: string(name='DBInstanceIPArrayName'),
      securityIPList?: string(name='SecurityIPList'),
    }
  ](name='DBInstanceIPArray')
  }(name='Items'),
  requestId?: string(name='RequestId'),
}

model DescribeDBInstanceIPArrayListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceIPArrayListResponseBody(name='body'),
}

async function describeDBInstanceIPArrayList(request: DescribeDBInstanceIPArrayListRequest): DescribeDBInstanceIPArrayListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceIPArrayList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceNetInfoRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
}

model DescribeDBInstanceNetInfoResponseBody = {
  DBInstanceNetInfos?: {
    DBInstanceNetInfo?: [ 
    {
      addressType?: string(name='AddressType'),
      connectionString?: string(name='ConnectionString'),
      IPAddress?: string(name='IPAddress'),
      IPType?: string(name='IPType'),
      port?: string(name='Port'),
      VPCId?: string(name='VPCId'),
      vSwitchId?: string(name='VSwitchId'),
      vpcInstanceId?: string(name='VpcInstanceId'),
    }
  ](name='DBInstanceNetInfo')
  }(name='DBInstanceNetInfos'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  requestId?: string(name='RequestId'),
}

model DescribeDBInstanceNetInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceNetInfoResponseBody(name='body'),
}

async function describeDBInstanceNetInfo(request: DescribeDBInstanceNetInfoRequest): DescribeDBInstanceNetInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceNetInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceOnECSAttributeRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
}

model DescribeDBInstanceOnECSAttributeResponseBody = {
  items?: {
    DBInstanceAttribute?: [ 
    {
      connectionMode?: string(name='ConnectionMode'),
      connectionString?: string(name='ConnectionString'),
      cpuCores?: int32(name='CpuCores'),
      creationTime?: string(name='CreationTime'),
      DBInstanceCategory?: string(name='DBInstanceCategory'),
      DBInstanceClass?: string(name='DBInstanceClass'),
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceId?: string(name='DBInstanceId'),
      DBInstanceStatus?: string(name='DBInstanceStatus'),
      encryptionKey?: string(name='EncryptionKey'),
      encryptionType?: string(name='EncryptionType'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      expireTime?: string(name='ExpireTime'),
      instanceDeployType?: string(name='InstanceDeployType'),
      instanceNetworkType?: string(name='InstanceNetworkType'),
      lockMode?: string(name='LockMode'),
      masterNodeNum?: int32(name='MasterNodeNum'),
      memorySize?: int32(name='MemorySize'),
      minorVersion?: string(name='MinorVersion'),
      payType?: string(name='PayType'),
      port?: string(name='Port'),
      regionId?: string(name='RegionId'),
      segNodeNum?: int32(name='SegNodeNum'),
      storageSize?: int32(name='StorageSize'),
      storageType?: string(name='StorageType'),
      supportRestore?: boolean(name='SupportRestore'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      vSwitchId?: string(name='VSwitchId'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='DBInstanceAttribute')
  }(name='Items'),
  requestId?: string(name='RequestId'),
}

model DescribeDBInstanceOnECSAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceOnECSAttributeResponseBody(name='body'),
}

async function describeDBInstanceOnECSAttribute(request: DescribeDBInstanceOnECSAttributeRequest): DescribeDBInstanceOnECSAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceOnECSAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstancePerformanceRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  key: string(name='Key', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeDBInstancePerformanceResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  engine?: string(name='Engine'),
  performanceKeys?: [ string ](name='PerformanceKeys'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
}

model DescribeDBInstancePerformanceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstancePerformanceResponseBody(name='body'),
}

async function describeDBInstancePerformance(request: DescribeDBInstancePerformanceRequest): DescribeDBInstancePerformanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstancePerformance', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceSQLPatternsRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  database?: string(name='Database', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  queryKeywords: string(name='QueryKeywords', position='Query'),
  sourceIP?: string(name='SourceIP', position='Query'),
  startTime: string(name='StartTime', position='Query'),
  user?: string(name='User', position='Query'),
}

model DescribeDBInstanceSQLPatternsResponseBody = {
  DBClusterId?: string(name='DBClusterId'),
  endTime?: string(name='EndTime'),
  patterns?: [ 
    {
      name?: string(name='Name'),
      values?: map[string]any(name='Values'),
    }
  ](name='Patterns'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
}

model DescribeDBInstanceSQLPatternsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceSQLPatternsResponseBody(name='body'),
}

async function describeDBInstanceSQLPatterns(request: DescribeDBInstanceSQLPatternsRequest): DescribeDBInstanceSQLPatternsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceSQLPatterns', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceSSLRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
}

model DescribeDBInstanceSSLResponseBody = {
  certCommonName?: string(name='CertCommonName'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBInstanceName?: string(name='DBInstanceName'),
  requestId?: string(name='RequestId'),
  SSLEnabled?: boolean(name='SSLEnabled'),
  SSLExpiredTime?: string(name='SSLExpiredTime'),
}

model DescribeDBInstanceSSLResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceSSLResponseBody(name='body'),
}

async function describeDBInstanceSSL(request: DescribeDBInstanceSSLRequest): DescribeDBInstanceSSLResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceSSL', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstancesRequest {
  DBInstanceCategories?: [ string ](name='DBInstanceCategories', position='Query'),
  DBInstanceDescription?: string(name='DBInstanceDescription', position='Query'),
  DBInstanceIds?: string(name='DBInstanceIds', position='Query'),
  DBInstanceModes?: [ string ](name='DBInstanceModes', position='Query'),
  DBInstanceStatuses?: [ string ](name='DBInstanceStatuses', position='Query'),
  instanceDeployTypes?: [ string ](name='InstanceDeployTypes', position='Query'),
  instanceNetworkType?: string(name='InstanceNetworkType', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model DescribeDBInstancesResponseBody = {
  items?: {
    DBInstance?: [ 
    {
      connectionMode?: string(name='ConnectionMode'),
      createTime?: string(name='CreateTime'),
      DBInstanceCategory?: string(name='DBInstanceCategory'),
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceId?: string(name='DBInstanceId'),
      DBInstanceMode?: string(name='DBInstanceMode'),
      DBInstanceNetType?: string(name='DBInstanceNetType'),
      DBInstanceStatus?: string(name='DBInstanceStatus'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      expireTime?: string(name='ExpireTime'),
      instanceDeployType?: string(name='InstanceDeployType'),
      instanceNetworkType?: string(name='InstanceNetworkType'),
      lockMode?: string(name='LockMode'),
      lockReason?: string(name='LockReason'),
      masterNodeNum?: int32(name='MasterNodeNum'),
      payType?: string(name='PayType'),
      regionId?: string(name='RegionId'),
      segNodeNum?: string(name='SegNodeNum'),
      storageSize?: string(name='StorageSize'),
      storageType?: string(name='StorageType'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      vSwitchId?: string(name='VSwitchId'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='DBInstance')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeDBInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstancesResponseBody(name='body'),
}

async function describeDBInstances(request: DescribeDBInstancesRequest): DescribeDBInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDataBackupsRequest {
  backupId?: string(name='BackupId', position='Query'),
  backupMode?: string(name='BackupMode', position='Query'),
  backupStatus?: string(name='BackupStatus', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  dataType?: string(name='DataType', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=30, maximum=100, position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeDataBackupsResponseBody = {
  items?: [ 
    {
      backupEndTime?: string(name='BackupEndTime'),
      backupEndTimeLocal?: string(name='BackupEndTimeLocal'),
      backupMode?: string(name='BackupMode'),
      backupSetId?: string(name='BackupSetId'),
      backupSize?: long(name='BackupSize'),
      backupStartTime?: string(name='BackupStartTime'),
      backupStartTimeLocal?: string(name='BackupStartTimeLocal'),
      backupStatus?: string(name='BackupStatus'),
      baksetName?: string(name='BaksetName'),
      consistentTime?: long(name='ConsistentTime'),
      DBInstanceId?: string(name='DBInstanceId'),
      dataType?: string(name='DataType'),
    }
  ](name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeDataBackupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDataBackupsResponseBody(name='body'),
}

async function describeDataBackups(request: DescribeDataBackupsRequest): DescribeDataBackupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDataBackups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDataShareInstancesRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  searchValue?: string(name='SearchValue', position='Query'),
}

model DescribeDataShareInstancesResponseBody = {
  items?: {
    DBInstance?: [ 
    {
      DBInstanceId?: string(name='DBInstanceId'),
      DBInstanceMode?: string(name='DBInstanceMode'),
      dataShareStatus?: string(name='DataShareStatus'),
      description?: string(name='Description'),
      regionId?: string(name='RegionId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='DBInstance')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeDataShareInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDataShareInstancesResponseBody(name='body'),
}

async function describeDataShareInstances(request: DescribeDataShareInstancesRequest): DescribeDataShareInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDataShareInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeHealthStatusRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  key: string(name='Key', position='Query'),
}

model DescribeHealthStatusResponseBody = {
  DBClusterId?: string(name='DBClusterId'),
  requestId?: string(name='RequestId'),
  status?: {
    adbgpSegmentDiskUsagePercentMax?: {
      status?: string(name='Status'),
      value?: float(name='Value'),
    }(name='adbgp_segment_disk_usage_percent_max'),
    adbpgConnectionStatus?: {
      status?: string(name='Status'),
      value?: float(name='Value'),
    }(name='adbpg_connection_status'),
    adbpgDiskStatus?: {
      status?: string(name='Status'),
      value?: float(name='Value'),
    }(name='adbpg_disk_status'),
    adbpgDiskUsagePercent?: {
      status?: string(name='Status'),
      value?: float(name='Value'),
    }(name='adbpg_disk_usage_percent'),
    adbpgMasterDiskUsagePercentMax?: {
      status?: string(name='Status'),
      value?: float(name='Value'),
    }(name='adbpg_master_disk_usage_percent_max'),
    adbpgStatus?: {
      status?: string(name='Status'),
      value?: float(name='Value'),
    }(name='adbpg_status'),
    nodeMasterConnectionStatus?: {
      status?: string(name='Status'),
      value?: float(name='Value'),
    }(name='node_master_connection_status'),
    nodeMasterStatus?: {
      status?: string(name='Status'),
      value?: float(name='Value'),
    }(name='node_master_status'),
    nodeSegmentConnectionStatus?: {
      status?: string(name='Status'),
      value?: float(name='Value'),
    }(name='node_segment_connection_status'),
    nodeSegmentDiskStatus?: {
      status?: string(name='Status'),
      value?: float(name='Value'),
    }(name='node_segment_disk_status'),
  }(name='Status'),
}

model DescribeHealthStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHealthStatusResponseBody(name='body'),
}

async function describeHealthStatus(request: DescribeHealthStatusRequest): DescribeHealthStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeHealthStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLogBackupsRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=30, maximum=100, position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeLogBackupsResponseBody = {
  items?: [ 
    {
      backupId?: string(name='BackupId'),
      DBInstanceId?: string(name='DBInstanceId'),
      logFileName?: string(name='LogFileName'),
      logFileSize?: long(name='LogFileSize'),
      logTime?: string(name='LogTime'),
      segmentName?: string(name='SegmentName'),
    }
  ](name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  totalLogSize?: long(name='TotalLogSize'),
}

model DescribeLogBackupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLogBackupsResponseBody(name='body'),
}

async function describeLogBackups(request: DescribeLogBackupsRequest): DescribeLogBackupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLogBackups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeModifyParameterLogRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model DescribeModifyParameterLogResponseBody = {
  changelogs?: [ 
    {
      effectTime?: string(name='EffectTime'),
      parameterName?: string(name='ParameterName'),
      parameterValid?: string(name='ParameterValid'),
      parameterValueAfter?: string(name='ParameterValueAfter'),
      parameterValueBefore?: string(name='ParameterValueBefore'),
    }
  ](name='Changelogs'),
  requestId?: string(name='RequestId'),
}

model DescribeModifyParameterLogResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeModifyParameterLogResponseBody(name='body'),
}

async function describeModifyParameterLog(request: DescribeModifyParameterLogRequest): DescribeModifyParameterLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeModifyParameterLog', 'POST', '/', 'json', false, 'json', request);
}

model DescribeParametersRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
}

model DescribeParametersResponseBody = {
  parameters?: [ 
    {
      currentValue?: string(name='CurrentValue'),
      forceRestartInstance?: string(name='ForceRestartInstance'),
      isChangeableConfig?: string(name='IsChangeableConfig'),
      optionalRange?: string(name='OptionalRange'),
      parameterDescription?: string(name='ParameterDescription'),
      parameterName?: string(name='ParameterName'),
      parameterValue?: string(name='ParameterValue'),
    }
  ](name='Parameters'),
  requestId?: string(name='RequestId'),
}

model DescribeParametersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeParametersResponseBody(name='body'),
}

async function describeParameters(request: DescribeParametersRequest): DescribeParametersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeParameters', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRdsVSwitchsRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeRdsVSwitchsResponseBody = {
  requestId?: string(name='RequestId'),
  vSwitches?: {
    vSwitch?: [ 
      {
        aliUid?: string(name='AliUid'),
        bid?: string(name='Bid'),
        cidrBlock?: string(name='CidrBlock'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        isDefault?: boolean(name='IsDefault'),
        izNo?: string(name='IzNo'),
        regionNo?: string(name='RegionNo'),
        status?: string(name='Status'),
        vSwitchId?: string(name='VSwitchId'),
        vSwitchName?: string(name='VSwitchName'),
      }
    ](name='VSwitch'),
  }(name='VSwitches'),
}

model DescribeRdsVSwitchsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRdsVSwitchsResponseBody(name='body'),
}

async function describeRdsVSwitchs(request: DescribeRdsVSwitchsRequest): DescribeRdsVSwitchsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRdsVSwitchs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRdsVpcsRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeRdsVpcsResponseBody = {
  requestId?: string(name='RequestId'),
  vpcs?: {
    vpc?: [ 
      {
        aliUid?: string(name='AliUid'),
        bid?: string(name='Bid'),
        cidrBlock?: string(name='CidrBlock'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        isDefault?: boolean(name='IsDefault'),
        regionNo?: string(name='RegionNo'),
        status?: string(name='Status'),
        vSwitchs?: [ 
          {
            cidrBlock?: string(name='CidrBlock'),
            gmtCreate?: string(name='GmtCreate'),
            gmtModified?: string(name='GmtModified'),
            isDefault?: boolean(name='IsDefault'),
            izNo?: string(name='IzNo'),
            status?: string(name='Status'),
            vSwitchId?: string(name='VSwitchId'),
            vSwitchName?: string(name='VSwitchName'),
          }
        ](name='VSwitchs'),
        vpcId?: string(name='VpcId'),
        vpcName?: string(name='VpcName'),
      }
    ](name='Vpc'),
  }(name='Vpcs'),
}

model DescribeRdsVpcsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRdsVpcsResponseBody(name='body'),
}

async function describeRdsVpcs(request: DescribeRdsVpcsRequest): DescribeRdsVpcsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRdsVpcs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
  region?: string(name='Region', position='Query'),
}

model DescribeRegionsResponseBody = {
  regions?: {
    region?: [ 
    {
      regionId?: string(name='RegionId'),
      zones?: {
        zone?: [ 
        {
          vpcEnabled?: boolean(name='VpcEnabled'),
          zoneId?: string(name='ZoneId'),
        }
      ](name='Zone')
      }(name='Zones'),
    }
  ](name='Region')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRegions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeResourceUsageRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
}

model DescribeResourceUsageResponseBody = {
  backupSize?: long(name='BackupSize'),
  DBInstanceId?: string(name='DBInstanceId'),
  dataSize?: long(name='DataSize'),
  diskUsed?: long(name='DiskUsed'),
  engine?: string(name='Engine'),
  logSize?: long(name='LogSize'),
  requestId?: string(name='RequestId'),
}

model DescribeResourceUsageResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeResourceUsageResponseBody(name='body'),
}

async function describeResourceUsage(request: DescribeResourceUsageRequest): DescribeResourceUsageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeResourceUsage', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSQLCollectorPolicyRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
}

model DescribeSQLCollectorPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  SQLCollectorStatus?: string(name='SQLCollectorStatus'),
}

model DescribeSQLCollectorPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSQLCollectorPolicyResponseBody(name='body'),
}

async function describeSQLCollectorPolicy(request: DescribeSQLCollectorPolicyRequest): DescribeSQLCollectorPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSQLCollectorPolicy', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSQLLogRequest {
  DBInstanceId?: string(name='DBInstanceId', position='Query'),
  queryId: string(name='QueryId', position='Query'),
}

model DescribeSQLLogResponseBody = {
  items?: [ 
    {
      accountName?: string(name='AccountName'),
      DBName?: string(name='DBName'),
      DBRole?: string(name='DBRole'),
      executeCost?: float(name='ExecuteCost'),
      executeState?: string(name='ExecuteState'),
      operationClass?: string(name='OperationClass'),
      operationExecuteTime?: string(name='OperationExecuteTime'),
      operationType?: string(name='OperationType'),
      queryId?: string(name='QueryId'),
      returnRowCounts?: long(name='ReturnRowCounts'),
      SQLPlan?: string(name='SQLPlan'),
      SQLText?: string(name='SQLText'),
      scanRowCounts?: long(name='ScanRowCounts'),
      sourceIP?: string(name='SourceIP'),
      sourcePort?: int32(name='SourcePort'),
    }
  ](name='Items'),
  requestId?: string(name='RequestId'),
}

model DescribeSQLLogResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSQLLogResponseBody(name='body'),
}

async function describeSQLLog(request: DescribeSQLLogRequest): DescribeSQLLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSQLLog', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSQLLogByQueryIdRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  queryId: string(name='QueryId', position='Query'),
}

model DescribeSQLLogByQueryIdResponseBody = {
  items?: [ 
    {
      accountName?: string(name='AccountName'),
      DBName?: string(name='DBName'),
      DBRole?: string(name='DBRole'),
      executeCost?: float(name='ExecuteCost'),
      executeState?: string(name='ExecuteState'),
      operationClass?: string(name='OperationClass'),
      operationExecuteTime?: string(name='OperationExecuteTime'),
      operationType?: string(name='OperationType'),
      queryId?: string(name='QueryId'),
      returnRowCounts?: long(name='ReturnRowCounts'),
      SQLPlan?: string(name='SQLPlan'),
      SQLText?: string(name='SQLText'),
      scanRowCounts?: long(name='ScanRowCounts'),
      sliceIds?: [ string ](name='SliceIds'),
      sourceIP?: string(name='SourceIP'),
      sourcePort?: int32(name='SourcePort'),
    }
  ](name='Items'),
  requestId?: string(name='RequestId'),
}

model DescribeSQLLogByQueryIdResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSQLLogByQueryIdResponseBody(name='body'),
}

async function describeSQLLogByQueryId(request: DescribeSQLLogByQueryIdRequest): DescribeSQLLogByQueryIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSQLLogByQueryId', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSQLLogCountRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  database?: string(name='Database', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  executeCost?: string(name='ExecuteCost', position='Query'),
  executeState?: string(name='ExecuteState', position='Query'),
  maxExecuteCost?: string(name='MaxExecuteCost', position='Query'),
  minExecuteCost?: string(name='MinExecuteCost', position='Query'),
  operationClass?: string(name='OperationClass', position='Query'),
  operationType?: string(name='OperationType', position='Query'),
  queryKeywords?: string(name='QueryKeywords', position='Query'),
  sourceIP?: string(name='SourceIP', position='Query'),
  startTime: string(name='StartTime', position='Query'),
  user?: string(name='User', position='Query'),
}

model DescribeSQLLogCountResponseBody = {
  DBClusterId?: string(name='DBClusterId'),
  endTime?: string(name='EndTime'),
  items?: [ 
    {
      name?: string(name='Name'),
      series?: [ 
        {
          values?: [ 
            {
              point?: [ string ](name='Point'),
            }
          ](name='Values'),
        }
      ](name='Series'),
    }
  ](name='Items'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
}

model DescribeSQLLogCountResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSQLLogCountResponseBody(name='body'),
}

async function describeSQLLogCount(request: DescribeSQLLogCountRequest): DescribeSQLLogCountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSQLLogCount', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSQLLogFilesRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  fileName?: string(name='FileName', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=30, maximum=200, position='Query'),
}

model DescribeSQLLogFilesResponseBody = {
  items?: {
    logFile?: [ 
    {
      fileID?: string(name='FileID'),
      logDownloadURL?: string(name='LogDownloadURL'),
      logEndTime?: string(name='LogEndTime'),
      logSize?: string(name='LogSize'),
      logStartTime?: string(name='LogStartTime'),
      logStatus?: string(name='LogStatus'),
    }
  ](name='LogFile')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeSQLLogFilesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSQLLogFilesResponseBody(name='body'),
}

async function describeSQLLogFiles(request: DescribeSQLLogFilesRequest): DescribeSQLLogFilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSQLLogFiles', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSQLLogRecordsRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  database?: string(name='Database', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  form?: string(name='Form', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=30, maximum=200, position='Query'),
  queryKeywords?: string(name='QueryKeywords', position='Query'),
  startTime: string(name='StartTime', position='Query'),
  user?: string(name='User', position='Query'),
}

model DescribeSQLLogRecordsResponseBody = {
  items?: {
    SQLRecord?: [ 
    {
      accountName?: string(name='AccountName'),
      DBName?: string(name='DBName'),
      executeTime?: string(name='ExecuteTime'),
      hostAddress?: string(name='HostAddress'),
      returnRowCounts?: long(name='ReturnRowCounts'),
      SQLText?: string(name='SQLText'),
      threadID?: string(name='ThreadID'),
      totalExecutionTimes?: long(name='TotalExecutionTimes'),
    }
  ](name='SQLRecord')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeSQLLogRecordsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSQLLogRecordsResponseBody(name='body'),
}

async function describeSQLLogRecords(request: DescribeSQLLogRecordsRequest): DescribeSQLLogRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSQLLogRecords', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSQLLogsRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  database?: string(name='Database', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  executeCost?: string(name='ExecuteCost', position='Query'),
  executeState?: string(name='ExecuteState', position='Query'),
  maxExecuteCost?: string(name='MaxExecuteCost', position='Query'),
  minExecuteCost?: string(name='MinExecuteCost', position='Query'),
  operationClass?: string(name='OperationClass', position='Query'),
  operationType?: string(name='OperationType', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=0, maximum=200, position='Query'),
  queryKeywords?: string(name='QueryKeywords', position='Query'),
  sourceIP?: string(name='SourceIP', position='Query'),
  startTime: string(name='StartTime', position='Query'),
  user?: string(name='User', position='Query'),
}

model DescribeSQLLogsResponseBody = {
  items?: [ 
    {
      accountName?: string(name='AccountName'),
      DBName?: string(name='DBName'),
      DBRole?: string(name='DBRole'),
      executeCost?: float(name='ExecuteCost'),
      executeState?: string(name='ExecuteState'),
      operationClass?: string(name='OperationClass'),
      operationExecuteTime?: string(name='OperationExecuteTime'),
      operationType?: string(name='OperationType'),
      returnRowCounts?: long(name='ReturnRowCounts'),
      SQLPlan?: string(name='SQLPlan'),
      SQLText?: string(name='SQLText'),
      scanRowCounts?: long(name='ScanRowCounts'),
      sourceIP?: string(name='SourceIP'),
      sourcePort?: int32(name='SourcePort'),
    }
  ](name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
}

model DescribeSQLLogsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSQLLogsResponseBody(name='body'),
}

async function describeSQLLogs(request: DescribeSQLLogsRequest): DescribeSQLLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSQLLogs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSQLLogsOnSliceRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  executeState?: string(name='ExecuteState', position='Query'),
  maxExecuteCost?: string(name='MaxExecuteCost', position='Query'),
  minExecuteCost?: string(name='MinExecuteCost', position='Query'),
  pageNumber: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  queryId: string(name='QueryId', position='Query'),
  sliceId: string(name='SliceId', position='Query'),
}

model DescribeSQLLogsOnSliceResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  sliceLogItems?: [ 
    {
      executeCost?: float(name='ExecuteCost'),
      executeStatus?: string(name='ExecuteStatus'),
      operationExecuteEndTime?: string(name='OperationExecuteEndTime'),
      operationExecuteTime?: string(name='OperationExecuteTime'),
      peakMemory?: float(name='PeakMemory'),
      returnRowCounts?: long(name='ReturnRowCounts'),
      segmentId?: string(name='SegmentId'),
      segmentName?: string(name='SegmentName'),
    }
  ](name='SliceLogItems'),
}

model DescribeSQLLogsOnSliceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSQLLogsOnSliceResponseBody(name='body'),
}

async function describeSQLLogsOnSlice(request: DescribeSQLLogsOnSliceRequest): DescribeSQLLogsOnSliceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSQLLogsOnSlice', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSlowLogRecordsRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBName?: string(name='DBName', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=30, maximum=100, position='Query'),
  SQLId?: long(name='SQLId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeSlowLogRecordsResponseBody = {
  engine?: string(name='Engine'),
  items?: {
    SQLSlowRecord?: [ 
    {
      DBName?: string(name='DBName'),
      executionStartTime?: string(name='ExecutionStartTime'),
      hostAddress?: string(name='HostAddress'),
      lockTimes?: long(name='LockTimes'),
      parseRowCounts?: long(name='ParseRowCounts'),
      queryTimes?: long(name='QueryTimes'),
      returnRowCounts?: long(name='ReturnRowCounts'),
      SQLText?: string(name='SQLText'),
    }
  ](name='SQLSlowRecord')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeSlowLogRecordsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSlowLogRecordsResponseBody(name='body'),
}

async function describeSlowLogRecords(request: DescribeSlowLogRecordsRequest): DescribeSlowLogRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSlowLogRecords', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSlowSQLLogsRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  database?: string(name='Database', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  executeState?: string(name='ExecuteState', position='Query'),
  maxExecuteCost?: string(name='MaxExecuteCost', position='Query'),
  minExecuteCost?: string(name='MinExecuteCost', position='Query'),
  operationClass?: string(name='OperationClass', position='Query'),
  operationType?: string(name='OperationType', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=0, maximum=200, position='Query'),
  queryKeywords?: string(name='QueryKeywords', position='Query'),
  sourceIP?: string(name='SourceIP', position='Query'),
  startTime: string(name='StartTime', position='Query'),
  user?: string(name='User', position='Query'),
}

model DescribeSlowSQLLogsResponseBody = {
  items?: [ 
    {
      accountName?: string(name='AccountName'),
      DBName?: string(name='DBName'),
      DBRole?: string(name='DBRole'),
      executeCost?: float(name='ExecuteCost'),
      executeState?: string(name='ExecuteState'),
      operationClass?: string(name='OperationClass'),
      operationExecuteTime?: string(name='OperationExecuteTime'),
      operationType?: string(name='OperationType'),
      queryId?: string(name='QueryId'),
      returnRowCounts?: long(name='ReturnRowCounts'),
      SQLPlan?: string(name='SQLPlan'),
      SQLText?: string(name='SQLText'),
      scanRowCounts?: long(name='ScanRowCounts'),
      sourceIP?: string(name='SourceIP'),
      sourcePort?: int32(name='SourcePort'),
    }
  ](name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
}

model DescribeSlowSQLLogsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSlowSQLLogsResponseBody(name='body'),
}

async function describeSlowSQLLogs(request: DescribeSlowSQLLogsRequest): DescribeSlowSQLLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSlowSQLLogs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSpecificationRequest {
  cpuCores: int32(name='CpuCores', position='Query'),
  DBInstanceId?: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  storageType: string(name='StorageType', position='Query'),
  totalNodeNum: int32(name='TotalNodeNum', position='Query'),
}

model DescribeSpecificationResponseBody = {
  DBInstanceClass?: [ 
    {
      text?: string(name='Text'),
      value?: string(name='Value'),
    }
  ](name='DBInstanceClass'),
  DBInstanceGroupCount?: [ 
    {
      text?: string(name='Text'),
      value?: string(name='Value'),
    }
  ](name='DBInstanceGroupCount'),
  requestId?: string(name='RequestId'),
  storageNotice?: [ 
    {
      text?: string(name='Text'),
      value?: string(name='Value'),
    }
  ](name='StorageNotice'),
}

model DescribeSpecificationResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSpecificationResponseBody(name='body'),
}

async function describeSpecification(request: DescribeSpecificationRequest): DescribeSpecificationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSpecification', 'POST', '/', 'json', false, 'json', request);
}

model DescribeTagsRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
}

model DescribeTagsResponseBody = {
  requestId?: string(name='RequestId'),
  tags?: [ 
    {
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='Tags'),
}

model DescribeTagsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTagsResponseBody(name='body'),
}

async function describeTags(request: DescribeTagsRequest): DescribeTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTags', 'POST', '/', 'json', false, 'json', request);
}

model DescribeUserEncryptionKeyListRequest {
  pageNumber?: string(name='PageNumber', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeUserEncryptionKeyListResponseBody = {
  kmsKeys?: [ 
    {
      keyId?: string(name='KeyId'),
    }
  ](name='KmsKeys'),
  requestId?: string(name='RequestId'),
}

model DescribeUserEncryptionKeyListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUserEncryptionKeyListResponseBody(name='body'),
}

async function describeUserEncryptionKeyList(request: DescribeUserEncryptionKeyListRequest): DescribeUserEncryptionKeyListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUserEncryptionKeyList', 'POST', '/', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId?: [ string ](name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', '/', 'json', false, 'json', request);
}

model ModifyAccountDescriptionRequest {
  accountDescription: string(name='AccountDescription', position='Query'),
  accountName: string(name='AccountName', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
}

model ModifyAccountDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyAccountDescriptionResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyAccountDescriptionResponseBody(name='body'),
}

async function modifyAccountDescription(request: ModifyAccountDescriptionRequest): ModifyAccountDescriptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyAccountDescription', 'POST', '/', 'json', false, 'json', request);
}

model ModifyBackupPolicyRequest {
  backupRetentionPeriod?: int32(name='BackupRetentionPeriod', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  enableRecoveryPoint?: boolean(name='EnableRecoveryPoint', position='Query'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod', position='Query'),
  preferredBackupTime?: string(name='PreferredBackupTime', position='Query'),
  recoveryPointPeriod?: string(name='RecoveryPointPeriod', position='Query'),
}

model ModifyBackupPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyBackupPolicyResponseBody(name='body'),
}

async function modifyBackupPolicy(request: ModifyBackupPolicyRequest): ModifyBackupPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyBackupPolicy', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceConnectionModeRequest {
  connectionMode: string(name='ConnectionMode', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
}

model ModifyDBInstanceConnectionModeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceConnectionModeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceConnectionModeResponseBody(name='body'),
}

async function modifyDBInstanceConnectionMode(request: ModifyDBInstanceConnectionModeRequest): ModifyDBInstanceConnectionModeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceConnectionMode', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceConnectionStringRequest {
  connectionStringPrefix: string(name='ConnectionStringPrefix', position='Query'),
  currentConnectionString: string(name='CurrentConnectionString', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  port: string(name='Port', position='Query'),
}

model ModifyDBInstanceConnectionStringResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceConnectionStringResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceConnectionStringResponseBody(name='body'),
}

async function modifyDBInstanceConnectionString(request: ModifyDBInstanceConnectionStringRequest): ModifyDBInstanceConnectionStringResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceConnectionString', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceDescriptionRequest {
  DBInstanceDescription: string(name='DBInstanceDescription', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
}

model ModifyDBInstanceDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceDescriptionResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceDescriptionResponseBody(name='body'),
}

async function modifyDBInstanceDescription(request: ModifyDBInstanceDescriptionRequest): ModifyDBInstanceDescriptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceDescription', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceMaintainTimeRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model ModifyDBInstanceMaintainTimeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceMaintainTimeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceMaintainTimeResponseBody(name='body'),
}

async function modifyDBInstanceMaintainTime(request: ModifyDBInstanceMaintainTimeRequest): ModifyDBInstanceMaintainTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceMaintainTime', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceNetworkTypeRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  instanceNetworkType: string(name='InstanceNetworkType', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', position='Query'),
  VPCId?: string(name='VPCId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
}

model ModifyDBInstanceNetworkTypeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceNetworkTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceNetworkTypeResponseBody(name='body'),
}

async function modifyDBInstanceNetworkType(request: ModifyDBInstanceNetworkTypeRequest): ModifyDBInstanceNetworkTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceNetworkType', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceSSLRequest {
  connectionString?: string(name='ConnectionString', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  SSLEnabled: int32(name='SSLEnabled', position='Query'),
}

model ModifyDBInstanceSSLResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceSSLResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceSSLResponseBody(name='body'),
}

async function modifyDBInstanceSSL(request: ModifyDBInstanceSSLRequest): ModifyDBInstanceSSLResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceSSL', 'POST', '/', 'json', false, 'json', request);
}

model ModifyParametersRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  forceRestartInstance?: boolean(name='ForceRestartInstance', position='Query'),
  parameters: string(name='Parameters', position='Query'),
}

model ModifyParametersResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyParametersResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyParametersResponseBody(name='body'),
}

async function modifyParameters(request: ModifyParametersRequest): ModifyParametersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyParameters', 'POST', '/', 'json', false, 'json', request);
}

model ModifySQLCollectorPolicyRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  SQLCollectorStatus: string(name='SQLCollectorStatus', position='Query'),
}

model ModifySQLCollectorPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySQLCollectorPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySQLCollectorPolicyResponseBody(name='body'),
}

async function modifySQLCollectorPolicy(request: ModifySQLCollectorPolicyRequest): ModifySQLCollectorPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySQLCollectorPolicy', 'POST', '/', 'json', false, 'json', request);
}

model ModifySecurityIpsRequest {
  DBInstanceIPArrayAttribute?: string(name='DBInstanceIPArrayAttribute', position='Query'),
  DBInstanceIPArrayName?: string(name='DBInstanceIPArrayName', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  securityIPList: string(name='SecurityIPList', position='Query'),
}

model ModifySecurityIpsResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySecurityIpsResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySecurityIpsResponseBody(name='body'),
}

async function modifySecurityIps(request: ModifySecurityIpsRequest): ModifySecurityIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySecurityIps', 'POST', '/', 'json', false, 'json', request);
}

model ReleaseInstancePublicConnectionRequest {
  addressType?: string(name='AddressType', position='Query'),
  currentConnectionString: string(name='CurrentConnectionString', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
}

model ReleaseInstancePublicConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseInstancePublicConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseInstancePublicConnectionResponseBody(name='body'),
}

async function releaseInstancePublicConnection(request: ReleaseInstancePublicConnectionRequest): ReleaseInstancePublicConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleaseInstancePublicConnection', 'POST', '/', 'json', false, 'json', request);
}

model ResetAccountPasswordRequest {
  accountName: string(name='AccountName', position='Query'),
  accountPassword: string(name='AccountPassword', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
}

model ResetAccountPasswordResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetAccountPasswordResponse = {
  headers: map[string]string(name='headers'),
  body: ResetAccountPasswordResponseBody(name='body'),
}

async function resetAccountPassword(request: ResetAccountPasswordRequest): ResetAccountPasswordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetAccountPassword', 'POST', '/', 'json', false, 'json', request);
}

model RestartDBInstanceRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
}

model RestartDBInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model RestartDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RestartDBInstanceResponseBody(name='body'),
}

async function restartDBInstance(request: RestartDBInstanceRequest): RestartDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RestartDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model SetDataShareInstanceRequest {
  instanceList: [ string ](name='InstanceList', position='Query'),
  operationType: string(name='OperationType', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model SetDataShareInstanceResponseBody = {
  errMessage?: string(name='ErrMessage'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model SetDataShareInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: SetDataShareInstanceResponseBody(name='body'),
}

async function setDataShareInstance(request: SetDataShareInstanceRequest): SetDataShareInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDataShareInstance', 'POST', '/', 'json', false, 'json', request);
}

model SwitchDBInstanceNetTypeRequest {
  connectionStringPrefix: string(name='ConnectionStringPrefix', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  port: string(name='Port', position='Query'),
}

model SwitchDBInstanceNetTypeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SwitchDBInstanceNetTypeResponse = {
  headers: map[string]string(name='headers'),
  body: SwitchDBInstanceNetTypeResponseBody(name='body'),
}

async function switchDBInstanceNetType(request: SwitchDBInstanceNetTypeRequest): SwitchDBInstanceNetTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SwitchDBInstanceNetType', 'POST', '/', 'json', false, 'json', request);
}

model TagResourcesRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagResources', 'POST', '/', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  all?: boolean(name='All', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tagKey?: [ string ](name='TagKey', position='Query'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UntagResources', 'POST', '/', 'json', false, 'json', request);
}

model UpgradeDBInstanceRequest {
  DBInstanceClass: string(name='DBInstanceClass', position='Query'),
  DBInstanceGroupCount: string(name='DBInstanceGroupCount', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  payType?: string(name='PayType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model UpgradeDBInstanceResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model UpgradeDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeDBInstanceResponseBody(name='body'),
}

async function upgradeDBInstance(request: UpgradeDBInstanceRequest): UpgradeDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpgradeDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model UpgradeDBVersionRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  majorVersion?: string(name='MajorVersion', position='Query'),
  minorVersion?: string(name='MinorVersion', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  switchTime?: string(name='SwitchTime', position='Query'),
  switchTimeMode?: string(name='SwitchTimeMode', position='Query'),
}

model UpgradeDBVersionResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  DBInstanceName?: string(name='DBInstanceName'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model UpgradeDBVersionResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeDBVersionResponseBody(name='body'),
}

async function upgradeDBVersion(request: UpgradeDBVersionRequest): UpgradeDBVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpgradeDBVersion', 'POST', '/', 'json', false, 'json', request);
}

