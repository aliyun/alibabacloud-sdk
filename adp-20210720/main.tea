/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('adp', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ComponentVersion {
  appVersion?: string(name='appVersion', description='appVersion'),
  componentName?: string(name='componentName', description='componentName'),
  componentUID?: string(name='componentUID', description='componentUID'),
  description?: string(name='description', description='description'),
  documents?: string(name='documents', description='documents'),
  imagesMapping?: string(name='imagesMapping', description='imagesMapping'),
  namespace?: string(name='namespace', description='namespace'),
  orchestrationType?: string(name='orchestrationType', description='orchestrationType'),
  orchestrationValues?: string(name='orchestrationValues', description='orchestrationValues'),
  packageURL?: string(name='packageURL', description='packageURL'),
  parentComponent?: boolean(name='parentComponent', description='parentComponent'),
  platforms?: [
    Platform
  ](name='platforms', description='platforms'),
  readme?: string(name='readme', description='readme'),
  resources?: string(name='resources', description='resources'),
  source?: string(name='source', description='source'),
  uid?: string(name='uid', description='uid'),
  version?: string(name='version', description='version'),
}

model Disk {
  capacity?: int32(name='capacity', description='capacity'),
  fsType?: string(name='fsType', description='fsType'),
  mountPoint?: string(name='mountPoint', description='mountPoint'),
  name?: string(name='name', description='name'),
  remain?: int32(name='remain', description='remain'),
  type?: string(name='type', description='type'),
}

model ExportPort {
  cidrIP?: string(name='cidrIP', description='目标IP 段'),
  portRange?: string(name='portRange', description='端口范围，格式：start/end'),
  protocol?: string(name='protocol', description='协议'),
  unallowed?: boolean(name='unallowed', description='为true，则代表deny'),
}

model FoundationVersion {
  description?: string(name='description', description='description'),
  documents?: string(name='documents', description='documents'),
  features?: [ string ](name='features', description='底座功能列表'),
  labels?: string(name='labels', description='标签'),
  name?: string(name='name', description='name，目前仅能是 “ADP 底座“'),
  packageTools?: [ 
    {
      name?: string(name='name', description='工具名'),
      version?: string(name='version', description='工具版本'),
    }
  ](name='packageTools', description='打包工具'),
  platforms?: [
    Platform
  ](name='platforms', description='platforms'),
  status?: string(name='status', description='status，ENUM:["Testing","Published","Deprecated"] Published 后，则全平台所有用户可见，请谨慎操作'),
  type?: string(name='type', description='the type of foundation version,ENUM:["trident","ack"]'),
  uid?: string(name='uid', description='uid'),
  version?: string(name='version', description='version'),
}

model GetInstanceInfoResponse {
  annotations?: map[string]string(name='annotations', description='annotations'),
  arch?: string(name='arch', description='arch'),
  cpu?: string(name='cpu', description='cpu'),
  dataDisk?: [
    Disk
  ](name='dataDisk', description='dataDisk'),
  hostName?: string(name='hostName', description='hostName'),
  identifier?: string(name='identifier', description='identifier'),
  imageID?: string(name='imageID', description='imageID'),
  instanceType?: string(name='instanceType', description='instanceType'),
  internetBandwidth?: int32(name='internetBandwidth', description='internetBandwidth'),
  kernel?: string(name='kernel', description='kernel'),
  labels?: map[string]string(name='labels', description='labels'),
  macAddress?: string(name='macAddress', description='macAddress'),
  memory?: string(name='memory', description='memory'),
  networkCards?: [ 
    {
      ip?: string(name='ip', description='ip'),
      name?: string(name='name', description='name'),
    }
  ](name='networkCards', description='networkCards'),
  os?: string(name='os', description='os'),
  osVersion?: string(name='osVersion', description='osVersion'),
  privateIP?: string(name='privateIP', description='privateIP'),
  publicIP?: string(name='publicIP', description='publicIP'),
  rootPassword?: string(name='rootPassword', description='rootPassword'),
  systemDisk?: [
    Disk
  ](name='systemDisk', description='systemDisk'),
  systemInfo?: string(name='systemInfo', description='systemInfo'),
  taints?: [ 
    {
      effect?: string(name='effect', description='effect'),
      key?: string(name='key', description='key'),
      value?: string(name='value', description='value'),
    }
  ](name='taints', description='taints'),
  uid?: string(name='uid', description='uid'),
}

model InstanceInfo {
  annotations?: map[string]string(name='annotations', description='annotations'),
  arch?: string(name='arch', description='arch'),
  cpu?: string(name='cpu', description='cpu'),
  dataDisk?: [
    Disk
  ](name='dataDisk', description='dataDisk'),
  diskConfigAnnotations?: map[string]string(name='diskConfigAnnotations', description='diskConfigAnnotations'),
  hostName?: string(name='hostName', description='hostName'),
  identifier?: string(name='identifier', description='identifier'),
  imageID?: string(name='imageID', description='imageID'),
  instanceType?: string(name='instanceType', description='instanceType'),
  internetBandwidth?: int32(name='internetBandwidth', description='internetBandwidth'),
  kernel?: string(name='kernel', description='kernel'),
  labels?: map[string]string(name='labels', description='labels'),
  macAddress?: string(name='macAddress', description='macAddress'),
  memory?: string(name='memory', description='memory'),
  networkCards?: [ 
    {
      ip?: string(name='ip', description='ip'),
      name?: string(name='name', description='name'),
    }
  ](name='networkCards', description='networkCards'),
  os?: string(name='os', description='os'),
  osVersion?: string(name='osVersion', description='osVersion'),
  privateIP?: string(name='privateIP', description='privateIP'),
  publicIP?: string(name='publicIP', description='publicIP'),
  rootPassword?: string(name='rootPassword', description='rootPassword'),
  systemDisk?: [
    Disk
  ](name='systemDisk', description='systemDisk'),
  systemInfo?: string(name='systemInfo', description='systemInfo'),
  taints?: [ 
    {
      effect?: string(name='effect', description='effect'),
      key?: string(name='key', description='key'),
      value?: string(name='value', description='value'),
    }
  ](name='taints', description='taints'),
}

model Platform {
  architecture?: string(name='architecture', description='architecture'),
  os?: string(name='os', description='os'),
}

model ProductComponentRelationDetail {
  appVersion?: string(name='appVersion', description='appVersion'),
  category?: string(name='category', description='category'),
  class?: string(name='class', description='class'),
  componentName?: string(name='componentName', description='componentName'),
  componentOrchestrationValues?: string(name='componentOrchestrationValues', description='componentOrchestrationValues'),
  componentUID?: string(name='componentUID', description='componentUID'),
  componentVersionUID?: string(name='componentVersionUID', description='componentVersionUID'),
  createdAt?: string(name='createdAt', description='createdAt'),
  description?: string(name='description', description='description'),
  documents?: string(name='documents', description='documents'),
  enable?: boolean(name='enable', description='enable'),
  imagesMapping?: string(name='imagesMapping', description='imagesMapping'),
  namespace?: string(name='namespace', description='namespace'),
  orchestrationType?: string(name='orchestrationType', description='orchestrationType'),
  parentComponent?: boolean(name='parentComponent', description='parentComponent'),
  parentComponentVersionRelationUID?: string(name='parentComponentVersionRelationUID', description='parentComponentVersionRelationUID'),
  parentComponentVersionUID?: string(name='parentComponentVersionUID', description='parentComponentVersionUID'),
  priority?: int32(name='priority', description='priority'),
  productVersionUID?: string(name='productVersionUID', description='productVersionUID'),
  provider?: string(name='provider', description='provider'),
  public?: boolean(name='public', description='public'),
  readme?: string(name='readme', description='readme'),
  relationUID?: string(name='relationUID', description='relationUID'),
  releaseName?: string(name='releaseName', description='releaseName'),
  resources?: string(name='resources', description='resources'),
  sequence?: int32(name='sequence', description='sequence'),
  singleton?: boolean(name='singleton', description='singleton'),
  source?: string(name='source', description='source'),
  version?: string(name='version', description='version'),
}

model Resource {
  cpu?: {
    required?: int32(name='required', description='需要的数量'),
  }(name='cpu', description='cpu'),
  hostname?: string(name='hostname', description='实例hostname'),
  identifier?: string(name='identifier', description='资源分组名'),
  image?: {
    id?: string(name='id', description='image id'),
    nameRegex?: string(name='nameRegex', description='名称正则'),
  }(name='image', description='镜像'),
  instanceType?: string(name='instanceType', description='实例类型'),
  memory?: {
    required?: int32(name='required', description='需要的内存，单位 G'),
  }(name='memory', description='memory'),
  ports?: [
    ExportPort
  ](name='ports', description='需要开放的端口'),
  publicIP?: {
    bandwidth?: int32(name='bandwidth', description='带宽'),
    required?: int32(name='required', description='需要的数量'),
  }(name='publicIP', description='公网IP 需求'),
  replica?: int32(name='replica', description='数量'),
  storage?: [ 
    {
      required?: int32(name='required', description='磁盘大小'),
    }
  ](name='storage', description='存储需求'),
}

model AddEnvironmentNodesRequest {
  applicationDisk?: string(name='applicationDisk', description='保留业务分区'),
  cpu?: int32(name='cpu'),
  dataDisk?: [ 
    {
      name?: string(name='name'),
      required?: int32(name='required'),
    }
  ](name='dataDisk'),
  etcdDisk?: string(name='etcdDisk', description='etcd数据盘'),
  hostName?: string(name='hostName'),
  labels?: map[string]any(name='labels'),
  masterPrivateIPs?: [ string ](name='masterPrivateIPs', description='master privateId'),
  memory?: int32(name='memory'),
  os?: string(name='os'),
  rootPassword?: string(name='rootPassword'),
  systemDisk?: [ 
    {
      name?: string(name='name'),
      required?: int32(name='required'),
    }
  ](name='systemDisk'),
  taints?: [ 
    {
      effect?: string(name='effect'),
      key?: string(name='key'),
      value?: string(name='value'),
    }
  ](name='taints'),
  tridentSystemDisk?: string(name='tridentSystemDisk', description='k8s管控数据盘'),
  tridentSystemSizeDisk?: int32(name='tridentSystemSizeDisk', description='k8s管控数据盘大小'),
  workerPrivateIPs?: [ string ](name='workerPrivateIPs', description='work privateIp'),
}

model AddEnvironmentNodesResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model AddEnvironmentNodesResponse = {
  headers: map[string]string(name='headers'),
  body: AddEnvironmentNodesResponseBody(name='body'),
}

async function addEnvironmentNodes(uid: string, request: AddEnvironmentNodesRequest): AddEnvironmentNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addEnvironmentNodesWithOptions(uid, request, headers, runtime);
}

async function addEnvironmentNodesWithOptions(uid: string, request: AddEnvironmentNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddEnvironmentNodesResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  var body : map[string]any= {};
  if (!Util.isUnset(request.applicationDisk)) {
    body['applicationDisk'] = request.applicationDisk;
  }
  if (!Util.isUnset(request.cpu)) {
    body['cpu'] = request.cpu;
  }
  if (!Util.isUnset(request.dataDisk)) {
    body['dataDisk'] = request.dataDisk;
  }
  if (!Util.isUnset(request.etcdDisk)) {
    body['etcdDisk'] = request.etcdDisk;
  }
  if (!Util.isUnset(request.hostName)) {
    body['hostName'] = request.hostName;
  }
  if (!Util.isUnset(request.labels)) {
    body['labels'] = request.labels;
  }
  if (!Util.isUnset(request.masterPrivateIPs)) {
    body['masterPrivateIPs'] = request.masterPrivateIPs;
  }
  if (!Util.isUnset(request.memory)) {
    body['memory'] = request.memory;
  }
  if (!Util.isUnset(request.os)) {
    body['os'] = request.os;
  }
  if (!Util.isUnset(request.rootPassword)) {
    body['rootPassword'] = request.rootPassword;
  }
  if (!Util.isUnset(request.systemDisk)) {
    body['systemDisk'] = request.systemDisk;
  }
  if (!Util.isUnset(request.taints)) {
    body['taints'] = request.taints;
  }
  if (!Util.isUnset(request.tridentSystemDisk)) {
    body['tridentSystemDisk'] = request.tridentSystemDisk;
  }
  if (!Util.isUnset(request.tridentSystemSizeDisk)) {
    body['tridentSystemSizeDisk'] = request.tridentSystemSizeDisk;
  }
  if (!Util.isUnset(request.workerPrivateIPs)) {
    body['workerPrivateIPs'] = request.workerPrivateIPs;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddEnvironmentNodes',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${uid}/nodes`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AddProductComponentVersionRequest {
  releaseName?: string(name='releaseName'),
}

model AddProductComponentVersionResponseBody = {
  code?: string(name='code'),
  data?: {
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model AddProductComponentVersionResponse = {
  headers: map[string]string(name='headers'),
  body: AddProductComponentVersionResponseBody(name='body'),
}

async function addProductComponentVersion(uid: string, componentVersionUID: string, request: AddProductComponentVersionRequest): AddProductComponentVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addProductComponentVersionWithOptions(uid, componentVersionUID, request, headers, runtime);
}

async function addProductComponentVersionWithOptions(uid: string, componentVersionUID: string, request: AddProductComponentVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddProductComponentVersionResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  componentVersionUID = OpenApiUtil.getEncodeParam(componentVersionUID);
  var body : map[string]any= {};
  if (!Util.isUnset(request.releaseName)) {
    body['releaseName'] = request.releaseName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddProductComponentVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/integration/api/v2/product-versions/${uid}/component-versions/${componentVersionUID}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AddProductVersionConfigRequest {
  componentVersionUID?: string(name='componentVersionUID', description='组件uid'),
  description?: string(name='description', description='配置说明'),
  name?: string(name='name', description='配置信息key'),
  parentComponentVersionUID?: string(name='parentComponentVersionUID', description='父组件uid'),
  value?: string(name='value', description='配置信息value'),
  valueType?: string(name='valueType'),
}

model AddProductVersionConfigResponseBody = {
  code?: string(name='code'),
  data?: {
    uid?: string(name='uid', description='product version config uid'),
  }(name='data'),
  msg?: string(name='msg'),
  requestId?: string(name='requestId', description='Id of the request'),
}

model AddProductVersionConfigResponse = {
  headers: map[string]string(name='headers'),
  body: AddProductVersionConfigResponseBody(name='body'),
}

async function addProductVersionConfig(uid: string, request: AddProductVersionConfigRequest): AddProductVersionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addProductVersionConfigWithOptions(uid, request, headers, runtime);
}

async function addProductVersionConfigWithOptions(uid: string, request: AddProductVersionConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddProductVersionConfigResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  var body : map[string]any= {};
  if (!Util.isUnset(request.componentVersionUID)) {
    body['componentVersionUID'] = request.componentVersionUID;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.parentComponentVersionUID)) {
    body['parentComponentVersionUID'] = request.parentComponentVersionUID;
  }
  if (!Util.isUnset(request.value)) {
    body['value'] = request.value;
  }
  if (!Util.isUnset(request.valueType)) {
    body['valueType'] = request.valueType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddProductVersionConfig',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${uid}/configs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchAddEnvironmentNodesRequest {
  instanceList?: [
    InstanceInfo
  ](name='instanceList'),
}

model BatchAddEnvironmentNodesResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model BatchAddEnvironmentNodesResponse = {
  headers: map[string]string(name='headers'),
  body: BatchAddEnvironmentNodesResponseBody(name='body'),
}

async function batchAddEnvironmentNodes(uid: string, request: BatchAddEnvironmentNodesRequest): BatchAddEnvironmentNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchAddEnvironmentNodesWithOptions(uid, request, headers, runtime);
}

async function batchAddEnvironmentNodesWithOptions(uid: string, request: BatchAddEnvironmentNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchAddEnvironmentNodesResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  var body : map[string]any= {};
  if (!Util.isUnset(request.instanceList)) {
    body['instanceList'] = request.instanceList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchAddEnvironmentNodes',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${uid}/batch/nodes`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchAddProductVersionConfigRequest {
  productVersionConfigList?: [ 
    {
      componentVersionUID?: string(name='componentVersionUID', description='组件uid'),
      description?: string(name='description', description='配置说明'),
      name?: string(name='name', description='配置信息key'),
      parentComponentVersionUID?: string(name='parentComponentVersionUID', description='父组件uid'),
      value?: string(name='value', description='配置信息value'),
      valueType?: string(name='valueType'),
    }
  ](name='productVersionConfigList'),
}

model BatchAddProductVersionConfigResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model BatchAddProductVersionConfigResponse = {
  headers: map[string]string(name='headers'),
  body: BatchAddProductVersionConfigResponseBody(name='body'),
}

async function batchAddProductVersionConfig(uid: string, request: BatchAddProductVersionConfigRequest): BatchAddProductVersionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchAddProductVersionConfigWithOptions(uid, request, headers, runtime);
}

async function batchAddProductVersionConfigWithOptions(uid: string, request: BatchAddProductVersionConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchAddProductVersionConfigResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  var body : map[string]any= {};
  if (!Util.isUnset(request.productVersionConfigList)) {
    body['productVersionConfigList'] = request.productVersionConfigList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchAddProductVersionConfig',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${uid}/batch/configs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateEnvironmentHeaders {
  commonHeaders?: map[string]string,
  clientToken?: string(name='ClientToken'),
}

model CreateEnvironmentRequest {
  description?: string(name='description'),
  location?: string(name='location'),
  name?: string(name='name'),
  platform?: {
    architecture?: string(name='architecture'),
    os?: string(name='os'),
  }(name='platform'),
  productVersionUID?: string(name='productVersionUID'),
  type?: string(name='type', description='环境类型'),
  vendorConfig?: string(name='vendorConfig'),
  vendorType?: string(name='vendorType'),
}

model CreateEnvironmentResponseBody = {
  code?: string(name='code'),
  data?: {
    environmentUID?: string(name='environmentUID'),
    vendorConfig?: string(name='vendorConfig'),
  }(name='data'),
  msg?: string(name='msg'),
}

model CreateEnvironmentResponse = {
  headers: map[string]string(name='headers'),
  body: CreateEnvironmentResponseBody(name='body'),
}

async function createEnvironment(request: CreateEnvironmentRequest): CreateEnvironmentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateEnvironmentHeaders{};
  return createEnvironmentWithOptions(request, headers, runtime);
}

async function createEnvironmentWithOptions(request: CreateEnvironmentRequest, headers: CreateEnvironmentHeaders, runtime: Util.RuntimeOptions): CreateEnvironmentResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.location)) {
    body['location'] = request.location;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.platform)) {
    body['platform'] = request.platform;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    body['productVersionUID'] = request.productVersionUID;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }
  if (!Util.isUnset(request.vendorConfig)) {
    body['vendorConfig'] = request.vendorConfig;
  }
  if (!Util.isUnset(request.vendorType)) {
    body['vendorType'] = request.vendorType;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.clientToken)) {
    realHeaders['ClientToken'] = Util.toJSONString(headers.clientToken);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateEnvironment',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateEnvironmentLicenseRequest {
  companyName?: string(name='companyName', description='企业名称'),
  contact?: string(name='contact', description='联系方式'),
  machineFingerprint?: string(name='machineFingerprint', description='机器指纹信息'),
  scenario?: string(name='scenario', description='使用场景'),
  type?: string(name='type', description='证书类型'),
}

model CreateEnvironmentLicenseResponseBody = {
  code?: string(name='code'),
  data?: {
    uid?: string(name='uid', description='license uid'),
  }(name='data', description='业务数据'),
  msg?: string(name='msg'),
}

model CreateEnvironmentLicenseResponse = {
  headers: map[string]string(name='headers'),
  body: CreateEnvironmentLicenseResponseBody(name='body'),
}

async function createEnvironmentLicense(uid: string, request: CreateEnvironmentLicenseRequest): CreateEnvironmentLicenseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createEnvironmentLicenseWithOptions(uid, request, headers, runtime);
}

async function createEnvironmentLicenseWithOptions(uid: string, request: CreateEnvironmentLicenseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateEnvironmentLicenseResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  var body : map[string]any= {};
  if (!Util.isUnset(request.companyName)) {
    body['companyName'] = request.companyName;
  }
  if (!Util.isUnset(request.contact)) {
    body['contact'] = request.contact;
  }
  if (!Util.isUnset(request.machineFingerprint)) {
    body['machineFingerprint'] = request.machineFingerprint;
  }
  if (!Util.isUnset(request.scenario)) {
    body['scenario'] = request.scenario;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateEnvironmentLicense',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${uid}/licenses`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateFoundationReferenceRequest {
  clusterConfig?: string(name='clusterConfig'),
  foundationVersionUID?: string(name='foundationVersionUID'),
}

model CreateFoundationReferenceResponseBody = {
  code?: string(name='code'),
  data?: {
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model CreateFoundationReferenceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFoundationReferenceResponseBody(name='body'),
}

async function createFoundationReference(request: CreateFoundationReferenceRequest): CreateFoundationReferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFoundationReferenceWithOptions(request, headers, runtime);
}

async function createFoundationReferenceWithOptions(request: CreateFoundationReferenceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFoundationReferenceResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.clusterConfig)) {
    body['clusterConfig'] = request.clusterConfig;
  }
  if (!Util.isUnset(request.foundationVersionUID)) {
    body['foundationVersionUID'] = request.foundationVersionUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFoundationReference',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/foundation-references`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateProductHeaders {
  commonHeaders?: map[string]string,
  clientToken?: string(name='ClientToken'),
}

model CreateProductRequest {
  description?: string(name='description'),
  foundationVersionUID?: string(name='foundationVersionUID'),
  productName?: string(name='productName'),
}

model CreateProductResponseBody = {
  code?: string(name='code'),
  data?: {
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model CreateProductResponse = {
  headers: map[string]string(name='headers'),
  body: CreateProductResponseBody(name='body'),
}

async function createProduct(request: CreateProductRequest): CreateProductResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateProductHeaders{};
  return createProductWithOptions(request, headers, runtime);
}

async function createProductWithOptions(request: CreateProductRequest, headers: CreateProductHeaders, runtime: Util.RuntimeOptions): CreateProductResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.foundationVersionUID)) {
    body['foundationVersionUID'] = request.foundationVersionUID;
  }
  if (!Util.isUnset(request.productName)) {
    body['productName'] = request.productName;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.clientToken)) {
    realHeaders['ClientToken'] = Util.toJSONString(headers.clientToken);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateProduct',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/integration/api/v2/products`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateProductDeploymentRequest {
  environmentUID?: string(name='environmentUID', description='环境uid'),
  oldProductVersionUID?: string(name='oldProductVersionUID', description='旧产品版本uid'),
  packageUID?: string(name='packageUID', description='部署包uid'),
  productVersionUID?: string(name='productVersionUID', description='产品版本uid'),
}

model CreateProductDeploymentResponseBody = {
  code?: string(name='code', description='错误码'),
  data?: {
    uid?: string(name='uid', description='部署uid'),
  }(name='data', description='数据'),
  msg?: string(name='msg', description='错误信息'),
}

model CreateProductDeploymentResponse = {
  headers: map[string]string(name='headers'),
  body: CreateProductDeploymentResponseBody(name='body'),
}

async function createProductDeployment(request: CreateProductDeploymentRequest): CreateProductDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createProductDeploymentWithOptions(request, headers, runtime);
}

async function createProductDeploymentWithOptions(request: CreateProductDeploymentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateProductDeploymentResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.environmentUID)) {
    body['environmentUID'] = request.environmentUID;
  }
  if (!Util.isUnset(request.oldProductVersionUID)) {
    body['oldProductVersionUID'] = request.oldProductVersionUID;
  }
  if (!Util.isUnset(request.packageUID)) {
    body['packageUID'] = request.packageUID;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    body['productVersionUID'] = request.productVersionUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateProductDeployment',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-instances/deployments`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateProductVersionResponseBody = {
  code?: string(name='code'),
  data?: {
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model CreateProductVersionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateProductVersionResponseBody(name='body'),
}

async function createProductVersion(uid: string): CreateProductVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createProductVersionWithOptions(uid, headers, runtime);
}

async function createProductVersionWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): CreateProductVersionResponse {
  uid = OpenApiUtil.getEncodeParam(uid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CreateProductVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/integration/api/v2/products/${uid}/versions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateProductVersionPackageHeaders {
  commonHeaders?: map[string]string,
  clientToken?: string(name='ClientToken'),
}

model CreateProductVersionPackageRequest {
  oldProductVersionUID?: string(name='oldProductVersionUID'),
  packageContentType?: string(name='packageContentType', description='ENUM:["all","base"."application"]'),
  packageType?: string(name='packageType', description='ENUM:["full","upgrade"]'),
  platform?: string(name='platform'),
}

model CreateProductVersionPackageResponseBody = {
  code?: string(name='code'),
  data?: {
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model CreateProductVersionPackageResponse = {
  headers: map[string]string(name='headers'),
  body: CreateProductVersionPackageResponseBody(name='body'),
}

async function createProductVersionPackage(uid: string, request: CreateProductVersionPackageRequest): CreateProductVersionPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateProductVersionPackageHeaders{};
  return createProductVersionPackageWithOptions(uid, request, headers, runtime);
}

async function createProductVersionPackageWithOptions(uid: string, request: CreateProductVersionPackageRequest, headers: CreateProductVersionPackageHeaders, runtime: Util.RuntimeOptions): CreateProductVersionPackageResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  var query : map[string]any= {};
  if (!Util.isUnset(request.oldProductVersionUID)) {
    query['oldProductVersionUID'] = request.oldProductVersionUID;
  }
  if (!Util.isUnset(request.packageContentType)) {
    query['packageContentType'] = request.packageContentType;
  }
  if (!Util.isUnset(request.packageType)) {
    query['packageType'] = request.packageType;
  }
  if (!Util.isUnset(request.platform)) {
    query['platform'] = request.platform;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.clientToken)) {
    realHeaders['ClientToken'] = Util.toJSONString(headers.clientToken);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateProductVersionPackage',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/hosting/product-versions/${uid}/packages`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteEnvironmentResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model DeleteEnvironmentResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEnvironmentResponseBody(name='body'),
}

async function deleteEnvironment(uid: string): DeleteEnvironmentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteEnvironmentWithOptions(uid, headers, runtime);
}

async function deleteEnvironmentWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteEnvironmentResponse {
  uid = OpenApiUtil.getEncodeParam(uid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteEnvironment',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${uid}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteEnvironmentNodeResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model DeleteEnvironmentNodeResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEnvironmentNodeResponseBody(name='body'),
}

async function deleteEnvironmentNode(uid: string, nodeUID: string): DeleteEnvironmentNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteEnvironmentNodeWithOptions(uid, nodeUID, headers, runtime);
}

async function deleteEnvironmentNodeWithOptions(uid: string, nodeUID: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteEnvironmentNodeResponse {
  uid = OpenApiUtil.getEncodeParam(uid);
  nodeUID = OpenApiUtil.getEncodeParam(nodeUID);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteEnvironmentNode',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${uid}/nodes/${nodeUID}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteEnvironmentProductVersionResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model DeleteEnvironmentProductVersionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEnvironmentProductVersionResponseBody(name='body'),
}

async function deleteEnvironmentProductVersion(uid: string, productVersionUID: string): DeleteEnvironmentProductVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteEnvironmentProductVersionWithOptions(uid, productVersionUID, headers, runtime);
}

async function deleteEnvironmentProductVersionWithOptions(uid: string, productVersionUID: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteEnvironmentProductVersionResponse {
  uid = OpenApiUtil.getEncodeParam(uid);
  productVersionUID = OpenApiUtil.getEncodeParam(productVersionUID);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteEnvironmentProductVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${uid}/product-versions/${productVersionUID}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteProductResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model DeleteProductResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteProductResponseBody(name='body'),
}

async function deleteProduct(uid: string): DeleteProductResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProductWithOptions(uid, headers, runtime);
}

async function deleteProductWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProductResponse {
  uid = OpenApiUtil.getEncodeParam(uid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteProduct',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/integration/api/v2/products/${uid}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteProductComponentVersionResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model DeleteProductComponentVersionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteProductComponentVersionResponseBody(name='body'),
}

async function deleteProductComponentVersion(uid: string, relationUID: string): DeleteProductComponentVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProductComponentVersionWithOptions(uid, relationUID, headers, runtime);
}

async function deleteProductComponentVersionWithOptions(uid: string, relationUID: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProductComponentVersionResponse {
  uid = OpenApiUtil.getEncodeParam(uid);
  relationUID = OpenApiUtil.getEncodeParam(relationUID);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteProductComponentVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${uid}/relations/${relationUID}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteProductInstanceConfigRequest {
  environmentUID?: string(name='environmentUID'),
  productVersionUID?: string(name='productVersionUID'),
}

model DeleteProductInstanceConfigResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model DeleteProductInstanceConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteProductInstanceConfigResponseBody(name='body'),
}

async function deleteProductInstanceConfig(configUID: string, request: DeleteProductInstanceConfigRequest): DeleteProductInstanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProductInstanceConfigWithOptions(configUID, request, headers, runtime);
}

async function deleteProductInstanceConfigWithOptions(configUID: string, request: DeleteProductInstanceConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProductInstanceConfigResponse {
  Util.validateModel(request);
  configUID = OpenApiUtil.getEncodeParam(configUID);
  var query : map[string]any= {};
  if (!Util.isUnset(request.environmentUID)) {
    query['environmentUID'] = request.environmentUID;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    query['productVersionUID'] = request.productVersionUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProductInstanceConfig',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-instances/configs/${configUID}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteProductVersionResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
  requestId?: string(name='requestId', description='Id of the request'),
}

model DeleteProductVersionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteProductVersionResponseBody(name='body'),
}

async function deleteProductVersion(uid: string): DeleteProductVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProductVersionWithOptions(uid, headers, runtime);
}

async function deleteProductVersionWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProductVersionResponse {
  uid = OpenApiUtil.getEncodeParam(uid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteProductVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${uid}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteProductVersionConfigResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
  requestId?: string(name='requestId', description='Id of the request'),
}

model DeleteProductVersionConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteProductVersionConfigResponseBody(name='body'),
}

async function deleteProductVersionConfig(uid: string, configUID: string): DeleteProductVersionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProductVersionConfigWithOptions(uid, configUID, headers, runtime);
}

async function deleteProductVersionConfigWithOptions(uid: string, configUID: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProductVersionConfigResponse {
  uid = OpenApiUtil.getEncodeParam(uid);
  configUID = OpenApiUtil.getEncodeParam(configUID);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteProductVersionConfig',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${uid}/configs/${configUID}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GenerateProductInstanceDeploymentConfigRequest {
  environmentUID?: string(name='environmentUID'),
  productVersionUID?: string(name='productVersionUID'),
}

model GenerateProductInstanceDeploymentConfigResponseBody = {
  code?: string(name='code'),
  data?: {
    packageConfig?: string(name='packageConfig'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GenerateProductInstanceDeploymentConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateProductInstanceDeploymentConfigResponseBody(name='body'),
}

async function generateProductInstanceDeploymentConfig(request: GenerateProductInstanceDeploymentConfigRequest): GenerateProductInstanceDeploymentConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return generateProductInstanceDeploymentConfigWithOptions(request, headers, runtime);
}

async function generateProductInstanceDeploymentConfigWithOptions(request: GenerateProductInstanceDeploymentConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GenerateProductInstanceDeploymentConfigResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.environmentUID)) {
    body['environmentUID'] = request.environmentUID;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    body['productVersionUID'] = request.productVersionUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GenerateProductInstanceDeploymentConfig',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-instances/package-configs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetComponentResponseBody = {
  code?: string(name='code'),
  data?: {
    category?: string(name='category'),
    description?: string(name='description'),
    documents?: string(name='documents'),
    name?: string(name='name'),
    public?: boolean(name='public'),
    singleton?: boolean(name='singleton'),
    source?: string(name='source'),
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GetComponentResponse = {
  headers: map[string]string(name='headers'),
  body: GetComponentResponseBody(name='body'),
}

async function getComponent(uid: string): GetComponentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getComponentWithOptions(uid, headers, runtime);
}

async function getComponentWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetComponentResponse {
  uid = OpenApiUtil.getEncodeParam(uid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetComponent',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/components/${uid}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetComponentVersionResponseBody = {
  code?: string(name='code'),
  data?: [ 
    {
      componentName?: string(name='componentName'),
      componentUID?: string(name='componentUID'),
      description?: string(name='description'),
      documents?: [ string ](name='documents'),
      orchestrationValues?: string(name='orchestrationValues'),
      packageURL?: string(name='packageURL'),
      parentComponent?: boolean(name='parentComponent'),
      productComponentVersionUID?: string(name='productComponentVersionUID'),
      provider?: string(name='provider'),
      readme?: string(name='readme'),
      resources?: string(name='resources'),
      uid?: string(name='uid'),
      version?: string(name='version'),
    }
  ](name='data'),
  msg?: string(name='msg'),
}

model GetComponentVersionResponse = {
  headers: map[string]string(name='headers'),
  body: GetComponentVersionResponseBody(name='body'),
}

async function getComponentVersion(uid: string, versionUID: string): GetComponentVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getComponentVersionWithOptions(uid, versionUID, headers, runtime);
}

async function getComponentVersionWithOptions(uid: string, versionUID: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetComponentVersionResponse {
  uid = OpenApiUtil.getEncodeParam(uid);
  versionUID = OpenApiUtil.getEncodeParam(versionUID);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetComponentVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/integration/api/v2/components/${uid}/versions/${versionUID}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetEnvironmentResponseBody = {
  code?: string(name='code'),
  data?: {
    clusterId?: string(name='clusterId'),
    createdAt?: string(name='createdAt'),
    description?: string(name='description'),
    foundationVersion?: string(name='foundationVersion'),
    foundationVersionUID?: string(name='foundationVersionUID'),
    instanceList?: [
      InstanceInfo
    ](name='instanceList'),
    instanceStatus?: string(name='instanceStatus'),
    location?: string(name='location'),
    name?: string(name='name'),
    oldProductVersion?: string(name='oldProductVersion'),
    oldProductVersionUID?: string(name='oldProductVersionUID'),
    platform?: {
      architecture?: string(name='architecture'),
      os?: string(name='os'),
    }(name='platform'),
    productName?: string(name='productName'),
    productVersion?: string(name='productVersion'),
    uid?: string(name='uid'),
    vendorConfig?: string(name='vendorConfig'),
    vendorType?: string(name='vendorType'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GetEnvironmentResponse = {
  headers: map[string]string(name='headers'),
  body: GetEnvironmentResponseBody(name='body'),
}

async function getEnvironment(uid: string): GetEnvironmentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEnvironmentWithOptions(uid, headers, runtime);
}

async function getEnvironmentWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetEnvironmentResponse {
  uid = OpenApiUtil.getEncodeParam(uid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetEnvironment',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${uid}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetEnvironmentLicenseResponseBody = {
  code?: string(name='code', description='错误码'),
  data?: {
    expireTime?: string(name='expireTime', description='过期时间'),
    licenseKey?: string(name='licenseKey', description='license内容'),
    licenseQuota?: {
      clusterQuota?: {
        cpuCoreLimit?: long(name='cpuCoreLimit', description='cpu核数限制'),
      }(name='clusterQuota', description='集群配额'),
      componentQuotas?: [ 
        {
          componentName?: string(name='componentName', description='组件名'),
          componentSource?: string(name='componentSource', description='组件来源'),
          instanceLimit?: long(name='instanceLimit', description='实例数限制'),
        }
      ](name='componentQuotas', description='组件配额'),
    }(name='licenseQuota', description='license配额'),
    rejectReason?: string(name='rejectReason', description='拒绝原因'),
    status?: string(name='status', description='状态'),
    type?: string(name='type', description='类型'),
    uid?: string(name='uid', description='license uid'),
  }(name='data'),
  msg?: string(name='msg', description='错误信息'),
}

model GetEnvironmentLicenseResponse = {
  headers: map[string]string(name='headers'),
  body: GetEnvironmentLicenseResponseBody(name='body'),
}

async function getEnvironmentLicense(uid: string, licenseUID: string): GetEnvironmentLicenseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEnvironmentLicenseWithOptions(uid, licenseUID, headers, runtime);
}

async function getEnvironmentLicenseWithOptions(uid: string, licenseUID: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetEnvironmentLicenseResponse {
  uid = OpenApiUtil.getEncodeParam(uid);
  licenseUID = OpenApiUtil.getEncodeParam(licenseUID);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetEnvironmentLicense',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${uid}/licenses/${licenseUID}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetEnvironmentNodeResponseBody = {
  code?: string(name='code'),
  data?: {
    arch?: string(name='arch', description='arch'),
    clusterUID?: string(name='clusterUID'),
    cpu?: string(name='cpu', description='cpu'),
    createdAt?: string(name='createdAt'),
    dataDisk?: [
      Disk
    ](name='dataDisk', description='dataDisk'),
    hostName?: string(name='hostName', description='hostName'),
    identifier?: string(name='identifier', description='identifier'),
    imageID?: string(name='imageID', description='imageID'),
    instanceType?: string(name='instanceType', description='instanceType'),
    internetBandwidth?: int32(name='internetBandwidth', description='internetBandwidth'),
    kernel?: string(name='kernel', description='kernel'),
    labels?: map[string]string(name='labels', description='labels'),
    macAddress?: string(name='macAddress', description='macAddress'),
    memory?: string(name='memory', description='memory'),
    networkCards?: [ 
      {
        ip?: string(name='ip', description='ip'),
        name?: string(name='name', description='name'),
      }
    ](name='networkCards', description='networkCards'),
    os?: string(name='os', description='os'),
    osVersion?: string(name='osVersion', description='osVersion'),
    privateIP?: string(name='privateIP', description='privateIP'),
    publicIP?: string(name='publicIP', description='publicIP'),
    rootPassword?: string(name='rootPassword', description='rootPassword'),
    systemDisk?: [
      Disk
    ](name='systemDisk', description='systemDisk'),
    systemInfo?: string(name='systemInfo', description='systemInfo'),
    taints?: [ 
      {
        effect?: string(name='effect', description='effect'),
        key?: string(name='key', description='key'),
        value?: string(name='value', description='value'),
      }
    ](name='taints', description='taints'),
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GetEnvironmentNodeResponse = {
  headers: map[string]string(name='headers'),
  body: GetEnvironmentNodeResponseBody(name='body'),
}

async function getEnvironmentNode(uid: string, nodeUID: string): GetEnvironmentNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEnvironmentNodeWithOptions(uid, nodeUID, headers, runtime);
}

async function getEnvironmentNodeWithOptions(uid: string, nodeUID: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetEnvironmentNodeResponse {
  uid = OpenApiUtil.getEncodeParam(uid);
  nodeUID = OpenApiUtil.getEncodeParam(nodeUID);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetEnvironmentNode',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${uid}/nodes/${nodeUID}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetFoundationComponentReferenceResponseBody = {
  code?: string(name='code'),
  data?: [ 
    {
      appVersion?: string(name='appVersion'),
      componentDescription?: string(name='componentDescription'),
      componentName?: string(name='componentName'),
      componentReferenceUID?: string(name='componentReferenceUID'),
      componentUID?: string(name='componentUID'),
      componentVersionDescription?: string(name='componentVersionDescription'),
      componentVersionUID?: string(name='componentVersionUID'),
      enable?: boolean(name='enable'),
      namespace?: string(name='namespace'),
      orchestrationValues?: string(name='orchestrationValues'),
      parentComponent?: boolean(name='parentComponent'),
      parentComponentVersionRelationUID?: string(name='parentComponentVersionRelationUID'),
      parentComponentVersionUID?: string(name='parentComponentVersionUID'),
      releaseName?: string(name='releaseName'),
      resources?: string(name='resources'),
      sequence?: int32(name='sequence'),
      values?: string(name='values'),
      version?: string(name='version'),
    }
  ](name='data'),
  msg?: string(name='msg'),
}

model GetFoundationComponentReferenceResponse = {
  headers: map[string]string(name='headers'),
  body: GetFoundationComponentReferenceResponseBody(name='body'),
}

async function getFoundationComponentReference(componentReferenceUID: string, uid: string): GetFoundationComponentReferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFoundationComponentReferenceWithOptions(componentReferenceUID, uid, headers, runtime);
}

async function getFoundationComponentReferenceWithOptions(componentReferenceUID: string, uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetFoundationComponentReferenceResponse {
  componentReferenceUID = OpenApiUtil.getEncodeParam(componentReferenceUID);
  uid = OpenApiUtil.getEncodeParam(uid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetFoundationComponentReference',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/foundation-references/${uid}/components/${componentReferenceUID}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetFoundationVersionResponseBody = {
  code?: string(name='code'),
  data?: {
    description?: string(name='description', description='description'),
    features?: [ string ](name='features', description='底座功能列表'),
    labels?: string(name='labels'),
    name?: string(name='name', description='name，目前仅能是 “ADP 底座“'),
    platforms?: [
      Platform
    ](name='platforms', description='platforms'),
    status?: string(name='status', description='status，ENUM:["Testing","Published","Deprecated"] Published 后，则全平台所有用户可见，请谨慎操作'),
    type?: string(name='type', description='the type of foundation version,ENUM:["trident","ack"]'),
    uid?: string(name='uid', description='uid'),
    version?: string(name='version', description='version'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GetFoundationVersionResponse = {
  headers: map[string]string(name='headers'),
  body: GetFoundationVersionResponseBody(name='body'),
}

async function getFoundationVersion(uid: string): GetFoundationVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFoundationVersionWithOptions(uid, headers, runtime);
}

async function getFoundationVersionWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetFoundationVersionResponse {
  uid = OpenApiUtil.getEncodeParam(uid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetFoundationVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/foundation/versions/${uid}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProductResponseBody = {
  code?: string(name='code'),
  data?: {
    description?: string(name='description'),
    name?: string(name='name'),
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GetProductResponse = {
  headers: map[string]string(name='headers'),
  body: GetProductResponseBody(name='body'),
}

async function getProduct(uid: string): GetProductResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProductWithOptions(uid, headers, runtime);
}

async function getProductWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetProductResponse {
  uid = OpenApiUtil.getEncodeParam(uid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetProduct',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/products/${uid}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProductComponentVersionResponseBody = {
  code?: string(name='code'),
  data?: [ 
    {
      appVersion?: string(name='appVersion'),
      componentDescription?: string(name='componentDescription'),
      componentName?: string(name='componentName'),
      componentUID?: string(name='componentUID'),
      componentVersionDescription?: string(name='componentVersionDescription'),
      componentVersionUID?: string(name='componentVersionUID'),
      enable?: boolean(name='enable'),
      namespace?: string(name='namespace'),
      orchestrationValues?: string(name='orchestrationValues'),
      parentComponent?: boolean(name='parentComponent'),
      parentComponentVersionRelationUID?: string(name='parentComponentVersionRelationUID'),
      parentComponentVersionUID?: string(name='parentComponentVersionUID'),
      productVersionUID?: string(name='productVersionUID'),
      relationUID?: string(name='relationUID'),
      releaseName?: string(name='releaseName'),
      resources?: string(name='resources'),
      sequence?: int32(name='sequence'),
      values?: string(name='values'),
      version?: string(name='version'),
    }
  ](name='data'),
  msg?: string(name='msg'),
}

model GetProductComponentVersionResponse = {
  headers: map[string]string(name='headers'),
  body: GetProductComponentVersionResponseBody(name='body'),
}

async function getProductComponentVersion(relationUID: string, uid: string): GetProductComponentVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProductComponentVersionWithOptions(relationUID, uid, headers, runtime);
}

async function getProductComponentVersionWithOptions(relationUID: string, uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetProductComponentVersionResponse {
  relationUID = OpenApiUtil.getEncodeParam(relationUID);
  uid = OpenApiUtil.getEncodeParam(uid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetProductComponentVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/integration/api/v2/product-versions/${uid}/relations/${relationUID}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProductDeploymentRequest {
  environmentUID?: string(name='environmentUID'),
  productVersionUID?: string(name='productVersionUID'),
  withParamConfig?: boolean(name='withParamConfig'),
}

model GetProductDeploymentResponseBody = {
  code?: string(name='code'),
  data?: {
    envParams?: string(name='envParams'),
    envUID?: string(name='envUID'),
    status?: string(name='status'),
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GetProductDeploymentResponse = {
  headers: map[string]string(name='headers'),
  body: GetProductDeploymentResponseBody(name='body'),
}

async function getProductDeployment(deploymentUID: string, request: GetProductDeploymentRequest): GetProductDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProductDeploymentWithOptions(deploymentUID, request, headers, runtime);
}

async function getProductDeploymentWithOptions(deploymentUID: string, request: GetProductDeploymentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProductDeploymentResponse {
  Util.validateModel(request);
  deploymentUID = OpenApiUtil.getEncodeParam(deploymentUID);
  var query : map[string]any= {};
  if (!Util.isUnset(request.environmentUID)) {
    query['environmentUID'] = request.environmentUID;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    query['productVersionUID'] = request.productVersionUID;
  }
  if (!Util.isUnset(request.withParamConfig)) {
    query['withParamConfig'] = request.withParamConfig;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProductDeployment',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-instances/deployments/${deploymentUID}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProductVersionResponseBody = {
  code?: string(name='code'),
  data?: {
    description?: string(name='description'),
    foundationVersionUID?: string(name='foundationVersionUID'),
    packageURL?: string(name='packageURL'),
    platforms?: [
      Platform
    ](name='platforms'),
    productName?: string(name='productName'),
    productUID?: string(name='productUID'),
    provider?: string(name='provider'),
    uid?: string(name='uid'),
    version?: string(name='version'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GetProductVersionResponse = {
  headers: map[string]string(name='headers'),
  body: GetProductVersionResponseBody(name='body'),
}

async function getProductVersion(uid: string): GetProductVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProductVersionWithOptions(uid, headers, runtime);
}

async function getProductVersionWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetProductVersionResponse {
  uid = OpenApiUtil.getEncodeParam(uid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetProductVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${uid}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProductVersionDifferencesRequest {
  preVersionUID?: string(name='preVersionUID', description='上一个产品版本id'),
}

model GetProductVersionDifferencesResponseBody = {
  code?: string(name='code'),
  data?: [ 
    {
      componentName?: string(name='componentName', description='组件名称'),
      difference?: string(name='difference', description='变更类型，ENUM 类型'),
      message?: string(name='message', description='变更描述信息'),
      preVersion?: string(name='preVersion', description='组件之前的版本号'),
      releaseName?: string(name='releaseName', description='组件实例名称'),
      upgradeFlag?: boolean(name='upgradeFlag'),
      version?: string(name='version', description='组件当前的版本号'),
    }
  ](name='data'),
  msg?: string(name='msg'),
  requestId?: string(name='requestId', description='Id of the request'),
}

model GetProductVersionDifferencesResponse = {
  headers: map[string]string(name='headers'),
  body: GetProductVersionDifferencesResponseBody(name='body'),
}

async function getProductVersionDifferences(uid: string, versionUID: string, request: GetProductVersionDifferencesRequest): GetProductVersionDifferencesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProductVersionDifferencesWithOptions(uid, versionUID, request, headers, runtime);
}

async function getProductVersionDifferencesWithOptions(uid: string, versionUID: string, request: GetProductVersionDifferencesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProductVersionDifferencesResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  versionUID = OpenApiUtil.getEncodeParam(versionUID);
  var query : map[string]any= {};
  if (!Util.isUnset(request.preVersionUID)) {
    query['preVersionUID'] = request.preVersionUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProductVersionDifferences',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/integration/api/v2/products/${uid}/versions/${versionUID}/differences`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProductVersionPackageRequest {
  oldProductVersionUID?: string(name='oldProductVersionUID'),
  packageContentType?: string(name='packageContentType'),
  packageType?: string(name='packageType'),
  packageUID?: string(name='packageUID'),
  platform?: string(name='platform'),
  withURL?: boolean(name='withURL'),
}

model GetProductVersionPackageResponseBody = {
  code?: string(name='code'),
  data?: {
    packageContentType?: string(name='packageContentType'),
    packageSize?: string(name='packageSize'),
    packageStatus?: string(name='packageStatus'),
    packageType?: string(name='packageType'),
    packageUID?: string(name='packageUID'),
    packageURL?: string(name='packageURL'),
    platform?: Platform(name='platform'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GetProductVersionPackageResponse = {
  headers: map[string]string(name='headers'),
  body: GetProductVersionPackageResponseBody(name='body'),
}

async function getProductVersionPackage(uid: string, request: GetProductVersionPackageRequest): GetProductVersionPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProductVersionPackageWithOptions(uid, request, headers, runtime);
}

async function getProductVersionPackageWithOptions(uid: string, request: GetProductVersionPackageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProductVersionPackageResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  var query : map[string]any= {};
  if (!Util.isUnset(request.oldProductVersionUID)) {
    query['oldProductVersionUID'] = request.oldProductVersionUID;
  }
  if (!Util.isUnset(request.packageContentType)) {
    query['packageContentType'] = request.packageContentType;
  }
  if (!Util.isUnset(request.packageType)) {
    query['packageType'] = request.packageType;
  }
  if (!Util.isUnset(request.packageUID)) {
    query['packageUID'] = request.packageUID;
  }
  if (!Util.isUnset(request.platform)) {
    query['platform'] = request.platform;
  }
  if (!Util.isUnset(request.withURL)) {
    query['withURL'] = request.withURL;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProductVersionPackage',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/hosting/product-versions/${uid}/packages`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetWorkflowStatusRequest {
  workflowType?: string(name='workflowType', description='ENUM:["CreateCluster","DeleteCluster","Pack","Deploy","UnbindProductVersion"]'),
  xuid?: string(name='xuid', description='xuid，根据场景传递env_uid/package_uid/deploy_uid'),
}

model GetWorkflowStatusResponseBody = {
  code?: string(name='code'),
  data?: {
    status?: string(name='status'),
    stepStatus?: [ 
      {
        name?: string(name='name', description='step name'),
        status?: string(name='status', description='step status'),
        workflowTasks?: [ 
          {
            name?: string(name='name', description='task name'),
            status?: string(name='status', description='task status'),
          }
        ](name='workflowTasks'),
      }
    ](name='stepStatus'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GetWorkflowStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetWorkflowStatusResponseBody(name='body'),
}

async function getWorkflowStatus(request: GetWorkflowStatusRequest): GetWorkflowStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getWorkflowStatusWithOptions(request, headers, runtime);
}

async function getWorkflowStatusWithOptions(request: GetWorkflowStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetWorkflowStatusResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.workflowType)) {
    query['workflowType'] = request.workflowType;
  }
  if (!Util.isUnset(request.xuid)) {
    query['xuid'] = request.xuid;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetWorkflowStatus',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/workflows/status`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model InitEnvironmentResourceRequest {
  accessKeyID?: string(name='accessKeyID'),
  accessKeySecret?: string(name='accessKeySecret'),
  securityToken?: string(name='securityToken'),
}

model InitEnvironmentResourceResponseBody = {
  code?: string(name='code'),
  data?: {
    status?: string(name='status'),
  }(name='data'),
  msg?: string(name='msg'),
}

model InitEnvironmentResourceResponse = {
  headers: map[string]string(name='headers'),
  body: InitEnvironmentResourceResponseBody(name='body'),
}

async function initEnvironmentResource(uid: string, request: InitEnvironmentResourceRequest): InitEnvironmentResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return initEnvironmentResourceWithOptions(uid, request, headers, runtime);
}

async function initEnvironmentResourceWithOptions(uid: string, request: InitEnvironmentResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InitEnvironmentResourceResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  var body : map[string]any= {};
  if (!Util.isUnset(request.accessKeyID)) {
    body['accessKeyID'] = request.accessKeyID;
  }
  if (!Util.isUnset(request.accessKeySecret)) {
    body['accessKeySecret'] = request.accessKeySecret;
  }
  if (!Util.isUnset(request.securityToken)) {
    body['securityToken'] = request.securityToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'InitEnvironmentResource',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${uid}/resources`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListComponentVersionsRequest {
  pageNum?: int32(name='pageNum'),
  pageSize?: int32(name='pageSize'),
  platforms?: [ 
    {
      architecture?: string(name='architecture'),
      os?: string(name='os'),
    }
  ](name='platforms'),
}

model ListComponentVersionsShrinkRequest {
  pageNum?: int32(name='pageNum'),
  pageSize?: int32(name='pageSize'),
  platformsShrink?: string(name='platforms'),
}

model ListComponentVersionsResponseBody = {
  requestId?: string(name='RequestId'),
  code?: string(name='code'),
  data?: {
    list?: [ 
      {
        appVersion?: string(name='appVersion'),
        componentName?: string(name='componentName'),
        componentUID?: string(name='componentUID'),
        description?: string(name='description'),
        documents?: string(name='documents'),
        imagesMapping?: string(name='imagesMapping'),
        orchestrationValues?: string(name='orchestrationValues'),
        packageURL?: string(name='packageURL'),
        parentComponent?: boolean(name='parentComponent'),
        readme?: string(name='readme'),
        resources?: string(name='resources'),
        uid?: string(name='uid'),
        version?: string(name='version'),
      }
    ](name='list'),
    pageNum?: int32(name='pageNum'),
    pageSize?: int32(name='pageSize'),
    total?: int32(name='total'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListComponentVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListComponentVersionsResponseBody(name='body'),
}

async function listComponentVersions(uid: string, request: ListComponentVersionsRequest): ListComponentVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listComponentVersionsWithOptions(uid, request, headers, runtime);
}

async function listComponentVersionsWithOptions(uid: string, tmpReq: ListComponentVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListComponentVersionsResponse {
  Util.validateModel(tmpReq);
  uid = OpenApiUtil.getEncodeParam(uid);
  var request = new ListComponentVersionsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.platforms)) {
    request.platformsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.platforms, 'platforms', 'json');
  }
  var query : map[string]any= {};
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.platformsShrink)) {
    query['platforms'] = request.platformsShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListComponentVersions',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/components/${uid}/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListComponentsRequest {
  category?: string(name='category'),
  fuzzy?: string(name='fuzzy'),
  name?: string(name='name'),
  pageNum?: int32(name='pageNum'),
  pageSize?: int32(name='pageSize'),
  public?: boolean(name='public'),
}

model ListComponentsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [ 
      {
        annotations?: {
          annotations?: string(name='annotations'),
        }(name='annotations'),
        category?: string(name='category'),
        description?: string(name='description'),
        documents?: string(name='documents'),
        name?: string(name='name'),
        provider?: string(name='provider'),
        public?: boolean(name='public'),
        singleton?: boolean(name='singleton'),
        source?: string(name='source'),
        uid?: string(name='uid'),
      }
    ](name='list'),
    pageNum?: int32(name='pageNum'),
    pageSize?: int32(name='pageSize'),
    total?: int32(name='total'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListComponentsResponse = {
  headers: map[string]string(name='headers'),
  body: ListComponentsResponseBody(name='body'),
}

async function listComponents(request: ListComponentsRequest): ListComponentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listComponentsWithOptions(request, headers, runtime);
}

async function listComponentsWithOptions(request: ListComponentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListComponentsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.category)) {
    query['category'] = request.category;
  }
  if (!Util.isUnset(request.fuzzy)) {
    query['fuzzy'] = request.fuzzy;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.public)) {
    query['public'] = request.public;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListComponents',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/components`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListEnvironmentLicensesRequest {
  pageNum?: int32(name='pageNum', description='页码'),
  pageSize?: int32(name='pageSize', description='页大小'),
  type?: string(name='type', description='类型'),
}

model ListEnvironmentLicensesResponseBody = {
  code?: string(name='code', description='错误码'),
  data?: {
    list?: [ 
      {
        expireTime?: string(name='expireTime', description='过期时间'),
        licenseKey?: string(name='licenseKey', description='license内容'),
        licenseQuota?: {
          clusterQuota?: {
            cpuCoreLimit?: int32(name='cpuCoreLimit', description='cpu核数限制'),
          }(name='clusterQuota', description='集群配额'),
          componentQuotas?: [ 
            {
              componentName?: string(name='componentName', description='组件名'),
              componentSource?: string(name='componentSource', description='组件来源'),
              instanceLimit?: int32(name='instanceLimit', description='实例数限制'),
            }
          ](name='componentQuotas', description='组件配额'),
        }(name='licenseQuota', description='license配额'),
        rejectReason?: string(name='rejectReason', description='拒绝原因'),
        status?: string(name='status', description='状态'),
        type?: string(name='type', description='类型'),
        uid?: string(name='uid', description='license uid'),
      }
    ](name='list', description='license列表'),
    pageNum?: int32(name='pageNum', description='页码'),
    pageSize?: int32(name='pageSize', description='页大小'),
    total?: int32(name='total', description='总数'),
  }(name='data', description='业务数据'),
  msg?: string(name='msg', description='错误信息'),
}

model ListEnvironmentLicensesResponse = {
  headers: map[string]string(name='headers'),
  body: ListEnvironmentLicensesResponseBody(name='body'),
}

async function listEnvironmentLicenses(uid: string, request: ListEnvironmentLicensesRequest): ListEnvironmentLicensesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEnvironmentLicensesWithOptions(uid, request, headers, runtime);
}

async function listEnvironmentLicensesWithOptions(uid: string, request: ListEnvironmentLicensesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListEnvironmentLicensesResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  var query : map[string]any= {};
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEnvironmentLicenses',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${uid}/licenses`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListEnvironmentNodesRequest {
  pageNum?: int32(name='pageNum'),
  pageSize?: int32(name='pageSize'),
}

model ListEnvironmentNodesResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [
      GetInstanceInfoResponse
    ](name='list'),
    pageNum?: long(name='pageNum'),
    pageSize?: long(name='pageSize'),
    total?: long(name='total'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListEnvironmentNodesResponse = {
  headers: map[string]string(name='headers'),
  body: ListEnvironmentNodesResponseBody(name='body'),
}

async function listEnvironmentNodes(uid: string, request: ListEnvironmentNodesRequest): ListEnvironmentNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEnvironmentNodesWithOptions(uid, request, headers, runtime);
}

async function listEnvironmentNodesWithOptions(uid: string, request: ListEnvironmentNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListEnvironmentNodesResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  var query : map[string]any= {};
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEnvironmentNodes',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${uid}/nodes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListEnvironmentTunnelsResponseBody = {
  code?: string(name='code', description='错误码'),
  data?: {
    list?: [ 
      {
        tunnelConfig?: {
          hostname?: string(name='hostname', description='跳板机hostname'),
          password?: string(name='password', description='跳板机密码'),
          regionId?: string(name='regionId', description='直连regionId'),
          sshPort?: int32(name='sshPort', description='跳板机ssh端口号'),
          username?: string(name='username', description='跳板机用户名'),
          vpcId?: string(name='vpcId', description='直连vpcId'),
        }(name='tunnelConfig'),
        tunnelType?: string(name='tunnelType', description='通道类型'),
      }
    ](name='list'),
  }(name='data'),
  msg?: string(name='msg', description='错误信息'),
}

model ListEnvironmentTunnelsResponse = {
  headers: map[string]string(name='headers'),
  body: ListEnvironmentTunnelsResponseBody(name='body'),
}

async function listEnvironmentTunnels(uid: string): ListEnvironmentTunnelsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEnvironmentTunnelsWithOptions(uid, headers, runtime);
}

async function listEnvironmentTunnelsWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListEnvironmentTunnelsResponse {
  uid = OpenApiUtil.getEncodeParam(uid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListEnvironmentTunnels',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${uid}/tunnels`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListEnvironmentsRequest {
  clusterUID?: string(name='clusterUID'),
  foundationType?: string(name='foundationType'),
  fuzzy?: string(name='fuzzy'),
  instanceStatus?: string(name='instanceStatus'),
  name?: string(name='name'),
  pageNum?: int32(name='pageNum'),
  pageSize?: int32(name='pageSize'),
  type?: string(name='type'),
  vendorType?: string(name='vendorType'),
}

model ListEnvironmentsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [ 
      {
        createdAt?: string(name='createdAt'),
        description?: string(name='description'),
        id?: int32(name='id'),
        location?: string(name='location'),
        name?: string(name='name'),
        platform?: {
          architecture?: string(name='architecture'),
          os?: string(name='os'),
        }(name='platform'),
        productName?: string(name='productName'),
        productVersion?: string(name='productVersion'),
        productVersionUID?: string(name='productVersionUID'),
        uid?: string(name='uid'),
        vendorType?: string(name='vendorType'),
      }
    ](name='list'),
    pageNum?: int32(name='pageNum'),
    pageSize?: int32(name='pageSize'),
    total?: int32(name='total'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListEnvironmentsResponse = {
  headers: map[string]string(name='headers'),
  body: ListEnvironmentsResponseBody(name='body'),
}

async function listEnvironments(request: ListEnvironmentsRequest): ListEnvironmentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEnvironmentsWithOptions(request, headers, runtime);
}

async function listEnvironmentsWithOptions(request: ListEnvironmentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListEnvironmentsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterUID)) {
    query['clusterUID'] = request.clusterUID;
  }
  if (!Util.isUnset(request.foundationType)) {
    query['foundationType'] = request.foundationType;
  }
  if (!Util.isUnset(request.fuzzy)) {
    query['fuzzy'] = request.fuzzy;
  }
  if (!Util.isUnset(request.instanceStatus)) {
    query['instanceStatus'] = request.instanceStatus;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }
  if (!Util.isUnset(request.vendorType)) {
    query['vendorType'] = request.vendorType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEnvironments',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListFoundationComponentVersionsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [
      ComponentVersion
    ](name='list'),
    pageNum?: int32(name='pageNum'),
    pageSize?: int32(name='pageSize'),
    total?: int32(name='total'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListFoundationComponentVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFoundationComponentVersionsResponseBody(name='body'),
}

async function listFoundationComponentVersions(uid: string): ListFoundationComponentVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFoundationComponentVersionsWithOptions(uid, headers, runtime);
}

async function listFoundationComponentVersionsWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListFoundationComponentVersionsResponse {
  uid = OpenApiUtil.getEncodeParam(uid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListFoundationComponentVersions',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/foundation/versions/${uid}/component-versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListFoundationReferenceComponentsRequest {
  foundationVersionUID?: string(name='foundationVersionUID', description='foundation version uid'),
  onlyEnabled?: boolean(name='onlyEnabled'),
  productVersionUID?: string(name='productVersionUID', description='产品版本uid'),
}

model ListFoundationReferenceComponentsResponseBody = {
  code?: string(name='code'),
  data?: [
    ProductComponentRelationDetail
  ](name='data'),
  msg?: string(name='msg'),
}

model ListFoundationReferenceComponentsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFoundationReferenceComponentsResponseBody(name='body'),
}

async function listFoundationReferenceComponents(request: ListFoundationReferenceComponentsRequest): ListFoundationReferenceComponentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFoundationReferenceComponentsWithOptions(request, headers, runtime);
}

async function listFoundationReferenceComponentsWithOptions(request: ListFoundationReferenceComponentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFoundationReferenceComponentsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.foundationVersionUID)) {
    query['foundationVersionUID'] = request.foundationVersionUID;
  }
  if (!Util.isUnset(request.onlyEnabled)) {
    query['onlyEnabled'] = request.onlyEnabled;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    query['productVersionUID'] = request.productVersionUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFoundationReferenceComponents',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/foundation-references/component-versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListFoundationVersionsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [
      FoundationVersion
    ](name='list'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListFoundationVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFoundationVersionsResponseBody(name='body'),
}

async function listFoundationVersions(): ListFoundationVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFoundationVersionsWithOptions(headers, runtime);
}

async function listFoundationVersionsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListFoundationVersionsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListFoundationVersions',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/foundation/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProductComponentVersionsRequest {
  category?: string(name='category', description='组件类型，不填写则为全部'),
  pageNum?: string(name='pageNum'),
  pageSize?: string(name='pageSize'),
  sortDirect?: string(name='sortDirect'),
  sortKey?: string(name='sortKey'),
}

model ListProductComponentVersionsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [
      ProductComponentRelationDetail
    ](name='list'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListProductComponentVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProductComponentVersionsResponseBody(name='body'),
}

async function listProductComponentVersions(uid: string, request: ListProductComponentVersionsRequest): ListProductComponentVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProductComponentVersionsWithOptions(uid, request, headers, runtime);
}

async function listProductComponentVersionsWithOptions(uid: string, request: ListProductComponentVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProductComponentVersionsResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  var query : map[string]any= {};
  if (!Util.isUnset(request.category)) {
    query['category'] = request.category;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortDirect)) {
    query['sortDirect'] = request.sortDirect;
  }
  if (!Util.isUnset(request.sortKey)) {
    query['sortKey'] = request.sortKey;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProductComponentVersions',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${uid}/component-versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProductDeploymentsRequest {
  environmentUID?: string(name='environmentUID'),
  pageNum?: int32(name='pageNum'),
  pageSize?: int32(name='pageSize'),
  productVersionUID?: string(name='productVersionUID'),
}

model ListProductDeploymentsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [ 
      {
        envParams?: string(name='envParams'),
        envUID?: string(name='envUID'),
        oldProductVersion?: string(name='oldProductVersion'),
        packageContentType?: string(name='packageContentType'),
        packageInfoUID?: string(name='packageInfoUID'),
        packageType?: string(name='packageType'),
        productName?: string(name='productName'),
        productVersion?: string(name='productVersion'),
        status?: string(name='status'),
        uid?: string(name='uid'),
      }
    ](name='list'),
    pageNum?: int32(name='pageNum'),
    pageSize?: int32(name='pageSize'),
    total?: int32(name='total'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListProductDeploymentsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProductDeploymentsResponseBody(name='body'),
}

async function listProductDeployments(request: ListProductDeploymentsRequest): ListProductDeploymentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProductDeploymentsWithOptions(request, headers, runtime);
}

async function listProductDeploymentsWithOptions(request: ListProductDeploymentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProductDeploymentsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.environmentUID)) {
    query['environmentUID'] = request.environmentUID;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    query['productVersionUID'] = request.productVersionUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProductDeployments',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-instances/deployments`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProductEnvironmentsRequest {
  compatibleProductVersionUID?: string(name='compatibleProductVersionUID', description='兼容版本产品版本id'),
  envType?: string(name='envType'),
  platforms?: [ 
    {
      architecture?: string(name='architecture'),
      os?: string(name='os'),
    }
  ](name='platforms'),
  productVersionUID?: string(name='productVersionUID'),
}

model ListProductEnvironmentsShrinkRequest {
  compatibleProductVersionUID?: string(name='compatibleProductVersionUID', description='兼容版本产品版本id'),
  envType?: string(name='envType'),
  platformsShrink?: string(name='platforms'),
  productVersionUID?: string(name='productVersionUID'),
}

model ListProductEnvironmentsResponseBody = {
  code?: string(name='code'),
  data?: [ 
    {
      envName?: string(name='envName'),
      envType?: string(name='envType'),
      envUID?: string(name='envUID'),
      instanceStatus?: string(name='instanceStatus'),
      oldProductVersion?: string(name='oldProductVersion'),
      oldProductVersionUID?: string(name='oldProductVersionUID'),
      platformStatus?: string(name='platformStatus'),
      productName?: string(name='productName'),
      productUID?: string(name='productUID'),
      productVersion?: string(name='productVersion'),
      productVersionUID?: string(name='productVersionUID'),
      provider?: string(name='provider'),
      uid?: string(name='uid'),
      vendorConfig?: string(name='vendorConfig'),
      vendorType?: string(name='vendorType'),
    }
  ](name='data'),
  msg?: string(name='msg'),
}

model ListProductEnvironmentsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProductEnvironmentsResponseBody(name='body'),
}

async function listProductEnvironments(uid: string, request: ListProductEnvironmentsRequest): ListProductEnvironmentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProductEnvironmentsWithOptions(uid, request, headers, runtime);
}

async function listProductEnvironmentsWithOptions(uid: string, tmpReq: ListProductEnvironmentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProductEnvironmentsResponse {
  Util.validateModel(tmpReq);
  uid = OpenApiUtil.getEncodeParam(uid);
  var request = new ListProductEnvironmentsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.platforms)) {
    request.platformsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.platforms, 'platforms', 'json');
  }
  var query : map[string]any= {};
  if (!Util.isUnset(request.compatibleProductVersionUID)) {
    query['compatibleProductVersionUID'] = request.compatibleProductVersionUID;
  }
  if (!Util.isUnset(request.envType)) {
    query['envType'] = request.envType;
  }
  if (!Util.isUnset(request.platformsShrink)) {
    query['platforms'] = request.platformsShrink;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    query['productVersionUID'] = request.productVersionUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProductEnvironments',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/hosting/products/${uid}/environments`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProductInstanceConfigsRequest {
  environmentUID?: string(name='environmentUID'),
  pageNum?: int32(name='pageNum'),
  pageSize?: int32(name='pageSize'),
  paramType?: string(name='paramType', description='组件和全局类型字段'),
  productVersionUID?: string(name='productVersionUID'),
}

model ListProductInstanceConfigsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [ 
      {
        componentName?: string(name='componentName'),
        componentReleaseName?: string(name='componentReleaseName'),
        componentUID?: string(name='componentUID'),
        componentVersionUID?: string(name='componentVersionUID'),
        createdAt?: string(name='createdAt'),
        description?: string(name='description'),
        envUID?: string(name='envUID'),
        name?: string(name='name'),
        parentComponentName?: string(name='parentComponentName'),
        parentComponentReleaseName?: string(name='parentComponentReleaseName'),
        parentComponentVersionUID?: string(name='parentComponentVersionUID'),
        productName?: string(name='productName'),
        productVersion?: string(name='productVersion'),
        productVersionUID?: string(name='productVersionUID'),
        uid?: string(name='uid'),
        value?: string(name='value'),
        valueType?: string(name='valueType'),
        vendorType?: string(name='vendorType'),
      }
    ](name='list'),
    pageNum?: int32(name='pageNum'),
    pageSize?: int32(name='pageSize'),
    total?: int32(name='total'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListProductInstanceConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProductInstanceConfigsResponseBody(name='body'),
}

async function listProductInstanceConfigs(request: ListProductInstanceConfigsRequest): ListProductInstanceConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProductInstanceConfigsWithOptions(request, headers, runtime);
}

async function listProductInstanceConfigsWithOptions(request: ListProductInstanceConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProductInstanceConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.environmentUID)) {
    query['environmentUID'] = request.environmentUID;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.paramType)) {
    query['paramType'] = request.paramType;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    query['productVersionUID'] = request.productVersionUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProductInstanceConfigs',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-instances/configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProductInstancesRequest {
  envUID?: string(name='envUID'),
  pageNum?: string(name='pageNum'),
  pageSize?: string(name='pageSize'),
  productVersionUID?: string(name='productVersionUID'),
}

model ListProductInstancesResponseBody = {
  data?: {
    list?: [ 
      {
        productName?: string(name='productName'),
        productVersion?: string(name='productVersion'),
        productVersionUID?: string(name='productVersionUID'),
        status?: string(name='status'),
        uid?: string(name='uid'),
      }
    ](name='list'),
  }(name='data'),
}

model ListProductInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListProductInstancesResponseBody(name='body'),
}

async function listProductInstances(request: ListProductInstancesRequest): ListProductInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProductInstancesWithOptions(request, headers, runtime);
}

async function listProductInstancesWithOptions(request: ListProductInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProductInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.envUID)) {
    query['envUID'] = request.envUID;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    query['productVersionUID'] = request.productVersionUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProductInstances',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProductVersionConfigsRequest {
  configType?: string(name='configType'),
  pageNum?: string(name='pageNum'),
  pageSize?: string(name='pageSize'),
}

model ListProductVersionConfigsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [ 
      {
        componentName?: string(name='componentName'),
        componentReleaseName?: string(name='componentReleaseName'),
        componentVersionUID?: string(name='componentVersionUID'),
        description?: string(name='description'),
        name?: string(name='name'),
        parentComponentName?: string(name='parentComponentName'),
        parentComponentReleaseName?: string(name='parentComponentReleaseName'),
        parentComponentVersionUID?: string(name='parentComponentVersionUID'),
        productVersionUID?: string(name='productVersionUID'),
        uid?: string(name='uid'),
        value?: string(name='value'),
      }
    ](name='list'),
    pageNum?: int32(name='pageNum'),
    pageSize?: int32(name='pageSize'),
    total?: int32(name='total'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListProductVersionConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProductVersionConfigsResponseBody(name='body'),
}

async function listProductVersionConfigs(uid: string, request: ListProductVersionConfigsRequest): ListProductVersionConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProductVersionConfigsWithOptions(uid, request, headers, runtime);
}

async function listProductVersionConfigsWithOptions(uid: string, request: ListProductVersionConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProductVersionConfigsResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  var query : map[string]any= {};
  if (!Util.isUnset(request.configType)) {
    query['configType'] = request.configType;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProductVersionConfigs',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${uid}/configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProductVersionsRequest {
  pageNum?: string(name='pageNum'),
  pageSize?: string(name='pageSize'),
  platforms?: [ 
    {
      architecture?: string(name='architecture'),
      os?: string(name='os'),
    }
  ](name='platforms', description='支持的platform，为空则不过滤'),
  productName?: string(name='productName', description='过滤参数，产品名称'),
  productUID?: string(name='productUID', description='过滤参数，产品uid'),
  released?: boolean(name='released', description='过滤参数，是否已发布'),
  supportedFoundationTypes?: [ string ](name='supportedFoundationTypes', description='过滤参数，支持的环境类型'),
  version?: string(name='version', description='过滤参数，产品版本号'),
}

model ListProductVersionsShrinkRequest {
  pageNum?: string(name='pageNum'),
  pageSize?: string(name='pageSize'),
  platformsShrink?: string(name='platforms', description='支持的platform，为空则不过滤'),
  productName?: string(name='productName', description='过滤参数，产品名称'),
  productUID?: string(name='productUID', description='过滤参数，产品uid'),
  released?: boolean(name='released', description='过滤参数，是否已发布'),
  supportedFoundationTypesShrink?: string(name='supportedFoundationTypes', description='过滤参数，支持的环境类型'),
  version?: string(name='version', description='过滤参数，产品版本号'),
}

model ListProductVersionsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [ 
      {
        annotations?: {
          additionalProp1?: string(name='additionalProp1'),
          additionalProp2?: string(name='additionalProp2'),
          additionalProp3?: string(name='additionalProp3'),
        }(name='annotations'),
        description?: string(name='description'),
        packageURL?: string(name='packageURL'),
        productName?: string(name='productName'),
        productUID?: string(name='productUID'),
        provider?: string(name='provider'),
        uid?: string(name='uid'),
        version?: string(name='version'),
      }
    ](name='list'),
    pageNum?: int32(name='pageNum'),
    pageSize?: int32(name='pageSize'),
    total?: int32(name='total'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListProductVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProductVersionsResponseBody(name='body'),
}

async function listProductVersions(request: ListProductVersionsRequest): ListProductVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProductVersionsWithOptions(request, headers, runtime);
}

async function listProductVersionsWithOptions(tmpReq: ListProductVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProductVersionsResponse {
  Util.validateModel(tmpReq);
  var request = new ListProductVersionsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.platforms)) {
    request.platformsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.platforms, 'platforms', 'json');
  }
  if (!Util.isUnset(tmpReq.supportedFoundationTypes)) {
    request.supportedFoundationTypesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.supportedFoundationTypes, 'supportedFoundationTypes', 'json');
  }
  var query : map[string]any= {};
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.platformsShrink)) {
    query['platforms'] = request.platformsShrink;
  }
  if (!Util.isUnset(request.productName)) {
    query['productName'] = request.productName;
  }
  if (!Util.isUnset(request.productUID)) {
    query['productUID'] = request.productUID;
  }
  if (!Util.isUnset(request.released)) {
    query['released'] = request.released;
  }
  if (!Util.isUnset(request.supportedFoundationTypesShrink)) {
    query['supportedFoundationTypes'] = request.supportedFoundationTypesShrink;
  }
  if (!Util.isUnset(request.version)) {
    query['version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProductVersions',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProductsRequest {
  fuzzy?: string(name='fuzzy'),
  name?: string(name='name'),
  pageNum?: int32(name='pageNum'),
  pageSize?: int32(name='pageSize'),
}

model ListProductsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [ 
      {
        description?: string(name='description'),
        name?: string(name='name'),
        uid?: string(name='uid'),
      }
    ](name='list'),
    pageNum?: int32(name='pageNum'),
    pageSize?: int32(name='pageSize'),
    total?: int32(name='total'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListProductsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProductsResponseBody(name='body'),
}

async function listProducts(request: ListProductsRequest): ListProductsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProductsWithOptions(request, headers, runtime);
}

async function listProductsWithOptions(request: ListProductsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProductsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.fuzzy)) {
    query['fuzzy'] = request.fuzzy;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProducts',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/products`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListWorkflowTaskLogsRequest {
  filterValues?: [ string ](name='filterValues'),
  orderType?: string(name='orderType', description='log 的顺序，positive 代表最新的数据在最后，reverse 代表最新的数据在最前'),
  pageNum?: long(name='pageNum'),
  pageSize?: long(name='pageSize', description='每一页的行数，最大值 100'),
  workflowType?: string(name='workflowType', description='ENUM:["CreateCluster","DeleteCluster","Pack","Deploy"]'),
  xuid?: string(name='xuid'),
}

model ListWorkflowTaskLogsShrinkRequest {
  filterValuesShrink?: string(name='filterValues'),
  orderType?: string(name='orderType', description='log 的顺序，positive 代表最新的数据在最后，reverse 代表最新的数据在最前'),
  pageNum?: long(name='pageNum'),
  pageSize?: long(name='pageSize', description='每一页的行数，最大值 100'),
  workflowType?: string(name='workflowType', description='ENUM:["CreateCluster","DeleteCluster","Pack","Deploy"]'),
  xuid?: string(name='xuid'),
}

model ListWorkflowTaskLogsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [ string ](name='list', description='日志数据'),
    pageNum?: long(name='pageNum'),
    pageSize?: long(name='pageSize'),
    total?: long(name='total'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListWorkflowTaskLogsResponse = {
  headers: map[string]string(name='headers'),
  body: ListWorkflowTaskLogsResponseBody(name='body'),
}

async function listWorkflowTaskLogs(stepName: string, taskName: string, request: ListWorkflowTaskLogsRequest): ListWorkflowTaskLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listWorkflowTaskLogsWithOptions(stepName, taskName, request, headers, runtime);
}

async function listWorkflowTaskLogsWithOptions(stepName: string, taskName: string, tmpReq: ListWorkflowTaskLogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListWorkflowTaskLogsResponse {
  Util.validateModel(tmpReq);
  stepName = OpenApiUtil.getEncodeParam(stepName);
  taskName = OpenApiUtil.getEncodeParam(taskName);
  var request = new ListWorkflowTaskLogsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.filterValues)) {
    request.filterValuesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterValues, 'filterValues', 'json');
  }
  var query : map[string]any= {};
  if (!Util.isUnset(request.filterValuesShrink)) {
    query['filterValues'] = request.filterValuesShrink;
  }
  if (!Util.isUnset(request.orderType)) {
    query['orderType'] = request.orderType;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.workflowType)) {
    query['workflowType'] = request.workflowType;
  }
  if (!Util.isUnset(request.xuid)) {
    query['xuid'] = request.xuid;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListWorkflowTaskLogs',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/workflows/steps/${stepName}/tasks/${taskName}/logs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PutEnvironmentTunnelRequest {
  tunnelConfig?: {
    hostname?: string(name='hostname', description='跳板机hostname'),
    password?: string(name='password', description='跳板机密码'),
    regionId?: string(name='regionId', description='直连地域id'),
    sshPort?: int32(name='sshPort', description='跳板机ssh端口号'),
    username?: string(name='username', description='跳板机用户名'),
    vpcId?: string(name='vpcId', description='直连vpcId'),
  }(name='tunnelConfig', description='通道配置'),
  tunnelType?: string(name='tunnelType', description='通道类型'),
}

model PutEnvironmentTunnelResponseBody = {
  code?: string(name='code', description='错误码'),
  data?: {
    uid?: string(name='uid', description='通道id，可空'),
  }(name='data', description='数据'),
  msg?: string(name='msg', description='错误信息'),
}

model PutEnvironmentTunnelResponse = {
  headers: map[string]string(name='headers'),
  body: PutEnvironmentTunnelResponseBody(name='body'),
}

async function putEnvironmentTunnel(uid: string, request: PutEnvironmentTunnelRequest): PutEnvironmentTunnelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putEnvironmentTunnelWithOptions(uid, request, headers, runtime);
}

async function putEnvironmentTunnelWithOptions(uid: string, request: PutEnvironmentTunnelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutEnvironmentTunnelResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  var body : map[string]any= {};
  if (!Util.isUnset(request.tunnelConfig)) {
    body['tunnelConfig'] = request.tunnelConfig;
  }
  if (!Util.isUnset(request.tunnelType)) {
    body['tunnelType'] = request.tunnelType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutEnvironmentTunnel',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${uid}/tunnels`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PutProductInstanceConfigRequest {
  componentUID?: string(name='componentUID'),
  componentVersionUID?: string(name='componentVersionUID'),
  configUID?: string(name='configUID'),
  description?: string(name='description'),
  environmentUID?: string(name='environmentUID'),
  name?: string(name='name'),
  parentComponentName?: string(name='parentComponentName'),
  parentComponentVersionUID?: string(name='parentComponentVersionUID'),
  productVersionUID?: string(name='productVersionUID'),
  releaseName?: string(name='releaseName'),
  scope?: [ string ](name='scope'),
  value?: string(name='value'),
  valueType?: string(name='valueType'),
}

model PutProductInstanceConfigResponseBody = {
  code?: string(name='code'),
  data?: {
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model PutProductInstanceConfigResponse = {
  headers: map[string]string(name='headers'),
  body: PutProductInstanceConfigResponseBody(name='body'),
}

async function putProductInstanceConfig(request: PutProductInstanceConfigRequest): PutProductInstanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putProductInstanceConfigWithOptions(request, headers, runtime);
}

async function putProductInstanceConfigWithOptions(request: PutProductInstanceConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutProductInstanceConfigResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.componentUID)) {
    body['componentUID'] = request.componentUID;
  }
  if (!Util.isUnset(request.componentVersionUID)) {
    body['componentVersionUID'] = request.componentVersionUID;
  }
  if (!Util.isUnset(request.configUID)) {
    body['configUID'] = request.configUID;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.environmentUID)) {
    body['environmentUID'] = request.environmentUID;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.parentComponentName)) {
    body['parentComponentName'] = request.parentComponentName;
  }
  if (!Util.isUnset(request.parentComponentVersionUID)) {
    body['parentComponentVersionUID'] = request.parentComponentVersionUID;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    body['productVersionUID'] = request.productVersionUID;
  }
  if (!Util.isUnset(request.releaseName)) {
    body['releaseName'] = request.releaseName;
  }
  if (!Util.isUnset(request.scope)) {
    body['scope'] = request.scope;
  }
  if (!Util.isUnset(request.value)) {
    body['value'] = request.value;
  }
  if (!Util.isUnset(request.valueType)) {
    body['valueType'] = request.valueType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutProductInstanceConfig',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-instances/configs`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model SetEnvironmentFoundationReferenceResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model SetEnvironmentFoundationReferenceResponse = {
  headers: map[string]string(name='headers'),
  body: SetEnvironmentFoundationReferenceResponseBody(name='body'),
}

async function setEnvironmentFoundationReference(uid: string, foundationReferenceUID: string): SetEnvironmentFoundationReferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return setEnvironmentFoundationReferenceWithOptions(uid, foundationReferenceUID, headers, runtime);
}

async function setEnvironmentFoundationReferenceWithOptions(uid: string, foundationReferenceUID: string, headers: map[string]string, runtime: Util.RuntimeOptions): SetEnvironmentFoundationReferenceResponse {
  uid = OpenApiUtil.getEncodeParam(uid);
  foundationReferenceUID = OpenApiUtil.getEncodeParam(foundationReferenceUID);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'SetEnvironmentFoundationReference',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${uid}/foundation-references/${foundationReferenceUID}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateEnvironmentRequest {
  description?: string(name='description'),
  location?: string(name='location'),
  vendorConfig?: string(name='vendorConfig'),
}

model UpdateEnvironmentResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model UpdateEnvironmentResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateEnvironmentResponseBody(name='body'),
}

async function updateEnvironment(uid: string, request: UpdateEnvironmentRequest): UpdateEnvironmentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateEnvironmentWithOptions(uid, request, headers, runtime);
}

async function updateEnvironmentWithOptions(uid: string, request: UpdateEnvironmentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateEnvironmentResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.location)) {
    body['location'] = request.location;
  }
  if (!Util.isUnset(request.vendorConfig)) {
    body['vendorConfig'] = request.vendorConfig;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEnvironment',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${uid}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateEnvironmentNodeRequest {
  applicationDisk?: string(name='applicationDisk', description='保留业务分区'),
  etcdDisk?: string(name='etcdDisk', description='etcd数据盘'),
  labels?: map[string]any(name='labels'),
  rootPassword?: string(name='rootPassword'),
  taints?: [ 
    {
      effect?: string(name='effect'),
      key?: string(name='key'),
      value?: string(name='value'),
    }
  ](name='taints'),
  tridentSystemDisk?: string(name='tridentSystemDisk', description='k8s管控数据盘'),
  tridentSystemSizeDisk?: int32(name='tridentSystemSizeDisk', description='k8s管控数据盘大小'),
}

model UpdateEnvironmentNodeResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model UpdateEnvironmentNodeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateEnvironmentNodeResponseBody(name='body'),
}

async function updateEnvironmentNode(uid: string, nodeUID: string, request: UpdateEnvironmentNodeRequest): UpdateEnvironmentNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateEnvironmentNodeWithOptions(uid, nodeUID, request, headers, runtime);
}

async function updateEnvironmentNodeWithOptions(uid: string, nodeUID: string, request: UpdateEnvironmentNodeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateEnvironmentNodeResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  nodeUID = OpenApiUtil.getEncodeParam(nodeUID);
  var body : map[string]any= {};
  if (!Util.isUnset(request.applicationDisk)) {
    body['applicationDisk'] = request.applicationDisk;
  }
  if (!Util.isUnset(request.etcdDisk)) {
    body['etcdDisk'] = request.etcdDisk;
  }
  if (!Util.isUnset(request.labels)) {
    body['labels'] = request.labels;
  }
  if (!Util.isUnset(request.rootPassword)) {
    body['rootPassword'] = request.rootPassword;
  }
  if (!Util.isUnset(request.taints)) {
    body['taints'] = request.taints;
  }
  if (!Util.isUnset(request.tridentSystemDisk)) {
    body['tridentSystemDisk'] = request.tridentSystemDisk;
  }
  if (!Util.isUnset(request.tridentSystemSizeDisk)) {
    body['tridentSystemSizeDisk'] = request.tridentSystemSizeDisk;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEnvironmentNode',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${uid}/nodes/${nodeUID}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateEnvironmentProductVersionRequest {
  oldProductVersionUID?: string(name='oldProductVersionUID'),
  productVersionUID?: string(name='productVersionUID'),
}

model UpdateEnvironmentProductVersionResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model UpdateEnvironmentProductVersionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateEnvironmentProductVersionResponseBody(name='body'),
}

async function updateEnvironmentProductVersion(uid: string, request: UpdateEnvironmentProductVersionRequest): UpdateEnvironmentProductVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateEnvironmentProductVersionWithOptions(uid, request, headers, runtime);
}

async function updateEnvironmentProductVersionWithOptions(uid: string, request: UpdateEnvironmentProductVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateEnvironmentProductVersionResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  var body : map[string]any= {};
  if (!Util.isUnset(request.oldProductVersionUID)) {
    body['oldProductVersionUID'] = request.oldProductVersionUID;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    body['productVersionUID'] = request.productVersionUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEnvironmentProductVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${uid}/product-versions`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateFoundationComponentReferenceRequest {
  componentOrchestrationValues?: string(name='componentOrchestrationValues'),
  enable?: boolean(name='enable'),
}

model UpdateFoundationComponentReferenceResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model UpdateFoundationComponentReferenceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateFoundationComponentReferenceResponseBody(name='body'),
}

async function updateFoundationComponentReference(uid: string, componentReferenceUID: string, request: UpdateFoundationComponentReferenceRequest): UpdateFoundationComponentReferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFoundationComponentReferenceWithOptions(uid, componentReferenceUID, request, headers, runtime);
}

async function updateFoundationComponentReferenceWithOptions(uid: string, componentReferenceUID: string, request: UpdateFoundationComponentReferenceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFoundationComponentReferenceResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  componentReferenceUID = OpenApiUtil.getEncodeParam(componentReferenceUID);
  var body : map[string]any= {};
  if (!Util.isUnset(request.componentOrchestrationValues)) {
    body['componentOrchestrationValues'] = request.componentOrchestrationValues;
  }
  if (!Util.isUnset(request.enable)) {
    body['enable'] = request.enable;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFoundationComponentReference',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/foundation-references/${uid}/components/${componentReferenceUID}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateProductRequest {
  description?: string(name='description'),
}

model UpdateProductResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model UpdateProductResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateProductResponseBody(name='body'),
}

async function updateProduct(uid: string, request: UpdateProductRequest): UpdateProductResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProductWithOptions(uid, request, headers, runtime);
}

async function updateProductWithOptions(uid: string, request: UpdateProductRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProductResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProduct',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/products/${uid}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateProductComponentVersionRequest {
  componentOrchestrationValues?: string(name='componentOrchestrationValues'),
  enable?: boolean(name='enable'),
  newComponentVersionUID?: string(name='newComponentVersionUID', description='如果该参数不为空，则代表更新组件版本'),
  releaseName?: string(name='releaseName'),
}

model UpdateProductComponentVersionResponseBody = {
  code?: string(name='code'),
  data?: {
    relationUID?: string(name='relationUID'),
  }(name='data'),
  msg?: string(name='msg'),
}

model UpdateProductComponentVersionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateProductComponentVersionResponseBody(name='body'),
}

async function updateProductComponentVersion(uid: string, relationUID: string, request: UpdateProductComponentVersionRequest): UpdateProductComponentVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProductComponentVersionWithOptions(uid, relationUID, request, headers, runtime);
}

async function updateProductComponentVersionWithOptions(uid: string, relationUID: string, request: UpdateProductComponentVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProductComponentVersionResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  relationUID = OpenApiUtil.getEncodeParam(relationUID);
  var body : map[string]any= {};
  if (!Util.isUnset(request.componentOrchestrationValues)) {
    body['componentOrchestrationValues'] = request.componentOrchestrationValues;
  }
  if (!Util.isUnset(request.enable)) {
    body['enable'] = request.enable;
  }
  if (!Util.isUnset(request.newComponentVersionUID)) {
    body['newComponentVersionUID'] = request.newComponentVersionUID;
  }
  if (!Util.isUnset(request.releaseName)) {
    body['releaseName'] = request.releaseName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProductComponentVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${uid}/relations/${relationUID}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateProductFoundationVersionRequest {
  foundationVersionUID?: string(name='foundationVersionUID', description='底座版本uid'),
}

model UpdateProductFoundationVersionResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model UpdateProductFoundationVersionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateProductFoundationVersionResponseBody(name='body'),
}

async function updateProductFoundationVersion(uid: string, request: UpdateProductFoundationVersionRequest): UpdateProductFoundationVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProductFoundationVersionWithOptions(uid, request, headers, runtime);
}

async function updateProductFoundationVersionWithOptions(uid: string, request: UpdateProductFoundationVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProductFoundationVersionResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  var body : map[string]any= {};
  if (!Util.isUnset(request.foundationVersionUID)) {
    body['foundationVersionUID'] = request.foundationVersionUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProductFoundationVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${uid}/foundation`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateProductVersionRequest {
  description?: string(name='description'),
  version?: string(name='version', description='更新版本号，只允许从latest 更新到其他版本号，更新之后代表已发布'),
}

model UpdateProductVersionResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model UpdateProductVersionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateProductVersionResponseBody(name='body'),
}

async function updateProductVersion(uid: string, request: UpdateProductVersionRequest): UpdateProductVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProductVersionWithOptions(uid, request, headers, runtime);
}

async function updateProductVersionWithOptions(uid: string, request: UpdateProductVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProductVersionResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.version)) {
    body['version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProductVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${uid}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateProductVersionConfigRequest {
  componentVersionUID?: string(name='componentVersionUID', description='子组件versinid'),
  description?: string(name='description', description='配置说明'),
  name?: string(name='name', description='配置信息key'),
  parentComponentVersionUID?: string(name='parentComponentVersionUID', description='父组件versionid'),
  value?: string(name='value', description='配置信息value'),
  valueType?: string(name='valueType', description='value类型'),
}

model UpdateProductVersionConfigResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
  requestId?: string(name='requestId', description='Id of the request'),
}

model UpdateProductVersionConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateProductVersionConfigResponseBody(name='body'),
}

async function updateProductVersionConfig(uid: string, configUID: string, request: UpdateProductVersionConfigRequest): UpdateProductVersionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProductVersionConfigWithOptions(uid, configUID, request, headers, runtime);
}

async function updateProductVersionConfigWithOptions(uid: string, configUID: string, request: UpdateProductVersionConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProductVersionConfigResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  configUID = OpenApiUtil.getEncodeParam(configUID);
  var body : map[string]any= {};
  if (!Util.isUnset(request.componentVersionUID)) {
    body['componentVersionUID'] = request.componentVersionUID;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.parentComponentVersionUID)) {
    body['parentComponentVersionUID'] = request.parentComponentVersionUID;
  }
  if (!Util.isUnset(request.value)) {
    body['value'] = request.value;
  }
  if (!Util.isUnset(request.valueType)) {
    body['valueType'] = request.valueType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProductVersionConfig',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${uid}/configs/${configUID}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ValidateEnvironmentTunnelRequest {
  tunnelConfig?: {
    hostname?: string(name='hostname', description='跳板机hostname'),
    password?: string(name='password', description='跳板机密码'),
    regionId?: string(name='regionId', description='直连地域id'),
    sshPort?: int32(name='sshPort', description='跳板机ssh端口号'),
    username?: string(name='username', description='跳板机用户名'),
    vpcId?: string(name='vpcId', description='直连vpcId'),
  }(name='tunnelConfig', description='通道配置'),
  tunnelType?: string(name='tunnelType', description='通道类型'),
}

model ValidateEnvironmentTunnelResponseBody = {
  code?: string(name='code', description='错误码'),
  msg?: string(name='msg', description='错误信息'),
}

model ValidateEnvironmentTunnelResponse = {
  headers: map[string]string(name='headers'),
  body: ValidateEnvironmentTunnelResponseBody(name='body'),
}

async function validateEnvironmentTunnel(uid: string, request: ValidateEnvironmentTunnelRequest): ValidateEnvironmentTunnelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return validateEnvironmentTunnelWithOptions(uid, request, headers, runtime);
}

async function validateEnvironmentTunnelWithOptions(uid: string, request: ValidateEnvironmentTunnelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ValidateEnvironmentTunnelResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  var body : map[string]any= {};
  if (!Util.isUnset(request.tunnelConfig)) {
    body['tunnelConfig'] = request.tunnelConfig;
  }
  if (!Util.isUnset(request.tunnelType)) {
    body['tunnelType'] = request.tunnelType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ValidateEnvironmentTunnel',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${uid}/tunnels/validation`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

