/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('adp', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ComponentVersion {
  appVersion?: string(name='appVersion'),
  componentName?: string(name='componentName'),
  componentUID?: string(name='componentUID'),
  description?: string(name='description'),
  documents?: string(name='documents'),
  imagesMapping?: string(name='imagesMapping'),
  namespace?: string(name='namespace'),
  orchestrationType?: string(name='orchestrationType'),
  orchestrationValues?: string(name='orchestrationValues'),
  packageURL?: string(name='packageURL'),
  parentComponent?: boolean(name='parentComponent'),
  platforms?: [
    Platform
  ](name='platforms'),
  readme?: string(name='readme'),
  resources?: string(name='resources'),
  source?: string(name='source'),
  uid?: string(name='uid'),
  version?: string(name='version'),
}

model Disk {
  capacity?: int32(name='capacity'),
  fsType?: string(name='fsType'),
  mountPoint?: string(name='mountPoint'),
  name?: string(name='name'),
  remain?: int32(name='remain'),
  type?: string(name='type'),
}

model ExportPort {
  cidrIP?: string(name='cidrIP'),
  portRange?: string(name='portRange'),
  protocol?: string(name='protocol'),
  unallowed?: boolean(name='unallowed'),
}

model FoundationComponentReferenceDetail {
  appVersion?: string(name='appVersion'),
  category?: string(name='category'),
  class?: string(name='class'),
  componentDescription?: string(name='componentDescription'),
  componentName?: string(name='componentName'),
  componentReferenceUID?: string(name='componentReferenceUID'),
  componentUID?: string(name='componentUID'),
  componentVersionDescription?: string(name='componentVersionDescription'),
  componentVersionUID?: string(name='componentVersionUID'),
  createdAt?: string(name='createdAt'),
  documents?: string(name='documents'),
  enable?: boolean(name='enable'),
  imagesMapping?: string(name='imagesMapping'),
  namespace?: string(name='namespace'),
  orchestrationType?: string(name='orchestrationType'),
  orchestrationValues?: string(name='orchestrationValues'),
  parentComponent?: boolean(name='parentComponent'),
  parentComponentVersionUID?: string(name='parentComponentVersionUID'),
  priority?: int32(name='priority'),
  provider?: string(name='provider'),
  public?: boolean(name='public'),
  readme?: string(name='readme'),
  relationUID?: string(name='relationUID'),
  releaseName?: string(name='releaseName'),
  resources?: string(name='resources'),
  sequence?: int32(name='sequence'),
  singleton?: boolean(name='singleton'),
  source?: string(name='source'),
  values?: string(name='values'),
  version?: string(name='version'),
}

model FoundationVersion {
  clusterConfigSchema?: string(name='clusterConfigSchema'),
  clusterEngines?: [ 
    {
      infrastructureStatements?: [ 
        {
          default?: boolean(name='default'),
          distroName?: string(name='distroName'),
          distroVersion?: string(name='distroVersion'),
          platform?: Platform(name='platform'),
        }
      ](name='infrastructureStatements'),
      networkList?: [ 
        {
          ipFamilies?: [ string ](name='ipFamilies'),
          name?: string(name='name'),
        }
      ](name='networkList'),
      packageTools?: [ 
        {
          image?: string(name='image'),
          installToolPackages?: [ 
            {
              architecture?: string(name='architecture'),
              os?: string(name='os'),
              url?: string(name='url'),
            }
          ](name='installToolPackages'),
          name?: string(name='name'),
          packageFormat?: string(name='packageFormat'),
          type?: string(name='type'),
          version?: string(name='version'),
        }
      ](name='packageTools'),
      packages?: [ 
        {
          architecture?: string(name='architecture'),
          os?: string(name='os'),
          url?: string(name='url'),
        }
      ](name='packages'),
      type?: string(name='type'),
      version?: string(name='version'),
    }
  ](name='clusterEngines'),
  defaultClusterConfig?: string(name='defaultClusterConfig'),
  description?: string(name='description'),
  documents?: string(name='documents'),
  driver?: {
    components?: [ 
      {
        name?: string(name='name'),
        version?: string(name='version'),
      }
    ](name='components'),
  }(name='driver'),
  features?: [ string ](name='features'),
  labels?: string(name='labels'),
  name?: string(name='name'),
  packageTools?: [ 
    {
      name?: string(name='name'),
      version?: string(name='version'),
    }
  ](name='packageTools'),
  platforms?: [
    Platform
  ](name='platforms'),
  status?: string(name='status'),
  tools?: {
    siteSurvey?: {
      clusterCheckerURL?: string(name='clusterCheckerURL'),
      clusterInfoBrief?: string(name='clusterInfoBrief'),
    }(name='siteSurvey'),
  }(name='tools'),
  type?: string(name='type'),
  uid?: string(name='uid'),
  version?: string(name='version'),
}

model GetInstanceInfoResponse {
  annotations?: map[string]string(name='annotations'),
  arch?: string(name='arch'),
  clusterLabels?: map[string]string(name='clusterLabels'),
  clusterTaints?: [ 
    {
      effect?: string(name='effect'),
      key?: string(name='key'),
      value?: string(name='value'),
    }
  ](name='clusterTaints'),
  cpu?: string(name='cpu'),
  dataDisk?: [
    Disk
  ](name='dataDisk'),
  hostName?: string(name='hostName'),
  identifier?: string(name='identifier'),
  imageID?: string(name='imageID'),
  instanceType?: string(name='instanceType'),
  internetBandwidth?: int32(name='internetBandwidth'),
  kernel?: string(name='kernel'),
  labels?: map[string]string(name='labels'),
  macAddress?: string(name='macAddress'),
  memory?: string(name='memory'),
  networkCards?: [ 
    {
      ip?: string(name='ip'),
      name?: string(name='name'),
    }
  ](name='networkCards'),
  os?: string(name='os'),
  osVersion?: string(name='osVersion'),
  privateIP?: string(name='privateIP'),
  publicIP?: string(name='publicIP'),
  rootPassword?: string(name='rootPassword'),
  systemDisk?: [
    Disk
  ](name='systemDisk'),
  systemInfo?: string(name='systemInfo'),
  taints?: [ 
    {
      effect?: string(name='effect'),
      key?: string(name='key'),
      value?: string(name='value'),
    }
  ](name='taints'),
  uid?: string(name='uid'),
}

model GetPayAsYouGoPriceData {
  moduleList?: [ 
    {
      config?: string(name='Config'),
      moduleCode?: string(name='ModuleCode'),
      priceType?: string(name='PriceType'),
    }
  ](name='ModuleList'),
  ownerId?: string(name='OwnerId'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  region?: string(name='Region'),
  subscriptionType?: string(name='SubscriptionType'),
}

model InstanceInfo {
  annotations?: map[string]string(name='annotations'),
  arch?: string(name='arch'),
  clusterLabels?: map[string]string(name='clusterLabels'),
  clusterTaints?: [ 
    {
      effect?: string(name='effect'),
      key?: string(name='key'),
      value?: string(name='value'),
    }
  ](name='clusterTaints'),
  clusterUID?: string(name='clusterUID'),
  cpu?: string(name='cpu'),
  createdAt?: string(name='createdAt'),
  dataDisk?: [
    Disk
  ](name='dataDisk'),
  diskConfigAnnotations?: map[string]string(name='diskConfigAnnotations'),
  hostName?: string(name='hostName'),
  identifier?: string(name='identifier'),
  imageID?: string(name='imageID'),
  instanceType?: string(name='instanceType'),
  internetBandwidth?: int32(name='internetBandwidth'),
  kernel?: string(name='kernel'),
  labels?: map[string]string(name='labels'),
  macAddress?: string(name='macAddress'),
  memory?: string(name='memory'),
  networkCards?: [ 
    {
      ip?: string(name='ip'),
      name?: string(name='name'),
    }
  ](name='networkCards'),
  os?: string(name='os'),
  osVersion?: string(name='osVersion'),
  privateIP?: string(name='privateIP'),
  publicIP?: string(name='publicIP'),
  rootPassword?: string(name='rootPassword'),
  systemDisk?: [
    Disk
  ](name='systemDisk'),
  systemInfo?: string(name='systemInfo'),
  taints?: [ 
    {
      effect?: string(name='effect'),
      key?: string(name='key'),
      value?: string(name='value'),
    }
  ](name='taints'),
  uid?: string(name='uid'),
}

model LabelSelector {
  matchExpressions?: [ 
    {
      key?: string(name='key'),
      operator?: string(name='operator'),
      values?: [ string ](name='values'),
    }
  ](name='matchExpressions'),
  matchLabels?: map[string]string(name='matchLabels'),
}

model Platform {
  architecture?: string(name='architecture'),
  os?: string(name='os'),
}

model ProductComponentRelationDetail {
  appVersion?: string(name='appVersion'),
  category?: string(name='category'),
  class?: string(name='class'),
  componentName?: string(name='componentName'),
  componentOrchestrationValues?: string(name='componentOrchestrationValues'),
  componentUID?: string(name='componentUID'),
  componentVersionUID?: string(name='componentVersionUID'),
  createdAt?: string(name='createdAt'),
  description?: string(name='description'),
  documents?: string(name='documents'),
  enable?: boolean(name='enable'),
  imagesMapping?: string(name='imagesMapping'),
  namespace?: string(name='namespace'),
  orchestrationType?: string(name='orchestrationType'),
  parentComponent?: boolean(name='parentComponent'),
  parentComponentVersionRelationUID?: string(name='parentComponentVersionRelationUID'),
  parentComponentVersionUID?: string(name='parentComponentVersionUID'),
  priority?: int32(name='priority'),
  productVersionUID?: string(name='productVersionUID'),
  provider?: string(name='provider'),
  public?: boolean(name='public'),
  readme?: string(name='readme'),
  relationUID?: string(name='relationUID'),
  releaseName?: string(name='releaseName'),
  resources?: string(name='resources'),
  sequence?: int32(name='sequence'),
  singleton?: boolean(name='singleton'),
  source?: string(name='source'),
  version?: string(name='version'),
}

model Resource {
  cpu?: {
    required?: int32(name='required'),
  }(name='cpu'),
  hostname?: string(name='hostname'),
  identifier?: string(name='identifier'),
  image?: {
    id?: string(name='id'),
    nameRegex?: string(name='nameRegex'),
  }(name='image'),
  instanceType?: string(name='instanceType'),
  memory?: {
    required?: int32(name='required'),
  }(name='memory'),
  ports?: [
    ExportPort
  ](name='ports'),
  publicIP?: {
    bandwidth?: int32(name='bandwidth'),
    required?: int32(name='required'),
  }(name='publicIP'),
  replica?: int32(name='replica'),
  storage?: [ 
    {
      required?: int32(name='required'),
    }
  ](name='storage'),
}

model AddEnvironmentNodesRequest {
  applicationDisk?: string(name='applicationDisk'),
  cpu?: int32(name='cpu'),
  dataDisk?: [ 
    {
      name?: string(name='name'),
      required?: int32(name='required'),
    }
  ](name='dataDisk'),
  etcdDisk?: string(name='etcdDisk'),
  hostName?: string(name='hostName'),
  labels?: map[string]any(name='labels'),
  masterPrivateIPs?: [ string ](name='masterPrivateIPs'),
  memory?: int32(name='memory'),
  os?: string(name='os'),
  rootPassword?: string(name='rootPassword'),
  systemDisk?: [ 
    {
      name?: string(name='name'),
      required?: int32(name='required'),
    }
  ](name='systemDisk'),
  taints?: [ 
    {
      effect?: string(name='effect'),
      key?: string(name='key'),
      value?: string(name='value'),
    }
  ](name='taints'),
  tridentSystemDisk?: string(name='tridentSystemDisk'),
  tridentSystemSizeDisk?: int32(name='tridentSystemSizeDisk'),
  workerPrivateIPs?: [ string ](name='workerPrivateIPs'),
}

model AddEnvironmentNodesResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model AddEnvironmentNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddEnvironmentNodesResponseBody(name='body'),
}

async function addEnvironmentNodes(uid: string, request: AddEnvironmentNodesRequest): AddEnvironmentNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addEnvironmentNodesWithOptions(uid, request, headers, runtime);
}

async function addEnvironmentNodesWithOptions(uid: string, request: AddEnvironmentNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddEnvironmentNodesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.applicationDisk)) {
    body['applicationDisk'] = request.applicationDisk;
  }
  if (!Util.isUnset(request.cpu)) {
    body['cpu'] = request.cpu;
  }
  if (!Util.isUnset(request.dataDisk)) {
    body['dataDisk'] = request.dataDisk;
  }
  if (!Util.isUnset(request.etcdDisk)) {
    body['etcdDisk'] = request.etcdDisk;
  }
  if (!Util.isUnset(request.hostName)) {
    body['hostName'] = request.hostName;
  }
  if (!Util.isUnset(request.labels)) {
    body['labels'] = request.labels;
  }
  if (!Util.isUnset(request.masterPrivateIPs)) {
    body['masterPrivateIPs'] = request.masterPrivateIPs;
  }
  if (!Util.isUnset(request.memory)) {
    body['memory'] = request.memory;
  }
  if (!Util.isUnset(request.os)) {
    body['os'] = request.os;
  }
  if (!Util.isUnset(request.rootPassword)) {
    body['rootPassword'] = request.rootPassword;
  }
  if (!Util.isUnset(request.systemDisk)) {
    body['systemDisk'] = request.systemDisk;
  }
  if (!Util.isUnset(request.taints)) {
    body['taints'] = request.taints;
  }
  if (!Util.isUnset(request.tridentSystemDisk)) {
    body['tridentSystemDisk'] = request.tridentSystemDisk;
  }
  if (!Util.isUnset(request.tridentSystemSizeDisk)) {
    body['tridentSystemSizeDisk'] = request.tridentSystemSizeDisk;
  }
  if (!Util.isUnset(request.workerPrivateIPs)) {
    body['workerPrivateIPs'] = request.workerPrivateIPs;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddEnvironmentNodes',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${OpenApiUtil.getEncodeParam(uid)}/nodes`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AddEnvironmentProductVersionsRequest {
  productVersionInfoList?: [ 
    {
      namespace?: string(name='namespace'),
      productVersionUID?: string(name='productVersionUID'),
      specUID?: string(name='specUID'),
    }
  ](name='productVersionInfoList'),
  productVersionUIDList?: [ string ](name='productVersionUIDList'),
}

model AddEnvironmentProductVersionsResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model AddEnvironmentProductVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddEnvironmentProductVersionsResponseBody(name='body'),
}

async function addEnvironmentProductVersions(uid: string, request: AddEnvironmentProductVersionsRequest): AddEnvironmentProductVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addEnvironmentProductVersionsWithOptions(uid, request, headers, runtime);
}

async function addEnvironmentProductVersionsWithOptions(uid: string, request: AddEnvironmentProductVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddEnvironmentProductVersionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.productVersionInfoList)) {
    body['productVersionInfoList'] = request.productVersionInfoList;
  }
  if (!Util.isUnset(request.productVersionUIDList)) {
    body['productVersionUIDList'] = request.productVersionUIDList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddEnvironmentProductVersions',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${OpenApiUtil.getEncodeParam(uid)}/product-versions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AddProductComponentVersionRequest {
  releaseName?: string(name='releaseName'),
}

model AddProductComponentVersionResponseBody = {
  code?: string(name='code'),
  data?: {
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model AddProductComponentVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddProductComponentVersionResponseBody(name='body'),
}

async function addProductComponentVersion(uid: string, componentVersionUID: string, request: AddProductComponentVersionRequest): AddProductComponentVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addProductComponentVersionWithOptions(uid, componentVersionUID, request, headers, runtime);
}

async function addProductComponentVersionWithOptions(uid: string, componentVersionUID: string, request: AddProductComponentVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddProductComponentVersionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.releaseName)) {
    body['releaseName'] = request.releaseName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddProductComponentVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/integration/api/v2/product-versions/${OpenApiUtil.getEncodeParam(uid)}/component-versions/${OpenApiUtil.getEncodeParam(componentVersionUID)}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AddProductVersionConfigRequest {
  componentReleaseName?: string(name='componentReleaseName'),
  componentVersionUID?: string(name='componentVersionUID'),
  description?: string(name='description'),
  name?: string(name='name'),
  parentComponentReleaseName?: string(name='parentComponentReleaseName'),
  parentComponentVersionUID?: string(name='parentComponentVersionUID'),
  scope?: string(name='scope'),
  value?: string(name='value'),
  valueType?: string(name='valueType'),
}

model AddProductVersionConfigResponseBody = {
  code?: string(name='code'),
  data?: {
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
  requestId?: string(name='requestId'),
}

model AddProductVersionConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddProductVersionConfigResponseBody(name='body'),
}

async function addProductVersionConfig(uid: string, request: AddProductVersionConfigRequest): AddProductVersionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addProductVersionConfigWithOptions(uid, request, headers, runtime);
}

async function addProductVersionConfigWithOptions(uid: string, request: AddProductVersionConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddProductVersionConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.componentReleaseName)) {
    body['componentReleaseName'] = request.componentReleaseName;
  }
  if (!Util.isUnset(request.componentVersionUID)) {
    body['componentVersionUID'] = request.componentVersionUID;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.parentComponentReleaseName)) {
    body['parentComponentReleaseName'] = request.parentComponentReleaseName;
  }
  if (!Util.isUnset(request.parentComponentVersionUID)) {
    body['parentComponentVersionUID'] = request.parentComponentVersionUID;
  }
  if (!Util.isUnset(request.scope)) {
    body['scope'] = request.scope;
  }
  if (!Util.isUnset(request.value)) {
    body['value'] = request.value;
  }
  if (!Util.isUnset(request.valueType)) {
    body['valueType'] = request.valueType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddProductVersionConfig',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${OpenApiUtil.getEncodeParam(uid)}/configs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AddResourceSnapshotRequest {
  name?: string(name='name'),
  clusterUID?: string(name='clusterUID'),
  productVersionUID?: string(name='productVersionUID'),
}

model AddResourceSnapshotResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model AddResourceSnapshotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddResourceSnapshotResponseBody(name='body'),
}

async function addResourceSnapshot(request: AddResourceSnapshotRequest): AddResourceSnapshotResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addResourceSnapshotWithOptions(request, headers, runtime);
}

async function addResourceSnapshotWithOptions(request: AddResourceSnapshotRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddResourceSnapshotResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterUID)) {
    query['clusterUID'] = request.clusterUID;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    query['productVersionUID'] = request.productVersionUID;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddResourceSnapshot',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/resource-snapshots`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchAddEnvironmentNodesRequest {
  instanceList?: [
    InstanceInfo
  ](name='instanceList'),
  overwrite?: boolean(name='overwrite'),
}

model BatchAddEnvironmentNodesResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model BatchAddEnvironmentNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchAddEnvironmentNodesResponseBody(name='body'),
}

async function batchAddEnvironmentNodes(uid: string, request: BatchAddEnvironmentNodesRequest): BatchAddEnvironmentNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchAddEnvironmentNodesWithOptions(uid, request, headers, runtime);
}

async function batchAddEnvironmentNodesWithOptions(uid: string, request: BatchAddEnvironmentNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchAddEnvironmentNodesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceList)) {
    body['instanceList'] = request.instanceList;
  }
  if (!Util.isUnset(request.overwrite)) {
    body['overwrite'] = request.overwrite;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchAddEnvironmentNodes',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${OpenApiUtil.getEncodeParam(uid)}/batch/nodes`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchAddProductVersionConfigRequest {
  productVersionConfigList?: [ 
    {
      componentReleaseName?: string(name='componentReleaseName'),
      componentVersionUID?: string(name='componentVersionUID'),
      description?: string(name='description'),
      name?: string(name='name'),
      parentComponentReleaseName?: string(name='parentComponentReleaseName'),
      parentComponentVersionUID?: string(name='parentComponentVersionUID'),
      scope?: string(name='scope'),
      value?: string(name='value'),
      valueType?: string(name='valueType'),
    }
  ](name='productVersionConfigList'),
}

model BatchAddProductVersionConfigResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model BatchAddProductVersionConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchAddProductVersionConfigResponseBody(name='body'),
}

async function batchAddProductVersionConfig(uid: string, request: BatchAddProductVersionConfigRequest): BatchAddProductVersionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchAddProductVersionConfigWithOptions(uid, request, headers, runtime);
}

async function batchAddProductVersionConfigWithOptions(uid: string, request: BatchAddProductVersionConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchAddProductVersionConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.productVersionConfigList)) {
    body['productVersionConfigList'] = request.productVersionConfigList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchAddProductVersionConfig',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${OpenApiUtil.getEncodeParam(uid)}/batch/configs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateDeliverableRequest {
  foundation?: {
    clusterConfig?: string(name='clusterConfig'),
    foundationReferenceUID?: string(name='foundationReferenceUID'),
    foundationVersion?: string(name='foundationVersion'),
    foundationVersionUID?: string(name='foundationVersionUID'),
    reusable?: boolean(name='reusable'),
  }(name='foundation'),
  products?: [ 
    {
      namespace?: string(name='namespace'),
      productName?: string(name='productName'),
      productType?: string(name='productType'),
      productUID?: string(name='productUID'),
      productVersion?: string(name='productVersion'),
      productVersionSpecName?: string(name='productVersionSpecName'),
      productVersionSpecUID?: string(name='productVersionSpecUID'),
      productVersionUID?: string(name='productVersionUID'),
    }
  ](name='products'),
}

model CreateDeliverableResponseBody = {
  code?: string(name='code'),
  data?: {
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model CreateDeliverableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDeliverableResponseBody(name='body'),
}

async function createDeliverable(request: CreateDeliverableRequest): CreateDeliverableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDeliverableWithOptions(request, headers, runtime);
}

async function createDeliverableWithOptions(request: CreateDeliverableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDeliverableResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.foundation)) {
    body['foundation'] = request.foundation;
  }
  if (!Util.isUnset(request.products)) {
    body['products'] = request.products;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDeliverable',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/delivery/deliverables`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateDeliveryInstanceRequest {
  clusterUID?: string(name='clusterUID'),
  deliverableConfigUID?: string(name='deliverableConfigUID'),
  deliverableUID?: string(name='deliverableUID'),
  envUID?: string(name='envUID'),
}

model CreateDeliveryInstanceResponseBody = {
  code?: string(name='code'),
  data?: {
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model CreateDeliveryInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDeliveryInstanceResponseBody(name='body'),
}

async function createDeliveryInstance(request: CreateDeliveryInstanceRequest): CreateDeliveryInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDeliveryInstanceWithOptions(request, headers, runtime);
}

async function createDeliveryInstanceWithOptions(request: CreateDeliveryInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDeliveryInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clusterUID)) {
    body['clusterUID'] = request.clusterUID;
  }
  if (!Util.isUnset(request.deliverableConfigUID)) {
    body['deliverableConfigUID'] = request.deliverableConfigUID;
  }
  if (!Util.isUnset(request.deliverableUID)) {
    body['deliverableUID'] = request.deliverableUID;
  }
  if (!Util.isUnset(request.envUID)) {
    body['envUID'] = request.envUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDeliveryInstance',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/delivery/delivery-instances`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateDeliveryPackageRequest {
  deliverableUID?: string(name='deliverableUID'),
  originDeliverableUID?: string(name='originDeliverableUID'),
  packageContentType?: string(name='packageContentType'),
  packageType?: string(name='packageType'),
  platform?: string(name='platform'),
}

model CreateDeliveryPackageResponseBody = {
  code?: string(name='code'),
  data?: {
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model CreateDeliveryPackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDeliveryPackageResponseBody(name='body'),
}

async function createDeliveryPackage(request: CreateDeliveryPackageRequest): CreateDeliveryPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDeliveryPackageWithOptions(request, headers, runtime);
}

async function createDeliveryPackageWithOptions(request: CreateDeliveryPackageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDeliveryPackageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deliverableUID)) {
    body['deliverableUID'] = request.deliverableUID;
  }
  if (!Util.isUnset(request.originDeliverableUID)) {
    body['originDeliverableUID'] = request.originDeliverableUID;
  }
  if (!Util.isUnset(request.packageContentType)) {
    body['packageContentType'] = request.packageContentType;
  }
  if (!Util.isUnset(request.packageType)) {
    body['packageType'] = request.packageType;
  }
  if (!Util.isUnset(request.platform)) {
    body['platform'] = request.platform;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDeliveryPackage',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/delivery/delivery-packages`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateEnvironmentHeaders {
  commonHeaders?: map[string]string,
  clientToken?: string(name='ClientToken'),
}

model CreateEnvironmentRequest {
  annotations?: string(name='annotations'),
  description?: string(name='description'),
  location?: string(name='location'),
  name?: string(name='name'),
  platform?: {
    architecture?: string(name='architecture'),
    os?: string(name='os'),
  }(name='platform'),
  platformList?: [
    Platform
  ](name='platformList'),
  productVersionUID?: string(name='productVersionUID'),
  type?: string(name='type'),
  vendorConfig?: string(name='vendorConfig'),
  vendorType?: string(name='vendorType'),
}

model CreateEnvironmentResponseBody = {
  code?: string(name='code'),
  data?: {
    environmentUID?: string(name='environmentUID'),
    vendorConfig?: string(name='vendorConfig'),
  }(name='data'),
  msg?: string(name='msg'),
}

model CreateEnvironmentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateEnvironmentResponseBody(name='body'),
}

async function createEnvironment(request: CreateEnvironmentRequest): CreateEnvironmentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateEnvironmentHeaders{};
  return createEnvironmentWithOptions(request, headers, runtime);
}

async function createEnvironmentWithOptions(request: CreateEnvironmentRequest, headers: CreateEnvironmentHeaders, runtime: Util.RuntimeOptions): CreateEnvironmentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.annotations)) {
    body['annotations'] = request.annotations;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.location)) {
    body['location'] = request.location;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.platform)) {
    body['platform'] = request.platform;
  }
  if (!Util.isUnset(request.platformList)) {
    body['platformList'] = request.platformList;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    body['productVersionUID'] = request.productVersionUID;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }
  if (!Util.isUnset(request.vendorConfig)) {
    body['vendorConfig'] = request.vendorConfig;
  }
  if (!Util.isUnset(request.vendorType)) {
    body['vendorType'] = request.vendorType;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.clientToken)) {
    realHeaders['ClientToken'] = Util.toJSONString(headers.clientToken);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateEnvironment',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateEnvironmentLicenseRequest {
  companyName?: string(name='companyName'),
  contact?: string(name='contact'),
  description?: string(name='description'),
  licenseQuota?: {
    clusterQuota?: {
      cpuCoreLimit?: long(name='cpuCoreLimit'),
    }(name='clusterQuota'),
    customQuotas?: [ 
      {
        description?: string(name='description'),
        key?: string(name='key'),
        value?: string(name='value'),
      }
    ](name='customQuotas'),
  }(name='licenseQuota'),
  machineFingerprint?: string(name='machineFingerprint'),
  name?: string(name='name'),
  productVersionUID?: string(name='productVersionUID'),
  scenario?: string(name='scenario'),
  scope?: string(name='scope'),
  type?: string(name='type'),
}

model CreateEnvironmentLicenseResponseBody = {
  code?: string(name='code'),
  data?: {
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model CreateEnvironmentLicenseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateEnvironmentLicenseResponseBody(name='body'),
}

async function createEnvironmentLicense(uid: string, request: CreateEnvironmentLicenseRequest): CreateEnvironmentLicenseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createEnvironmentLicenseWithOptions(uid, request, headers, runtime);
}

async function createEnvironmentLicenseWithOptions(uid: string, request: CreateEnvironmentLicenseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateEnvironmentLicenseResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.companyName)) {
    body['companyName'] = request.companyName;
  }
  if (!Util.isUnset(request.contact)) {
    body['contact'] = request.contact;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.licenseQuota)) {
    body['licenseQuota'] = request.licenseQuota;
  }
  if (!Util.isUnset(request.machineFingerprint)) {
    body['machineFingerprint'] = request.machineFingerprint;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    body['productVersionUID'] = request.productVersionUID;
  }
  if (!Util.isUnset(request.scenario)) {
    body['scenario'] = request.scenario;
  }
  if (!Util.isUnset(request.scope)) {
    body['scope'] = request.scope;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateEnvironmentLicense',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${OpenApiUtil.getEncodeParam(uid)}/licenses`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateFoundationReferenceRequest {
  clusterConfig?: string(name='clusterConfig'),
  componentConfigs?: [ 
    {
      componentVersionUID?: string(name='componentVersionUID'),
      orchestrationValues?: string(name='orchestrationValues'),
    }
  ](name='componentConfigs'),
  foundationVersionUID?: string(name='foundationVersionUID'),
  originFoundationReferenceUID?: string(name='originFoundationReferenceUID'),
}

model CreateFoundationReferenceResponseBody = {
  code?: string(name='code'),
  data?: {
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model CreateFoundationReferenceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFoundationReferenceResponseBody(name='body'),
}

async function createFoundationReference(request: CreateFoundationReferenceRequest): CreateFoundationReferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFoundationReferenceWithOptions(request, headers, runtime);
}

async function createFoundationReferenceWithOptions(request: CreateFoundationReferenceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFoundationReferenceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clusterConfig)) {
    body['clusterConfig'] = request.clusterConfig;
  }
  if (!Util.isUnset(request.componentConfigs)) {
    body['componentConfigs'] = request.componentConfigs;
  }
  if (!Util.isUnset(request.foundationVersionUID)) {
    body['foundationVersionUID'] = request.foundationVersionUID;
  }
  if (!Util.isUnset(request.originFoundationReferenceUID)) {
    body['originFoundationReferenceUID'] = request.originFoundationReferenceUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFoundationReference',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/foundation-references`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateProductHeaders {
  commonHeaders?: map[string]string,
  clientToken?: string(name='ClientToken'),
}

model CreateProductRequest {
  categories?: [ string ](name='categories'),
  description?: string(name='description'),
  displayName?: string(name='displayName'),
  foundationVersionUID?: string(name='foundationVersionUID'),
  productName?: string(name='productName'),
  vendor?: string(name='vendor'),
}

model CreateProductResponseBody = {
  code?: string(name='code'),
  data?: {
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model CreateProductResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateProductResponseBody(name='body'),
}

async function createProduct(request: CreateProductRequest): CreateProductResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateProductHeaders{};
  return createProductWithOptions(request, headers, runtime);
}

async function createProductWithOptions(request: CreateProductRequest, headers: CreateProductHeaders, runtime: Util.RuntimeOptions): CreateProductResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.categories)) {
    body['categories'] = request.categories;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.foundationVersionUID)) {
    body['foundationVersionUID'] = request.foundationVersionUID;
  }
  if (!Util.isUnset(request.productName)) {
    body['productName'] = request.productName;
  }
  if (!Util.isUnset(request.vendor)) {
    body['vendor'] = request.vendor;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.clientToken)) {
    realHeaders['ClientToken'] = Util.toJSONString(headers.clientToken);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateProduct',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/integration/api/v2/products`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateProductDeploymentRequest {
  environmentUID?: string(name='environmentUID'),
  namespace?: string(name='namespace'),
  oldProductVersionUID?: string(name='oldProductVersionUID'),
  packageConfig?: string(name='packageConfig'),
  packageUID?: string(name='packageUID'),
  productVersionUID?: string(name='productVersionUID'),
}

model CreateProductDeploymentResponseBody = {
  code?: string(name='code'),
  data?: {
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model CreateProductDeploymentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateProductDeploymentResponseBody(name='body'),
}

async function createProductDeployment(request: CreateProductDeploymentRequest): CreateProductDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createProductDeploymentWithOptions(request, headers, runtime);
}

async function createProductDeploymentWithOptions(request: CreateProductDeploymentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateProductDeploymentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.environmentUID)) {
    body['environmentUID'] = request.environmentUID;
  }
  if (!Util.isUnset(request.namespace)) {
    body['namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.oldProductVersionUID)) {
    body['oldProductVersionUID'] = request.oldProductVersionUID;
  }
  if (!Util.isUnset(request.packageConfig)) {
    body['packageConfig'] = request.packageConfig;
  }
  if (!Util.isUnset(request.packageUID)) {
    body['packageUID'] = request.packageUID;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    body['productVersionUID'] = request.productVersionUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateProductDeployment',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-instances/deployments`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateProductVersionRequest {
  baseProductVersionUID?: string(name='baseProductVersionUID'),
}

model CreateProductVersionResponseBody = {
  code?: string(name='code'),
  data?: {
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model CreateProductVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateProductVersionResponseBody(name='body'),
}

async function createProductVersion(uid: string, request: CreateProductVersionRequest): CreateProductVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createProductVersionWithOptions(uid, request, headers, runtime);
}

async function createProductVersionWithOptions(uid: string, request: CreateProductVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateProductVersionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.baseProductVersionUID)) {
    query['baseProductVersionUID'] = request.baseProductVersionUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateProductVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/integration/api/v2/products/${OpenApiUtil.getEncodeParam(uid)}/versions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateProductVersionPackageHeaders {
  commonHeaders?: map[string]string,
  clientToken?: string(name='ClientToken'),
}

model CreateProductVersionPackageRequest {
  clusterEngineType?: string(name='clusterEngineType'),
  foundationReferenceUID?: string(name='foundationReferenceUID'),
  oldFoundationReferenceUID?: string(name='oldFoundationReferenceUID'),
  oldProductVersionUID?: string(name='oldProductVersionUID'),
  packageContentType?: string(name='packageContentType'),
  packageToolType?: string(name='packageToolType'),
  packageType?: string(name='packageType'),
  platform?: string(name='platform'),
}

model CreateProductVersionPackageResponseBody = {
  code?: string(name='code'),
  data?: {
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model CreateProductVersionPackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateProductVersionPackageResponseBody(name='body'),
}

async function createProductVersionPackage(uid: string, request: CreateProductVersionPackageRequest): CreateProductVersionPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateProductVersionPackageHeaders{};
  return createProductVersionPackageWithOptions(uid, request, headers, runtime);
}

async function createProductVersionPackageWithOptions(uid: string, request: CreateProductVersionPackageRequest, headers: CreateProductVersionPackageHeaders, runtime: Util.RuntimeOptions): CreateProductVersionPackageResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterEngineType)) {
    query['clusterEngineType'] = request.clusterEngineType;
  }
  if (!Util.isUnset(request.foundationReferenceUID)) {
    query['foundationReferenceUID'] = request.foundationReferenceUID;
  }
  if (!Util.isUnset(request.oldFoundationReferenceUID)) {
    query['oldFoundationReferenceUID'] = request.oldFoundationReferenceUID;
  }
  if (!Util.isUnset(request.oldProductVersionUID)) {
    query['oldProductVersionUID'] = request.oldProductVersionUID;
  }
  if (!Util.isUnset(request.packageContentType)) {
    query['packageContentType'] = request.packageContentType;
  }
  if (!Util.isUnset(request.packageToolType)) {
    query['packageToolType'] = request.packageToolType;
  }
  if (!Util.isUnset(request.packageType)) {
    query['packageType'] = request.packageType;
  }
  if (!Util.isUnset(request.platform)) {
    query['platform'] = request.platform;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.clientToken)) {
    realHeaders['ClientToken'] = Util.toJSONString(headers.clientToken);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateProductVersionPackage',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/hosting/product-versions/${OpenApiUtil.getEncodeParam(uid)}/packages`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteEnvironmentResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model DeleteEnvironmentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEnvironmentResponseBody(name='body'),
}

async function deleteEnvironment(uid: string): DeleteEnvironmentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteEnvironmentWithOptions(uid, headers, runtime);
}

async function deleteEnvironmentWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteEnvironmentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteEnvironment',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${OpenApiUtil.getEncodeParam(uid)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteEnvironmentLicenseResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
  requestId?: string(name='requestId'),
}

model DeleteEnvironmentLicenseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEnvironmentLicenseResponseBody(name='body'),
}

async function deleteEnvironmentLicense(uid: string, licenseUID: string): DeleteEnvironmentLicenseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteEnvironmentLicenseWithOptions(uid, licenseUID, headers, runtime);
}

async function deleteEnvironmentLicenseWithOptions(uid: string, licenseUID: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteEnvironmentLicenseResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteEnvironmentLicense',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${OpenApiUtil.getEncodeParam(uid)}/licenses/${OpenApiUtil.getEncodeParam(licenseUID)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteEnvironmentNodeResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model DeleteEnvironmentNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEnvironmentNodeResponseBody(name='body'),
}

async function deleteEnvironmentNode(uid: string, nodeUID: string): DeleteEnvironmentNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteEnvironmentNodeWithOptions(uid, nodeUID, headers, runtime);
}

async function deleteEnvironmentNodeWithOptions(uid: string, nodeUID: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteEnvironmentNodeResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteEnvironmentNode',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${OpenApiUtil.getEncodeParam(uid)}/nodes/${OpenApiUtil.getEncodeParam(nodeUID)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteEnvironmentProductVersionResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model DeleteEnvironmentProductVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEnvironmentProductVersionResponseBody(name='body'),
}

async function deleteEnvironmentProductVersion(uid: string, productVersionUID: string): DeleteEnvironmentProductVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteEnvironmentProductVersionWithOptions(uid, productVersionUID, headers, runtime);
}

async function deleteEnvironmentProductVersionWithOptions(uid: string, productVersionUID: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteEnvironmentProductVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteEnvironmentProductVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${OpenApiUtil.getEncodeParam(uid)}/product-versions/${OpenApiUtil.getEncodeParam(productVersionUID)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteProductResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model DeleteProductResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteProductResponseBody(name='body'),
}

async function deleteProduct(uid: string): DeleteProductResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProductWithOptions(uid, headers, runtime);
}

async function deleteProductWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProductResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteProduct',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/integration/api/v2/products/${OpenApiUtil.getEncodeParam(uid)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteProductComponentVersionResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model DeleteProductComponentVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteProductComponentVersionResponseBody(name='body'),
}

async function deleteProductComponentVersion(uid: string, relationUID: string): DeleteProductComponentVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProductComponentVersionWithOptions(uid, relationUID, headers, runtime);
}

async function deleteProductComponentVersionWithOptions(uid: string, relationUID: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProductComponentVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteProductComponentVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${OpenApiUtil.getEncodeParam(uid)}/relations/${OpenApiUtil.getEncodeParam(relationUID)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteProductInstanceConfigRequest {
  environmentUID?: string(name='environmentUID'),
  productVersionUID?: string(name='productVersionUID'),
}

model DeleteProductInstanceConfigResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model DeleteProductInstanceConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteProductInstanceConfigResponseBody(name='body'),
}

async function deleteProductInstanceConfig(configUID: string, request: DeleteProductInstanceConfigRequest): DeleteProductInstanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProductInstanceConfigWithOptions(configUID, request, headers, runtime);
}

async function deleteProductInstanceConfigWithOptions(configUID: string, request: DeleteProductInstanceConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProductInstanceConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.environmentUID)) {
    query['environmentUID'] = request.environmentUID;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    query['productVersionUID'] = request.productVersionUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProductInstanceConfig',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-instances/configs/${OpenApiUtil.getEncodeParam(configUID)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteProductVersionResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
  requestId?: string(name='requestId'),
}

model DeleteProductVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteProductVersionResponseBody(name='body'),
}

async function deleteProductVersion(uid: string): DeleteProductVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProductVersionWithOptions(uid, headers, runtime);
}

async function deleteProductVersionWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProductVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteProductVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${OpenApiUtil.getEncodeParam(uid)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteProductVersionConfigResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
  requestId?: string(name='requestId'),
}

model DeleteProductVersionConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteProductVersionConfigResponseBody(name='body'),
}

async function deleteProductVersionConfig(uid: string, configUID: string): DeleteProductVersionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProductVersionConfigWithOptions(uid, configUID, headers, runtime);
}

async function deleteProductVersionConfigWithOptions(uid: string, configUID: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProductVersionConfigResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteProductVersionConfig',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${OpenApiUtil.getEncodeParam(uid)}/configs/${OpenApiUtil.getEncodeParam(configUID)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GenerateProductInstanceDeploymentConfigRequest {
  environmentUID?: string(name='environmentUID'),
  packageUID?: string(name='packageUID'),
  productVersionUID?: string(name='productVersionUID'),
  productVersionUIDList?: [ string ](name='productVersionUIDList'),
}

model GenerateProductInstanceDeploymentConfigResponseBody = {
  code?: string(name='code'),
  data?: {
    packageConfig?: string(name='packageConfig'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GenerateProductInstanceDeploymentConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateProductInstanceDeploymentConfigResponseBody(name='body'),
}

async function generateProductInstanceDeploymentConfig(request: GenerateProductInstanceDeploymentConfigRequest): GenerateProductInstanceDeploymentConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return generateProductInstanceDeploymentConfigWithOptions(request, headers, runtime);
}

async function generateProductInstanceDeploymentConfigWithOptions(request: GenerateProductInstanceDeploymentConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GenerateProductInstanceDeploymentConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.environmentUID)) {
    body['environmentUID'] = request.environmentUID;
  }
  if (!Util.isUnset(request.packageUID)) {
    body['packageUID'] = request.packageUID;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    body['productVersionUID'] = request.productVersionUID;
  }
  if (!Util.isUnset(request.productVersionUIDList)) {
    body['productVersionUIDList'] = request.productVersionUIDList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GenerateProductInstanceDeploymentConfig',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-instances/package-configs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetComponentResponseBody = {
  code?: string(name='code'),
  data?: {
    category?: string(name='category'),
    description?: string(name='description'),
    documents?: string(name='documents'),
    name?: string(name='name'),
    public?: boolean(name='public'),
    singleton?: boolean(name='singleton'),
    source?: string(name='source'),
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GetComponentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetComponentResponseBody(name='body'),
}

async function getComponent(uid: string): GetComponentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getComponentWithOptions(uid, headers, runtime);
}

async function getComponentWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetComponentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetComponent',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/components/${OpenApiUtil.getEncodeParam(uid)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetComponentVersionRequest {
  withoutChartContent?: boolean(name='withoutChartContent'),
}

model GetComponentVersionResponseBody = {
  code?: string(name='code'),
  data?: [ 
    {
      componentName?: string(name='componentName'),
      componentUID?: string(name='componentUID'),
      description?: string(name='description'),
      documents?: string(name='documents'),
      orchestrationValues?: string(name='orchestrationValues'),
      packageURL?: string(name='packageURL'),
      parentComponent?: boolean(name='parentComponent'),
      productComponentVersionUID?: string(name='productComponentVersionUID'),
      provider?: string(name='provider'),
      readme?: string(name='readme'),
      resources?: {
        limits?: map[string]any(name='limits'),
        requests?: map[string]any(name='requests'),
      }(name='resources'),
      uid?: string(name='uid'),
      version?: string(name='version'),
    }
  ](name='data'),
  msg?: string(name='msg'),
}

model GetComponentVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetComponentVersionResponseBody(name='body'),
}

async function getComponentVersion(uid: string, versionUID: string, request: GetComponentVersionRequest): GetComponentVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getComponentVersionWithOptions(uid, versionUID, request, headers, runtime);
}

async function getComponentVersionWithOptions(uid: string, versionUID: string, request: GetComponentVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetComponentVersionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.withoutChartContent)) {
    query['withoutChartContent'] = request.withoutChartContent;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetComponentVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/integration/api/v2/components/${OpenApiUtil.getEncodeParam(uid)}/versions/${OpenApiUtil.getEncodeParam(versionUID)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetDeliverableResponseBody = {
  code?: string(name='code'),
  data?: {
    foundation?: {
      clusterConfig?: string(name='clusterConfig'),
      foundationReferenceUID?: string(name='foundationReferenceUID'),
      foundationVersion?: string(name='foundationVersion'),
      foundationVersionUID?: string(name='foundationVersionUID'),
    }(name='foundation'),
    products?: [ 
      {
        productName?: string(name='productName'),
        productType?: string(name='productType'),
        productUID?: string(name='productUID'),
        productVersion?: string(name='productVersion'),
        productVersionSpecName?: string(name='productVersionSpecName'),
        productVersionSpecUID?: string(name='productVersionSpecUID'),
        productVersionUID?: string(name='productVersionUID'),
      }
    ](name='products'),
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GetDeliverableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeliverableResponseBody(name='body'),
}

async function getDeliverable(uid: string): GetDeliverableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDeliverableWithOptions(uid, headers, runtime);
}

async function getDeliverableWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetDeliverableResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetDeliverable',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/delivery/deliverables/${OpenApiUtil.getEncodeParam(uid)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetDeliveryPackageResponseBody = {
  code?: string(name='code'),
  data?: {
    deliverableUID?: string(name='deliverableUID'),
    originDeliverableUID?: string(name='originDeliverableUID'),
    packageContentType?: string(name='packageContentType'),
    packageSize?: string(name='packageSize'),
    packageStatus?: string(name='packageStatus'),
    packageType?: string(name='packageType'),
    packageUID?: string(name='packageUID'),
    packageURL?: string(name='packageURL'),
    platform?: string(name='platform'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GetDeliveryPackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeliveryPackageResponseBody(name='body'),
}

async function getDeliveryPackage(uid: string): GetDeliveryPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDeliveryPackageWithOptions(uid, headers, runtime);
}

async function getDeliveryPackageWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetDeliveryPackageResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetDeliveryPackage',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/delivery/delivery-packages/${OpenApiUtil.getEncodeParam(uid)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetEnvironmentRequest {
  options?: {
    withSiteSurveyReport?: boolean(name='withSiteSurveyReport'),
  }(name='options'),
}

model GetEnvironmentShrinkRequest {
  optionsShrink?: string(name='options'),
}

model GetEnvironmentResponseBody = {
  code?: string(name='code'),
  data?: {
    advancedConfigs?: {
      enableDeploySimulation?: boolean(name='enableDeploySimulation'),
      enableSiteSurvey?: boolean(name='enableSiteSurvey'),
    }(name='advancedConfigs'),
    clusterId?: string(name='clusterId'),
    clusterUID?: string(name='clusterUID'),
    createdAt?: string(name='createdAt'),
    description?: string(name='description'),
    foundationVersion?: string(name='foundationVersion'),
    foundationVersionUID?: string(name='foundationVersionUID'),
    instanceList?: [
      InstanceInfo
    ](name='instanceList'),
    instanceStatus?: string(name='instanceStatus'),
    location?: string(name='location'),
    name?: string(name='name'),
    oldProductVersion?: string(name='oldProductVersion'),
    oldProductVersionUID?: string(name='oldProductVersionUID'),
    platform?: {
      architecture?: string(name='architecture'),
      os?: string(name='os'),
    }(name='platform'),
    platformList?: [
      Platform
    ](name='platformList'),
    platformStatus?: string(name='platformStatus'),
    productName?: string(name='productName'),
    productVersion?: string(name='productVersion'),
    siteSurveyReport?: {
      checkList?: [ 
        {
          description?: map[string]any(name='description'),
          failedList?: [ 
            {
              ip?: string(name='ip'),
              reason?: map[string]any(name='reason'),
            }
          ](name='failedList'),
          level?: string(name='level'),
          name?: string(name='name'),
          status?: string(name='status'),
        }
      ](name='checkList'),
      result?: string(name='result'),
    }(name='siteSurveyReport'),
    uid?: string(name='uid'),
    vendorConfig?: string(name='vendorConfig'),
    vendorType?: string(name='vendorType'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GetEnvironmentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEnvironmentResponseBody(name='body'),
}

async function getEnvironment(uid: string, request: GetEnvironmentRequest): GetEnvironmentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEnvironmentWithOptions(uid, request, headers, runtime);
}

async function getEnvironmentWithOptions(uid: string, tmpReq: GetEnvironmentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetEnvironmentResponse {
  Util.validateModel(tmpReq);
  var request = new GetEnvironmentShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.options)) {
    request.optionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.options, 'options', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.optionsShrink)) {
    query['options'] = request.optionsShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetEnvironment',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${OpenApiUtil.getEncodeParam(uid)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetEnvironmentDeliveryInstanceRequest {
  clusterUID?: string(name='clusterUID'),
  envUID?: string(name='envUID'),
}

model GetEnvironmentDeliveryInstanceResponseBody = {
  code?: string(name='code'),
  data?: {
    clusterUID?: string(name='clusterUID'),
    deliverableConfigUID?: string(name='deliverableConfigUID'),
    deliverableUID?: string(name='deliverableUID'),
    envUID?: string(name='envUID'),
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GetEnvironmentDeliveryInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEnvironmentDeliveryInstanceResponseBody(name='body'),
}

async function getEnvironmentDeliveryInstance(request: GetEnvironmentDeliveryInstanceRequest): GetEnvironmentDeliveryInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEnvironmentDeliveryInstanceWithOptions(request, headers, runtime);
}

async function getEnvironmentDeliveryInstanceWithOptions(request: GetEnvironmentDeliveryInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetEnvironmentDeliveryInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterUID)) {
    query['clusterUID'] = request.clusterUID;
  }
  if (!Util.isUnset(request.envUID)) {
    query['envUID'] = request.envUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetEnvironmentDeliveryInstance',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/delivery/delivery-instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetEnvironmentLicenseRequest {
  options?: {
    withSecretYAML?: boolean(name='withSecretYAML'),
  }(name='options'),
}

model GetEnvironmentLicenseShrinkRequest {
  optionsShrink?: string(name='options'),
}

model GetEnvironmentLicenseResponseBody = {
  code?: string(name='code'),
  data?: {
    expireTime?: string(name='expireTime'),
    licenseKey?: string(name='licenseKey'),
    licenseQuota?: {
      clusterQuota?: {
        cpuCoreLimit?: long(name='cpuCoreLimit'),
      }(name='clusterQuota'),
      componentQuotas?: [ 
        {
          componentName?: string(name='componentName'),
          componentSource?: string(name='componentSource'),
          instanceLimit?: long(name='instanceLimit'),
        }
      ](name='componentQuotas'),
      customQuotas?: [ 
        {
          description?: string(name='description'),
          key?: string(name='key'),
          value?: string(name='value'),
        }
      ](name='customQuotas'),
    }(name='licenseQuota'),
    productVersionUID?: string(name='productVersionUID'),
    rejectReason?: string(name='rejectReason'),
    scope?: string(name='scope'),
    secretYAML?: string(name='secretYAML'),
    status?: string(name='status'),
    type?: string(name='type'),
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GetEnvironmentLicenseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEnvironmentLicenseResponseBody(name='body'),
}

async function getEnvironmentLicense(uid: string, licenseUID: string, request: GetEnvironmentLicenseRequest): GetEnvironmentLicenseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEnvironmentLicenseWithOptions(uid, licenseUID, request, headers, runtime);
}

async function getEnvironmentLicenseWithOptions(uid: string, licenseUID: string, tmpReq: GetEnvironmentLicenseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetEnvironmentLicenseResponse {
  Util.validateModel(tmpReq);
  var request = new GetEnvironmentLicenseShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.options)) {
    request.optionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.options, 'options', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.optionsShrink)) {
    query['options'] = request.optionsShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetEnvironmentLicense',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${OpenApiUtil.getEncodeParam(uid)}/licenses/${OpenApiUtil.getEncodeParam(licenseUID)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetEnvironmentNodeResponseBody = {
  code?: string(name='code'),
  data?: InstanceInfo(name='data'),
  msg?: string(name='msg'),
}

model GetEnvironmentNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEnvironmentNodeResponseBody(name='body'),
}

async function getEnvironmentNode(uid: string, nodeUID: string): GetEnvironmentNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEnvironmentNodeWithOptions(uid, nodeUID, headers, runtime);
}

async function getEnvironmentNodeWithOptions(uid: string, nodeUID: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetEnvironmentNodeResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetEnvironmentNode',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${OpenApiUtil.getEncodeParam(uid)}/nodes/${OpenApiUtil.getEncodeParam(nodeUID)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetFoundationComponentReferenceResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [
      FoundationComponentReferenceDetail
    ](name='list'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GetFoundationComponentReferenceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFoundationComponentReferenceResponseBody(name='body'),
}

async function getFoundationComponentReference(componentReferenceUID: string, uid: string): GetFoundationComponentReferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFoundationComponentReferenceWithOptions(componentReferenceUID, uid, headers, runtime);
}

async function getFoundationComponentReferenceWithOptions(componentReferenceUID: string, uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetFoundationComponentReferenceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetFoundationComponentReference',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/foundation-references/${OpenApiUtil.getEncodeParam(uid)}/components/${OpenApiUtil.getEncodeParam(componentReferenceUID)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetFoundationReferenceResponseBody = {
  code?: string(name='code'),
  data?: {
    clusterConfig?: string(name='clusterConfig'),
    foundationVersionUID?: string(name='foundationVersionUID'),
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GetFoundationReferenceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFoundationReferenceResponseBody(name='body'),
}

async function getFoundationReference(uid: string): GetFoundationReferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFoundationReferenceWithOptions(uid, headers, runtime);
}

async function getFoundationReferenceWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetFoundationReferenceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetFoundationReference',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/foundation-references/${OpenApiUtil.getEncodeParam(uid)}/info`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetFoundationVersionResponseBody = {
  code?: string(name='code'),
  data?: {
    description?: string(name='description'),
    features?: [ string ](name='features'),
    labels?: string(name='labels'),
    name?: string(name='name'),
    platforms?: [
      Platform
    ](name='platforms'),
    siteSurveyTool?: {
      clusterCheckerURL?: string(name='clusterCheckerURL'),
      clusterInfoBrief?: string(name='clusterInfoBrief'),
    }(name='siteSurveyTool'),
    status?: string(name='status'),
    type?: string(name='type'),
    uid?: string(name='uid'),
    version?: string(name='version'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GetFoundationVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFoundationVersionResponseBody(name='body'),
}

async function getFoundationVersion(uid: string): GetFoundationVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFoundationVersionWithOptions(uid, headers, runtime);
}

async function getFoundationVersionWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetFoundationVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetFoundationVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/foundation/versions/${OpenApiUtil.getEncodeParam(uid)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProductRequest {
  withIconURL?: boolean(name='withIconURL'),
}

model GetProductResponseBody = {
  code?: string(name='code'),
  data?: {
    categories?: [ string ](name='categories'),
    description?: string(name='description'),
    displayName?: string(name='displayName'),
    icons?: [ 
      {
        description?: string(name='description'),
        name?: string(name='name'),
        url?: string(name='url'),
      }
    ](name='icons'),
    name?: string(name='name'),
    uid?: string(name='uid'),
    vendor?: string(name='vendor'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GetProductResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProductResponseBody(name='body'),
}

async function getProduct(uid: string, request: GetProductRequest): GetProductResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProductWithOptions(uid, request, headers, runtime);
}

async function getProductWithOptions(uid: string, request: GetProductRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProductResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.withIconURL)) {
    query['withIconURL'] = request.withIconURL;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProduct',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/products/${OpenApiUtil.getEncodeParam(uid)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProductComponentVersionResponseBody = {
  code?: string(name='code'),
  data?: [ 
    {
      appVersion?: string(name='appVersion'),
      componentDescription?: string(name='componentDescription'),
      componentName?: string(name='componentName'),
      componentUID?: string(name='componentUID'),
      componentVersionDescription?: string(name='componentVersionDescription'),
      componentVersionUID?: string(name='componentVersionUID'),
      enable?: boolean(name='enable'),
      namespace?: string(name='namespace'),
      orchestrationValues?: string(name='orchestrationValues'),
      parentComponent?: boolean(name='parentComponent'),
      parentComponentVersionRelationUID?: string(name='parentComponentVersionRelationUID'),
      parentComponentVersionUID?: string(name='parentComponentVersionUID'),
      productVersionUID?: string(name='productVersionUID'),
      relationUID?: string(name='relationUID'),
      releaseName?: string(name='releaseName'),
      resources?: string(name='resources'),
      sequence?: int32(name='sequence'),
      values?: string(name='values'),
      version?: string(name='version'),
    }
  ](name='data'),
  msg?: string(name='msg'),
}

model GetProductComponentVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProductComponentVersionResponseBody(name='body'),
}

async function getProductComponentVersion(relationUID: string, uid: string): GetProductComponentVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProductComponentVersionWithOptions(relationUID, uid, headers, runtime);
}

async function getProductComponentVersionWithOptions(relationUID: string, uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetProductComponentVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetProductComponentVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/integration/api/v2/product-versions/${OpenApiUtil.getEncodeParam(uid)}/relations/${OpenApiUtil.getEncodeParam(relationUID)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProductDeploymentRequest {
  environmentUID?: string(name='environmentUID'),
  productVersionUID?: string(name='productVersionUID'),
  withParamConfig?: boolean(name='withParamConfig'),
}

model GetProductDeploymentResponseBody = {
  code?: string(name='code'),
  data?: {
    envParams?: string(name='envParams'),
    envUID?: string(name='envUID'),
    status?: string(name='status'),
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GetProductDeploymentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProductDeploymentResponseBody(name='body'),
}

async function getProductDeployment(deploymentUID: string, request: GetProductDeploymentRequest): GetProductDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProductDeploymentWithOptions(deploymentUID, request, headers, runtime);
}

async function getProductDeploymentWithOptions(deploymentUID: string, request: GetProductDeploymentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProductDeploymentResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.environmentUID)) {
    query['environmentUID'] = request.environmentUID;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    query['productVersionUID'] = request.productVersionUID;
  }
  if (!Util.isUnset(request.withParamConfig)) {
    query['withParamConfig'] = request.withParamConfig;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProductDeployment',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-instances/deployments/${OpenApiUtil.getEncodeParam(deploymentUID)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProductVersionRequest {
  withDocumentationURL?: boolean(name='withDocumentationURL'),
  withExtendResourceURL?: boolean(name='withExtendResourceURL'),
}

model GetProductVersionResponseBody = {
  code?: string(name='code'),
  data?: {
    continuousIntegration?: boolean(name='continuousIntegration'),
    description?: string(name='description'),
    documentations?: [ 
      {
        description?: string(name='description'),
        name?: string(name='name'),
        url?: string(name='url'),
      }
    ](name='documentations'),
    extendedResources?: [ 
      {
        description?: string(name='description'),
        name?: string(name='name'),
        url?: string(name='url'),
      }
    ](name='extendedResources'),
    foundationVersionUID?: string(name='foundationVersionUID'),
    packageURL?: string(name='packageURL'),
    platforms?: [
      Platform
    ](name='platforms'),
    productName?: string(name='productName'),
    productUID?: string(name='productUID'),
    provider?: string(name='provider'),
    uid?: string(name='uid'),
    version?: string(name='version'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GetProductVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProductVersionResponseBody(name='body'),
}

async function getProductVersion(uid: string, request: GetProductVersionRequest): GetProductVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProductVersionWithOptions(uid, request, headers, runtime);
}

async function getProductVersionWithOptions(uid: string, request: GetProductVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProductVersionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.withDocumentationURL)) {
    query['withDocumentationURL'] = request.withDocumentationURL;
  }
  if (!Util.isUnset(request.withExtendResourceURL)) {
    query['withExtendResourceURL'] = request.withExtendResourceURL;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProductVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${OpenApiUtil.getEncodeParam(uid)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProductVersionDifferencesRequest {
  preVersionUID?: string(name='preVersionUID'),
}

model GetProductVersionDifferencesResponseBody = {
  code?: string(name='code'),
  data?: [ 
    {
      componentName?: string(name='componentName'),
      difference?: string(name='difference'),
      message?: string(name='message'),
      preVersion?: string(name='preVersion'),
      releaseName?: string(name='releaseName'),
      upgradeFlag?: boolean(name='upgradeFlag'),
      version?: string(name='version'),
    }
  ](name='data'),
  msg?: string(name='msg'),
  requestId?: string(name='requestId'),
}

model GetProductVersionDifferencesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProductVersionDifferencesResponseBody(name='body'),
}

async function getProductVersionDifferences(uid: string, versionUID: string, request: GetProductVersionDifferencesRequest): GetProductVersionDifferencesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProductVersionDifferencesWithOptions(uid, versionUID, request, headers, runtime);
}

async function getProductVersionDifferencesWithOptions(uid: string, versionUID: string, request: GetProductVersionDifferencesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProductVersionDifferencesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.preVersionUID)) {
    query['preVersionUID'] = request.preVersionUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProductVersionDifferences',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/integration/api/v2/products/${OpenApiUtil.getEncodeParam(uid)}/versions/${OpenApiUtil.getEncodeParam(versionUID)}/differences`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProductVersionPackageRequest {
  foundationReferenceUID?: string(name='foundationReferenceUID'),
  oldFoundationReferenceUID?: string(name='oldFoundationReferenceUID'),
  oldProductVersionUID?: string(name='oldProductVersionUID'),
  packageContentType?: string(name='packageContentType'),
  packageType?: string(name='packageType'),
  packageUID?: string(name='packageUID'),
  platform?: string(name='platform'),
  withURL?: boolean(name='withURL'),
}

model GetProductVersionPackageResponseBody = {
  code?: string(name='code'),
  data?: {
    packageContentType?: string(name='packageContentType'),
    packageSize?: string(name='packageSize'),
    packageStatus?: string(name='packageStatus'),
    packageType?: string(name='packageType'),
    packageUID?: string(name='packageUID'),
    packageURL?: string(name='packageURL'),
    platform?: Platform(name='platform'),
    platformList?: [
      Platform
    ](name='platformList'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GetProductVersionPackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProductVersionPackageResponseBody(name='body'),
}

async function getProductVersionPackage(uid: string, request: GetProductVersionPackageRequest): GetProductVersionPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProductVersionPackageWithOptions(uid, request, headers, runtime);
}

async function getProductVersionPackageWithOptions(uid: string, request: GetProductVersionPackageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProductVersionPackageResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.foundationReferenceUID)) {
    query['foundationReferenceUID'] = request.foundationReferenceUID;
  }
  if (!Util.isUnset(request.oldFoundationReferenceUID)) {
    query['oldFoundationReferenceUID'] = request.oldFoundationReferenceUID;
  }
  if (!Util.isUnset(request.oldProductVersionUID)) {
    query['oldProductVersionUID'] = request.oldProductVersionUID;
  }
  if (!Util.isUnset(request.packageContentType)) {
    query['packageContentType'] = request.packageContentType;
  }
  if (!Util.isUnset(request.packageType)) {
    query['packageType'] = request.packageType;
  }
  if (!Util.isUnset(request.packageUID)) {
    query['packageUID'] = request.packageUID;
  }
  if (!Util.isUnset(request.platform)) {
    query['platform'] = request.platform;
  }
  if (!Util.isUnset(request.withURL)) {
    query['withURL'] = request.withURL;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProductVersionPackage',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/hosting/product-versions/${OpenApiUtil.getEncodeParam(uid)}/packages`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetResourceSnapshotRequest {
  productVersionUID?: string(name='productVersionUID'),
  uid?: string(name='uid'),
}

model GetResourceSnapshotResponseBody = {
  CPULimit?: string(name='CPULimit'),
  CPURequest?: string(name='CPURequest'),
  adpInfo?: {
    CPURequest?: string(name='CPURequest'),
    componentNum?: int32(name='componentNum'),
    components?: [ 
      {
        CPULimit?: string(name='CPULimit'),
        CPURequest?: string(name='CPURequest'),
        componentName?: string(name='componentName'),
        componentReleaseName?: string(name='componentReleaseName'),
        componentVersion?: string(name='componentVersion'),
        memoryLimit?: string(name='memoryLimit'),
        memoryRequest?: string(name='memoryRequest'),
        orchestrationValue?: string(name='orchestrationValue'),
        status?: string(name='status'),
        storageRequest?: string(name='storageRequest'),
      }
    ](name='components'),
    memoryRequest?: string(name='memoryRequest'),
    podNum?: int32(name='podNum'),
    storageRequest?: string(name='storageRequest'),
    workloadNum?: int32(name='workloadNum'),
  }(name='adpInfo'),
  memoryLimit?: string(name='memoryLimit'),
  memoryRequest?: string(name='memoryRequest'),
  productInfo?: {
    CPURequest?: string(name='CPURequest'),
    componentNum?: int32(name='componentNum'),
    components?: [ 
      {
        CPULimit?: string(name='CPULimit'),
        CPURequest?: string(name='CPURequest'),
        componentName?: string(name='componentName'),
        componentReleaseName?: string(name='componentReleaseName'),
        componentVersion?: string(name='componentVersion'),
        memoryLimit?: string(name='memoryLimit'),
        memoryRequest?: string(name='memoryRequest'),
        orchestrationValue?: string(name='orchestrationValue'),
        status?: string(name='status'),
        storageRequest?: string(name='storageRequest'),
      }
    ](name='components'),
    memoryRequest?: string(name='memoryRequest'),
    podNum?: int32(name='podNum'),
    storageRequest?: string(name='storageRequest'),
    workloadNum?: int32(name='workloadNum'),
  }(name='productInfo'),
  specParamConfigs?: [ 
    {
      componentName?: string(name='componentName'),
      componentReleaseName?: string(name='componentReleaseName'),
      componentSource?: string(name='componentSource'),
      componentVersion?: string(name='componentVersion'),
      name?: string(name='name'),
      paramType?: string(name='paramType'),
      parentComponentName?: string(name='parentComponentName'),
      parentComponentReleaseName?: string(name='parentComponentReleaseName'),
      parentComponentVersion?: string(name='parentComponentVersion'),
      value?: string(name='value'),
      valueType?: string(name='valueType'),
    }
  ](name='specParamConfigs'),
  storageRequest?: string(name='storageRequest'),
}

model GetResourceSnapshotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceSnapshotResponseBody(name='body'),
}

async function getResourceSnapshot(request: GetResourceSnapshotRequest): GetResourceSnapshotResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getResourceSnapshotWithOptions(request, headers, runtime);
}

async function getResourceSnapshotWithOptions(request: GetResourceSnapshotRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetResourceSnapshotResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.productVersionUID)) {
    query['productVersionUID'] = request.productVersionUID;
  }
  if (!Util.isUnset(request.uid)) {
    query['uid'] = request.uid;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResourceSnapshot',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/resource-snapshots`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetWorkflowStatusRequest {
  workflowType?: string(name='workflowType'),
  xuid?: string(name='xuid'),
}

model GetWorkflowStatusResponseBody = {
  code?: string(name='code'),
  data?: {
    status?: string(name='status'),
    stepStatus?: [ 
      {
        name?: string(name='name'),
        status?: string(name='status'),
        workflowTasks?: [ 
          {
            name?: string(name='name'),
            status?: string(name='status'),
          }
        ](name='workflowTasks'),
      }
    ](name='stepStatus'),
  }(name='data'),
  msg?: string(name='msg'),
}

model GetWorkflowStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetWorkflowStatusResponseBody(name='body'),
}

async function getWorkflowStatus(request: GetWorkflowStatusRequest): GetWorkflowStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getWorkflowStatusWithOptions(request, headers, runtime);
}

async function getWorkflowStatusWithOptions(request: GetWorkflowStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetWorkflowStatusResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.workflowType)) {
    query['workflowType'] = request.workflowType;
  }
  if (!Util.isUnset(request.xuid)) {
    query['xuid'] = request.xuid;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetWorkflowStatus',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/workflows/status`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model InitEnvironmentResourceRequest {
  accessKeyID?: string(name='accessKeyID'),
  accessKeySecret?: string(name='accessKeySecret'),
  securityToken?: string(name='securityToken'),
}

model InitEnvironmentResourceResponseBody = {
  code?: string(name='code'),
  data?: {
    status?: string(name='status'),
  }(name='data'),
  msg?: string(name='msg'),
}

model InitEnvironmentResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InitEnvironmentResourceResponseBody(name='body'),
}

async function initEnvironmentResource(uid: string, request: InitEnvironmentResourceRequest): InitEnvironmentResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return initEnvironmentResourceWithOptions(uid, request, headers, runtime);
}

async function initEnvironmentResourceWithOptions(uid: string, request: InitEnvironmentResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InitEnvironmentResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accessKeyID)) {
    body['accessKeyID'] = request.accessKeyID;
  }
  if (!Util.isUnset(request.accessKeySecret)) {
    body['accessKeySecret'] = request.accessKeySecret;
  }
  if (!Util.isUnset(request.securityToken)) {
    body['securityToken'] = request.securityToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'InitEnvironmentResource',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${OpenApiUtil.getEncodeParam(uid)}/resources`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListComponentVersionsRequest {
  pageNum?: int32(name='pageNum'),
  pageSize?: int32(name='pageSize'),
  platforms?: [ 
    {
      architecture?: string(name='architecture'),
      os?: string(name='os'),
    }
  ](name='platforms'),
}

model ListComponentVersionsShrinkRequest {
  pageNum?: int32(name='pageNum'),
  pageSize?: int32(name='pageSize'),
  platformsShrink?: string(name='platforms'),
}

model ListComponentVersionsResponseBody = {
  requestId?: string(name='RequestId'),
  code?: string(name='code'),
  data?: {
    list?: [ 
      {
        appVersion?: string(name='appVersion'),
        componentName?: string(name='componentName'),
        componentUID?: string(name='componentUID'),
        description?: string(name='description'),
        documents?: string(name='documents'),
        imagesMapping?: string(name='imagesMapping'),
        orchestrationValues?: string(name='orchestrationValues'),
        packageURL?: string(name='packageURL'),
        parentComponent?: boolean(name='parentComponent'),
        readme?: string(name='readme'),
        resources?: string(name='resources'),
        uid?: string(name='uid'),
        version?: string(name='version'),
      }
    ](name='list'),
    pageNum?: int32(name='pageNum'),
    pageSize?: int32(name='pageSize'),
    total?: int32(name='total'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListComponentVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListComponentVersionsResponseBody(name='body'),
}

async function listComponentVersions(uid: string, request: ListComponentVersionsRequest): ListComponentVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listComponentVersionsWithOptions(uid, request, headers, runtime);
}

async function listComponentVersionsWithOptions(uid: string, tmpReq: ListComponentVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListComponentVersionsResponse {
  Util.validateModel(tmpReq);
  var request = new ListComponentVersionsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.platforms)) {
    request.platformsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.platforms, 'platforms', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.platformsShrink)) {
    query['platforms'] = request.platformsShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListComponentVersions',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/components/${OpenApiUtil.getEncodeParam(uid)}/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListComponentsRequest {
  category?: string(name='category'),
  fuzzy?: string(name='fuzzy'),
  name?: string(name='name'),
  pageNum?: int32(name='pageNum'),
  pageSize?: int32(name='pageSize'),
  public?: boolean(name='public'),
}

model ListComponentsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [ 
      {
        annotations?: {
          annotations?: string(name='annotations'),
        }(name='annotations'),
        category?: string(name='category'),
        description?: string(name='description'),
        documents?: string(name='documents'),
        name?: string(name='name'),
        provider?: string(name='provider'),
        public?: boolean(name='public'),
        singleton?: boolean(name='singleton'),
        source?: string(name='source'),
        uid?: string(name='uid'),
      }
    ](name='list'),
    pageNum?: int32(name='pageNum'),
    pageSize?: int32(name='pageSize'),
    total?: int32(name='total'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListComponentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListComponentsResponseBody(name='body'),
}

async function listComponents(request: ListComponentsRequest): ListComponentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listComponentsWithOptions(request, headers, runtime);
}

async function listComponentsWithOptions(request: ListComponentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListComponentsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.category)) {
    query['category'] = request.category;
  }
  if (!Util.isUnset(request.fuzzy)) {
    query['fuzzy'] = request.fuzzy;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.public)) {
    query['public'] = request.public;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListComponents',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/components`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDeliveryInstanceChangeRecordsResponseBody = {
  code?: string(name='code'),
  data?: [ 
    {
      deliverableUID?: string(name='deliverableUID'),
      envChangeRecords?: map[string]any(name='envChangeRecords'),
      envNodeInfo?: [ 
        {
          capacity?: string(name='capacity'),
          cpu?: string(name='cpu'),
          identifier?: string(name='identifier'),
          label?: map[string]any(name='label'),
          memory?: string(name='memory'),
          name?: string(name='name'),
          privateIP?: string(name='privateIP'),
          taints?: map[string]any(name='taints'),
        }
      ](name='envNodeInfo'),
      envPackageConfig?: string(name='envPackageConfig'),
      originDeliverableUID?: string(name='originDeliverableUID'),
      uid?: string(name='uid'),
    }
  ](name='data'),
  msg?: string(name='msg'),
}

model ListDeliveryInstanceChangeRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeliveryInstanceChangeRecordsResponseBody(name='body'),
}

async function listDeliveryInstanceChangeRecords(uid: string): ListDeliveryInstanceChangeRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDeliveryInstanceChangeRecordsWithOptions(uid, headers, runtime);
}

async function listDeliveryInstanceChangeRecordsWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListDeliveryInstanceChangeRecordsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListDeliveryInstanceChangeRecords',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/delivery/delivery-instances/${OpenApiUtil.getEncodeParam(uid)}/delivery-records`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDeliveryPackageRequest {
  deliverableUID?: string(name='deliverableUID'),
}

model ListDeliveryPackageResponseBody = {
  code?: string(name='code'),
  data?: [ 
    {
      deliverableUID?: string(name='deliverableUID'),
      originDeliverableUID?: string(name='originDeliverableUID'),
      packageContentType?: string(name='packageContentType'),
      packageSize?: string(name='packageSize'),
      packageStatus?: string(name='packageStatus'),
      packageType?: string(name='packageType'),
      packageUID?: string(name='packageUID'),
      packageURL?: string(name='packageURL'),
      platform?: string(name='platform'),
    }
  ](name='data'),
  msg?: string(name='msg'),
}

model ListDeliveryPackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeliveryPackageResponseBody(name='body'),
}

async function listDeliveryPackage(request: ListDeliveryPackageRequest): ListDeliveryPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDeliveryPackageWithOptions(request, headers, runtime);
}

async function listDeliveryPackageWithOptions(request: ListDeliveryPackageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDeliveryPackageResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.deliverableUID)) {
    query['deliverableUID'] = request.deliverableUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDeliveryPackage',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/delivery/delivery-packages`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListEnvironmentLicensesRequest {
  pageNum?: int32(name='pageNum'),
  pageSize?: int32(name='pageSize'),
  scope?: string(name='scope'),
  type?: string(name='type'),
}

model ListEnvironmentLicensesResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [ 
      {
        expireTime?: string(name='expireTime'),
        licenseKey?: string(name='licenseKey'),
        licenseQuota?: {
          clusterQuota?: {
            cpuCoreLimit?: int32(name='cpuCoreLimit'),
          }(name='clusterQuota'),
          componentQuotas?: [ 
            {
              componentName?: string(name='componentName'),
              componentSource?: string(name='componentSource'),
              instanceLimit?: int32(name='instanceLimit'),
            }
          ](name='componentQuotas'),
          customQuotas?: [ 
            {
              description?: string(name='description'),
              key?: string(name='key'),
              value?: string(name='value'),
            }
          ](name='customQuotas'),
        }(name='licenseQuota'),
        productVersionUID?: string(name='productVersionUID'),
        rejectReason?: string(name='rejectReason'),
        scope?: string(name='scope'),
        status?: string(name='status'),
        type?: string(name='type'),
        uid?: string(name='uid'),
      }
    ](name='list'),
    pageNum?: int32(name='pageNum'),
    pageSize?: int32(name='pageSize'),
    total?: int32(name='total'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListEnvironmentLicensesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEnvironmentLicensesResponseBody(name='body'),
}

async function listEnvironmentLicenses(uid: string, request: ListEnvironmentLicensesRequest): ListEnvironmentLicensesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEnvironmentLicensesWithOptions(uid, request, headers, runtime);
}

async function listEnvironmentLicensesWithOptions(uid: string, request: ListEnvironmentLicensesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListEnvironmentLicensesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.scope)) {
    query['scope'] = request.scope;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEnvironmentLicenses',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${OpenApiUtil.getEncodeParam(uid)}/licenses`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListEnvironmentNodesRequest {
  pageNum?: int32(name='pageNum'),
  pageSize?: int32(name='pageSize'),
}

model ListEnvironmentNodesResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [
      InstanceInfo
    ](name='list'),
    pageNum?: long(name='pageNum'),
    pageSize?: long(name='pageSize'),
    total?: long(name='total'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListEnvironmentNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEnvironmentNodesResponseBody(name='body'),
}

async function listEnvironmentNodes(uid: string, request: ListEnvironmentNodesRequest): ListEnvironmentNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEnvironmentNodesWithOptions(uid, request, headers, runtime);
}

async function listEnvironmentNodesWithOptions(uid: string, request: ListEnvironmentNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListEnvironmentNodesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEnvironmentNodes',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${OpenApiUtil.getEncodeParam(uid)}/nodes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListEnvironmentTunnelsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [ 
      {
        tunnelConfig?: {
          hostname?: string(name='hostname'),
          password?: string(name='password'),
          regionId?: string(name='regionId'),
          sshPort?: int32(name='sshPort'),
          username?: string(name='username'),
          vpcId?: string(name='vpcId'),
        }(name='tunnelConfig'),
        tunnelType?: string(name='tunnelType'),
      }
    ](name='list'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListEnvironmentTunnelsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEnvironmentTunnelsResponseBody(name='body'),
}

async function listEnvironmentTunnels(uid: string): ListEnvironmentTunnelsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEnvironmentTunnelsWithOptions(uid, headers, runtime);
}

async function listEnvironmentTunnelsWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListEnvironmentTunnelsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListEnvironmentTunnels',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${OpenApiUtil.getEncodeParam(uid)}/tunnels`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListEnvironmentsRequest {
  clusterUID?: string(name='clusterUID'),
  foundationType?: string(name='foundationType'),
  fuzzy?: string(name='fuzzy'),
  instanceStatus?: string(name='instanceStatus'),
  name?: string(name='name'),
  pageNum?: int32(name='pageNum'),
  pageSize?: int32(name='pageSize'),
  type?: string(name='type'),
  vendorType?: string(name='vendorType'),
}

model ListEnvironmentsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [ 
      {
        createdAt?: string(name='createdAt'),
        description?: string(name='description'),
        location?: string(name='location'),
        name?: string(name='name'),
        platform?: {
          architecture?: string(name='architecture'),
          os?: string(name='os'),
        }(name='platform'),
        platformList?: [
          Platform
        ](name='platformList'),
        productName?: string(name='productName'),
        productVersion?: string(name='productVersion'),
        productVersionUID?: string(name='productVersionUID'),
        uid?: string(name='uid'),
        vendorType?: string(name='vendorType'),
      }
    ](name='list'),
    pageNum?: int32(name='pageNum'),
    pageSize?: int32(name='pageSize'),
    total?: int32(name='total'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListEnvironmentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEnvironmentsResponseBody(name='body'),
}

async function listEnvironments(request: ListEnvironmentsRequest): ListEnvironmentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEnvironmentsWithOptions(request, headers, runtime);
}

async function listEnvironmentsWithOptions(request: ListEnvironmentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListEnvironmentsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterUID)) {
    query['clusterUID'] = request.clusterUID;
  }
  if (!Util.isUnset(request.foundationType)) {
    query['foundationType'] = request.foundationType;
  }
  if (!Util.isUnset(request.fuzzy)) {
    query['fuzzy'] = request.fuzzy;
  }
  if (!Util.isUnset(request.instanceStatus)) {
    query['instanceStatus'] = request.instanceStatus;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }
  if (!Util.isUnset(request.vendorType)) {
    query['vendorType'] = request.vendorType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEnvironments',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListFoundationComponentVersionsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [
      ComponentVersion
    ](name='list'),
    pageNum?: int32(name='pageNum'),
    pageSize?: int32(name='pageSize'),
    total?: int32(name='total'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListFoundationComponentVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFoundationComponentVersionsResponseBody(name='body'),
}

async function listFoundationComponentVersions(uid: string): ListFoundationComponentVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFoundationComponentVersionsWithOptions(uid, headers, runtime);
}

async function listFoundationComponentVersionsWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListFoundationComponentVersionsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListFoundationComponentVersions',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/foundation/versions/${OpenApiUtil.getEncodeParam(uid)}/component-versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListFoundationReferenceComponentsRequest {
  foundationReferenceUID?: string(name='foundationReferenceUID'),
  foundationVersionUID?: string(name='foundationVersionUID'),
  onlyEnabled?: boolean(name='onlyEnabled'),
  productVersionUID?: string(name='productVersionUID'),
}

model ListFoundationReferenceComponentsResponseBody = {
  code?: string(name='code'),
  data?: [
    ProductComponentRelationDetail
  ](name='data'),
  msg?: string(name='msg'),
}

model ListFoundationReferenceComponentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFoundationReferenceComponentsResponseBody(name='body'),
}

async function listFoundationReferenceComponents(request: ListFoundationReferenceComponentsRequest): ListFoundationReferenceComponentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFoundationReferenceComponentsWithOptions(request, headers, runtime);
}

async function listFoundationReferenceComponentsWithOptions(request: ListFoundationReferenceComponentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFoundationReferenceComponentsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.foundationReferenceUID)) {
    query['foundationReferenceUID'] = request.foundationReferenceUID;
  }
  if (!Util.isUnset(request.foundationVersionUID)) {
    query['foundationVersionUID'] = request.foundationVersionUID;
  }
  if (!Util.isUnset(request.onlyEnabled)) {
    query['onlyEnabled'] = request.onlyEnabled;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    query['productVersionUID'] = request.productVersionUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFoundationReferenceComponents',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/foundation-references/component-versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListFoundationVersionsRequest {
  sortDirect?: string(name='sortDirect'),
  sortKey?: string(name='sortKey'),
  type?: string(name='type'),
}

model ListFoundationVersionsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [
      FoundationVersion
    ](name='list'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListFoundationVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFoundationVersionsResponseBody(name='body'),
}

async function listFoundationVersions(request: ListFoundationVersionsRequest): ListFoundationVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFoundationVersionsWithOptions(request, headers, runtime);
}

async function listFoundationVersionsWithOptions(request: ListFoundationVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFoundationVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.sortDirect)) {
    query['sortDirect'] = request.sortDirect;
  }
  if (!Util.isUnset(request.sortKey)) {
    query['sortKey'] = request.sortKey;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFoundationVersions',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/foundation/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProductComponentVersionsRequest {
  category?: string(name='category'),
  pageNum?: string(name='pageNum'),
  pageSize?: string(name='pageSize'),
  sortDirect?: string(name='sortDirect'),
  sortKey?: string(name='sortKey'),
}

model ListProductComponentVersionsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [
      ProductComponentRelationDetail
    ](name='list'),
    pageNum?: long(name='pageNum'),
    pageSize?: long(name='pageSize'),
    total?: long(name='total'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListProductComponentVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProductComponentVersionsResponseBody(name='body'),
}

async function listProductComponentVersions(uid: string, request: ListProductComponentVersionsRequest): ListProductComponentVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProductComponentVersionsWithOptions(uid, request, headers, runtime);
}

async function listProductComponentVersionsWithOptions(uid: string, request: ListProductComponentVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProductComponentVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.category)) {
    query['category'] = request.category;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortDirect)) {
    query['sortDirect'] = request.sortDirect;
  }
  if (!Util.isUnset(request.sortKey)) {
    query['sortKey'] = request.sortKey;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProductComponentVersions',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${OpenApiUtil.getEncodeParam(uid)}/component-versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProductDeploymentsRequest {
  environmentUID?: string(name='environmentUID'),
  pageNum?: int32(name='pageNum'),
  pageSize?: int32(name='pageSize'),
  productVersionUID?: string(name='productVersionUID'),
}

model ListProductDeploymentsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [ 
      {
        envParams?: string(name='envParams'),
        envUID?: string(name='envUID'),
        oldProductVersion?: string(name='oldProductVersion'),
        packageContentType?: string(name='packageContentType'),
        packageInfoUID?: string(name='packageInfoUID'),
        packageType?: string(name='packageType'),
        productName?: string(name='productName'),
        productVersion?: string(name='productVersion'),
        status?: string(name='status'),
        uid?: string(name='uid'),
      }
    ](name='list'),
    pageNum?: int32(name='pageNum'),
    pageSize?: int32(name='pageSize'),
    total?: int32(name='total'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListProductDeploymentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProductDeploymentsResponseBody(name='body'),
}

async function listProductDeployments(request: ListProductDeploymentsRequest): ListProductDeploymentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProductDeploymentsWithOptions(request, headers, runtime);
}

async function listProductDeploymentsWithOptions(request: ListProductDeploymentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProductDeploymentsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.environmentUID)) {
    query['environmentUID'] = request.environmentUID;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    query['productVersionUID'] = request.productVersionUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProductDeployments',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-instances/deployments`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProductEnvironmentsRequest {
  compatibleProductVersionUID?: string(name='compatibleProductVersionUID'),
  envType?: string(name='envType'),
  options?: {
    filterWithSpecUID?: boolean(name='filterWithSpecUID'),
    specUID?: string(name='specUID'),
  }(name='options'),
  platforms?: [ 
    {
      architecture?: string(name='architecture'),
      os?: string(name='os'),
    }
  ](name='platforms'),
  productVersionSpecUID?: string(name='productVersionSpecUID'),
  productVersionUID?: string(name='productVersionUID'),
}

model ListProductEnvironmentsShrinkRequest {
  compatibleProductVersionUID?: string(name='compatibleProductVersionUID'),
  envType?: string(name='envType'),
  optionsShrink?: string(name='options'),
  platformsShrink?: string(name='platforms'),
  productVersionSpecUID?: string(name='productVersionSpecUID'),
  productVersionUID?: string(name='productVersionUID'),
}

model ListProductEnvironmentsResponseBody = {
  code?: string(name='code'),
  data?: [ 
    {
      envName?: string(name='envName'),
      envType?: string(name='envType'),
      envUID?: string(name='envUID'),
      instanceStatus?: string(name='instanceStatus'),
      oldProductVersion?: string(name='oldProductVersion'),
      oldProductVersionUID?: string(name='oldProductVersionUID'),
      platformStatus?: string(name='platformStatus'),
      productName?: string(name='productName'),
      productUID?: string(name='productUID'),
      productVersion?: string(name='productVersion'),
      productVersionUID?: string(name='productVersionUID'),
      provider?: string(name='provider'),
      uid?: string(name='uid'),
      vendorConfig?: string(name='vendorConfig'),
      vendorType?: string(name='vendorType'),
    }
  ](name='data'),
  msg?: string(name='msg'),
}

model ListProductEnvironmentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProductEnvironmentsResponseBody(name='body'),
}

async function listProductEnvironments(uid: string, request: ListProductEnvironmentsRequest): ListProductEnvironmentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProductEnvironmentsWithOptions(uid, request, headers, runtime);
}

async function listProductEnvironmentsWithOptions(uid: string, tmpReq: ListProductEnvironmentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProductEnvironmentsResponse {
  Util.validateModel(tmpReq);
  var request = new ListProductEnvironmentsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.options)) {
    request.optionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.options, 'options', 'json');
  }
  if (!Util.isUnset(tmpReq.platforms)) {
    request.platformsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.platforms, 'platforms', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.compatibleProductVersionUID)) {
    query['compatibleProductVersionUID'] = request.compatibleProductVersionUID;
  }
  if (!Util.isUnset(request.envType)) {
    query['envType'] = request.envType;
  }
  if (!Util.isUnset(request.optionsShrink)) {
    query['options'] = request.optionsShrink;
  }
  if (!Util.isUnset(request.platformsShrink)) {
    query['platforms'] = request.platformsShrink;
  }
  if (!Util.isUnset(request.productVersionSpecUID)) {
    query['productVersionSpecUID'] = request.productVersionSpecUID;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    query['productVersionUID'] = request.productVersionUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProductEnvironments',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/hosting/products/${OpenApiUtil.getEncodeParam(uid)}/environments`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProductFoundationReferencesResponseBody = {
  code?: string(name='code'),
  data?: [ 
    {
      foundationReferenceUID?: string(name='foundationReferenceUID'),
      foundationVersion?: string(name='foundationVersion'),
      foundationVersionName?: string(name='foundationVersionName'),
      foundationVersionType?: string(name='foundationVersionType'),
      foundationVersionUID?: string(name='foundationVersionUID'),
      productVersionUID?: string(name='productVersionUID'),
    }
  ](name='data'),
  msg?: string(name='msg'),
}

model ListProductFoundationReferencesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProductFoundationReferencesResponseBody(name='body'),
}

async function listProductFoundationReferences(uid: string): ListProductFoundationReferencesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProductFoundationReferencesWithOptions(uid, headers, runtime);
}

async function listProductFoundationReferencesWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListProductFoundationReferencesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListProductFoundationReferences',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${OpenApiUtil.getEncodeParam(uid)}/foundation-references`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProductInstanceConfigsRequest {
  environmentUID?: string(name='environmentUID'),
  pageNum?: int32(name='pageNum'),
  pageSize?: int32(name='pageSize'),
  paramType?: string(name='paramType'),
  productVersionUID?: string(name='productVersionUID'),
}

model ListProductInstanceConfigsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [ 
      {
        componentName?: string(name='componentName'),
        componentReleaseName?: string(name='componentReleaseName'),
        componentUID?: string(name='componentUID'),
        componentVersionUID?: string(name='componentVersionUID'),
        createdAt?: string(name='createdAt'),
        description?: string(name='description'),
        envUID?: string(name='envUID'),
        name?: string(name='name'),
        parentComponentName?: string(name='parentComponentName'),
        parentComponentReleaseName?: string(name='parentComponentReleaseName'),
        parentComponentVersionUID?: string(name='parentComponentVersionUID'),
        productName?: string(name='productName'),
        productVersion?: string(name='productVersion'),
        productVersionUID?: string(name='productVersionUID'),
        uid?: string(name='uid'),
        value?: string(name='value'),
        valueType?: string(name='valueType'),
        vendorType?: string(name='vendorType'),
      }
    ](name='list'),
    pageNum?: int32(name='pageNum'),
    pageSize?: int32(name='pageSize'),
    total?: int32(name='total'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListProductInstanceConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProductInstanceConfigsResponseBody(name='body'),
}

async function listProductInstanceConfigs(request: ListProductInstanceConfigsRequest): ListProductInstanceConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProductInstanceConfigsWithOptions(request, headers, runtime);
}

async function listProductInstanceConfigsWithOptions(request: ListProductInstanceConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProductInstanceConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.environmentUID)) {
    query['environmentUID'] = request.environmentUID;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.paramType)) {
    query['paramType'] = request.paramType;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    query['productVersionUID'] = request.productVersionUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProductInstanceConfigs',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-instances/configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProductInstancesRequest {
  envUID?: string(name='envUID'),
  options?: {
    filterWithSpecUID?: boolean(name='filterWithSpecUID'),
    specUID?: string(name='specUID'),
  }(name='options'),
  pageNum?: string(name='pageNum'),
  pageSize?: string(name='pageSize'),
  productVersionUID?: string(name='productVersionUID'),
}

model ListProductInstancesShrinkRequest {
  envUID?: string(name='envUID'),
  optionsShrink?: string(name='options'),
  pageNum?: string(name='pageNum'),
  pageSize?: string(name='pageSize'),
  productVersionUID?: string(name='productVersionUID'),
}

model ListProductInstancesResponseBody = {
  data?: {
    list?: [ 
      {
        continuousDeployment?: boolean(name='continuousDeployment'),
        productName?: string(name='productName'),
        productVersion?: string(name='productVersion'),
        productVersionUID?: string(name='productVersionUID'),
        status?: string(name='status'),
        uid?: string(name='uid'),
      }
    ](name='list'),
  }(name='data'),
}

model ListProductInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProductInstancesResponseBody(name='body'),
}

async function listProductInstances(request: ListProductInstancesRequest): ListProductInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProductInstancesWithOptions(request, headers, runtime);
}

async function listProductInstancesWithOptions(tmpReq: ListProductInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProductInstancesResponse {
  Util.validateModel(tmpReq);
  var request = new ListProductInstancesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.options)) {
    request.optionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.options, 'options', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.envUID)) {
    query['envUID'] = request.envUID;
  }
  if (!Util.isUnset(request.optionsShrink)) {
    query['options'] = request.optionsShrink;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    query['productVersionUID'] = request.productVersionUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProductInstances',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProductVersionConfigsRequest {
  configType?: string(name='configType'),
  pageNum?: string(name='pageNum'),
  pageSize?: string(name='pageSize'),
  parameter?: string(name='parameter'),
  scope?: string(name='scope'),
}

model ListProductVersionConfigsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [ 
      {
        componentName?: string(name='componentName'),
        componentReleaseName?: string(name='componentReleaseName'),
        componentVersionUID?: string(name='componentVersionUID'),
        description?: string(name='description'),
        name?: string(name='name'),
        parentComponentName?: string(name='parentComponentName'),
        parentComponentReleaseName?: string(name='parentComponentReleaseName'),
        parentComponentVersionUID?: string(name='parentComponentVersionUID'),
        productVersionUID?: string(name='productVersionUID'),
        uid?: string(name='uid'),
        value?: string(name='value'),
      }
    ](name='list'),
    pageNum?: int32(name='pageNum'),
    pageSize?: int32(name='pageSize'),
    total?: int32(name='total'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListProductVersionConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProductVersionConfigsResponseBody(name='body'),
}

async function listProductVersionConfigs(uid: string, request: ListProductVersionConfigsRequest): ListProductVersionConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProductVersionConfigsWithOptions(uid, request, headers, runtime);
}

async function listProductVersionConfigsWithOptions(uid: string, request: ListProductVersionConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProductVersionConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.configType)) {
    query['configType'] = request.configType;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.parameter)) {
    query['parameter'] = request.parameter;
  }
  if (!Util.isUnset(request.scope)) {
    query['scope'] = request.scope;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProductVersionConfigs',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${OpenApiUtil.getEncodeParam(uid)}/configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProductVersionsRequest {
  pageNum?: string(name='pageNum'),
  pageSize?: string(name='pageSize'),
  platforms?: [ 
    {
      architecture?: string(name='architecture'),
      os?: string(name='os'),
    }
  ](name='platforms'),
  productName?: string(name='productName'),
  productUID?: string(name='productUID'),
  released?: boolean(name='released'),
  supportedFoundationTypes?: [ string ](name='supportedFoundationTypes'),
  version?: string(name='version'),
}

model ListProductVersionsShrinkRequest {
  pageNum?: string(name='pageNum'),
  pageSize?: string(name='pageSize'),
  platformsShrink?: string(name='platforms'),
  productName?: string(name='productName'),
  productUID?: string(name='productUID'),
  released?: boolean(name='released'),
  supportedFoundationTypesShrink?: string(name='supportedFoundationTypes'),
  version?: string(name='version'),
}

model ListProductVersionsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [ 
      {
        annotations?: {
          additionalProp1?: string(name='additionalProp1'),
          additionalProp2?: string(name='additionalProp2'),
          additionalProp3?: string(name='additionalProp3'),
        }(name='annotations'),
        description?: string(name='description'),
        packageURL?: string(name='packageURL'),
        productName?: string(name='productName'),
        productUID?: string(name='productUID'),
        provider?: string(name='provider'),
        uid?: string(name='uid'),
        version?: string(name='version'),
      }
    ](name='list'),
    pageNum?: int32(name='pageNum'),
    pageSize?: int32(name='pageSize'),
    total?: int32(name='total'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListProductVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProductVersionsResponseBody(name='body'),
}

async function listProductVersions(request: ListProductVersionsRequest): ListProductVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProductVersionsWithOptions(request, headers, runtime);
}

async function listProductVersionsWithOptions(tmpReq: ListProductVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProductVersionsResponse {
  Util.validateModel(tmpReq);
  var request = new ListProductVersionsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.platforms)) {
    request.platformsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.platforms, 'platforms', 'json');
  }
  if (!Util.isUnset(tmpReq.supportedFoundationTypes)) {
    request.supportedFoundationTypesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.supportedFoundationTypes, 'supportedFoundationTypes', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.platformsShrink)) {
    query['platforms'] = request.platformsShrink;
  }
  if (!Util.isUnset(request.productName)) {
    query['productName'] = request.productName;
  }
  if (!Util.isUnset(request.productUID)) {
    query['productUID'] = request.productUID;
  }
  if (!Util.isUnset(request.released)) {
    query['released'] = request.released;
  }
  if (!Util.isUnset(request.supportedFoundationTypesShrink)) {
    query['supportedFoundationTypes'] = request.supportedFoundationTypesShrink;
  }
  if (!Util.isUnset(request.version)) {
    query['version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProductVersions',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProductsRequest {
  fuzzy?: string(name='fuzzy'),
  name?: string(name='name'),
  pageNum?: int32(name='pageNum'),
  pageSize?: int32(name='pageSize'),
}

model ListProductsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [ 
      {
        description?: string(name='description'),
        name?: string(name='name'),
        uid?: string(name='uid'),
      }
    ](name='list'),
    pageNum?: int32(name='pageNum'),
    pageSize?: int32(name='pageSize'),
    total?: int32(name='total'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListProductsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProductsResponseBody(name='body'),
}

async function listProducts(request: ListProductsRequest): ListProductsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProductsWithOptions(request, headers, runtime);
}

async function listProductsWithOptions(request: ListProductsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProductsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.fuzzy)) {
    query['fuzzy'] = request.fuzzy;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProducts',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/products`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListWorkflowTaskLogsRequest {
  filterValues?: [ string ](name='filterValues'),
  orderType?: string(name='orderType'),
  pageNum?: long(name='pageNum'),
  pageSize?: long(name='pageSize'),
  workflowType?: string(name='workflowType'),
  xuid?: string(name='xuid'),
}

model ListWorkflowTaskLogsShrinkRequest {
  filterValuesShrink?: string(name='filterValues'),
  orderType?: string(name='orderType'),
  pageNum?: long(name='pageNum'),
  pageSize?: long(name='pageSize'),
  workflowType?: string(name='workflowType'),
  xuid?: string(name='xuid'),
}

model ListWorkflowTaskLogsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [ string ](name='list'),
    pageNum?: long(name='pageNum'),
    pageSize?: long(name='pageSize'),
    total?: long(name='total'),
  }(name='data'),
  msg?: string(name='msg'),
}

model ListWorkflowTaskLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListWorkflowTaskLogsResponseBody(name='body'),
}

async function listWorkflowTaskLogs(stepName: string, taskName: string, request: ListWorkflowTaskLogsRequest): ListWorkflowTaskLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listWorkflowTaskLogsWithOptions(stepName, taskName, request, headers, runtime);
}

async function listWorkflowTaskLogsWithOptions(stepName: string, taskName: string, tmpReq: ListWorkflowTaskLogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListWorkflowTaskLogsResponse {
  Util.validateModel(tmpReq);
  var request = new ListWorkflowTaskLogsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.filterValues)) {
    request.filterValuesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterValues, 'filterValues', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.filterValuesShrink)) {
    query['filterValues'] = request.filterValuesShrink;
  }
  if (!Util.isUnset(request.orderType)) {
    query['orderType'] = request.orderType;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.workflowType)) {
    query['workflowType'] = request.workflowType;
  }
  if (!Util.isUnset(request.xuid)) {
    query['xuid'] = request.xuid;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListWorkflowTaskLogs',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/workflows/steps/${OpenApiUtil.getEncodeParam(stepName)}/tasks/${OpenApiUtil.getEncodeParam(taskName)}/logs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PutEnvironmentTunnelRequest {
  tunnelConfig?: {
    hostname?: string(name='hostname'),
    password?: string(name='password'),
    regionId?: string(name='regionId'),
    sshPort?: int32(name='sshPort'),
    username?: string(name='username'),
    vpcId?: string(name='vpcId'),
  }(name='tunnelConfig'),
  tunnelType?: string(name='tunnelType'),
}

model PutEnvironmentTunnelResponseBody = {
  code?: string(name='code'),
  data?: {
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model PutEnvironmentTunnelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutEnvironmentTunnelResponseBody(name='body'),
}

async function putEnvironmentTunnel(uid: string, request: PutEnvironmentTunnelRequest): PutEnvironmentTunnelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putEnvironmentTunnelWithOptions(uid, request, headers, runtime);
}

async function putEnvironmentTunnelWithOptions(uid: string, request: PutEnvironmentTunnelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutEnvironmentTunnelResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.tunnelConfig)) {
    body['tunnelConfig'] = request.tunnelConfig;
  }
  if (!Util.isUnset(request.tunnelType)) {
    body['tunnelType'] = request.tunnelType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutEnvironmentTunnel',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${OpenApiUtil.getEncodeParam(uid)}/tunnels`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PutProductInstanceConfigRequest {
  componentUID?: string(name='componentUID'),
  componentVersionUID?: string(name='componentVersionUID'),
  configUID?: string(name='configUID'),
  description?: string(name='description'),
  environmentUID?: string(name='environmentUID'),
  name?: string(name='name'),
  parentComponentName?: string(name='parentComponentName'),
  parentComponentVersionUID?: string(name='parentComponentVersionUID'),
  productVersionUID?: string(name='productVersionUID'),
  releaseName?: string(name='releaseName'),
  scope?: [ string ](name='scope'),
  value?: string(name='value'),
  valueType?: string(name='valueType'),
}

model PutProductInstanceConfigResponseBody = {
  code?: string(name='code'),
  data?: {
    uid?: string(name='uid'),
  }(name='data'),
  msg?: string(name='msg'),
}

model PutProductInstanceConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutProductInstanceConfigResponseBody(name='body'),
}

async function putProductInstanceConfig(request: PutProductInstanceConfigRequest): PutProductInstanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putProductInstanceConfigWithOptions(request, headers, runtime);
}

async function putProductInstanceConfigWithOptions(request: PutProductInstanceConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutProductInstanceConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.componentUID)) {
    body['componentUID'] = request.componentUID;
  }
  if (!Util.isUnset(request.componentVersionUID)) {
    body['componentVersionUID'] = request.componentVersionUID;
  }
  if (!Util.isUnset(request.configUID)) {
    body['configUID'] = request.configUID;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.environmentUID)) {
    body['environmentUID'] = request.environmentUID;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.parentComponentName)) {
    body['parentComponentName'] = request.parentComponentName;
  }
  if (!Util.isUnset(request.parentComponentVersionUID)) {
    body['parentComponentVersionUID'] = request.parentComponentVersionUID;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    body['productVersionUID'] = request.productVersionUID;
  }
  if (!Util.isUnset(request.releaseName)) {
    body['releaseName'] = request.releaseName;
  }
  if (!Util.isUnset(request.scope)) {
    body['scope'] = request.scope;
  }
  if (!Util.isUnset(request.value)) {
    body['value'] = request.value;
  }
  if (!Util.isUnset(request.valueType)) {
    body['valueType'] = request.valueType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutProductInstanceConfig',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-instances/configs`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model SetEnvironmentFoundationReferenceResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model SetEnvironmentFoundationReferenceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetEnvironmentFoundationReferenceResponseBody(name='body'),
}

async function setEnvironmentFoundationReference(uid: string, foundationReferenceUID: string): SetEnvironmentFoundationReferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return setEnvironmentFoundationReferenceWithOptions(uid, foundationReferenceUID, headers, runtime);
}

async function setEnvironmentFoundationReferenceWithOptions(uid: string, foundationReferenceUID: string, headers: map[string]string, runtime: Util.RuntimeOptions): SetEnvironmentFoundationReferenceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'SetEnvironmentFoundationReference',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${OpenApiUtil.getEncodeParam(uid)}/foundation-references/${OpenApiUtil.getEncodeParam(foundationReferenceUID)}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateDeliverableRequest {
  foundation?: {
    clusterConfig?: string(name='clusterConfig'),
    foundationReferenceUID?: string(name='foundationReferenceUID'),
    foundationVersion?: string(name='foundationVersion'),
    foundationVersionUID?: string(name='foundationVersionUID'),
    reusable?: boolean(name='reusable'),
  }(name='foundation'),
  products?: [ 
    {
      namespace?: string(name='namespace'),
      productName?: string(name='productName'),
      productType?: string(name='productType'),
      productUID?: string(name='productUID'),
      productVersion?: string(name='productVersion'),
      productVersionSpecName?: string(name='productVersionSpecName'),
      productVersionSpecUID?: string(name='productVersionSpecUID'),
      productVersionUID?: string(name='productVersionUID'),
    }
  ](name='products'),
}

model UpdateDeliverableResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model UpdateDeliverableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDeliverableResponseBody(name='body'),
}

async function updateDeliverable(uid: string, request: UpdateDeliverableRequest): UpdateDeliverableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDeliverableWithOptions(uid, request, headers, runtime);
}

async function updateDeliverableWithOptions(uid: string, request: UpdateDeliverableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDeliverableResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.foundation)) {
    body['foundation'] = request.foundation;
  }
  if (!Util.isUnset(request.products)) {
    body['products'] = request.products;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDeliverable',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/delivery/deliverables/${OpenApiUtil.getEncodeParam(uid)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateDeliveryInstanceRequest {
  deliverableConfigUID?: string(name='deliverableConfigUID'),
  deliverableUID?: string(name='deliverableUID'),
}

model UpdateDeliveryInstanceResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model UpdateDeliveryInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDeliveryInstanceResponseBody(name='body'),
}

async function updateDeliveryInstance(uid: string, request: UpdateDeliveryInstanceRequest): UpdateDeliveryInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDeliveryInstanceWithOptions(uid, request, headers, runtime);
}

async function updateDeliveryInstanceWithOptions(uid: string, request: UpdateDeliveryInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDeliveryInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deliverableConfigUID)) {
    body['deliverableConfigUID'] = request.deliverableConfigUID;
  }
  if (!Util.isUnset(request.deliverableUID)) {
    body['deliverableUID'] = request.deliverableUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDeliveryInstance',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/delivery/delivery-instances/${OpenApiUtil.getEncodeParam(uid)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateEnvironmentRequest {
  advancedConfigs?: {
    enableDeploySimulation?: boolean(name='enableDeploySimulation'),
    enableSiteSurvey?: boolean(name='enableSiteSurvey'),
  }(name='advancedConfigs'),
  description?: string(name='description'),
  location?: string(name='location'),
  vendorConfig?: string(name='vendorConfig'),
}

model UpdateEnvironmentResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model UpdateEnvironmentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateEnvironmentResponseBody(name='body'),
}

async function updateEnvironment(uid: string, request: UpdateEnvironmentRequest): UpdateEnvironmentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateEnvironmentWithOptions(uid, request, headers, runtime);
}

async function updateEnvironmentWithOptions(uid: string, request: UpdateEnvironmentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateEnvironmentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.advancedConfigs)) {
    body['advancedConfigs'] = request.advancedConfigs;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.location)) {
    body['location'] = request.location;
  }
  if (!Util.isUnset(request.vendorConfig)) {
    body['vendorConfig'] = request.vendorConfig;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEnvironment',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${OpenApiUtil.getEncodeParam(uid)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateEnvironmentNodeRequest {
  applicationDisk?: string(name='applicationDisk'),
  etcdDisk?: string(name='etcdDisk'),
  labels?: map[string]any(name='labels'),
  rootPassword?: string(name='rootPassword'),
  taints?: [ 
    {
      effect?: string(name='effect'),
      key?: string(name='key'),
      value?: string(name='value'),
    }
  ](name='taints'),
  tridentSystemDisk?: string(name='tridentSystemDisk'),
  tridentSystemSizeDisk?: int32(name='tridentSystemSizeDisk'),
}

model UpdateEnvironmentNodeResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model UpdateEnvironmentNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateEnvironmentNodeResponseBody(name='body'),
}

async function updateEnvironmentNode(uid: string, nodeUID: string, request: UpdateEnvironmentNodeRequest): UpdateEnvironmentNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateEnvironmentNodeWithOptions(uid, nodeUID, request, headers, runtime);
}

async function updateEnvironmentNodeWithOptions(uid: string, nodeUID: string, request: UpdateEnvironmentNodeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateEnvironmentNodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.applicationDisk)) {
    body['applicationDisk'] = request.applicationDisk;
  }
  if (!Util.isUnset(request.etcdDisk)) {
    body['etcdDisk'] = request.etcdDisk;
  }
  if (!Util.isUnset(request.labels)) {
    body['labels'] = request.labels;
  }
  if (!Util.isUnset(request.rootPassword)) {
    body['rootPassword'] = request.rootPassword;
  }
  if (!Util.isUnset(request.taints)) {
    body['taints'] = request.taints;
  }
  if (!Util.isUnset(request.tridentSystemDisk)) {
    body['tridentSystemDisk'] = request.tridentSystemDisk;
  }
  if (!Util.isUnset(request.tridentSystemSizeDisk)) {
    body['tridentSystemSizeDisk'] = request.tridentSystemSizeDisk;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEnvironmentNode',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${OpenApiUtil.getEncodeParam(uid)}/nodes/${OpenApiUtil.getEncodeParam(nodeUID)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateEnvironmentProductVersionRequest {
  oldProductVersionSpecUID?: string(name='oldProductVersionSpecUID'),
  oldProductVersionUID?: string(name='oldProductVersionUID'),
  productVersionSpecUID?: string(name='productVersionSpecUID'),
  productVersionUID?: string(name='productVersionUID'),
}

model UpdateEnvironmentProductVersionResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model UpdateEnvironmentProductVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateEnvironmentProductVersionResponseBody(name='body'),
}

async function updateEnvironmentProductVersion(uid: string, request: UpdateEnvironmentProductVersionRequest): UpdateEnvironmentProductVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateEnvironmentProductVersionWithOptions(uid, request, headers, runtime);
}

async function updateEnvironmentProductVersionWithOptions(uid: string, request: UpdateEnvironmentProductVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateEnvironmentProductVersionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.oldProductVersionSpecUID)) {
    body['oldProductVersionSpecUID'] = request.oldProductVersionSpecUID;
  }
  if (!Util.isUnset(request.oldProductVersionUID)) {
    body['oldProductVersionUID'] = request.oldProductVersionUID;
  }
  if (!Util.isUnset(request.productVersionSpecUID)) {
    body['productVersionSpecUID'] = request.productVersionSpecUID;
  }
  if (!Util.isUnset(request.productVersionUID)) {
    body['productVersionUID'] = request.productVersionUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEnvironmentProductVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${OpenApiUtil.getEncodeParam(uid)}/product-versions`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateFoundationComponentReferenceRequest {
  componentOrchestrationValues?: string(name='componentOrchestrationValues'),
  enable?: boolean(name='enable'),
}

model UpdateFoundationComponentReferenceResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model UpdateFoundationComponentReferenceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateFoundationComponentReferenceResponseBody(name='body'),
}

async function updateFoundationComponentReference(uid: string, componentReferenceUID: string, request: UpdateFoundationComponentReferenceRequest): UpdateFoundationComponentReferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFoundationComponentReferenceWithOptions(uid, componentReferenceUID, request, headers, runtime);
}

async function updateFoundationComponentReferenceWithOptions(uid: string, componentReferenceUID: string, request: UpdateFoundationComponentReferenceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFoundationComponentReferenceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.componentOrchestrationValues)) {
    body['componentOrchestrationValues'] = request.componentOrchestrationValues;
  }
  if (!Util.isUnset(request.enable)) {
    body['enable'] = request.enable;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFoundationComponentReference',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/foundation-references/${OpenApiUtil.getEncodeParam(uid)}/components/${OpenApiUtil.getEncodeParam(componentReferenceUID)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateFoundationReferenceRequest {
  clusterConfig?: string(name='clusterConfig'),
}

model UpdateFoundationReferenceResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model UpdateFoundationReferenceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateFoundationReferenceResponseBody(name='body'),
}

async function updateFoundationReference(uid: string, request: UpdateFoundationReferenceRequest): UpdateFoundationReferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFoundationReferenceWithOptions(uid, request, headers, runtime);
}

async function updateFoundationReferenceWithOptions(uid: string, request: UpdateFoundationReferenceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFoundationReferenceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clusterConfig)) {
    body['clusterConfig'] = request.clusterConfig;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFoundationReference',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/foundation-references/${OpenApiUtil.getEncodeParam(uid)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateProductRequest {
  categories?: [ string ](name='categories'),
  description?: string(name='description'),
  displayName?: string(name='displayName'),
  vendor?: string(name='vendor'),
}

model UpdateProductResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model UpdateProductResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateProductResponseBody(name='body'),
}

async function updateProduct(uid: string, request: UpdateProductRequest): UpdateProductResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProductWithOptions(uid, request, headers, runtime);
}

async function updateProductWithOptions(uid: string, request: UpdateProductRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProductResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.categories)) {
    body['categories'] = request.categories;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.vendor)) {
    body['vendor'] = request.vendor;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProduct',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/products/${OpenApiUtil.getEncodeParam(uid)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateProductComponentVersionRequest {
  componentOrchestrationValues?: string(name='componentOrchestrationValues'),
  enable?: boolean(name='enable'),
  newComponentVersionUID?: string(name='newComponentVersionUID'),
  policy?: {
    multiCluster?: {
      autoInstall?: boolean(name='autoInstall'),
      targetClusters?: [ string ](name='targetClusters'),
    }(name='multiCluster'),
  }(name='policy'),
  releaseName?: string(name='releaseName'),
}

model UpdateProductComponentVersionResponseBody = {
  code?: string(name='code'),
  data?: {
    relationUID?: string(name='relationUID'),
  }(name='data'),
  msg?: string(name='msg'),
}

model UpdateProductComponentVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateProductComponentVersionResponseBody(name='body'),
}

async function updateProductComponentVersion(uid: string, relationUID: string, request: UpdateProductComponentVersionRequest): UpdateProductComponentVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProductComponentVersionWithOptions(uid, relationUID, request, headers, runtime);
}

async function updateProductComponentVersionWithOptions(uid: string, relationUID: string, request: UpdateProductComponentVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProductComponentVersionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.componentOrchestrationValues)) {
    body['componentOrchestrationValues'] = request.componentOrchestrationValues;
  }
  if (!Util.isUnset(request.enable)) {
    body['enable'] = request.enable;
  }
  if (!Util.isUnset(request.newComponentVersionUID)) {
    body['newComponentVersionUID'] = request.newComponentVersionUID;
  }
  if (!Util.isUnset(request.policy)) {
    body['policy'] = request.policy;
  }
  if (!Util.isUnset(request.releaseName)) {
    body['releaseName'] = request.releaseName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProductComponentVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${OpenApiUtil.getEncodeParam(uid)}/relations/${OpenApiUtil.getEncodeParam(relationUID)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateProductFoundationVersionRequest {
  foundationVersionUID?: string(name='foundationVersionUID'),
}

model UpdateProductFoundationVersionResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model UpdateProductFoundationVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateProductFoundationVersionResponseBody(name='body'),
}

async function updateProductFoundationVersion(uid: string, request: UpdateProductFoundationVersionRequest): UpdateProductFoundationVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProductFoundationVersionWithOptions(uid, request, headers, runtime);
}

async function updateProductFoundationVersionWithOptions(uid: string, request: UpdateProductFoundationVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProductFoundationVersionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.foundationVersionUID)) {
    body['foundationVersionUID'] = request.foundationVersionUID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProductFoundationVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${OpenApiUtil.getEncodeParam(uid)}/foundation`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateProductVersionRequest {
  continuousIntegration?: boolean(name='continuousIntegration'),
  description?: string(name='description'),
  entry?: string(name='entry'),
  version?: string(name='version'),
}

model UpdateProductVersionResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model UpdateProductVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateProductVersionResponseBody(name='body'),
}

async function updateProductVersion(uid: string, request: UpdateProductVersionRequest): UpdateProductVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProductVersionWithOptions(uid, request, headers, runtime);
}

async function updateProductVersionWithOptions(uid: string, request: UpdateProductVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProductVersionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.continuousIntegration)) {
    body['continuousIntegration'] = request.continuousIntegration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.entry)) {
    body['entry'] = request.entry;
  }
  if (!Util.isUnset(request.version)) {
    body['version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProductVersion',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${OpenApiUtil.getEncodeParam(uid)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateProductVersionConfigRequest {
  componentVersionUID?: string(name='componentVersionUID'),
  description?: string(name='description'),
  name?: string(name='name'),
  parentComponentVersionUID?: string(name='parentComponentVersionUID'),
  value?: string(name='value'),
  valueType?: string(name='valueType'),
}

model UpdateProductVersionConfigResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
  requestId?: string(name='requestId'),
}

model UpdateProductVersionConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateProductVersionConfigResponseBody(name='body'),
}

async function updateProductVersionConfig(uid: string, configUID: string, request: UpdateProductVersionConfigRequest): UpdateProductVersionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProductVersionConfigWithOptions(uid, configUID, request, headers, runtime);
}

async function updateProductVersionConfigWithOptions(uid: string, configUID: string, request: UpdateProductVersionConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProductVersionConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.componentVersionUID)) {
    body['componentVersionUID'] = request.componentVersionUID;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.parentComponentVersionUID)) {
    body['parentComponentVersionUID'] = request.parentComponentVersionUID;
  }
  if (!Util.isUnset(request.value)) {
    body['value'] = request.value;
  }
  if (!Util.isUnset(request.valueType)) {
    body['valueType'] = request.valueType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProductVersionConfig',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/product-versions/${OpenApiUtil.getEncodeParam(uid)}/configs/${OpenApiUtil.getEncodeParam(configUID)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ValidateEnvironmentTunnelRequest {
  tunnelConfig?: {
    hostname?: string(name='hostname'),
    password?: string(name='password'),
    regionId?: string(name='regionId'),
    sshPort?: int32(name='sshPort'),
    username?: string(name='username'),
    vpcId?: string(name='vpcId'),
  }(name='tunnelConfig'),
  tunnelType?: string(name='tunnelType'),
}

model ValidateEnvironmentTunnelResponseBody = {
  code?: string(name='code'),
  msg?: string(name='msg'),
}

model ValidateEnvironmentTunnelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ValidateEnvironmentTunnelResponseBody(name='body'),
}

async function validateEnvironmentTunnel(uid: string, request: ValidateEnvironmentTunnelRequest): ValidateEnvironmentTunnelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return validateEnvironmentTunnelWithOptions(uid, request, headers, runtime);
}

async function validateEnvironmentTunnelWithOptions(uid: string, request: ValidateEnvironmentTunnelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ValidateEnvironmentTunnelResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.tunnelConfig)) {
    body['tunnelConfig'] = request.tunnelConfig;
  }
  if (!Util.isUnset(request.tunnelType)) {
    body['tunnelType'] = request.tunnelType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ValidateEnvironmentTunnel',
    version = '2021-07-20',
    protocol = 'HTTPS',
    pathname = `/api/v2/environments/${OpenApiUtil.getEncodeParam(uid)}/tunnels/validation`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

