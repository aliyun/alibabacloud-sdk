/**
 *
 */
import Util;
import OSS;
import OpenPlatform;
import OSSUtil;
import FileForm;
import Array;
import Number;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('facebody', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddBodyTraceRequest {
  dbId?: long(name='DbId'),
  extraData?: string(name='ExtraData'),
  images?: [ 
    {
      imageData?: bytes(name='ImageData'),
      imageURL?: string(name='ImageURL'),
    }
  ](name='Images'),
  personId?: long(name='PersonId'),
}

model AddBodyTraceShrinkRequest {
  dbId?: long(name='DbId'),
  extraData?: string(name='ExtraData'),
  imagesShrink?: string(name='Images'),
  personId?: long(name='PersonId'),
}

model AddBodyTraceResponseBody = {
  data?: {
    id?: long(name='Id'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model AddBodyTraceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddBodyTraceResponseBody(name='body'),
}

async function addBodyTraceWithOptions(tmpReq: AddBodyTraceRequest, runtime: Util.RuntimeOptions): AddBodyTraceResponse {
  Util.validateModel(tmpReq);
  var request = new AddBodyTraceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.images)) {
    request.imagesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.images, 'Images', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.dbId)) {
    body['DbId'] = request.dbId;
  }
  if (!Util.isUnset(request.extraData)) {
    body['ExtraData'] = request.extraData;
  }
  if (!Util.isUnset(request.imagesShrink)) {
    body['Images'] = request.imagesShrink;
  }
  if (!Util.isUnset(request.personId)) {
    body['PersonId'] = request.personId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddBodyTrace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addBodyTrace(request: AddBodyTraceRequest): AddBodyTraceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addBodyTraceWithOptions(request, runtime);
}

model AddFaceRequest {
  dbName?: string(name='DbName'),
  entityId?: string(name='EntityId'),
  extraData?: string(name='ExtraData'),
  imageUrl?: string(name='ImageUrl'),
  qualityScoreThreshold?: float(name='QualityScoreThreshold'),
  similarityScoreThresholdBetweenEntity?: float(name='SimilarityScoreThresholdBetweenEntity'),
  similarityScoreThresholdInEntity?: float(name='SimilarityScoreThresholdInEntity'),
}

model AddFaceAdvanceRequest {
  dbName?: string(name='DbName'),
  entityId?: string(name='EntityId'),
  extraData?: string(name='ExtraData'),
  imageUrlObject?: readable(name='ImageUrl'),
  qualityScoreThreshold?: float(name='QualityScoreThreshold'),
  similarityScoreThresholdBetweenEntity?: float(name='SimilarityScoreThresholdBetweenEntity'),
  similarityScoreThresholdInEntity?: float(name='SimilarityScoreThresholdInEntity'),
}

model AddFaceResponseBody = {
  data?: {
    faceId?: string(name='FaceId'),
    qualitieScore?: float(name='QualitieScore'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model AddFaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddFaceResponseBody(name='body'),
}

async function addFaceWithOptions(request: AddFaceRequest, runtime: Util.RuntimeOptions): AddFaceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dbName)) {
    body['DbName'] = request.dbName;
  }
  if (!Util.isUnset(request.entityId)) {
    body['EntityId'] = request.entityId;
  }
  if (!Util.isUnset(request.extraData)) {
    body['ExtraData'] = request.extraData;
  }
  if (!Util.isUnset(request.imageUrl)) {
    body['ImageUrl'] = request.imageUrl;
  }
  if (!Util.isUnset(request.qualityScoreThreshold)) {
    body['QualityScoreThreshold'] = request.qualityScoreThreshold;
  }
  if (!Util.isUnset(request.similarityScoreThresholdBetweenEntity)) {
    body['SimilarityScoreThresholdBetweenEntity'] = request.similarityScoreThresholdBetweenEntity;
  }
  if (!Util.isUnset(request.similarityScoreThresholdInEntity)) {
    body['SimilarityScoreThresholdInEntity'] = request.similarityScoreThresholdInEntity;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addFace(request: AddFaceRequest): AddFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addFaceWithOptions(request, runtime);
}

async function addFaceAdvance(request: AddFaceAdvanceRequest, runtime: Util.RuntimeOptions): AddFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var addFaceReq = new AddFaceRequest{};
  OpenApiUtil.convert(request, addFaceReq);

  if(!Util.isUnset(request.imageUrlObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageUrlObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    addFaceReq.imageUrl = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var addFaceResp = addFaceWithOptions(addFaceReq, runtime);
  return addFaceResp;
}

model AddFaceEntityRequest {
  dbName?: string(name='DbName'),
  entityId?: string(name='EntityId'),
  labels?: string(name='Labels'),
}

model AddFaceEntityResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddFaceEntityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddFaceEntityResponseBody(name='body'),
}

async function addFaceEntityWithOptions(request: AddFaceEntityRequest, runtime: Util.RuntimeOptions): AddFaceEntityResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dbName)) {
    body['DbName'] = request.dbName;
  }
  if (!Util.isUnset(request.entityId)) {
    body['EntityId'] = request.entityId;
  }
  if (!Util.isUnset(request.labels)) {
    body['Labels'] = request.labels;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddFaceEntity',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addFaceEntity(request: AddFaceEntityRequest): AddFaceEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return addFaceEntityWithOptions(request, runtime);
}

model AddFaceImageTemplateRequest {
  imageURL?: string(name='ImageURL'),
  userId?: string(name='UserId'),
}

model AddFaceImageTemplateAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
  userId?: string(name='UserId'),
}

model AddFaceImageTemplateResponseBody = {
  data?: {
    templateId?: string(name='TemplateId'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model AddFaceImageTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddFaceImageTemplateResponseBody(name='body'),
}

async function addFaceImageTemplateWithOptions(request: AddFaceImageTemplateRequest, runtime: Util.RuntimeOptions): AddFaceImageTemplateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddFaceImageTemplate',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addFaceImageTemplate(request: AddFaceImageTemplateRequest): AddFaceImageTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addFaceImageTemplateWithOptions(request, runtime);
}

async function addFaceImageTemplateAdvance(request: AddFaceImageTemplateAdvanceRequest, runtime: Util.RuntimeOptions): AddFaceImageTemplateResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var addFaceImageTemplateReq = new AddFaceImageTemplateRequest{};
  OpenApiUtil.convert(request, addFaceImageTemplateReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    addFaceImageTemplateReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var addFaceImageTemplateResp = addFaceImageTemplateWithOptions(addFaceImageTemplateReq, runtime);
  return addFaceImageTemplateResp;
}

model BatchAddFacesRequest {
  dbName?: string(name='DbName'),
  entityId?: string(name='EntityId'),
  faces?: [ 
    {
      extraData?: string(name='ExtraData'),
      imageURL?: string(name='ImageURL'),
    }
  ](name='Faces'),
  qualityScoreThreshold?: float(name='QualityScoreThreshold'),
  similarityScoreThresholdBetweenEntity?: float(name='SimilarityScoreThresholdBetweenEntity'),
  similarityScoreThresholdInEntity?: float(name='SimilarityScoreThresholdInEntity'),
}

model BatchAddFacesShrinkRequest {
  dbName?: string(name='DbName'),
  entityId?: string(name='EntityId'),
  facesShrink?: string(name='Faces'),
  qualityScoreThreshold?: float(name='QualityScoreThreshold'),
  similarityScoreThresholdBetweenEntity?: float(name='SimilarityScoreThresholdBetweenEntity'),
  similarityScoreThresholdInEntity?: float(name='SimilarityScoreThresholdInEntity'),
}

model BatchAddFacesResponseBody = {
  data?: {
    failedFaces?: [ 
      {
        code?: string(name='Code'),
        imageURL?: string(name='ImageURL'),
        message?: string(name='Message'),
      }
    ](name='FailedFaces'),
    insertedFaces?: [ 
      {
        faceId?: string(name='FaceId'),
        imageURL?: string(name='ImageURL'),
        qualitieScore?: float(name='QualitieScore'),
      }
    ](name='InsertedFaces'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model BatchAddFacesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchAddFacesResponseBody(name='body'),
}

async function batchAddFacesWithOptions(tmpReq: BatchAddFacesRequest, runtime: Util.RuntimeOptions): BatchAddFacesResponse {
  Util.validateModel(tmpReq);
  var request = new BatchAddFacesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.faces)) {
    request.facesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.faces, 'Faces', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.dbName)) {
    body['DbName'] = request.dbName;
  }
  if (!Util.isUnset(request.entityId)) {
    body['EntityId'] = request.entityId;
  }
  if (!Util.isUnset(request.facesShrink)) {
    body['Faces'] = request.facesShrink;
  }
  if (!Util.isUnset(request.qualityScoreThreshold)) {
    body['QualityScoreThreshold'] = request.qualityScoreThreshold;
  }
  if (!Util.isUnset(request.similarityScoreThresholdBetweenEntity)) {
    body['SimilarityScoreThresholdBetweenEntity'] = request.similarityScoreThresholdBetweenEntity;
  }
  if (!Util.isUnset(request.similarityScoreThresholdInEntity)) {
    body['SimilarityScoreThresholdInEntity'] = request.similarityScoreThresholdInEntity;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchAddFaces',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchAddFaces(request: BatchAddFacesRequest): BatchAddFacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchAddFacesWithOptions(request, runtime);
}

model BeautifyBodyRequest {
  ageRange?: {
    ageMax?: long(name='AgeMax'),
    ageMinimum?: long(name='AgeMinimum'),
  }(name='AgeRange'),
  bodyBoxes?: [ 
    {
      height?: float(name='Height'),
      width?: float(name='Width'),
      x?: float(name='X'),
      y?: float(name='Y'),
    }
  ](name='BodyBoxes'),
  custom?: long(name='Custom'),
  faceList?: [ 
    {
      age?: long(name='Age'),
      faceBox?: {
        height?: float(name='Height'),
        width?: float(name='Width'),
        x?: float(name='X'),
        y?: float(name='Y'),
      }(name='FaceBox'),
      gender?: long(name='Gender'),
    }
  ](name='FaceList'),
  femaleLiquifyDegree?: float(name='FemaleLiquifyDegree'),
  imageURL?: string(name='ImageURL'),
  isPregnant?: boolean(name='IsPregnant'),
  lengthenDegree?: float(name='LengthenDegree'),
  maleLiquifyDegree?: float(name='MaleLiquifyDegree'),
  originalHeight?: long(name='OriginalHeight'),
  originalWidth?: long(name='OriginalWidth'),
  poseList?: [ 
    {
      pose?: [ 
        {
          score?: float(name='Score'),
          x?: long(name='X'),
          y?: long(name='Y'),
        }
      ](name='Pose'),
    }
  ](name='PoseList'),
}

model BeautifyBodyAdvanceRequest {
  ageRange?: {
    ageMax?: long(name='AgeMax'),
    ageMinimum?: long(name='AgeMinimum'),
  }(name='AgeRange'),
  bodyBoxes?: [ 
    {
      height?: float(name='Height'),
      width?: float(name='Width'),
      x?: float(name='X'),
      y?: float(name='Y'),
    }
  ](name='BodyBoxes'),
  custom?: long(name='Custom'),
  faceList?: [ 
    {
      age?: long(name='Age'),
      faceBox?: {
        height?: float(name='Height'),
        width?: float(name='Width'),
        x?: float(name='X'),
        y?: float(name='Y'),
      }(name='FaceBox'),
      gender?: long(name='Gender'),
    }
  ](name='FaceList'),
  femaleLiquifyDegree?: float(name='FemaleLiquifyDegree'),
  imageURLObject?: readable(name='ImageURL'),
  isPregnant?: boolean(name='IsPregnant'),
  lengthenDegree?: float(name='LengthenDegree'),
  maleLiquifyDegree?: float(name='MaleLiquifyDegree'),
  originalHeight?: long(name='OriginalHeight'),
  originalWidth?: long(name='OriginalWidth'),
  poseList?: [ 
    {
      pose?: [ 
        {
          score?: float(name='Score'),
          x?: long(name='X'),
          y?: long(name='Y'),
        }
      ](name='Pose'),
    }
  ](name='PoseList'),
}

model BeautifyBodyShrinkRequest {
  ageRangeShrink?: string(name='AgeRange'),
  bodyBoxesShrink?: string(name='BodyBoxes'),
  custom?: long(name='Custom'),
  faceListShrink?: string(name='FaceList'),
  femaleLiquifyDegree?: float(name='FemaleLiquifyDegree'),
  imageURL?: string(name='ImageURL'),
  isPregnant?: boolean(name='IsPregnant'),
  lengthenDegree?: float(name='LengthenDegree'),
  maleLiquifyDegree?: float(name='MaleLiquifyDegree'),
  originalHeight?: long(name='OriginalHeight'),
  originalWidth?: long(name='OriginalWidth'),
  poseListShrink?: string(name='PoseList'),
}

model BeautifyBodyResponseBody = {
  data?: {
    action?: string(name='Action'),
    XFlowURL?: string(name='XFlowURL'),
    YFlowURL?: string(name='YFlowURL'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model BeautifyBodyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BeautifyBodyResponseBody(name='body'),
}

async function beautifyBodyWithOptions(tmpReq: BeautifyBodyRequest, runtime: Util.RuntimeOptions): BeautifyBodyResponse {
  Util.validateModel(tmpReq);
  var request = new BeautifyBodyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.ageRange)) {
    request.ageRangeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ageRange, 'AgeRange', 'json');
  }
  if (!Util.isUnset(tmpReq.bodyBoxes)) {
    request.bodyBoxesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.bodyBoxes, 'BodyBoxes', 'json');
  }
  if (!Util.isUnset(tmpReq.faceList)) {
    request.faceListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.faceList, 'FaceList', 'json');
  }
  if (!Util.isUnset(tmpReq.poseList)) {
    request.poseListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.poseList, 'PoseList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.ageRangeShrink)) {
    body['AgeRange'] = request.ageRangeShrink;
  }
  if (!Util.isUnset(request.bodyBoxesShrink)) {
    body['BodyBoxes'] = request.bodyBoxesShrink;
  }
  if (!Util.isUnset(request.custom)) {
    body['Custom'] = request.custom;
  }
  if (!Util.isUnset(request.faceListShrink)) {
    body['FaceList'] = request.faceListShrink;
  }
  if (!Util.isUnset(request.femaleLiquifyDegree)) {
    body['FemaleLiquifyDegree'] = request.femaleLiquifyDegree;
  }
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  if (!Util.isUnset(request.isPregnant)) {
    body['IsPregnant'] = request.isPregnant;
  }
  if (!Util.isUnset(request.lengthenDegree)) {
    body['LengthenDegree'] = request.lengthenDegree;
  }
  if (!Util.isUnset(request.maleLiquifyDegree)) {
    body['MaleLiquifyDegree'] = request.maleLiquifyDegree;
  }
  if (!Util.isUnset(request.originalHeight)) {
    body['OriginalHeight'] = request.originalHeight;
  }
  if (!Util.isUnset(request.originalWidth)) {
    body['OriginalWidth'] = request.originalWidth;
  }
  if (!Util.isUnset(request.poseListShrink)) {
    body['PoseList'] = request.poseListShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BeautifyBody',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function beautifyBody(request: BeautifyBodyRequest): BeautifyBodyResponse {
  var runtime = new Util.RuntimeOptions{};
  return beautifyBodyWithOptions(request, runtime);
}

async function beautifyBodyAdvance(request: BeautifyBodyAdvanceRequest, runtime: Util.RuntimeOptions): BeautifyBodyResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var beautifyBodyReq = new BeautifyBodyRequest{};
  OpenApiUtil.convert(request, beautifyBodyReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    beautifyBodyReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var beautifyBodyResp = beautifyBodyWithOptions(beautifyBodyReq, runtime);
  return beautifyBodyResp;
}

model BlurFaceRequest {
  imageURL?: string(name='ImageURL'),
}

model BlurFaceAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
}

model BlurFaceResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model BlurFaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BlurFaceResponseBody(name='body'),
}

async function blurFaceWithOptions(request: BlurFaceRequest, runtime: Util.RuntimeOptions): BlurFaceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BlurFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function blurFace(request: BlurFaceRequest): BlurFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return blurFaceWithOptions(request, runtime);
}

async function blurFaceAdvance(request: BlurFaceAdvanceRequest, runtime: Util.RuntimeOptions): BlurFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var blurFaceReq = new BlurFaceRequest{};
  OpenApiUtil.convert(request, blurFaceReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    blurFaceReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var blurFaceResp = blurFaceWithOptions(blurFaceReq, runtime);
  return blurFaceResp;
}

model BodyPostureRequest {
  imageURL?: string(name='ImageURL'),
}

model BodyPostureAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
}

model BodyPostureResponseBody = {
  data?: {
    metaObject?: {
      height?: int32(name='Height'),
      width?: int32(name='Width'),
    }(name='MetaObject'),
    outputs?: [ 
      {
        humanCount?: int32(name='HumanCount'),
        results?: [ 
          {
            bodies?: [ 
              {
                confident?: float(name='Confident'),
                label?: string(name='Label'),
                positions?: [ 
                  {
                    points?: [ float ](name='Points'),
                  }
                ](name='Positions'),
              }
            ](name='Bodies'),
          }
        ](name='Results'),
      }
    ](name='Outputs'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model BodyPostureResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BodyPostureResponseBody(name='body'),
}

async function bodyPostureWithOptions(request: BodyPostureRequest, runtime: Util.RuntimeOptions): BodyPostureResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BodyPosture',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function bodyPosture(request: BodyPostureRequest): BodyPostureResponse {
  var runtime = new Util.RuntimeOptions{};
  return bodyPostureWithOptions(request, runtime);
}

async function bodyPostureAdvance(request: BodyPostureAdvanceRequest, runtime: Util.RuntimeOptions): BodyPostureResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var bodyPostureReq = new BodyPostureRequest{};
  OpenApiUtil.convert(request, bodyPostureReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    bodyPostureReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var bodyPostureResp = bodyPostureWithOptions(bodyPostureReq, runtime);
  return bodyPostureResp;
}

model CompareFaceRequest {
  imageDataA?: bytes(name='ImageDataA'),
  imageDataB?: bytes(name='ImageDataB'),
  imageURLA?: string(name='ImageURLA'),
  imageURLB?: string(name='ImageURLB'),
  qualityScoreThreshold?: float(name='QualityScoreThreshold'),
}

model CompareFaceAdvanceRequest {
  imageDataA?: bytes(name='ImageDataA'),
  imageDataB?: bytes(name='ImageDataB'),
  imageURLAObject?: readable(name='ImageURLA'),
  imageURLBObject?: readable(name='ImageURLB'),
  qualityScoreThreshold?: float(name='QualityScoreThreshold'),
}

model CompareFaceResponseBody = {
  data?: {
    confidence?: float(name='Confidence'),
    messageTips?: string(name='MessageTips'),
    qualityScoreA?: float(name='QualityScoreA'),
    qualityScoreB?: float(name='QualityScoreB'),
    rectAList?: [ int32 ](name='RectAList'),
    rectBList?: [ int32 ](name='RectBList'),
    thresholds?: [ float ](name='Thresholds'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CompareFaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CompareFaceResponseBody(name='body'),
}

async function compareFaceWithOptions(request: CompareFaceRequest, runtime: Util.RuntimeOptions): CompareFaceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageDataA)) {
    body['ImageDataA'] = request.imageDataA;
  }
  if (!Util.isUnset(request.imageDataB)) {
    body['ImageDataB'] = request.imageDataB;
  }
  if (!Util.isUnset(request.imageURLA)) {
    body['ImageURLA'] = request.imageURLA;
  }
  if (!Util.isUnset(request.imageURLB)) {
    body['ImageURLB'] = request.imageURLB;
  }
  if (!Util.isUnset(request.qualityScoreThreshold)) {
    body['QualityScoreThreshold'] = request.qualityScoreThreshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CompareFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function compareFace(request: CompareFaceRequest): CompareFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return compareFaceWithOptions(request, runtime);
}

async function compareFaceAdvance(request: CompareFaceAdvanceRequest, runtime: Util.RuntimeOptions): CompareFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var compareFaceReq = new CompareFaceRequest{};
  OpenApiUtil.convert(request, compareFaceReq);

  if(!Util.isUnset(request.imageURLAObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLAObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    compareFaceReq.imageURLA = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  if(!Util.isUnset(request.imageURLBObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLBObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    compareFaceReq.imageURLB = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var compareFaceResp = compareFaceWithOptions(compareFaceReq, runtime);
  return compareFaceResp;
}

model CountCrowdRequest {
  imageURL?: string(name='ImageURL'),
  isShow?: boolean(name='IsShow'),
}

model CountCrowdAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
  isShow?: boolean(name='IsShow'),
}

model CountCrowdResponseBody = {
  data?: {
    hotMap?: string(name='HotMap'),
    peopleNumber?: int32(name='PeopleNumber'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CountCrowdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CountCrowdResponseBody(name='body'),
}

async function countCrowdWithOptions(request: CountCrowdRequest, runtime: Util.RuntimeOptions): CountCrowdResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  if (!Util.isUnset(request.isShow)) {
    body['IsShow'] = request.isShow;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CountCrowd',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function countCrowd(request: CountCrowdRequest): CountCrowdResponse {
  var runtime = new Util.RuntimeOptions{};
  return countCrowdWithOptions(request, runtime);
}

async function countCrowdAdvance(request: CountCrowdAdvanceRequest, runtime: Util.RuntimeOptions): CountCrowdResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var countCrowdReq = new CountCrowdRequest{};
  OpenApiUtil.convert(request, countCrowdReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    countCrowdReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var countCrowdResp = countCrowdWithOptions(countCrowdReq, runtime);
  return countCrowdResp;
}

model CreateBodyDbRequest {
  name?: string(name='Name'),
}

model CreateBodyDbResponseBody = {
  data?: {
    id?: long(name='Id'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateBodyDbResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBodyDbResponseBody(name='body'),
}

async function createBodyDbWithOptions(request: CreateBodyDbRequest, runtime: Util.RuntimeOptions): CreateBodyDbResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateBodyDb',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBodyDb(request: CreateBodyDbRequest): CreateBodyDbResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBodyDbWithOptions(request, runtime);
}

model CreateBodyPersonRequest {
  dbId?: long(name='DbId'),
  name?: string(name='Name'),
}

model CreateBodyPersonResponseBody = {
  data?: {
    id?: long(name='Id'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateBodyPersonResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBodyPersonResponseBody(name='body'),
}

async function createBodyPersonWithOptions(request: CreateBodyPersonRequest, runtime: Util.RuntimeOptions): CreateBodyPersonResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dbId)) {
    body['DbId'] = request.dbId;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateBodyPerson',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBodyPerson(request: CreateBodyPersonRequest): CreateBodyPersonResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBodyPersonWithOptions(request, runtime);
}

model CreateFaceDbRequest {
  name?: string(name='Name'),
}

model CreateFaceDbResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateFaceDbResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFaceDbResponseBody(name='body'),
}

async function createFaceDbWithOptions(request: CreateFaceDbRequest, runtime: Util.RuntimeOptions): CreateFaceDbResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFaceDb',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFaceDb(request: CreateFaceDbRequest): CreateFaceDbResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFaceDbWithOptions(request, runtime);
}

model DeleteBodyDbRequest {
  id?: long(name='Id'),
}

model DeleteBodyDbResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBodyDbResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBodyDbResponseBody(name='body'),
}

async function deleteBodyDbWithOptions(request: DeleteBodyDbRequest, runtime: Util.RuntimeOptions): DeleteBodyDbResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBodyDb',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBodyDb(request: DeleteBodyDbRequest): DeleteBodyDbResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBodyDbWithOptions(request, runtime);
}

model DeleteBodyPersonRequest {
  dbId?: long(name='DbId'),
  personId?: long(name='PersonId'),
}

model DeleteBodyPersonResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBodyPersonResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBodyPersonResponseBody(name='body'),
}

async function deleteBodyPersonWithOptions(request: DeleteBodyPersonRequest, runtime: Util.RuntimeOptions): DeleteBodyPersonResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dbId)) {
    body['DbId'] = request.dbId;
  }
  if (!Util.isUnset(request.personId)) {
    body['PersonId'] = request.personId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBodyPerson',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBodyPerson(request: DeleteBodyPersonRequest): DeleteBodyPersonResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBodyPersonWithOptions(request, runtime);
}

model DeleteFaceRequest {
  dbName?: string(name='DbName'),
  faceId?: string(name='FaceId'),
}

model DeleteFaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFaceResponseBody(name='body'),
}

async function deleteFaceWithOptions(request: DeleteFaceRequest, runtime: Util.RuntimeOptions): DeleteFaceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dbName)) {
    body['DbName'] = request.dbName;
  }
  if (!Util.isUnset(request.faceId)) {
    body['FaceId'] = request.faceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFace(request: DeleteFaceRequest): DeleteFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFaceWithOptions(request, runtime);
}

model DeleteFaceDbRequest {
  name?: string(name='Name'),
}

model DeleteFaceDbResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFaceDbResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFaceDbResponseBody(name='body'),
}

async function deleteFaceDbWithOptions(request: DeleteFaceDbRequest, runtime: Util.RuntimeOptions): DeleteFaceDbResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFaceDb',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFaceDb(request: DeleteFaceDbRequest): DeleteFaceDbResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFaceDbWithOptions(request, runtime);
}

model DeleteFaceEntityRequest {
  dbName?: string(name='DbName'),
  entityId?: string(name='EntityId'),
}

model DeleteFaceEntityResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFaceEntityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFaceEntityResponseBody(name='body'),
}

async function deleteFaceEntityWithOptions(request: DeleteFaceEntityRequest, runtime: Util.RuntimeOptions): DeleteFaceEntityResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dbName)) {
    body['DbName'] = request.dbName;
  }
  if (!Util.isUnset(request.entityId)) {
    body['EntityId'] = request.entityId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFaceEntity',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFaceEntity(request: DeleteFaceEntityRequest): DeleteFaceEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFaceEntityWithOptions(request, runtime);
}

model DeleteFaceImageTemplateRequest {
  templateId?: string(name='TemplateId'),
  userId?: string(name='UserId'),
}

model DeleteFaceImageTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFaceImageTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFaceImageTemplateResponseBody(name='body'),
}

async function deleteFaceImageTemplateWithOptions(request: DeleteFaceImageTemplateRequest, runtime: Util.RuntimeOptions): DeleteFaceImageTemplateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.templateId)) {
    body['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFaceImageTemplate',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFaceImageTemplate(request: DeleteFaceImageTemplateRequest): DeleteFaceImageTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFaceImageTemplateWithOptions(request, runtime);
}

model DetectBodyCountRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectBodyCountAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
}

model DetectBodyCountResponseBody = {
  data?: {
    personNumber?: int32(name='PersonNumber'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectBodyCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectBodyCountResponseBody(name='body'),
}

async function detectBodyCountWithOptions(request: DetectBodyCountRequest, runtime: Util.RuntimeOptions): DetectBodyCountResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetectBodyCount',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectBodyCount(request: DetectBodyCountRequest): DetectBodyCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectBodyCountWithOptions(request, runtime);
}

async function detectBodyCountAdvance(request: DetectBodyCountAdvanceRequest, runtime: Util.RuntimeOptions): DetectBodyCountResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectBodyCountReq = new DetectBodyCountRequest{};
  OpenApiUtil.convert(request, detectBodyCountReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectBodyCountReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var detectBodyCountResp = detectBodyCountWithOptions(detectBodyCountReq, runtime);
  return detectBodyCountResp;
}

model DetectCelebrityRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectCelebrityAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
}

model DetectCelebrityResponseBody = {
  data?: {
    faceRecognizeResults?: [ 
      {
        faceBoxes?: [ float ](name='FaceBoxes'),
        name?: string(name='Name'),
      }
    ](name='FaceRecognizeResults'),
    height?: int32(name='Height'),
    width?: int32(name='Width'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectCelebrityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectCelebrityResponseBody(name='body'),
}

async function detectCelebrityWithOptions(request: DetectCelebrityRequest, runtime: Util.RuntimeOptions): DetectCelebrityResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetectCelebrity',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectCelebrity(request: DetectCelebrityRequest): DetectCelebrityResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectCelebrityWithOptions(request, runtime);
}

async function detectCelebrityAdvance(request: DetectCelebrityAdvanceRequest, runtime: Util.RuntimeOptions): DetectCelebrityResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectCelebrityReq = new DetectCelebrityRequest{};
  OpenApiUtil.convert(request, detectCelebrityReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectCelebrityReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var detectCelebrityResp = detectCelebrityWithOptions(detectCelebrityReq, runtime);
  return detectCelebrityResp;
}

model DetectChefCapRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectChefCapAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
}

model DetectChefCapResponseBody = {
  data?: {
    elements?: [ 
      {
        box?: [ float ](name='Box'),
        category?: string(name='Category'),
        confidence?: float(name='Confidence'),
      }
    ](name='Elements'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectChefCapResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectChefCapResponseBody(name='body'),
}

async function detectChefCapWithOptions(request: DetectChefCapRequest, runtime: Util.RuntimeOptions): DetectChefCapResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetectChefCap',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectChefCap(request: DetectChefCapRequest): DetectChefCapResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectChefCapWithOptions(request, runtime);
}

async function detectChefCapAdvance(request: DetectChefCapAdvanceRequest, runtime: Util.RuntimeOptions): DetectChefCapResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectChefCapReq = new DetectChefCapRequest{};
  OpenApiUtil.convert(request, detectChefCapReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectChefCapReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var detectChefCapResp = detectChefCapWithOptions(detectChefCapReq, runtime);
  return detectChefCapResp;
}

model DetectFaceRequest {
  imageURL?: string(name='ImageURL'),
  landmark?: boolean(name='Landmark'),
  maxFaceNumber?: long(name='MaxFaceNumber'),
  pose?: boolean(name='Pose'),
  quality?: boolean(name='Quality'),
}

model DetectFaceAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
  landmark?: boolean(name='Landmark'),
  maxFaceNumber?: long(name='MaxFaceNumber'),
  pose?: boolean(name='Pose'),
  quality?: boolean(name='Quality'),
}

model DetectFaceResponseBody = {
  data?: {
    faceCount?: int32(name='FaceCount'),
    faceProbabilityList?: [ float ](name='FaceProbabilityList'),
    faceRectangles?: [ int32 ](name='FaceRectangles'),
    landmarkCount?: int32(name='LandmarkCount'),
    landmarks?: [ float ](name='Landmarks'),
    poseList?: [ float ](name='PoseList'),
    pupils?: [ float ](name='Pupils'),
    qualities?: {
      blurList?: [ float ](name='BlurList'),
      fnfList?: [ float ](name='FnfList'),
      glassList?: [ float ](name='GlassList'),
      illuList?: [ float ](name='IlluList'),
      maskList?: [ float ](name='MaskList'),
      noiseList?: [ float ](name='NoiseList'),
      poseList?: [ float ](name='PoseList'),
      scoreList?: [ float ](name='ScoreList'),
    }(name='Qualities'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectFaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectFaceResponseBody(name='body'),
}

async function detectFaceWithOptions(request: DetectFaceRequest, runtime: Util.RuntimeOptions): DetectFaceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  if (!Util.isUnset(request.landmark)) {
    body['Landmark'] = request.landmark;
  }
  if (!Util.isUnset(request.maxFaceNumber)) {
    body['MaxFaceNumber'] = request.maxFaceNumber;
  }
  if (!Util.isUnset(request.pose)) {
    body['Pose'] = request.pose;
  }
  if (!Util.isUnset(request.quality)) {
    body['Quality'] = request.quality;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetectFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectFace(request: DetectFaceRequest): DetectFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectFaceWithOptions(request, runtime);
}

async function detectFaceAdvance(request: DetectFaceAdvanceRequest, runtime: Util.RuntimeOptions): DetectFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectFaceReq = new DetectFaceRequest{};
  OpenApiUtil.convert(request, detectFaceReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectFaceReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var detectFaceResp = detectFaceWithOptions(detectFaceReq, runtime);
  return detectFaceResp;
}

model DetectIPCPedestrianRequest {
  height?: int32(name='Height'),
  imageData?: string(name='ImageData'),
  imageURL?: string(name='ImageURL'),
  width?: int32(name='Width'),
}

model DetectIPCPedestrianAdvanceRequest {
  height?: int32(name='Height'),
  imageData?: string(name='ImageData'),
  imageURLObject?: readable(name='ImageURL'),
  width?: int32(name='Width'),
}

model DetectIPCPedestrianResponseBody = {
  data?: {
    imageInfoList?: [ 
      {
        elements?: [ 
          {
            boxes?: [ int32 ](name='Boxes'),
            score?: float(name='Score'),
          }
        ](name='Elements'),
      }
    ](name='ImageInfoList'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectIPCPedestrianResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectIPCPedestrianResponseBody(name='body'),
}

async function detectIPCPedestrianWithOptions(request: DetectIPCPedestrianRequest, runtime: Util.RuntimeOptions): DetectIPCPedestrianResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.height)) {
    body['Height'] = request.height;
  }
  if (!Util.isUnset(request.imageData)) {
    body['ImageData'] = request.imageData;
  }
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  if (!Util.isUnset(request.width)) {
    body['Width'] = request.width;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetectIPCPedestrian',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectIPCPedestrian(request: DetectIPCPedestrianRequest): DetectIPCPedestrianResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectIPCPedestrianWithOptions(request, runtime);
}

async function detectIPCPedestrianAdvance(request: DetectIPCPedestrianAdvanceRequest, runtime: Util.RuntimeOptions): DetectIPCPedestrianResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectIPCPedestrianReq = new DetectIPCPedestrianRequest{};
  OpenApiUtil.convert(request, detectIPCPedestrianReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectIPCPedestrianReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var detectIPCPedestrianResp = detectIPCPedestrianWithOptions(detectIPCPedestrianReq, runtime);
  return detectIPCPedestrianResp;
}

model DetectLivingFaceRequest {
  tasks?: [ 
    {
      imageData?: bytes(name='ImageData'),
      imageURL?: string(name='ImageURL'),
    }
  ](name='Tasks'),
}

model DetectLivingFaceAdvanceRequest {
  tasks?: [ 
    {
      imageData?: bytes(name='ImageData'),
      imageURLObject?: readable(name='ImageURL'),
    }
  ](name='Tasks'),
}

model DetectLivingFaceResponseBody = {
  data?: {
    elements?: [ 
      {
        faceNumber?: long(name='FaceNumber'),
        imageURL?: string(name='ImageURL'),
        results?: [ 
          {
            frames?: [ 
              {
                rate?: float(name='Rate'),
                url?: string(name='Url'),
              }
            ](name='Frames'),
            label?: string(name='Label'),
            messageTips?: string(name='MessageTips'),
            rate?: float(name='Rate'),
            rect?: {
              height?: long(name='Height'),
              left?: long(name='Left'),
              top?: long(name='Top'),
              width?: long(name='Width'),
            }(name='Rect'),
            suggestion?: string(name='Suggestion'),
          }
        ](name='Results'),
        taskId?: string(name='TaskId'),
      }
    ](name='Elements'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectLivingFaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectLivingFaceResponseBody(name='body'),
}

async function detectLivingFaceWithOptions(request: DetectLivingFaceRequest, runtime: Util.RuntimeOptions): DetectLivingFaceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.tasks)) {
    body['Tasks'] = request.tasks;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetectLivingFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectLivingFace(request: DetectLivingFaceRequest): DetectLivingFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectLivingFaceWithOptions(request, runtime);
}

async function detectLivingFaceAdvance(request: DetectLivingFaceAdvanceRequest, runtime: Util.RuntimeOptions): DetectLivingFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectLivingFaceReq = new DetectLivingFaceRequest{};
  OpenApiUtil.convert(request, detectLivingFaceReq);

  if(!Util.isUnset(request.tasks)) {
    var i : integer = 0;
    for (var item0 : request.tasks) {
      if(!Util.isUnset(item0.imageURLObject)) {
        authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
        ossConfig.accessKeyId = authResponse.body.accessKeyId;
        ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
        ossClient = new OSS(ossConfig);

        fileObj = new FileForm.FileField{
          filename = authResponse.body.objectKey,
          content = item0.imageURLObject,
          contentType = '',
        };
        ossHeader = new OSS.PostObjectRequest.header{
          accessKeyId = authResponse.body.accessKeyId,
          policy = authResponse.body.encodedPolicy,
          signature = authResponse.body.signature,
          key = authResponse.body.objectKey,
          file = fileObj,
          successActionStatus = '201',
        };
        uploadRequest = new OSS.PostObjectRequest{
          bucketName = authResponse.body.bucket,
          header = ossHeader,
        };
        ossClient.postObject(uploadRequest, ossRuntime);
        var tmp : DetectLivingFaceRequest.tasks = detectLivingFaceReq.tasks[i];
        tmp.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        i = Number.ltoi(Number.add(Number.itol(i), Number.itol(1)));
      }
    }
  }
  var detectLivingFaceResp = detectLivingFaceWithOptions(detectLivingFaceReq, runtime);
  return detectLivingFaceResp;
}

model DetectPedestrianRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectPedestrianAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
}

model DetectPedestrianResponseBody = {
  data?: {
    elements?: [ 
      {
        boxes?: [ int32 ](name='Boxes'),
        score?: float(name='Score'),
        type?: string(name='Type'),
      }
    ](name='Elements'),
    height?: int32(name='Height'),
    width?: int32(name='Width'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectPedestrianResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectPedestrianResponseBody(name='body'),
}

async function detectPedestrianWithOptions(request: DetectPedestrianRequest, runtime: Util.RuntimeOptions): DetectPedestrianResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetectPedestrian',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectPedestrian(request: DetectPedestrianRequest): DetectPedestrianResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectPedestrianWithOptions(request, runtime);
}

async function detectPedestrianAdvance(request: DetectPedestrianAdvanceRequest, runtime: Util.RuntimeOptions): DetectPedestrianResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectPedestrianReq = new DetectPedestrianRequest{};
  OpenApiUtil.convert(request, detectPedestrianReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectPedestrianReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var detectPedestrianResp = detectPedestrianWithOptions(detectPedestrianReq, runtime);
  return detectPedestrianResp;
}

model DetectPedestrianIntrusionRequest {
  detectRegion?: [ 
    {
      line?: {
        x1?: long(name='X1'),
        x2?: long(name='X2'),
        y1?: long(name='Y1'),
        y2?: long(name='Y2'),
      }(name='Line'),
      rect?: {
        bottom?: long(name='Bottom'),
        left?: long(name='Left'),
        right?: long(name='Right'),
        top?: long(name='Top'),
      }(name='Rect'),
    }
  ](name='DetectRegion'),
  imageURL?: string(name='ImageURL'),
  regionType?: string(name='RegionType'),
}

model DetectPedestrianIntrusionAdvanceRequest {
  detectRegion?: [ 
    {
      line?: {
        x1?: long(name='X1'),
        x2?: long(name='X2'),
        y1?: long(name='Y1'),
        y2?: long(name='Y2'),
      }(name='Line'),
      rect?: {
        bottom?: long(name='Bottom'),
        left?: long(name='Left'),
        right?: long(name='Right'),
        top?: long(name='Top'),
      }(name='Rect'),
    }
  ](name='DetectRegion'),
  imageURLObject?: readable(name='ImageURL'),
  regionType?: string(name='RegionType'),
}

model DetectPedestrianIntrusionShrinkRequest {
  detectRegionShrink?: string(name='DetectRegion'),
  imageURL?: string(name='ImageURL'),
  regionType?: string(name='RegionType'),
}

model DetectPedestrianIntrusionResponseBody = {
  data?: {
    elements?: [ 
      {
        box?: {
          bottom?: long(name='Bottom'),
          left?: long(name='Left'),
          right?: long(name='Right'),
          top?: long(name='Top'),
        }(name='Box'),
        boxId?: long(name='BoxId'),
        isIntrude?: boolean(name='IsIntrude'),
        score?: long(name='Score'),
        type?: string(name='Type'),
      }
    ](name='Elements'),
    imageHeight?: long(name='ImageHeight'),
    imageWidth?: long(name='ImageWidth'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectPedestrianIntrusionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectPedestrianIntrusionResponseBody(name='body'),
}

async function detectPedestrianIntrusionWithOptions(tmpReq: DetectPedestrianIntrusionRequest, runtime: Util.RuntimeOptions): DetectPedestrianIntrusionResponse {
  Util.validateModel(tmpReq);
  var request = new DetectPedestrianIntrusionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.detectRegion)) {
    request.detectRegionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.detectRegion, 'DetectRegion', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.detectRegionShrink)) {
    body['DetectRegion'] = request.detectRegionShrink;
  }
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  if (!Util.isUnset(request.regionType)) {
    body['RegionType'] = request.regionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetectPedestrianIntrusion',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectPedestrianIntrusion(request: DetectPedestrianIntrusionRequest): DetectPedestrianIntrusionResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectPedestrianIntrusionWithOptions(request, runtime);
}

async function detectPedestrianIntrusionAdvance(request: DetectPedestrianIntrusionAdvanceRequest, runtime: Util.RuntimeOptions): DetectPedestrianIntrusionResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectPedestrianIntrusionReq = new DetectPedestrianIntrusionRequest{};
  OpenApiUtil.convert(request, detectPedestrianIntrusionReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectPedestrianIntrusionReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var detectPedestrianIntrusionResp = detectPedestrianIntrusionWithOptions(detectPedestrianIntrusionReq, runtime);
  return detectPedestrianIntrusionResp;
}

model DetectVideoLivingFaceRequest {
  videoUrl?: string(name='VideoUrl'),
}

model DetectVideoLivingFaceAdvanceRequest {
  videoUrlObject?: readable(name='VideoUrl'),
}

model DetectVideoLivingFaceResponseBody = {
  data?: {
    elements?: [ 
      {
        faceConfidence?: float(name='FaceConfidence'),
        liveConfidence?: float(name='LiveConfidence'),
        rect?: [ int32 ](name='Rect'),
      }
    ](name='Elements'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectVideoLivingFaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectVideoLivingFaceResponseBody(name='body'),
}

async function detectVideoLivingFaceWithOptions(request: DetectVideoLivingFaceRequest, runtime: Util.RuntimeOptions): DetectVideoLivingFaceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.videoUrl)) {
    body['VideoUrl'] = request.videoUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetectVideoLivingFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectVideoLivingFace(request: DetectVideoLivingFaceRequest): DetectVideoLivingFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectVideoLivingFaceWithOptions(request, runtime);
}

async function detectVideoLivingFaceAdvance(request: DetectVideoLivingFaceAdvanceRequest, runtime: Util.RuntimeOptions): DetectVideoLivingFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectVideoLivingFaceReq = new DetectVideoLivingFaceRequest{};
  OpenApiUtil.convert(request, detectVideoLivingFaceReq);

  if(!Util.isUnset(request.videoUrlObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.videoUrlObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectVideoLivingFaceReq.videoUrl = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var detectVideoLivingFaceResp = detectVideoLivingFaceWithOptions(detectVideoLivingFaceReq, runtime);
  return detectVideoLivingFaceResp;
}

model EnhanceFaceRequest {
  imageURL?: string(name='ImageURL'),
}

model EnhanceFaceAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
}

model EnhanceFaceResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model EnhanceFaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnhanceFaceResponseBody(name='body'),
}

async function enhanceFaceWithOptions(request: EnhanceFaceRequest, runtime: Util.RuntimeOptions): EnhanceFaceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EnhanceFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enhanceFace(request: EnhanceFaceRequest): EnhanceFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return enhanceFaceWithOptions(request, runtime);
}

async function enhanceFaceAdvance(request: EnhanceFaceAdvanceRequest, runtime: Util.RuntimeOptions): EnhanceFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var enhanceFaceReq = new EnhanceFaceRequest{};
  OpenApiUtil.convert(request, enhanceFaceReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    enhanceFaceReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var enhanceFaceResp = enhanceFaceWithOptions(enhanceFaceReq, runtime);
  return enhanceFaceResp;
}

model ExtractFingerPrintRequest {
  imageData?: bytes(name='ImageData'),
  imageURL?: string(name='ImageURL'),
}

model ExtractFingerPrintAdvanceRequest {
  imageData?: bytes(name='ImageData'),
  imageURLObject?: readable(name='ImageURL'),
}

model ExtractFingerPrintResponseBody = {
  data?: {
    fingerPrint?: bytes(name='FingerPrint'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ExtractFingerPrintResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExtractFingerPrintResponseBody(name='body'),
}

async function extractFingerPrintWithOptions(request: ExtractFingerPrintRequest, runtime: Util.RuntimeOptions): ExtractFingerPrintResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageData)) {
    body['ImageData'] = request.imageData;
  }
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ExtractFingerPrint',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function extractFingerPrint(request: ExtractFingerPrintRequest): ExtractFingerPrintResponse {
  var runtime = new Util.RuntimeOptions{};
  return extractFingerPrintWithOptions(request, runtime);
}

async function extractFingerPrintAdvance(request: ExtractFingerPrintAdvanceRequest, runtime: Util.RuntimeOptions): ExtractFingerPrintResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var extractFingerPrintReq = new ExtractFingerPrintRequest{};
  OpenApiUtil.convert(request, extractFingerPrintReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    extractFingerPrintReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var extractFingerPrintResp = extractFingerPrintWithOptions(extractFingerPrintReq, runtime);
  return extractFingerPrintResp;
}

model ExtractPedestrianFeatureAttrRequest {
  imageURL?: string(name='ImageURL'),
  mode?: string(name='Mode'),
  serviceVersion?: string(name='ServiceVersion'),
}

model ExtractPedestrianFeatureAttrAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
  mode?: string(name='Mode'),
  serviceVersion?: string(name='ServiceVersion'),
}

model ExtractPedestrianFeatureAttrResponseBody = {
  data?: {
    age?: string(name='Age'),
    ageScore?: float(name='AgeScore'),
    feature?: string(name='Feature'),
    gender?: string(name='Gender'),
    genderScore?: float(name='GenderScore'),
    hair?: string(name='Hair'),
    hairScore?: float(name='HairScore'),
    lowerColor?: string(name='LowerColor'),
    lowerColorScore?: float(name='LowerColorScore'),
    lowerType?: string(name='LowerType'),
    lowerTypeScore?: float(name='LowerTypeScore'),
    objType?: string(name='ObjType'),
    objTypeScore?: float(name='ObjTypeScore'),
    orientation?: string(name='Orientation'),
    orientationScore?: float(name='OrientationScore'),
    qualityScore?: float(name='QualityScore'),
    upperColor?: string(name='UpperColor'),
    upperColorScore?: float(name='UpperColorScore'),
    upperType?: string(name='UpperType'),
    upperTypeScore?: float(name='UpperTypeScore'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ExtractPedestrianFeatureAttrResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExtractPedestrianFeatureAttrResponseBody(name='body'),
}

async function extractPedestrianFeatureAttrWithOptions(request: ExtractPedestrianFeatureAttrRequest, runtime: Util.RuntimeOptions): ExtractPedestrianFeatureAttrResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  if (!Util.isUnset(request.mode)) {
    body['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.serviceVersion)) {
    body['ServiceVersion'] = request.serviceVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ExtractPedestrianFeatureAttr',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function extractPedestrianFeatureAttr(request: ExtractPedestrianFeatureAttrRequest): ExtractPedestrianFeatureAttrResponse {
  var runtime = new Util.RuntimeOptions{};
  return extractPedestrianFeatureAttrWithOptions(request, runtime);
}

async function extractPedestrianFeatureAttrAdvance(request: ExtractPedestrianFeatureAttrAdvanceRequest, runtime: Util.RuntimeOptions): ExtractPedestrianFeatureAttrResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var extractPedestrianFeatureAttrReq = new ExtractPedestrianFeatureAttrRequest{};
  OpenApiUtil.convert(request, extractPedestrianFeatureAttrReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    extractPedestrianFeatureAttrReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var extractPedestrianFeatureAttrResp = extractPedestrianFeatureAttrWithOptions(extractPedestrianFeatureAttrReq, runtime);
  return extractPedestrianFeatureAttrResp;
}

model FaceBeautyRequest {
  imageURL?: string(name='ImageURL'),
  sharp?: float(name='Sharp'),
  smooth?: float(name='Smooth'),
  white?: float(name='White'),
}

model FaceBeautyAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
  sharp?: float(name='Sharp'),
  smooth?: float(name='Smooth'),
  white?: float(name='White'),
}

model FaceBeautyResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model FaceBeautyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FaceBeautyResponseBody(name='body'),
}

async function faceBeautyWithOptions(request: FaceBeautyRequest, runtime: Util.RuntimeOptions): FaceBeautyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  if (!Util.isUnset(request.sharp)) {
    body['Sharp'] = request.sharp;
  }
  if (!Util.isUnset(request.smooth)) {
    body['Smooth'] = request.smooth;
  }
  if (!Util.isUnset(request.white)) {
    body['White'] = request.white;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FaceBeauty',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function faceBeauty(request: FaceBeautyRequest): FaceBeautyResponse {
  var runtime = new Util.RuntimeOptions{};
  return faceBeautyWithOptions(request, runtime);
}

async function faceBeautyAdvance(request: FaceBeautyAdvanceRequest, runtime: Util.RuntimeOptions): FaceBeautyResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var faceBeautyReq = new FaceBeautyRequest{};
  OpenApiUtil.convert(request, faceBeautyReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    faceBeautyReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var faceBeautyResp = faceBeautyWithOptions(faceBeautyReq, runtime);
  return faceBeautyResp;
}

model FaceFilterRequest {
  imageURL?: string(name='ImageURL'),
  resourceType?: string(name='ResourceType'),
  strength?: float(name='Strength'),
}

model FaceFilterAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
  resourceType?: string(name='ResourceType'),
  strength?: float(name='Strength'),
}

model FaceFilterResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model FaceFilterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FaceFilterResponseBody(name='body'),
}

async function faceFilterWithOptions(request: FaceFilterRequest, runtime: Util.RuntimeOptions): FaceFilterResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.strength)) {
    body['Strength'] = request.strength;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FaceFilter',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function faceFilter(request: FaceFilterRequest): FaceFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return faceFilterWithOptions(request, runtime);
}

async function faceFilterAdvance(request: FaceFilterAdvanceRequest, runtime: Util.RuntimeOptions): FaceFilterResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var faceFilterReq = new FaceFilterRequest{};
  OpenApiUtil.convert(request, faceFilterReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    faceFilterReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var faceFilterResp = faceFilterWithOptions(faceFilterReq, runtime);
  return faceFilterResp;
}

model FaceMakeupRequest {
  imageURL?: string(name='ImageURL'),
  makeupType?: string(name='MakeupType'),
  resourceType?: string(name='ResourceType'),
  strength?: float(name='Strength'),
}

model FaceMakeupAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
  makeupType?: string(name='MakeupType'),
  resourceType?: string(name='ResourceType'),
  strength?: float(name='Strength'),
}

model FaceMakeupResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model FaceMakeupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FaceMakeupResponseBody(name='body'),
}

async function faceMakeupWithOptions(request: FaceMakeupRequest, runtime: Util.RuntimeOptions): FaceMakeupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  if (!Util.isUnset(request.makeupType)) {
    body['MakeupType'] = request.makeupType;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.strength)) {
    body['Strength'] = request.strength;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FaceMakeup',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function faceMakeup(request: FaceMakeupRequest): FaceMakeupResponse {
  var runtime = new Util.RuntimeOptions{};
  return faceMakeupWithOptions(request, runtime);
}

async function faceMakeupAdvance(request: FaceMakeupAdvanceRequest, runtime: Util.RuntimeOptions): FaceMakeupResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var faceMakeupReq = new FaceMakeupRequest{};
  OpenApiUtil.convert(request, faceMakeupReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    faceMakeupReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var faceMakeupResp = faceMakeupWithOptions(faceMakeupReq, runtime);
  return faceMakeupResp;
}

model FaceTidyupRequest {
  imageURL?: string(name='ImageURL'),
  shapeType?: int32(name='ShapeType'),
  strength?: float(name='Strength'),
}

model FaceTidyupAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
  shapeType?: int32(name='ShapeType'),
  strength?: float(name='Strength'),
}

model FaceTidyupResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model FaceTidyupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FaceTidyupResponseBody(name='body'),
}

async function faceTidyupWithOptions(request: FaceTidyupRequest, runtime: Util.RuntimeOptions): FaceTidyupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  if (!Util.isUnset(request.shapeType)) {
    body['ShapeType'] = request.shapeType;
  }
  if (!Util.isUnset(request.strength)) {
    body['Strength'] = request.strength;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FaceTidyup',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function faceTidyup(request: FaceTidyupRequest): FaceTidyupResponse {
  var runtime = new Util.RuntimeOptions{};
  return faceTidyupWithOptions(request, runtime);
}

async function faceTidyupAdvance(request: FaceTidyupAdvanceRequest, runtime: Util.RuntimeOptions): FaceTidyupResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var faceTidyupReq = new FaceTidyupRequest{};
  OpenApiUtil.convert(request, faceTidyupReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    faceTidyupReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var faceTidyupResp = faceTidyupWithOptions(faceTidyupReq, runtime);
  return faceTidyupResp;
}

model GenRealPersonVerificationTokenRequest {
  certificateName?: string(name='CertificateName'),
  certificateNumber?: string(name='CertificateNumber'),
  metaInfo?: string(name='MetaInfo'),
}

model GenRealPersonVerificationTokenResponseBody = {
  data?: {
    verificationToken?: string(name='VerificationToken'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GenRealPersonVerificationTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenRealPersonVerificationTokenResponseBody(name='body'),
}

async function genRealPersonVerificationTokenWithOptions(request: GenRealPersonVerificationTokenRequest, runtime: Util.RuntimeOptions): GenRealPersonVerificationTokenResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.certificateName)) {
    body['CertificateName'] = request.certificateName;
  }
  if (!Util.isUnset(request.certificateNumber)) {
    body['CertificateNumber'] = request.certificateNumber;
  }
  if (!Util.isUnset(request.metaInfo)) {
    body['MetaInfo'] = request.metaInfo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GenRealPersonVerificationToken',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function genRealPersonVerificationToken(request: GenRealPersonVerificationTokenRequest): GenRealPersonVerificationTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return genRealPersonVerificationTokenWithOptions(request, runtime);
}

model GenerateHumanAnimeStyleRequest {
  algoType?: string(name='AlgoType'),
  imageURL?: string(name='ImageURL'),
}

model GenerateHumanAnimeStyleAdvanceRequest {
  algoType?: string(name='AlgoType'),
  imageURLObject?: readable(name='ImageURL'),
}

model GenerateHumanAnimeStyleResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GenerateHumanAnimeStyleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateHumanAnimeStyleResponseBody(name='body'),
}

async function generateHumanAnimeStyleWithOptions(request: GenerateHumanAnimeStyleRequest, runtime: Util.RuntimeOptions): GenerateHumanAnimeStyleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algoType)) {
    query['AlgoType'] = request.algoType;
  }
  if (!Util.isUnset(request.imageURL)) {
    query['ImageURL'] = request.imageURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateHumanAnimeStyle',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateHumanAnimeStyle(request: GenerateHumanAnimeStyleRequest): GenerateHumanAnimeStyleResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateHumanAnimeStyleWithOptions(request, runtime);
}

async function generateHumanAnimeStyleAdvance(request: GenerateHumanAnimeStyleAdvanceRequest, runtime: Util.RuntimeOptions): GenerateHumanAnimeStyleResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var generateHumanAnimeStyleReq = new GenerateHumanAnimeStyleRequest{};
  OpenApiUtil.convert(request, generateHumanAnimeStyleReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    generateHumanAnimeStyleReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var generateHumanAnimeStyleResp = generateHumanAnimeStyleWithOptions(generateHumanAnimeStyleReq, runtime);
  return generateHumanAnimeStyleResp;
}

model GenerateHumanSketchStyleRequest {
  imageURL?: string(name='ImageURL'),
  returnType?: string(name='ReturnType'),
}

model GenerateHumanSketchStyleAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
  returnType?: string(name='ReturnType'),
}

model GenerateHumanSketchStyleResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GenerateHumanSketchStyleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateHumanSketchStyleResponseBody(name='body'),
}

async function generateHumanSketchStyleWithOptions(request: GenerateHumanSketchStyleRequest, runtime: Util.RuntimeOptions): GenerateHumanSketchStyleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  if (!Util.isUnset(request.returnType)) {
    body['ReturnType'] = request.returnType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GenerateHumanSketchStyle',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateHumanSketchStyle(request: GenerateHumanSketchStyleRequest): GenerateHumanSketchStyleResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateHumanSketchStyleWithOptions(request, runtime);
}

async function generateHumanSketchStyleAdvance(request: GenerateHumanSketchStyleAdvanceRequest, runtime: Util.RuntimeOptions): GenerateHumanSketchStyleResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var generateHumanSketchStyleReq = new GenerateHumanSketchStyleRequest{};
  OpenApiUtil.convert(request, generateHumanSketchStyleReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    generateHumanSketchStyleReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var generateHumanSketchStyleResp = generateHumanSketchStyleWithOptions(generateHumanSketchStyleReq, runtime);
  return generateHumanSketchStyleResp;
}

model GetBodyPersonRequest {
  dbId?: long(name='DbId'),
  personId?: long(name='PersonId'),
}

model GetBodyPersonResponseBody = {
  data?: {
    dbId?: long(name='DbId'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    traceCount?: long(name='TraceCount'),
    traceList?: [ 
      {
        extraData?: string(name='ExtraData'),
        id?: long(name='Id'),
      }
    ](name='TraceList'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetBodyPersonResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBodyPersonResponseBody(name='body'),
}

async function getBodyPersonWithOptions(request: GetBodyPersonRequest, runtime: Util.RuntimeOptions): GetBodyPersonResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetBodyPerson',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getBodyPerson(request: GetBodyPersonRequest): GetBodyPersonResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBodyPersonWithOptions(request, runtime);
}

model GetFaceEntityRequest {
  dbName?: string(name='DbName'),
  entityId?: string(name='EntityId'),
}

model GetFaceEntityResponseBody = {
  data?: {
    dbName?: string(name='DbName'),
    entityId?: string(name='EntityId'),
    faces?: [ 
      {
        faceId?: string(name='FaceId'),
      }
    ](name='Faces'),
    labels?: string(name='Labels'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetFaceEntityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFaceEntityResponseBody(name='body'),
}

async function getFaceEntityWithOptions(request: GetFaceEntityRequest, runtime: Util.RuntimeOptions): GetFaceEntityResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dbName)) {
    body['DbName'] = request.dbName;
  }
  if (!Util.isUnset(request.entityId)) {
    body['EntityId'] = request.entityId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetFaceEntity',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getFaceEntity(request: GetFaceEntityRequest): GetFaceEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFaceEntityWithOptions(request, runtime);
}

model GetRealPersonVerificationResultRequest {
  verificationToken?: string(name='VerificationToken'),
}

model GetRealPersonVerificationResultResponseBody = {
  data?: {
    passed?: boolean(name='Passed'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetRealPersonVerificationResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRealPersonVerificationResultResponseBody(name='body'),
}

async function getRealPersonVerificationResultWithOptions(request: GetRealPersonVerificationResultRequest, runtime: Util.RuntimeOptions): GetRealPersonVerificationResultResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.verificationToken)) {
    body['VerificationToken'] = request.verificationToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetRealPersonVerificationResult',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRealPersonVerificationResult(request: GetRealPersonVerificationResultRequest): GetRealPersonVerificationResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRealPersonVerificationResultWithOptions(request, runtime);
}

model HandPostureRequest {
  imageURL?: string(name='ImageURL'),
}

model HandPostureAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
}

model HandPostureResponseBody = {
  data?: {
    metaObject?: {
      height?: int32(name='Height'),
      width?: int32(name='Width'),
    }(name='MetaObject'),
    outputs?: [ 
      {
        handCount?: int32(name='HandCount'),
        results?: [ 
          {
            box?: {
              confident?: float(name='Confident'),
              positions?: [ 
                {
                  points?: [ float ](name='Points'),
                }
              ](name='Positions'),
            }(name='Box'),
            hands?: {
              confident?: float(name='Confident'),
              keyPoints?: [ 
                {
                  label?: string(name='Label'),
                  positions?: [ 
                    {
                      points?: [ float ](name='Points'),
                    }
                  ](name='Positions'),
                }
              ](name='KeyPoints'),
            }(name='Hands'),
          }
        ](name='Results'),
      }
    ](name='Outputs'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model HandPostureResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: HandPostureResponseBody(name='body'),
}

async function handPostureWithOptions(request: HandPostureRequest, runtime: Util.RuntimeOptions): HandPostureResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'HandPosture',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function handPosture(request: HandPostureRequest): HandPostureResponse {
  var runtime = new Util.RuntimeOptions{};
  return handPostureWithOptions(request, runtime);
}

async function handPostureAdvance(request: HandPostureAdvanceRequest, runtime: Util.RuntimeOptions): HandPostureResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var handPostureReq = new HandPostureRequest{};
  OpenApiUtil.convert(request, handPostureReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    handPostureReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var handPostureResp = handPostureWithOptions(handPostureReq, runtime);
  return handPostureResp;
}

model LiquifyFaceRequest {
  imageURL?: string(name='ImageURL'),
  slimDegree?: float(name='SlimDegree'),
}

model LiquifyFaceAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
  slimDegree?: float(name='SlimDegree'),
}

model LiquifyFaceResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model LiquifyFaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LiquifyFaceResponseBody(name='body'),
}

async function liquifyFaceWithOptions(request: LiquifyFaceRequest, runtime: Util.RuntimeOptions): LiquifyFaceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  if (!Util.isUnset(request.slimDegree)) {
    body['SlimDegree'] = request.slimDegree;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'LiquifyFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function liquifyFace(request: LiquifyFaceRequest): LiquifyFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return liquifyFaceWithOptions(request, runtime);
}

async function liquifyFaceAdvance(request: LiquifyFaceAdvanceRequest, runtime: Util.RuntimeOptions): LiquifyFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var liquifyFaceReq = new LiquifyFaceRequest{};
  OpenApiUtil.convert(request, liquifyFaceReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    liquifyFaceReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var liquifyFaceResp = liquifyFaceWithOptions(liquifyFaceReq, runtime);
  return liquifyFaceResp;
}

model ListBodyDbsRequest {
  limit?: long(name='Limit'),
  offset?: long(name='Offset'),
}

model ListBodyDbsResponseBody = {
  data?: {
    dbList?: [ 
      {
        id?: long(name='Id'),
        name?: string(name='Name'),
      }
    ](name='DbList'),
    total?: long(name='Total'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListBodyDbsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListBodyDbsResponseBody(name='body'),
}

async function listBodyDbsWithOptions(request: ListBodyDbsRequest, runtime: Util.RuntimeOptions): ListBodyDbsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListBodyDbs',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listBodyDbs(request: ListBodyDbsRequest): ListBodyDbsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBodyDbsWithOptions(request, runtime);
}

model ListBodyPersonRequest {
  dbId?: long(name='DbId'),
  limit?: long(name='Limit'),
  offset?: long(name='Offset'),
}

model ListBodyPersonResponseBody = {
  data?: {
    personList?: [ 
      {
        dbId?: long(name='DbId'),
        id?: long(name='Id'),
        name?: string(name='Name'),
        traceCount?: long(name='TraceCount'),
      }
    ](name='PersonList'),
    total?: long(name='Total'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListBodyPersonResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListBodyPersonResponseBody(name='body'),
}

async function listBodyPersonWithOptions(request: ListBodyPersonRequest, runtime: Util.RuntimeOptions): ListBodyPersonResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListBodyPerson',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listBodyPerson(request: ListBodyPersonRequest): ListBodyPersonResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBodyPersonWithOptions(request, runtime);
}

model ListFaceDbsRequest {
  limit?: long(name='Limit'),
  offset?: long(name='Offset'),
}

model ListFaceDbsResponseBody = {
  data?: {
    dbList?: [ 
      {
        name?: string(name='Name'),
      }
    ](name='DbList'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListFaceDbsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFaceDbsResponseBody(name='body'),
}

async function listFaceDbsWithOptions(request: ListFaceDbsRequest, runtime: Util.RuntimeOptions): ListFaceDbsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    body['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.offset)) {
    body['Offset'] = request.offset;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListFaceDbs',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFaceDbs(request: ListFaceDbsRequest): ListFaceDbsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFaceDbsWithOptions(request, runtime);
}

model ListFaceEntitiesRequest {
  dbName?: string(name='DbName'),
  entityIdPrefix?: string(name='EntityIdPrefix'),
  labels?: string(name='Labels'),
  limit?: int32(name='Limit'),
  offset?: int32(name='Offset'),
  order?: string(name='Order'),
  token?: string(name='Token'),
}

model ListFaceEntitiesResponseBody = {
  data?: {
    entities?: [ 
      {
        createdAt?: long(name='CreatedAt'),
        dbName?: string(name='DbName'),
        entityId?: string(name='EntityId'),
        faceCount?: int32(name='FaceCount'),
        labels?: string(name='Labels'),
        updatedAt?: long(name='UpdatedAt'),
      }
    ](name='Entities'),
    token?: string(name='Token'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListFaceEntitiesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFaceEntitiesResponseBody(name='body'),
}

async function listFaceEntitiesWithOptions(request: ListFaceEntitiesRequest, runtime: Util.RuntimeOptions): ListFaceEntitiesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dbName)) {
    body['DbName'] = request.dbName;
  }
  if (!Util.isUnset(request.entityIdPrefix)) {
    body['EntityIdPrefix'] = request.entityIdPrefix;
  }
  if (!Util.isUnset(request.labels)) {
    body['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.limit)) {
    body['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.offset)) {
    body['Offset'] = request.offset;
  }
  if (!Util.isUnset(request.order)) {
    body['Order'] = request.order;
  }
  if (!Util.isUnset(request.token)) {
    body['Token'] = request.token;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListFaceEntities',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFaceEntities(request: ListFaceEntitiesRequest): ListFaceEntitiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFaceEntitiesWithOptions(request, runtime);
}

model MergeImageFaceRequest {
  imageURL?: string(name='ImageURL'),
  templateId?: string(name='TemplateId'),
  userId?: string(name='UserId'),
}

model MergeImageFaceAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
  templateId?: string(name='TemplateId'),
  userId?: string(name='UserId'),
}

model MergeImageFaceResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model MergeImageFaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MergeImageFaceResponseBody(name='body'),
}

async function mergeImageFaceWithOptions(request: MergeImageFaceRequest, runtime: Util.RuntimeOptions): MergeImageFaceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  if (!Util.isUnset(request.templateId)) {
    body['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'MergeImageFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function mergeImageFace(request: MergeImageFaceRequest): MergeImageFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return mergeImageFaceWithOptions(request, runtime);
}

async function mergeImageFaceAdvance(request: MergeImageFaceAdvanceRequest, runtime: Util.RuntimeOptions): MergeImageFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var mergeImageFaceReq = new MergeImageFaceRequest{};
  OpenApiUtil.convert(request, mergeImageFaceReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    mergeImageFaceReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var mergeImageFaceResp = mergeImageFaceWithOptions(mergeImageFaceReq, runtime);
  return mergeImageFaceResp;
}

model MonitorExaminationRequest {
  imageURL?: string(name='ImageURL'),
  type?: long(name='Type'),
}

model MonitorExaminationAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
  type?: long(name='Type'),
}

model MonitorExaminationResponseBody = {
  data?: {
    chatScore?: float(name='ChatScore'),
    faceInfo?: {
      completeness?: float(name='Completeness'),
      faceNumber?: long(name='FaceNumber'),
      pose?: {
        pitch?: float(name='Pitch'),
        roll?: float(name='Roll'),
        yaw?: float(name='Yaw'),
      }(name='Pose'),
    }(name='FaceInfo'),
    personInfo?: {
      cellPhone?: {
        score?: float(name='Score'),
        threshold?: float(name='Threshold'),
      }(name='CellPhone'),
      earPhone?: {
        score?: float(name='Score'),
        threshold?: float(name='Threshold'),
      }(name='EarPhone'),
      personNumber?: long(name='PersonNumber'),
    }(name='PersonInfo'),
    threshold?: float(name='Threshold'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model MonitorExaminationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorExaminationResponseBody(name='body'),
}

async function monitorExaminationWithOptions(request: MonitorExaminationRequest, runtime: Util.RuntimeOptions): MonitorExaminationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'MonitorExamination',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function monitorExamination(request: MonitorExaminationRequest): MonitorExaminationResponse {
  var runtime = new Util.RuntimeOptions{};
  return monitorExaminationWithOptions(request, runtime);
}

async function monitorExaminationAdvance(request: MonitorExaminationAdvanceRequest, runtime: Util.RuntimeOptions): MonitorExaminationResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var monitorExaminationReq = new MonitorExaminationRequest{};
  OpenApiUtil.convert(request, monitorExaminationReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    monitorExaminationReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var monitorExaminationResp = monitorExaminationWithOptions(monitorExaminationReq, runtime);
  return monitorExaminationResp;
}

model PedestrianDetectAttributeRequest {
  imageURL?: string(name='ImageURL'),
}

model PedestrianDetectAttributeAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
}

model PedestrianDetectAttributeResponseBody = {
  data?: {
    attributes?: [ 
      {
        age?: {
          name?: string(name='Name'),
          score?: float(name='Score'),
        }(name='Age'),
        backpack?: {
          name?: string(name='Name'),
          score?: float(name='Score'),
        }(name='Backpack'),
        gender?: {
          name?: string(name='Name'),
          score?: float(name='Score'),
        }(name='Gender'),
        glasses?: {
          name?: string(name='Name'),
          score?: float(name='Score'),
        }(name='Glasses'),
        handbag?: {
          name?: string(name='Name'),
          score?: float(name='Score'),
        }(name='Handbag'),
        hat?: {
          name?: string(name='Name'),
          score?: float(name='Score'),
        }(name='Hat'),
        lowerColor?: {
          name?: string(name='Name'),
          score?: float(name='Score'),
        }(name='LowerColor'),
        lowerWear?: {
          name?: string(name='Name'),
          score?: float(name='Score'),
        }(name='LowerWear'),
        orient?: {
          name?: string(name='Name'),
          score?: float(name='Score'),
        }(name='Orient'),
        shoulderBag?: {
          name?: string(name='Name'),
          score?: float(name='Score'),
        }(name='ShoulderBag'),
        upperColor?: {
          name?: string(name='Name'),
          score?: float(name='Score'),
        }(name='UpperColor'),
        upperWear?: {
          name?: string(name='Name'),
          score?: float(name='Score'),
        }(name='UpperWear'),
      }
    ](name='Attributes'),
    boxes?: [ 
      {
        bottomRightX?: float(name='BottomRightX'),
        bottomRightY?: float(name='BottomRightY'),
        score?: float(name='Score'),
        topLeftX?: float(name='TopLeftX'),
        topLeftY?: float(name='TopLeftY'),
      }
    ](name='Boxes'),
    height?: long(name='Height'),
    personNumber?: int32(name='PersonNumber'),
    width?: long(name='Width'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model PedestrianDetectAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PedestrianDetectAttributeResponseBody(name='body'),
}

async function pedestrianDetectAttributeWithOptions(request: PedestrianDetectAttributeRequest, runtime: Util.RuntimeOptions): PedestrianDetectAttributeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PedestrianDetectAttribute',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pedestrianDetectAttribute(request: PedestrianDetectAttributeRequest): PedestrianDetectAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return pedestrianDetectAttributeWithOptions(request, runtime);
}

async function pedestrianDetectAttributeAdvance(request: PedestrianDetectAttributeAdvanceRequest, runtime: Util.RuntimeOptions): PedestrianDetectAttributeResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var pedestrianDetectAttributeReq = new PedestrianDetectAttributeRequest{};
  OpenApiUtil.convert(request, pedestrianDetectAttributeReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    pedestrianDetectAttributeReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var pedestrianDetectAttributeResp = pedestrianDetectAttributeWithOptions(pedestrianDetectAttributeReq, runtime);
  return pedestrianDetectAttributeResp;
}

model QueryFaceImageTemplateRequest {
  templateId?: string(name='TemplateId'),
  userId?: string(name='UserId'),
}

model QueryFaceImageTemplateResponseBody = {
  data?: {
    elements?: [ 
      {
        createTime?: string(name='CreateTime'),
        templateId?: string(name='TemplateId'),
        templateURL?: string(name='TemplateURL'),
        updateTime?: string(name='UpdateTime'),
        userId?: string(name='UserId'),
      }
    ](name='Elements'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryFaceImageTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryFaceImageTemplateResponseBody(name='body'),
}

async function queryFaceImageTemplateWithOptions(request: QueryFaceImageTemplateRequest, runtime: Util.RuntimeOptions): QueryFaceImageTemplateResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryFaceImageTemplate',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryFaceImageTemplate(request: QueryFaceImageTemplateRequest): QueryFaceImageTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFaceImageTemplateWithOptions(request, runtime);
}

model RecognizeActionRequest {
  type?: int32(name='Type'),
  URLList?: [ 
    {
      URL?: string(name='URL'),
      imageData?: bytes(name='imageData'),
    }
  ](name='URLList'),
  videoData?: bytes(name='VideoData'),
  videoUrl?: string(name='VideoUrl'),
}

model RecognizeActionAdvanceRequest {
  type?: int32(name='Type'),
  URLList?: [ 
    {
      URLObject?: readable(name='URL'),
      imageData?: bytes(name='imageData'),
    }
  ](name='URLList'),
  videoData?: bytes(name='VideoData'),
  videoUrl?: string(name='VideoUrl'),
}

model RecognizeActionResponseBody = {
  data?: {
    elements?: [ 
      {
        boxes?: [ 
          {
            box?: [ int32 ](name='Box'),
          }
        ](name='Boxes'),
        labels?: [ string ](name='Labels'),
        scores?: [ float ](name='Scores'),
        timestamp?: int32(name='Timestamp'),
      }
    ](name='Elements'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model RecognizeActionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecognizeActionResponseBody(name='body'),
}

async function recognizeActionWithOptions(request: RecognizeActionRequest, runtime: Util.RuntimeOptions): RecognizeActionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  if (!Util.isUnset(request.URLList)) {
    body['URLList'] = request.URLList;
  }
  if (!Util.isUnset(request.videoData)) {
    body['VideoData'] = request.videoData;
  }
  if (!Util.isUnset(request.videoUrl)) {
    body['VideoUrl'] = request.videoUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RecognizeAction',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recognizeAction(request: RecognizeActionRequest): RecognizeActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizeActionWithOptions(request, runtime);
}

async function recognizeActionAdvance(request: RecognizeActionAdvanceRequest, runtime: Util.RuntimeOptions): RecognizeActionResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var recognizeActionReq = new RecognizeActionRequest{};
  OpenApiUtil.convert(request, recognizeActionReq);

  if(!Util.isUnset(request.URLList)) {
    var i : integer = 0;
    for (var item0 : request.URLList) {
      if(!Util.isUnset(item0.URLObject)) {
        authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
        ossConfig.accessKeyId = authResponse.body.accessKeyId;
        ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
        ossClient = new OSS(ossConfig);

        fileObj = new FileForm.FileField{
          filename = authResponse.body.objectKey,
          content = item0.URLObject,
          contentType = '',
        };
        ossHeader = new OSS.PostObjectRequest.header{
          accessKeyId = authResponse.body.accessKeyId,
          policy = authResponse.body.encodedPolicy,
          signature = authResponse.body.signature,
          key = authResponse.body.objectKey,
          file = fileObj,
          successActionStatus = '201',
        };
        uploadRequest = new OSS.PostObjectRequest{
          bucketName = authResponse.body.bucket,
          header = ossHeader,
        };
        ossClient.postObject(uploadRequest, ossRuntime);
        var tmp : RecognizeActionRequest.URLList = recognizeActionReq.URLList[i];
        tmp.URL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        i = Number.ltoi(Number.add(Number.itol(i), Number.itol(1)));
      }
    }
  }
  var recognizeActionResp = recognizeActionWithOptions(recognizeActionReq, runtime);
  return recognizeActionResp;
}

model RecognizeExpressionRequest {
  imageURL?: string(name='ImageURL'),
}

model RecognizeExpressionAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
}

model RecognizeExpressionResponseBody = {
  data?: {
    elements?: [ 
      {
        expression?: string(name='Expression'),
        faceProbability?: float(name='FaceProbability'),
        faceRectangle?: {
          height?: int32(name='Height'),
          left?: int32(name='Left'),
          top?: int32(name='Top'),
          width?: int32(name='Width'),
        }(name='FaceRectangle'),
      }
    ](name='Elements'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model RecognizeExpressionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecognizeExpressionResponseBody(name='body'),
}

async function recognizeExpressionWithOptions(request: RecognizeExpressionRequest, runtime: Util.RuntimeOptions): RecognizeExpressionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RecognizeExpression',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recognizeExpression(request: RecognizeExpressionRequest): RecognizeExpressionResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizeExpressionWithOptions(request, runtime);
}

async function recognizeExpressionAdvance(request: RecognizeExpressionAdvanceRequest, runtime: Util.RuntimeOptions): RecognizeExpressionResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var recognizeExpressionReq = new RecognizeExpressionRequest{};
  OpenApiUtil.convert(request, recognizeExpressionReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    recognizeExpressionReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var recognizeExpressionResp = recognizeExpressionWithOptions(recognizeExpressionReq, runtime);
  return recognizeExpressionResp;
}

model RecognizeFaceRequest {
  age?: boolean(name='Age'),
  beauty?: boolean(name='Beauty'),
  expression?: boolean(name='Expression'),
  gender?: boolean(name='Gender'),
  glass?: boolean(name='Glass'),
  hat?: boolean(name='Hat'),
  imageURL?: string(name='ImageURL'),
  mask?: boolean(name='Mask'),
  maxFaceNumber?: long(name='MaxFaceNumber'),
  quality?: boolean(name='Quality'),
}

model RecognizeFaceAdvanceRequest {
  age?: boolean(name='Age'),
  beauty?: boolean(name='Beauty'),
  expression?: boolean(name='Expression'),
  gender?: boolean(name='Gender'),
  glass?: boolean(name='Glass'),
  hat?: boolean(name='Hat'),
  imageURLObject?: readable(name='ImageURL'),
  mask?: boolean(name='Mask'),
  maxFaceNumber?: long(name='MaxFaceNumber'),
  quality?: boolean(name='Quality'),
}

model RecognizeFaceResponseBody = {
  data?: {
    ageList?: [ int32 ](name='AgeList'),
    beautyList?: [ float ](name='BeautyList'),
    denseFeatureLength?: int32(name='DenseFeatureLength'),
    denseFeatures?: [ string ](name='DenseFeatures'),
    expressions?: [ int32 ](name='Expressions'),
    faceCount?: int32(name='FaceCount'),
    faceProbabilityList?: [ float ](name='FaceProbabilityList'),
    faceRectangles?: [ int32 ](name='FaceRectangles'),
    genderList?: [ int32 ](name='GenderList'),
    glasses?: [ int32 ](name='Glasses'),
    hatList?: [ int32 ](name='HatList'),
    landmarkCount?: int32(name='LandmarkCount'),
    landmarks?: [ float ](name='Landmarks'),
    masks?: [ long ](name='Masks'),
    poseList?: [ float ](name='PoseList'),
    pupils?: [ float ](name='Pupils'),
    qualities?: {
      blurList?: [ float ](name='BlurList'),
      fnfList?: [ float ](name='FnfList'),
      glassList?: [ float ](name='GlassList'),
      illuList?: [ float ](name='IlluList'),
      maskList?: [ float ](name='MaskList'),
      noiseList?: [ float ](name='NoiseList'),
      poseList?: [ float ](name='PoseList'),
      scoreList?: [ float ](name='ScoreList'),
    }(name='Qualities'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model RecognizeFaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecognizeFaceResponseBody(name='body'),
}

async function recognizeFaceWithOptions(request: RecognizeFaceRequest, runtime: Util.RuntimeOptions): RecognizeFaceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.age)) {
    body['Age'] = request.age;
  }
  if (!Util.isUnset(request.beauty)) {
    body['Beauty'] = request.beauty;
  }
  if (!Util.isUnset(request.expression)) {
    body['Expression'] = request.expression;
  }
  if (!Util.isUnset(request.gender)) {
    body['Gender'] = request.gender;
  }
  if (!Util.isUnset(request.glass)) {
    body['Glass'] = request.glass;
  }
  if (!Util.isUnset(request.hat)) {
    body['Hat'] = request.hat;
  }
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  if (!Util.isUnset(request.mask)) {
    body['Mask'] = request.mask;
  }
  if (!Util.isUnset(request.maxFaceNumber)) {
    body['MaxFaceNumber'] = request.maxFaceNumber;
  }
  if (!Util.isUnset(request.quality)) {
    body['Quality'] = request.quality;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RecognizeFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recognizeFace(request: RecognizeFaceRequest): RecognizeFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizeFaceWithOptions(request, runtime);
}

async function recognizeFaceAdvance(request: RecognizeFaceAdvanceRequest, runtime: Util.RuntimeOptions): RecognizeFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var recognizeFaceReq = new RecognizeFaceRequest{};
  OpenApiUtil.convert(request, recognizeFaceReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    recognizeFaceReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var recognizeFaceResp = recognizeFaceWithOptions(recognizeFaceReq, runtime);
  return recognizeFaceResp;
}

model RecognizeHandGestureRequest {
  appId?: string(name='AppId'),
  gestureType?: string(name='GestureType'),
  imageURL?: string(name='ImageURL'),
}

model RecognizeHandGestureAdvanceRequest {
  appId?: string(name='AppId'),
  gestureType?: string(name='GestureType'),
  imageURLObject?: readable(name='ImageURL'),
}

model RecognizeHandGestureResponseBody = {
  data?: {
    height?: long(name='Height'),
    score?: float(name='Score'),
    type?: string(name='Type'),
    width?: long(name='Width'),
    x?: long(name='X'),
    y?: long(name='Y'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model RecognizeHandGestureResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecognizeHandGestureResponseBody(name='body'),
}

async function recognizeHandGestureWithOptions(request: RecognizeHandGestureRequest, runtime: Util.RuntimeOptions): RecognizeHandGestureResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.gestureType)) {
    body['GestureType'] = request.gestureType;
  }
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RecognizeHandGesture',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recognizeHandGesture(request: RecognizeHandGestureRequest): RecognizeHandGestureResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizeHandGestureWithOptions(request, runtime);
}

async function recognizeHandGestureAdvance(request: RecognizeHandGestureAdvanceRequest, runtime: Util.RuntimeOptions): RecognizeHandGestureResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var recognizeHandGestureReq = new RecognizeHandGestureRequest{};
  OpenApiUtil.convert(request, recognizeHandGestureReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    recognizeHandGestureReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var recognizeHandGestureResp = recognizeHandGestureWithOptions(recognizeHandGestureReq, runtime);
  return recognizeHandGestureResp;
}

model RecognizePublicFaceRequest {
  task?: [ 
    {
      imageData?: bytes(name='ImageData'),
      imageURL?: string(name='ImageURL'),
    }
  ](name='Task'),
}

model RecognizePublicFaceAdvanceRequest {
  task?: [ 
    {
      imageData?: bytes(name='ImageData'),
      imageURLObject?: readable(name='ImageURL'),
    }
  ](name='Task'),
}

model RecognizePublicFaceResponseBody = {
  data?: {
    elements?: [ 
      {
        imageURL?: string(name='ImageURL'),
        results?: [ 
          {
            label?: string(name='Label'),
            rate?: float(name='Rate'),
            subResults?: [ 
              {
                faces?: [ 
                  {
                    id?: string(name='Id'),
                    name?: string(name='Name'),
                    rate?: float(name='Rate'),
                  }
                ](name='Faces'),
                h?: float(name='H'),
                w?: float(name='W'),
                x?: float(name='X'),
                y?: float(name='Y'),
              }
            ](name='SubResults'),
            suggestion?: string(name='Suggestion'),
          }
        ](name='Results'),
        taskId?: string(name='TaskId'),
      }
    ](name='Elements'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model RecognizePublicFaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecognizePublicFaceResponseBody(name='body'),
}

async function recognizePublicFaceWithOptions(request: RecognizePublicFaceRequest, runtime: Util.RuntimeOptions): RecognizePublicFaceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.task)) {
    body['Task'] = request.task;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RecognizePublicFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recognizePublicFace(request: RecognizePublicFaceRequest): RecognizePublicFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizePublicFaceWithOptions(request, runtime);
}

async function recognizePublicFaceAdvance(request: RecognizePublicFaceAdvanceRequest, runtime: Util.RuntimeOptions): RecognizePublicFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var recognizePublicFaceReq = new RecognizePublicFaceRequest{};
  OpenApiUtil.convert(request, recognizePublicFaceReq);

  if(!Util.isUnset(request.task)) {
    var i : integer = 0;
    for (var item0 : request.task) {
      if(!Util.isUnset(item0.imageURLObject)) {
        authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
        ossConfig.accessKeyId = authResponse.body.accessKeyId;
        ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
        ossClient = new OSS(ossConfig);

        fileObj = new FileForm.FileField{
          filename = authResponse.body.objectKey,
          content = item0.imageURLObject,
          contentType = '',
        };
        ossHeader = new OSS.PostObjectRequest.header{
          accessKeyId = authResponse.body.accessKeyId,
          policy = authResponse.body.encodedPolicy,
          signature = authResponse.body.signature,
          key = authResponse.body.objectKey,
          file = fileObj,
          successActionStatus = '201',
        };
        uploadRequest = new OSS.PostObjectRequest{
          bucketName = authResponse.body.bucket,
          header = ossHeader,
        };
        ossClient.postObject(uploadRequest, ossRuntime);
        var tmp : RecognizePublicFaceRequest.task = recognizePublicFaceReq.task[i];
        tmp.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        i = Number.ltoi(Number.add(Number.itol(i), Number.itol(1)));
      }
    }
  }
  var recognizePublicFaceResp = recognizePublicFaceWithOptions(recognizePublicFaceReq, runtime);
  return recognizePublicFaceResp;
}

model RetouchBodyRequest {
  imageURL?: string(name='ImageURL'),
  lengthenDegree?: float(name='LengthenDegree'),
  slimDegree?: float(name='SlimDegree'),
}

model RetouchBodyAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
  lengthenDegree?: float(name='LengthenDegree'),
  slimDegree?: float(name='SlimDegree'),
}

model RetouchBodyResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model RetouchBodyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RetouchBodyResponseBody(name='body'),
}

async function retouchBodyWithOptions(request: RetouchBodyRequest, runtime: Util.RuntimeOptions): RetouchBodyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  if (!Util.isUnset(request.lengthenDegree)) {
    body['LengthenDegree'] = request.lengthenDegree;
  }
  if (!Util.isUnset(request.slimDegree)) {
    body['SlimDegree'] = request.slimDegree;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RetouchBody',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function retouchBody(request: RetouchBodyRequest): RetouchBodyResponse {
  var runtime = new Util.RuntimeOptions{};
  return retouchBodyWithOptions(request, runtime);
}

async function retouchBodyAdvance(request: RetouchBodyAdvanceRequest, runtime: Util.RuntimeOptions): RetouchBodyResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var retouchBodyReq = new RetouchBodyRequest{};
  OpenApiUtil.convert(request, retouchBodyReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    retouchBodyReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var retouchBodyResp = retouchBodyWithOptions(retouchBodyReq, runtime);
  return retouchBodyResp;
}

model RetouchSkinRequest {
  imageURL?: string(name='ImageURL'),
  retouchDegree?: float(name='RetouchDegree'),
  whiteningDegree?: float(name='WhiteningDegree'),
}

model RetouchSkinAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
  retouchDegree?: float(name='RetouchDegree'),
  whiteningDegree?: float(name='WhiteningDegree'),
}

model RetouchSkinResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model RetouchSkinResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RetouchSkinResponseBody(name='body'),
}

async function retouchSkinWithOptions(request: RetouchSkinRequest, runtime: Util.RuntimeOptions): RetouchSkinResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  if (!Util.isUnset(request.retouchDegree)) {
    body['RetouchDegree'] = request.retouchDegree;
  }
  if (!Util.isUnset(request.whiteningDegree)) {
    body['WhiteningDegree'] = request.whiteningDegree;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RetouchSkin',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function retouchSkin(request: RetouchSkinRequest): RetouchSkinResponse {
  var runtime = new Util.RuntimeOptions{};
  return retouchSkinWithOptions(request, runtime);
}

async function retouchSkinAdvance(request: RetouchSkinAdvanceRequest, runtime: Util.RuntimeOptions): RetouchSkinResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var retouchSkinReq = new RetouchSkinRequest{};
  OpenApiUtil.convert(request, retouchSkinReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    retouchSkinReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var retouchSkinResp = retouchSkinWithOptions(retouchSkinReq, runtime);
  return retouchSkinResp;
}

model SearchBodyTraceRequest {
  dbId?: long(name='DbId'),
  images?: [ 
    {
      imageData?: bytes(name='ImageData'),
      imageURL?: string(name='ImageURL'),
    }
  ](name='Images'),
  limit?: long(name='Limit'),
  minScore?: float(name='MinScore'),
}

model SearchBodyTraceAdvanceRequest {
  dbId?: long(name='DbId'),
  images?: [ 
    {
      imageData?: bytes(name='ImageData'),
      imageURLObject?: readable(name='ImageURL'),
    }
  ](name='Images'),
  limit?: long(name='Limit'),
  minScore?: float(name='MinScore'),
}

model SearchBodyTraceShrinkRequest {
  dbId?: long(name='DbId'),
  imagesShrink?: string(name='Images'),
  limit?: long(name='Limit'),
  minScore?: float(name='MinScore'),
}

model SearchBodyTraceResponseBody = {
  data?: {
    matchList?: [ 
      {
        dbId?: long(name='DbId'),
        extraData?: string(name='ExtraData'),
        personId?: long(name='PersonId'),
        score?: float(name='Score'),
        traceId?: long(name='TraceId'),
      }
    ](name='MatchList'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model SearchBodyTraceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchBodyTraceResponseBody(name='body'),
}

async function searchBodyTraceWithOptions(tmpReq: SearchBodyTraceRequest, runtime: Util.RuntimeOptions): SearchBodyTraceResponse {
  Util.validateModel(tmpReq);
  var request = new SearchBodyTraceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.images)) {
    request.imagesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.images, 'Images', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.dbId)) {
    body['DbId'] = request.dbId;
  }
  if (!Util.isUnset(request.imagesShrink)) {
    body['Images'] = request.imagesShrink;
  }
  if (!Util.isUnset(request.limit)) {
    body['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.minScore)) {
    body['MinScore'] = request.minScore;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchBodyTrace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchBodyTrace(request: SearchBodyTraceRequest): SearchBodyTraceResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchBodyTraceWithOptions(request, runtime);
}

async function searchBodyTraceAdvance(request: SearchBodyTraceAdvanceRequest, runtime: Util.RuntimeOptions): SearchBodyTraceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var searchBodyTraceReq = new SearchBodyTraceRequest{};
  OpenApiUtil.convert(request, searchBodyTraceReq);

  if(!Util.isUnset(request.images)) {
    var i : integer = 0;
    for (var item0 : request.images) {
      if(!Util.isUnset(item0.imageURLObject)) {
        authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
        ossConfig.accessKeyId = authResponse.body.accessKeyId;
        ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
        ossClient = new OSS(ossConfig);

        fileObj = new FileForm.FileField{
          filename = authResponse.body.objectKey,
          content = item0.imageURLObject,
          contentType = '',
        };
        ossHeader = new OSS.PostObjectRequest.header{
          accessKeyId = authResponse.body.accessKeyId,
          policy = authResponse.body.encodedPolicy,
          signature = authResponse.body.signature,
          key = authResponse.body.objectKey,
          file = fileObj,
          successActionStatus = '201',
        };
        uploadRequest = new OSS.PostObjectRequest{
          bucketName = authResponse.body.bucket,
          header = ossHeader,
        };
        ossClient.postObject(uploadRequest, ossRuntime);
        var tmp : SearchBodyTraceRequest.images = searchBodyTraceReq.images[i];
        tmp.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        i = Number.ltoi(Number.add(Number.itol(i), Number.itol(1)));
      }
    }
  }
  var searchBodyTraceResp = searchBodyTraceWithOptions(searchBodyTraceReq, runtime);
  return searchBodyTraceResp;
}

model SearchFaceRequest {
  dbName?: string(name='DbName'),
  dbNames?: string(name='DbNames'),
  imageUrl?: string(name='ImageUrl'),
  limit?: int32(name='Limit'),
  maxFaceNum?: long(name='MaxFaceNum'),
  qualityScoreThreshold?: float(name='QualityScoreThreshold'),
}

model SearchFaceAdvanceRequest {
  dbName?: string(name='DbName'),
  dbNames?: string(name='DbNames'),
  imageUrlObject?: readable(name='ImageUrl'),
  limit?: int32(name='Limit'),
  maxFaceNum?: long(name='MaxFaceNum'),
  qualityScoreThreshold?: float(name='QualityScoreThreshold'),
}

model SearchFaceResponseBody = {
  data?: {
    matchList?: [ 
      {
        faceItems?: [ 
          {
            confidence?: float(name='Confidence'),
            dbName?: string(name='DbName'),
            entityId?: string(name='EntityId'),
            extraData?: string(name='ExtraData'),
            faceId?: string(name='FaceId'),
            score?: float(name='Score'),
          }
        ](name='FaceItems'),
        location?: {
          height?: int32(name='Height'),
          width?: int32(name='Width'),
          x?: int32(name='X'),
          y?: int32(name='Y'),
        }(name='Location'),
        qualitieScore?: float(name='QualitieScore'),
      }
    ](name='MatchList'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model SearchFaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchFaceResponseBody(name='body'),
}

async function searchFaceWithOptions(request: SearchFaceRequest, runtime: Util.RuntimeOptions): SearchFaceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dbName)) {
    body['DbName'] = request.dbName;
  }
  if (!Util.isUnset(request.dbNames)) {
    body['DbNames'] = request.dbNames;
  }
  if (!Util.isUnset(request.imageUrl)) {
    body['ImageUrl'] = request.imageUrl;
  }
  if (!Util.isUnset(request.limit)) {
    body['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.maxFaceNum)) {
    body['MaxFaceNum'] = request.maxFaceNum;
  }
  if (!Util.isUnset(request.qualityScoreThreshold)) {
    body['QualityScoreThreshold'] = request.qualityScoreThreshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchFace(request: SearchFaceRequest): SearchFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchFaceWithOptions(request, runtime);
}

async function searchFaceAdvance(request: SearchFaceAdvanceRequest, runtime: Util.RuntimeOptions): SearchFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var searchFaceReq = new SearchFaceRequest{};
  OpenApiUtil.convert(request, searchFaceReq);

  if(!Util.isUnset(request.imageUrlObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageUrlObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    searchFaceReq.imageUrl = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var searchFaceResp = searchFaceWithOptions(searchFaceReq, runtime);
  return searchFaceResp;
}

model SwapFacialFeaturesRequest {
  editPart?: string(name='EditPart'),
  sourceImageData?: bytes(name='SourceImageData'),
  sourceImageURL?: string(name='SourceImageURL'),
  targetImageData?: bytes(name='TargetImageData'),
  targetImageURL?: string(name='TargetImageURL'),
}

model SwapFacialFeaturesAdvanceRequest {
  editPart?: string(name='EditPart'),
  sourceImageData?: bytes(name='SourceImageData'),
  sourceImageURLObject?: readable(name='SourceImageURL'),
  targetImageData?: bytes(name='TargetImageData'),
  targetImageURLObject?: readable(name='TargetImageURL'),
}

model SwapFacialFeaturesResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model SwapFacialFeaturesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SwapFacialFeaturesResponseBody(name='body'),
}

async function swapFacialFeaturesWithOptions(request: SwapFacialFeaturesRequest, runtime: Util.RuntimeOptions): SwapFacialFeaturesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.editPart)) {
    body['EditPart'] = request.editPart;
  }
  if (!Util.isUnset(request.sourceImageData)) {
    body['SourceImageData'] = request.sourceImageData;
  }
  if (!Util.isUnset(request.sourceImageURL)) {
    body['SourceImageURL'] = request.sourceImageURL;
  }
  if (!Util.isUnset(request.targetImageData)) {
    body['TargetImageData'] = request.targetImageData;
  }
  if (!Util.isUnset(request.targetImageURL)) {
    body['TargetImageURL'] = request.targetImageURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SwapFacialFeatures',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function swapFacialFeatures(request: SwapFacialFeaturesRequest): SwapFacialFeaturesResponse {
  var runtime = new Util.RuntimeOptions{};
  return swapFacialFeaturesWithOptions(request, runtime);
}

async function swapFacialFeaturesAdvance(request: SwapFacialFeaturesAdvanceRequest, runtime: Util.RuntimeOptions): SwapFacialFeaturesResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var swapFacialFeaturesReq = new SwapFacialFeaturesRequest{};
  OpenApiUtil.convert(request, swapFacialFeaturesReq);

  if(!Util.isUnset(request.sourceImageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.sourceImageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    swapFacialFeaturesReq.sourceImageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  if(!Util.isUnset(request.targetImageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.targetImageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    swapFacialFeaturesReq.targetImageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var swapFacialFeaturesResp = swapFacialFeaturesWithOptions(swapFacialFeaturesReq, runtime);
  return swapFacialFeaturesResp;
}

model UpdateFaceEntityRequest {
  dbName?: string(name='DbName'),
  entityId?: string(name='EntityId'),
  labels?: string(name='Labels'),
}

model UpdateFaceEntityResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateFaceEntityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateFaceEntityResponseBody(name='body'),
}

async function updateFaceEntityWithOptions(request: UpdateFaceEntityRequest, runtime: Util.RuntimeOptions): UpdateFaceEntityResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dbName)) {
    body['DbName'] = request.dbName;
  }
  if (!Util.isUnset(request.entityId)) {
    body['EntityId'] = request.entityId;
  }
  if (!Util.isUnset(request.labels)) {
    body['Labels'] = request.labels;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFaceEntity',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateFaceEntity(request: UpdateFaceEntityRequest): UpdateFaceEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFaceEntityWithOptions(request, runtime);
}

model VerifyFaceMaskRequest {
  imageData?: bytes(name='ImageData'),
  imageURL?: string(name='ImageURL'),
  refData?: bytes(name='RefData'),
  refUrl?: string(name='RefUrl'),
}

model VerifyFaceMaskAdvanceRequest {
  imageData?: bytes(name='ImageData'),
  imageURLObject?: readable(name='ImageURL'),
  refData?: bytes(name='RefData'),
  refUrlObject?: readable(name='RefUrl'),
}

model VerifyFaceMaskResponseBody = {
  data?: {
    confidence?: float(name='Confidence'),
    mask?: int32(name='Mask'),
    maskRef?: int32(name='MaskRef'),
    rectangle?: [ int32 ](name='Rectangle'),
    rectangleRef?: [ int32 ](name='RectangleRef'),
    thresholds?: [ float ](name='Thresholds'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model VerifyFaceMaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: VerifyFaceMaskResponseBody(name='body'),
}

async function verifyFaceMaskWithOptions(request: VerifyFaceMaskRequest, runtime: Util.RuntimeOptions): VerifyFaceMaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageData)) {
    body['ImageData'] = request.imageData;
  }
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  if (!Util.isUnset(request.refData)) {
    body['RefData'] = request.refData;
  }
  if (!Util.isUnset(request.refUrl)) {
    body['RefUrl'] = request.refUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'VerifyFaceMask',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function verifyFaceMask(request: VerifyFaceMaskRequest): VerifyFaceMaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyFaceMaskWithOptions(request, runtime);
}

async function verifyFaceMaskAdvance(request: VerifyFaceMaskAdvanceRequest, runtime: Util.RuntimeOptions): VerifyFaceMaskResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var verifyFaceMaskReq = new VerifyFaceMaskRequest{};
  OpenApiUtil.convert(request, verifyFaceMaskReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    verifyFaceMaskReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  if(!Util.isUnset(request.refUrlObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.refUrlObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    verifyFaceMaskReq.refUrl = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var verifyFaceMaskResp = verifyFaceMaskWithOptions(verifyFaceMaskReq, runtime);
  return verifyFaceMaskResp;
}

