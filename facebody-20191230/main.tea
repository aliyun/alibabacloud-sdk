/**
 *
 */
import Util;
import OSS;
import RPC;
import OpenPlatform;
import OSSUtil;
import FileForm;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  

  checkConfig(config);
  @endpoint = getEndpoint('facebody', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model AddBodyTraceRequest {
  dbId?: long(name='DbId', description='数据库ID'),
  extraData?: string(name='ExtraData', description='自定义信息。支持字母、数字、标点符号和汉字。不超过4096个字符。'),
  images?: [ 
    {
      imageData?: bytes(name='ImageData'),
      imageURL?: string(name='ImageURL', description='Trace图片URL'),
    }
  ](name='Images', description='Trace图片信息列表'),
  personId?: long(name='PersonId', description='实体ID，可以包含数字、字母和下划线，相同db下不可以重复，长度1-64。'),
}

model AddBodyTraceShrinkRequest {
  dbId?: long(name='DbId', description='数据库ID'),
  extraData?: string(name='ExtraData', description='自定义信息。支持字母、数字、标点符号和汉字。不超过4096个字符。'),
  imagesShrink?: string(name='Images', description='Trace图片信息列表'),
  personId?: long(name='PersonId', description='实体ID，可以包含数字、字母和下划线，相同db下不可以重复，长度1-64。'),
}

model AddBodyTraceResponseBody = {
  data?: {
    id?: long(name='Id', description='TraceID'),
  }(name='Data'),
  requestId?: string(name='RequestId', description='RequestId'),
}

model AddBodyTraceResponse = {
  headers: map[string]string(name='headers'),
  body: AddBodyTraceResponseBody(name='body'),
}

async function addBodyTraceWithOptions(tmpReq: AddBodyTraceRequest, runtime: Util.RuntimeOptions): AddBodyTraceResponse {
  Util.validateModel(tmpReq);
  var request = new AddBodyTraceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.images)) {
    request.imagesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.images, 'Images', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddBodyTrace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addBodyTrace(request: AddBodyTraceRequest): AddBodyTraceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addBodyTraceWithOptions(request, runtime);
}

model AddFaceRequest {
  dbName?: string(name='DbName'),
  entityId?: string(name='EntityId'),
  extraData?: string(name='ExtraData'),
  imageUrl?: string(name='ImageUrl'),
  qualityScoreThreshold?: float(name='QualityScoreThreshold'),
  similarityScoreThresholdBetweenEntity?: float(name='SimilarityScoreThresholdBetweenEntity'),
  similarityScoreThresholdInEntity?: float(name='SimilarityScoreThresholdInEntity'),
}

model AddFaceAdvanceRequest {
  imageUrlObject: readable(name='ImageUrlObject'),
  dbName?: string(name='DbName'),
  entityId?: string(name='EntityId'),
  extraData?: string(name='ExtraData'),
  qualityScoreThreshold?: float(name='QualityScoreThreshold'),
  similarityScoreThresholdBetweenEntity?: float(name='SimilarityScoreThresholdBetweenEntity'),
  similarityScoreThresholdInEntity?: float(name='SimilarityScoreThresholdInEntity'),
}

model AddFaceResponseBody = {
  data?: {
    faceId?: string(name='FaceId'),
    qualitieScore?: float(name='QualitieScore'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model AddFaceResponse = {
  headers: map[string]string(name='headers'),
  body: AddFaceResponseBody(name='body'),
}

async function addFaceWithOptions(request: AddFaceRequest, runtime: Util.RuntimeOptions): AddFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addFace(request: AddFaceRequest): AddFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addFaceWithOptions(request, runtime);
}

async function addFaceAdvance(request: AddFaceAdvanceRequest, runtime: Util.RuntimeOptions): AddFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var addFaceReq = new AddFaceRequest{};
  OpenApiUtil.convert(request, addFaceReq);

  if(!Util.isUnset(request.imageUrlObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageUrlObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    addFaceReq.imageUrl =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var addFaceResp = addFaceWithOptions(addFaceReq, runtime);
  return addFaceResp;
}

model AddFaceEntityRequest {
  dbName?: string(name='DbName'),
  entityId?: string(name='EntityId'),
  labels?: string(name='Labels'),
}

model AddFaceEntityResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddFaceEntityResponse = {
  headers: map[string]string(name='headers'),
  body: AddFaceEntityResponseBody(name='body'),
}

async function addFaceEntityWithOptions(request: AddFaceEntityRequest, runtime: Util.RuntimeOptions): AddFaceEntityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddFaceEntity',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addFaceEntity(request: AddFaceEntityRequest): AddFaceEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return addFaceEntityWithOptions(request, runtime);
}

model AddFaceImageTemplateRequest {
  imageURL?: string(name='ImageURL'),
  userId?: string(name='UserId', description='A short description of struct'),
}

model AddFaceImageTemplateAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  userId?: string(name='UserId', description='A short description of struct'),
}

model AddFaceImageTemplateResponseBody = {
  data?: {
    templateId?: string(name='TemplateId'),
  }(name='Data'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AddFaceImageTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: AddFaceImageTemplateResponseBody(name='body'),
}

async function addFaceImageTemplateWithOptions(request: AddFaceImageTemplateRequest, runtime: Util.RuntimeOptions): AddFaceImageTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddFaceImageTemplate',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addFaceImageTemplate(request: AddFaceImageTemplateRequest): AddFaceImageTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addFaceImageTemplateWithOptions(request, runtime);
}

async function addFaceImageTemplateAdvance(request: AddFaceImageTemplateAdvanceRequest, runtime: Util.RuntimeOptions): AddFaceImageTemplateResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var addFaceImageTemplateReq = new AddFaceImageTemplateRequest{};
  OpenApiUtil.convert(request, addFaceImageTemplateReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    addFaceImageTemplateReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var addFaceImageTemplateResp = addFaceImageTemplateWithOptions(addFaceImageTemplateReq, runtime);
  return addFaceImageTemplateResp;
}

model BatchAddFacesRequest {
  dbName?: string(name='DbName'),
  entityId?: string(name='EntityId'),
  faces?: [ 
    {
      extraData?: string(name='ExtraData'),
      imageURL?: string(name='ImageURL'),
    }
  ](name='Faces'),
  qualityScoreThreshold?: float(name='QualityScoreThreshold'),
  similarityScoreThresholdBetweenEntity?: float(name='SimilarityScoreThresholdBetweenEntity'),
  similarityScoreThresholdInEntity?: float(name='SimilarityScoreThresholdInEntity'),
}

model BatchAddFacesShrinkRequest {
  dbName?: string(name='DbName'),
  entityId?: string(name='EntityId'),
  facesShrink?: string(name='Faces'),
  qualityScoreThreshold?: float(name='QualityScoreThreshold'),
  similarityScoreThresholdBetweenEntity?: float(name='SimilarityScoreThresholdBetweenEntity'),
  similarityScoreThresholdInEntity?: float(name='SimilarityScoreThresholdInEntity'),
}

model BatchAddFacesResponseBody = {
  data?: {
    failedFaces?: [ 
      {
        code?: string(name='Code'),
        imageURL?: string(name='ImageURL'),
        message?: string(name='Message'),
      }
    ](name='FailedFaces'),
    insertedFaces?: [ 
      {
        faceId?: string(name='FaceId'),
        imageURL?: string(name='ImageURL'),
        qualitieScore?: float(name='QualitieScore'),
      }
    ](name='InsertedFaces'),
  }(name='Data'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model BatchAddFacesResponse = {
  headers: map[string]string(name='headers'),
  body: BatchAddFacesResponseBody(name='body'),
}

async function batchAddFacesWithOptions(tmpReq: BatchAddFacesRequest, runtime: Util.RuntimeOptions): BatchAddFacesResponse {
  Util.validateModel(tmpReq);
  var request = new BatchAddFacesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.faces)) {
    request.facesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.faces, 'Faces', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'BatchAddFaces',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchAddFaces(request: BatchAddFacesRequest): BatchAddFacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchAddFacesWithOptions(request, runtime);
}

model BeautifyBodyRequest {
  ageRange?: {
    ageMax?: long(name='AgeMax'),
    ageMinimum?: long(name='AgeMinimum'),
  }(name='AgeRange'),
  bodyBoxes?: [ 
    {
      height?: float(name='Height'),
      width?: float(name='Width'),
      x?: float(name='X'),
      y?: float(name='Y'),
    }
  ](name='BodyBoxes'),
  custom?: long(name='Custom'),
  faceList?: [ 
    {
      age?: long(name='Age'),
      faceBox?: {
        height?: float(name='Height'),
        width?: float(name='Width'),
        x?: float(name='X'),
        y?: float(name='Y'),
      }(name='FaceBox'),
      gender?: long(name='Gender'),
    }
  ](name='FaceList'),
  femaleLiquifyDegree?: float(name='FemaleLiquifyDegree'),
  imageURL?: string(name='ImageURL'),
  isPregnant?: boolean(name='IsPregnant'),
  lengthenDegree?: float(name='LengthenDegree'),
  maleLiquifyDegree?: float(name='MaleLiquifyDegree'),
  originalHeight?: long(name='OriginalHeight'),
  originalWidth?: long(name='OriginalWidth'),
  poseList?: [ 
    {
      pose?: [ 
        {
          score?: float(name='Score'),
          x?: long(name='X'),
          y?: long(name='Y'),
        }
      ](name='Pose'),
    }
  ](name='PoseList'),
}

model BeautifyBodyAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  ageRange?: {
    ageMax?: long(name='AgeMax'),
    ageMinimum?: long(name='AgeMinimum'),
  }(name='AgeRange'),
  bodyBoxes?: [ 
    {
      height?: float(name='Height'),
      width?: float(name='Width'),
      x?: float(name='X'),
      y?: float(name='Y'),
    }
  ](name='BodyBoxes'),
  custom?: long(name='Custom'),
  faceList?: [ 
    {
      age?: long(name='Age'),
      faceBox?: {
        height?: float(name='Height'),
        width?: float(name='Width'),
        x?: float(name='X'),
        y?: float(name='Y'),
      }(name='FaceBox'),
      gender?: long(name='Gender'),
    }
  ](name='FaceList'),
  femaleLiquifyDegree?: float(name='FemaleLiquifyDegree'),
  isPregnant?: boolean(name='IsPregnant'),
  lengthenDegree?: float(name='LengthenDegree'),
  maleLiquifyDegree?: float(name='MaleLiquifyDegree'),
  originalHeight?: long(name='OriginalHeight'),
  originalWidth?: long(name='OriginalWidth'),
  poseList?: [ 
    {
      pose?: [ 
        {
          score?: float(name='Score'),
          x?: long(name='X'),
          y?: long(name='Y'),
        }
      ](name='Pose'),
    }
  ](name='PoseList'),
}

model BeautifyBodyShrinkRequest {
  ageRangeShrink?: string(name='AgeRange'),
  bodyBoxesShrink?: string(name='BodyBoxes'),
  custom?: long(name='Custom'),
  faceListShrink?: string(name='FaceList'),
  femaleLiquifyDegree?: float(name='FemaleLiquifyDegree'),
  imageURL?: string(name='ImageURL'),
  isPregnant?: boolean(name='IsPregnant'),
  lengthenDegree?: float(name='LengthenDegree'),
  maleLiquifyDegree?: float(name='MaleLiquifyDegree'),
  originalHeight?: long(name='OriginalHeight'),
  originalWidth?: long(name='OriginalWidth'),
  poseListShrink?: string(name='PoseList'),
}

model BeautifyBodyResponseBody = {
  data?: {
    action?: string(name='Action'),
    XFlowURL?: string(name='XFlowURL'),
    YFlowURL?: string(name='YFlowURL'),
  }(name='Data', description='Id of the request'),
  requestId?: string(name='RequestId'),
}

model BeautifyBodyResponse = {
  headers: map[string]string(name='headers'),
  body: BeautifyBodyResponseBody(name='body'),
}

async function beautifyBodyWithOptions(tmpReq: BeautifyBodyRequest, runtime: Util.RuntimeOptions): BeautifyBodyResponse {
  Util.validateModel(tmpReq);
  var request = new BeautifyBodyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.ageRange)) {
    request.ageRangeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ageRange, 'AgeRange', 'json');
  }
  if (!Util.isUnset(tmpReq.bodyBoxes)) {
    request.bodyBoxesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.bodyBoxes, 'BodyBoxes', 'json');
  }
  if (!Util.isUnset(tmpReq.faceList)) {
    request.faceListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.faceList, 'FaceList', 'json');
  }
  if (!Util.isUnset(tmpReq.poseList)) {
    request.poseListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.poseList, 'PoseList', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'BeautifyBody',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function beautifyBody(request: BeautifyBodyRequest): BeautifyBodyResponse {
  var runtime = new Util.RuntimeOptions{};
  return beautifyBodyWithOptions(request, runtime);
}

async function beautifyBodyAdvance(request: BeautifyBodyAdvanceRequest, runtime: Util.RuntimeOptions): BeautifyBodyResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var beautifyBodyReq = new BeautifyBodyRequest{};
  OpenApiUtil.convert(request, beautifyBodyReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    beautifyBodyReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var beautifyBodyResp = beautifyBodyWithOptions(beautifyBodyReq, runtime);
  return beautifyBodyResp;
}

model BlurFaceRequest {
  imageURL?: string(name='ImageURL'),
}

model BlurFaceAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model BlurFaceResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model BlurFaceResponse = {
  headers: map[string]string(name='headers'),
  body: BlurFaceResponseBody(name='body'),
}

async function blurFaceWithOptions(request: BlurFaceRequest, runtime: Util.RuntimeOptions): BlurFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'BlurFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function blurFace(request: BlurFaceRequest): BlurFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return blurFaceWithOptions(request, runtime);
}

async function blurFaceAdvance(request: BlurFaceAdvanceRequest, runtime: Util.RuntimeOptions): BlurFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var blurFaceReq = new BlurFaceRequest{};
  OpenApiUtil.convert(request, blurFaceReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    blurFaceReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var blurFaceResp = blurFaceWithOptions(blurFaceReq, runtime);
  return blurFaceResp;
}

model BodyPostureRequest {
  imageURL?: string(name='ImageURL'),
}

model BodyPostureAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model BodyPostureResponseBody = {
  data?: {
    metaObject?: {
      height?: int32(name='Height'),
      width?: int32(name='Width'),
    }(name='MetaObject'),
    outputs?: [ 
      {
        humanCount?: int32(name='HumanCount'),
        results?: [ 
          {
            bodies?: [ 
              {
                confident?: float(name='Confident'),
                label?: string(name='Label'),
                positions?: [ 
                  {
                    points?: [ float ](name='Points'),
                  }
                ](name='Positions'),
              }
            ](name='Bodies'),
          }
        ](name='Results'),
      }
    ](name='Outputs'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model BodyPostureResponse = {
  headers: map[string]string(name='headers'),
  body: BodyPostureResponseBody(name='body'),
}

async function bodyPostureWithOptions(request: BodyPostureRequest, runtime: Util.RuntimeOptions): BodyPostureResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'BodyPosture',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function bodyPosture(request: BodyPostureRequest): BodyPostureResponse {
  var runtime = new Util.RuntimeOptions{};
  return bodyPostureWithOptions(request, runtime);
}

async function bodyPostureAdvance(request: BodyPostureAdvanceRequest, runtime: Util.RuntimeOptions): BodyPostureResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var bodyPostureReq = new BodyPostureRequest{};
  OpenApiUtil.convert(request, bodyPostureReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    bodyPostureReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var bodyPostureResp = bodyPostureWithOptions(bodyPostureReq, runtime);
  return bodyPostureResp;
}

model CompareFaceRequest {
  imageDataA?: bytes(name='ImageDataA'),
  imageDataB?: bytes(name='ImageDataB'),
  imageURLA?: string(name='ImageURLA'),
  imageURLB?: string(name='ImageURLB'),
  qualityScoreThreshold?: float(name='QualityScoreThreshold', description='质量分阈值，取值范围 [0.0, 100.0],   0.0或空  表示不做质量分判断逻辑。'),
}

model CompareFaceResponseBody = {
  data?: {
    confidence?: float(name='Confidence'),
    messageTips?: string(name='MessageTips', description='信息提示信息，纯文字描述，目前支持质量分的提示信息'),
    qualityScoreA?: float(name='QualityScoreA', description='输入图像A的质量分'),
    qualityScoreB?: float(name='QualityScoreB', description='输入图像A的质量分'),
    rectAList?: [ int32 ](name='RectAList'),
    rectBList?: [ int32 ](name='RectBList'),
    thresholds?: [ float ](name='Thresholds'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CompareFaceResponse = {
  headers: map[string]string(name='headers'),
  body: CompareFaceResponseBody(name='body'),
}

async function compareFaceWithOptions(request: CompareFaceRequest, runtime: Util.RuntimeOptions): CompareFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CompareFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function compareFace(request: CompareFaceRequest): CompareFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return compareFaceWithOptions(request, runtime);
}

model CountCrowdRequest {
  imageURL?: string(name='ImageURL'),
  isShow?: boolean(name='IsShow'),
}

model CountCrowdAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  isShow?: boolean(name='IsShow'),
}

model CountCrowdResponseBody = {
  data?: {
    hotMap?: string(name='HotMap'),
    peopleNumber?: int32(name='PeopleNumber'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CountCrowdResponse = {
  headers: map[string]string(name='headers'),
  body: CountCrowdResponseBody(name='body'),
}

async function countCrowdWithOptions(request: CountCrowdRequest, runtime: Util.RuntimeOptions): CountCrowdResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CountCrowd',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function countCrowd(request: CountCrowdRequest): CountCrowdResponse {
  var runtime = new Util.RuntimeOptions{};
  return countCrowdWithOptions(request, runtime);
}

async function countCrowdAdvance(request: CountCrowdAdvanceRequest, runtime: Util.RuntimeOptions): CountCrowdResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var countCrowdReq = new CountCrowdRequest{};
  OpenApiUtil.convert(request, countCrowdReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    countCrowdReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var countCrowdResp = countCrowdWithOptions(countCrowdReq, runtime);
  return countCrowdResp;
}

model CreateBodyDbRequest {
  name?: string(name='Name', description='数据库名称'),
}

model CreateBodyDbResponseBody = {
  data?: {
    id?: long(name='Id', description='数据库ID'),
  }(name='Data'),
  requestId?: string(name='RequestId', description='RequestId'),
}

model CreateBodyDbResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBodyDbResponseBody(name='body'),
}

async function createBodyDbWithOptions(request: CreateBodyDbRequest, runtime: Util.RuntimeOptions): CreateBodyDbResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateBodyDb',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBodyDb(request: CreateBodyDbRequest): CreateBodyDbResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBodyDbWithOptions(request, runtime);
}

model CreateBodyPersonRequest {
  dbId?: long(name='DbId', description='数据库ID'),
  name?: string(name='Name', description='实体ID，可以包含数字、字母和下划线，相同db下不可以重复，长度1-64。'),
}

model CreateBodyPersonResponseBody = {
  data?: {
    id?: long(name='Id', description='数据库ID'),
  }(name='Data'),
  requestId?: string(name='RequestId', description='RequestId'),
}

model CreateBodyPersonResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBodyPersonResponseBody(name='body'),
}

async function createBodyPersonWithOptions(request: CreateBodyPersonRequest, runtime: Util.RuntimeOptions): CreateBodyPersonResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateBodyPerson',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBodyPerson(request: CreateBodyPersonRequest): CreateBodyPersonResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBodyPersonWithOptions(request, runtime);
}

model CreateFaceDbRequest {
  name?: string(name='Name'),
}

model CreateFaceDbResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateFaceDbResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFaceDbResponseBody(name='body'),
}

async function createFaceDbWithOptions(request: CreateFaceDbRequest, runtime: Util.RuntimeOptions): CreateFaceDbResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateFaceDb',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFaceDb(request: CreateFaceDbRequest): CreateFaceDbResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFaceDbWithOptions(request, runtime);
}

model DeleteBodyDbRequest {
  id?: long(name='Id', description='数据库ID'),
}

model DeleteBodyDbResponseBody = {
  requestId?: string(name='RequestId', description='RequestId'),
}

model DeleteBodyDbResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBodyDbResponseBody(name='body'),
}

async function deleteBodyDbWithOptions(request: DeleteBodyDbRequest, runtime: Util.RuntimeOptions): DeleteBodyDbResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBodyDb',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBodyDb(request: DeleteBodyDbRequest): DeleteBodyDbResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBodyDbWithOptions(request, runtime);
}

model DeleteBodyPersonRequest {
  dbId?: long(name='DbId', description='数据库ID'),
  personId?: long(name='PersonId', description='人员ID'),
}

model DeleteBodyPersonResponseBody = {
  requestId?: string(name='RequestId', description='RequestId'),
}

model DeleteBodyPersonResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBodyPersonResponseBody(name='body'),
}

async function deleteBodyPersonWithOptions(request: DeleteBodyPersonRequest, runtime: Util.RuntimeOptions): DeleteBodyPersonResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBodyPerson',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBodyPerson(request: DeleteBodyPersonRequest): DeleteBodyPersonResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBodyPersonWithOptions(request, runtime);
}

model DeleteFaceRequest {
  dbName?: string(name='DbName'),
  faceId?: string(name='FaceId'),
}

model DeleteFaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFaceResponseBody(name='body'),
}

async function deleteFaceWithOptions(request: DeleteFaceRequest, runtime: Util.RuntimeOptions): DeleteFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFace(request: DeleteFaceRequest): DeleteFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFaceWithOptions(request, runtime);
}

model DeleteFaceDbRequest {
  name?: string(name='Name'),
}

model DeleteFaceDbResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFaceDbResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFaceDbResponseBody(name='body'),
}

async function deleteFaceDbWithOptions(request: DeleteFaceDbRequest, runtime: Util.RuntimeOptions): DeleteFaceDbResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFaceDb',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFaceDb(request: DeleteFaceDbRequest): DeleteFaceDbResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFaceDbWithOptions(request, runtime);
}

model DeleteFaceEntityRequest {
  dbName?: string(name='DbName'),
  entityId?: string(name='EntityId'),
}

model DeleteFaceEntityResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFaceEntityResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFaceEntityResponseBody(name='body'),
}

async function deleteFaceEntityWithOptions(request: DeleteFaceEntityRequest, runtime: Util.RuntimeOptions): DeleteFaceEntityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFaceEntity',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFaceEntity(request: DeleteFaceEntityRequest): DeleteFaceEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFaceEntityWithOptions(request, runtime);
}

model DeleteFaceImageTemplateRequest {
  templateId?: string(name='TemplateId'),
  userId?: string(name='UserId', description='A short description of struct'),
}

model DeleteFaceImageTemplateResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteFaceImageTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFaceImageTemplateResponseBody(name='body'),
}

async function deleteFaceImageTemplateWithOptions(request: DeleteFaceImageTemplateRequest, runtime: Util.RuntimeOptions): DeleteFaceImageTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFaceImageTemplate',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFaceImageTemplate(request: DeleteFaceImageTemplateRequest): DeleteFaceImageTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFaceImageTemplateWithOptions(request, runtime);
}

model DetectBodyCountRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectBodyCountAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model DetectBodyCountResponseBody = {
  data?: {
    personNumber?: int32(name='PersonNumber'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectBodyCountResponse = {
  headers: map[string]string(name='headers'),
  body: DetectBodyCountResponseBody(name='body'),
}

async function detectBodyCountWithOptions(request: DetectBodyCountRequest, runtime: Util.RuntimeOptions): DetectBodyCountResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DetectBodyCount',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectBodyCount(request: DetectBodyCountRequest): DetectBodyCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectBodyCountWithOptions(request, runtime);
}

async function detectBodyCountAdvance(request: DetectBodyCountAdvanceRequest, runtime: Util.RuntimeOptions): DetectBodyCountResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectBodyCountReq = new DetectBodyCountRequest{};
  OpenApiUtil.convert(request, detectBodyCountReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectBodyCountReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var detectBodyCountResp = detectBodyCountWithOptions(detectBodyCountReq, runtime);
  return detectBodyCountResp;
}

model DetectCelebrityRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectCelebrityAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model DetectCelebrityResponseBody = {
  data?: {
    faceRecognizeResults?: [ 
      {
        faceBoxes?: [ float ](name='FaceBoxes'),
        name?: string(name='Name'),
      }
    ](name='FaceRecognizeResults'),
    height?: int32(name='Height'),
    width?: int32(name='Width'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectCelebrityResponse = {
  headers: map[string]string(name='headers'),
  body: DetectCelebrityResponseBody(name='body'),
}

async function detectCelebrityWithOptions(request: DetectCelebrityRequest, runtime: Util.RuntimeOptions): DetectCelebrityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DetectCelebrity',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectCelebrity(request: DetectCelebrityRequest): DetectCelebrityResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectCelebrityWithOptions(request, runtime);
}

async function detectCelebrityAdvance(request: DetectCelebrityAdvanceRequest, runtime: Util.RuntimeOptions): DetectCelebrityResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectCelebrityReq = new DetectCelebrityRequest{};
  OpenApiUtil.convert(request, detectCelebrityReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectCelebrityReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var detectCelebrityResp = detectCelebrityWithOptions(detectCelebrityReq, runtime);
  return detectCelebrityResp;
}

model DetectChefCapRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectChefCapAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model DetectChefCapResponseBody = {
  data?: {
    elements?: [ 
      {
        box?: [ float ](name='Box'),
        category?: string(name='Category'),
        confidence?: float(name='Confidence'),
      }
    ](name='Elements'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectChefCapResponse = {
  headers: map[string]string(name='headers'),
  body: DetectChefCapResponseBody(name='body'),
}

async function detectChefCapWithOptions(request: DetectChefCapRequest, runtime: Util.RuntimeOptions): DetectChefCapResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DetectChefCap',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectChefCap(request: DetectChefCapRequest): DetectChefCapResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectChefCapWithOptions(request, runtime);
}

async function detectChefCapAdvance(request: DetectChefCapAdvanceRequest, runtime: Util.RuntimeOptions): DetectChefCapResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectChefCapReq = new DetectChefCapRequest{};
  OpenApiUtil.convert(request, detectChefCapReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectChefCapReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var detectChefCapResp = detectChefCapWithOptions(detectChefCapReq, runtime);
  return detectChefCapResp;
}

model DetectFaceRequest {
  imageURL?: string(name='ImageURL'),
  landmark?: boolean(name='Landmark'),
  maxFaceNumber?: long(name='MaxFaceNumber'),
  pose?: boolean(name='Pose'),
  quality?: boolean(name='Quality'),
}

model DetectFaceAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  landmark?: boolean(name='Landmark'),
  maxFaceNumber?: long(name='MaxFaceNumber'),
  pose?: boolean(name='Pose'),
  quality?: boolean(name='Quality'),
}

model DetectFaceResponseBody = {
  data?: {
    faceCount?: int32(name='FaceCount'),
    faceProbabilityList?: [ float ](name='FaceProbabilityList'),
    faceRectangles?: [ int32 ](name='FaceRectangles'),
    landmarkCount?: int32(name='LandmarkCount'),
    landmarks?: [ float ](name='Landmarks'),
    poseList?: [ float ](name='PoseList'),
    pupils?: [ float ](name='Pupils'),
    qualities?: {
      blurList?: [ float ](name='BlurList'),
      fnfList?: [ float ](name='FnfList'),
      glassList?: [ float ](name='GlassList'),
      illuList?: [ float ](name='IlluList'),
      maskList?: [ float ](name='MaskList'),
      noiseList?: [ float ](name='NoiseList'),
      poseList?: [ float ](name='PoseList'),
      scoreList?: [ float ](name='ScoreList'),
    }(name='Qualities'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectFaceResponse = {
  headers: map[string]string(name='headers'),
  body: DetectFaceResponseBody(name='body'),
}

async function detectFaceWithOptions(request: DetectFaceRequest, runtime: Util.RuntimeOptions): DetectFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DetectFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectFace(request: DetectFaceRequest): DetectFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectFaceWithOptions(request, runtime);
}

async function detectFaceAdvance(request: DetectFaceAdvanceRequest, runtime: Util.RuntimeOptions): DetectFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectFaceReq = new DetectFaceRequest{};
  OpenApiUtil.convert(request, detectFaceReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectFaceReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var detectFaceResp = detectFaceWithOptions(detectFaceReq, runtime);
  return detectFaceResp;
}

model DetectIPCPedestrianRequest {
  height?: int32(name='Height'),
  imageData?: string(name='ImageData'),
  imageURL?: string(name='ImageURL'),
  width?: int32(name='Width'),
}

model DetectIPCPedestrianAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  height?: int32(name='Height'),
  imageData?: string(name='ImageData'),
  width?: int32(name='Width'),
}

model DetectIPCPedestrianResponseBody = {
  data?: {
    imageInfoList?: [ 
      {
        elements?: [ 
          {
            boxes?: [ int32 ](name='Boxes'),
            score?: float(name='Score'),
          }
        ](name='Elements'),
      }
    ](name='ImageInfoList'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectIPCPedestrianResponse = {
  headers: map[string]string(name='headers'),
  body: DetectIPCPedestrianResponseBody(name='body'),
}

async function detectIPCPedestrianWithOptions(request: DetectIPCPedestrianRequest, runtime: Util.RuntimeOptions): DetectIPCPedestrianResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DetectIPCPedestrian',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectIPCPedestrian(request: DetectIPCPedestrianRequest): DetectIPCPedestrianResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectIPCPedestrianWithOptions(request, runtime);
}

async function detectIPCPedestrianAdvance(request: DetectIPCPedestrianAdvanceRequest, runtime: Util.RuntimeOptions): DetectIPCPedestrianResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectIPCPedestrianReq = new DetectIPCPedestrianRequest{};
  OpenApiUtil.convert(request, detectIPCPedestrianReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectIPCPedestrianReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var detectIPCPedestrianResp = detectIPCPedestrianWithOptions(detectIPCPedestrianReq, runtime);
  return detectIPCPedestrianResp;
}

model DetectLivingFaceRequest {
  tasks?: [ 
    {
      imageData?: bytes(name='ImageData'),
      imageURL?: string(name='ImageURL'),
    }
  ](name='Tasks'),
}

model DetectLivingFaceResponseBody = {
  data?: {
    elements?: [ 
      {
        imageURL?: string(name='ImageURL'),
        results?: [ 
          {
            frames?: [ 
              {
                rate?: float(name='Rate'),
                url?: string(name='Url'),
              }
            ](name='Frames'),
            label?: string(name='Label'),
            rate?: float(name='Rate'),
            suggestion?: string(name='Suggestion'),
          }
        ](name='Results'),
        taskId?: string(name='TaskId'),
      }
    ](name='Elements'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectLivingFaceResponse = {
  headers: map[string]string(name='headers'),
  body: DetectLivingFaceResponseBody(name='body'),
}

async function detectLivingFaceWithOptions(request: DetectLivingFaceRequest, runtime: Util.RuntimeOptions): DetectLivingFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DetectLivingFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectLivingFace(request: DetectLivingFaceRequest): DetectLivingFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectLivingFaceWithOptions(request, runtime);
}

model DetectMaskRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectMaskAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model DetectMaskResponseBody = {
  data?: {
    faceProbability?: float(name='FaceProbability'),
    mask?: int32(name='Mask'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectMaskResponse = {
  headers: map[string]string(name='headers'),
  body: DetectMaskResponseBody(name='body'),
}

async function detectMaskWithOptions(request: DetectMaskRequest, runtime: Util.RuntimeOptions): DetectMaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DetectMask',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectMask(request: DetectMaskRequest): DetectMaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectMaskWithOptions(request, runtime);
}

async function detectMaskAdvance(request: DetectMaskAdvanceRequest, runtime: Util.RuntimeOptions): DetectMaskResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectMaskReq = new DetectMaskRequest{};
  OpenApiUtil.convert(request, detectMaskReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectMaskReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var detectMaskResp = detectMaskWithOptions(detectMaskReq, runtime);
  return detectMaskResp;
}

model DetectPedestrianRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectPedestrianAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model DetectPedestrianResponseBody = {
  data?: {
    elements?: [ 
      {
        boxes?: [ int32 ](name='Boxes'),
        score?: float(name='Score'),
        type?: string(name='Type'),
      }
    ](name='Elements'),
    height?: int32(name='Height'),
    width?: int32(name='Width'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectPedestrianResponse = {
  headers: map[string]string(name='headers'),
  body: DetectPedestrianResponseBody(name='body'),
}

async function detectPedestrianWithOptions(request: DetectPedestrianRequest, runtime: Util.RuntimeOptions): DetectPedestrianResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DetectPedestrian',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectPedestrian(request: DetectPedestrianRequest): DetectPedestrianResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectPedestrianWithOptions(request, runtime);
}

async function detectPedestrianAdvance(request: DetectPedestrianAdvanceRequest, runtime: Util.RuntimeOptions): DetectPedestrianResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectPedestrianReq = new DetectPedestrianRequest{};
  OpenApiUtil.convert(request, detectPedestrianReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectPedestrianReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var detectPedestrianResp = detectPedestrianWithOptions(detectPedestrianReq, runtime);
  return detectPedestrianResp;
}

model DetectPedestrianIntrusionRequest {
  detectRegion?: [ 
    {
      line?: {
        x1?: long(name='X1'),
        x2?: long(name='X2'),
        y1?: long(name='Y1'),
        y2?: long(name='Y2'),
      }(name='Line'),
      rect?: {
        bottom?: long(name='Bottom'),
        left?: long(name='Left'),
        right?: long(name='Right'),
        top?: long(name='Top'),
      }(name='Rect'),
    }
  ](name='DetectRegion'),
  imageURL?: string(name='ImageURL'),
  regionType?: string(name='RegionType'),
}

model DetectPedestrianIntrusionAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  detectRegion?: [ 
    {
      line?: {
        x1?: long(name='X1'),
        x2?: long(name='X2'),
        y1?: long(name='Y1'),
        y2?: long(name='Y2'),
      }(name='Line'),
      rect?: {
        bottom?: long(name='Bottom'),
        left?: long(name='Left'),
        right?: long(name='Right'),
        top?: long(name='Top'),
      }(name='Rect'),
    }
  ](name='DetectRegion'),
  regionType?: string(name='RegionType'),
}

model DetectPedestrianIntrusionShrinkRequest {
  detectRegionShrink?: string(name='DetectRegion'),
  imageURL?: string(name='ImageURL'),
  regionType?: string(name='RegionType'),
}

model DetectPedestrianIntrusionResponseBody = {
  data?: {
    elements?: [ 
      {
        box?: {
          bottom?: long(name='Bottom'),
          left?: long(name='Left'),
          right?: long(name='Right'),
          top?: long(name='Top'),
        }(name='Box'),
        boxId?: long(name='BoxId'),
        isIntrude?: boolean(name='IsIntrude'),
        score?: long(name='Score'),
        type?: string(name='Type'),
      }
    ](name='Elements'),
    imageHeight?: long(name='ImageHeight'),
    imageWidth?: long(name='ImageWidth'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectPedestrianIntrusionResponse = {
  headers: map[string]string(name='headers'),
  body: DetectPedestrianIntrusionResponseBody(name='body'),
}

async function detectPedestrianIntrusionWithOptions(tmpReq: DetectPedestrianIntrusionRequest, runtime: Util.RuntimeOptions): DetectPedestrianIntrusionResponse {
  Util.validateModel(tmpReq);
  var request = new DetectPedestrianIntrusionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.detectRegion)) {
    request.detectRegionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.detectRegion, 'DetectRegion', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DetectPedestrianIntrusion',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectPedestrianIntrusion(request: DetectPedestrianIntrusionRequest): DetectPedestrianIntrusionResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectPedestrianIntrusionWithOptions(request, runtime);
}

async function detectPedestrianIntrusionAdvance(request: DetectPedestrianIntrusionAdvanceRequest, runtime: Util.RuntimeOptions): DetectPedestrianIntrusionResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectPedestrianIntrusionReq = new DetectPedestrianIntrusionRequest{};
  OpenApiUtil.convert(request, detectPedestrianIntrusionReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectPedestrianIntrusionReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var detectPedestrianIntrusionResp = detectPedestrianIntrusionWithOptions(detectPedestrianIntrusionReq, runtime);
  return detectPedestrianIntrusionResp;
}

model DetectVideoLivingFaceRequest {
  videoUrl?: string(name='VideoUrl'),
}

model DetectVideoLivingFaceAdvanceRequest {
  videoUrlObject: readable(name='VideoUrlObject'),
}

model DetectVideoLivingFaceResponseBody = {
  data?: {
    elements?: [ 
      {
        faceConfidence?: float(name='FaceConfidence'),
        liveConfidence?: float(name='LiveConfidence'),
        rect?: [ int32 ](name='Rect'),
      }
    ](name='Elements'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectVideoLivingFaceResponse = {
  headers: map[string]string(name='headers'),
  body: DetectVideoLivingFaceResponseBody(name='body'),
}

async function detectVideoLivingFaceWithOptions(request: DetectVideoLivingFaceRequest, runtime: Util.RuntimeOptions): DetectVideoLivingFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DetectVideoLivingFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectVideoLivingFace(request: DetectVideoLivingFaceRequest): DetectVideoLivingFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectVideoLivingFaceWithOptions(request, runtime);
}

async function detectVideoLivingFaceAdvance(request: DetectVideoLivingFaceAdvanceRequest, runtime: Util.RuntimeOptions): DetectVideoLivingFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectVideoLivingFaceReq = new DetectVideoLivingFaceRequest{};
  OpenApiUtil.convert(request, detectVideoLivingFaceReq);

  if(!Util.isUnset(request.videoUrlObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.videoUrlObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectVideoLivingFaceReq.videoUrl =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var detectVideoLivingFaceResp = detectVideoLivingFaceWithOptions(detectVideoLivingFaceReq, runtime);
  return detectVideoLivingFaceResp;
}

model EnhanceFaceRequest {
  imageURL?: string(name='ImageURL'),
}

model EnhanceFaceAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model EnhanceFaceResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model EnhanceFaceResponse = {
  headers: map[string]string(name='headers'),
  body: EnhanceFaceResponseBody(name='body'),
}

async function enhanceFaceWithOptions(request: EnhanceFaceRequest, runtime: Util.RuntimeOptions): EnhanceFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'EnhanceFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enhanceFace(request: EnhanceFaceRequest): EnhanceFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return enhanceFaceWithOptions(request, runtime);
}

async function enhanceFaceAdvance(request: EnhanceFaceAdvanceRequest, runtime: Util.RuntimeOptions): EnhanceFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var enhanceFaceReq = new EnhanceFaceRequest{};
  OpenApiUtil.convert(request, enhanceFaceReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    enhanceFaceReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var enhanceFaceResp = enhanceFaceWithOptions(enhanceFaceReq, runtime);
  return enhanceFaceResp;
}

model ExtractFingerPrintRequest {
  imageData?: bytes(name='ImageData'),
  imageURL?: string(name='ImageURL'),
}

model ExtractFingerPrintAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  imageData?: bytes(name='ImageData'),
}

model ExtractFingerPrintResponseBody = {
  data?: {
    fingerPrint?: bytes(name='FingerPrint'),
  }(name='Data'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ExtractFingerPrintResponse = {
  headers: map[string]string(name='headers'),
  body: ExtractFingerPrintResponseBody(name='body'),
}

async function extractFingerPrintWithOptions(request: ExtractFingerPrintRequest, runtime: Util.RuntimeOptions): ExtractFingerPrintResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ExtractFingerPrint',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function extractFingerPrint(request: ExtractFingerPrintRequest): ExtractFingerPrintResponse {
  var runtime = new Util.RuntimeOptions{};
  return extractFingerPrintWithOptions(request, runtime);
}

async function extractFingerPrintAdvance(request: ExtractFingerPrintAdvanceRequest, runtime: Util.RuntimeOptions): ExtractFingerPrintResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var extractFingerPrintReq = new ExtractFingerPrintRequest{};
  OpenApiUtil.convert(request, extractFingerPrintReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    extractFingerPrintReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var extractFingerPrintResp = extractFingerPrintWithOptions(extractFingerPrintReq, runtime);
  return extractFingerPrintResp;
}

model ExtractPedestrianFeatureAttrRequest {
  imageURL?: string(name='ImageURL'),
  mode?: string(name='Mode'),
  serviceVersion?: string(name='ServiceVersion'),
}

model ExtractPedestrianFeatureAttrAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  mode?: string(name='Mode'),
  serviceVersion?: string(name='ServiceVersion'),
}

model ExtractPedestrianFeatureAttrResponseBody = {
  data?: {
    age?: string(name='Age'),
    ageScore?: float(name='AgeScore'),
    feature?: string(name='Feature'),
    gender?: string(name='Gender'),
    genderScore?: float(name='GenderScore'),
    hair?: string(name='Hair'),
    hairScore?: float(name='HairScore'),
    lowerColor?: string(name='LowerColor'),
    lowerColorScore?: float(name='LowerColorScore'),
    lowerType?: string(name='LowerType'),
    lowerTypeScore?: float(name='LowerTypeScore'),
    objType?: string(name='ObjType'),
    objTypeScore?: float(name='ObjTypeScore'),
    orientation?: string(name='Orientation'),
    orientationScore?: float(name='OrientationScore'),
    qualityScore?: float(name='QualityScore'),
    upperColor?: string(name='UpperColor'),
    upperColorScore?: float(name='UpperColorScore'),
    upperType?: string(name='UpperType'),
    upperTypeScore?: float(name='UpperTypeScore'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ExtractPedestrianFeatureAttrResponse = {
  headers: map[string]string(name='headers'),
  body: ExtractPedestrianFeatureAttrResponseBody(name='body'),
}

async function extractPedestrianFeatureAttrWithOptions(request: ExtractPedestrianFeatureAttrRequest, runtime: Util.RuntimeOptions): ExtractPedestrianFeatureAttrResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ExtractPedestrianFeatureAttr',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function extractPedestrianFeatureAttr(request: ExtractPedestrianFeatureAttrRequest): ExtractPedestrianFeatureAttrResponse {
  var runtime = new Util.RuntimeOptions{};
  return extractPedestrianFeatureAttrWithOptions(request, runtime);
}

async function extractPedestrianFeatureAttrAdvance(request: ExtractPedestrianFeatureAttrAdvanceRequest, runtime: Util.RuntimeOptions): ExtractPedestrianFeatureAttrResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var extractPedestrianFeatureAttrReq = new ExtractPedestrianFeatureAttrRequest{};
  OpenApiUtil.convert(request, extractPedestrianFeatureAttrReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    extractPedestrianFeatureAttrReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var extractPedestrianFeatureAttrResp = extractPedestrianFeatureAttrWithOptions(extractPedestrianFeatureAttrReq, runtime);
  return extractPedestrianFeatureAttrResp;
}

model ExtractPedestrianFeatureAttributeRequest {
  imageURL?: string(name='ImageURL'),
  mode?: string(name='Mode'),
  urlList?: [ 
    {
      url?: string(name='Url'),
    }
  ](name='UrlList'),
}

model ExtractPedestrianFeatureAttributeResponseBody = {
  data?: {
    age?: string(name='Age'),
    ageScore?: float(name='AgeScore'),
    elements?: [ 
      {
        age?: string(name='Age'),
        ageScore?: float(name='AgeScore'),
        feature?: string(name='Feature'),
        gender?: string(name='Gender'),
        genderScore?: float(name='GenderScore'),
        hair?: string(name='Hair'),
        hairScore?: float(name='HairScore'),
        lowerColor?: string(name='LowerColor'),
        lowerColorScore?: float(name='LowerColorScore'),
        lowerType?: string(name='LowerType'),
        lowerTypeScore?: float(name='LowerTypeScore'),
        objType?: string(name='ObjType'),
        objTypeScore?: float(name='ObjTypeScore'),
        qualityScore?: float(name='QualityScore'),
        upperColor?: string(name='UpperColor'),
        upperColorScore?: float(name='UpperColorScore'),
        upperType?: string(name='UpperType'),
        upperTypeScore?: float(name='UpperTypeScore'),
      }
    ](name='Elements'),
    feature?: string(name='Feature'),
    gender?: string(name='Gender'),
    genderScore?: float(name='GenderScore'),
    hair?: string(name='Hair'),
    hairScore?: float(name='HairScore'),
    lowerColor?: string(name='LowerColor'),
    lowerColorScore?: float(name='LowerColorScore'),
    lowerType?: string(name='LowerType'),
    lowerTypeScore?: float(name='LowerTypeScore'),
    objType?: string(name='ObjType'),
    objTypeScore?: float(name='ObjTypeScore'),
    qualityScore?: float(name='QualityScore'),
    upperColor?: string(name='UpperColor'),
    upperColorScore?: float(name='UpperColorScore'),
    upperType?: string(name='UpperType'),
    upperTypeScore?: float(name='UpperTypeScore'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ExtractPedestrianFeatureAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ExtractPedestrianFeatureAttributeResponseBody(name='body'),
}

async function extractPedestrianFeatureAttributeWithOptions(request: ExtractPedestrianFeatureAttributeRequest, runtime: Util.RuntimeOptions): ExtractPedestrianFeatureAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ExtractPedestrianFeatureAttribute',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function extractPedestrianFeatureAttribute(request: ExtractPedestrianFeatureAttributeRequest): ExtractPedestrianFeatureAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return extractPedestrianFeatureAttributeWithOptions(request, runtime);
}

model FaceBeautyRequest {
  imageURL?: string(name='ImageURL'),
  sharp?: float(name='Sharp'),
  smooth?: float(name='Smooth'),
  white?: float(name='White'),
}

model FaceBeautyAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  sharp?: float(name='Sharp'),
  smooth?: float(name='Smooth'),
  white?: float(name='White'),
}

model FaceBeautyResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model FaceBeautyResponse = {
  headers: map[string]string(name='headers'),
  body: FaceBeautyResponseBody(name='body'),
}

async function faceBeautyWithOptions(request: FaceBeautyRequest, runtime: Util.RuntimeOptions): FaceBeautyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'FaceBeauty',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function faceBeauty(request: FaceBeautyRequest): FaceBeautyResponse {
  var runtime = new Util.RuntimeOptions{};
  return faceBeautyWithOptions(request, runtime);
}

async function faceBeautyAdvance(request: FaceBeautyAdvanceRequest, runtime: Util.RuntimeOptions): FaceBeautyResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var faceBeautyReq = new FaceBeautyRequest{};
  OpenApiUtil.convert(request, faceBeautyReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    faceBeautyReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var faceBeautyResp = faceBeautyWithOptions(faceBeautyReq, runtime);
  return faceBeautyResp;
}

model FaceFilterRequest {
  imageURL?: string(name='ImageURL'),
  resourceType?: string(name='ResourceType'),
  strength?: float(name='Strength'),
}

model FaceFilterAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  resourceType?: string(name='ResourceType'),
  strength?: float(name='Strength'),
}

model FaceFilterResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model FaceFilterResponse = {
  headers: map[string]string(name='headers'),
  body: FaceFilterResponseBody(name='body'),
}

async function faceFilterWithOptions(request: FaceFilterRequest, runtime: Util.RuntimeOptions): FaceFilterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'FaceFilter',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function faceFilter(request: FaceFilterRequest): FaceFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return faceFilterWithOptions(request, runtime);
}

async function faceFilterAdvance(request: FaceFilterAdvanceRequest, runtime: Util.RuntimeOptions): FaceFilterResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var faceFilterReq = new FaceFilterRequest{};
  OpenApiUtil.convert(request, faceFilterReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    faceFilterReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var faceFilterResp = faceFilterWithOptions(faceFilterReq, runtime);
  return faceFilterResp;
}

model FaceMakeupRequest {
  imageURL?: string(name='ImageURL'),
  makeupType?: string(name='MakeupType'),
  resourceType?: string(name='ResourceType'),
  strength?: float(name='Strength'),
}

model FaceMakeupAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  makeupType?: string(name='MakeupType'),
  resourceType?: string(name='ResourceType'),
  strength?: float(name='Strength'),
}

model FaceMakeupResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model FaceMakeupResponse = {
  headers: map[string]string(name='headers'),
  body: FaceMakeupResponseBody(name='body'),
}

async function faceMakeupWithOptions(request: FaceMakeupRequest, runtime: Util.RuntimeOptions): FaceMakeupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'FaceMakeup',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function faceMakeup(request: FaceMakeupRequest): FaceMakeupResponse {
  var runtime = new Util.RuntimeOptions{};
  return faceMakeupWithOptions(request, runtime);
}

async function faceMakeupAdvance(request: FaceMakeupAdvanceRequest, runtime: Util.RuntimeOptions): FaceMakeupResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var faceMakeupReq = new FaceMakeupRequest{};
  OpenApiUtil.convert(request, faceMakeupReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    faceMakeupReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var faceMakeupResp = faceMakeupWithOptions(faceMakeupReq, runtime);
  return faceMakeupResp;
}

model FaceTidyupRequest {
  imageURL?: string(name='ImageURL'),
  shapeType?: int32(name='ShapeType'),
  strength?: float(name='Strength'),
}

model FaceTidyupAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  shapeType?: int32(name='ShapeType'),
  strength?: float(name='Strength'),
}

model FaceTidyupResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model FaceTidyupResponse = {
  headers: map[string]string(name='headers'),
  body: FaceTidyupResponseBody(name='body'),
}

async function faceTidyupWithOptions(request: FaceTidyupRequest, runtime: Util.RuntimeOptions): FaceTidyupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'FaceTidyup',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function faceTidyup(request: FaceTidyupRequest): FaceTidyupResponse {
  var runtime = new Util.RuntimeOptions{};
  return faceTidyupWithOptions(request, runtime);
}

async function faceTidyupAdvance(request: FaceTidyupAdvanceRequest, runtime: Util.RuntimeOptions): FaceTidyupResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var faceTidyupReq = new FaceTidyupRequest{};
  OpenApiUtil.convert(request, faceTidyupReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    faceTidyupReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var faceTidyupResp = faceTidyupWithOptions(faceTidyupReq, runtime);
  return faceTidyupResp;
}

model GenRealPersonVerificationTokenRequest {
  certificateName?: string(name='CertificateName'),
  certificateNumber?: string(name='CertificateNumber'),
  metaInfo?: string(name='MetaInfo'),
}

model GenRealPersonVerificationTokenResponseBody = {
  data?: {
    verificationToken?: string(name='VerificationToken'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GenRealPersonVerificationTokenResponse = {
  headers: map[string]string(name='headers'),
  body: GenRealPersonVerificationTokenResponseBody(name='body'),
}

async function genRealPersonVerificationTokenWithOptions(request: GenRealPersonVerificationTokenRequest, runtime: Util.RuntimeOptions): GenRealPersonVerificationTokenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GenRealPersonVerificationToken',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function genRealPersonVerificationToken(request: GenRealPersonVerificationTokenRequest): GenRealPersonVerificationTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return genRealPersonVerificationTokenWithOptions(request, runtime);
}

model GenerateHumanAnimeStyleRequest {
  algoType?: string(name='AlgoType'),
  imageURL?: string(name='ImageURL'),
}

model GenerateHumanAnimeStyleAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  algoType?: string(name='AlgoType'),
}

model GenerateHumanAnimeStyleResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GenerateHumanAnimeStyleResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateHumanAnimeStyleResponseBody(name='body'),
}

async function generateHumanAnimeStyleWithOptions(request: GenerateHumanAnimeStyleRequest, runtime: Util.RuntimeOptions): GenerateHumanAnimeStyleResponse {
  Util.validateModel(request);
  var query = {};
  query["AlgoType"] = request.algoType;
  query["ImageURL"] = request.imageURL;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GenerateHumanAnimeStyle',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateHumanAnimeStyle(request: GenerateHumanAnimeStyleRequest): GenerateHumanAnimeStyleResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateHumanAnimeStyleWithOptions(request, runtime);
}

async function generateHumanAnimeStyleAdvance(request: GenerateHumanAnimeStyleAdvanceRequest, runtime: Util.RuntimeOptions): GenerateHumanAnimeStyleResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var generateHumanAnimeStyleReq = new GenerateHumanAnimeStyleRequest{};
  OpenApiUtil.convert(request, generateHumanAnimeStyleReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    generateHumanAnimeStyleReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var generateHumanAnimeStyleResp = generateHumanAnimeStyleWithOptions(generateHumanAnimeStyleReq, runtime);
  return generateHumanAnimeStyleResp;
}

model GenerateHumanSketchStyleRequest {
  imageURL?: string(name='ImageURL', description='A short description of struct'),
  returnType?: string(name='ReturnType'),
}

model GenerateHumanSketchStyleAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  returnType?: string(name='ReturnType'),
}

model GenerateHumanSketchStyleResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL', description='出参图片地址'),
  }(name='Data'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GenerateHumanSketchStyleResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateHumanSketchStyleResponseBody(name='body'),
}

async function generateHumanSketchStyleWithOptions(request: GenerateHumanSketchStyleRequest, runtime: Util.RuntimeOptions): GenerateHumanSketchStyleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GenerateHumanSketchStyle',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateHumanSketchStyle(request: GenerateHumanSketchStyleRequest): GenerateHumanSketchStyleResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateHumanSketchStyleWithOptions(request, runtime);
}

async function generateHumanSketchStyleAdvance(request: GenerateHumanSketchStyleAdvanceRequest, runtime: Util.RuntimeOptions): GenerateHumanSketchStyleResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var generateHumanSketchStyleReq = new GenerateHumanSketchStyleRequest{};
  OpenApiUtil.convert(request, generateHumanSketchStyleReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    generateHumanSketchStyleReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var generateHumanSketchStyleResp = generateHumanSketchStyleWithOptions(generateHumanSketchStyleReq, runtime);
  return generateHumanSketchStyleResp;
}

model GetBodyPersonRequest {
  dbId?: long(name='DbId', description='数据库ID'),
  personId?: long(name='PersonId', description='人员ID'),
}

model GetBodyPersonResponseBody = {
  data?: {
    dbId?: long(name='DbId', description='数据库ID'),
    id?: long(name='Id', description='人员ID'),
    name?: string(name='Name', description='人员名称'),
    traceCount?: long(name='TraceCount', description='Trace数量'),
    traceList?: [ 
      {
        extraData?: string(name='ExtraData', description='自定义Trace信息'),
        id?: long(name='Id', description='TraceId'),
      }
    ](name='TraceList', description='Trace列表'),
  }(name='Data'),
  requestId?: string(name='RequestId', description='RequestId'),
}

model GetBodyPersonResponse = {
  headers: map[string]string(name='headers'),
  body: GetBodyPersonResponseBody(name='body'),
}

async function getBodyPersonWithOptions(request: GetBodyPersonRequest, runtime: Util.RuntimeOptions): GetBodyPersonResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetBodyPerson',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getBodyPerson(request: GetBodyPersonRequest): GetBodyPersonResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBodyPersonWithOptions(request, runtime);
}

model GetFaceEntityRequest {
  dbName?: string(name='DbName'),
  entityId?: string(name='EntityId'),
}

model GetFaceEntityResponseBody = {
  data?: {
    dbName?: string(name='DbName'),
    entityId?: string(name='EntityId'),
    faces?: [ 
      {
        faceId?: string(name='FaceId'),
      }
    ](name='Faces'),
    labels?: string(name='Labels'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetFaceEntityResponse = {
  headers: map[string]string(name='headers'),
  body: GetFaceEntityResponseBody(name='body'),
}

async function getFaceEntityWithOptions(request: GetFaceEntityRequest, runtime: Util.RuntimeOptions): GetFaceEntityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetFaceEntity',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getFaceEntity(request: GetFaceEntityRequest): GetFaceEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFaceEntityWithOptions(request, runtime);
}

model GetRealPersonVerificationResultRequest {
  materialHash?: string(name='MaterialHash'),
  verificationToken?: string(name='VerificationToken'),
}

model GetRealPersonVerificationResultResponseBody = {
  data?: {
    identityInfo?: string(name='IdentityInfo'),
    materialMatch?: string(name='MaterialMatch'),
    passed?: boolean(name='Passed'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetRealPersonVerificationResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetRealPersonVerificationResultResponseBody(name='body'),
}

async function getRealPersonVerificationResultWithOptions(request: GetRealPersonVerificationResultRequest, runtime: Util.RuntimeOptions): GetRealPersonVerificationResultResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetRealPersonVerificationResult',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRealPersonVerificationResult(request: GetRealPersonVerificationResultRequest): GetRealPersonVerificationResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRealPersonVerificationResultWithOptions(request, runtime);
}

model HandPostureRequest {
  imageURL?: string(name='ImageURL'),
}

model HandPostureAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model HandPostureResponseBody = {
  data?: {
    metaObject?: {
      height?: int32(name='Height'),
      width?: int32(name='Width'),
    }(name='MetaObject'),
    outputs?: [ 
      {
        handCount?: int32(name='HandCount'),
        results?: [ 
          {
            box?: {
              confident?: float(name='Confident'),
              positions?: [ 
                {
                  points?: [ float ](name='Points'),
                }
              ](name='Positions'),
            }(name='Box'),
            hands?: {
              confident?: float(name='Confident'),
              keyPoints?: [ 
                {
                  label?: string(name='Label'),
                  positions?: [ 
                    {
                      points?: [ float ](name='Points'),
                    }
                  ](name='Positions'),
                }
              ](name='KeyPoints'),
            }(name='Hands'),
          }
        ](name='Results'),
      }
    ](name='Outputs'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model HandPostureResponse = {
  headers: map[string]string(name='headers'),
  body: HandPostureResponseBody(name='body'),
}

async function handPostureWithOptions(request: HandPostureRequest, runtime: Util.RuntimeOptions): HandPostureResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'HandPosture',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function handPosture(request: HandPostureRequest): HandPostureResponse {
  var runtime = new Util.RuntimeOptions{};
  return handPostureWithOptions(request, runtime);
}

async function handPostureAdvance(request: HandPostureAdvanceRequest, runtime: Util.RuntimeOptions): HandPostureResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var handPostureReq = new HandPostureRequest{};
  OpenApiUtil.convert(request, handPostureReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    handPostureReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var handPostureResp = handPostureWithOptions(handPostureReq, runtime);
  return handPostureResp;
}

model LiquifyFaceRequest {
  imageURL?: string(name='ImageURL'),
  slimDegree?: float(name='SlimDegree'),
}

model LiquifyFaceAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  slimDegree?: float(name='SlimDegree'),
}

model LiquifyFaceResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model LiquifyFaceResponse = {
  headers: map[string]string(name='headers'),
  body: LiquifyFaceResponseBody(name='body'),
}

async function liquifyFaceWithOptions(request: LiquifyFaceRequest, runtime: Util.RuntimeOptions): LiquifyFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'LiquifyFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function liquifyFace(request: LiquifyFaceRequest): LiquifyFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return liquifyFaceWithOptions(request, runtime);
}

async function liquifyFaceAdvance(request: LiquifyFaceAdvanceRequest, runtime: Util.RuntimeOptions): LiquifyFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var liquifyFaceReq = new LiquifyFaceRequest{};
  OpenApiUtil.convert(request, liquifyFaceReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    liquifyFaceReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var liquifyFaceResp = liquifyFaceWithOptions(liquifyFaceReq, runtime);
  return liquifyFaceResp;
}

model ListBodyDbsRequest {
  limit?: long(name='Limit', description='分页数量'),
  offset?: long(name='Offset', description='起始位置(不含)'),
}

model ListBodyDbsResponseBody = {
  data?: {
    dbList?: [ 
      {
        id?: long(name='Id', description='数据库ID'),
        name?: string(name='Name', description='数据库名称'),
      }
    ](name='DbList'),
    total?: long(name='Total', description='数据库ID'),
  }(name='Data'),
  requestId?: string(name='RequestId', description='RequestId'),
}

model ListBodyDbsResponse = {
  headers: map[string]string(name='headers'),
  body: ListBodyDbsResponseBody(name='body'),
}

async function listBodyDbsWithOptions(request: ListBodyDbsRequest, runtime: Util.RuntimeOptions): ListBodyDbsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListBodyDbs',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listBodyDbs(request: ListBodyDbsRequest): ListBodyDbsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBodyDbsWithOptions(request, runtime);
}

model ListBodyPersonRequest {
  dbId?: long(name='DbId', description='数据库ID'),
  limit?: long(name='Limit', description='分页数量'),
  offset?: long(name='Offset', description='起始位置(不含)'),
}

model ListBodyPersonResponseBody = {
  data?: {
    personList?: [ 
      {
        dbId?: long(name='DbId', description='数据库ID'),
        id?: long(name='Id', description='人员ID'),
        name?: string(name='Name', description='人员名称'),
        traceCount?: long(name='TraceCount', description='Trace数量'),
      }
    ](name='PersonList'),
    total?: long(name='Total', description='数据总量'),
  }(name='Data'),
  requestId?: string(name='RequestId', description='RequestId'),
}

model ListBodyPersonResponse = {
  headers: map[string]string(name='headers'),
  body: ListBodyPersonResponseBody(name='body'),
}

async function listBodyPersonWithOptions(request: ListBodyPersonRequest, runtime: Util.RuntimeOptions): ListBodyPersonResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListBodyPerson',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listBodyPerson(request: ListBodyPersonRequest): ListBodyPersonResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBodyPersonWithOptions(request, runtime);
}

model ListFaceDbsResponseBody = {
  data?: {
    dbList?: [ 
      {
        name?: string(name='Name'),
      }
    ](name='DbList'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListFaceDbsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFaceDbsResponseBody(name='body'),
}

async function listFaceDbsWithOptions(runtime: Util.RuntimeOptions): ListFaceDbsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListFaceDbs',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFaceDbs(): ListFaceDbsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFaceDbsWithOptions(runtime);
}

model ListFaceEntitiesRequest {
  dbName?: string(name='DbName'),
  entityIdPrefix?: string(name='EntityIdPrefix'),
  labels?: string(name='Labels'),
  limit?: int32(name='Limit'),
  offset?: int32(name='Offset'),
  order?: string(name='Order'),
  token?: string(name='Token'),
}

model ListFaceEntitiesResponseBody = {
  data?: {
    entities?: [ 
      {
        createdAt?: long(name='CreatedAt'),
        dbName?: string(name='DbName'),
        entityId?: string(name='EntityId'),
        faceCount?: int32(name='FaceCount'),
        labels?: string(name='Labels'),
        updatedAt?: long(name='UpdatedAt'),
      }
    ](name='Entities'),
    token?: string(name='Token'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListFaceEntitiesResponse = {
  headers: map[string]string(name='headers'),
  body: ListFaceEntitiesResponseBody(name='body'),
}

async function listFaceEntitiesWithOptions(request: ListFaceEntitiesRequest, runtime: Util.RuntimeOptions): ListFaceEntitiesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFaceEntities',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFaceEntities(request: ListFaceEntitiesRequest): ListFaceEntitiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFaceEntitiesWithOptions(request, runtime);
}

model MergeImageFaceRequest {
  imageURL?: string(name='ImageURL'),
  templateId?: string(name='TemplateId'),
  userId?: string(name='UserId', description='A short description of struct'),
}

model MergeImageFaceAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  templateId?: string(name='TemplateId'),
  userId?: string(name='UserId', description='A short description of struct'),
}

model MergeImageFaceResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model MergeImageFaceResponse = {
  headers: map[string]string(name='headers'),
  body: MergeImageFaceResponseBody(name='body'),
}

async function mergeImageFaceWithOptions(request: MergeImageFaceRequest, runtime: Util.RuntimeOptions): MergeImageFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'MergeImageFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function mergeImageFace(request: MergeImageFaceRequest): MergeImageFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return mergeImageFaceWithOptions(request, runtime);
}

async function mergeImageFaceAdvance(request: MergeImageFaceAdvanceRequest, runtime: Util.RuntimeOptions): MergeImageFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var mergeImageFaceReq = new MergeImageFaceRequest{};
  OpenApiUtil.convert(request, mergeImageFaceReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    mergeImageFaceReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var mergeImageFaceResp = mergeImageFaceWithOptions(mergeImageFaceReq, runtime);
  return mergeImageFaceResp;
}

model MonitorExaminationRequest {
  imageURL?: string(name='ImageURL'),
  type?: long(name='Type', description='A short description of struct'),
}

model MonitorExaminationAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  type?: long(name='Type', description='A short description of struct'),
}

model MonitorExaminationResponseBody = {
  data?: {
    chatScore?: float(name='ChatScore'),
    faceInfo?: {
      completeness?: long(name='Completeness'),
      faceNumber?: long(name='FaceNumber'),
      pose?: {
        pitch?: float(name='Pitch'),
        roll?: float(name='Roll'),
        yaw?: float(name='Yaw'),
      }(name='Pose'),
    }(name='FaceInfo'),
    personInfo?: {
      cellPhone?: {
        score?: float(name='Score'),
        threshold?: float(name='Threshold'),
      }(name='CellPhone'),
      earPhone?: {
        score?: float(name='Score'),
        threshold?: float(name='Threshold'),
      }(name='EarPhone'),
      personNumber?: long(name='PersonNumber'),
    }(name='PersonInfo'),
    threshold?: float(name='Threshold'),
  }(name='Data'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model MonitorExaminationResponse = {
  headers: map[string]string(name='headers'),
  body: MonitorExaminationResponseBody(name='body'),
}

async function monitorExaminationWithOptions(request: MonitorExaminationRequest, runtime: Util.RuntimeOptions): MonitorExaminationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'MonitorExamination',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function monitorExamination(request: MonitorExaminationRequest): MonitorExaminationResponse {
  var runtime = new Util.RuntimeOptions{};
  return monitorExaminationWithOptions(request, runtime);
}

async function monitorExaminationAdvance(request: MonitorExaminationAdvanceRequest, runtime: Util.RuntimeOptions): MonitorExaminationResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var monitorExaminationReq = new MonitorExaminationRequest{};
  OpenApiUtil.convert(request, monitorExaminationReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    monitorExaminationReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var monitorExaminationResp = monitorExaminationWithOptions(monitorExaminationReq, runtime);
  return monitorExaminationResp;
}

model PedestrianDetectAttributeRequest {
  imageURL?: string(name='ImageURL'),
}

model PedestrianDetectAttributeAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model PedestrianDetectAttributeResponseBody = {
  data?: {
    attributes?: [ 
      {
        age?: {
          name?: string(name='Name'),
          score?: float(name='Score'),
        }(name='Age'),
        backpack?: {
          name?: string(name='Name'),
          score?: float(name='Score'),
        }(name='Backpack'),
        gender?: {
          name?: string(name='Name'),
          score?: float(name='Score'),
        }(name='Gender'),
        glasses?: {
          name?: string(name='Name'),
          score?: float(name='Score'),
        }(name='Glasses'),
        handbag?: {
          name?: string(name='Name'),
          score?: float(name='Score'),
        }(name='Handbag'),
        hat?: {
          name?: string(name='Name'),
          score?: float(name='Score'),
        }(name='Hat'),
        lowerColor?: {
          name?: string(name='Name'),
          score?: float(name='Score'),
        }(name='LowerColor'),
        lowerWear?: {
          name?: string(name='Name'),
          score?: float(name='Score'),
        }(name='LowerWear'),
        orient?: {
          name?: string(name='Name'),
          score?: float(name='Score'),
        }(name='Orient'),
        shoulderBag?: {
          name?: string(name='Name'),
          score?: float(name='Score'),
        }(name='ShoulderBag'),
        upperColor?: {
          name?: string(name='Name'),
          score?: float(name='Score'),
        }(name='UpperColor'),
        upperWear?: {
          name?: string(name='Name'),
          score?: float(name='Score'),
        }(name='UpperWear'),
      }
    ](name='Attributes'),
    boxes?: [ 
      {
        bottomRightX?: float(name='BottomRightX'),
        bottomRightY?: float(name='BottomRightY'),
        score?: float(name='Score'),
        topLeftX?: float(name='TopLeftX'),
        topLeftY?: float(name='TopLeftY'),
      }
    ](name='Boxes'),
    height?: long(name='Height'),
    personNumber?: int32(name='PersonNumber'),
    width?: long(name='Width'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model PedestrianDetectAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: PedestrianDetectAttributeResponseBody(name='body'),
}

async function pedestrianDetectAttributeWithOptions(request: PedestrianDetectAttributeRequest, runtime: Util.RuntimeOptions): PedestrianDetectAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'PedestrianDetectAttribute',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pedestrianDetectAttribute(request: PedestrianDetectAttributeRequest): PedestrianDetectAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return pedestrianDetectAttributeWithOptions(request, runtime);
}

async function pedestrianDetectAttributeAdvance(request: PedestrianDetectAttributeAdvanceRequest, runtime: Util.RuntimeOptions): PedestrianDetectAttributeResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var pedestrianDetectAttributeReq = new PedestrianDetectAttributeRequest{};
  OpenApiUtil.convert(request, pedestrianDetectAttributeReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    pedestrianDetectAttributeReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var pedestrianDetectAttributeResp = pedestrianDetectAttributeWithOptions(pedestrianDetectAttributeReq, runtime);
  return pedestrianDetectAttributeResp;
}

model QueryFaceImageTemplateRequest {
  templateId?: string(name='TemplateId'),
  userId?: string(name='UserId', description='A short description of struct'),
}

model QueryFaceImageTemplateResponseBody = {
  data?: {
    elements?: [ 
      {
        createTime?: string(name='CreateTime'),
        templateId?: string(name='TemplateId'),
        templateURL?: string(name='TemplateURL'),
        updateTime?: string(name='UpdateTime'),
        userId?: string(name='UserId'),
      }
    ](name='Elements'),
  }(name='Data'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model QueryFaceImageTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: QueryFaceImageTemplateResponseBody(name='body'),
}

async function queryFaceImageTemplateWithOptions(request: QueryFaceImageTemplateRequest, runtime: Util.RuntimeOptions): QueryFaceImageTemplateResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryFaceImageTemplate',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryFaceImageTemplate(request: QueryFaceImageTemplateRequest): QueryFaceImageTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFaceImageTemplateWithOptions(request, runtime);
}

model RecognizeActionRequest {
  type?: int32(name='Type'),
  URLList?: [ 
    {
      URL?: string(name='URL'),
      imageData?: bytes(name='imageData'),
    }
  ](name='URLList'),
  videoData?: bytes(name='VideoData'),
  videoUrl?: string(name='VideoUrl'),
}

model RecognizeActionResponseBody = {
  data?: {
    elements?: [ 
      {
        boxes?: [ 
          {
            box?: [ int32 ](name='Box'),
          }
        ](name='Boxes'),
        labels?: [ string ](name='Labels'),
        scores?: [ float ](name='Scores'),
        timestamp?: int32(name='Timestamp'),
      }
    ](name='Elements'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model RecognizeActionResponse = {
  headers: map[string]string(name='headers'),
  body: RecognizeActionResponseBody(name='body'),
}

async function recognizeActionWithOptions(request: RecognizeActionRequest, runtime: Util.RuntimeOptions): RecognizeActionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RecognizeAction',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recognizeAction(request: RecognizeActionRequest): RecognizeActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizeActionWithOptions(request, runtime);
}

model RecognizeExpressionRequest {
  imageURL?: string(name='ImageURL'),
}

model RecognizeExpressionAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model RecognizeExpressionResponseBody = {
  data?: {
    elements?: [ 
      {
        expression?: string(name='Expression'),
        faceProbability?: float(name='FaceProbability'),
        faceRectangle?: {
          height?: int32(name='Height'),
          left?: int32(name='Left'),
          top?: int32(name='Top'),
          width?: int32(name='Width'),
        }(name='FaceRectangle'),
      }
    ](name='Elements'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model RecognizeExpressionResponse = {
  headers: map[string]string(name='headers'),
  body: RecognizeExpressionResponseBody(name='body'),
}

async function recognizeExpressionWithOptions(request: RecognizeExpressionRequest, runtime: Util.RuntimeOptions): RecognizeExpressionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RecognizeExpression',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recognizeExpression(request: RecognizeExpressionRequest): RecognizeExpressionResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizeExpressionWithOptions(request, runtime);
}

async function recognizeExpressionAdvance(request: RecognizeExpressionAdvanceRequest, runtime: Util.RuntimeOptions): RecognizeExpressionResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var recognizeExpressionReq = new RecognizeExpressionRequest{};
  OpenApiUtil.convert(request, recognizeExpressionReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    recognizeExpressionReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var recognizeExpressionResp = recognizeExpressionWithOptions(recognizeExpressionReq, runtime);
  return recognizeExpressionResp;
}

model RecognizeFaceRequest {
  age?: boolean(name='Age'),
  beauty?: boolean(name='Beauty'),
  expression?: boolean(name='Expression'),
  gender?: boolean(name='Gender'),
  glass?: boolean(name='Glass'),
  hat?: boolean(name='Hat'),
  imageURL?: string(name='ImageURL'),
  mask?: boolean(name='Mask'),
  maxFaceNumber?: long(name='MaxFaceNumber'),
  quality?: boolean(name='Quality'),
}

model RecognizeFaceAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  age?: boolean(name='Age'),
  beauty?: boolean(name='Beauty'),
  expression?: boolean(name='Expression'),
  gender?: boolean(name='Gender'),
  glass?: boolean(name='Glass'),
  hat?: boolean(name='Hat'),
  mask?: boolean(name='Mask'),
  maxFaceNumber?: long(name='MaxFaceNumber'),
  quality?: boolean(name='Quality'),
}

model RecognizeFaceResponseBody = {
  data?: {
    ageList?: [ int32 ](name='AgeList'),
    beautyList?: [ float ](name='BeautyList'),
    denseFeatureLength?: int32(name='DenseFeatureLength'),
    denseFeatures?: [ string ](name='DenseFeatures'),
    expressions?: [ int32 ](name='Expressions'),
    faceCount?: int32(name='FaceCount'),
    faceProbabilityList?: [ float ](name='FaceProbabilityList'),
    faceRectangles?: [ int32 ](name='FaceRectangles'),
    genderList?: [ int32 ](name='GenderList'),
    glasses?: [ int32 ](name='Glasses'),
    hatList?: [ int32 ](name='HatList'),
    landmarkCount?: int32(name='LandmarkCount'),
    landmarks?: [ float ](name='Landmarks'),
    masks?: [ long ](name='Masks'),
    poseList?: [ float ](name='PoseList'),
    pupils?: [ float ](name='Pupils'),
    qualities?: {
      blurList?: [ float ](name='BlurList'),
      fnfList?: [ float ](name='FnfList'),
      glassList?: [ float ](name='GlassList'),
      illuList?: [ float ](name='IlluList'),
      maskList?: [ float ](name='MaskList'),
      noiseList?: [ float ](name='NoiseList'),
      poseList?: [ float ](name='PoseList'),
      scoreList?: [ float ](name='ScoreList'),
    }(name='Qualities'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model RecognizeFaceResponse = {
  headers: map[string]string(name='headers'),
  body: RecognizeFaceResponseBody(name='body'),
}

async function recognizeFaceWithOptions(request: RecognizeFaceRequest, runtime: Util.RuntimeOptions): RecognizeFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RecognizeFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recognizeFace(request: RecognizeFaceRequest): RecognizeFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizeFaceWithOptions(request, runtime);
}

async function recognizeFaceAdvance(request: RecognizeFaceAdvanceRequest, runtime: Util.RuntimeOptions): RecognizeFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var recognizeFaceReq = new RecognizeFaceRequest{};
  OpenApiUtil.convert(request, recognizeFaceReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    recognizeFaceReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var recognizeFaceResp = recognizeFaceWithOptions(recognizeFaceReq, runtime);
  return recognizeFaceResp;
}

model RecognizeHandGestureRequest {
  appId?: string(name='AppId', description='A short description of struct'),
  gestureType?: string(name='GestureType'),
  imageURL?: string(name='ImageURL'),
}

model RecognizeHandGestureAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  appId?: string(name='AppId', description='A short description of struct'),
  gestureType?: string(name='GestureType'),
}

model RecognizeHandGestureResponseBody = {
  data?: {
    height?: long(name='Height'),
    score?: float(name='Score'),
    type?: string(name='Type'),
    width?: long(name='Width'),
    x?: long(name='X'),
    y?: long(name='Y'),
  }(name='Data'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model RecognizeHandGestureResponse = {
  headers: map[string]string(name='headers'),
  body: RecognizeHandGestureResponseBody(name='body'),
}

async function recognizeHandGestureWithOptions(request: RecognizeHandGestureRequest, runtime: Util.RuntimeOptions): RecognizeHandGestureResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RecognizeHandGesture',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recognizeHandGesture(request: RecognizeHandGestureRequest): RecognizeHandGestureResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizeHandGestureWithOptions(request, runtime);
}

async function recognizeHandGestureAdvance(request: RecognizeHandGestureAdvanceRequest, runtime: Util.RuntimeOptions): RecognizeHandGestureResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var recognizeHandGestureReq = new RecognizeHandGestureRequest{};
  OpenApiUtil.convert(request, recognizeHandGestureReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    recognizeHandGestureReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var recognizeHandGestureResp = recognizeHandGestureWithOptions(recognizeHandGestureReq, runtime);
  return recognizeHandGestureResp;
}

model RecognizePublicFaceRequest {
  task?: [ 
    {
      imageData?: bytes(name='ImageData'),
      imageURL?: string(name='ImageURL'),
    }
  ](name='Task'),
}

model RecognizePublicFaceResponseBody = {
  data?: {
    elements?: [ 
      {
        imageURL?: string(name='ImageURL'),
        results?: [ 
          {
            label?: string(name='Label'),
            rate?: float(name='Rate'),
            subResults?: [ 
              {
                faces?: [ 
                  {
                    id?: string(name='Id'),
                    name?: string(name='Name'),
                    rate?: float(name='Rate'),
                  }
                ](name='Faces'),
                h?: float(name='H'),
                w?: float(name='W'),
                x?: float(name='X'),
                y?: float(name='Y'),
              }
            ](name='SubResults'),
            suggestion?: string(name='Suggestion'),
          }
        ](name='Results'),
        taskId?: string(name='TaskId'),
      }
    ](name='Elements'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model RecognizePublicFaceResponse = {
  headers: map[string]string(name='headers'),
  body: RecognizePublicFaceResponseBody(name='body'),
}

async function recognizePublicFaceWithOptions(request: RecognizePublicFaceRequest, runtime: Util.RuntimeOptions): RecognizePublicFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RecognizePublicFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recognizePublicFace(request: RecognizePublicFaceRequest): RecognizePublicFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizePublicFaceWithOptions(request, runtime);
}

model RetouchBodyRequest {
  imageURL?: string(name='ImageURL'),
  lengthenDegree?: float(name='LengthenDegree'),
  slimDegree?: float(name='SlimDegree'),
}

model RetouchBodyAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  lengthenDegree?: float(name='LengthenDegree'),
  slimDegree?: float(name='SlimDegree'),
}

model RetouchBodyResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model RetouchBodyResponse = {
  headers: map[string]string(name='headers'),
  body: RetouchBodyResponseBody(name='body'),
}

async function retouchBodyWithOptions(request: RetouchBodyRequest, runtime: Util.RuntimeOptions): RetouchBodyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RetouchBody',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function retouchBody(request: RetouchBodyRequest): RetouchBodyResponse {
  var runtime = new Util.RuntimeOptions{};
  return retouchBodyWithOptions(request, runtime);
}

async function retouchBodyAdvance(request: RetouchBodyAdvanceRequest, runtime: Util.RuntimeOptions): RetouchBodyResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var retouchBodyReq = new RetouchBodyRequest{};
  OpenApiUtil.convert(request, retouchBodyReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    retouchBodyReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var retouchBodyResp = retouchBodyWithOptions(retouchBodyReq, runtime);
  return retouchBodyResp;
}

model RetouchSkinRequest {
  imageURL?: string(name='ImageURL'),
  retouchDegree?: float(name='RetouchDegree'),
  whiteningDegree?: float(name='WhiteningDegree'),
}

model RetouchSkinAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  retouchDegree?: float(name='RetouchDegree'),
  whiteningDegree?: float(name='WhiteningDegree'),
}

model RetouchSkinResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model RetouchSkinResponse = {
  headers: map[string]string(name='headers'),
  body: RetouchSkinResponseBody(name='body'),
}

async function retouchSkinWithOptions(request: RetouchSkinRequest, runtime: Util.RuntimeOptions): RetouchSkinResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RetouchSkin',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function retouchSkin(request: RetouchSkinRequest): RetouchSkinResponse {
  var runtime = new Util.RuntimeOptions{};
  return retouchSkinWithOptions(request, runtime);
}

async function retouchSkinAdvance(request: RetouchSkinAdvanceRequest, runtime: Util.RuntimeOptions): RetouchSkinResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var retouchSkinReq = new RetouchSkinRequest{};
  OpenApiUtil.convert(request, retouchSkinReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    retouchSkinReq.imageURL =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var retouchSkinResp = retouchSkinWithOptions(retouchSkinReq, runtime);
  return retouchSkinResp;
}

model SearchBodyTraceRequest {
  dbId?: long(name='DbId', description='数据库ID'),
  images?: [ 
    {
      imageData?: bytes(name='ImageData', description='图片Base64数据'),
      imageURL?: string(name='ImageURL', description='Trace图片URL'),
    }
  ](name='Images', description='Trace图片信息列表'),
  limit?: long(name='Limit', description='结果Trace数量上限，默认10，取值范围[1, 100]'),
  minScore?: float(name='MinScore', description='score阈值，只返回大于等于该score的数据，取值范围[-1.0, 1.0]，默认为空'),
}

model SearchBodyTraceShrinkRequest {
  dbId?: long(name='DbId', description='数据库ID'),
  imagesShrink?: string(name='Images', description='Trace图片信息列表'),
  limit?: long(name='Limit', description='结果Trace数量上限，默认10，取值范围[1, 100]'),
  minScore?: float(name='MinScore', description='score阈值，只返回大于等于该score的数据，取值范围[-1.0, 1.0]，默认为空'),
}

model SearchBodyTraceResponseBody = {
  data?: {
    matchList?: [ 
      {
        dbId?: long(name='DbId', description='数据库ID'),
        extraData?: string(name='ExtraData', description='自定义数据信息'),
        personId?: long(name='PersonId', description='人员ID'),
        score?: float(name='Score', description='匹配度分值，越大越相似，取值范围[-1.0, 1.0]'),
        traceId?: long(name='TraceId', description='TraceId'),
      }
    ](name='MatchList', description='匹配的Trace列表'),
  }(name='Data'),
  requestId?: string(name='RequestId', description='RequestId'),
}

model SearchBodyTraceResponse = {
  headers: map[string]string(name='headers'),
  body: SearchBodyTraceResponseBody(name='body'),
}

async function searchBodyTraceWithOptions(tmpReq: SearchBodyTraceRequest, runtime: Util.RuntimeOptions): SearchBodyTraceResponse {
  Util.validateModel(tmpReq);
  var request = new SearchBodyTraceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.images)) {
    request.imagesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.images, 'Images', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SearchBodyTrace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchBodyTrace(request: SearchBodyTraceRequest): SearchBodyTraceResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchBodyTraceWithOptions(request, runtime);
}

model SearchFaceRequest {
  dbName?: string(name='DbName'),
  dbNames?: string(name='DbNames'),
  imageUrl?: string(name='ImageUrl'),
  limit?: int32(name='Limit'),
  maxFaceNum?: long(name='MaxFaceNum'),
  qualityScoreThreshold?: float(name='QualityScoreThreshold'),
}

model SearchFaceAdvanceRequest {
  imageUrlObject: readable(name='ImageUrlObject'),
  dbName?: string(name='DbName'),
  dbNames?: string(name='DbNames'),
  limit?: int32(name='Limit'),
  maxFaceNum?: long(name='MaxFaceNum'),
  qualityScoreThreshold?: float(name='QualityScoreThreshold'),
}

model SearchFaceResponseBody = {
  data?: {
    matchList?: [ 
      {
        faceItems?: [ 
          {
            confidence?: float(name='Confidence'),
            dbName?: string(name='DbName'),
            entityId?: string(name='EntityId'),
            extraData?: string(name='ExtraData'),
            faceId?: string(name='FaceId'),
            score?: float(name='Score'),
          }
        ](name='FaceItems'),
        location?: {
          height?: int32(name='Height'),
          width?: int32(name='Width'),
          x?: int32(name='X'),
          y?: int32(name='Y'),
        }(name='Location'),
        qualitieScore?: float(name='QualitieScore'),
      }
    ](name='MatchList'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model SearchFaceResponse = {
  headers: map[string]string(name='headers'),
  body: SearchFaceResponseBody(name='body'),
}

async function searchFaceWithOptions(request: SearchFaceRequest, runtime: Util.RuntimeOptions): SearchFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SearchFace',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchFace(request: SearchFaceRequest): SearchFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchFaceWithOptions(request, runtime);
}

async function searchFaceAdvance(request: SearchFaceAdvanceRequest, runtime: Util.RuntimeOptions): SearchFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var searchFaceReq = new SearchFaceRequest{};
  OpenApiUtil.convert(request, searchFaceReq);

  if(!Util.isUnset(request.imageUrlObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageUrlObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    searchFaceReq.imageUrl =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var searchFaceResp = searchFaceWithOptions(searchFaceReq, runtime);
  return searchFaceResp;
}

model SwapFacialFeaturesRequest {
  editPart?: string(name='EditPart'),
  sourceImageData?: bytes(name='SourceImageData'),
  sourceImageURL?: string(name='SourceImageURL'),
  targetImageData?: bytes(name='TargetImageData'),
  targetImageURL?: string(name='TargetImageURL'),
}

model SwapFacialFeaturesResponseBody = {
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model SwapFacialFeaturesResponse = {
  headers: map[string]string(name='headers'),
  body: SwapFacialFeaturesResponseBody(name='body'),
}

async function swapFacialFeaturesWithOptions(request: SwapFacialFeaturesRequest, runtime: Util.RuntimeOptions): SwapFacialFeaturesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SwapFacialFeatures',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function swapFacialFeatures(request: SwapFacialFeaturesRequest): SwapFacialFeaturesResponse {
  var runtime = new Util.RuntimeOptions{};
  return swapFacialFeaturesWithOptions(request, runtime);
}

model UpdateFaceEntityRequest {
  dbName?: string(name='DbName'),
  entityId?: string(name='EntityId'),
  labels?: string(name='Labels'),
}

model UpdateFaceEntityResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateFaceEntityResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateFaceEntityResponseBody(name='body'),
}

async function updateFaceEntityWithOptions(request: UpdateFaceEntityRequest, runtime: Util.RuntimeOptions): UpdateFaceEntityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFaceEntity',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateFaceEntity(request: UpdateFaceEntityRequest): UpdateFaceEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFaceEntityWithOptions(request, runtime);
}

model VerifyFaceMaskRequest {
  imageData?: bytes(name='ImageData'),
  imageURL?: string(name='ImageURL'),
  refData?: bytes(name='RefData'),
  refUrl?: string(name='RefUrl'),
}

model VerifyFaceMaskResponseBody = {
  data?: {
    confidence?: float(name='Confidence'),
    mask?: int32(name='Mask'),
    maskRef?: int32(name='MaskRef'),
    rectangle?: [ int32 ](name='Rectangle'),
    rectangleRef?: [ int32 ](name='RectangleRef'),
    thresholds?: [ float ](name='Thresholds'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model VerifyFaceMaskResponse = {
  headers: map[string]string(name='headers'),
  body: VerifyFaceMaskResponseBody(name='body'),
}

async function verifyFaceMaskWithOptions(request: VerifyFaceMaskRequest, runtime: Util.RuntimeOptions): VerifyFaceMaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'VerifyFaceMask',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function verifyFaceMask(request: VerifyFaceMaskRequest): VerifyFaceMaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyFaceMaskWithOptions(request, runtime);
}

