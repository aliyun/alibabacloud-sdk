/**
 *
 */
import Util;
import OSS;
import RPC;
import OpenPlatform;
import OSSUtil;
import FileForm;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('facebody', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model ExtractPedestrianFeatureAttrRequest {
  imageURL?: string(name='ImageURL'),
  mode?: string(name='Mode'),
  serviceVersion?: string(name='ServiceVersion'),
}

model ExtractPedestrianFeatureAttrAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  mode?: string(name='Mode'),
  serviceVersion?: string(name='ServiceVersion'),
}

model ExtractPedestrianFeatureAttrResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    qualityScore?: float(name='QualityScore'),
    objType?: string(name='ObjType'),
    feature?: string(name='Feature'),
    gender?: string(name='Gender'),
    lowerColorScore?: float(name='LowerColorScore'),
    objTypeScore?: float(name='ObjTypeScore'),
    age?: string(name='Age'),
    ageScore?: float(name='AgeScore'),
    upperTypeScore?: float(name='UpperTypeScore'),
    lowerTypeScore?: float(name='LowerTypeScore'),
    lowerColor?: string(name='LowerColor'),
    hair?: string(name='Hair'),
    upperColor?: string(name='UpperColor'),
    genderScore?: float(name='GenderScore'),
    upperType?: string(name='UpperType'),
    hairScore?: float(name='HairScore'),
    lowerType?: string(name='LowerType'),
    upperColorScore?: float(name='UpperColorScore'),
    orientation?: string(name='Orientation'),
    orientationScore?: float(name='OrientationScore'),
  }(name='Data'),
}

model ExtractPedestrianFeatureAttrResponse = {
  headers: map[string]string(name='headers'),
  body: ExtractPedestrianFeatureAttrResponseBody(name='body'),
}

async function extractPedestrianFeatureAttrWithOptions(request: ExtractPedestrianFeatureAttrRequest, runtime: Util.RuntimeOptions): ExtractPedestrianFeatureAttrResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ExtractPedestrianFeatureAttr', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function extractPedestrianFeatureAttr(request: ExtractPedestrianFeatureAttrRequest): ExtractPedestrianFeatureAttrResponse {
  var runtime = new Util.RuntimeOptions{};
  return extractPedestrianFeatureAttrWithOptions(request, runtime);
}

async function extractPedestrianFeatureAttrAdvance(request: ExtractPedestrianFeatureAttrAdvanceRequest, runtime: Util.RuntimeOptions): ExtractPedestrianFeatureAttrResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var extractPedestrianFeatureAttrReq = new ExtractPedestrianFeatureAttrRequest{};
  OpenApiUtil.convert(request, extractPedestrianFeatureAttrReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    extractPedestrianFeatureAttrReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var extractPedestrianFeatureAttrResp = extractPedestrianFeatureAttrWithOptions(extractPedestrianFeatureAttrReq, runtime);
  return extractPedestrianFeatureAttrResp;
}

model DetectBodyCountRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectBodyCountAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model DetectBodyCountResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    personNumber?: int32(name='PersonNumber'),
  }(name='Data'),
}

model DetectBodyCountResponse = {
  headers: map[string]string(name='headers'),
  body: DetectBodyCountResponseBody(name='body'),
}

async function detectBodyCountWithOptions(request: DetectBodyCountRequest, runtime: Util.RuntimeOptions): DetectBodyCountResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectBodyCount', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectBodyCount(request: DetectBodyCountRequest): DetectBodyCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectBodyCountWithOptions(request, runtime);
}

async function detectBodyCountAdvance(request: DetectBodyCountAdvanceRequest, runtime: Util.RuntimeOptions): DetectBodyCountResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectBodyCountReq = new DetectBodyCountRequest{};
  OpenApiUtil.convert(request, detectBodyCountReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectBodyCountReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var detectBodyCountResp = detectBodyCountWithOptions(detectBodyCountReq, runtime);
  return detectBodyCountResp;
}

model DetectVideoLivingFaceRequest {
  videoUrl?: string(name='VideoUrl'),
}

model DetectVideoLivingFaceAdvanceRequest {
  videoUrlObject: readable(name='VideoUrlObject'),
}

model DetectVideoLivingFaceResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    elements?: [ 
      {
        rect?: [ int32 ](name='Rect'),
        liveConfidence?: float(name='LiveConfidence'),
        faceConfidence?: float(name='FaceConfidence'),
      }
    ](name='Elements'),
  }(name='Data'),
}

model DetectVideoLivingFaceResponse = {
  headers: map[string]string(name='headers'),
  body: DetectVideoLivingFaceResponseBody(name='body'),
}

async function detectVideoLivingFaceWithOptions(request: DetectVideoLivingFaceRequest, runtime: Util.RuntimeOptions): DetectVideoLivingFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectVideoLivingFace', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectVideoLivingFace(request: DetectVideoLivingFaceRequest): DetectVideoLivingFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectVideoLivingFaceWithOptions(request, runtime);
}

async function detectVideoLivingFaceAdvance(request: DetectVideoLivingFaceAdvanceRequest, runtime: Util.RuntimeOptions): DetectVideoLivingFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectVideoLivingFaceReq = new DetectVideoLivingFaceRequest{};
  OpenApiUtil.convert(request, detectVideoLivingFaceReq);

  if(!Util.isUnset(request.videoUrlObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.videoUrlObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectVideoLivingFaceReq.videoUrl = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var detectVideoLivingFaceResp = detectVideoLivingFaceWithOptions(detectVideoLivingFaceReq, runtime);
  return detectVideoLivingFaceResp;
}

model RecognizeFaceRequest {
  imageURL?: string(name='ImageURL'),
}

model RecognizeFaceAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model RecognizeFaceResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    pupils?: [ float ](name='Pupils'),
    genderList?: [ int32 ](name='GenderList'),
    expressions?: [ int32 ](name='Expressions'),
    denseFeatures?: [ string ](name='DenseFeatures'),
    faceCount?: int32(name='FaceCount'),
    landmarks?: [ float ](name='Landmarks'),
    landmarkCount?: int32(name='LandmarkCount'),
    qualities?: {
      scoreList?: [ float ](name='ScoreList'),
      blurList?: [ float ](name='BlurList'),
      fnfList?: [ float ](name='FnfList'),
      glassList?: [ float ](name='GlassList'),
      illuList?: [ float ](name='IlluList'),
      maskList?: [ float ](name='MaskList'),
      noiseList?: [ float ](name='NoiseList'),
      poseList?: [ float ](name='PoseList'),
    }(name='Qualities'),
    beautyList?: [ float ](name='BeautyList'),
    hatList?: [ int32 ](name='HatList'),
    faceProbabilityList?: [ float ](name='FaceProbabilityList'),
    glasses?: [ int32 ](name='Glasses'),
    faceRectangles?: [ int32 ](name='FaceRectangles'),
    poseList?: [ float ](name='PoseList'),
    ageList?: [ int32 ](name='AgeList'),
    denseFeatureLength?: int32(name='DenseFeatureLength'),
    masks?: [ long ](name='Masks'),
  }(name='Data'),
}

model RecognizeFaceResponse = {
  headers: map[string]string(name='headers'),
  body: RecognizeFaceResponseBody(name='body'),
}

async function recognizeFaceWithOptions(request: RecognizeFaceRequest, runtime: Util.RuntimeOptions): RecognizeFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RecognizeFace', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function recognizeFace(request: RecognizeFaceRequest): RecognizeFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizeFaceWithOptions(request, runtime);
}

async function recognizeFaceAdvance(request: RecognizeFaceAdvanceRequest, runtime: Util.RuntimeOptions): RecognizeFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var recognizeFaceReq = new RecognizeFaceRequest{};
  OpenApiUtil.convert(request, recognizeFaceReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    recognizeFaceReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var recognizeFaceResp = recognizeFaceWithOptions(recognizeFaceReq, runtime);
  return recognizeFaceResp;
}

model VerifyFaceMaskRequest {
  imageURL?: string(name='ImageURL'),
  refUrl?: string(name='RefUrl'),
  imageData?: bytes(name='ImageData'),
  refData?: bytes(name='RefData'),
}

model VerifyFaceMaskResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    thresholds?: [ float ](name='Thresholds'),
    mask?: int32(name='Mask'),
    confidence?: float(name='Confidence'),
    rectangle?: [ int32 ](name='Rectangle'),
    rectangleRef?: [ int32 ](name='RectangleRef'),
    maskRef?: int32(name='MaskRef'),
  }(name='Data'),
}

model VerifyFaceMaskResponse = {
  headers: map[string]string(name='headers'),
  body: VerifyFaceMaskResponseBody(name='body'),
}

async function verifyFaceMaskWithOptions(request: VerifyFaceMaskRequest, runtime: Util.RuntimeOptions): VerifyFaceMaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('VerifyFaceMask', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function verifyFaceMask(request: VerifyFaceMaskRequest): VerifyFaceMaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyFaceMaskWithOptions(request, runtime);
}

model DetectIPCPedestrianRequest {
  imageData?: string(name='ImageData'),
  width?: int32(name='Width'),
  height?: int32(name='Height'),
  imageURL?: string(name='ImageURL'),
}

model DetectIPCPedestrianAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  imageData?: string(name='ImageData'),
  width?: int32(name='Width'),
  height?: int32(name='Height'),
}

model DetectIPCPedestrianResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    imageInfoList?: [ 
      {
        elements?: [ 
          {
            boxes?: [ int32 ](name='Boxes'),
            score?: float(name='Score'),
          }
        ](name='Elements'),
      }
    ](name='ImageInfoList'),
  }(name='Data'),
}

model DetectIPCPedestrianResponse = {
  headers: map[string]string(name='headers'),
  body: DetectIPCPedestrianResponseBody(name='body'),
}

async function detectIPCPedestrianWithOptions(request: DetectIPCPedestrianRequest, runtime: Util.RuntimeOptions): DetectIPCPedestrianResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectIPCPedestrian', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectIPCPedestrian(request: DetectIPCPedestrianRequest): DetectIPCPedestrianResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectIPCPedestrianWithOptions(request, runtime);
}

async function detectIPCPedestrianAdvance(request: DetectIPCPedestrianAdvanceRequest, runtime: Util.RuntimeOptions): DetectIPCPedestrianResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectIPCPedestrianReq = new DetectIPCPedestrianRequest{};
  OpenApiUtil.convert(request, detectIPCPedestrianReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectIPCPedestrianReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var detectIPCPedestrianResp = detectIPCPedestrianWithOptions(detectIPCPedestrianReq, runtime);
  return detectIPCPedestrianResp;
}

model GetFaceEntityRequest {
  dbName?: string(name='DbName'),
  entityId?: string(name='EntityId'),
}

model GetFaceEntityResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    dbName?: string(name='DbName'),
    entityId?: string(name='EntityId'),
    labels?: string(name='Labels'),
    faces?: [ 
      {
        faceId?: string(name='FaceId'),
      }
    ](name='Faces'),
  }(name='Data'),
}

model GetFaceEntityResponse = {
  headers: map[string]string(name='headers'),
  body: GetFaceEntityResponseBody(name='body'),
}

async function getFaceEntityWithOptions(request: GetFaceEntityRequest, runtime: Util.RuntimeOptions): GetFaceEntityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetFaceEntity', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getFaceEntity(request: GetFaceEntityRequest): GetFaceEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFaceEntityWithOptions(request, runtime);
}

model CompareFaceRequest {
  qualityScoreThreshold?: float(name='QualityScoreThreshold', description='质量分阈值，取值范围 [0.0, 100.0],   0.0或空  表示不做质量分判断逻辑。'),
  imageURLA?: string(name='ImageURLA'),
  imageURLB?: string(name='ImageURLB'),
  imageDataA?: bytes(name='ImageDataA'),
  imageDataB?: bytes(name='ImageDataB'),
}

model CompareFaceResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    thresholds?: [ float ](name='Thresholds'),
    rectBList?: [ int32 ](name='RectBList'),
    confidence?: float(name='Confidence'),
    rectAList?: [ int32 ](name='RectAList'),
    qualityScoreA?: float(name='QualityScoreA', description='输入图像A的质量分'),
    qualityScoreB?: float(name='QualityScoreB', description='输入图像A的质量分'),
    messageTips?: string(name='MessageTips', description='信息提示信息，纯文字描述，目前支持质量分的提示信息'),
  }(name='Data'),
}

model CompareFaceResponse = {
  headers: map[string]string(name='headers'),
  body: CompareFaceResponseBody(name='body'),
}

async function compareFaceWithOptions(request: CompareFaceRequest, runtime: Util.RuntimeOptions): CompareFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CompareFace', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function compareFace(request: CompareFaceRequest): CompareFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return compareFaceWithOptions(request, runtime);
}

model PedestrianDetectAttributeRequest {
  imageURL?: string(name='ImageURL'),
}

model PedestrianDetectAttributeAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model PedestrianDetectAttributeResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    attributes?: [ 
      {
        gender?: {
          score?: float(name='Score'),
          name?: string(name='Name'),
        }(name='Gender'),
        orient?: {
          score?: float(name='Score'),
          name?: string(name='Name'),
        }(name='Orient'),
        age?: {
          score?: float(name='Score'),
          name?: string(name='Name'),
        }(name='Age'),
        upperWear?: {
          score?: float(name='Score'),
          name?: string(name='Name'),
        }(name='UpperWear'),
        glasses?: {
          score?: float(name='Score'),
          name?: string(name='Name'),
        }(name='Glasses'),
        lowerWear?: {
          score?: float(name='Score'),
          name?: string(name='Name'),
        }(name='LowerWear'),
        lowerColor?: {
          score?: float(name='Score'),
          name?: string(name='Name'),
        }(name='LowerColor'),
        hat?: {
          score?: float(name='Score'),
          name?: string(name='Name'),
        }(name='Hat'),
        handbag?: {
          score?: float(name='Score'),
          name?: string(name='Name'),
        }(name='Handbag'),
        backpack?: {
          score?: float(name='Score'),
          name?: string(name='Name'),
        }(name='Backpack'),
        upperColor?: {
          score?: float(name='Score'),
          name?: string(name='Name'),
        }(name='UpperColor'),
        shoulderBag?: {
          score?: float(name='Score'),
          name?: string(name='Name'),
        }(name='ShoulderBag'),
      }
    ](name='Attributes'),
    boxes?: [ 
      {
        bottomRightX?: float(name='BottomRightX'),
        topLeftY?: float(name='TopLeftY'),
        score?: float(name='Score'),
        topLeftX?: float(name='TopLeftX'),
        bottomRightY?: float(name='BottomRightY'),
      }
    ](name='Boxes'),
    personNumber?: int32(name='PersonNumber'),
    width?: long(name='Width'),
    height?: long(name='Height'),
  }(name='Data'),
}

model PedestrianDetectAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: PedestrianDetectAttributeResponseBody(name='body'),
}

async function pedestrianDetectAttributeWithOptions(request: PedestrianDetectAttributeRequest, runtime: Util.RuntimeOptions): PedestrianDetectAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PedestrianDetectAttribute', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function pedestrianDetectAttribute(request: PedestrianDetectAttributeRequest): PedestrianDetectAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return pedestrianDetectAttributeWithOptions(request, runtime);
}

async function pedestrianDetectAttributeAdvance(request: PedestrianDetectAttributeAdvanceRequest, runtime: Util.RuntimeOptions): PedestrianDetectAttributeResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var pedestrianDetectAttributeReq = new PedestrianDetectAttributeRequest{};
  OpenApiUtil.convert(request, pedestrianDetectAttributeReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    pedestrianDetectAttributeReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var pedestrianDetectAttributeResp = pedestrianDetectAttributeWithOptions(pedestrianDetectAttributeReq, runtime);
  return pedestrianDetectAttributeResp;
}

model FaceFilterRequest {
  imageURL?: string(name='ImageURL'),
  resourceType?: string(name='ResourceType'),
  strength?: float(name='Strength'),
}

model FaceFilterAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  resourceType?: string(name='ResourceType'),
  strength?: float(name='Strength'),
}

model FaceFilterResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
}

model FaceFilterResponse = {
  headers: map[string]string(name='headers'),
  body: FaceFilterResponseBody(name='body'),
}

async function faceFilterWithOptions(request: FaceFilterRequest, runtime: Util.RuntimeOptions): FaceFilterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('FaceFilter', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function faceFilter(request: FaceFilterRequest): FaceFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return faceFilterWithOptions(request, runtime);
}

async function faceFilterAdvance(request: FaceFilterAdvanceRequest, runtime: Util.RuntimeOptions): FaceFilterResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var faceFilterReq = new FaceFilterRequest{};
  OpenApiUtil.convert(request, faceFilterReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    faceFilterReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var faceFilterResp = faceFilterWithOptions(faceFilterReq, runtime);
  return faceFilterResp;
}

model FaceBeautyRequest {
  imageURL?: string(name='ImageURL'),
  sharp?: float(name='Sharp'),
  smooth?: float(name='Smooth'),
  white?: float(name='White'),
}

model FaceBeautyAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  sharp?: float(name='Sharp'),
  smooth?: float(name='Smooth'),
  white?: float(name='White'),
}

model FaceBeautyResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
}

model FaceBeautyResponse = {
  headers: map[string]string(name='headers'),
  body: FaceBeautyResponseBody(name='body'),
}

async function faceBeautyWithOptions(request: FaceBeautyRequest, runtime: Util.RuntimeOptions): FaceBeautyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('FaceBeauty', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function faceBeauty(request: FaceBeautyRequest): FaceBeautyResponse {
  var runtime = new Util.RuntimeOptions{};
  return faceBeautyWithOptions(request, runtime);
}

async function faceBeautyAdvance(request: FaceBeautyAdvanceRequest, runtime: Util.RuntimeOptions): FaceBeautyResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var faceBeautyReq = new FaceBeautyRequest{};
  OpenApiUtil.convert(request, faceBeautyReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    faceBeautyReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var faceBeautyResp = faceBeautyWithOptions(faceBeautyReq, runtime);
  return faceBeautyResp;
}

model GenerateHumanAnimeStyleRequest {
  imageURL?: string(name='ImageURL'),
  algoType?: string(name='AlgoType'),
}

model GenerateHumanAnimeStyleAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  algoType?: string(name='AlgoType'),
}

model GenerateHumanAnimeStyleResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
}

model GenerateHumanAnimeStyleResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateHumanAnimeStyleResponseBody(name='body'),
}

async function generateHumanAnimeStyleWithOptions(request: GenerateHumanAnimeStyleRequest, runtime: Util.RuntimeOptions): GenerateHumanAnimeStyleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GenerateHumanAnimeStyle', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function generateHumanAnimeStyle(request: GenerateHumanAnimeStyleRequest): GenerateHumanAnimeStyleResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateHumanAnimeStyleWithOptions(request, runtime);
}

async function generateHumanAnimeStyleAdvance(request: GenerateHumanAnimeStyleAdvanceRequest, runtime: Util.RuntimeOptions): GenerateHumanAnimeStyleResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var generateHumanAnimeStyleReq = new GenerateHumanAnimeStyleRequest{};
  OpenApiUtil.convert(request, generateHumanAnimeStyleReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    generateHumanAnimeStyleReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var generateHumanAnimeStyleResp = generateHumanAnimeStyleWithOptions(generateHumanAnimeStyleReq, runtime);
  return generateHumanAnimeStyleResp;
}

model QueryFaceImageTemplateRequest {
  userId?: string(name='UserId', description='A short description of struct'),
  templateId?: string(name='TemplateId'),
}

model QueryFaceImageTemplateResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  data?: {
    elements?: [ 
      {
        createTime?: string(name='CreateTime'),
        updateTime?: string(name='UpdateTime'),
        userId?: string(name='UserId'),
        templateId?: string(name='TemplateId'),
        templateURL?: string(name='TemplateURL'),
      }
    ](name='Elements'),
  }(name='Data'),
}

model QueryFaceImageTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: QueryFaceImageTemplateResponseBody(name='body'),
}

async function queryFaceImageTemplateWithOptions(request: QueryFaceImageTemplateRequest, runtime: Util.RuntimeOptions): QueryFaceImageTemplateResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('QueryFaceImageTemplate', '2019-12-30', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function queryFaceImageTemplate(request: QueryFaceImageTemplateRequest): QueryFaceImageTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFaceImageTemplateWithOptions(request, runtime);
}

model DetectFaceRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectFaceAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model DetectFaceResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    faceProbabilityList?: [ float ](name='FaceProbabilityList'),
    pupils?: [ float ](name='Pupils'),
    faceRectangles?: [ int32 ](name='FaceRectangles'),
    faceCount?: int32(name='FaceCount'),
    poseList?: [ float ](name='PoseList'),
    landmarks?: [ float ](name='Landmarks'),
    landmarkCount?: int32(name='LandmarkCount'),
    qualities?: {
      scoreList?: [ float ](name='ScoreList'),
      blurList?: [ float ](name='BlurList'),
      fnfList?: [ float ](name='FnfList'),
      glassList?: [ float ](name='GlassList'),
      illuList?: [ float ](name='IlluList'),
      maskList?: [ float ](name='MaskList'),
      noiseList?: [ float ](name='NoiseList'),
      poseList?: [ float ](name='PoseList'),
    }(name='Qualities'),
  }(name='Data'),
}

model DetectFaceResponse = {
  headers: map[string]string(name='headers'),
  body: DetectFaceResponseBody(name='body'),
}

async function detectFaceWithOptions(request: DetectFaceRequest, runtime: Util.RuntimeOptions): DetectFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectFace', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectFace(request: DetectFaceRequest): DetectFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectFaceWithOptions(request, runtime);
}

async function detectFaceAdvance(request: DetectFaceAdvanceRequest, runtime: Util.RuntimeOptions): DetectFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectFaceReq = new DetectFaceRequest{};
  OpenApiUtil.convert(request, detectFaceReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectFaceReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var detectFaceResp = detectFaceWithOptions(detectFaceReq, runtime);
  return detectFaceResp;
}

model DetectMaskRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectMaskAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model DetectMaskResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    mask?: int32(name='Mask'),
    faceProbability?: float(name='FaceProbability'),
  }(name='Data'),
}

model DetectMaskResponse = {
  headers: map[string]string(name='headers'),
  body: DetectMaskResponseBody(name='body'),
}

async function detectMaskWithOptions(request: DetectMaskRequest, runtime: Util.RuntimeOptions): DetectMaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectMask', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectMask(request: DetectMaskRequest): DetectMaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectMaskWithOptions(request, runtime);
}

async function detectMaskAdvance(request: DetectMaskAdvanceRequest, runtime: Util.RuntimeOptions): DetectMaskResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectMaskReq = new DetectMaskRequest{};
  OpenApiUtil.convert(request, detectMaskReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectMaskReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var detectMaskResp = detectMaskWithOptions(detectMaskReq, runtime);
  return detectMaskResp;
}

model GenRealPersonVerificationTokenRequest {
  certificateName?: string(name='CertificateName'),
  certificateNumber?: string(name='CertificateNumber'),
  metaInfo?: string(name='MetaInfo'),
}

model GenRealPersonVerificationTokenResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    verificationToken?: string(name='VerificationToken'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GenRealPersonVerificationTokenResponse = {
  headers: map[string]string(name='headers'),
  body: GenRealPersonVerificationTokenResponseBody(name='body'),
}

async function genRealPersonVerificationTokenWithOptions(request: GenRealPersonVerificationTokenRequest, runtime: Util.RuntimeOptions): GenRealPersonVerificationTokenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GenRealPersonVerificationToken', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function genRealPersonVerificationToken(request: GenRealPersonVerificationTokenRequest): GenRealPersonVerificationTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return genRealPersonVerificationTokenWithOptions(request, runtime);
}

model ListFaceDbsResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    dbList?: [ 
      {
        name?: string(name='Name'),
      }
    ](name='DbList'),
  }(name='Data'),
}

model ListFaceDbsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFaceDbsResponseBody(name='body'),
}

async function listFaceDbsWithOptions(runtime: Util.RuntimeOptions): ListFaceDbsResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('ListFaceDbs', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFaceDbs(): ListFaceDbsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFaceDbsWithOptions(runtime);
}

model RecognizeActionRequest {
  type?: int32(name='Type'),
  videoUrl?: string(name='VideoUrl'),
  URLList?: [ 
    {
      URL?: string(name='URL'),
      imageData?: bytes(name='imageData'),
    }
  ](name='URLList'),
  videoData?: bytes(name='VideoData'),
}

model RecognizeActionResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    elements?: [ 
      {
        scores?: [ float ](name='Scores'),
        labels?: [ string ](name='Labels'),
        boxes?: [ 
          {
            box?: [ int32 ](name='Box'),
          }
        ](name='Boxes'),
        timestamp?: int32(name='Timestamp'),
      }
    ](name='Elements'),
  }(name='Data'),
}

model RecognizeActionResponse = {
  headers: map[string]string(name='headers'),
  body: RecognizeActionResponseBody(name='body'),
}

async function recognizeActionWithOptions(request: RecognizeActionRequest, runtime: Util.RuntimeOptions): RecognizeActionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RecognizeAction', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function recognizeAction(request: RecognizeActionRequest): RecognizeActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizeActionWithOptions(request, runtime);
}

model DetectChefCapRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectChefCapAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model DetectChefCapResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    elements?: [ 
      {
        confidence?: float(name='Confidence'),
        category?: string(name='Category'),
        box?: [ float ](name='Box'),
      }
    ](name='Elements'),
  }(name='Data'),
}

model DetectChefCapResponse = {
  headers: map[string]string(name='headers'),
  body: DetectChefCapResponseBody(name='body'),
}

async function detectChefCapWithOptions(request: DetectChefCapRequest, runtime: Util.RuntimeOptions): DetectChefCapResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectChefCap', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectChefCap(request: DetectChefCapRequest): DetectChefCapResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectChefCapWithOptions(request, runtime);
}

async function detectChefCapAdvance(request: DetectChefCapAdvanceRequest, runtime: Util.RuntimeOptions): DetectChefCapResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectChefCapReq = new DetectChefCapRequest{};
  OpenApiUtil.convert(request, detectChefCapReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectChefCapReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var detectChefCapResp = detectChefCapWithOptions(detectChefCapReq, runtime);
  return detectChefCapResp;
}

model DetectLivingFaceRequest {
  tasks?: [ 
    {
      imageURL?: string(name='ImageURL'),
      imageData?: bytes(name='ImageData'),
    }
  ](name='Tasks'),
}

model DetectLivingFaceResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    elements?: [ 
      {
        imageURL?: string(name='ImageURL'),
        taskId?: string(name='TaskId'),
        results?: [ 
          {
            suggestion?: string(name='Suggestion'),
            frames?: [ 
              {
                url?: string(name='Url'),
                rate?: float(name='Rate'),
              }
            ](name='Frames'),
            label?: string(name='Label'),
            rate?: float(name='Rate'),
          }
        ](name='Results'),
      }
    ](name='Elements'),
  }(name='Data'),
}

model DetectLivingFaceResponse = {
  headers: map[string]string(name='headers'),
  body: DetectLivingFaceResponseBody(name='body'),
}

async function detectLivingFaceWithOptions(request: DetectLivingFaceRequest, runtime: Util.RuntimeOptions): DetectLivingFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectLivingFace', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectLivingFace(request: DetectLivingFaceRequest): DetectLivingFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectLivingFaceWithOptions(request, runtime);
}

model DetectCelebrityRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectCelebrityAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model DetectCelebrityResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    faceRecognizeResults?: [ 
      {
        faceBoxes?: [ float ](name='FaceBoxes'),
        name?: string(name='Name'),
      }
    ](name='FaceRecognizeResults'),
    width?: int32(name='Width'),
    height?: int32(name='Height'),
  }(name='Data'),
}

model DetectCelebrityResponse = {
  headers: map[string]string(name='headers'),
  body: DetectCelebrityResponseBody(name='body'),
}

async function detectCelebrityWithOptions(request: DetectCelebrityRequest, runtime: Util.RuntimeOptions): DetectCelebrityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectCelebrity', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectCelebrity(request: DetectCelebrityRequest): DetectCelebrityResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectCelebrityWithOptions(request, runtime);
}

async function detectCelebrityAdvance(request: DetectCelebrityAdvanceRequest, runtime: Util.RuntimeOptions): DetectCelebrityResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectCelebrityReq = new DetectCelebrityRequest{};
  OpenApiUtil.convert(request, detectCelebrityReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectCelebrityReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var detectCelebrityResp = detectCelebrityWithOptions(detectCelebrityReq, runtime);
  return detectCelebrityResp;
}

model GetRealPersonVerificationResultRequest {
  verificationToken?: string(name='VerificationToken'),
  materialHash?: string(name='MaterialHash'),
}

model GetRealPersonVerificationResultResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    pass?: boolean(name='Pass'),
    identityInfo?: string(name='IdentityInfo'),
    materialMatch?: string(name='MaterialMatch'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetRealPersonVerificationResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetRealPersonVerificationResultResponseBody(name='body'),
}

async function getRealPersonVerificationResultWithOptions(request: GetRealPersonVerificationResultRequest, runtime: Util.RuntimeOptions): GetRealPersonVerificationResultResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetRealPersonVerificationResult', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getRealPersonVerificationResult(request: GetRealPersonVerificationResultRequest): GetRealPersonVerificationResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRealPersonVerificationResultWithOptions(request, runtime);
}

model DeleteFaceRequest {
  dbName?: string(name='DbName'),
  faceId?: string(name='FaceId'),
}

model DeleteFaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFaceResponseBody(name='body'),
}

async function deleteFaceWithOptions(request: DeleteFaceRequest, runtime: Util.RuntimeOptions): DeleteFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteFace', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteFace(request: DeleteFaceRequest): DeleteFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFaceWithOptions(request, runtime);
}

model ExtractPedestrianFeatureAttributeRequest {
  mode?: string(name='Mode'),
  imageURL?: string(name='ImageURL'),
  urlList?: [ 
    {
      url?: string(name='Url'),
    }
  ](name='UrlList'),
}

model ExtractPedestrianFeatureAttributeResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    qualityScore?: float(name='QualityScore'),
    objType?: string(name='ObjType'),
    elements?: [ 
      {
        qualityScore?: float(name='QualityScore'),
        objType?: string(name='ObjType'),
        feature?: string(name='Feature'),
        gender?: string(name='Gender'),
        lowerColorScore?: float(name='LowerColorScore'),
        objTypeScore?: float(name='ObjTypeScore'),
        age?: string(name='Age'),
        ageScore?: float(name='AgeScore'),
        upperTypeScore?: float(name='UpperTypeScore'),
        lowerTypeScore?: float(name='LowerTypeScore'),
        lowerColor?: string(name='LowerColor'),
        hair?: string(name='Hair'),
        upperColor?: string(name='UpperColor'),
        genderScore?: float(name='GenderScore'),
        upperType?: string(name='UpperType'),
        hairScore?: float(name='HairScore'),
        lowerType?: string(name='LowerType'),
        upperColorScore?: float(name='UpperColorScore'),
      }
    ](name='Elements'),
    feature?: string(name='Feature'),
    gender?: string(name='Gender'),
    lowerColorScore?: float(name='LowerColorScore'),
    objTypeScore?: float(name='ObjTypeScore'),
    age?: string(name='Age'),
    ageScore?: float(name='AgeScore'),
    upperTypeScore?: float(name='UpperTypeScore'),
    lowerTypeScore?: float(name='LowerTypeScore'),
    lowerColor?: string(name='LowerColor'),
    hair?: string(name='Hair'),
    upperColor?: string(name='UpperColor'),
    genderScore?: float(name='GenderScore'),
    upperType?: string(name='UpperType'),
    hairScore?: float(name='HairScore'),
    lowerType?: string(name='LowerType'),
    upperColorScore?: float(name='UpperColorScore'),
  }(name='Data'),
}

model ExtractPedestrianFeatureAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ExtractPedestrianFeatureAttributeResponseBody(name='body'),
}

async function extractPedestrianFeatureAttributeWithOptions(request: ExtractPedestrianFeatureAttributeRequest, runtime: Util.RuntimeOptions): ExtractPedestrianFeatureAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ExtractPedestrianFeatureAttribute', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function extractPedestrianFeatureAttribute(request: ExtractPedestrianFeatureAttributeRequest): ExtractPedestrianFeatureAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return extractPedestrianFeatureAttributeWithOptions(request, runtime);
}

model RecognizeExpressionRequest {
  imageURL?: string(name='ImageURL'),
}

model RecognizeExpressionAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model RecognizeExpressionResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    elements?: [ 
      {
        faceRectangle?: {
          top?: int32(name='Top'),
          width?: int32(name='Width'),
          height?: int32(name='Height'),
          left?: int32(name='Left'),
        }(name='FaceRectangle'),
        expression?: string(name='Expression'),
        faceProbability?: float(name='FaceProbability'),
      }
    ](name='Elements'),
  }(name='Data'),
}

model RecognizeExpressionResponse = {
  headers: map[string]string(name='headers'),
  body: RecognizeExpressionResponseBody(name='body'),
}

async function recognizeExpressionWithOptions(request: RecognizeExpressionRequest, runtime: Util.RuntimeOptions): RecognizeExpressionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RecognizeExpression', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function recognizeExpression(request: RecognizeExpressionRequest): RecognizeExpressionResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizeExpressionWithOptions(request, runtime);
}

async function recognizeExpressionAdvance(request: RecognizeExpressionAdvanceRequest, runtime: Util.RuntimeOptions): RecognizeExpressionResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var recognizeExpressionReq = new RecognizeExpressionRequest{};
  OpenApiUtil.convert(request, recognizeExpressionReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    recognizeExpressionReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var recognizeExpressionResp = recognizeExpressionWithOptions(recognizeExpressionReq, runtime);
  return recognizeExpressionResp;
}

model MergeImageFaceRequest {
  userId?: string(name='UserId', description='A short description of struct'),
  templateId?: string(name='TemplateId'),
  imageURL?: string(name='ImageURL'),
}

model MergeImageFaceAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  userId?: string(name='UserId', description='A short description of struct'),
  templateId?: string(name='TemplateId'),
}

model MergeImageFaceResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
}

model MergeImageFaceResponse = {
  headers: map[string]string(name='headers'),
  body: MergeImageFaceResponseBody(name='body'),
}

async function mergeImageFaceWithOptions(request: MergeImageFaceRequest, runtime: Util.RuntimeOptions): MergeImageFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('MergeImageFace', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function mergeImageFace(request: MergeImageFaceRequest): MergeImageFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return mergeImageFaceWithOptions(request, runtime);
}

async function mergeImageFaceAdvance(request: MergeImageFaceAdvanceRequest, runtime: Util.RuntimeOptions): MergeImageFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var mergeImageFaceReq = new MergeImageFaceRequest{};
  OpenApiUtil.convert(request, mergeImageFaceReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    mergeImageFaceReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var mergeImageFaceResp = mergeImageFaceWithOptions(mergeImageFaceReq, runtime);
  return mergeImageFaceResp;
}

model DeleteBodyPersonRequest {
  dbId?: long(name='DbId', description='数据库ID'),
  personId?: long(name='PersonId', description='人员ID'),
}

model DeleteBodyPersonResponseBody = {
  requestId?: string(name='RequestId', description='RequestId'),
}

model DeleteBodyPersonResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBodyPersonResponseBody(name='body'),
}

async function deleteBodyPersonWithOptions(request: DeleteBodyPersonRequest, runtime: Util.RuntimeOptions): DeleteBodyPersonResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteBodyPerson', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteBodyPerson(request: DeleteBodyPersonRequest): DeleteBodyPersonResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBodyPersonWithOptions(request, runtime);
}

model DetectPedestrianRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectPedestrianAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model DetectPedestrianResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    elements?: [ 
      {
        type?: string(name='Type'),
        boxes?: [ int32 ](name='Boxes'),
        score?: float(name='Score'),
      }
    ](name='Elements'),
    width?: int32(name='Width'),
    height?: int32(name='Height'),
  }(name='Data'),
}

model DetectPedestrianResponse = {
  headers: map[string]string(name='headers'),
  body: DetectPedestrianResponseBody(name='body'),
}

async function detectPedestrianWithOptions(request: DetectPedestrianRequest, runtime: Util.RuntimeOptions): DetectPedestrianResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectPedestrian', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectPedestrian(request: DetectPedestrianRequest): DetectPedestrianResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectPedestrianWithOptions(request, runtime);
}

async function detectPedestrianAdvance(request: DetectPedestrianAdvanceRequest, runtime: Util.RuntimeOptions): DetectPedestrianResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectPedestrianReq = new DetectPedestrianRequest{};
  OpenApiUtil.convert(request, detectPedestrianReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectPedestrianReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var detectPedestrianResp = detectPedestrianWithOptions(detectPedestrianReq, runtime);
  return detectPedestrianResp;
}

model SwapFacialFeaturesRequest {
  editPart?: string(name='EditPart'),
  sourceImageURL?: string(name='SourceImageURL'),
  targetImageURL?: string(name='TargetImageURL'),
  sourceImageData?: bytes(name='SourceImageData'),
  targetImageData?: bytes(name='TargetImageData'),
}

model SwapFacialFeaturesResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
}

model SwapFacialFeaturesResponse = {
  headers: map[string]string(name='headers'),
  body: SwapFacialFeaturesResponseBody(name='body'),
}

async function swapFacialFeaturesWithOptions(request: SwapFacialFeaturesRequest, runtime: Util.RuntimeOptions): SwapFacialFeaturesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SwapFacialFeatures', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function swapFacialFeatures(request: SwapFacialFeaturesRequest): SwapFacialFeaturesResponse {
  var runtime = new Util.RuntimeOptions{};
  return swapFacialFeaturesWithOptions(request, runtime);
}

model SearchFaceRequest {
  dbName?: string(name='DbName'),
  imageUrl?: string(name='ImageUrl'),
  limit?: int32(name='Limit'),
  dbNames?: string(name='DbNames'),
}

model SearchFaceAdvanceRequest {
  imageUrlObject: readable(name='ImageUrlObject'),
  dbName?: string(name='DbName'),
  limit?: int32(name='Limit'),
  dbNames?: string(name='DbNames'),
}

model SearchFaceResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    matchList?: [ 
      {
        faceItems?: [ 
          {
            entityId?: string(name='EntityId'),
            faceId?: string(name='FaceId'),
            score?: float(name='Score'),
            extraData?: string(name='ExtraData'),
            dbName?: string(name='DbName'),
          }
        ](name='FaceItems'),
        location?: {
          width?: int32(name='Width'),
          height?: int32(name='Height'),
          y?: int32(name='Y'),
          x?: int32(name='X'),
        }(name='Location'),
      }
    ](name='MatchList'),
  }(name='Data'),
}

model SearchFaceResponse = {
  headers: map[string]string(name='headers'),
  body: SearchFaceResponseBody(name='body'),
}

async function searchFaceWithOptions(request: SearchFaceRequest, runtime: Util.RuntimeOptions): SearchFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SearchFace', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function searchFace(request: SearchFaceRequest): SearchFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchFaceWithOptions(request, runtime);
}

async function searchFaceAdvance(request: SearchFaceAdvanceRequest, runtime: Util.RuntimeOptions): SearchFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var searchFaceReq = new SearchFaceRequest{};
  OpenApiUtil.convert(request, searchFaceReq);

  if(!Util.isUnset(request.imageUrlObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageUrlObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    searchFaceReq.imageUrl = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var searchFaceResp = searchFaceWithOptions(searchFaceReq, runtime);
  return searchFaceResp;
}

model UpdateFaceEntityRequest {
  dbName?: string(name='DbName'),
  entityId?: string(name='EntityId'),
  labels?: string(name='Labels'),
}

model UpdateFaceEntityResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateFaceEntityResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateFaceEntityResponseBody(name='body'),
}

async function updateFaceEntityWithOptions(request: UpdateFaceEntityRequest, runtime: Util.RuntimeOptions): UpdateFaceEntityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateFaceEntity', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateFaceEntity(request: UpdateFaceEntityRequest): UpdateFaceEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFaceEntityWithOptions(request, runtime);
}

model BlurFaceRequest {
  imageURL?: string(name='ImageURL'),
}

model BlurFaceAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model BlurFaceResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
}

model BlurFaceResponse = {
  headers: map[string]string(name='headers'),
  body: BlurFaceResponseBody(name='body'),
}

async function blurFaceWithOptions(request: BlurFaceRequest, runtime: Util.RuntimeOptions): BlurFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('BlurFace', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function blurFace(request: BlurFaceRequest): BlurFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return blurFaceWithOptions(request, runtime);
}

async function blurFaceAdvance(request: BlurFaceAdvanceRequest, runtime: Util.RuntimeOptions): BlurFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var blurFaceReq = new BlurFaceRequest{};
  OpenApiUtil.convert(request, blurFaceReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    blurFaceReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var blurFaceResp = blurFaceWithOptions(blurFaceReq, runtime);
  return blurFaceResp;
}

model FaceMakeupRequest {
  imageURL?: string(name='ImageURL'),
  makeupType?: string(name='MakeupType'),
  resourceType?: string(name='ResourceType'),
  strength?: float(name='Strength'),
}

model FaceMakeupAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  makeupType?: string(name='MakeupType'),
  resourceType?: string(name='ResourceType'),
  strength?: float(name='Strength'),
}

model FaceMakeupResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
}

model FaceMakeupResponse = {
  headers: map[string]string(name='headers'),
  body: FaceMakeupResponseBody(name='body'),
}

async function faceMakeupWithOptions(request: FaceMakeupRequest, runtime: Util.RuntimeOptions): FaceMakeupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('FaceMakeup', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function faceMakeup(request: FaceMakeupRequest): FaceMakeupResponse {
  var runtime = new Util.RuntimeOptions{};
  return faceMakeupWithOptions(request, runtime);
}

async function faceMakeupAdvance(request: FaceMakeupAdvanceRequest, runtime: Util.RuntimeOptions): FaceMakeupResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var faceMakeupReq = new FaceMakeupRequest{};
  OpenApiUtil.convert(request, faceMakeupReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    faceMakeupReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var faceMakeupResp = faceMakeupWithOptions(faceMakeupReq, runtime);
  return faceMakeupResp;
}

model CreateBodyPersonRequest {
  dbId?: long(name='DbId', description='数据库ID'),
  name?: string(name='Name', description='实体ID，可以包含数字、字母和下划线，相同db下不可以重复，长度1-64。'),
}

model CreateBodyPersonResponseBody = {
  requestId?: string(name='RequestId', description='RequestId'),
  data?: {
    id?: long(name='Id', description='数据库ID'),
  }(name='Data'),
}

model CreateBodyPersonResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBodyPersonResponseBody(name='body'),
}

async function createBodyPersonWithOptions(request: CreateBodyPersonRequest, runtime: Util.RuntimeOptions): CreateBodyPersonResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateBodyPerson', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createBodyPerson(request: CreateBodyPersonRequest): CreateBodyPersonResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBodyPersonWithOptions(request, runtime);
}

model AddFaceRequest {
  dbName?: string(name='DbName'),
  imageUrl?: string(name='ImageUrl'),
  entityId?: string(name='EntityId'),
  extraData?: string(name='ExtraData'),
}

model AddFaceAdvanceRequest {
  imageUrlObject: readable(name='ImageUrlObject'),
  dbName?: string(name='DbName'),
  entityId?: string(name='EntityId'),
  extraData?: string(name='ExtraData'),
}

model AddFaceResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    faceId?: string(name='FaceId'),
  }(name='Data'),
}

model AddFaceResponse = {
  headers: map[string]string(name='headers'),
  body: AddFaceResponseBody(name='body'),
}

async function addFaceWithOptions(request: AddFaceRequest, runtime: Util.RuntimeOptions): AddFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddFace', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addFace(request: AddFaceRequest): AddFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addFaceWithOptions(request, runtime);
}

async function addFaceAdvance(request: AddFaceAdvanceRequest, runtime: Util.RuntimeOptions): AddFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var addFaceReq = new AddFaceRequest{};
  OpenApiUtil.convert(request, addFaceReq);

  if(!Util.isUnset(request.imageUrlObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageUrlObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    addFaceReq.imageUrl = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var addFaceResp = addFaceWithOptions(addFaceReq, runtime);
  return addFaceResp;
}

model GenerateHumanSketchStyleRequest {
  imageURL?: string(name='ImageURL', description='A short description of struct'),
}

model GenerateHumanSketchStyleAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model GenerateHumanSketchStyleResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  data?: {
    imageURL?: string(name='ImageURL', description='出参图片地址'),
  }(name='Data'),
}

model GenerateHumanSketchStyleResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateHumanSketchStyleResponseBody(name='body'),
}

async function generateHumanSketchStyleWithOptions(request: GenerateHumanSketchStyleRequest, runtime: Util.RuntimeOptions): GenerateHumanSketchStyleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GenerateHumanSketchStyle', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function generateHumanSketchStyle(request: GenerateHumanSketchStyleRequest): GenerateHumanSketchStyleResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateHumanSketchStyleWithOptions(request, runtime);
}

async function generateHumanSketchStyleAdvance(request: GenerateHumanSketchStyleAdvanceRequest, runtime: Util.RuntimeOptions): GenerateHumanSketchStyleResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var generateHumanSketchStyleReq = new GenerateHumanSketchStyleRequest{};
  OpenApiUtil.convert(request, generateHumanSketchStyleReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    generateHumanSketchStyleReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var generateHumanSketchStyleResp = generateHumanSketchStyleWithOptions(generateHumanSketchStyleReq, runtime);
  return generateHumanSketchStyleResp;
}

model DeleteBodyDbRequest {
  id?: long(name='Id', description='数据库ID'),
}

model DeleteBodyDbResponseBody = {
  requestId?: string(name='RequestId', description='RequestId'),
}

model DeleteBodyDbResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBodyDbResponseBody(name='body'),
}

async function deleteBodyDbWithOptions(request: DeleteBodyDbRequest, runtime: Util.RuntimeOptions): DeleteBodyDbResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteBodyDb', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteBodyDb(request: DeleteBodyDbRequest): DeleteBodyDbResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBodyDbWithOptions(request, runtime);
}

model DetectPedestrianIntrusionRequest {
  imageURL?: string(name='ImageURL'),
  detectRegion?: [ 
    {
      rect?: {
        left?: long(name='Left'),
        top?: long(name='Top'),
        right?: long(name='Right'),
        bottom?: long(name='Bottom'),
      }(name='Rect'),
      line?: {
        x1?: long(name='X1'),
        y1?: long(name='Y1'),
        x2?: long(name='X2'),
        y2?: long(name='Y2'),
      }(name='Line'),
    }
  ](name='DetectRegion'),
  regionType?: string(name='RegionType'),
}

model DetectPedestrianIntrusionAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  detectRegion?: [ 
    {
      rect?: {
        left?: long(name='Left'),
        top?: long(name='Top'),
        right?: long(name='Right'),
        bottom?: long(name='Bottom'),
      }(name='Rect'),
      line?: {
        x1?: long(name='X1'),
        y1?: long(name='Y1'),
        x2?: long(name='X2'),
        y2?: long(name='Y2'),
      }(name='Line'),
    }
  ](name='DetectRegion'),
  regionType?: string(name='RegionType'),
}

model DetectPedestrianIntrusionShrinkRequest {
  imageURL?: string(name='ImageURL'),
  detectRegionShrink?: string(name='DetectRegion'),
  regionType?: string(name='RegionType'),
}

model DetectPedestrianIntrusionResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    imageWidth?: long(name='ImageWidth'),
    imageHeight?: long(name='ImageHeight'),
    elements?: [ 
      {
        score?: long(name='Score'),
        type?: string(name='Type'),
        isIntrude?: boolean(name='IsIntrude'),
        box?: {
          left?: long(name='Left'),
          top?: long(name='Top'),
          right?: long(name='Right'),
          bottom?: long(name='Bottom'),
        }(name='Box'),
        boxId?: long(name='BoxId'),
      }
    ](name='Elements'),
  }(name='Data'),
}

model DetectPedestrianIntrusionResponse = {
  headers: map[string]string(name='headers'),
  body: DetectPedestrianIntrusionResponseBody(name='body'),
}

async function detectPedestrianIntrusionWithOptions(tmpReq: DetectPedestrianIntrusionRequest, runtime: Util.RuntimeOptions): DetectPedestrianIntrusionResponse {
  Util.validateModel(tmpReq);
  var request = new DetectPedestrianIntrusionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.detectRegion)) {
    request.detectRegionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.detectRegion, 'DetectRegion', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectPedestrianIntrusion', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectPedestrianIntrusion(request: DetectPedestrianIntrusionRequest): DetectPedestrianIntrusionResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectPedestrianIntrusionWithOptions(request, runtime);
}

async function detectPedestrianIntrusionAdvance(request: DetectPedestrianIntrusionAdvanceRequest, runtime: Util.RuntimeOptions): DetectPedestrianIntrusionResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectPedestrianIntrusionReq = new DetectPedestrianIntrusionRequest{};
  OpenApiUtil.convert(request, detectPedestrianIntrusionReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectPedestrianIntrusionReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var detectPedestrianIntrusionResp = detectPedestrianIntrusionWithOptions(detectPedestrianIntrusionReq, runtime);
  return detectPedestrianIntrusionResp;
}

model HandPostureRequest {
  imageURL?: string(name='ImageURL'),
}

model HandPostureAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model HandPostureResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    outputs?: [ 
      {
        handCount?: int32(name='HandCount'),
        results?: [ 
          {
            hands?: {
              keyPoints?: [ 
                {
                  positions?: [ 
                    {
                      points?: [ float ](name='Points'),
                    }
                  ](name='Positions'),
                  label?: string(name='Label'),
                }
              ](name='KeyPoints'),
              confident?: float(name='Confident'),
            }(name='Hands'),
            box?: {
              positions?: [ 
                {
                  points?: [ float ](name='Points'),
                }
              ](name='Positions'),
              confident?: float(name='Confident'),
            }(name='Box'),
          }
        ](name='Results'),
      }
    ](name='Outputs'),
    metaObject?: {
      width?: int32(name='Width'),
      height?: int32(name='Height'),
    }(name='MetaObject'),
  }(name='Data'),
}

model HandPostureResponse = {
  headers: map[string]string(name='headers'),
  body: HandPostureResponseBody(name='body'),
}

async function handPostureWithOptions(request: HandPostureRequest, runtime: Util.RuntimeOptions): HandPostureResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('HandPosture', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function handPosture(request: HandPostureRequest): HandPostureResponse {
  var runtime = new Util.RuntimeOptions{};
  return handPostureWithOptions(request, runtime);
}

async function handPostureAdvance(request: HandPostureAdvanceRequest, runtime: Util.RuntimeOptions): HandPostureResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var handPostureReq = new HandPostureRequest{};
  OpenApiUtil.convert(request, handPostureReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    handPostureReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var handPostureResp = handPostureWithOptions(handPostureReq, runtime);
  return handPostureResp;
}

model EnhanceFaceRequest {
  imageURL?: string(name='ImageURL'),
}

model EnhanceFaceAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model EnhanceFaceResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
}

model EnhanceFaceResponse = {
  headers: map[string]string(name='headers'),
  body: EnhanceFaceResponseBody(name='body'),
}

async function enhanceFaceWithOptions(request: EnhanceFaceRequest, runtime: Util.RuntimeOptions): EnhanceFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('EnhanceFace', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function enhanceFace(request: EnhanceFaceRequest): EnhanceFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return enhanceFaceWithOptions(request, runtime);
}

async function enhanceFaceAdvance(request: EnhanceFaceAdvanceRequest, runtime: Util.RuntimeOptions): EnhanceFaceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var enhanceFaceReq = new EnhanceFaceRequest{};
  OpenApiUtil.convert(request, enhanceFaceReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    enhanceFaceReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var enhanceFaceResp = enhanceFaceWithOptions(enhanceFaceReq, runtime);
  return enhanceFaceResp;
}

model GetBodyPersonRequest {
  dbId?: long(name='DbId', description='数据库ID'),
  personId?: long(name='PersonId', description='人员ID'),
}

model GetBodyPersonResponseBody = {
  requestId?: string(name='RequestId', description='RequestId'),
  data?: {
    dbId?: long(name='DbId', description='数据库ID'),
    id?: long(name='Id', description='人员ID'),
    name?: string(name='Name', description='人员名称'),
    traceCount?: long(name='TraceCount', description='Trace数量'),
    traceList?: [ 
      {
        id?: long(name='Id', description='TraceId'),
        extraData?: string(name='ExtraData', description='自定义Trace信息'),
      }
    ](name='TraceList', description='Trace列表'),
  }(name='Data'),
}

model GetBodyPersonResponse = {
  headers: map[string]string(name='headers'),
  body: GetBodyPersonResponseBody(name='body'),
}

async function getBodyPersonWithOptions(request: GetBodyPersonRequest, runtime: Util.RuntimeOptions): GetBodyPersonResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('GetBodyPerson', '2019-12-30', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function getBodyPerson(request: GetBodyPersonRequest): GetBodyPersonResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBodyPersonWithOptions(request, runtime);
}

model RecognizeHandGestureRequest {
  appId?: string(name='AppId', description='A short description of struct'),
  imageURL?: string(name='ImageURL'),
  gestureType?: string(name='GestureType'),
}

model RecognizeHandGestureAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  appId?: string(name='AppId', description='A short description of struct'),
  gestureType?: string(name='GestureType'),
}

model RecognizeHandGestureResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  data?: {
    type?: string(name='Type'),
    x?: long(name='X'),
    y?: long(name='Y'),
    width?: long(name='Width'),
    height?: long(name='Height'),
    score?: float(name='Score'),
  }(name='Data'),
}

model RecognizeHandGestureResponse = {
  headers: map[string]string(name='headers'),
  body: RecognizeHandGestureResponseBody(name='body'),
}

async function recognizeHandGestureWithOptions(request: RecognizeHandGestureRequest, runtime: Util.RuntimeOptions): RecognizeHandGestureResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RecognizeHandGesture', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function recognizeHandGesture(request: RecognizeHandGestureRequest): RecognizeHandGestureResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizeHandGestureWithOptions(request, runtime);
}

async function recognizeHandGestureAdvance(request: RecognizeHandGestureAdvanceRequest, runtime: Util.RuntimeOptions): RecognizeHandGestureResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var recognizeHandGestureReq = new RecognizeHandGestureRequest{};
  OpenApiUtil.convert(request, recognizeHandGestureReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    recognizeHandGestureReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var recognizeHandGestureResp = recognizeHandGestureWithOptions(recognizeHandGestureReq, runtime);
  return recognizeHandGestureResp;
}

model DeleteFaceDbRequest {
  name?: string(name='Name'),
}

model DeleteFaceDbResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFaceDbResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFaceDbResponseBody(name='body'),
}

async function deleteFaceDbWithOptions(request: DeleteFaceDbRequest, runtime: Util.RuntimeOptions): DeleteFaceDbResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteFaceDb', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteFaceDb(request: DeleteFaceDbRequest): DeleteFaceDbResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFaceDbWithOptions(request, runtime);
}

model ListBodyPersonRequest {
  dbId?: long(name='DbId', description='数据库ID'),
  offset?: long(name='Offset', description='起始位置(不含)'),
  limit?: long(name='Limit', description='分页数量'),
}

model ListBodyPersonResponseBody = {
  requestId?: string(name='RequestId', description='RequestId'),
  data?: {
    total?: long(name='Total', description='数据总量'),
    personList?: [ 
      {
        dbId?: long(name='DbId', description='数据库ID'),
        name?: string(name='Name', description='人员名称'),
        traceCount?: long(name='TraceCount', description='Trace数量'),
        id?: long(name='Id', description='人员ID'),
      }
    ](name='PersonList'),
  }(name='Data'),
}

model ListBodyPersonResponse = {
  headers: map[string]string(name='headers'),
  body: ListBodyPersonResponseBody(name='body'),
}

async function listBodyPersonWithOptions(request: ListBodyPersonRequest, runtime: Util.RuntimeOptions): ListBodyPersonResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListBodyPerson', '2019-12-30', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listBodyPerson(request: ListBodyPersonRequest): ListBodyPersonResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBodyPersonWithOptions(request, runtime);
}

model ListBodyDbsRequest {
  offset?: long(name='Offset', description='起始位置(不含)'),
  limit?: long(name='Limit', description='分页数量'),
}

model ListBodyDbsResponseBody = {
  requestId?: string(name='RequestId', description='RequestId'),
  data?: {
    total?: long(name='Total', description='数据库ID'),
    dbList?: [ 
      {
        id?: long(name='Id', description='数据库ID'),
        name?: string(name='Name', description='数据库名称'),
      }
    ](name='DbList'),
  }(name='Data'),
}

model ListBodyDbsResponse = {
  headers: map[string]string(name='headers'),
  body: ListBodyDbsResponseBody(name='body'),
}

async function listBodyDbsWithOptions(request: ListBodyDbsRequest, runtime: Util.RuntimeOptions): ListBodyDbsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListBodyDbs', '2019-12-30', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listBodyDbs(request: ListBodyDbsRequest): ListBodyDbsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBodyDbsWithOptions(request, runtime);
}

model ListFaceEntitiesRequest {
  dbName?: string(name='DbName'),
  offset?: int32(name='Offset'),
  limit?: int32(name='Limit'),
  token?: string(name='Token'),
  labels?: string(name='Labels'),
  entityIdPrefix?: string(name='EntityIdPrefix'),
  order?: string(name='Order'),
}

model ListFaceEntitiesResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    token?: string(name='Token'),
    totalCount?: int32(name='TotalCount'),
    entities?: [ 
      {
        dbName?: string(name='DbName'),
        entityId?: string(name='EntityId'),
        labels?: string(name='Labels'),
        createdAt?: long(name='CreatedAt'),
        faceCount?: int32(name='FaceCount'),
        updatedAt?: long(name='UpdatedAt'),
      }
    ](name='Entities'),
  }(name='Data'),
}

model ListFaceEntitiesResponse = {
  headers: map[string]string(name='headers'),
  body: ListFaceEntitiesResponseBody(name='body'),
}

async function listFaceEntitiesWithOptions(request: ListFaceEntitiesRequest, runtime: Util.RuntimeOptions): ListFaceEntitiesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListFaceEntities', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFaceEntities(request: ListFaceEntitiesRequest): ListFaceEntitiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFaceEntitiesWithOptions(request, runtime);
}

model RecognizePublicFaceRequest {
  task?: [ 
    {
      imageURL?: string(name='ImageURL'),
      imageData?: bytes(name='ImageData'),
    }
  ](name='Task'),
}

model RecognizePublicFaceResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    elements?: [ 
      {
        imageURL?: string(name='ImageURL'),
        taskId?: string(name='TaskId'),
        results?: [ 
          {
            suggestion?: string(name='Suggestion'),
            label?: string(name='Label'),
            subResults?: [ 
              {
                w?: float(name='W'),
                faces?: [ 
                  {
                    name?: string(name='Name'),
                    id?: string(name='Id'),
                    rate?: float(name='Rate'),
                  }
                ](name='Faces'),
                h?: float(name='H'),
                y?: float(name='Y'),
                x?: float(name='X'),
              }
            ](name='SubResults'),
            rate?: float(name='Rate'),
          }
        ](name='Results'),
      }
    ](name='Elements'),
  }(name='Data'),
}

model RecognizePublicFaceResponse = {
  headers: map[string]string(name='headers'),
  body: RecognizePublicFaceResponseBody(name='body'),
}

async function recognizePublicFaceWithOptions(request: RecognizePublicFaceRequest, runtime: Util.RuntimeOptions): RecognizePublicFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RecognizePublicFace', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function recognizePublicFace(request: RecognizePublicFaceRequest): RecognizePublicFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizePublicFaceWithOptions(request, runtime);
}

model DeleteFaceImageTemplateRequest {
  userId?: string(name='UserId', description='A short description of struct'),
  templateId?: string(name='TemplateId'),
}

model DeleteFaceImageTemplateResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteFaceImageTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFaceImageTemplateResponseBody(name='body'),
}

async function deleteFaceImageTemplateWithOptions(request: DeleteFaceImageTemplateRequest, runtime: Util.RuntimeOptions): DeleteFaceImageTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteFaceImageTemplate', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteFaceImageTemplate(request: DeleteFaceImageTemplateRequest): DeleteFaceImageTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFaceImageTemplateWithOptions(request, runtime);
}

model CreateFaceDbRequest {
  name?: string(name='Name'),
}

model CreateFaceDbResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateFaceDbResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFaceDbResponseBody(name='body'),
}

async function createFaceDbWithOptions(request: CreateFaceDbRequest, runtime: Util.RuntimeOptions): CreateFaceDbResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateFaceDb', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createFaceDb(request: CreateFaceDbRequest): CreateFaceDbResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFaceDbWithOptions(request, runtime);
}

model AddBodyTraceRequest {
  dbId?: long(name='DbId', description='数据库ID'),
  personId?: long(name='PersonId', description='实体ID，可以包含数字、字母和下划线，相同db下不可以重复，长度1-64。'),
  images?: [ 
    {
      imageURL?: string(name='ImageURL', description='Trace图片URL'),
      imageData?: bytes(name='ImageData'),
    }
  ](name='Images', description='Trace图片信息列表'),
  extraData?: string(name='ExtraData', description='自定义信息。支持字母、数字、标点符号和汉字。不超过4096个字符。'),
}

model AddBodyTraceShrinkRequest {
  dbId?: long(name='DbId', description='数据库ID'),
  personId?: long(name='PersonId', description='实体ID，可以包含数字、字母和下划线，相同db下不可以重复，长度1-64。'),
  imagesShrink?: string(name='Images', description='Trace图片信息列表'),
  extraData?: string(name='ExtraData', description='自定义信息。支持字母、数字、标点符号和汉字。不超过4096个字符。'),
}

model AddBodyTraceResponseBody = {
  requestId?: string(name='RequestId', description='RequestId'),
  data?: {
    id?: long(name='Id', description='TraceID'),
  }(name='Data'),
}

model AddBodyTraceResponse = {
  headers: map[string]string(name='headers'),
  body: AddBodyTraceResponseBody(name='body'),
}

async function addBodyTraceWithOptions(tmpReq: AddBodyTraceRequest, runtime: Util.RuntimeOptions): AddBodyTraceResponse {
  Util.validateModel(tmpReq);
  var request = new AddBodyTraceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.images)) {
    request.imagesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.images, 'Images', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddBodyTrace', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addBodyTrace(request: AddBodyTraceRequest): AddBodyTraceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addBodyTraceWithOptions(request, runtime);
}

model SearchBodyTraceRequest {
  dbId?: long(name='DbId', description='数据库ID'),
  images?: [ 
    {
      imageURL?: string(name='ImageURL', description='Trace图片URL'),
      imageData?: bytes(name='ImageData', description='图片Base64数据'),
    }
  ](name='Images', description='Trace图片信息列表'),
  limit?: long(name='Limit', description='结果Trace数量上限，默认10，取值范围[1, 100]'),
  minScore?: float(name='MinScore', description='score阈值，只返回大于等于该score的数据，取值范围[-1.0, 1.0]，默认为空'),
}

model SearchBodyTraceShrinkRequest {
  dbId?: long(name='DbId', description='数据库ID'),
  imagesShrink?: string(name='Images', description='Trace图片信息列表'),
  limit?: long(name='Limit', description='结果Trace数量上限，默认10，取值范围[1, 100]'),
  minScore?: float(name='MinScore', description='score阈值，只返回大于等于该score的数据，取值范围[-1.0, 1.0]，默认为空'),
}

model SearchBodyTraceResponseBody = {
  requestId?: string(name='RequestId', description='RequestId'),
  data?: {
    matchList?: [ 
      {
        dbId?: long(name='DbId', description='数据库ID'),
        personId?: long(name='PersonId', description='人员ID'),
        traceId?: long(name='TraceId', description='TraceId'),
        score?: float(name='Score', description='匹配度分值，越大越相似，取值范围[-1.0, 1.0]'),
        extraData?: string(name='ExtraData', description='自定义数据信息'),
      }
    ](name='MatchList', description='匹配的Trace列表'),
  }(name='Data'),
}

model SearchBodyTraceResponse = {
  headers: map[string]string(name='headers'),
  body: SearchBodyTraceResponseBody(name='body'),
}

async function searchBodyTraceWithOptions(tmpReq: SearchBodyTraceRequest, runtime: Util.RuntimeOptions): SearchBodyTraceResponse {
  Util.validateModel(tmpReq);
  var request = new SearchBodyTraceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.images)) {
    request.imagesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.images, 'Images', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SearchBodyTrace', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function searchBodyTrace(request: SearchBodyTraceRequest): SearchBodyTraceResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchBodyTraceWithOptions(request, runtime);
}

model AddFaceImageTemplateRequest {
  userId?: string(name='UserId', description='A short description of struct'),
  imageURL?: string(name='ImageURL'),
}

model AddFaceImageTemplateAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  userId?: string(name='UserId', description='A short description of struct'),
}

model AddFaceImageTemplateResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  data?: {
    templateId?: string(name='TemplateId'),
  }(name='Data'),
}

model AddFaceImageTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: AddFaceImageTemplateResponseBody(name='body'),
}

async function addFaceImageTemplateWithOptions(request: AddFaceImageTemplateRequest, runtime: Util.RuntimeOptions): AddFaceImageTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddFaceImageTemplate', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addFaceImageTemplate(request: AddFaceImageTemplateRequest): AddFaceImageTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addFaceImageTemplateWithOptions(request, runtime);
}

async function addFaceImageTemplateAdvance(request: AddFaceImageTemplateAdvanceRequest, runtime: Util.RuntimeOptions): AddFaceImageTemplateResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var addFaceImageTemplateReq = new AddFaceImageTemplateRequest{};
  OpenApiUtil.convert(request, addFaceImageTemplateReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    addFaceImageTemplateReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var addFaceImageTemplateResp = addFaceImageTemplateWithOptions(addFaceImageTemplateReq, runtime);
  return addFaceImageTemplateResp;
}

model CountCrowdRequest {
  imageURL?: string(name='ImageURL'),
  isShow?: boolean(name='IsShow'),
}

model CountCrowdAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  isShow?: boolean(name='IsShow'),
}

model CountCrowdResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    peopleNumber?: int32(name='PeopleNumber'),
    hotMap?: string(name='HotMap'),
  }(name='Data'),
}

model CountCrowdResponse = {
  headers: map[string]string(name='headers'),
  body: CountCrowdResponseBody(name='body'),
}

async function countCrowdWithOptions(request: CountCrowdRequest, runtime: Util.RuntimeOptions): CountCrowdResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CountCrowd', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function countCrowd(request: CountCrowdRequest): CountCrowdResponse {
  var runtime = new Util.RuntimeOptions{};
  return countCrowdWithOptions(request, runtime);
}

async function countCrowdAdvance(request: CountCrowdAdvanceRequest, runtime: Util.RuntimeOptions): CountCrowdResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var countCrowdReq = new CountCrowdRequest{};
  OpenApiUtil.convert(request, countCrowdReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    countCrowdReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var countCrowdResp = countCrowdWithOptions(countCrowdReq, runtime);
  return countCrowdResp;
}

model AddFaceEntityRequest {
  dbName?: string(name='DbName'),
  entityId?: string(name='EntityId'),
  labels?: string(name='Labels'),
}

model AddFaceEntityResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddFaceEntityResponse = {
  headers: map[string]string(name='headers'),
  body: AddFaceEntityResponseBody(name='body'),
}

async function addFaceEntityWithOptions(request: AddFaceEntityRequest, runtime: Util.RuntimeOptions): AddFaceEntityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddFaceEntity', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addFaceEntity(request: AddFaceEntityRequest): AddFaceEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return addFaceEntityWithOptions(request, runtime);
}

model DeleteFaceEntityRequest {
  dbName?: string(name='DbName'),
  entityId?: string(name='EntityId'),
}

model DeleteFaceEntityResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFaceEntityResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFaceEntityResponseBody(name='body'),
}

async function deleteFaceEntityWithOptions(request: DeleteFaceEntityRequest, runtime: Util.RuntimeOptions): DeleteFaceEntityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteFaceEntity', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteFaceEntity(request: DeleteFaceEntityRequest): DeleteFaceEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFaceEntityWithOptions(request, runtime);
}

model FaceTidyupRequest {
  imageURL?: string(name='ImageURL'),
  shapeType?: int32(name='ShapeType'),
  strength?: float(name='Strength'),
}

model FaceTidyupAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  shapeType?: int32(name='ShapeType'),
  strength?: float(name='Strength'),
}

model FaceTidyupResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    imageURL?: string(name='ImageURL'),
  }(name='Data'),
}

model FaceTidyupResponse = {
  headers: map[string]string(name='headers'),
  body: FaceTidyupResponseBody(name='body'),
}

async function faceTidyupWithOptions(request: FaceTidyupRequest, runtime: Util.RuntimeOptions): FaceTidyupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('FaceTidyup', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function faceTidyup(request: FaceTidyupRequest): FaceTidyupResponse {
  var runtime = new Util.RuntimeOptions{};
  return faceTidyupWithOptions(request, runtime);
}

async function faceTidyupAdvance(request: FaceTidyupAdvanceRequest, runtime: Util.RuntimeOptions): FaceTidyupResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var faceTidyupReq = new FaceTidyupRequest{};
  OpenApiUtil.convert(request, faceTidyupReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    faceTidyupReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var faceTidyupResp = faceTidyupWithOptions(faceTidyupReq, runtime);
  return faceTidyupResp;
}

model BodyPostureRequest {
  imageURL?: string(name='ImageURL'),
}

model BodyPostureAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model BodyPostureResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    outputs?: [ 
      {
        humanCount?: int32(name='HumanCount'),
        results?: [ 
          {
            bodies?: [ 
              {
                positions?: [ 
                  {
                    points?: [ float ](name='Points'),
                  }
                ](name='Positions'),
                confident?: float(name='Confident'),
                label?: string(name='Label'),
              }
            ](name='Bodies'),
          }
        ](name='Results'),
      }
    ](name='Outputs'),
    metaObject?: {
      width?: int32(name='Width'),
      height?: int32(name='Height'),
    }(name='MetaObject'),
  }(name='Data'),
}

model BodyPostureResponse = {
  headers: map[string]string(name='headers'),
  body: BodyPostureResponseBody(name='body'),
}

async function bodyPostureWithOptions(request: BodyPostureRequest, runtime: Util.RuntimeOptions): BodyPostureResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('BodyPosture', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function bodyPosture(request: BodyPostureRequest): BodyPostureResponse {
  var runtime = new Util.RuntimeOptions{};
  return bodyPostureWithOptions(request, runtime);
}

async function bodyPostureAdvance(request: BodyPostureAdvanceRequest, runtime: Util.RuntimeOptions): BodyPostureResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var bodyPostureReq = new BodyPostureRequest{};
  OpenApiUtil.convert(request, bodyPostureReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    bodyPostureReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var bodyPostureResp = bodyPostureWithOptions(bodyPostureReq, runtime);
  return bodyPostureResp;
}

model MonitorExaminationRequest {
  type?: long(name='Type', description='A short description of struct'),
  imageURL?: string(name='ImageURL'),
}

model MonitorExaminationAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
  type?: long(name='Type', description='A short description of struct'),
}

model MonitorExaminationResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  data?: {
    faceInfo?: {
      completeness?: long(name='Completeness'),
      faceNumber?: long(name='FaceNumber'),
      pose?: {
        pitch?: float(name='Pitch'),
        roll?: float(name='Roll'),
        yaw?: float(name='Yaw'),
      }(name='Pose'),
    }(name='FaceInfo'),
    personInfo?: {
      cellPhone?: {
        score?: float(name='Score'),
        threshold?: float(name='Threshold'),
      }(name='CellPhone'),
      earPhone?: {
        score?: float(name='Score'),
        threshold?: float(name='Threshold'),
      }(name='EarPhone'),
      personNumber?: long(name='PersonNumber'),
    }(name='PersonInfo'),
    chatScore?: float(name='ChatScore'),
    threshold?: float(name='Threshold'),
  }(name='Data'),
}

model MonitorExaminationResponse = {
  headers: map[string]string(name='headers'),
  body: MonitorExaminationResponseBody(name='body'),
}

async function monitorExaminationWithOptions(request: MonitorExaminationRequest, runtime: Util.RuntimeOptions): MonitorExaminationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('MonitorExamination', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function monitorExamination(request: MonitorExaminationRequest): MonitorExaminationResponse {
  var runtime = new Util.RuntimeOptions{};
  return monitorExaminationWithOptions(request, runtime);
}

async function monitorExaminationAdvance(request: MonitorExaminationAdvanceRequest, runtime: Util.RuntimeOptions): MonitorExaminationResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'facebody',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var monitorExaminationReq = new MonitorExaminationRequest{};
  OpenApiUtil.convert(request, monitorExaminationReq);

  if(!Util.isUnset(request.imageURLObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    monitorExaminationReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var monitorExaminationResp = monitorExaminationWithOptions(monitorExaminationReq, runtime);
  return monitorExaminationResp;
}

model CreateBodyDbRequest {
  name?: string(name='Name', description='数据库名称'),
}

model CreateBodyDbResponseBody = {
  requestId?: string(name='RequestId', description='RequestId'),
  data?: {
    id?: long(name='Id', description='数据库ID'),
  }(name='Data'),
}

model CreateBodyDbResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBodyDbResponseBody(name='body'),
}

async function createBodyDbWithOptions(request: CreateBodyDbRequest, runtime: Util.RuntimeOptions): CreateBodyDbResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateBodyDb', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createBodyDb(request: CreateBodyDbRequest): CreateBodyDbResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBodyDbWithOptions(request, runtime);
}

