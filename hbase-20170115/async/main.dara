/**
  *
  */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'HBase';
  @version = '2017-01-15';
  @endpointRule = 'regional';
  @endpointMap = {
    'ap-northeast-2-pop' = 'hbase.aliyuncs.com',
    'ap-south-1' = 'hbase.aliyuncs.com',
    'ap-southeast-2' = 'hbase.aliyuncs.com',
    'cn-beijing-finance-1' = 'hbase.aliyuncs.com',
    'cn-beijing-finance-pop' = 'hbase.aliyuncs.com',
    'cn-beijing-gov-1' = 'hbase.aliyuncs.com',
    'cn-beijing-nu16-b01' = 'hbase.aliyuncs.com',
    'cn-edge-1' = 'hbase.aliyuncs.com',
    'cn-fujian' = 'hbase.aliyuncs.com',
    'cn-haidian-cm12-c01' = 'hbase.aliyuncs.com',
    'cn-hangzhou-bj-b01' = 'hbase.aliyuncs.com',
    'cn-hangzhou-internal-prod-1' = 'hbase.aliyuncs.com',
    'cn-hangzhou-internal-test-1' = 'hbase.aliyuncs.com',
    'cn-hangzhou-internal-test-2' = 'hbase.aliyuncs.com',
    'cn-hangzhou-internal-test-3' = 'hbase.aliyuncs.com',
    'cn-hangzhou-test-306' = 'hbase.aliyuncs.com',
    'cn-hongkong-finance-pop' = 'hbase.aliyuncs.com',
    'cn-qingdao-nebula' = 'hbase.aliyuncs.com',
    'cn-shanghai-et15-b01' = 'hbase.aliyuncs.com',
    'cn-shanghai-et2-b01' = 'hbase.aliyuncs.com',
    'cn-shanghai-inner' = 'hbase.aliyuncs.com',
    'cn-shanghai-internal-test-1' = 'hbase.aliyuncs.com',
    'cn-shenzhen-inner' = 'hbase.aliyuncs.com',
    'cn-shenzhen-st4-d01' = 'hbase.aliyuncs.com',
    'cn-shenzhen-su18-b01' = 'hbase.aliyuncs.com',
    'cn-wuhan' = 'hbase.aliyuncs.com',
    'cn-wulanchabu' = 'hbase.aliyuncs.com',
    'cn-yushanfang' = 'hbase.aliyuncs.com',
    'cn-zhangbei' = 'hbase.aliyuncs.com',
    'cn-zhangbei-na61-b01' = 'hbase.aliyuncs.com',
    'cn-zhangjiakou-na62-a01' = 'hbase.aliyuncs.com',
    'cn-zhengzhou-nebula-1' = 'hbase.aliyuncs.com',
    'eu-west-1-oxs' = 'hbase.aliyuncs.com',
    'rus-west-1-pop' = 'hbase.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model AddUserHdfsInfoRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  extInfo: string(name='ExtInfo', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model AddUserHdfsInfoResponseBody = {
  clusterId?: string(name='ClusterId'),
  requestId?: string(name='RequestId'),
}

model AddUserHdfsInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddUserHdfsInfoResponseBody(name='body'),
}

/**
  * @param request  the request parameters of AddUserHdfsInfo  AddUserHdfsInfoRequest
  * @return AddUserHdfsInfoResponse
 */
async function addUserHdfsInfo(request: AddUserHdfsInfoRequest): AddUserHdfsInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddUserHdfsInfo', 'POST', '/', 'json', false, 'json', request);
}

model AllocatePublicNetworkAddressRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AllocatePublicNetworkAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model AllocatePublicNetworkAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AllocatePublicNetworkAddressResponseBody(name='body'),
}

/**
  * @param request  the request parameters of AllocatePublicNetworkAddress  AllocatePublicNetworkAddressRequest
  * @return AllocatePublicNetworkAddressResponse
 */
async function allocatePublicNetworkAddress(request: AllocatePublicNetworkAddressRequest): AllocatePublicNetworkAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AllocatePublicNetworkAddress', 'POST', '/', 'json', false, 'json', request);
}

model CheckVersionsOfComponentsRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  components: string(name='Components', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model CheckVersionsOfComponentsResponseBody = {
  components?: {
    components?: [ 
    {
      component?: string(name='Component'),
      isLatestVersion?: string(name='IsLatestVersion'),
    }
  ](name='Components')
  }(name='Components'),
  requestId?: string(name='RequestId'),
}

model CheckVersionsOfComponentsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckVersionsOfComponentsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CheckVersionsOfComponents  CheckVersionsOfComponentsRequest
  * @return CheckVersionsOfComponentsResponse
 */
async function checkVersionsOfComponents(request: CheckVersionsOfComponentsRequest): CheckVersionsOfComponentsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckVersionsOfComponents', 'POST', '/', 'json', false, 'json', request);
}

model CloseBackupRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model CloseBackupResponseBody = {
  requestId?: string(name='RequestId'),
}

model CloseBackupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CloseBackupResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CloseBackup  CloseBackupRequest
  * @return CloseBackupResponse
 */
async function closeBackup(request: CloseBackupRequest): CloseBackupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CloseBackup', 'POST', '/', 'json', false, 'json', request);
}

model ConvertClusterRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  duration: int32(name='Duration', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pricingCycle: string(name='PricingCycle', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ConvertClusterResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ConvertClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConvertClusterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ConvertCluster  ConvertClusterRequest
  * @return ConvertClusterResponse
 */
async function convertCluster(request: ConvertClusterRequest): ConvertClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConvertCluster', 'POST', '/', 'json', false, 'json', request);
}

model CreateClusterRequest {
  autoRenew?: string(name='AutoRenew', position='Query'),
  backupId?: string(name='BackupId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  cloudType: string(name='CloudType', description='This parameter is required.', position='Query'),
  clusterName: string(name='ClusterName', description='This parameter is required.', position='Query'),
  coldStorageSize?: string(name='ColdStorageSize', position='Query'),
  coreDiskQuantity: string(name='CoreDiskQuantity', description='This parameter is required.', position='Query'),
  coreDiskSize: string(name='CoreDiskSize', description='This parameter is required.', position='Query'),
  coreDiskType: string(name='CoreDiskType', description='This parameter is required.', position='Query'),
  coreInstanceQuantity: string(name='CoreInstanceQuantity', description='This parameter is required.', position='Query'),
  coreInstanceType: string(name='CoreInstanceType', description='This parameter is required.', position='Query'),
  dbInstanceConnType?: string(name='DbInstanceConnType', position='Query'),
  dbInstanceType?: string(name='DbInstanceType', position='Query'),
  dbType?: string(name='DbType', position='Query'),
  depMode?: string(name='DepMode', position='Query'),
  duration?: string(name='Duration', position='Query'),
  engine: string(name='Engine', description='This parameter is required.', position='Query'),
  engineVersion: string(name='EngineVersion', description='This parameter is required.', position='Query'),
  isColdStorage?: string(name='IsColdStorage', position='Query'),
  masterInstanceType: string(name='MasterInstanceType', description='This parameter is required.', position='Query'),
  netType: string(name='NetType', description='This parameter is required.', position='Query'),
  payType?: string(name='PayType', position='Query'),
  pricingCycle?: string(name='PricingCycle', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  restoreTime?: string(name='RestoreTime', position='Query'),
  securityIPList: string(name='SecurityIPList', description='This parameter is required.', position='Query'),
  srcDBInstanceId?: string(name='SrcDBInstanceId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  zoneId: string(name='ZoneId', description='This parameter is required.', position='Query'),
}

model CreateClusterResponseBody = {
  clusterId?: string(name='ClusterId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateClusterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateCluster  CreateClusterRequest
  * @return CreateClusterResponse
 */
async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCluster', 'POST', '/', 'json', false, 'json', request);
}

model CreateGlobalResourceRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceName: string(name='ResourceName', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', description='This parameter is required.', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model CreateGlobalResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateGlobalResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateGlobalResourceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateGlobalResource  CreateGlobalResourceRequest
  * @return CreateGlobalResourceResponse
 */
async function createGlobalResource(request: CreateGlobalResourceRequest): CreateGlobalResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateGlobalResource', 'POST', '/', 'json', false, 'json', request);
}

model CreateHbaseSlbServerRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  slbServer: string(name='SlbServer', description='This parameter is required.', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model CreateHbaseSlbServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateHbaseSlbServerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateHbaseSlbServerResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateHbaseSlbServer  CreateHbaseSlbServerRequest
  * @return CreateHbaseSlbServerResponse
 */
async function createHbaseSlbServer(request: CreateHbaseSlbServerRequest): CreateHbaseSlbServerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateHbaseSlbServer', 'POST', '/', 'json', false, 'json', request);
}

model CreateSubscriptionRequest {
  destinationInstanceId: string(name='DestinationInstanceId', description='This parameter is required.', position='Query'),
  destinationInstanceRegionId: string(name='DestinationInstanceRegionId', description='This parameter is required.', position='Query'),
  extraContext?: string(name='ExtraContext', position='Query'),
  mapping: string(name='Mapping', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  slbServer?: string(name='SlbServer', position='Query'),
  sourceInstanceId: string(name='SourceInstanceId', description='This parameter is required.', position='Query'),
  sourceInstanceRegionId: string(name='SourceInstanceRegionId', description='This parameter is required.', position='Query'),
  subscriptionDescription?: string(name='SubscriptionDescription', position='Query'),
  subscriptionType: string(name='SubscriptionType', description='This parameter is required.', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model CreateSubscriptionResponseBody = {
  requestId?: string(name='RequestId'),
  subscriptionId?: string(name='SubscriptionId'),
}

model CreateSubscriptionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSubscriptionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateSubscription  CreateSubscriptionRequest
  * @return CreateSubscriptionResponse
 */
async function createSubscription(request: CreateSubscriptionRequest): CreateSubscriptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSubscription', 'POST', '/', 'json', false, 'json', request);
}

model DeleteClusterRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DeleteClusterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteClusterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteCluster  DeleteClusterRequest
  * @return DeleteClusterResponse
 */
async function deleteCluster(request: DeleteClusterRequest): DeleteClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCluster', 'POST', '/', 'json', false, 'json', request);
}

model DeleteGlobalResourceRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceName: string(name='ResourceName', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', description='This parameter is required.', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DeleteGlobalResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGlobalResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteGlobalResourceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteGlobalResource  DeleteGlobalResourceRequest
  * @return DeleteGlobalResourceResponse
 */
async function deleteGlobalResource(request: DeleteGlobalResourceRequest): DeleteGlobalResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGlobalResource', 'POST', '/', 'json', false, 'json', request);
}

model DeleteHbaseSlbServerRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  slbServer: string(name='SlbServer', description='This parameter is required.', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DeleteHbaseSlbServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteHbaseSlbServerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteHbaseSlbServerResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteHbaseSlbServer  DeleteHbaseSlbServerRequest
  * @return DeleteHbaseSlbServerResponse
 */
async function deleteHbaseSlbServer(request: DeleteHbaseSlbServerRequest): DeleteHbaseSlbServerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteHbaseSlbServer', 'POST', '/', 'json', false, 'json', request);
}

model DeleteServerlessInstanceRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId: string(name='ZoneId', description='This parameter is required.', position='Query'),
}

model DeleteServerlessInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteServerlessInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteServerlessInstanceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteServerlessInstance  DeleteServerlessInstanceRequest
  * @return DeleteServerlessInstanceResponse
 */
async function deleteServerlessInstance(request: DeleteServerlessInstanceRequest): DeleteServerlessInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteServerlessInstance', 'POST', '/', 'json', false, 'json', request);
}

model DeleteUserHdfsInfoRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  nameService: string(name='NameService', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DeleteUserHdfsInfoResponseBody = {
  clusterId?: string(name='ClusterId'),
  requestId?: string(name='RequestId'),
}

model DeleteUserHdfsInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteUserHdfsInfoResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteUserHdfsInfo  DeleteUserHdfsInfoRequest
  * @return DeleteUserHdfsInfoResponse
 */
async function deleteUserHdfsInfo(request: DeleteUserHdfsInfoRequest): DeleteUserHdfsInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteUserHdfsInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBackupPolicyRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeBackupPolicyResponseBody = {
  backupRetentionPeriod?: string(name='BackupRetentionPeriod'),
  preferredBackupEndTimeUTC?: string(name='PreferredBackupEndTimeUTC'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod'),
  preferredBackupStartTimeUTC?: string(name='PreferredBackupStartTimeUTC'),
  preferredBackupTime?: string(name='PreferredBackupTime'),
  requestId?: string(name='RequestId'),
}

model DescribeBackupPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBackupPolicyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeBackupPolicy  DescribeBackupPolicyRequest
  * @return DescribeBackupPolicyResponse
 */
async function describeBackupPolicy(request: DescribeBackupPolicyRequest): DescribeBackupPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBackupPolicy', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBackupsRequest {
  backupId?: int32(name='BackupId', position='Query'),
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  endTimeUTC?: string(name='EndTimeUTC', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  startTimeUTC?: string(name='StartTimeUTC', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeBackupsResponseBody = {
  backups?: {
    backup?: [ 
    {
      backupDBNames?: string(name='BackupDBNames'),
      backupDownloadURL?: string(name='BackupDownloadURL'),
      backupEndTime?: string(name='BackupEndTime'),
      backupEndTimeUTC?: string(name='BackupEndTimeUTC'),
      backupId?: int32(name='BackupId'),
      backupMethod?: string(name='BackupMethod'),
      backupMode?: string(name='BackupMode'),
      backupSize?: string(name='BackupSize'),
      backupStartTime?: string(name='BackupStartTime'),
      backupStartTimeUTC?: string(name='BackupStartTimeUTC'),
      backupStatus?: string(name='BackupStatus'),
      backupType?: string(name='BackupType'),
    }
  ](name='Backup')
  }(name='Backups'),
  enableStatus?: string(name='EnableStatus'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeBackupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBackupsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeBackups  DescribeBackupsRequest
  * @return DescribeBackupsResponse
 */
async function describeBackups(request: DescribeBackupsRequest): DescribeBackupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBackups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeClusterAttributeRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeClusterAttributeResponseBody = {
  autoRenew?: string(name='AutoRenew'),
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  clusterType?: string(name='ClusterType'),
  coldStorageStatus?: string(name='ColdStorageStatus'),
  connectionInfo?: {
    haRestConnectionString?: string(name='HaRestConnectionString'),
    haRestPort?: string(name='HaRestPort'),
    haThriftConnectionString?: string(name='HaThriftConnectionString'),
    haThriftPort?: string(name='HaThriftPort'),
    thriftConnectionString?: string(name='ThriftConnectionString'),
    thriftPort?: string(name='ThriftPort'),
    UIProxyConnectionString?: string(name='UIProxyConnectionString'),
    ZKClassicConnectionStringList?: {
      string?: [ string ](name='String')
    }(name='ZKClassicConnectionStringList'),
    ZKConnectionStringList?: {
      string?: [ string ](name='String')
    }(name='ZKConnectionStringList'),
    ZKInnerConnectionStringList?: {
      string?: [ string ](name='String')
    }(name='ZKInnerConnectionStringList'),
    ZKPort?: int32(name='ZKPort'),
    ZKPublicConnectionStringList?: {
      string?: [ string ](name='String')
    }(name='ZKPublicConnectionStringList'),
  }(name='ConnectionInfo'),
  coreDiskQuantity?: int32(name='CoreDiskQuantity'),
  coreDiskSize?: string(name='CoreDiskSize'),
  coreDiskType?: string(name='CoreDiskType'),
  coreInstanceQuantity?: int32(name='CoreInstanceQuantity'),
  coreInstanceType?: string(name='CoreInstanceType'),
  createTime?: string(name='CreateTime'),
  expireTime?: string(name='ExpireTime'),
  haType?: string(name='HaType'),
  hasUser?: string(name='HasUser'),
  lockMode?: string(name='LockMode'),
  mainVersion?: string(name='MainVersion'),
  masterDiskSize?: int32(name='MasterDiskSize'),
  masterDiskType?: string(name='MasterDiskType'),
  masterInstanceType?: string(name='MasterInstanceType'),
  minorVersion?: string(name='MinorVersion'),
  netInfo?: {
    innerIpAddress?: string(name='InnerIpAddress'),
    netType?: string(name='NetType'),
    publicIpAddress?: string(name='PublicIpAddress'),
    securityIpList?: string(name='SecurityIpList'),
    vSwitchId?: string(name='VSwitchId'),
    vpcId?: string(name='VpcId'),
  }(name='NetInfo'),
  nodeList?: {
    node?: [ 
    {
      daemonList?: {
        daemon?: [ 
        {
          daemonName?: string(name='DaemonName'),
          daemonStatus?: string(name='DaemonStatus'),
        }
      ](name='Daemon')
      }(name='DaemonList'),
      memStore?: string(name='MemStore'),
      nodeDiskQuantity?: string(name='NodeDiskQuantity'),
      nodeDiskSize?: string(name='NodeDiskSize'),
      nodeDiskType?: string(name='NodeDiskType'),
      nodeId?: string(name='NodeId'),
      nodeInstanceType?: string(name='NodeInstanceType'),
      nodeStatus?: string(name='NodeStatus'),
      nodeType?: string(name='NodeType'),
      regionQuantity?: string(name='RegionQuantity'),
      serviceType?: string(name='ServiceType'),
      storeFile?: string(name='StoreFile'),
    }
  ](name='Node')
  }(name='NodeList'),
  payType?: string(name='PayType'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  updateStatus?: string(name='UpdateStatus'),
  zoneId?: string(name='ZoneId'),
}

model DescribeClusterAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterAttributeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeClusterAttribute  DescribeClusterAttributeRequest
  * @return DescribeClusterAttributeResponse
 */
async function describeClusterAttribute(request: DescribeClusterAttributeRequest): DescribeClusterAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClusterAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeClusterConnectAddrsRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeClusterConnectAddrsResponseBody = {
  dbType?: string(name='DbType'),
  isMultimod?: string(name='IsMultimod'),
  netType?: string(name='NetType'),
  requestId?: string(name='RequestId'),
  serviceConnAddrs?: {
    serviceConnAddr?: [ 
    {
      connAddrInfo?: {
        connAddr?: string(name='ConnAddr'),
        connAddrPort?: string(name='ConnAddrPort'),
        netType?: string(name='NetType'),
      }(name='ConnAddrInfo'),
      connType?: string(name='ConnType'),
    }
  ](name='ServiceConnAddr')
  }(name='ServiceConnAddrs'),
  slbConnAddrs?: {
    slbConnAddr?: [ 
    {
      connAddrInfo?: {
        connAddr?: string(name='ConnAddr'),
        connAddrPort?: string(name='ConnAddrPort'),
        netType?: string(name='NetType'),
      }(name='ConnAddrInfo'),
      slbType?: string(name='SlbType'),
    }
  ](name='SlbConnAddr')
  }(name='SlbConnAddrs'),
  thriftConn?: {
    connAddr?: string(name='ConnAddr'),
    connAddrPort?: string(name='ConnAddrPort'),
    netType?: string(name='NetType'),
  }(name='ThriftConn'),
  uiProxyConnAddrInfo?: {
    connAddr?: string(name='ConnAddr'),
    connAddrPort?: string(name='ConnAddrPort'),
    netType?: string(name='NetType'),
  }(name='UiProxyConnAddrInfo'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  zkConnAddrs?: {
    zkConnAddr?: [ 
    {
      connAddr?: string(name='ConnAddr'),
      connAddrPort?: string(name='ConnAddrPort'),
      netType?: string(name='NetType'),
    }
  ](name='ZkConnAddr')
  }(name='ZkConnAddrs'),
}

model DescribeClusterConnectAddrsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterConnectAddrsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeClusterConnectAddrs  DescribeClusterConnectAddrsRequest
  * @return DescribeClusterConnectAddrsResponse
 */
async function describeClusterConnectAddrs(request: DescribeClusterConnectAddrsRequest): DescribeClusterConnectAddrsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClusterConnectAddrs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeClusterListRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  clusterName?: string(name='ClusterName', position='Query'),
  dbType?: string(name='DbType', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  statusList?: [ string ](name='StatusList', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeClusterListResponseBody = {
  clusterList?: {
    cluster?: [ 
    {
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      clusterType?: string(name='ClusterType'),
      coreDiskSize?: string(name='CoreDiskSize'),
      coreDiskType?: string(name='CoreDiskType'),
      coreInstanceQuantity?: int32(name='CoreInstanceQuantity'),
      createTime?: string(name='CreateTime'),
      dbType?: string(name='DbType'),
      expireTime?: string(name='ExpireTime'),
      lockMode?: string(name='LockMode'),
      mainVersion?: string(name='MainVersion'),
      netType?: string(name='NetType'),
      payType?: string(name='PayType'),
      reason?: string(name='Reason'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      userId?: string(name='UserId'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Cluster')
  }(name='ClusterList'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeClusterListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeClusterList  DescribeClusterListRequest
  * @return DescribeClusterListResponse
 */
async function describeClusterList(request: DescribeClusterListRequest): DescribeClusterListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClusterList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeClusterModelRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeClusterModelResponseBody = {
  autoRenew?: string(name='AutoRenew'),
  backupStatus?: string(name='BackupStatus'),
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  clusterType?: string(name='ClusterType'),
  coldStorageStatus?: string(name='ColdStorageStatus'),
  coreDiskQuantity?: int32(name='CoreDiskQuantity'),
  coreDiskSize?: string(name='CoreDiskSize'),
  coreDiskType?: string(name='CoreDiskType'),
  coreInstanceQuantity?: int32(name='CoreInstanceQuantity'),
  coreInstanceType?: string(name='CoreInstanceType'),
  createTime?: string(name='CreateTime'),
  dbType?: string(name='DbType'),
  expireTime?: string(name='ExpireTime'),
  haType?: string(name='HaType'),
  hasUser?: string(name='HasUser'),
  isMultimod?: string(name='IsMultimod'),
  lockMode?: string(name='LockMode'),
  mainVersion?: string(name='MainVersion'),
  masterDiskSize?: int32(name='MasterDiskSize'),
  masterDiskType?: string(name='MasterDiskType'),
  masterInstanceType?: string(name='MasterInstanceType'),
  minorVersion?: string(name='MinorVersion'),
  payType?: string(name='PayType'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  tags?: {
    tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag')
  }(name='Tags'),
  updateStatus?: string(name='UpdateStatus'),
  zoneId?: string(name='ZoneId'),
}

model DescribeClusterModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterModelResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeClusterModel  DescribeClusterModelRequest
  * @return DescribeClusterModelResponse
 */
async function describeClusterModel(request: DescribeClusterModelRequest): DescribeClusterModelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClusterModel', 'POST', '/', 'json', false, 'json', request);
}

model DescribeClusterWhiteListRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeClusterWhiteListResponseBody = {
  groupItems?: {
    whiteIp?: [ string ](name='WhiteIp')
  }(name='GroupItems'),
  requestId?: string(name='RequestId'),
}

model DescribeClusterWhiteListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterWhiteListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeClusterWhiteList  DescribeClusterWhiteListRequest
  * @return DescribeClusterWhiteListResponse
 */
async function describeClusterWhiteList(request: DescribeClusterWhiteListRequest): DescribeClusterWhiteListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClusterWhiteList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeColdStorageRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeColdStorageResponseBody = {
  clusterId?: string(name='ClusterId'),
  coldStorageSize?: string(name='ColdStorageSize'),
  coldStorageUsePercent?: string(name='ColdStorageUsePercent'),
  openStatus?: string(name='OpenStatus'),
  payType?: string(name='PayType'),
  requestId?: string(name='RequestId'),
}

model DescribeColdStorageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeColdStorageResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeColdStorage  DescribeColdStorageRequest
  * @return DescribeColdStorageResponse
 */
async function describeColdStorage(request: DescribeColdStorageRequest): DescribeColdStorageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeColdStorage', 'POST', '/', 'json', false, 'json', request);
}

model DescribeMultiModDbAttributeRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeMultiModDbAttributeResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeMultiModDbAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeMultiModDbAttributeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeMultiModDbAttribute  DescribeMultiModDbAttributeRequest
  * @return DescribeMultiModDbAttributeResponse
 */
async function describeMultiModDbAttribute(request: DescribeMultiModDbAttributeRequest): DescribeMultiModDbAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMultiModDbAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRdsVSwitchsRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeRdsVSwitchsResponseBody = {
  requestId?: string(name='RequestId'),
  vSwitches?: {
    vSwitch?: [ 
      {
        aliUid?: string(name='AliUid'),
        bid?: string(name='Bid'),
        cidrBlock?: string(name='CidrBlock'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        isDefault?: boolean(name='IsDefault'),
        izNo?: string(name='IzNo'),
        regionNo?: string(name='RegionNo'),
        status?: string(name='Status'),
        vSwitchId?: string(name='VSwitchId'),
        vSwitchName?: string(name='VSwitchName'),
      }
    ](name='VSwitch'),
  }(name='VSwitches'),
}

model DescribeRdsVSwitchsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRdsVSwitchsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeRdsVSwitchs  DescribeRdsVSwitchsRequest
  * @return DescribeRdsVSwitchsResponse
 */
async function describeRdsVSwitchs(request: DescribeRdsVSwitchsRequest): DescribeRdsVSwitchsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRdsVSwitchs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeRegionsResponseBody = {
  regions?: {
    region?: [ 
    {
      regionId?: string(name='RegionId'),
      zones?: {
        zone?: [ 
        {
          vpcEnabled?: boolean(name='VpcEnabled'),
          zoneId?: string(name='ZoneId'),
        }
      ](name='Zone')
      }(name='Zones'),
    }
  ](name='Region')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeRegions  DescribeRegionsRequest
  * @return DescribeRegionsResponse
 */
async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRegions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeServerlessInstanceRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  zoneId: string(name='ZoneId', description='This parameter is required.', position='Query'),
}

model DescribeServerlessInstanceResponseBody = {
  autoRenew?: string(name='AutoRenew'),
  clusterType?: string(name='ClusterType'),
  createTime?: string(name='CreateTime'),
  cuSize?: string(name='CuSize'),
  diskSize?: string(name='DiskSize'),
  expireTime?: string(name='ExpireTime'),
  haType?: string(name='HaType'),
  hasUser?: string(name='HasUser'),
  innerEndpoint?: string(name='InnerEndpoint'),
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  isDeletionProtection?: string(name='IsDeletionProtection'),
  lockMode?: string(name='LockMode'),
  mainVersion?: string(name='MainVersion'),
  outerEndpoint?: string(name='OuterEndpoint'),
  payType?: string(name='PayType'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  reserverMaxQpsNum?: string(name='ReserverMaxQpsNum'),
  reserverMinQpsNum?: string(name='ReserverMinQpsNum'),
  status?: string(name='Status'),
  updateStatus?: string(name='UpdateStatus'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeServerlessInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeServerlessInstanceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeServerlessInstance  DescribeServerlessInstanceRequest
  * @return DescribeServerlessInstanceResponse
 */
async function describeServerlessInstance(request: DescribeServerlessInstanceRequest): DescribeServerlessInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeServerlessInstance', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSubscriptionInitializeProgressRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  subscriptionId: string(name='SubscriptionId', description='This parameter is required.', position='Query'),
}

model DescribeSubscriptionInitializeProgressResponseBody = {
  items?: [ 
    {
      finishTime?: string(name='FinishTime'),
      progress?: string(name='Progress'),
      status?: string(name='Status'),
      subscriptionId?: string(name='SubscriptionId'),
    }
  ](name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeSubscriptionInitializeProgressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSubscriptionInitializeProgressResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeSubscriptionInitializeProgress  DescribeSubscriptionInitializeProgressRequest
  * @return DescribeSubscriptionInitializeProgressResponse
 */
async function describeSubscriptionInitializeProgress(request: DescribeSubscriptionInitializeProgressRequest): DescribeSubscriptionInitializeProgressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSubscriptionInitializeProgress', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSubscriptionPerformanceRequest {
  endTime: string(name='EndTime', description='This parameter is required.', position='Query'),
  key: string(name='Key', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sourceInstanceId: string(name='SourceInstanceId', description='This parameter is required.', position='Query'),
  startTime: string(name='StartTime', description='This parameter is required.', position='Query'),
  subscriptionId: string(name='SubscriptionId', description='This parameter is required.', position='Query'),
}

model DescribeSubscriptionPerformanceResponseBody = {
  endTime?: string(name='EndTime'),
  performanceKeys?: {
    performanceKey?: [ 
      {
        key?: string(name='Key'),
        performanceValues?: {
          performanceValue?: [ 
            {
              date?: string(name='Date'),
              value?: string(name='Value'),
            }
          ](name='PerformanceValue'),
        }(name='PerformanceValues'),
        unit?: string(name='Unit'),
        valueFormat?: string(name='ValueFormat'),
      }
    ](name='PerformanceKey'),
  }(name='PerformanceKeys'),
  replicaId?: string(name='ReplicaId'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
}

model DescribeSubscriptionPerformanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSubscriptionPerformanceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeSubscriptionPerformance  DescribeSubscriptionPerformanceRequest
  * @return DescribeSubscriptionPerformanceResponse
 */
async function describeSubscriptionPerformance(request: DescribeSubscriptionPerformanceRequest): DescribeSubscriptionPerformanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSubscriptionPerformance', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSubscriptionPermissionRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeSubscriptionPermissionResponseBody = {
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model DescribeSubscriptionPermissionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSubscriptionPermissionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeSubscriptionPermission  DescribeSubscriptionPermissionRequest
  * @return DescribeSubscriptionPermissionResponse
 */
async function describeSubscriptionPermission(request: DescribeSubscriptionPermissionRequest): DescribeSubscriptionPermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSubscriptionPermission', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSubscriptionsRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  subscriptionId?: string(name='SubscriptionId', position='Query'),
}

model DescribeSubscriptionsResponseBody = {
  requestId?: string(name='RequestId'),
  subscriptions?: [ 
    {
      DBInstances?: [ 
        {
          DBInstanceId?: string(name='DBInstanceId'),
          regionId?: string(name='RegionId'),
          role?: string(name='Role'),
        }
      ](name='DBInstances'),
      mapping?: string(name='Mapping'),
      subscriptionDescription?: string(name='SubscriptionDescription'),
      subscriptionId?: string(name='SubscriptionId'),
      subscriptionStatus?: string(name='SubscriptionStatus'),
      subscriptionType?: string(name='SubscriptionType'),
    }
  ](name='Subscriptions'),
}

model DescribeSubscriptionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSubscriptionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeSubscriptions  DescribeSubscriptionsRequest
  * @return DescribeSubscriptionsResponse
 */
async function describeSubscriptions(request: DescribeSubscriptionsRequest): DescribeSubscriptionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSubscriptions', 'POST', '/', 'json', false, 'json', request);
}

model EnableServerlessPublicConnectionRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId: string(name='ZoneId', description='This parameter is required.', position='Query'),
}

model EnableServerlessPublicConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableServerlessPublicConnectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableServerlessPublicConnectionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of EnableServerlessPublicConnection  EnableServerlessPublicConnectionRequest
  * @return EnableServerlessPublicConnectionResponse
 */
async function enableServerlessPublicConnection(request: EnableServerlessPublicConnectionRequest): EnableServerlessPublicConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableServerlessPublicConnection', 'POST', '/', 'json', false, 'json', request);
}

model GetMultimodeCmsUrlRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model GetMultimodeCmsUrlResponseBody = {
  clusterId?: string(name='ClusterId'),
  multimodCmsUrl?: string(name='MultimodCmsUrl'),
  requestId?: string(name='RequestId'),
}

model GetMultimodeCmsUrlResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMultimodeCmsUrlResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetMultimodeCmsUrl  GetMultimodeCmsUrlRequest
  * @return GetMultimodeCmsUrlResponse
 */
async function getMultimodeCmsUrl(request: GetMultimodeCmsUrlRequest): GetMultimodeCmsUrlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMultimodeCmsUrl', 'POST', '/', 'json', false, 'json', request);
}

model ListClusterServiceConfigRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListClusterServiceConfigResponseBody = {
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  configList?: {
    config?: [ 
    {
      defaultValue?: string(name='DefaultValue'),
      description?: string(name='Description'),
      name?: string(name='Name'),
      needRestart?: string(name='NeedRestart'),
      runningValue?: string(name='RunningValue'),
      unit?: string(name='Unit'),
      valueRange?: string(name='ValueRange'),
    }
  ](name='Config')
  }(name='ConfigList'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model ListClusterServiceConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListClusterServiceConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListClusterServiceConfig  ListClusterServiceConfigRequest
  * @return ListClusterServiceConfigResponse
 */
async function listClusterServiceConfig(request: ListClusterServiceConfigRequest): ListClusterServiceConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusterServiceConfig', 'POST', '/', 'json', false, 'json', request);
}

model ListClusterServiceConfigHistoryRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model ListClusterServiceConfigHistoryResponseBody = {
  configHistoryList?: {
    configHistory?: [ 
    {
      createTime?: string(name='CreateTime'),
      effective?: string(name='Effective'),
      name?: string(name='Name'),
      newValue?: string(name='NewValue'),
      oldValue?: string(name='OldValue'),
    }
  ](name='ConfigHistory')
  }(name='ConfigHistoryList'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model ListClusterServiceConfigHistoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListClusterServiceConfigHistoryResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListClusterServiceConfigHistory  ListClusterServiceConfigHistoryRequest
  * @return ListClusterServiceConfigHistoryResponse
 */
async function listClusterServiceConfigHistory(request: ListClusterServiceConfigHistoryRequest): ListClusterServiceConfigHistoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusterServiceConfigHistory', 'POST', '/', 'json', false, 'json', request);
}

model ListHbaseInstancesRequest {
  regionId?: string(name='RegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model ListHbaseInstancesResponseBody = {
  instances?: {
    instance?: [ 
    {
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      isDefault?: boolean(name='IsDefault'),
    }
  ](name='Instance')
  }(name='Instances'),
  requestId?: string(name='RequestId'),
}

model ListHbaseInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListHbaseInstancesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListHbaseInstances  ListHbaseInstancesRequest
  * @return ListHbaseInstancesResponse
 */
async function listHbaseInstances(request: ListHbaseInstancesRequest): ListHbaseInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListHbaseInstances', 'POST', '/', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceId?: [ string ](name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', description='This parameter is required.', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListTagResources  ListTagResourcesRequest
  * @return ListTagResourcesResponse
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', '/', 'json', false, 'json', request);
}

model ModifyBackupPolicyRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  preferredBackupEndTimeUTC?: string(name='PreferredBackupEndTimeUTC', position='Query'),
  preferredBackupPeriod: string(name='PreferredBackupPeriod', description='This parameter is required.', position='Query'),
  preferredBackupStartTimeUTC?: string(name='PreferredBackupStartTimeUTC', position='Query'),
  preferredBackupTime: string(name='PreferredBackupTime', description='This parameter is required.', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model ModifyBackupPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBackupPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyBackupPolicyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyBackupPolicy  ModifyBackupPolicyRequest
  * @return ModifyBackupPolicyResponse
 */
async function modifyBackupPolicy(request: ModifyBackupPolicyRequest): ModifyBackupPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyBackupPolicy', 'POST', '/', 'json', false, 'json', request);
}

model ModifyClusterNameRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  clusterName: string(name='ClusterName', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model ModifyClusterNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyClusterNameResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyClusterName  ModifyClusterNameRequest
  * @return ModifyClusterNameResponse
 */
async function modifyClusterName(request: ModifyClusterNameRequest): ModifyClusterNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyClusterName', 'POST', '/', 'json', false, 'json', request);
}

model ModifyClusterNetTypeRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  netType: string(name='NetType', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model ModifyClusterNetTypeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterNetTypeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyClusterNetTypeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyClusterNetType  ModifyClusterNetTypeRequest
  * @return ModifyClusterNetTypeResponse
 */
async function modifyClusterNetType(request: ModifyClusterNetTypeRequest): ModifyClusterNetTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyClusterNetType', 'POST', '/', 'json', false, 'json', request);
}

model ModifyClusterSecurityIpListRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityIpList: string(name='SecurityIpList', description='This parameter is required.', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model ModifyClusterSecurityIpListResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterSecurityIpListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyClusterSecurityIpListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyClusterSecurityIpList  ModifyClusterSecurityIpListRequest
  * @return ModifyClusterSecurityIpListResponse
 */
async function modifyClusterSecurityIpList(request: ModifyClusterSecurityIpListRequest): ModifyClusterSecurityIpListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyClusterSecurityIpList', 'POST', '/', 'json', false, 'json', request);
}

model ModifyClusterServiceConfigRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  parameters?: string(name='Parameters', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  restart?: boolean(name='Restart', position='Query'),
  value?: string(name='Value', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model ModifyClusterServiceConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterServiceConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyClusterServiceConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyClusterServiceConfig  ModifyClusterServiceConfigRequest
  * @return ModifyClusterServiceConfigResponse
 */
async function modifyClusterServiceConfig(request: ModifyClusterServiceConfigRequest): ModifyClusterServiceConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyClusterServiceConfig', 'POST', '/', 'json', false, 'json', request);
}

model ModifyHasRootPasswordRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  hasPassword: string(name='HasPassword', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model ModifyHasRootPasswordResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyHasRootPasswordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyHasRootPasswordResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyHasRootPassword  ModifyHasRootPasswordRequest
  * @return ModifyHasRootPasswordResponse
 */
async function modifyHasRootPassword(request: ModifyHasRootPasswordRequest): ModifyHasRootPasswordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyHasRootPassword', 'POST', '/', 'json', false, 'json', request);
}

model ModifyRestartClusterRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  components?: string(name='Components', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model ModifyRestartClusterResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyRestartClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyRestartClusterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyRestartCluster  ModifyRestartClusterRequest
  * @return ModifyRestartClusterResponse
 */
async function modifyRestartCluster(request: ModifyRestartClusterRequest): ModifyRestartClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyRestartCluster', 'POST', '/', 'json', false, 'json', request);
}

model ModifyRollbackHasForHbaseRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model ModifyRollbackHasForHbaseResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyRollbackHasForHbaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyRollbackHasForHbaseResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyRollbackHasForHbase  ModifyRollbackHasForHbaseRequest
  * @return ModifyRollbackHasForHbaseResponse
 */
async function modifyRollbackHasForHbase(request: ModifyRollbackHasForHbaseRequest): ModifyRollbackHasForHbaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyRollbackHasForHbase', 'POST', '/', 'json', false, 'json', request);
}

model ModifySubscriptionDescriptionRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  subscriptionDescription: string(name='SubscriptionDescription', description='This parameter is required.', position='Query'),
  subscriptionId: string(name='SubscriptionId', description='This parameter is required.', position='Query'),
}

model ModifySubscriptionDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySubscriptionDescriptionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifySubscriptionDescriptionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifySubscriptionDescription  ModifySubscriptionDescriptionRequest
  * @return ModifySubscriptionDescriptionResponse
 */
async function modifySubscriptionDescription(request: ModifySubscriptionDescriptionRequest): ModifySubscriptionDescriptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySubscriptionDescription', 'POST', '/', 'json', false, 'json', request);
}

model ModifySubscriptionMappingRequest {
  mapping: string(name='Mapping', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  subscriptionId: string(name='SubscriptionId', description='This parameter is required.', position='Query'),
}

model ModifySubscriptionMappingResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySubscriptionMappingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifySubscriptionMappingResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifySubscriptionMapping  ModifySubscriptionMappingRequest
  * @return ModifySubscriptionMappingResponse
 */
async function modifySubscriptionMapping(request: ModifySubscriptionMappingRequest): ModifySubscriptionMappingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySubscriptionMapping', 'POST', '/', 'json', false, 'json', request);
}

model ModifySubscriptionPermissionRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status: int32(name='Status', description='This parameter is required.', position='Query'),
}

model ModifySubscriptionPermissionResponseBody = {
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model ModifySubscriptionPermissionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifySubscriptionPermissionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifySubscriptionPermission  ModifySubscriptionPermissionRequest
  * @return ModifySubscriptionPermissionResponse
 */
async function modifySubscriptionPermission(request: ModifySubscriptionPermissionRequest): ModifySubscriptionPermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySubscriptionPermission', 'POST', '/', 'json', false, 'json', request);
}

model ModifyUIProxyAccountPasswordRequest {
  accountName: string(name='AccountName', description='This parameter is required.', position='Query'),
  accountPassword: string(name='AccountPassword', description='This parameter is required.', position='Query'),
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model ModifyUIProxyAccountPasswordResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyUIProxyAccountPasswordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyUIProxyAccountPasswordResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyUIProxyAccountPassword  ModifyUIProxyAccountPasswordRequest
  * @return ModifyUIProxyAccountPasswordResponse
 */
async function modifyUIProxyAccountPassword(request: ModifyUIProxyAccountPasswordRequest): ModifyUIProxyAccountPasswordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyUIProxyAccountPassword', 'POST', '/', 'json', false, 'json', request);
}

model ModifyUpgradeToHasForHbaseRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  hasPassword: string(name='HasPassword', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model ModifyUpgradeToHasForHbaseResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyUpgradeToHasForHbaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyUpgradeToHasForHbaseResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyUpgradeToHasForHbase  ModifyUpgradeToHasForHbaseRequest
  * @return ModifyUpgradeToHasForHbaseResponse
 */
async function modifyUpgradeToHasForHbase(request: ModifyUpgradeToHasForHbaseRequest): ModifyUpgradeToHasForHbaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyUpgradeToHasForHbase', 'POST', '/', 'json', false, 'json', request);
}

model MultimodAddComponentsRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  components: string(name='Components', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model MultimodAddComponentsResponseBody = {
  requestId?: string(name='RequestId'),
}

model MultimodAddComponentsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MultimodAddComponentsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of MultimodAddComponents  MultimodAddComponentsRequest
  * @return MultimodAddComponentsResponse
 */
async function multimodAddComponents(request: MultimodAddComponentsRequest): MultimodAddComponentsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'MultimodAddComponents', 'POST', '/', 'json', false, 'json', request);
}

model OpenBackupRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model OpenBackupResponseBody = {
  requestId?: string(name='RequestId'),
}

model OpenBackupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OpenBackupResponseBody(name='body'),
}

/**
  * @param request  the request parameters of OpenBackup  OpenBackupRequest
  * @return OpenBackupResponse
 */
async function openBackup(request: OpenBackupRequest): OpenBackupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OpenBackup', 'POST', '/', 'json', false, 'json', request);
}

model QueryHBaseHaDBRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model QueryHBaseHaDBResponseBody = {
  clusterList?: {
    cluster?: [ 
    {
      activeName?: string(name='ActiveName'),
      bdsName?: string(name='BdsName'),
      haName?: string(name='HaName'),
      standbyName?: string(name='StandbyName'),
    }
  ](name='Cluster')
  }(name='ClusterList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model QueryHBaseHaDBResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryHBaseHaDBResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryHBaseHaDB  QueryHBaseHaDBRequest
  * @return QueryHBaseHaDBResponse
 */
async function queryHBaseHaDB(request: QueryHBaseHaDBRequest): QueryHBaseHaDBResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryHBaseHaDB', 'POST', '/', 'json', false, 'json', request);
}

model QuerySparkRelateHBaseRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model QuerySparkRelateHBaseResponseBody = {
  clusterList?: {
    cluster?: [ 
    {
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      clusterType?: string(name='ClusterType'),
      coreDiskType?: string(name='CoreDiskType'),
      coreInstanceQuantity?: int32(name='CoreInstanceQuantity'),
      createTime?: string(name='CreateTime'),
      dbType?: string(name='DbType'),
      expireTime?: string(name='ExpireTime'),
      isRelated?: boolean(name='IsRelated'),
      lockMode?: string(name='LockMode'),
      mainVersion?: string(name='MainVersion'),
      netType?: string(name='NetType'),
      payType?: string(name='PayType'),
      reason?: string(name='Reason'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      userId?: string(name='UserId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Cluster')
  }(name='ClusterList'),
  requestId?: string(name='RequestId'),
}

model QuerySparkRelateHBaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySparkRelateHBaseResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QuerySparkRelateHBase  QuerySparkRelateHBaseRequest
  * @return QuerySparkRelateHBaseResponse
 */
async function querySparkRelateHBase(request: QuerySparkRelateHBaseRequest): QuerySparkRelateHBaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QuerySparkRelateHBase', 'POST', '/', 'json', false, 'json', request);
}

model QueryXpackRelatedDBRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  relateDbType: string(name='RelateDbType', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model QueryXpackRelatedDBResponseBody = {
  clusterList?: {
    cluster?: [ 
    {
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      DBType?: string(name='DBType'),
      DBVersion?: string(name='DBVersion'),
      isRelated?: boolean(name='IsRelated'),
      status?: string(name='Status'),
    }
  ](name='Cluster')
  }(name='ClusterList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model QueryXpackRelatedDBResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryXpackRelatedDBResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryXpackRelatedDB  QueryXpackRelatedDBRequest
  * @return QueryXpackRelatedDBResponse
 */
async function queryXpackRelatedDB(request: QueryXpackRelatedDBRequest): QueryXpackRelatedDBResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryXpackRelatedDB', 'POST', '/', 'json', false, 'json', request);
}

model RelateDbForHBaseHaRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  haActive: string(name='HaActive', description='This parameter is required.', position='Query'),
  haActiveClusterKey?: string(name='HaActiveClusterKey', position='Query'),
  haActiveDBType: string(name='HaActiveDBType', description='This parameter is required.', position='Query'),
  haActiveHbaseFsDir?: string(name='HaActiveHbaseFsDir', position='Query'),
  haActiveHdfsUri?: string(name='HaActiveHdfsUri', position='Query'),
  haActivePassword?: string(name='HaActivePassword', position='Query'),
  haActiveUser?: string(name='HaActiveUser', position='Query'),
  haActiveVersion?: string(name='HaActiveVersion', position='Query'),
  haMigrateType: string(name='HaMigrateType', description='This parameter is required.', position='Query'),
  haStandby: string(name='HaStandby', description='This parameter is required.', position='Query'),
  haStandbyClusterKey?: string(name='HaStandbyClusterKey', position='Query'),
  haStandbyDBType: string(name='HaStandbyDBType', description='This parameter is required.', position='Query'),
  haStandbyHbaseFsDir?: string(name='HaStandbyHbaseFsDir', position='Query'),
  haStandbyHdfsUri?: string(name='HaStandbyHdfsUri', position='Query'),
  haStandbyPassword?: string(name='HaStandbyPassword', position='Query'),
  haStandbyUser?: string(name='HaStandbyUser', position='Query'),
  haStandbyVersion?: string(name='HaStandbyVersion', position='Query'),
  haTables?: string(name='HaTables', position='Query'),
  isActiveStandard: boolean(name='IsActiveStandard', description='This parameter is required.', position='Query'),
  isStandbyStandard: boolean(name='IsStandbyStandard', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model RelateDbForHBaseHaResponseBody = {
  requestId?: string(name='RequestId'),
}

model RelateDbForHBaseHaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RelateDbForHBaseHaResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RelateDbForHBaseHa  RelateDbForHBaseHaRequest
  * @return RelateDbForHBaseHaResponse
 */
async function relateDbForHBaseHa(request: RelateDbForHBaseHaRequest): RelateDbForHBaseHaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RelateDbForHBaseHa', 'POST', '/', 'json', false, 'json', request);
}

model ReleasePublicNetworkAddressRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ReleasePublicNetworkAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleasePublicNetworkAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReleasePublicNetworkAddressResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ReleasePublicNetworkAddress  ReleasePublicNetworkAddressRequest
  * @return ReleasePublicNetworkAddressResponse
 */
async function releasePublicNetworkAddress(request: ReleasePublicNetworkAddressRequest): ReleasePublicNetworkAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleasePublicNetworkAddress', 'POST', '/', 'json', false, 'json', request);
}

model ReleaseSubscriptionRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  subscriptionId: string(name='SubscriptionId', description='This parameter is required.', position='Query'),
}

model ReleaseSubscriptionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseSubscriptionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReleaseSubscriptionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ReleaseSubscription  ReleaseSubscriptionRequest
  * @return ReleaseSubscriptionResponse
 */
async function releaseSubscription(request: ReleaseSubscriptionRequest): ReleaseSubscriptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleaseSubscription', 'POST', '/', 'json', false, 'json', request);
}

model RenewClusterRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  duration: int32(name='Duration', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pricingCycle: string(name='PricingCycle', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RenewClusterResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model RenewClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RenewClusterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RenewCluster  RenewClusterRequest
  * @return RenewClusterResponse
 */
async function renewCluster(request: RenewClusterRequest): RenewClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RenewCluster', 'POST', '/', 'json', false, 'json', request);
}

model ResizeClusterRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  cloudType: string(name='CloudType', description='This parameter is required.', position='Query'),
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  coldStorageSize?: string(name='ColdStorageSize', position='Query'),
  coreDiskQuantity?: string(name='CoreDiskQuantity', position='Query'),
  coreDiskSize?: string(name='CoreDiskSize', position='Query'),
  coreDiskType?: string(name='CoreDiskType', position='Query'),
  coreInstanceQuantity: string(name='CoreInstanceQuantity', description='This parameter is required.', position='Query'),
  coreInstanceType?: string(name='CoreInstanceType', position='Query'),
  engine: string(name='Engine', description='This parameter is required.', position='Query'),
  isColdStorage?: string(name='IsColdStorage', position='Query'),
  payType?: string(name='PayType', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  upgradeType: string(name='UpgradeType', description='This parameter is required.', position='Query'),
  zoneId: string(name='ZoneId', description='This parameter is required.', position='Query'),
}

model ResizeClusterResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResizeClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResizeClusterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ResizeCluster  ResizeClusterRequest
  * @return ResizeClusterResponse
 */
async function resizeCluster(request: ResizeClusterRequest): ResizeClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResizeCluster', 'POST', '/', 'json', false, 'json', request);
}

model SparkRelateHBaseRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  hBaseClusterIds: string(name='HBaseClusterIds', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model SparkRelateHBaseResponseBody = {
  requestId?: string(name='RequestId'),
}

model SparkRelateHBaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SparkRelateHBaseResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SparkRelateHBase  SparkRelateHBaseRequest
  * @return SparkRelateHBaseResponse
 */
async function sparkRelateHBase(request: SparkRelateHBaseRequest): SparkRelateHBaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SparkRelateHBase', 'POST', '/', 'json', false, 'json', request);
}

model TagResourcesRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceId: [ string ](name='ResourceId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', description='This parameter is required.', position='Query'),
  tag: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', description='This parameter is required.', position='Query'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TagResourcesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of TagResources  TagResourcesRequest
  * @return TagResourcesResponse
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagResources', 'POST', '/', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  all?: boolean(name='All', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', position='Query'),
  resourceId: [ string ](name='ResourceId', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', description='This parameter is required.', position='Query'),
  tagKey?: [ string ](name='TagKey', position='Query'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UntagResourcesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UntagResources  UntagResourcesRequest
  * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UntagResources', 'POST', '/', 'json', false, 'json', request);
}

model UpgradeMinorVersionRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  components?: string(name='Components', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  upgradeVersion?: string(name='UpgradeVersion', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model UpgradeMinorVersionResponseBody = {
  newVersion?: string(name='NewVersion'),
  oldVersion?: string(name='OldVersion'),
  requestId?: string(name='RequestId'),
}

model UpgradeMinorVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpgradeMinorVersionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpgradeMinorVersion  UpgradeMinorVersionRequest
  * @return UpgradeMinorVersionResponse
 */
async function upgradeMinorVersion(request: UpgradeMinorVersionRequest): UpgradeMinorVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpgradeMinorVersion', 'POST', '/', 'json', false, 'json', request);
}

model XpackRelateDBRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Query'),
  dbClusterIds: string(name='DbClusterIds', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  relateDbType: string(name='RelateDbType', description='This parameter is required.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model XpackRelateDBResponseBody = {
  requestId?: string(name='RequestId'),
}

model XpackRelateDBResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: XpackRelateDBResponseBody(name='body'),
}

/**
  * @param request  the request parameters of XpackRelateDB  XpackRelateDBRequest
  * @return XpackRelateDBResponse
 */
async function xpackRelateDB(request: XpackRelateDBRequest): XpackRelateDBResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'XpackRelateDB', 'POST', '/', 'json', false, 'json', request);
}

