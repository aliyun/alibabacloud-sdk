/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-southeast-1 = 'hbase.aliyuncs.com',
    cn-beijing = 'hbase.aliyuncs.com',
    cn-hangzhou = 'hbase.aliyuncs.com',
    cn-hangzhou-finance = 'hbase.aliyuncs.com',
    cn-hongkong = 'hbase.aliyuncs.com',
    cn-north-2-gov-1 = 'hbase.aliyuncs.com',
    cn-qingdao = 'hbase.aliyuncs.com',
    cn-shanghai = 'hbase.aliyuncs.com',
    cn-shanghai-finance-1 = 'hbase.aliyuncs.com',
    cn-shenzhen = 'hbase.aliyuncs.com',
    cn-shenzhen-finance-1 = 'hbase.aliyuncs.com',
    cn-guangzhou = 'hbase.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('hbase', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddUserHdfsInfoRequest {
  clusterId?: string(name='ClusterId'),
  extInfo?: string(name='ExtInfo'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model AddUserHdfsInfoResponseBody = {
  clusterId?: string(name='ClusterId'),
  requestId?: string(name='RequestId'),
}

model AddUserHdfsInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddUserHdfsInfoResponseBody(name='body'),
}

async function addUserHdfsInfoWithOptions(request: AddUserHdfsInfoRequest, runtime: Util.RuntimeOptions): AddUserHdfsInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.extInfo)) {
    query['ExtInfo'] = request.extInfo;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddUserHdfsInfo',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addUserHdfsInfo(request: AddUserHdfsInfoRequest): AddUserHdfsInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return addUserHdfsInfoWithOptions(request, runtime);
}

model AllocatePublicNetworkAddressRequest {
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AllocatePublicNetworkAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model AllocatePublicNetworkAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AllocatePublicNetworkAddressResponseBody(name='body'),
}

async function allocatePublicNetworkAddressWithOptions(request: AllocatePublicNetworkAddressRequest, runtime: Util.RuntimeOptions): AllocatePublicNetworkAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AllocatePublicNetworkAddress',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function allocatePublicNetworkAddress(request: AllocatePublicNetworkAddressRequest): AllocatePublicNetworkAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocatePublicNetworkAddressWithOptions(request, runtime);
}

model CheckVersionsOfComponentsRequest {
  clusterId?: string(name='ClusterId'),
  components?: string(name='Components'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model CheckVersionsOfComponentsResponseBody = {
  components?: {
    components?: [ 
    {
      component?: string(name='Component'),
      isLatestVersion?: string(name='IsLatestVersion'),
    }
  ](name='Components')
  }(name='Components'),
  requestId?: string(name='RequestId'),
}

model CheckVersionsOfComponentsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckVersionsOfComponentsResponseBody(name='body'),
}

async function checkVersionsOfComponentsWithOptions(request: CheckVersionsOfComponentsRequest, runtime: Util.RuntimeOptions): CheckVersionsOfComponentsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.components)) {
    query['Components'] = request.components;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckVersionsOfComponents',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkVersionsOfComponents(request: CheckVersionsOfComponentsRequest): CheckVersionsOfComponentsResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkVersionsOfComponentsWithOptions(request, runtime);
}

model CloseBackupRequest {
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model CloseBackupResponseBody = {
  requestId?: string(name='RequestId'),
}

model CloseBackupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CloseBackupResponseBody(name='body'),
}

async function closeBackupWithOptions(request: CloseBackupRequest, runtime: Util.RuntimeOptions): CloseBackupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloseBackup',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function closeBackup(request: CloseBackupRequest): CloseBackupResponse {
  var runtime = new Util.RuntimeOptions{};
  return closeBackupWithOptions(request, runtime);
}

model ConvertClusterRequest {
  clusterId?: string(name='ClusterId'),
  duration?: int32(name='Duration'),
  ownerId?: long(name='OwnerId'),
  pricingCycle?: string(name='PricingCycle'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ConvertClusterResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ConvertClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConvertClusterResponseBody(name='body'),
}

async function convertClusterWithOptions(request: ConvertClusterRequest, runtime: Util.RuntimeOptions): ConvertClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConvertCluster',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function convertCluster(request: ConvertClusterRequest): ConvertClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return convertClusterWithOptions(request, runtime);
}

model CreateClusterRequest {
  autoRenew?: string(name='AutoRenew'),
  backupId?: string(name='BackupId'),
  clientToken?: string(name='ClientToken'),
  cloudType?: string(name='CloudType'),
  clusterName?: string(name='ClusterName'),
  coldStorageSize?: string(name='ColdStorageSize'),
  coreDiskQuantity?: string(name='CoreDiskQuantity'),
  coreDiskSize?: string(name='CoreDiskSize'),
  coreDiskType?: string(name='CoreDiskType'),
  coreInstanceQuantity?: string(name='CoreInstanceQuantity'),
  coreInstanceType?: string(name='CoreInstanceType'),
  dbInstanceConnType?: string(name='DbInstanceConnType'),
  dbInstanceType?: string(name='DbInstanceType'),
  dbType?: string(name='DbType'),
  depMode?: string(name='DepMode'),
  duration?: string(name='Duration'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  isColdStorage?: string(name='IsColdStorage'),
  masterInstanceType?: string(name='MasterInstanceType'),
  netType?: string(name='NetType'),
  payType?: string(name='PayType'),
  pricingCycle?: string(name='PricingCycle'),
  regionId?: string(name='RegionId'),
  restoreTime?: string(name='RestoreTime'),
  securityIPList?: string(name='SecurityIPList'),
  srcDBInstanceId?: string(name='SrcDBInstanceId'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model CreateClusterResponseBody = {
  clusterId?: string(name='ClusterId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateClusterResponseBody(name='body'),
}

async function createClusterWithOptions(request: CreateClusterRequest, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.cloudType)) {
    query['CloudType'] = request.cloudType;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.coldStorageSize)) {
    query['ColdStorageSize'] = request.coldStorageSize;
  }
  if (!Util.isUnset(request.coreDiskQuantity)) {
    query['CoreDiskQuantity'] = request.coreDiskQuantity;
  }
  if (!Util.isUnset(request.coreDiskSize)) {
    query['CoreDiskSize'] = request.coreDiskSize;
  }
  if (!Util.isUnset(request.coreDiskType)) {
    query['CoreDiskType'] = request.coreDiskType;
  }
  if (!Util.isUnset(request.coreInstanceQuantity)) {
    query['CoreInstanceQuantity'] = request.coreInstanceQuantity;
  }
  if (!Util.isUnset(request.coreInstanceType)) {
    query['CoreInstanceType'] = request.coreInstanceType;
  }
  if (!Util.isUnset(request.dbInstanceConnType)) {
    query['DbInstanceConnType'] = request.dbInstanceConnType;
  }
  if (!Util.isUnset(request.dbInstanceType)) {
    query['DbInstanceType'] = request.dbInstanceType;
  }
  if (!Util.isUnset(request.dbType)) {
    query['DbType'] = request.dbType;
  }
  if (!Util.isUnset(request.depMode)) {
    query['DepMode'] = request.depMode;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.isColdStorage)) {
    query['IsColdStorage'] = request.isColdStorage;
  }
  if (!Util.isUnset(request.masterInstanceType)) {
    query['MasterInstanceType'] = request.masterInstanceType;
  }
  if (!Util.isUnset(request.netType)) {
    query['NetType'] = request.netType;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.restoreTime)) {
    query['RestoreTime'] = request.restoreTime;
  }
  if (!Util.isUnset(request.securityIPList)) {
    query['SecurityIPList'] = request.securityIPList;
  }
  if (!Util.isUnset(request.srcDBInstanceId)) {
    query['SrcDBInstanceId'] = request.srcDBInstanceId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCluster',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createClusterWithOptions(request, runtime);
}

model CreateGlobalResourceRequest {
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceName?: string(name='ResourceName'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  zoneId?: string(name='ZoneId'),
}

model CreateGlobalResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateGlobalResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateGlobalResourceResponseBody(name='body'),
}

async function createGlobalResourceWithOptions(request: CreateGlobalResourceRequest, runtime: Util.RuntimeOptions): CreateGlobalResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGlobalResource',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGlobalResource(request: CreateGlobalResourceRequest): CreateGlobalResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGlobalResourceWithOptions(request, runtime);
}

model CreateHbaseSlbServerRequest {
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  slbServer?: string(name='SlbServer'),
  zoneId?: string(name='ZoneId'),
}

model CreateHbaseSlbServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateHbaseSlbServerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateHbaseSlbServerResponseBody(name='body'),
}

async function createHbaseSlbServerWithOptions(request: CreateHbaseSlbServerRequest, runtime: Util.RuntimeOptions): CreateHbaseSlbServerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.slbServer)) {
    query['SlbServer'] = request.slbServer;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHbaseSlbServer',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createHbaseSlbServer(request: CreateHbaseSlbServerRequest): CreateHbaseSlbServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHbaseSlbServerWithOptions(request, runtime);
}

model CreateSubscriptionRequest {
  destinationInstanceId?: string(name='DestinationInstanceId'),
  destinationInstanceRegionId?: string(name='DestinationInstanceRegionId'),
  extraContext?: string(name='ExtraContext'),
  mapping?: string(name='Mapping'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  slbServer?: string(name='SlbServer'),
  sourceInstanceId?: string(name='SourceInstanceId'),
  sourceInstanceRegionId?: string(name='SourceInstanceRegionId'),
  subscriptionDescription?: string(name='SubscriptionDescription'),
  subscriptionType?: string(name='SubscriptionType'),
  zoneId?: string(name='ZoneId'),
}

model CreateSubscriptionResponseBody = {
  requestId?: string(name='RequestId'),
  subscriptionId?: string(name='SubscriptionId'),
}

model CreateSubscriptionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSubscriptionResponseBody(name='body'),
}

async function createSubscriptionWithOptions(request: CreateSubscriptionRequest, runtime: Util.RuntimeOptions): CreateSubscriptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.destinationInstanceId)) {
    query['DestinationInstanceId'] = request.destinationInstanceId;
  }
  if (!Util.isUnset(request.destinationInstanceRegionId)) {
    query['DestinationInstanceRegionId'] = request.destinationInstanceRegionId;
  }
  if (!Util.isUnset(request.extraContext)) {
    query['ExtraContext'] = request.extraContext;
  }
  if (!Util.isUnset(request.mapping)) {
    query['Mapping'] = request.mapping;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.slbServer)) {
    query['SlbServer'] = request.slbServer;
  }
  if (!Util.isUnset(request.sourceInstanceId)) {
    query['SourceInstanceId'] = request.sourceInstanceId;
  }
  if (!Util.isUnset(request.sourceInstanceRegionId)) {
    query['SourceInstanceRegionId'] = request.sourceInstanceRegionId;
  }
  if (!Util.isUnset(request.subscriptionDescription)) {
    query['SubscriptionDescription'] = request.subscriptionDescription;
  }
  if (!Util.isUnset(request.subscriptionType)) {
    query['SubscriptionType'] = request.subscriptionType;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSubscription',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSubscription(request: CreateSubscriptionRequest): CreateSubscriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSubscriptionWithOptions(request, runtime);
}

model DeleteClusterRequest {
  clientToken?: string(name='ClientToken'),
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model DeleteClusterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteClusterResponseBody(name='body'),
}

async function deleteClusterWithOptions(request: DeleteClusterRequest, runtime: Util.RuntimeOptions): DeleteClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCluster',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCluster(request: DeleteClusterRequest): DeleteClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClusterWithOptions(request, runtime);
}

model DeleteGlobalResourceRequest {
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceName?: string(name='ResourceName'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  zoneId?: string(name='ZoneId'),
}

model DeleteGlobalResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGlobalResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteGlobalResourceResponseBody(name='body'),
}

async function deleteGlobalResourceWithOptions(request: DeleteGlobalResourceRequest, runtime: Util.RuntimeOptions): DeleteGlobalResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGlobalResource',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGlobalResource(request: DeleteGlobalResourceRequest): DeleteGlobalResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGlobalResourceWithOptions(request, runtime);
}

model DeleteHbaseSlbServerRequest {
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  slbServer?: string(name='SlbServer'),
  zoneId?: string(name='ZoneId'),
}

model DeleteHbaseSlbServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteHbaseSlbServerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteHbaseSlbServerResponseBody(name='body'),
}

async function deleteHbaseSlbServerWithOptions(request: DeleteHbaseSlbServerRequest, runtime: Util.RuntimeOptions): DeleteHbaseSlbServerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.slbServer)) {
    query['SlbServer'] = request.slbServer;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHbaseSlbServer',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteHbaseSlbServer(request: DeleteHbaseSlbServerRequest): DeleteHbaseSlbServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHbaseSlbServerWithOptions(request, runtime);
}

model DeleteServerlessInstanceRequest {
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model DeleteServerlessInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteServerlessInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteServerlessInstanceResponseBody(name='body'),
}

async function deleteServerlessInstanceWithOptions(request: DeleteServerlessInstanceRequest, runtime: Util.RuntimeOptions): DeleteServerlessInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteServerlessInstance',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteServerlessInstance(request: DeleteServerlessInstanceRequest): DeleteServerlessInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteServerlessInstanceWithOptions(request, runtime);
}

model DeleteUserHdfsInfoRequest {
  clusterId?: string(name='ClusterId'),
  nameService?: string(name='NameService'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model DeleteUserHdfsInfoResponseBody = {
  clusterId?: string(name='ClusterId'),
  requestId?: string(name='RequestId'),
}

model DeleteUserHdfsInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteUserHdfsInfoResponseBody(name='body'),
}

async function deleteUserHdfsInfoWithOptions(request: DeleteUserHdfsInfoRequest, runtime: Util.RuntimeOptions): DeleteUserHdfsInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.nameService)) {
    query['NameService'] = request.nameService;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUserHdfsInfo',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUserHdfsInfo(request: DeleteUserHdfsInfoRequest): DeleteUserHdfsInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserHdfsInfoWithOptions(request, runtime);
}

model DescribeBackupPolicyRequest {
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeBackupPolicyResponseBody = {
  backupRetentionPeriod?: string(name='BackupRetentionPeriod'),
  preferredBackupEndTimeUTC?: string(name='PreferredBackupEndTimeUTC'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod'),
  preferredBackupStartTimeUTC?: string(name='PreferredBackupStartTimeUTC'),
  preferredBackupTime?: string(name='PreferredBackupTime'),
  requestId?: string(name='RequestId'),
}

model DescribeBackupPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBackupPolicyResponseBody(name='body'),
}

async function describeBackupPolicyWithOptions(request: DescribeBackupPolicyRequest, runtime: Util.RuntimeOptions): DescribeBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupPolicy',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupPolicy(request: DescribeBackupPolicyRequest): DescribeBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupPolicyWithOptions(request, runtime);
}

model DescribeBackupsRequest {
  backupId?: int32(name='BackupId'),
  clusterId?: string(name='ClusterId'),
  endTime?: string(name='EndTime'),
  endTimeUTC?: string(name='EndTimeUTC'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime'),
  startTimeUTC?: string(name='StartTimeUTC'),
  zoneId?: string(name='ZoneId'),
}

model DescribeBackupsResponseBody = {
  backups?: {
    backup?: [ 
    {
      backupDBNames?: string(name='BackupDBNames'),
      backupDownloadURL?: string(name='BackupDownloadURL'),
      backupEndTime?: string(name='BackupEndTime'),
      backupEndTimeUTC?: string(name='BackupEndTimeUTC'),
      backupId?: int32(name='BackupId'),
      backupMethod?: string(name='BackupMethod'),
      backupMode?: string(name='BackupMode'),
      backupSize?: string(name='BackupSize'),
      backupStartTime?: string(name='BackupStartTime'),
      backupStartTimeUTC?: string(name='BackupStartTimeUTC'),
      backupStatus?: string(name='BackupStatus'),
      backupType?: string(name='BackupType'),
    }
  ](name='Backup')
  }(name='Backups'),
  enableStatus?: string(name='EnableStatus'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeBackupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBackupsResponseBody(name='body'),
}

async function describeBackupsWithOptions(request: DescribeBackupsRequest, runtime: Util.RuntimeOptions): DescribeBackupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.endTimeUTC)) {
    query['EndTimeUTC'] = request.endTimeUTC;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.startTimeUTC)) {
    query['StartTimeUTC'] = request.startTimeUTC;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackups',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackups(request: DescribeBackupsRequest): DescribeBackupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupsWithOptions(request, runtime);
}

model DescribeClusterAttributeRequest {
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeClusterAttributeResponseBody = {
  autoRenew?: string(name='AutoRenew'),
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  clusterType?: string(name='ClusterType'),
  coldStorageStatus?: string(name='ColdStorageStatus'),
  connectionInfo?: {
    haRestConnectionString?: string(name='HaRestConnectionString'),
    haRestPort?: string(name='HaRestPort'),
    haThriftConnectionString?: string(name='HaThriftConnectionString'),
    haThriftPort?: string(name='HaThriftPort'),
    thriftConnectionString?: string(name='ThriftConnectionString'),
    thriftPort?: string(name='ThriftPort'),
    UIProxyConnectionString?: string(name='UIProxyConnectionString'),
    ZKClassicConnectionStringList?: {
      string?: [ string ](name='String')
    }(name='ZKClassicConnectionStringList'),
    ZKConnectionStringList?: {
      string?: [ string ](name='String')
    }(name='ZKConnectionStringList'),
    ZKInnerConnectionStringList?: {
      string?: [ string ](name='String')
    }(name='ZKInnerConnectionStringList'),
    ZKPort?: int32(name='ZKPort'),
    ZKPublicConnectionStringList?: {
      string?: [ string ](name='String')
    }(name='ZKPublicConnectionStringList'),
  }(name='ConnectionInfo'),
  coreDiskQuantity?: int32(name='CoreDiskQuantity'),
  coreDiskSize?: string(name='CoreDiskSize'),
  coreDiskType?: string(name='CoreDiskType'),
  coreInstanceQuantity?: int32(name='CoreInstanceQuantity'),
  coreInstanceType?: string(name='CoreInstanceType'),
  createTime?: string(name='CreateTime'),
  expireTime?: string(name='ExpireTime'),
  haType?: string(name='HaType'),
  hasUser?: string(name='HasUser'),
  lockMode?: string(name='LockMode'),
  mainVersion?: string(name='MainVersion'),
  masterDiskSize?: int32(name='MasterDiskSize'),
  masterDiskType?: string(name='MasterDiskType'),
  masterInstanceType?: string(name='MasterInstanceType'),
  minorVersion?: string(name='MinorVersion'),
  netInfo?: {
    innerIpAddress?: string(name='InnerIpAddress'),
    netType?: string(name='NetType'),
    publicIpAddress?: string(name='PublicIpAddress'),
    securityIpList?: string(name='SecurityIpList'),
    vSwitchId?: string(name='VSwitchId'),
    vpcId?: string(name='VpcId'),
  }(name='NetInfo'),
  nodeList?: {
    node?: [ 
    {
      daemonList?: {
        daemon?: [ 
        {
          daemonName?: string(name='DaemonName'),
          daemonStatus?: string(name='DaemonStatus'),
        }
      ](name='Daemon')
      }(name='DaemonList'),
      memStore?: string(name='MemStore'),
      nodeDiskQuantity?: string(name='NodeDiskQuantity'),
      nodeDiskSize?: string(name='NodeDiskSize'),
      nodeDiskType?: string(name='NodeDiskType'),
      nodeId?: string(name='NodeId'),
      nodeInstanceType?: string(name='NodeInstanceType'),
      nodeStatus?: string(name='NodeStatus'),
      nodeType?: string(name='NodeType'),
      regionQuantity?: string(name='RegionQuantity'),
      serviceType?: string(name='ServiceType'),
      storeFile?: string(name='StoreFile'),
    }
  ](name='Node')
  }(name='NodeList'),
  payType?: string(name='PayType'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  updateStatus?: string(name='UpdateStatus'),
  zoneId?: string(name='ZoneId'),
}

model DescribeClusterAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterAttributeResponseBody(name='body'),
}

async function describeClusterAttributeWithOptions(request: DescribeClusterAttributeRequest, runtime: Util.RuntimeOptions): DescribeClusterAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterAttribute',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterAttribute(request: DescribeClusterAttributeRequest): DescribeClusterAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterAttributeWithOptions(request, runtime);
}

model DescribeClusterConnectAddrsRequest {
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeClusterConnectAddrsResponseBody = {
  dbType?: string(name='DbType'),
  isMultimod?: string(name='IsMultimod'),
  netType?: string(name='NetType'),
  requestId?: string(name='RequestId'),
  serviceConnAddrs?: {
    serviceConnAddr?: [ 
    {
      connAddrInfo?: {
        connAddr?: string(name='ConnAddr'),
        connAddrPort?: string(name='ConnAddrPort'),
        netType?: string(name='NetType'),
      }(name='ConnAddrInfo'),
      connType?: string(name='ConnType'),
    }
  ](name='ServiceConnAddr')
  }(name='ServiceConnAddrs'),
  slbConnAddrs?: {
    slbConnAddr?: [ 
    {
      connAddrInfo?: {
        connAddr?: string(name='ConnAddr'),
        connAddrPort?: string(name='ConnAddrPort'),
        netType?: string(name='NetType'),
      }(name='ConnAddrInfo'),
      slbType?: string(name='SlbType'),
    }
  ](name='SlbConnAddr')
  }(name='SlbConnAddrs'),
  thriftConn?: {
    connAddr?: string(name='ConnAddr'),
    connAddrPort?: string(name='ConnAddrPort'),
    netType?: string(name='NetType'),
  }(name='ThriftConn'),
  uiProxyConnAddrInfo?: {
    connAddr?: string(name='ConnAddr'),
    connAddrPort?: string(name='ConnAddrPort'),
    netType?: string(name='NetType'),
  }(name='UiProxyConnAddrInfo'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  zkConnAddrs?: {
    zkConnAddr?: [ 
    {
      connAddr?: string(name='ConnAddr'),
      connAddrPort?: string(name='ConnAddrPort'),
      netType?: string(name='NetType'),
    }
  ](name='ZkConnAddr')
  }(name='ZkConnAddrs'),
}

model DescribeClusterConnectAddrsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterConnectAddrsResponseBody(name='body'),
}

async function describeClusterConnectAddrsWithOptions(request: DescribeClusterConnectAddrsRequest, runtime: Util.RuntimeOptions): DescribeClusterConnectAddrsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterConnectAddrs',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterConnectAddrs(request: DescribeClusterConnectAddrsRequest): DescribeClusterConnectAddrsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterConnectAddrsWithOptions(request, runtime);
}

model DescribeClusterListRequest {
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  dbType?: string(name='DbType'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  statusList?: [ string ](name='StatusList'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  zoneId?: string(name='ZoneId'),
}

model DescribeClusterListResponseBody = {
  clusterList?: {
    cluster?: [ 
    {
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      clusterType?: string(name='ClusterType'),
      coreDiskSize?: string(name='CoreDiskSize'),
      coreDiskType?: string(name='CoreDiskType'),
      coreInstanceQuantity?: int32(name='CoreInstanceQuantity'),
      createTime?: string(name='CreateTime'),
      dbType?: string(name='DbType'),
      expireTime?: string(name='ExpireTime'),
      lockMode?: string(name='LockMode'),
      mainVersion?: string(name='MainVersion'),
      netType?: string(name='NetType'),
      payType?: string(name='PayType'),
      reason?: string(name='Reason'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      userId?: string(name='UserId'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Cluster')
  }(name='ClusterList'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeClusterListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterListResponseBody(name='body'),
}

async function describeClusterListWithOptions(request: DescribeClusterListRequest, runtime: Util.RuntimeOptions): DescribeClusterListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.dbType)) {
    query['DbType'] = request.dbType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.statusList)) {
    query['StatusList'] = request.statusList;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterList',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterList(request: DescribeClusterListRequest): DescribeClusterListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterListWithOptions(request, runtime);
}

model DescribeClusterModelRequest {
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeClusterModelResponseBody = {
  autoRenew?: string(name='AutoRenew'),
  backupStatus?: string(name='BackupStatus'),
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  clusterType?: string(name='ClusterType'),
  coldStorageStatus?: string(name='ColdStorageStatus'),
  coreDiskQuantity?: int32(name='CoreDiskQuantity'),
  coreDiskSize?: string(name='CoreDiskSize'),
  coreDiskType?: string(name='CoreDiskType'),
  coreInstanceQuantity?: int32(name='CoreInstanceQuantity'),
  coreInstanceType?: string(name='CoreInstanceType'),
  createTime?: string(name='CreateTime'),
  dbType?: string(name='DbType'),
  expireTime?: string(name='ExpireTime'),
  haType?: string(name='HaType'),
  hasUser?: string(name='HasUser'),
  isMultimod?: string(name='IsMultimod'),
  lockMode?: string(name='LockMode'),
  mainVersion?: string(name='MainVersion'),
  masterDiskSize?: int32(name='MasterDiskSize'),
  masterDiskType?: string(name='MasterDiskType'),
  masterInstanceType?: string(name='MasterInstanceType'),
  minorVersion?: string(name='MinorVersion'),
  payType?: string(name='PayType'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  tags?: {
    tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag')
  }(name='Tags'),
  updateStatus?: string(name='UpdateStatus'),
  zoneId?: string(name='ZoneId'),
}

model DescribeClusterModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterModelResponseBody(name='body'),
}

async function describeClusterModelWithOptions(request: DescribeClusterModelRequest, runtime: Util.RuntimeOptions): DescribeClusterModelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterModel',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterModel(request: DescribeClusterModelRequest): DescribeClusterModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterModelWithOptions(request, runtime);
}

model DescribeClusterWhiteListRequest {
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeClusterWhiteListResponseBody = {
  groupItems?: {
    whiteIp?: [ string ](name='WhiteIp')
  }(name='GroupItems'),
  requestId?: string(name='RequestId'),
}

model DescribeClusterWhiteListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterWhiteListResponseBody(name='body'),
}

async function describeClusterWhiteListWithOptions(request: DescribeClusterWhiteListRequest, runtime: Util.RuntimeOptions): DescribeClusterWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterWhiteList',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterWhiteList(request: DescribeClusterWhiteListRequest): DescribeClusterWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterWhiteListWithOptions(request, runtime);
}

model DescribeColdStorageRequest {
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeColdStorageResponseBody = {
  clusterId?: string(name='ClusterId'),
  coldStorageSize?: string(name='ColdStorageSize'),
  coldStorageUsePercent?: string(name='ColdStorageUsePercent'),
  openStatus?: string(name='OpenStatus'),
  payType?: string(name='PayType'),
  requestId?: string(name='RequestId'),
}

model DescribeColdStorageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeColdStorageResponseBody(name='body'),
}

async function describeColdStorageWithOptions(request: DescribeColdStorageRequest, runtime: Util.RuntimeOptions): DescribeColdStorageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeColdStorage',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeColdStorage(request: DescribeColdStorageRequest): DescribeColdStorageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeColdStorageWithOptions(request, runtime);
}

model DescribeMultiModDbAttributeRequest {
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeMultiModDbAttributeResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeMultiModDbAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeMultiModDbAttributeResponseBody(name='body'),
}

async function describeMultiModDbAttributeWithOptions(request: DescribeMultiModDbAttributeRequest, runtime: Util.RuntimeOptions): DescribeMultiModDbAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMultiModDbAttribute',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMultiModDbAttribute(request: DescribeMultiModDbAttributeRequest): DescribeMultiModDbAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMultiModDbAttributeWithOptions(request, runtime);
}

model DescribeRdsVSwitchsRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeRdsVSwitchsResponseBody = {
  requestId?: string(name='RequestId'),
  vSwitches?: {
    vSwitch?: [ 
      {
        aliUid?: string(name='AliUid'),
        bid?: string(name='Bid'),
        cidrBlock?: string(name='CidrBlock'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        isDefault?: boolean(name='IsDefault'),
        izNo?: string(name='IzNo'),
        regionNo?: string(name='RegionNo'),
        status?: string(name='Status'),
        vSwitchId?: string(name='VSwitchId'),
        vSwitchName?: string(name='VSwitchName'),
      }
    ](name='VSwitch'),
  }(name='VSwitches'),
}

model DescribeRdsVSwitchsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRdsVSwitchsResponseBody(name='body'),
}

async function describeRdsVSwitchsWithOptions(request: DescribeRdsVSwitchsRequest, runtime: Util.RuntimeOptions): DescribeRdsVSwitchsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRdsVSwitchs',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRdsVSwitchs(request: DescribeRdsVSwitchsRequest): DescribeRdsVSwitchsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRdsVSwitchsWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeRegionsResponseBody = {
  regions?: {
    region?: [ 
    {
      regionId?: string(name='RegionId'),
      zones?: {
        zone?: [ 
        {
          vpcEnabled?: boolean(name='VpcEnabled'),
          zoneId?: string(name='ZoneId'),
        }
      ](name='Zone')
      }(name='Zones'),
    }
  ](name='Region')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeServerlessInstanceRequest {
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeServerlessInstanceResponseBody = {
  autoRenew?: string(name='AutoRenew'),
  clusterType?: string(name='ClusterType'),
  createTime?: string(name='CreateTime'),
  cuSize?: string(name='CuSize'),
  diskSize?: string(name='DiskSize'),
  expireTime?: string(name='ExpireTime'),
  haType?: string(name='HaType'),
  hasUser?: string(name='HasUser'),
  innerEndpoint?: string(name='InnerEndpoint'),
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  isDeletionProtection?: string(name='IsDeletionProtection'),
  lockMode?: string(name='LockMode'),
  mainVersion?: string(name='MainVersion'),
  outerEndpoint?: string(name='OuterEndpoint'),
  payType?: string(name='PayType'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  reserverMaxQpsNum?: string(name='ReserverMaxQpsNum'),
  reserverMinQpsNum?: string(name='ReserverMinQpsNum'),
  status?: string(name='Status'),
  updateStatus?: string(name='UpdateStatus'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeServerlessInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeServerlessInstanceResponseBody(name='body'),
}

async function describeServerlessInstanceWithOptions(request: DescribeServerlessInstanceRequest, runtime: Util.RuntimeOptions): DescribeServerlessInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServerlessInstance',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServerlessInstance(request: DescribeServerlessInstanceRequest): DescribeServerlessInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServerlessInstanceWithOptions(request, runtime);
}

model DescribeSubscriptionInitializeProgressRequest {
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  subscriptionId?: string(name='SubscriptionId'),
}

model DescribeSubscriptionInitializeProgressResponseBody = {
  items?: [ 
    {
      finishTime?: string(name='FinishTime'),
      progress?: string(name='Progress'),
      status?: string(name='Status'),
      subscriptionId?: string(name='SubscriptionId'),
    }
  ](name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeSubscriptionInitializeProgressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSubscriptionInitializeProgressResponseBody(name='body'),
}

async function describeSubscriptionInitializeProgressWithOptions(request: DescribeSubscriptionInitializeProgressRequest, runtime: Util.RuntimeOptions): DescribeSubscriptionInitializeProgressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.subscriptionId)) {
    query['SubscriptionId'] = request.subscriptionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSubscriptionInitializeProgress',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSubscriptionInitializeProgress(request: DescribeSubscriptionInitializeProgressRequest): DescribeSubscriptionInitializeProgressResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSubscriptionInitializeProgressWithOptions(request, runtime);
}

model DescribeSubscriptionPerformanceRequest {
  endTime?: string(name='EndTime'),
  key?: string(name='Key'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceInstanceId?: string(name='SourceInstanceId'),
  startTime?: string(name='StartTime'),
  subscriptionId?: string(name='SubscriptionId'),
}

model DescribeSubscriptionPerformanceResponseBody = {
  endTime?: string(name='EndTime'),
  performanceKeys?: {
    performanceKey?: [ 
      {
        key?: string(name='Key'),
        performanceValues?: {
          performanceValue?: [ 
            {
              date?: string(name='Date'),
              value?: string(name='Value'),
            }
          ](name='PerformanceValue'),
        }(name='PerformanceValues'),
        unit?: string(name='Unit'),
        valueFormat?: string(name='ValueFormat'),
      }
    ](name='PerformanceKey'),
  }(name='PerformanceKeys'),
  replicaId?: string(name='ReplicaId'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
}

model DescribeSubscriptionPerformanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSubscriptionPerformanceResponseBody(name='body'),
}

async function describeSubscriptionPerformanceWithOptions(request: DescribeSubscriptionPerformanceRequest, runtime: Util.RuntimeOptions): DescribeSubscriptionPerformanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceInstanceId)) {
    query['SourceInstanceId'] = request.sourceInstanceId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.subscriptionId)) {
    query['SubscriptionId'] = request.subscriptionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSubscriptionPerformance',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSubscriptionPerformance(request: DescribeSubscriptionPerformanceRequest): DescribeSubscriptionPerformanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSubscriptionPerformanceWithOptions(request, runtime);
}

model DescribeSubscriptionPermissionRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeSubscriptionPermissionResponseBody = {
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model DescribeSubscriptionPermissionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSubscriptionPermissionResponseBody(name='body'),
}

async function describeSubscriptionPermissionWithOptions(request: DescribeSubscriptionPermissionRequest, runtime: Util.RuntimeOptions): DescribeSubscriptionPermissionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSubscriptionPermission',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSubscriptionPermission(request: DescribeSubscriptionPermissionRequest): DescribeSubscriptionPermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSubscriptionPermissionWithOptions(request, runtime);
}

model DescribeSubscriptionsRequest {
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  subscriptionId?: string(name='SubscriptionId'),
}

model DescribeSubscriptionsResponseBody = {
  requestId?: string(name='RequestId'),
  subscriptions?: [ 
    {
      DBInstances?: [ 
        {
          DBInstanceId?: string(name='DBInstanceId'),
          regionId?: string(name='RegionId'),
          role?: string(name='Role'),
        }
      ](name='DBInstances'),
      mapping?: string(name='Mapping'),
      subscriptionDescription?: string(name='SubscriptionDescription'),
      subscriptionId?: string(name='SubscriptionId'),
      subscriptionStatus?: string(name='SubscriptionStatus'),
      subscriptionType?: string(name='SubscriptionType'),
    }
  ](name='Subscriptions'),
}

model DescribeSubscriptionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSubscriptionsResponseBody(name='body'),
}

async function describeSubscriptionsWithOptions(request: DescribeSubscriptionsRequest, runtime: Util.RuntimeOptions): DescribeSubscriptionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.subscriptionId)) {
    query['SubscriptionId'] = request.subscriptionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSubscriptions',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSubscriptions(request: DescribeSubscriptionsRequest): DescribeSubscriptionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSubscriptionsWithOptions(request, runtime);
}

model EnableServerlessPublicConnectionRequest {
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model EnableServerlessPublicConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableServerlessPublicConnectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableServerlessPublicConnectionResponseBody(name='body'),
}

async function enableServerlessPublicConnectionWithOptions(request: EnableServerlessPublicConnectionRequest, runtime: Util.RuntimeOptions): EnableServerlessPublicConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableServerlessPublicConnection',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableServerlessPublicConnection(request: EnableServerlessPublicConnectionRequest): EnableServerlessPublicConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableServerlessPublicConnectionWithOptions(request, runtime);
}

model GetMultimodeCmsUrlRequest {
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model GetMultimodeCmsUrlResponseBody = {
  clusterId?: string(name='ClusterId'),
  multimodCmsUrl?: string(name='MultimodCmsUrl'),
  requestId?: string(name='RequestId'),
}

model GetMultimodeCmsUrlResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMultimodeCmsUrlResponseBody(name='body'),
}

async function getMultimodeCmsUrlWithOptions(request: GetMultimodeCmsUrlRequest, runtime: Util.RuntimeOptions): GetMultimodeCmsUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMultimodeCmsUrl',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMultimodeCmsUrl(request: GetMultimodeCmsUrlRequest): GetMultimodeCmsUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMultimodeCmsUrlWithOptions(request, runtime);
}

model ListClusterServiceConfigRequest {
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListClusterServiceConfigResponseBody = {
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  configList?: {
    config?: [ 
    {
      defaultValue?: string(name='DefaultValue'),
      description?: string(name='Description'),
      name?: string(name='Name'),
      needRestart?: string(name='NeedRestart'),
      runningValue?: string(name='RunningValue'),
      unit?: string(name='Unit'),
      valueRange?: string(name='ValueRange'),
    }
  ](name='Config')
  }(name='ConfigList'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model ListClusterServiceConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListClusterServiceConfigResponseBody(name='body'),
}

async function listClusterServiceConfigWithOptions(request: ListClusterServiceConfigRequest, runtime: Util.RuntimeOptions): ListClusterServiceConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterServiceConfig',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterServiceConfig(request: ListClusterServiceConfigRequest): ListClusterServiceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterServiceConfigWithOptions(request, runtime);
}

model ListClusterServiceConfigHistoryRequest {
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model ListClusterServiceConfigHistoryResponseBody = {
  configHistoryList?: {
    configHistory?: [ 
    {
      createTime?: string(name='CreateTime'),
      effective?: string(name='Effective'),
      name?: string(name='Name'),
      newValue?: string(name='NewValue'),
      oldValue?: string(name='OldValue'),
    }
  ](name='ConfigHistory')
  }(name='ConfigHistoryList'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model ListClusterServiceConfigHistoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListClusterServiceConfigHistoryResponseBody(name='body'),
}

async function listClusterServiceConfigHistoryWithOptions(request: ListClusterServiceConfigHistoryRequest, runtime: Util.RuntimeOptions): ListClusterServiceConfigHistoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterServiceConfigHistory',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterServiceConfigHistory(request: ListClusterServiceConfigHistoryRequest): ListClusterServiceConfigHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterServiceConfigHistoryWithOptions(request, runtime);
}

model ListHbaseInstancesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model ListHbaseInstancesResponseBody = {
  instances?: {
    instance?: [ 
    {
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      isDefault?: boolean(name='IsDefault'),
    }
  ](name='Instance')
  }(name='Instances'),
  requestId?: string(name='RequestId'),
}

model ListHbaseInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListHbaseInstancesResponseBody(name='body'),
}

async function listHbaseInstancesWithOptions(request: ListHbaseInstancesRequest, runtime: Util.RuntimeOptions): ListHbaseInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHbaseInstances',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHbaseInstances(request: ListHbaseInstancesRequest): ListHbaseInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHbaseInstancesWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ModifyBackupPolicyRequest {
  clientToken?: string(name='ClientToken'),
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  preferredBackupEndTimeUTC?: string(name='PreferredBackupEndTimeUTC'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod'),
  preferredBackupStartTimeUTC?: string(name='PreferredBackupStartTimeUTC'),
  preferredBackupTime?: string(name='PreferredBackupTime'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model ModifyBackupPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBackupPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyBackupPolicyResponseBody(name='body'),
}

async function modifyBackupPolicyWithOptions(request: ModifyBackupPolicyRequest, runtime: Util.RuntimeOptions): ModifyBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.preferredBackupEndTimeUTC)) {
    query['PreferredBackupEndTimeUTC'] = request.preferredBackupEndTimeUTC;
  }
  if (!Util.isUnset(request.preferredBackupPeriod)) {
    query['PreferredBackupPeriod'] = request.preferredBackupPeriod;
  }
  if (!Util.isUnset(request.preferredBackupStartTimeUTC)) {
    query['PreferredBackupStartTimeUTC'] = request.preferredBackupStartTimeUTC;
  }
  if (!Util.isUnset(request.preferredBackupTime)) {
    query['PreferredBackupTime'] = request.preferredBackupTime;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyBackupPolicy',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyBackupPolicy(request: ModifyBackupPolicyRequest): ModifyBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBackupPolicyWithOptions(request, runtime);
}

model ModifyClusterNameRequest {
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model ModifyClusterNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyClusterNameResponseBody(name='body'),
}

async function modifyClusterNameWithOptions(request: ModifyClusterNameRequest, runtime: Util.RuntimeOptions): ModifyClusterNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterName',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyClusterName(request: ModifyClusterNameRequest): ModifyClusterNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClusterNameWithOptions(request, runtime);
}

model ModifyClusterNetTypeRequest {
  clusterId?: string(name='ClusterId'),
  netType?: string(name='NetType'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model ModifyClusterNetTypeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterNetTypeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyClusterNetTypeResponseBody(name='body'),
}

async function modifyClusterNetTypeWithOptions(request: ModifyClusterNetTypeRequest, runtime: Util.RuntimeOptions): ModifyClusterNetTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.netType)) {
    query['NetType'] = request.netType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterNetType',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyClusterNetType(request: ModifyClusterNetTypeRequest): ModifyClusterNetTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClusterNetTypeWithOptions(request, runtime);
}

model ModifyClusterSecurityIpListRequest {
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityIpList?: string(name='SecurityIpList'),
  zoneId?: string(name='ZoneId'),
}

model ModifyClusterSecurityIpListResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterSecurityIpListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyClusterSecurityIpListResponseBody(name='body'),
}

async function modifyClusterSecurityIpListWithOptions(request: ModifyClusterSecurityIpListRequest, runtime: Util.RuntimeOptions): ModifyClusterSecurityIpListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityIpList)) {
    query['SecurityIpList'] = request.securityIpList;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterSecurityIpList',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyClusterSecurityIpList(request: ModifyClusterSecurityIpListRequest): ModifyClusterSecurityIpListResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClusterSecurityIpListWithOptions(request, runtime);
}

model ModifyClusterServiceConfigRequest {
  clusterId?: string(name='ClusterId'),
  name?: string(name='Name'),
  ownerId?: long(name='OwnerId'),
  parameters?: string(name='Parameters'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restart?: boolean(name='Restart'),
  value?: string(name='Value'),
  zoneId?: string(name='ZoneId'),
}

model ModifyClusterServiceConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterServiceConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyClusterServiceConfigResponseBody(name='body'),
}

async function modifyClusterServiceConfigWithOptions(request: ModifyClusterServiceConfigRequest, runtime: Util.RuntimeOptions): ModifyClusterServiceConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameters)) {
    query['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.restart)) {
    query['Restart'] = request.restart;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterServiceConfig',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyClusterServiceConfig(request: ModifyClusterServiceConfigRequest): ModifyClusterServiceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClusterServiceConfigWithOptions(request, runtime);
}

model ModifyHasRootPasswordRequest {
  clusterId?: string(name='ClusterId'),
  hasPassword?: string(name='HasPassword'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model ModifyHasRootPasswordResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyHasRootPasswordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyHasRootPasswordResponseBody(name='body'),
}

async function modifyHasRootPasswordWithOptions(request: ModifyHasRootPasswordRequest, runtime: Util.RuntimeOptions): ModifyHasRootPasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.hasPassword)) {
    query['HasPassword'] = request.hasPassword;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyHasRootPassword',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyHasRootPassword(request: ModifyHasRootPasswordRequest): ModifyHasRootPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHasRootPasswordWithOptions(request, runtime);
}

model ModifyRestartClusterRequest {
  clusterId?: string(name='ClusterId'),
  components?: string(name='Components'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model ModifyRestartClusterResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyRestartClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyRestartClusterResponseBody(name='body'),
}

async function modifyRestartClusterWithOptions(request: ModifyRestartClusterRequest, runtime: Util.RuntimeOptions): ModifyRestartClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.components)) {
    query['Components'] = request.components;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyRestartCluster',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyRestartCluster(request: ModifyRestartClusterRequest): ModifyRestartClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyRestartClusterWithOptions(request, runtime);
}

model ModifyRollbackHasForHbaseRequest {
  clientToken?: string(name='ClientToken'),
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model ModifyRollbackHasForHbaseResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyRollbackHasForHbaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyRollbackHasForHbaseResponseBody(name='body'),
}

async function modifyRollbackHasForHbaseWithOptions(request: ModifyRollbackHasForHbaseRequest, runtime: Util.RuntimeOptions): ModifyRollbackHasForHbaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyRollbackHasForHbase',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyRollbackHasForHbase(request: ModifyRollbackHasForHbaseRequest): ModifyRollbackHasForHbaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyRollbackHasForHbaseWithOptions(request, runtime);
}

model ModifySubscriptionDescriptionRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  subscriptionDescription?: string(name='SubscriptionDescription'),
  subscriptionId?: string(name='SubscriptionId'),
}

model ModifySubscriptionDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySubscriptionDescriptionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifySubscriptionDescriptionResponseBody(name='body'),
}

async function modifySubscriptionDescriptionWithOptions(request: ModifySubscriptionDescriptionRequest, runtime: Util.RuntimeOptions): ModifySubscriptionDescriptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.subscriptionDescription)) {
    query['SubscriptionDescription'] = request.subscriptionDescription;
  }
  if (!Util.isUnset(request.subscriptionId)) {
    query['SubscriptionId'] = request.subscriptionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifySubscriptionDescription',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifySubscriptionDescription(request: ModifySubscriptionDescriptionRequest): ModifySubscriptionDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySubscriptionDescriptionWithOptions(request, runtime);
}

model ModifySubscriptionMappingRequest {
  mapping?: string(name='Mapping'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  subscriptionId?: string(name='SubscriptionId'),
}

model ModifySubscriptionMappingResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySubscriptionMappingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifySubscriptionMappingResponseBody(name='body'),
}

async function modifySubscriptionMappingWithOptions(request: ModifySubscriptionMappingRequest, runtime: Util.RuntimeOptions): ModifySubscriptionMappingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mapping)) {
    query['Mapping'] = request.mapping;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.subscriptionId)) {
    query['SubscriptionId'] = request.subscriptionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifySubscriptionMapping',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifySubscriptionMapping(request: ModifySubscriptionMappingRequest): ModifySubscriptionMappingResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySubscriptionMappingWithOptions(request, runtime);
}

model ModifySubscriptionPermissionRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  status?: int32(name='Status'),
}

model ModifySubscriptionPermissionResponseBody = {
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model ModifySubscriptionPermissionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifySubscriptionPermissionResponseBody(name='body'),
}

async function modifySubscriptionPermissionWithOptions(request: ModifySubscriptionPermissionRequest, runtime: Util.RuntimeOptions): ModifySubscriptionPermissionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifySubscriptionPermission',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifySubscriptionPermission(request: ModifySubscriptionPermissionRequest): ModifySubscriptionPermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySubscriptionPermissionWithOptions(request, runtime);
}

model ModifyUIProxyAccountPasswordRequest {
  accountName?: string(name='AccountName'),
  accountPassword?: string(name='AccountPassword'),
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model ModifyUIProxyAccountPasswordResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyUIProxyAccountPasswordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyUIProxyAccountPasswordResponseBody(name='body'),
}

async function modifyUIProxyAccountPasswordWithOptions(request: ModifyUIProxyAccountPasswordRequest, runtime: Util.RuntimeOptions): ModifyUIProxyAccountPasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyUIProxyAccountPassword',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyUIProxyAccountPassword(request: ModifyUIProxyAccountPasswordRequest): ModifyUIProxyAccountPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyUIProxyAccountPasswordWithOptions(request, runtime);
}

model ModifyUpgradeToHasForHbaseRequest {
  clientToken?: string(name='ClientToken'),
  clusterId?: string(name='ClusterId'),
  hasPassword?: string(name='HasPassword'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model ModifyUpgradeToHasForHbaseResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyUpgradeToHasForHbaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyUpgradeToHasForHbaseResponseBody(name='body'),
}

async function modifyUpgradeToHasForHbaseWithOptions(request: ModifyUpgradeToHasForHbaseRequest, runtime: Util.RuntimeOptions): ModifyUpgradeToHasForHbaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.hasPassword)) {
    query['HasPassword'] = request.hasPassword;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyUpgradeToHasForHbase',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyUpgradeToHasForHbase(request: ModifyUpgradeToHasForHbaseRequest): ModifyUpgradeToHasForHbaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyUpgradeToHasForHbaseWithOptions(request, runtime);
}

model MultimodAddComponentsRequest {
  clusterId?: string(name='ClusterId'),
  components?: string(name='Components'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model MultimodAddComponentsResponseBody = {
  requestId?: string(name='RequestId'),
}

model MultimodAddComponentsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MultimodAddComponentsResponseBody(name='body'),
}

async function multimodAddComponentsWithOptions(request: MultimodAddComponentsRequest, runtime: Util.RuntimeOptions): MultimodAddComponentsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.components)) {
    query['Components'] = request.components;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MultimodAddComponents',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function multimodAddComponents(request: MultimodAddComponentsRequest): MultimodAddComponentsResponse {
  var runtime = new Util.RuntimeOptions{};
  return multimodAddComponentsWithOptions(request, runtime);
}

model OpenBackupRequest {
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
}

model OpenBackupResponseBody = {
  requestId?: string(name='RequestId'),
}

model OpenBackupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OpenBackupResponseBody(name='body'),
}

async function openBackupWithOptions(request: OpenBackupRequest, runtime: Util.RuntimeOptions): OpenBackupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenBackup',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openBackup(request: OpenBackupRequest): OpenBackupResponse {
  var runtime = new Util.RuntimeOptions{};
  return openBackupWithOptions(request, runtime);
}

model QueryHBaseHaDBRequest {
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model QueryHBaseHaDBResponseBody = {
  clusterList?: {
    cluster?: [ 
    {
      activeName?: string(name='ActiveName'),
      bdsName?: string(name='BdsName'),
      haName?: string(name='HaName'),
      standbyName?: string(name='StandbyName'),
    }
  ](name='Cluster')
  }(name='ClusterList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model QueryHBaseHaDBResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryHBaseHaDBResponseBody(name='body'),
}

async function queryHBaseHaDBWithOptions(request: QueryHBaseHaDBRequest, runtime: Util.RuntimeOptions): QueryHBaseHaDBResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryHBaseHaDB',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryHBaseHaDB(request: QueryHBaseHaDBRequest): QueryHBaseHaDBResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryHBaseHaDBWithOptions(request, runtime);
}

model QuerySparkRelateHBaseRequest {
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model QuerySparkRelateHBaseResponseBody = {
  clusterList?: {
    cluster?: [ 
    {
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      clusterType?: string(name='ClusterType'),
      coreDiskType?: string(name='CoreDiskType'),
      coreInstanceQuantity?: int32(name='CoreInstanceQuantity'),
      createTime?: string(name='CreateTime'),
      dbType?: string(name='DbType'),
      expireTime?: string(name='ExpireTime'),
      isRelated?: boolean(name='IsRelated'),
      lockMode?: string(name='LockMode'),
      mainVersion?: string(name='MainVersion'),
      netType?: string(name='NetType'),
      payType?: string(name='PayType'),
      reason?: string(name='Reason'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      userId?: string(name='UserId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Cluster')
  }(name='ClusterList'),
  requestId?: string(name='RequestId'),
}

model QuerySparkRelateHBaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySparkRelateHBaseResponseBody(name='body'),
}

async function querySparkRelateHBaseWithOptions(request: QuerySparkRelateHBaseRequest, runtime: Util.RuntimeOptions): QuerySparkRelateHBaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySparkRelateHBase',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySparkRelateHBase(request: QuerySparkRelateHBaseRequest): QuerySparkRelateHBaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySparkRelateHBaseWithOptions(request, runtime);
}

model QueryXpackRelatedDBRequest {
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  relateDbType?: string(name='RelateDbType'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model QueryXpackRelatedDBResponseBody = {
  clusterList?: {
    cluster?: [ 
    {
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      DBType?: string(name='DBType'),
      DBVersion?: string(name='DBVersion'),
      isRelated?: boolean(name='IsRelated'),
      status?: string(name='Status'),
    }
  ](name='Cluster')
  }(name='ClusterList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model QueryXpackRelatedDBResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryXpackRelatedDBResponseBody(name='body'),
}

async function queryXpackRelatedDBWithOptions(request: QueryXpackRelatedDBRequest, runtime: Util.RuntimeOptions): QueryXpackRelatedDBResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.relateDbType)) {
    query['RelateDbType'] = request.relateDbType;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryXpackRelatedDB',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryXpackRelatedDB(request: QueryXpackRelatedDBRequest): QueryXpackRelatedDBResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryXpackRelatedDBWithOptions(request, runtime);
}

model RelateDbForHBaseHaRequest {
  clusterId?: string(name='ClusterId'),
  haActive?: string(name='HaActive'),
  haActiveClusterKey?: string(name='HaActiveClusterKey'),
  haActiveDBType?: string(name='HaActiveDBType'),
  haActiveHbaseFsDir?: string(name='HaActiveHbaseFsDir'),
  haActiveHdfsUri?: string(name='HaActiveHdfsUri'),
  haActivePassword?: string(name='HaActivePassword'),
  haActiveUser?: string(name='HaActiveUser'),
  haActiveVersion?: string(name='HaActiveVersion'),
  haMigrateType?: string(name='HaMigrateType'),
  haStandby?: string(name='HaStandby'),
  haStandbyClusterKey?: string(name='HaStandbyClusterKey'),
  haStandbyDBType?: string(name='HaStandbyDBType'),
  haStandbyHbaseFsDir?: string(name='HaStandbyHbaseFsDir'),
  haStandbyHdfsUri?: string(name='HaStandbyHdfsUri'),
  haStandbyPassword?: string(name='HaStandbyPassword'),
  haStandbyUser?: string(name='HaStandbyUser'),
  haStandbyVersion?: string(name='HaStandbyVersion'),
  haTables?: string(name='HaTables'),
  isActiveStandard?: boolean(name='IsActiveStandard'),
  isStandbyStandard?: boolean(name='IsStandbyStandard'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model RelateDbForHBaseHaResponseBody = {
  requestId?: string(name='RequestId'),
}

model RelateDbForHBaseHaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RelateDbForHBaseHaResponseBody(name='body'),
}

async function relateDbForHBaseHaWithOptions(request: RelateDbForHBaseHaRequest, runtime: Util.RuntimeOptions): RelateDbForHBaseHaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.haActive)) {
    query['HaActive'] = request.haActive;
  }
  if (!Util.isUnset(request.haActiveClusterKey)) {
    query['HaActiveClusterKey'] = request.haActiveClusterKey;
  }
  if (!Util.isUnset(request.haActiveDBType)) {
    query['HaActiveDBType'] = request.haActiveDBType;
  }
  if (!Util.isUnset(request.haActiveHbaseFsDir)) {
    query['HaActiveHbaseFsDir'] = request.haActiveHbaseFsDir;
  }
  if (!Util.isUnset(request.haActiveHdfsUri)) {
    query['HaActiveHdfsUri'] = request.haActiveHdfsUri;
  }
  if (!Util.isUnset(request.haActivePassword)) {
    query['HaActivePassword'] = request.haActivePassword;
  }
  if (!Util.isUnset(request.haActiveUser)) {
    query['HaActiveUser'] = request.haActiveUser;
  }
  if (!Util.isUnset(request.haActiveVersion)) {
    query['HaActiveVersion'] = request.haActiveVersion;
  }
  if (!Util.isUnset(request.haMigrateType)) {
    query['HaMigrateType'] = request.haMigrateType;
  }
  if (!Util.isUnset(request.haStandby)) {
    query['HaStandby'] = request.haStandby;
  }
  if (!Util.isUnset(request.haStandbyClusterKey)) {
    query['HaStandbyClusterKey'] = request.haStandbyClusterKey;
  }
  if (!Util.isUnset(request.haStandbyDBType)) {
    query['HaStandbyDBType'] = request.haStandbyDBType;
  }
  if (!Util.isUnset(request.haStandbyHbaseFsDir)) {
    query['HaStandbyHbaseFsDir'] = request.haStandbyHbaseFsDir;
  }
  if (!Util.isUnset(request.haStandbyHdfsUri)) {
    query['HaStandbyHdfsUri'] = request.haStandbyHdfsUri;
  }
  if (!Util.isUnset(request.haStandbyPassword)) {
    query['HaStandbyPassword'] = request.haStandbyPassword;
  }
  if (!Util.isUnset(request.haStandbyUser)) {
    query['HaStandbyUser'] = request.haStandbyUser;
  }
  if (!Util.isUnset(request.haStandbyVersion)) {
    query['HaStandbyVersion'] = request.haStandbyVersion;
  }
  if (!Util.isUnset(request.haTables)) {
    query['HaTables'] = request.haTables;
  }
  if (!Util.isUnset(request.isActiveStandard)) {
    query['IsActiveStandard'] = request.isActiveStandard;
  }
  if (!Util.isUnset(request.isStandbyStandard)) {
    query['IsStandbyStandard'] = request.isStandbyStandard;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RelateDbForHBaseHa',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function relateDbForHBaseHa(request: RelateDbForHBaseHaRequest): RelateDbForHBaseHaResponse {
  var runtime = new Util.RuntimeOptions{};
  return relateDbForHBaseHaWithOptions(request, runtime);
}

model ReleasePublicNetworkAddressRequest {
  clusterId?: string(name='ClusterId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ReleasePublicNetworkAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleasePublicNetworkAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReleasePublicNetworkAddressResponseBody(name='body'),
}

async function releasePublicNetworkAddressWithOptions(request: ReleasePublicNetworkAddressRequest, runtime: Util.RuntimeOptions): ReleasePublicNetworkAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleasePublicNetworkAddress',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function releasePublicNetworkAddress(request: ReleasePublicNetworkAddressRequest): ReleasePublicNetworkAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return releasePublicNetworkAddressWithOptions(request, runtime);
}

model ReleaseSubscriptionRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  subscriptionId?: string(name='SubscriptionId'),
}

model ReleaseSubscriptionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseSubscriptionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReleaseSubscriptionResponseBody(name='body'),
}

async function releaseSubscriptionWithOptions(request: ReleaseSubscriptionRequest, runtime: Util.RuntimeOptions): ReleaseSubscriptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.subscriptionId)) {
    query['SubscriptionId'] = request.subscriptionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseSubscription',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function releaseSubscription(request: ReleaseSubscriptionRequest): ReleaseSubscriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseSubscriptionWithOptions(request, runtime);
}

model RenewClusterRequest {
  clusterId?: string(name='ClusterId'),
  duration?: int32(name='Duration'),
  ownerId?: long(name='OwnerId'),
  pricingCycle?: string(name='PricingCycle'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RenewClusterResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model RenewClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RenewClusterResponseBody(name='body'),
}

async function renewClusterWithOptions(request: RenewClusterRequest, runtime: Util.RuntimeOptions): RenewClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RenewCluster',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function renewCluster(request: RenewClusterRequest): RenewClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return renewClusterWithOptions(request, runtime);
}

model ResizeClusterRequest {
  clientToken?: string(name='ClientToken'),
  cloudType?: string(name='CloudType'),
  clusterId?: string(name='ClusterId'),
  coldStorageSize?: string(name='ColdStorageSize'),
  coreDiskQuantity?: string(name='CoreDiskQuantity'),
  coreDiskSize?: string(name='CoreDiskSize'),
  coreDiskType?: string(name='CoreDiskType'),
  coreInstanceQuantity?: string(name='CoreInstanceQuantity'),
  coreInstanceType?: string(name='CoreInstanceType'),
  engine?: string(name='Engine'),
  isColdStorage?: string(name='IsColdStorage'),
  payType?: string(name='PayType'),
  regionId?: string(name='RegionId'),
  upgradeType?: string(name='UpgradeType'),
  zoneId?: string(name='ZoneId'),
}

model ResizeClusterResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResizeClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResizeClusterResponseBody(name='body'),
}

async function resizeClusterWithOptions(request: ResizeClusterRequest, runtime: Util.RuntimeOptions): ResizeClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.cloudType)) {
    query['CloudType'] = request.cloudType;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.coldStorageSize)) {
    query['ColdStorageSize'] = request.coldStorageSize;
  }
  if (!Util.isUnset(request.coreDiskQuantity)) {
    query['CoreDiskQuantity'] = request.coreDiskQuantity;
  }
  if (!Util.isUnset(request.coreDiskSize)) {
    query['CoreDiskSize'] = request.coreDiskSize;
  }
  if (!Util.isUnset(request.coreDiskType)) {
    query['CoreDiskType'] = request.coreDiskType;
  }
  if (!Util.isUnset(request.coreInstanceQuantity)) {
    query['CoreInstanceQuantity'] = request.coreInstanceQuantity;
  }
  if (!Util.isUnset(request.coreInstanceType)) {
    query['CoreInstanceType'] = request.coreInstanceType;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.isColdStorage)) {
    query['IsColdStorage'] = request.isColdStorage;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.upgradeType)) {
    query['UpgradeType'] = request.upgradeType;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResizeCluster',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resizeCluster(request: ResizeClusterRequest): ResizeClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return resizeClusterWithOptions(request, runtime);
}

model SparkRelateHBaseRequest {
  clusterId?: string(name='ClusterId'),
  HBaseClusterIds?: string(name='HBaseClusterIds'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model SparkRelateHBaseResponseBody = {
  requestId?: string(name='RequestId'),
}

model SparkRelateHBaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SparkRelateHBaseResponseBody(name='body'),
}

async function sparkRelateHBaseWithOptions(request: SparkRelateHBaseRequest, runtime: Util.RuntimeOptions): SparkRelateHBaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.HBaseClusterIds)) {
    query['HBaseClusterIds'] = request.HBaseClusterIds;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SparkRelateHBase',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sparkRelateHBase(request: SparkRelateHBaseRequest): SparkRelateHBaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return sparkRelateHBaseWithOptions(request, runtime);
}

model TagResourcesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpgradeMinorVersionRequest {
  clientToken?: string(name='ClientToken'),
  clusterId?: string(name='ClusterId'),
  components?: string(name='Components'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  upgradeVersion?: string(name='UpgradeVersion'),
  zoneId?: string(name='ZoneId'),
}

model UpgradeMinorVersionResponseBody = {
  newVersion?: string(name='NewVersion'),
  oldVersion?: string(name='OldVersion'),
  requestId?: string(name='RequestId'),
}

model UpgradeMinorVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpgradeMinorVersionResponseBody(name='body'),
}

async function upgradeMinorVersionWithOptions(request: UpgradeMinorVersionRequest, runtime: Util.RuntimeOptions): UpgradeMinorVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.components)) {
    query['Components'] = request.components;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.upgradeVersion)) {
    query['UpgradeVersion'] = request.upgradeVersion;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeMinorVersion',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradeMinorVersion(request: UpgradeMinorVersionRequest): UpgradeMinorVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeMinorVersionWithOptions(request, runtime);
}

model XpackRelateDBRequest {
  clusterId?: string(name='ClusterId'),
  dbClusterIds?: string(name='DbClusterIds'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  relateDbType?: string(name='RelateDbType'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model XpackRelateDBResponseBody = {
  requestId?: string(name='RequestId'),
}

model XpackRelateDBResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: XpackRelateDBResponseBody(name='body'),
}

async function xpackRelateDBWithOptions(request: XpackRelateDBRequest, runtime: Util.RuntimeOptions): XpackRelateDBResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.dbClusterIds)) {
    query['DbClusterIds'] = request.dbClusterIds;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.relateDbType)) {
    query['RelateDbType'] = request.relateDbType;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'XpackRelateDB',
    version = '2017-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function xpackRelateDB(request: XpackRelateDBRequest): XpackRelateDBResponse {
  var runtime = new Util.RuntimeOptions{};
  return xpackRelateDBWithOptions(request, runtime);
}

