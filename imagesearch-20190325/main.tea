/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('imagesearch', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddImageRequest {
  categoryId?: int32(name='CategoryId'),
  crop?: boolean(name='Crop'),
  customContent?: string(name='CustomContent'),
  instanceName?: string(name='InstanceName'),
  intAttr?: int32(name='IntAttr'),
  picContent?: string(name='PicContent'),
  picName?: string(name='PicName'),
  productId?: string(name='ProductId'),
  region?: string(name='Region'),
  strAttr?: string(name='StrAttr'),
}

model AddImageResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  picInfo?: {
    categoryId?: int32(name='CategoryId'),
    region?: string(name='Region'),
  }(name='PicInfo'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddImageResponseBody(name='body'),
}

async function addImage(request: AddImageRequest): AddImageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addImageWithOptions(request, headers, runtime);
}

async function addImageWithOptions(request: AddImageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddImageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.categoryId)) {
    body['CategoryId'] = request.categoryId;
  }
  if (!Util.isUnset(request.crop)) {
    body['Crop'] = request.crop;
  }
  if (!Util.isUnset(request.customContent)) {
    body['CustomContent'] = request.customContent;
  }
  if (!Util.isUnset(request.instanceName)) {
    body['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.intAttr)) {
    body['IntAttr'] = request.intAttr;
  }
  if (!Util.isUnset(request.picContent)) {
    body['PicContent'] = request.picContent;
  }
  if (!Util.isUnset(request.picName)) {
    body['PicName'] = request.picName;
  }
  if (!Util.isUnset(request.productId)) {
    body['ProductId'] = request.productId;
  }
  if (!Util.isUnset(request.region)) {
    body['Region'] = request.region;
  }
  if (!Util.isUnset(request.strAttr)) {
    body['StrAttr'] = request.strAttr;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddImage',
    version = '2019-03-25',
    protocol = 'HTTPS',
    pathname = `/v2/image/add`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteImageRequest {
  instanceName?: string(name='InstanceName'),
  picName?: string(name='PicName'),
  productId?: string(name='ProductId'),
}

model DeleteImageResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteImageResponseBody(name='body'),
}

async function deleteImage(request: DeleteImageRequest): DeleteImageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteImageWithOptions(request, headers, runtime);
}

async function deleteImageWithOptions(request: DeleteImageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteImageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceName)) {
    body['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.picName)) {
    body['PicName'] = request.picName;
  }
  if (!Util.isUnset(request.productId)) {
    body['ProductId'] = request.productId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteImage',
    version = '2019-03-25',
    protocol = 'HTTPS',
    pathname = `/v2/image/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model SearchImageRequest {
  categoryId?: int32(name='CategoryId'),
  crop?: boolean(name='Crop'),
  filter?: string(name='Filter'),
  instanceName?: string(name='InstanceName'),
  num?: int32(name='Num'),
  picContent?: string(name='PicContent'),
  picName?: string(name='PicName'),
  productId?: string(name='ProductId'),
  region?: string(name='Region'),
  start?: int32(name='Start'),
  type?: string(name='Type'),
}

model SearchImageResponseBody = {
  auctions?: [ 
    {
      categoryId?: int32(name='CategoryId'),
      customContent?: string(name='CustomContent'),
      intAttr?: int32(name='IntAttr'),
      picName?: string(name='PicName'),
      productId?: string(name='ProductId'),
      sortExprValues?: string(name='SortExprValues'),
      strAttr?: string(name='StrAttr'),
    }
  ](name='Auctions'),
  code?: int32(name='Code'),
  head?: {
    docsFound?: int32(name='DocsFound'),
    docsReturn?: int32(name='DocsReturn'),
    searchTime?: int32(name='SearchTime'),
  }(name='Head'),
  msg?: string(name='Msg'),
  picInfo?: {
    allCategories?: [ 
      {
        id?: int32(name='Id'),
        name?: string(name='Name'),
      }
    ](name='AllCategories'),
    categoryId?: int32(name='CategoryId'),
    region?: string(name='Region'),
  }(name='PicInfo'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SearchImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchImageResponseBody(name='body'),
}

async function searchImage(request: SearchImageRequest): SearchImageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchImageWithOptions(request, headers, runtime);
}

async function searchImageWithOptions(request: SearchImageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchImageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.categoryId)) {
    body['CategoryId'] = request.categoryId;
  }
  if (!Util.isUnset(request.crop)) {
    body['Crop'] = request.crop;
  }
  if (!Util.isUnset(request.filter)) {
    body['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.instanceName)) {
    body['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.num)) {
    body['Num'] = request.num;
  }
  if (!Util.isUnset(request.picContent)) {
    body['PicContent'] = request.picContent;
  }
  if (!Util.isUnset(request.picName)) {
    body['PicName'] = request.picName;
  }
  if (!Util.isUnset(request.productId)) {
    body['ProductId'] = request.productId;
  }
  if (!Util.isUnset(request.region)) {
    body['Region'] = request.region;
  }
  if (!Util.isUnset(request.start)) {
    body['Start'] = request.start;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchImage',
    version = '2019-03-25',
    protocol = 'HTTPS',
    pathname = `/v2/image/search`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

