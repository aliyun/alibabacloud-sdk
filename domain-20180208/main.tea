/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('domain', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AcceptDemandRequest {
  bizId?: string(name='BizId'),
  message?: string(name='Message'),
}

model AcceptDemandResponseBody = {
  bindUrl?: string(name='BindUrl'),
  requestId?: string(name='RequestId'),
}

model AcceptDemandResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AcceptDemandResponseBody(name='body'),
}

async function acceptDemandWithOptions(request: AcceptDemandRequest, runtime: Util.RuntimeOptions): AcceptDemandResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.message)) {
    query['Message'] = request.message;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AcceptDemand',
    version = '2018-02-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function acceptDemand(request: AcceptDemandRequest): AcceptDemandResponse {
  var runtime = new Util.RuntimeOptions{};
  return acceptDemandWithOptions(request, runtime);
}

model BidDomainRequest {
  auctionId?: string(name='AuctionId'),
  currency?: string(name='Currency'),
  maxBid?: float(name='MaxBid'),
}

model BidDomainResponseBody = {
  auctionId?: string(name='AuctionId'),
  requestId?: string(name='RequestId'),
}

model BidDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BidDomainResponseBody(name='body'),
}

async function bidDomainWithOptions(request: BidDomainRequest, runtime: Util.RuntimeOptions): BidDomainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.auctionId)) {
    body['AuctionId'] = request.auctionId;
  }
  if (!Util.isUnset(request.currency)) {
    body['Currency'] = request.currency;
  }
  if (!Util.isUnset(request.maxBid)) {
    body['MaxBid'] = request.maxBid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BidDomain',
    version = '2018-02-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function bidDomain(request: BidDomainRequest): BidDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return bidDomainWithOptions(request, runtime);
}

model ChangeAuctionRequest {
  auctionList?: [ 
    {
      bidRecords?: [ 
        {
          createTime?: string(name='CreateTime'),
          price?: float(name='Price'),
          userId?: string(name='UserId'),
        }
      ](name='BidRecords'),
      domainName?: string(name='DomainName'),
      endTime?: string(name='EndTime'),
      isReserve?: int32(name='IsReserve'),
      reservePrice?: float(name='ReservePrice'),
      reserveRange?: string(name='ReserveRange'),
      status?: string(name='Status'),
      timeLeft?: long(name='TimeLeft'),
      winner?: string(name='Winner'),
      winnerPrice?: float(name='WinnerPrice'),
    }
  ](name='AuctionList'),
}

model ChangeAuctionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ChangeAuctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangeAuctionResponseBody(name='body'),
}

async function changeAuctionWithOptions(request: ChangeAuctionRequest, runtime: Util.RuntimeOptions): ChangeAuctionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.auctionList)) {
    body['AuctionList'] = request.auctionList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ChangeAuction',
    version = '2018-02-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function changeAuction(request: ChangeAuctionRequest): ChangeAuctionResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeAuctionWithOptions(request, runtime);
}

model CheckDomainStatusRequest {
  domain?: string(name='Domain'),
}

model CheckDomainStatusResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  module?: {
    deadDate?: long(name='DeadDate'),
    domain?: string(name='Domain'),
    endTime?: long(name='EndTime'),
    price?: float(name='Price'),
    regDate?: long(name='RegDate'),
  }(name='Module'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckDomainStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckDomainStatusResponseBody(name='body'),
}

async function checkDomainStatusWithOptions(request: CheckDomainStatusRequest, runtime: Util.RuntimeOptions): CheckDomainStatusResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckDomainStatus',
    version = '2018-02-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkDomainStatus(request: CheckDomainStatusRequest): CheckDomainStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkDomainStatusWithOptions(request, runtime);
}

model CreateFixedPriceDemandOrderRequest {
  code?: string(name='Code'),
  contactId?: string(name='ContactId'),
  domain?: string(name='Domain'),
  source?: string(name='Source'),
}

model CreateFixedPriceDemandOrderResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  module?: {
    domain?: string(name='Domain'),
    orderNo?: string(name='OrderNo'),
    price?: long(name='Price'),
  }(name='Module'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateFixedPriceDemandOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFixedPriceDemandOrderResponseBody(name='body'),
}

async function createFixedPriceDemandOrderWithOptions(request: CreateFixedPriceDemandOrderRequest, runtime: Util.RuntimeOptions): CreateFixedPriceDemandOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.code)) {
    query['Code'] = request.code;
  }
  if (!Util.isUnset(request.contactId)) {
    query['ContactId'] = request.contactId;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateFixedPriceDemandOrder',
    version = '2018-02-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFixedPriceDemandOrder(request: CreateFixedPriceDemandOrderRequest): CreateFixedPriceDemandOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFixedPriceDemandOrderWithOptions(request, runtime);
}

model FailDemandRequest {
  bizId?: string(name='BizId'),
  message?: string(name='Message'),
}

model FailDemandResponseBody = {
  requestId?: string(name='RequestId'),
}

model FailDemandResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FailDemandResponseBody(name='body'),
}

async function failDemandWithOptions(request: FailDemandRequest, runtime: Util.RuntimeOptions): FailDemandResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.message)) {
    query['Message'] = request.message;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FailDemand',
    version = '2018-02-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function failDemand(request: FailDemandRequest): FailDemandResponse {
  var runtime = new Util.RuntimeOptions{};
  return failDemandWithOptions(request, runtime);
}

model FinishDemandRequest {
  bizId?: string(name='BizId'),
  message?: string(name='Message'),
}

model FinishDemandResponseBody = {
  requestId?: string(name='RequestId'),
}

model FinishDemandResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FinishDemandResponseBody(name='body'),
}

async function finishDemandWithOptions(request: FinishDemandRequest, runtime: Util.RuntimeOptions): FinishDemandResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.message)) {
    query['Message'] = request.message;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FinishDemand',
    version = '2018-02-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function finishDemand(request: FinishDemandRequest): FinishDemandResponse {
  var runtime = new Util.RuntimeOptions{};
  return finishDemandWithOptions(request, runtime);
}

model GetIntlDomainDownloadUrlResponseBody = {
  allowRetry?: boolean(name='AllowRetry'),
  appName?: string(name='AppName'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorArgs?: [ any ](name='ErrorArgs'),
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  url?: string(name='Url'),
}

model GetIntlDomainDownloadUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetIntlDomainDownloadUrlResponseBody(name='body'),
}

async function getIntlDomainDownloadUrlWithOptions(runtime: Util.RuntimeOptions): GetIntlDomainDownloadUrlResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetIntlDomainDownloadUrl',
    version = '2018-02-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getIntlDomainDownloadUrl(): GetIntlDomainDownloadUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getIntlDomainDownloadUrlWithOptions(runtime);
}

model GetReserveDomainUrlResponseBody = {
  requestId?: string(name='RequestId'),
  url?: string(name='Url'),
}

model GetReserveDomainUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetReserveDomainUrlResponseBody(name='body'),
}

async function getReserveDomainUrlWithOptions(runtime: Util.RuntimeOptions): GetReserveDomainUrlResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetReserveDomainUrl',
    version = '2018-02-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getReserveDomainUrl(): GetReserveDomainUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getReserveDomainUrlWithOptions(runtime);
}

model PurchaseIntlDomainRequest {
  auctionId?: string(name='AuctionId'),
  currency?: string(name='Currency'),
  price?: double(name='Price'),
}

model PurchaseIntlDomainResponseBody = {
  allowRetry?: boolean(name='AllowRetry'),
  appName?: string(name='AppName'),
  auctionId?: string(name='AuctionId'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorArgs?: [ any ](name='ErrorArgs'),
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PurchaseIntlDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PurchaseIntlDomainResponseBody(name='body'),
}

async function purchaseIntlDomainWithOptions(request: PurchaseIntlDomainRequest, runtime: Util.RuntimeOptions): PurchaseIntlDomainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.auctionId)) {
    body['AuctionId'] = request.auctionId;
  }
  if (!Util.isUnset(request.currency)) {
    body['Currency'] = request.currency;
  }
  if (!Util.isUnset(request.price)) {
    body['Price'] = request.price;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PurchaseIntlDomain',
    version = '2018-02-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function purchaseIntlDomain(request: PurchaseIntlDomainRequest): PurchaseIntlDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return purchaseIntlDomainWithOptions(request, runtime);
}

model QueryAuctionDetailRequest {
  auctionId?: string(name='AuctionId'),
}

model QueryAuctionDetailResponseBody = {
  auctionEndTime?: long(name='AuctionEndTime'),
  auctionId?: string(name='AuctionId'),
  bookEndTime?: long(name='BookEndTime'),
  bookedPartner?: string(name='BookedPartner'),
  currency?: string(name='Currency'),
  deliveryTime?: long(name='DeliveryTime'),
  domainName?: string(name='DomainName'),
  domainType?: string(name='DomainType'),
  failCode?: string(name='FailCode'),
  highBid?: float(name='HighBid'),
  highBidder?: string(name='HighBidder'),
  nextValidBid?: float(name='NextValidBid'),
  partnerType?: string(name='PartnerType'),
  payEndTime?: long(name='PayEndTime'),
  payPrice?: float(name='PayPrice'),
  payStatus?: string(name='PayStatus'),
  produceStatus?: string(name='ProduceStatus'),
  requestId?: string(name='RequestId'),
  reserveMet?: boolean(name='ReserveMet'),
  reservePrice?: float(name='ReservePrice'),
  status?: string(name='Status'),
  transferInPrice?: float(name='TransferInPrice'),
  yourCurrentBid?: float(name='YourCurrentBid'),
  yourMaxBid?: float(name='YourMaxBid'),
}

model QueryAuctionDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryAuctionDetailResponseBody(name='body'),
}

async function queryAuctionDetailWithOptions(request: QueryAuctionDetailRequest, runtime: Util.RuntimeOptions): QueryAuctionDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.auctionId)) {
    body['AuctionId'] = request.auctionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryAuctionDetail',
    version = '2018-02-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryAuctionDetail(request: QueryAuctionDetailRequest): QueryAuctionDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAuctionDetailWithOptions(request, runtime);
}

model QueryAuctionsRequest {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
}

model QueryAuctionsResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: [ 
    {
      auctionEndTime?: long(name='AuctionEndTime'),
      auctionId?: string(name='AuctionId'),
      bookEndTime?: long(name='BookEndTime'),
      bookedPartner?: string(name='BookedPartner'),
      currency?: string(name='Currency'),
      deliveryTime?: long(name='DeliveryTime'),
      domainName?: string(name='DomainName'),
      domainType?: string(name='DomainType'),
      failCode?: string(name='FailCode'),
      highBid?: float(name='HighBid'),
      highBidder?: string(name='HighBidder'),
      nextValidBid?: float(name='NextValidBid'),
      partnerType?: string(name='PartnerType'),
      payEndTime?: long(name='PayEndTime'),
      payPrice?: float(name='PayPrice'),
      payStatus?: string(name='PayStatus'),
      produceStatus?: string(name='ProduceStatus'),
      reserveMax?: long(name='ReserveMax'),
      reserveMet?: boolean(name='ReserveMet'),
      reserveMin?: long(name='ReserveMin'),
      reservePrice?: long(name='ReservePrice'),
      status?: string(name='Status'),
      transferInPrice?: float(name='TransferInPrice'),
      yourCurrentBid?: float(name='YourCurrentBid'),
      yourMaxBid?: float(name='YourMaxBid'),
    }
  ](name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryAuctionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryAuctionsResponseBody(name='body'),
}

async function queryAuctionsWithOptions(request: QueryAuctionsRequest, runtime: Util.RuntimeOptions): QueryAuctionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.currentPage)) {
    body['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryAuctions',
    version = '2018-02-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryAuctions(request: QueryAuctionsRequest): QueryAuctionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAuctionsWithOptions(request, runtime);
}

model QueryBidRecordsRequest {
  auctionId?: string(name='AuctionId'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
}

model QueryBidRecordsResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: [ 
    {
      bid?: float(name='Bid'),
      bidTime?: long(name='BidTime'),
      bidder?: string(name='Bidder'),
      currency?: string(name='Currency'),
      domainName?: string(name='DomainName'),
    }
  ](name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryBidRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryBidRecordsResponseBody(name='body'),
}

async function queryBidRecordsWithOptions(request: QueryBidRecordsRequest, runtime: Util.RuntimeOptions): QueryBidRecordsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.auctionId)) {
    body['AuctionId'] = request.auctionId;
  }
  if (!Util.isUnset(request.currentPage)) {
    body['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryBidRecords',
    version = '2018-02-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryBidRecords(request: QueryBidRecordsRequest): QueryBidRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryBidRecordsWithOptions(request, runtime);
}

model QueryBookingDomainInfoRequest {
  domainName?: string(name='DomainName'),
}

model QueryBookingDomainInfoResponseBody = {
  auctionId?: int32(name='AuctionId'),
  bookEndTime?: long(name='BookEndTime'),
  currency?: string(name='Currency'),
  maxBid?: float(name='MaxBid'),
  partnerType?: string(name='PartnerType'),
  requestId?: string(name='RequestId'),
  transferInPrice?: float(name='TransferInPrice'),
}

model QueryBookingDomainInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryBookingDomainInfoResponseBody(name='body'),
}

async function queryBookingDomainInfoWithOptions(request: QueryBookingDomainInfoRequest, runtime: Util.RuntimeOptions): QueryBookingDomainInfoResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.domainName)) {
    body['DomainName'] = request.domainName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryBookingDomainInfo',
    version = '2018-02-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryBookingDomainInfo(request: QueryBookingDomainInfoRequest): QueryBookingDomainInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryBookingDomainInfoWithOptions(request, runtime);
}

model QueryBrokerDemandRequest {
  bizId?: string(name='BizId'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
}

model QueryBrokerDemandResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: [ 
    {
      auditStatus?: int32(name='AuditStatus'),
      bargainSellerMobile?: string(name='BargainSellerMobile'),
      bargainSellerPrice?: float(name='BargainSellerPrice'),
      bizId?: string(name='BizId'),
      demandDomain?: string(name='DemandDomain'),
      demandPrice?: float(name='DemandPrice'),
      description?: string(name='Description'),
      mobile?: string(name='Mobile'),
      orderType?: int32(name='OrderType'),
      partnerDomain?: string(name='PartnerDomain'),
      payDomain?: string(name='PayDomain'),
      payPrice?: float(name='PayPrice'),
      payTime?: long(name='PayTime'),
      produceType?: int32(name='ProduceType'),
      publishTime?: long(name='PublishTime'),
      servicePayPrice?: float(name='ServicePayPrice'),
      status?: string(name='Status'),
    }
  ](name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryBrokerDemandResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryBrokerDemandResponseBody(name='body'),
}

async function queryBrokerDemandWithOptions(request: QueryBrokerDemandRequest, runtime: Util.RuntimeOptions): QueryBrokerDemandResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryBrokerDemand',
    version = '2018-02-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryBrokerDemand(request: QueryBrokerDemandRequest): QueryBrokerDemandResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryBrokerDemandWithOptions(request, runtime);
}

model QueryBrokerDemandRecordRequest {
  bizId?: string(name='BizId'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
}

model QueryBrokerDemandRecordResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    brokerDemandRecord?: [ 
    {
      bizId?: string(name='BizId'),
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
    }
  ](name='BrokerDemandRecord')
  }(name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryBrokerDemandRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryBrokerDemandRecordResponseBody(name='body'),
}

async function queryBrokerDemandRecordWithOptions(request: QueryBrokerDemandRecordRequest, runtime: Util.RuntimeOptions): QueryBrokerDemandRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryBrokerDemandRecord',
    version = '2018-02-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryBrokerDemandRecord(request: QueryBrokerDemandRecordRequest): QueryBrokerDemandRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryBrokerDemandRecordWithOptions(request, runtime);
}

model QueryDomainTransferStatusRequest {
  domainName?: string(name='DomainName'),
}

model QueryDomainTransferStatusResponseBody = {
  domainTransferStatus?: [ 
    {
      domainName?: string(name='DomainName'),
      domainStatusDescription?: string(name='DomainStatusDescription'),
    }
  ](name='DomainTransferStatus'),
  requestId?: string(name='RequestId'),
}

model QueryDomainTransferStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryDomainTransferStatusResponseBody(name='body'),
}

async function queryDomainTransferStatusWithOptions(request: QueryDomainTransferStatusRequest, runtime: Util.RuntimeOptions): QueryDomainTransferStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.domainName)) {
    body['DomainName'] = request.domainName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryDomainTransferStatus',
    version = '2018-02-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryDomainTransferStatus(request: QueryDomainTransferStatusRequest): QueryDomainTransferStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDomainTransferStatusWithOptions(request, runtime);
}

model RecordDemandRequest {
  bizId?: string(name='BizId'),
  message?: string(name='Message'),
}

model RecordDemandResponseBody = {
  requestId?: string(name='RequestId'),
}

model RecordDemandResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecordDemandResponseBody(name='body'),
}

async function recordDemandWithOptions(request: RecordDemandRequest, runtime: Util.RuntimeOptions): RecordDemandResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.message)) {
    query['Message'] = request.message;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RecordDemand',
    version = '2018-02-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recordDemand(request: RecordDemandRequest): RecordDemandResponse {
  var runtime = new Util.RuntimeOptions{};
  return recordDemandWithOptions(request, runtime);
}

model RefuseDemandRequest {
  bizId?: string(name='BizId'),
  message?: string(name='Message'),
}

model RefuseDemandResponseBody = {
  requestId?: string(name='RequestId'),
}

model RefuseDemandResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefuseDemandResponseBody(name='body'),
}

async function refuseDemandWithOptions(request: RefuseDemandRequest, runtime: Util.RuntimeOptions): RefuseDemandResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.message)) {
    query['Message'] = request.message;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefuseDemand',
    version = '2018-02-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refuseDemand(request: RefuseDemandRequest): RefuseDemandResponse {
  var runtime = new Util.RuntimeOptions{};
  return refuseDemandWithOptions(request, runtime);
}

model RequestPayDemandRequest {
  bizId?: string(name='BizId'),
  domainName?: string(name='DomainName'),
  message?: string(name='Message'),
  price?: float(name='Price'),
  produceType?: int32(name='ProduceType'),
}

model RequestPayDemandResponseBody = {
  requestId?: string(name='RequestId'),
}

model RequestPayDemandResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RequestPayDemandResponseBody(name='body'),
}

async function requestPayDemandWithOptions(request: RequestPayDemandRequest, runtime: Util.RuntimeOptions): RequestPayDemandResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.message)) {
    query['Message'] = request.message;
  }
  if (!Util.isUnset(request.price)) {
    query['Price'] = request.price;
  }
  if (!Util.isUnset(request.produceType)) {
    query['ProduceType'] = request.produceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RequestPayDemand',
    version = '2018-02-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function requestPayDemand(request: RequestPayDemandRequest): RequestPayDemandResponse {
  var runtime = new Util.RuntimeOptions{};
  return requestPayDemandWithOptions(request, runtime);
}

model ReserveDomainRequest {
  channels?: [ string ](name='Channels'),
  domainName?: string(name='DomainName'),
}

model ReserveDomainResponseBody = {
  auctionId?: string(name='AuctionId'),
  requestId?: string(name='RequestId'),
}

model ReserveDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReserveDomainResponseBody(name='body'),
}

async function reserveDomainWithOptions(request: ReserveDomainRequest, runtime: Util.RuntimeOptions): ReserveDomainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.channels)) {
    body['Channels'] = request.channels;
  }
  if (!Util.isUnset(request.domainName)) {
    body['DomainName'] = request.domainName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReserveDomain',
    version = '2018-02-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reserveDomain(request: ReserveDomainRequest): ReserveDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return reserveDomainWithOptions(request, runtime);
}

model ReserveIntlDomainRequest {
  domainName?: string(name='DomainName'),
}

model ReserveIntlDomainResponseBody = {
  allowRetry?: boolean(name='AllowRetry'),
  appName?: string(name='AppName'),
  auctionId?: string(name='AuctionId'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorArgs?: [ any ](name='ErrorArgs'),
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ReserveIntlDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReserveIntlDomainResponseBody(name='body'),
}

async function reserveIntlDomainWithOptions(request: ReserveIntlDomainRequest, runtime: Util.RuntimeOptions): ReserveIntlDomainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.domainName)) {
    body['DomainName'] = request.domainName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReserveIntlDomain',
    version = '2018-02-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reserveIntlDomain(request: ReserveIntlDomainRequest): ReserveIntlDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return reserveIntlDomainWithOptions(request, runtime);
}

