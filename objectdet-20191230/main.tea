/**
 *
 */
import Util;
import OSS;
import RPC;
import OpenPlatform;
import OSSUtil;
import FileForm;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('objectdet', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model DetectTransparentImageRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectTransparentImageAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model DetectTransparentImageResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    elements?: [ 
      {
        transparentImage?: int32(name='TransparentImage'),
      }
    ](name='Elements'),
  }(name='Data'),
}

model DetectTransparentImageResponse = {
  headers: map[string]string(name='headers'),
  body: DetectTransparentImageResponseBody(name='body'),
}

async function detectTransparentImageWithOptions(request: DetectTransparentImageRequest, runtime: Util.RuntimeOptions): DetectTransparentImageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectTransparentImage', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectTransparentImage(request: DetectTransparentImageRequest): DetectTransparentImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectTransparentImageWithOptions(request, runtime);
}

async function detectTransparentImageAdvance(request: DetectTransparentImageAdvanceRequest, runtime: Util.RuntimeOptions): DetectTransparentImageResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectTransparentImageReq = new DetectTransparentImageRequest{};
  OpenApiUtil.convert(request, detectTransparentImageReq);

  authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
  ossConfig.accessKeyId = authResponse.accessKeyId;
  ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
  ossClient = new OSS(ossConfig);

  fileObj = new FileForm.FileField{
    filename = authResponse.objectKey,
    content = request.imageURLObject,
    contentType = '',
  };
  ossHeader = new OSS.PostObjectRequest.header{
    accessKeyId = authResponse.accessKeyId,
    policy = authResponse.encodedPolicy,
    signature = authResponse.signature,
    key = authResponse.objectKey,
    file = fileObj,
    successActionStatus = '201',
  };
  uploadRequest = new OSS.PostObjectRequest{
    bucketName = authResponse.bucket,
    header = ossHeader,
  };
  ossClient.postObject(uploadRequest, ossRuntime);
  detectTransparentImageReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  var detectTransparentImageResp = detectTransparentImageWithOptions(detectTransparentImageReq, runtime);
  return detectTransparentImageResp;
}

model DetectVehicleICongestionRequest {
  imageURL?: string(name='ImageURL', description='A short description of struct'),
  roadRegions?: [ 
    {
      roadRegion?: [ 
        {
          point?: {
            x?: long(name='X'),
            y?: long(name='Y'),
          }(name='Point'),
        }
      ](name='RoadRegion'),
    }
  ](name='RoadRegions'),
  preRegionIntersectFeatures?: [ 
    {
      features?: [ string ](name='Features'),
    }
  ](name='PreRegionIntersectFeatures'),
}

model DetectVehicleICongestionShrinkRequest {
  imageURL?: string(name='ImageURL', description='A short description of struct'),
  roadRegionsShrink?: string(name='RoadRegions'),
  preRegionIntersectFeaturesShrink?: string(name='PreRegionIntersectFeatures'),
}

model DetectVehicleICongestionResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  data?: {
    elements?: [ 
      {
        boxes?: [ 
          {
            left?: long(name='Left'),
            top?: long(name='Top'),
            right?: long(name='Right'),
            bottom?: long(name='Bottom'),
          }
        ](name='Boxes'),
        score?: float(name='Score'),
        typeName?: string(name='TypeName'),
      }
    ](name='Elements'),
    regionIntersectFeatures?: [ 
      {
        features?: [ string ](name='Features'),
      }
    ](name='RegionIntersectFeatures'),
    regionIntersectMatched?: [ 
      {
        ids?: [ long ](name='Ids'),
      }
    ](name='RegionIntersectMatched'),
    regionIntersects?: [ 
      {
        ids?: [ long ](name='Ids'),
      }
    ](name='RegionIntersects'),
  }(name='Data'),
}

model DetectVehicleICongestionResponse = {
  headers: map[string]string(name='headers'),
  body: DetectVehicleICongestionResponseBody(name='body'),
}

async function detectVehicleICongestionWithOptions(tmpReq: DetectVehicleICongestionRequest, runtime: Util.RuntimeOptions): DetectVehicleICongestionResponse {
  Util.validateModel(tmpReq);
  var request = new DetectVehicleICongestionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.roadRegions)) {
    request.roadRegionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.roadRegions, 'RoadRegions', 'json');
  }
  if (!Util.isUnset(tmpReq.preRegionIntersectFeatures)) {
    request.preRegionIntersectFeaturesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.preRegionIntersectFeatures, 'PreRegionIntersectFeatures', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectVehicleICongestion', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectVehicleICongestion(request: DetectVehicleICongestionRequest): DetectVehicleICongestionResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectVehicleICongestionWithOptions(request, runtime);
}

model ClassifyVehicleInsuranceRequest {
  imageURL?: string(name='ImageURL'),
}

model ClassifyVehicleInsuranceAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model ClassifyVehicleInsuranceResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    labels?: [ 
      {
        score?: float(name='Score'),
        name?: string(name='Name'),
      }
    ](name='Labels'),
    threshold?: float(name='Threshold'),
  }(name='Data'),
}

model ClassifyVehicleInsuranceResponse = {
  headers: map[string]string(name='headers'),
  body: ClassifyVehicleInsuranceResponseBody(name='body'),
}

async function classifyVehicleInsuranceWithOptions(request: ClassifyVehicleInsuranceRequest, runtime: Util.RuntimeOptions): ClassifyVehicleInsuranceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ClassifyVehicleInsurance', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function classifyVehicleInsurance(request: ClassifyVehicleInsuranceRequest): ClassifyVehicleInsuranceResponse {
  var runtime = new Util.RuntimeOptions{};
  return classifyVehicleInsuranceWithOptions(request, runtime);
}

async function classifyVehicleInsuranceAdvance(request: ClassifyVehicleInsuranceAdvanceRequest, runtime: Util.RuntimeOptions): ClassifyVehicleInsuranceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var classifyVehicleInsuranceReq = new ClassifyVehicleInsuranceRequest{};
  OpenApiUtil.convert(request, classifyVehicleInsuranceReq);

  authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
  ossConfig.accessKeyId = authResponse.accessKeyId;
  ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
  ossClient = new OSS(ossConfig);

  fileObj = new FileForm.FileField{
    filename = authResponse.objectKey,
    content = request.imageURLObject,
    contentType = '',
  };
  ossHeader = new OSS.PostObjectRequest.header{
    accessKeyId = authResponse.accessKeyId,
    policy = authResponse.encodedPolicy,
    signature = authResponse.signature,
    key = authResponse.objectKey,
    file = fileObj,
    successActionStatus = '201',
  };
  uploadRequest = new OSS.PostObjectRequest{
    bucketName = authResponse.bucket,
    header = ossHeader,
  };
  ossClient.postObject(uploadRequest, ossRuntime);
  classifyVehicleInsuranceReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  var classifyVehicleInsuranceResp = classifyVehicleInsuranceWithOptions(classifyVehicleInsuranceReq, runtime);
  return classifyVehicleInsuranceResp;
}

model DetectIPCObjectRequest {
  imageURL?: string(name='ImageURL', description='图片URL地址'),
}

model DetectIPCObjectResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  data?: {
    elements?: [ 
      {
        type?: string(name='Type'),
        score?: float(name='Score'),
        box?: [ long ](name='Box'),
        targetRate?: float(name='TargetRate'),
      }
    ](name='Elements'),
    width?: long(name='Width'),
    height?: long(name='Height'),
  }(name='Data'),
}

model DetectIPCObjectResponse = {
  headers: map[string]string(name='headers'),
  body: DetectIPCObjectResponseBody(name='body'),
}

async function detectIPCObjectWithOptions(request: DetectIPCObjectRequest, runtime: Util.RuntimeOptions): DetectIPCObjectResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectIPCObject', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectIPCObject(request: DetectIPCObjectRequest): DetectIPCObjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectIPCObjectWithOptions(request, runtime);
}

model GetVehicleRepairPlanRequest {
  taskId?: string(name='TaskId'),
  carNumberImage?: string(name='CarNumberImage'),
  vinCodeImage?: string(name='VinCodeImage'),
}

model GetVehicleRepairPlanResponseBody = {
  httpCode?: int32(name='HttpCode'),
  requestId?: string(name='RequestId'),
  data?: {
    repairParts?: [ 
      {
        relationType?: string(name='RelationType'),
        partsStdCode?: string(name='PartsStdCode'),
        partNameMatch?: boolean(name='PartNameMatch'),
        repairFee?: string(name='RepairFee'),
        outStandardPartsName?: string(name='OutStandardPartsName'),
        partsStdName?: string(name='PartsStdName'),
        repairTypeName?: string(name='RepairTypeName'),
        repairType?: string(name='RepairType'),
        oeMatch?: boolean(name='OeMatch'),
        outStandardPartsId?: string(name='OutStandardPartsId'),
        garageType?: string(name='GarageType'),
      }
    ](name='RepairParts'),
    frameNo?: string(name='FrameNo'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetVehicleRepairPlanResponse = {
  headers: map[string]string(name='headers'),
  body: GetVehicleRepairPlanResponseBody(name='body'),
}

async function getVehicleRepairPlanWithOptions(request: GetVehicleRepairPlanRequest, runtime: Util.RuntimeOptions): GetVehicleRepairPlanResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetVehicleRepairPlan', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getVehicleRepairPlan(request: GetVehicleRepairPlanRequest): GetVehicleRepairPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVehicleRepairPlanWithOptions(request, runtime);
}

model DetectWhiteBaseImageRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectWhiteBaseImageAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model DetectWhiteBaseImageResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    elements?: [ 
      {
        whiteBase?: int32(name='WhiteBase'),
      }
    ](name='Elements'),
  }(name='Data'),
}

model DetectWhiteBaseImageResponse = {
  headers: map[string]string(name='headers'),
  body: DetectWhiteBaseImageResponseBody(name='body'),
}

async function detectWhiteBaseImageWithOptions(request: DetectWhiteBaseImageRequest, runtime: Util.RuntimeOptions): DetectWhiteBaseImageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectWhiteBaseImage', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectWhiteBaseImage(request: DetectWhiteBaseImageRequest): DetectWhiteBaseImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectWhiteBaseImageWithOptions(request, runtime);
}

async function detectWhiteBaseImageAdvance(request: DetectWhiteBaseImageAdvanceRequest, runtime: Util.RuntimeOptions): DetectWhiteBaseImageResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectWhiteBaseImageReq = new DetectWhiteBaseImageRequest{};
  OpenApiUtil.convert(request, detectWhiteBaseImageReq);

  authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
  ossConfig.accessKeyId = authResponse.accessKeyId;
  ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
  ossClient = new OSS(ossConfig);

  fileObj = new FileForm.FileField{
    filename = authResponse.objectKey,
    content = request.imageURLObject,
    contentType = '',
  };
  ossHeader = new OSS.PostObjectRequest.header{
    accessKeyId = authResponse.accessKeyId,
    policy = authResponse.encodedPolicy,
    signature = authResponse.signature,
    key = authResponse.objectKey,
    file = fileObj,
    successActionStatus = '201',
  };
  uploadRequest = new OSS.PostObjectRequest{
    bucketName = authResponse.bucket,
    header = ossHeader,
  };
  ossClient.postObject(uploadRequest, ossRuntime);
  detectWhiteBaseImageReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  var detectWhiteBaseImageResp = detectWhiteBaseImageWithOptions(detectWhiteBaseImageReq, runtime);
  return detectWhiteBaseImageResp;
}

model DetectVideoIPCObjectRequest {
  videoURL?: string(name='VideoURL', description='视频文件URL地址'),
  startTimestamp?: long(name='StartTimestamp', description='视频的开始时间戳(秒)，即UTC时间，默认为0'),
}

model DetectVideoIPCObjectAdvanceRequest {
  videoURLObject: readable(name='VideoURLObject'),
  startTimestamp?: long(name='StartTimestamp', description='视频的开始时间戳(秒)，即UTC时间，默认为0'),
}

model DetectVideoIPCObjectResponseBody = {
  requestId?: string(name='RequestId', description='JobId'),
  data?: {
    width?: long(name='Width', description='视频文件的分辨率(像素)'),
    height?: long(name='Height', description='视频文件的分辨率(像素)'),
    frames?: [ 
      {
        time?: long(name='Time', description='视频帧时间，startTimestamp+视频帧的相对时间的值，单位毫秒，如果startTimestamp为空，则是相对时间'),
        elements?: [ 
          {
            type?: string(name='Type'),
            x?: long(name='X'),
            y?: long(name='Y'),
            width?: long(name='Width'),
            height?: long(name='Height'),
            score?: float(name='Score'),
          }
        ](name='Elements'),
      }
    ](name='Frames', description='视频帧的集合，未检测到目标的帧不列出'),
    inputFile?: string(name='InputFile', description='输入文件信息'),
  }(name='Data'),
}

model DetectVideoIPCObjectResponse = {
  headers: map[string]string(name='headers'),
  body: DetectVideoIPCObjectResponseBody(name='body'),
}

async function detectVideoIPCObjectWithOptions(request: DetectVideoIPCObjectRequest, runtime: Util.RuntimeOptions): DetectVideoIPCObjectResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectVideoIPCObject', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectVideoIPCObject(request: DetectVideoIPCObjectRequest): DetectVideoIPCObjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectVideoIPCObjectWithOptions(request, runtime);
}

async function detectVideoIPCObjectAdvance(request: DetectVideoIPCObjectAdvanceRequest, runtime: Util.RuntimeOptions): DetectVideoIPCObjectResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectVideoIPCObjectReq = new DetectVideoIPCObjectRequest{};
  OpenApiUtil.convert(request, detectVideoIPCObjectReq);

  authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
  ossConfig.accessKeyId = authResponse.accessKeyId;
  ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
  ossClient = new OSS(ossConfig);

  fileObj = new FileForm.FileField{
    filename = authResponse.objectKey,
    content = request.videoURLObject,
    contentType = '',
  };
  ossHeader = new OSS.PostObjectRequest.header{
    accessKeyId = authResponse.accessKeyId,
    policy = authResponse.encodedPolicy,
    signature = authResponse.signature,
    key = authResponse.objectKey,
    file = fileObj,
    successActionStatus = '201',
  };
  uploadRequest = new OSS.PostObjectRequest{
    bucketName = authResponse.bucket,
    header = ossHeader,
  };
  ossClient.postObject(uploadRequest, ossRuntime);
  detectVideoIPCObjectReq.videoURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  var detectVideoIPCObjectResp = detectVideoIPCObjectWithOptions(detectVideoIPCObjectReq, runtime);
  return detectVideoIPCObjectResp;
}

model GetAsyncJobResultRequest {
  jobId?: string(name='JobId'),
}

model GetAsyncJobResultResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    status?: string(name='Status'),
    errorMessage?: string(name='ErrorMessage'),
    result?: string(name='Result'),
    errorCode?: string(name='ErrorCode'),
    jobId?: string(name='JobId'),
  }(name='Data'),
}

model GetAsyncJobResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetAsyncJobResultResponseBody(name='body'),
}

async function getAsyncJobResultWithOptions(request: GetAsyncJobResultRequest, runtime: Util.RuntimeOptions): GetAsyncJobResultResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetAsyncJobResult', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getAsyncJobResult(request: GetAsyncJobResultRequest): GetAsyncJobResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAsyncJobResultWithOptions(request, runtime);
}

model DetectMainBodyRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectMainBodyAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model DetectMainBodyResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    location?: {
      width?: int32(name='Width'),
      height?: int32(name='Height'),
      y?: int32(name='Y'),
      x?: int32(name='X'),
    }(name='Location'),
  }(name='Data'),
}

model DetectMainBodyResponse = {
  headers: map[string]string(name='headers'),
  body: DetectMainBodyResponseBody(name='body'),
}

async function detectMainBodyWithOptions(request: DetectMainBodyRequest, runtime: Util.RuntimeOptions): DetectMainBodyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectMainBody', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectMainBody(request: DetectMainBodyRequest): DetectMainBodyResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectMainBodyWithOptions(request, runtime);
}

async function detectMainBodyAdvance(request: DetectMainBodyAdvanceRequest, runtime: Util.RuntimeOptions): DetectMainBodyResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectMainBodyReq = new DetectMainBodyRequest{};
  OpenApiUtil.convert(request, detectMainBodyReq);

  authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
  ossConfig.accessKeyId = authResponse.accessKeyId;
  ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
  ossClient = new OSS(ossConfig);

  fileObj = new FileForm.FileField{
    filename = authResponse.objectKey,
    content = request.imageURLObject,
    contentType = '',
  };
  ossHeader = new OSS.PostObjectRequest.header{
    accessKeyId = authResponse.accessKeyId,
    policy = authResponse.encodedPolicy,
    signature = authResponse.signature,
    key = authResponse.objectKey,
    file = fileObj,
    successActionStatus = '201',
  };
  uploadRequest = new OSS.PostObjectRequest{
    bucketName = authResponse.bucket,
    header = ossHeader,
  };
  ossClient.postObject(uploadRequest, ossRuntime);
  detectMainBodyReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  var detectMainBodyResp = detectMainBodyWithOptions(detectMainBodyReq, runtime);
  return detectMainBodyResp;
}

model DetectVehicleRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectVehicleAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model DetectVehicleResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    detectObjectInfoList?: [ 
      {
        type?: string(name='Type'),
        boxes?: [ int32 ](name='Boxes'),
        score?: float(name='Score'),
        id?: int32(name='Id'),
      }
    ](name='DetectObjectInfoList'),
    width?: int32(name='Width'),
    height?: int32(name='Height'),
  }(name='Data'),
}

model DetectVehicleResponse = {
  headers: map[string]string(name='headers'),
  body: DetectVehicleResponseBody(name='body'),
}

async function detectVehicleWithOptions(request: DetectVehicleRequest, runtime: Util.RuntimeOptions): DetectVehicleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectVehicle', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectVehicle(request: DetectVehicleRequest): DetectVehicleResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectVehicleWithOptions(request, runtime);
}

async function detectVehicleAdvance(request: DetectVehicleAdvanceRequest, runtime: Util.RuntimeOptions): DetectVehicleResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectVehicleReq = new DetectVehicleRequest{};
  OpenApiUtil.convert(request, detectVehicleReq);

  authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
  ossConfig.accessKeyId = authResponse.accessKeyId;
  ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
  ossClient = new OSS(ossConfig);

  fileObj = new FileForm.FileField{
    filename = authResponse.objectKey,
    content = request.imageURLObject,
    contentType = '',
  };
  ossHeader = new OSS.PostObjectRequest.header{
    accessKeyId = authResponse.accessKeyId,
    policy = authResponse.encodedPolicy,
    signature = authResponse.signature,
    key = authResponse.objectKey,
    file = fileObj,
    successActionStatus = '201',
  };
  uploadRequest = new OSS.PostObjectRequest{
    bucketName = authResponse.bucket,
    header = ossHeader,
  };
  ossClient.postObject(uploadRequest, ossRuntime);
  detectVehicleReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  var detectVehicleResp = detectVehicleWithOptions(detectVehicleReq, runtime);
  return detectVehicleResp;
}

model DetectVehicleIllegalParkingRequest {
  imageURL?: string(name='ImageURL', description='A short description of struct'),
  roadRegions?: [ 
    {
      roadRegion?: [ 
        {
          point?: {
            x?: long(name='X'),
            y?: long(name='Y'),
          }(name='Point'),
        }
      ](name='RoadRegion'),
    }
  ](name='RoadRegions'),
}

model DetectVehicleIllegalParkingShrinkRequest {
  imageURL?: string(name='ImageURL', description='A short description of struct'),
  roadRegionsShrink?: string(name='RoadRegions'),
}

model DetectVehicleIllegalParkingResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  data?: {
    elements?: [ 
      {
        boxes?: [ 
          {
            left?: long(name='Left'),
            top?: long(name='Top'),
            right?: long(name='Right'),
            bottom?: long(name='Bottom'),
          }
        ](name='Boxes'),
        score?: float(name='Score'),
        typeName?: string(name='TypeName'),
      }
    ](name='Elements'),
    regionIntersects?: [ 
      {
        ids?: [ long ](name='Ids'),
      }
    ](name='RegionIntersects'),
  }(name='Data'),
}

model DetectVehicleIllegalParkingResponse = {
  headers: map[string]string(name='headers'),
  body: DetectVehicleIllegalParkingResponseBody(name='body'),
}

async function detectVehicleIllegalParkingWithOptions(tmpReq: DetectVehicleIllegalParkingRequest, runtime: Util.RuntimeOptions): DetectVehicleIllegalParkingResponse {
  Util.validateModel(tmpReq);
  var request = new DetectVehicleIllegalParkingShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.roadRegions)) {
    request.roadRegionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.roadRegions, 'RoadRegions', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectVehicleIllegalParking', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectVehicleIllegalParking(request: DetectVehicleIllegalParkingRequest): DetectVehicleIllegalParkingResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectVehicleIllegalParkingWithOptions(request, runtime);
}

model RecognizeVehicleDamageRequest {
  imageURL?: string(name='ImageURL'),
}

model RecognizeVehicleDamageAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model RecognizeVehicleDamageResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    elements?: [ 
      {
        type?: string(name='Type'),
        scores?: [ float ](name='Scores'),
        boxes?: [ int32 ](name='Boxes'),
        score?: float(name='Score'),
      }
    ](name='Elements'),
  }(name='Data'),
}

model RecognizeVehicleDamageResponse = {
  headers: map[string]string(name='headers'),
  body: RecognizeVehicleDamageResponseBody(name='body'),
}

async function recognizeVehicleDamageWithOptions(request: RecognizeVehicleDamageRequest, runtime: Util.RuntimeOptions): RecognizeVehicleDamageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RecognizeVehicleDamage', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function recognizeVehicleDamage(request: RecognizeVehicleDamageRequest): RecognizeVehicleDamageResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizeVehicleDamageWithOptions(request, runtime);
}

async function recognizeVehicleDamageAdvance(request: RecognizeVehicleDamageAdvanceRequest, runtime: Util.RuntimeOptions): RecognizeVehicleDamageResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var recognizeVehicleDamageReq = new RecognizeVehicleDamageRequest{};
  OpenApiUtil.convert(request, recognizeVehicleDamageReq);

  authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
  ossConfig.accessKeyId = authResponse.accessKeyId;
  ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
  ossClient = new OSS(ossConfig);

  fileObj = new FileForm.FileField{
    filename = authResponse.objectKey,
    content = request.imageURLObject,
    contentType = '',
  };
  ossHeader = new OSS.PostObjectRequest.header{
    accessKeyId = authResponse.accessKeyId,
    policy = authResponse.encodedPolicy,
    signature = authResponse.signature,
    key = authResponse.objectKey,
    file = fileObj,
    successActionStatus = '201',
  };
  uploadRequest = new OSS.PostObjectRequest{
    bucketName = authResponse.bucket,
    header = ossHeader,
  };
  ossClient.postObject(uploadRequest, ossRuntime);
  recognizeVehicleDamageReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  var recognizeVehicleDamageResp = recognizeVehicleDamageWithOptions(recognizeVehicleDamageReq, runtime);
  return recognizeVehicleDamageResp;
}

model RecognizeVehicleDashboardRequest {
  imageURL?: string(name='ImageURL'),
}

model RecognizeVehicleDashboardAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model RecognizeVehicleDashboardResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    elements?: [ 
      {
        boxes?: [ float ](name='Boxes'),
        score?: float(name='Score'),
        label?: string(name='Label'),
        className?: string(name='ClassName'),
      }
    ](name='Elements'),
  }(name='Data'),
}

model RecognizeVehicleDashboardResponse = {
  headers: map[string]string(name='headers'),
  body: RecognizeVehicleDashboardResponseBody(name='body'),
}

async function recognizeVehicleDashboardWithOptions(request: RecognizeVehicleDashboardRequest, runtime: Util.RuntimeOptions): RecognizeVehicleDashboardResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RecognizeVehicleDashboard', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function recognizeVehicleDashboard(request: RecognizeVehicleDashboardRequest): RecognizeVehicleDashboardResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizeVehicleDashboardWithOptions(request, runtime);
}

async function recognizeVehicleDashboardAdvance(request: RecognizeVehicleDashboardAdvanceRequest, runtime: Util.RuntimeOptions): RecognizeVehicleDashboardResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var recognizeVehicleDashboardReq = new RecognizeVehicleDashboardRequest{};
  OpenApiUtil.convert(request, recognizeVehicleDashboardReq);

  authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
  ossConfig.accessKeyId = authResponse.accessKeyId;
  ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
  ossClient = new OSS(ossConfig);

  fileObj = new FileForm.FileField{
    filename = authResponse.objectKey,
    content = request.imageURLObject,
    contentType = '',
  };
  ossHeader = new OSS.PostObjectRequest.header{
    accessKeyId = authResponse.accessKeyId,
    policy = authResponse.encodedPolicy,
    signature = authResponse.signature,
    key = authResponse.objectKey,
    file = fileObj,
    successActionStatus = '201',
  };
  uploadRequest = new OSS.PostObjectRequest{
    bucketName = authResponse.bucket,
    header = ossHeader,
  };
  ossClient.postObject(uploadRequest, ossRuntime);
  recognizeVehicleDashboardReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  var recognizeVehicleDashboardResp = recognizeVehicleDashboardWithOptions(recognizeVehicleDashboardReq, runtime);
  return recognizeVehicleDashboardResp;
}

model RecognizeVehiclePartsRequest {
  imageURL?: string(name='ImageURL'),
}

model RecognizeVehiclePartsAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model RecognizeVehiclePartsResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    elements?: [ 
      {
        type?: string(name='Type'),
        boxes?: [ int32 ](name='Boxes'),
        score?: float(name='Score'),
      }
    ](name='Elements'),
    originShapes?: [ int32 ](name='OriginShapes'),
  }(name='Data'),
}

model RecognizeVehiclePartsResponse = {
  headers: map[string]string(name='headers'),
  body: RecognizeVehiclePartsResponseBody(name='body'),
}

async function recognizeVehiclePartsWithOptions(request: RecognizeVehiclePartsRequest, runtime: Util.RuntimeOptions): RecognizeVehiclePartsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RecognizeVehicleParts', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function recognizeVehicleParts(request: RecognizeVehiclePartsRequest): RecognizeVehiclePartsResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizeVehiclePartsWithOptions(request, runtime);
}

async function recognizeVehiclePartsAdvance(request: RecognizeVehiclePartsAdvanceRequest, runtime: Util.RuntimeOptions): RecognizeVehiclePartsResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var recognizeVehiclePartsReq = new RecognizeVehiclePartsRequest{};
  OpenApiUtil.convert(request, recognizeVehiclePartsReq);

  authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
  ossConfig.accessKeyId = authResponse.accessKeyId;
  ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
  ossClient = new OSS(ossConfig);

  fileObj = new FileForm.FileField{
    filename = authResponse.objectKey,
    content = request.imageURLObject,
    contentType = '',
  };
  ossHeader = new OSS.PostObjectRequest.header{
    accessKeyId = authResponse.accessKeyId,
    policy = authResponse.encodedPolicy,
    signature = authResponse.signature,
    key = authResponse.objectKey,
    file = fileObj,
    successActionStatus = '201',
  };
  uploadRequest = new OSS.PostObjectRequest{
    bucketName = authResponse.bucket,
    header = ossHeader,
  };
  ossClient.postObject(uploadRequest, ossRuntime);
  recognizeVehiclePartsReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  var recognizeVehiclePartsResp = recognizeVehiclePartsWithOptions(recognizeVehiclePartsReq, runtime);
  return recognizeVehiclePartsResp;
}

model GenerateVehicleRepairPlanRequest {
  damageImageList?: [ 
    {
      createTimeStamp?: string(name='CreateTimeStamp'),
      imageUrl?: string(name='ImageUrl'),
    }
  ](name='DamageImageList'),
}

model GenerateVehicleRepairPlanResponseBody = {
  httpCode?: int32(name='HttpCode'),
  requestId?: string(name='RequestId'),
  data?: {
    taskId?: string(name='TaskId'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GenerateVehicleRepairPlanResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateVehicleRepairPlanResponseBody(name='body'),
}

async function generateVehicleRepairPlanWithOptions(request: GenerateVehicleRepairPlanRequest, runtime: Util.RuntimeOptions): GenerateVehicleRepairPlanResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GenerateVehicleRepairPlan', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function generateVehicleRepairPlan(request: GenerateVehicleRepairPlanRequest): GenerateVehicleRepairPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateVehicleRepairPlanWithOptions(request, runtime);
}

model DetectObjectRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectObjectAdvanceRequest {
  imageURLObject: readable(name='ImageURLObject'),
}

model DetectObjectResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    elements?: [ 
      {
        type?: string(name='Type'),
        boxes?: [ int32 ](name='Boxes'),
        score?: float(name='Score'),
      }
    ](name='Elements'),
    width?: int32(name='Width'),
    height?: int32(name='Height'),
  }(name='Data'),
}

model DetectObjectResponse = {
  headers: map[string]string(name='headers'),
  body: DetectObjectResponseBody(name='body'),
}

async function detectObjectWithOptions(request: DetectObjectRequest, runtime: Util.RuntimeOptions): DetectObjectResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectObject', '2019-12-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectObject(request: DetectObjectRequest): DetectObjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectObjectWithOptions(request, runtime);
}

async function detectObjectAdvance(request: DetectObjectAdvanceRequest, runtime: Util.RuntimeOptions): DetectObjectResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectObjectReq = new DetectObjectRequest{};
  OpenApiUtil.convert(request, detectObjectReq);

  authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
  ossConfig.accessKeyId = authResponse.accessKeyId;
  ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
  ossClient = new OSS(ossConfig);

  fileObj = new FileForm.FileField{
    filename = authResponse.objectKey,
    content = request.imageURLObject,
    contentType = '',
  };
  ossHeader = new OSS.PostObjectRequest.header{
    accessKeyId = authResponse.accessKeyId,
    policy = authResponse.encodedPolicy,
    signature = authResponse.signature,
    key = authResponse.objectKey,
    file = fileObj,
    successActionStatus = '201',
  };
  uploadRequest = new OSS.PostObjectRequest{
    bucketName = authResponse.bucket,
    header = ossHeader,
  };
  ossClient.postObject(uploadRequest, ossRuntime);
  detectObjectReq.imageURL = `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  var detectObjectResp = detectObjectWithOptions(detectObjectReq, runtime);
  return detectObjectResp;
}

