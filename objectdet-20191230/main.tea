/**
 *
 */
import Util;
import OSS;
import OpenPlatform;
import OSSUtil;
import FileForm;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('objectdet', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model DetectObjectElement {
  height?: long(name='Height'),
  score?: float(name='Score'),
  type?: string(name='Type'),
  width?: long(name='Width'),
  x?: long(name='X'),
  y?: long(name='Y'),
}

model DetectObjectFrame {
  elements?: [
    DetectObjectElement
  ](name='Elements'),
  time?: long(name='Time'),
}

model ClassifyVehicleInsuranceRequest {
  imageURL?: string(name='ImageURL'),
}

model ClassifyVehicleInsuranceAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
}

model ClassifyVehicleInsuranceResponseBody = {
  data?: {
    labels?: [ 
      {
        name?: string(name='Name'),
        score?: float(name='Score'),
      }
    ](name='Labels'),
    threshold?: float(name='Threshold'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ClassifyVehicleInsuranceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ClassifyVehicleInsuranceResponseBody(name='body'),
}

async function classifyVehicleInsuranceWithOptions(request: ClassifyVehicleInsuranceRequest, runtime: Util.RuntimeOptions): ClassifyVehicleInsuranceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ClassifyVehicleInsurance',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function classifyVehicleInsurance(request: ClassifyVehicleInsuranceRequest): ClassifyVehicleInsuranceResponse {
  var runtime = new Util.RuntimeOptions{};
  return classifyVehicleInsuranceWithOptions(request, runtime);
}

async function classifyVehicleInsuranceAdvance(request: ClassifyVehicleInsuranceAdvanceRequest, runtime: Util.RuntimeOptions): ClassifyVehicleInsuranceResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var classifyVehicleInsuranceReq = new ClassifyVehicleInsuranceRequest{};
  OpenApiUtil.convert(request, classifyVehicleInsuranceReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    classifyVehicleInsuranceReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var classifyVehicleInsuranceResp = classifyVehicleInsuranceWithOptions(classifyVehicleInsuranceReq, runtime);
  return classifyVehicleInsuranceResp;
}

model DetectIPCObjectRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectIPCObjectAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
}

model DetectIPCObjectResponseBody = {
  data?: {
    elements?: [ 
      {
        box?: [ long ](name='Box'),
        score?: float(name='Score'),
        targetRate?: float(name='TargetRate'),
        type?: string(name='Type'),
      }
    ](name='Elements'),
    height?: long(name='Height'),
    width?: long(name='Width'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectIPCObjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectIPCObjectResponseBody(name='body'),
}

async function detectIPCObjectWithOptions(request: DetectIPCObjectRequest, runtime: Util.RuntimeOptions): DetectIPCObjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetectIPCObject',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectIPCObject(request: DetectIPCObjectRequest): DetectIPCObjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectIPCObjectWithOptions(request, runtime);
}

async function detectIPCObjectAdvance(request: DetectIPCObjectAdvanceRequest, runtime: Util.RuntimeOptions): DetectIPCObjectResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectIPCObjectReq = new DetectIPCObjectRequest{};
  OpenApiUtil.convert(request, detectIPCObjectReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectIPCObjectReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var detectIPCObjectResp = detectIPCObjectWithOptions(detectIPCObjectReq, runtime);
  return detectIPCObjectResp;
}

model DetectKitchenAnimalsRequest {
  imageURLA?: string(name='ImageURLA'),
  imageURLB?: string(name='ImageURLB'),
}

model DetectKitchenAnimalsAdvanceRequest {
  imageURLAObject?: readable(name='ImageURLA'),
  imageURLBObject?: readable(name='ImageURLB'),
}

model DetectKitchenAnimalsResponseBody = {
  data?: {
    elements?: [ 
      {
        rectangles?: {
          height?: long(name='Height'),
          left?: long(name='Left'),
          top?: long(name='Top'),
          width?: long(name='Width'),
        }(name='Rectangles'),
        score?: float(name='Score'),
        type?: string(name='Type'),
      }
    ](name='Elements'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectKitchenAnimalsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectKitchenAnimalsResponseBody(name='body'),
}

async function detectKitchenAnimalsWithOptions(request: DetectKitchenAnimalsRequest, runtime: Util.RuntimeOptions): DetectKitchenAnimalsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURLA)) {
    body['ImageURLA'] = request.imageURLA;
  }
  if (!Util.isUnset(request.imageURLB)) {
    body['ImageURLB'] = request.imageURLB;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetectKitchenAnimals',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectKitchenAnimals(request: DetectKitchenAnimalsRequest): DetectKitchenAnimalsResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectKitchenAnimalsWithOptions(request, runtime);
}

async function detectKitchenAnimalsAdvance(request: DetectKitchenAnimalsAdvanceRequest, runtime: Util.RuntimeOptions): DetectKitchenAnimalsResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectKitchenAnimalsReq = new DetectKitchenAnimalsRequest{};
  OpenApiUtil.convert(request, detectKitchenAnimalsReq);

  if(!Util.isUnset(request.imageURLAObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLAObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectKitchenAnimalsReq.imageURLA = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  if(!Util.isUnset(request.imageURLBObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLBObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectKitchenAnimalsReq.imageURLB = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var detectKitchenAnimalsResp = detectKitchenAnimalsWithOptions(detectKitchenAnimalsReq, runtime);
  return detectKitchenAnimalsResp;
}

model DetectMainBodyRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectMainBodyAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
}

model DetectMainBodyResponseBody = {
  data?: {
    location?: {
      height?: int32(name='Height'),
      width?: int32(name='Width'),
      x?: int32(name='X'),
      y?: int32(name='Y'),
    }(name='Location'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectMainBodyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectMainBodyResponseBody(name='body'),
}

async function detectMainBodyWithOptions(request: DetectMainBodyRequest, runtime: Util.RuntimeOptions): DetectMainBodyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageURL)) {
    query['ImageURL'] = request.imageURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetectMainBody',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectMainBody(request: DetectMainBodyRequest): DetectMainBodyResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectMainBodyWithOptions(request, runtime);
}

async function detectMainBodyAdvance(request: DetectMainBodyAdvanceRequest, runtime: Util.RuntimeOptions): DetectMainBodyResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectMainBodyReq = new DetectMainBodyRequest{};
  OpenApiUtil.convert(request, detectMainBodyReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectMainBodyReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var detectMainBodyResp = detectMainBodyWithOptions(detectMainBodyReq, runtime);
  return detectMainBodyResp;
}

model DetectObjectRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectObjectAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
}

model DetectObjectResponseBody = {
  data?: {
    elements?: [ 
      {
        boxes?: [ int32 ](name='Boxes'),
        score?: float(name='Score'),
        type?: string(name='Type'),
      }
    ](name='Elements'),
    height?: int32(name='Height'),
    width?: int32(name='Width'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectObjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectObjectResponseBody(name='body'),
}

async function detectObjectWithOptions(request: DetectObjectRequest, runtime: Util.RuntimeOptions): DetectObjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetectObject',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectObject(request: DetectObjectRequest): DetectObjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectObjectWithOptions(request, runtime);
}

async function detectObjectAdvance(request: DetectObjectAdvanceRequest, runtime: Util.RuntimeOptions): DetectObjectResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectObjectReq = new DetectObjectRequest{};
  OpenApiUtil.convert(request, detectObjectReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectObjectReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var detectObjectResp = detectObjectWithOptions(detectObjectReq, runtime);
  return detectObjectResp;
}

model DetectTransparentImageRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectTransparentImageAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
}

model DetectTransparentImageResponseBody = {
  data?: {
    elements?: [ 
      {
        transparentImage?: int32(name='TransparentImage'),
      }
    ](name='Elements'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectTransparentImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectTransparentImageResponseBody(name='body'),
}

async function detectTransparentImageWithOptions(request: DetectTransparentImageRequest, runtime: Util.RuntimeOptions): DetectTransparentImageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetectTransparentImage',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectTransparentImage(request: DetectTransparentImageRequest): DetectTransparentImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectTransparentImageWithOptions(request, runtime);
}

async function detectTransparentImageAdvance(request: DetectTransparentImageAdvanceRequest, runtime: Util.RuntimeOptions): DetectTransparentImageResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectTransparentImageReq = new DetectTransparentImageRequest{};
  OpenApiUtil.convert(request, detectTransparentImageReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectTransparentImageReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var detectTransparentImageResp = detectTransparentImageWithOptions(detectTransparentImageReq, runtime);
  return detectTransparentImageResp;
}

model DetectVehicleRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectVehicleAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
}

model DetectVehicleResponseBody = {
  data?: {
    detectObjectInfoList?: [ 
      {
        boxes?: [ int32 ](name='Boxes'),
        id?: int32(name='Id'),
        score?: float(name='Score'),
        type?: string(name='Type'),
      }
    ](name='DetectObjectInfoList'),
    height?: int32(name='Height'),
    width?: int32(name='Width'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectVehicleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectVehicleResponseBody(name='body'),
}

async function detectVehicleWithOptions(request: DetectVehicleRequest, runtime: Util.RuntimeOptions): DetectVehicleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetectVehicle',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectVehicle(request: DetectVehicleRequest): DetectVehicleResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectVehicleWithOptions(request, runtime);
}

async function detectVehicleAdvance(request: DetectVehicleAdvanceRequest, runtime: Util.RuntimeOptions): DetectVehicleResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectVehicleReq = new DetectVehicleRequest{};
  OpenApiUtil.convert(request, detectVehicleReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectVehicleReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var detectVehicleResp = detectVehicleWithOptions(detectVehicleReq, runtime);
  return detectVehicleResp;
}

model DetectVehicleICongestionRequest {
  imageURL?: string(name='ImageURL'),
  preRegionIntersectFeatures?: [ 
    {
      features?: [ string ](name='Features'),
    }
  ](name='PreRegionIntersectFeatures'),
  roadRegions?: [ 
    {
      roadRegion?: [ 
        {
          point?: {
            x?: long(name='X'),
            y?: long(name='Y'),
          }(name='Point'),
        }
      ](name='RoadRegion'),
    }
  ](name='RoadRegions'),
}

model DetectVehicleICongestionAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
  preRegionIntersectFeatures?: [ 
    {
      features?: [ string ](name='Features'),
    }
  ](name='PreRegionIntersectFeatures'),
  roadRegions?: [ 
    {
      roadRegion?: [ 
        {
          point?: {
            x?: long(name='X'),
            y?: long(name='Y'),
          }(name='Point'),
        }
      ](name='RoadRegion'),
    }
  ](name='RoadRegions'),
}

model DetectVehicleICongestionShrinkRequest {
  imageURL?: string(name='ImageURL'),
  preRegionIntersectFeaturesShrink?: string(name='PreRegionIntersectFeatures'),
  roadRegionsShrink?: string(name='RoadRegions'),
}

model DetectVehicleICongestionResponseBody = {
  data?: {
    elements?: [ 
      {
        boxes?: [ 
          {
            bottom?: long(name='Bottom'),
            left?: long(name='Left'),
            right?: long(name='Right'),
            top?: long(name='Top'),
          }
        ](name='Boxes'),
        id?: long(name='Id'),
        score?: float(name='Score'),
        typeName?: string(name='TypeName'),
      }
    ](name='Elements'),
    regionIntersectFeatures?: [ 
      {
        features?: [ string ](name='Features'),
      }
    ](name='RegionIntersectFeatures'),
    regionIntersectMatched?: [ 
      {
        ids?: [ long ](name='Ids'),
      }
    ](name='RegionIntersectMatched'),
    regionIntersects?: [ 
      {
        ids?: [ long ](name='Ids'),
      }
    ](name='RegionIntersects'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectVehicleICongestionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectVehicleICongestionResponseBody(name='body'),
}

async function detectVehicleICongestionWithOptions(tmpReq: DetectVehicleICongestionRequest, runtime: Util.RuntimeOptions): DetectVehicleICongestionResponse {
  Util.validateModel(tmpReq);
  var request = new DetectVehicleICongestionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.preRegionIntersectFeatures)) {
    request.preRegionIntersectFeaturesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.preRegionIntersectFeatures, 'PreRegionIntersectFeatures', 'json');
  }
  if (!Util.isUnset(tmpReq.roadRegions)) {
    request.roadRegionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.roadRegions, 'RoadRegions', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  if (!Util.isUnset(request.preRegionIntersectFeaturesShrink)) {
    body['PreRegionIntersectFeatures'] = request.preRegionIntersectFeaturesShrink;
  }
  if (!Util.isUnset(request.roadRegionsShrink)) {
    body['RoadRegions'] = request.roadRegionsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetectVehicleICongestion',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectVehicleICongestion(request: DetectVehicleICongestionRequest): DetectVehicleICongestionResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectVehicleICongestionWithOptions(request, runtime);
}

async function detectVehicleICongestionAdvance(request: DetectVehicleICongestionAdvanceRequest, runtime: Util.RuntimeOptions): DetectVehicleICongestionResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectVehicleICongestionReq = new DetectVehicleICongestionRequest{};
  OpenApiUtil.convert(request, detectVehicleICongestionReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectVehicleICongestionReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var detectVehicleICongestionResp = detectVehicleICongestionWithOptions(detectVehicleICongestionReq, runtime);
  return detectVehicleICongestionResp;
}

model DetectVehicleIllegalParkingRequest {
  imageURL?: string(name='ImageURL'),
  roadRegions?: [ 
    {
      roadRegion?: [ 
        {
          point?: {
            x?: long(name='X'),
            y?: long(name='Y'),
          }(name='Point'),
        }
      ](name='RoadRegion'),
    }
  ](name='RoadRegions'),
}

model DetectVehicleIllegalParkingAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
  roadRegions?: [ 
    {
      roadRegion?: [ 
        {
          point?: {
            x?: long(name='X'),
            y?: long(name='Y'),
          }(name='Point'),
        }
      ](name='RoadRegion'),
    }
  ](name='RoadRegions'),
}

model DetectVehicleIllegalParkingShrinkRequest {
  imageURL?: string(name='ImageURL'),
  roadRegionsShrink?: string(name='RoadRegions'),
}

model DetectVehicleIllegalParkingResponseBody = {
  data?: {
    elements?: [ 
      {
        boxes?: [ 
          {
            bottom?: long(name='Bottom'),
            left?: long(name='Left'),
            right?: long(name='Right'),
            top?: long(name='Top'),
          }
        ](name='Boxes'),
        id?: long(name='Id'),
        score?: float(name='Score'),
        typeName?: string(name='TypeName'),
      }
    ](name='Elements'),
    regionIntersects?: [ 
      {
        ids?: [ long ](name='Ids'),
      }
    ](name='RegionIntersects'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectVehicleIllegalParkingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectVehicleIllegalParkingResponseBody(name='body'),
}

async function detectVehicleIllegalParkingWithOptions(tmpReq: DetectVehicleIllegalParkingRequest, runtime: Util.RuntimeOptions): DetectVehicleIllegalParkingResponse {
  Util.validateModel(tmpReq);
  var request = new DetectVehicleIllegalParkingShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.roadRegions)) {
    request.roadRegionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.roadRegions, 'RoadRegions', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  if (!Util.isUnset(request.roadRegionsShrink)) {
    body['RoadRegions'] = request.roadRegionsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetectVehicleIllegalParking',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectVehicleIllegalParking(request: DetectVehicleIllegalParkingRequest): DetectVehicleIllegalParkingResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectVehicleIllegalParkingWithOptions(request, runtime);
}

async function detectVehicleIllegalParkingAdvance(request: DetectVehicleIllegalParkingAdvanceRequest, runtime: Util.RuntimeOptions): DetectVehicleIllegalParkingResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectVehicleIllegalParkingReq = new DetectVehicleIllegalParkingRequest{};
  OpenApiUtil.convert(request, detectVehicleIllegalParkingReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectVehicleIllegalParkingReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var detectVehicleIllegalParkingResp = detectVehicleIllegalParkingWithOptions(detectVehicleIllegalParkingReq, runtime);
  return detectVehicleIllegalParkingResp;
}

model DetectVideoFrameRequest {
  createTime?: long(name='CreateTime'),
  featureConfig?: string(name='FeatureConfig'),
  features?: [ string ](name='Features'),
  height?: long(name='Height'),
  imageURL?: string(name='ImageURL'),
  ownerId?: long(name='OwnerId'),
  streamArn?: string(name='StreamArn'),
  width?: long(name='Width'),
}

model DetectVideoFrameShrinkRequest {
  createTime?: long(name='CreateTime'),
  featureConfig?: string(name='FeatureConfig'),
  featuresShrink?: string(name='Features'),
  height?: long(name='Height'),
  imageURL?: string(name='ImageURL'),
  ownerId?: long(name='OwnerId'),
  streamArn?: string(name='StreamArn'),
  width?: long(name='Width'),
}

model DetectVideoFrameResponseBody = {
  data?: {
    requestId?: string(name='RequestId'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectVideoFrameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectVideoFrameResponseBody(name='body'),
}

async function detectVideoFrameWithOptions(tmpReq: DetectVideoFrameRequest, runtime: Util.RuntimeOptions): DetectVideoFrameResponse {
  Util.validateModel(tmpReq);
  var request = new DetectVideoFrameShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.features)) {
    request.featuresShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.features, 'Features', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.createTime)) {
    body['CreateTime'] = request.createTime;
  }
  if (!Util.isUnset(request.featureConfig)) {
    body['FeatureConfig'] = request.featureConfig;
  }
  if (!Util.isUnset(request.featuresShrink)) {
    body['Features'] = request.featuresShrink;
  }
  if (!Util.isUnset(request.height)) {
    body['Height'] = request.height;
  }
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  if (!Util.isUnset(request.ownerId)) {
    body['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.streamArn)) {
    body['StreamArn'] = request.streamArn;
  }
  if (!Util.isUnset(request.width)) {
    body['Width'] = request.width;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetectVideoFrame',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectVideoFrame(request: DetectVideoFrameRequest): DetectVideoFrameResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectVideoFrameWithOptions(request, runtime);
}

model DetectVideoIPCObjectRequest {
  callbackOnlyHasObject?: boolean(name='CallbackOnlyHasObject'),
  startTimestamp?: long(name='StartTimestamp'),
  videoURL?: string(name='VideoURL'),
}

model DetectVideoIPCObjectAdvanceRequest {
  callbackOnlyHasObject?: boolean(name='CallbackOnlyHasObject'),
  startTimestamp?: long(name='StartTimestamp'),
  videoURLObject?: readable(name='VideoURL'),
}

model DetectVideoIPCObjectResponseBody = {
  data?: {
    frames?: [ 
      {
        elements?: [ 
          {
            height?: long(name='Height'),
            score?: float(name='Score'),
            type?: string(name='Type'),
            width?: long(name='Width'),
            x?: long(name='X'),
            y?: long(name='Y'),
          }
        ](name='Elements'),
        time?: long(name='Time'),
      }
    ](name='Frames'),
    height?: long(name='Height'),
    inputFile?: string(name='InputFile'),
    width?: long(name='Width'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectVideoIPCObjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectVideoIPCObjectResponseBody(name='body'),
}

async function detectVideoIPCObjectWithOptions(request: DetectVideoIPCObjectRequest, runtime: Util.RuntimeOptions): DetectVideoIPCObjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.callbackOnlyHasObject)) {
    body['CallbackOnlyHasObject'] = request.callbackOnlyHasObject;
  }
  if (!Util.isUnset(request.startTimestamp)) {
    body['StartTimestamp'] = request.startTimestamp;
  }
  if (!Util.isUnset(request.videoURL)) {
    body['VideoURL'] = request.videoURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetectVideoIPCObject',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectVideoIPCObject(request: DetectVideoIPCObjectRequest): DetectVideoIPCObjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectVideoIPCObjectWithOptions(request, runtime);
}

async function detectVideoIPCObjectAdvance(request: DetectVideoIPCObjectAdvanceRequest, runtime: Util.RuntimeOptions): DetectVideoIPCObjectResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectVideoIPCObjectReq = new DetectVideoIPCObjectRequest{};
  OpenApiUtil.convert(request, detectVideoIPCObjectReq);

  if(!Util.isUnset(request.videoURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.videoURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectVideoIPCObjectReq.videoURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var detectVideoIPCObjectResp = detectVideoIPCObjectWithOptions(detectVideoIPCObjectReq, runtime);
  return detectVideoIPCObjectResp;
}

model DetectWhiteBaseImageRequest {
  imageURL?: string(name='ImageURL'),
}

model DetectWhiteBaseImageAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
}

model DetectWhiteBaseImageResponseBody = {
  data?: {
    elements?: [ 
      {
        whiteBase?: int32(name='WhiteBase'),
      }
    ](name='Elements'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectWhiteBaseImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectWhiteBaseImageResponseBody(name='body'),
}

async function detectWhiteBaseImageWithOptions(request: DetectWhiteBaseImageRequest, runtime: Util.RuntimeOptions): DetectWhiteBaseImageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetectWhiteBaseImage',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectWhiteBaseImage(request: DetectWhiteBaseImageRequest): DetectWhiteBaseImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectWhiteBaseImageWithOptions(request, runtime);
}

async function detectWhiteBaseImageAdvance(request: DetectWhiteBaseImageAdvanceRequest, runtime: Util.RuntimeOptions): DetectWhiteBaseImageResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectWhiteBaseImageReq = new DetectWhiteBaseImageRequest{};
  OpenApiUtil.convert(request, detectWhiteBaseImageReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectWhiteBaseImageReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var detectWhiteBaseImageResp = detectWhiteBaseImageWithOptions(detectWhiteBaseImageReq, runtime);
  return detectWhiteBaseImageResp;
}

model DetectWorkwearRequest {
  clothes?: {
    maxNum?: long(name='MaxNum'),
    threshold?: double(name='Threshold'),
  }(name='Clothes'),
  imageUrl?: string(name='ImageUrl'),
  labels?: [ string ](name='Labels'),
}

model DetectWorkwearAdvanceRequest {
  clothes?: {
    maxNum?: long(name='MaxNum'),
    threshold?: double(name='Threshold'),
  }(name='Clothes'),
  imageUrlObject?: readable(name='ImageUrl'),
  labels?: [ string ](name='Labels'),
}

model DetectWorkwearShrinkRequest {
  clothesShrink?: string(name='Clothes'),
  imageUrl?: string(name='ImageUrl'),
  labels?: [ string ](name='Labels'),
}

model DetectWorkwearResponseBody = {
  data?: {
    elements?: [ 
      {
        property?: [ 
          {
            label?: string(name='Label'),
            probability?: {
              no?: double(name='No'),
              threshold?: long(name='Threshold'),
              unknown?: double(name='Unknown'),
              yes?: double(name='Yes'),
            }(name='Probability'),
          }
        ](name='Property'),
        rectangles?: {
          height?: long(name='Height'),
          left?: long(name='Left'),
          top?: long(name='Top'),
          width?: long(name='Width'),
        }(name='Rectangles'),
        score?: double(name='Score'),
        type?: string(name='Type'),
      }
    ](name='Elements'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DetectWorkwearResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectWorkwearResponseBody(name='body'),
}

async function detectWorkwearWithOptions(tmpReq: DetectWorkwearRequest, runtime: Util.RuntimeOptions): DetectWorkwearResponse {
  Util.validateModel(tmpReq);
  var request = new DetectWorkwearShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.clothes)) {
    request.clothesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.clothes, 'Clothes', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.clothesShrink)) {
    body['Clothes'] = request.clothesShrink;
  }
  if (!Util.isUnset(request.imageUrl)) {
    body['ImageUrl'] = request.imageUrl;
  }
  if (!Util.isUnset(request.labels)) {
    body['Labels'] = request.labels;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetectWorkwear',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectWorkwear(request: DetectWorkwearRequest): DetectWorkwearResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectWorkwearWithOptions(request, runtime);
}

async function detectWorkwearAdvance(request: DetectWorkwearAdvanceRequest, runtime: Util.RuntimeOptions): DetectWorkwearResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var detectWorkwearReq = new DetectWorkwearRequest{};
  OpenApiUtil.convert(request, detectWorkwearReq);

  if(!Util.isUnset(request.imageUrlObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageUrlObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    detectWorkwearReq.imageUrl = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var detectWorkwearResp = detectWorkwearWithOptions(detectWorkwearReq, runtime);
  return detectWorkwearResp;
}

model GenerateVehicleRepairPlanRequest {
  damageImageList?: [ 
    {
      createTimeStamp?: string(name='CreateTimeStamp'),
      imageUrl?: string(name='ImageUrl'),
    }
  ](name='DamageImageList'),
}

model GenerateVehicleRepairPlanResponseBody = {
  code?: string(name='Code'),
  data?: {
    taskId?: string(name='TaskId'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  httpCode?: int32(name='HttpCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GenerateVehicleRepairPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateVehicleRepairPlanResponseBody(name='body'),
}

async function generateVehicleRepairPlanWithOptions(request: GenerateVehicleRepairPlanRequest, runtime: Util.RuntimeOptions): GenerateVehicleRepairPlanResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.damageImageList)) {
    body['DamageImageList'] = request.damageImageList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GenerateVehicleRepairPlan',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateVehicleRepairPlan(request: GenerateVehicleRepairPlanRequest): GenerateVehicleRepairPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateVehicleRepairPlanWithOptions(request, runtime);
}

model GetAsyncJobResultRequest {
  jobId?: string(name='JobId'),
}

model GetAsyncJobResultResponseBody = {
  data?: {
    errorCode?: string(name='ErrorCode'),
    errorMessage?: string(name='ErrorMessage'),
    jobId?: string(name='JobId'),
    result?: string(name='Result'),
    status?: string(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetAsyncJobResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAsyncJobResultResponseBody(name='body'),
}

async function getAsyncJobResultWithOptions(request: GetAsyncJobResultRequest, runtime: Util.RuntimeOptions): GetAsyncJobResultResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.jobId)) {
    body['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetAsyncJobResult',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAsyncJobResult(request: GetAsyncJobResultRequest): GetAsyncJobResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAsyncJobResultWithOptions(request, runtime);
}

model GetVehicleRepairPlanRequest {
  carNumberImage?: string(name='CarNumberImage'),
  taskId?: string(name='TaskId'),
  vinCodeImage?: string(name='VinCodeImage'),
}

model GetVehicleRepairPlanAdvanceRequest {
  carNumberImageObject?: readable(name='CarNumberImage'),
  taskId?: string(name='TaskId'),
  vinCodeImageObject?: readable(name='VinCodeImage'),
}

model GetVehicleRepairPlanResponseBody = {
  code?: string(name='Code'),
  data?: {
    frameNo?: string(name='FrameNo'),
    repairParts?: [ 
      {
        garageType?: string(name='GarageType'),
        oeMatch?: boolean(name='OeMatch'),
        outStandardPartsId?: string(name='OutStandardPartsId'),
        outStandardPartsName?: string(name='OutStandardPartsName'),
        partNameMatch?: boolean(name='PartNameMatch'),
        partsStdCode?: string(name='PartsStdCode'),
        partsStdName?: string(name='PartsStdName'),
        relationType?: string(name='RelationType'),
        repairFee?: string(name='RepairFee'),
        repairType?: string(name='RepairType'),
        repairTypeName?: string(name='RepairTypeName'),
      }
    ](name='RepairParts'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  httpCode?: int32(name='HttpCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetVehicleRepairPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVehicleRepairPlanResponseBody(name='body'),
}

async function getVehicleRepairPlanWithOptions(request: GetVehicleRepairPlanRequest, runtime: Util.RuntimeOptions): GetVehicleRepairPlanResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.carNumberImage)) {
    body['CarNumberImage'] = request.carNumberImage;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.vinCodeImage)) {
    body['VinCodeImage'] = request.vinCodeImage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetVehicleRepairPlan',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getVehicleRepairPlan(request: GetVehicleRepairPlanRequest): GetVehicleRepairPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVehicleRepairPlanWithOptions(request, runtime);
}

async function getVehicleRepairPlanAdvance(request: GetVehicleRepairPlanAdvanceRequest, runtime: Util.RuntimeOptions): GetVehicleRepairPlanResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var getVehicleRepairPlanReq = new GetVehicleRepairPlanRequest{};
  OpenApiUtil.convert(request, getVehicleRepairPlanReq);

  if(!Util.isUnset(request.carNumberImageObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.carNumberImageObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    getVehicleRepairPlanReq.carNumberImage = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  if(!Util.isUnset(request.vinCodeImageObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.vinCodeImageObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    getVehicleRepairPlanReq.vinCodeImage = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var getVehicleRepairPlanResp = getVehicleRepairPlanWithOptions(getVehicleRepairPlanReq, runtime);
  return getVehicleRepairPlanResp;
}

model RecognizeVehicleDamageRequest {
  imageURL?: string(name='ImageURL'),
}

model RecognizeVehicleDamageAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
}

model RecognizeVehicleDamageResponseBody = {
  data?: {
    elements?: [ 
      {
        boxes?: [ int32 ](name='Boxes'),
        score?: float(name='Score'),
        scores?: [ float ](name='Scores'),
        type?: string(name='Type'),
      }
    ](name='Elements'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model RecognizeVehicleDamageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecognizeVehicleDamageResponseBody(name='body'),
}

async function recognizeVehicleDamageWithOptions(request: RecognizeVehicleDamageRequest, runtime: Util.RuntimeOptions): RecognizeVehicleDamageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RecognizeVehicleDamage',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recognizeVehicleDamage(request: RecognizeVehicleDamageRequest): RecognizeVehicleDamageResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizeVehicleDamageWithOptions(request, runtime);
}

async function recognizeVehicleDamageAdvance(request: RecognizeVehicleDamageAdvanceRequest, runtime: Util.RuntimeOptions): RecognizeVehicleDamageResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var recognizeVehicleDamageReq = new RecognizeVehicleDamageRequest{};
  OpenApiUtil.convert(request, recognizeVehicleDamageReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    recognizeVehicleDamageReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var recognizeVehicleDamageResp = recognizeVehicleDamageWithOptions(recognizeVehicleDamageReq, runtime);
  return recognizeVehicleDamageResp;
}

model RecognizeVehicleDashboardRequest {
  imageURL?: string(name='ImageURL'),
}

model RecognizeVehicleDashboardAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
}

model RecognizeVehicleDashboardResponseBody = {
  data?: {
    elements?: [ 
      {
        boxes?: [ float ](name='Boxes'),
        className?: string(name='ClassName'),
        label?: string(name='Label'),
        score?: float(name='Score'),
      }
    ](name='Elements'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model RecognizeVehicleDashboardResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecognizeVehicleDashboardResponseBody(name='body'),
}

async function recognizeVehicleDashboardWithOptions(request: RecognizeVehicleDashboardRequest, runtime: Util.RuntimeOptions): RecognizeVehicleDashboardResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RecognizeVehicleDashboard',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recognizeVehicleDashboard(request: RecognizeVehicleDashboardRequest): RecognizeVehicleDashboardResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizeVehicleDashboardWithOptions(request, runtime);
}

async function recognizeVehicleDashboardAdvance(request: RecognizeVehicleDashboardAdvanceRequest, runtime: Util.RuntimeOptions): RecognizeVehicleDashboardResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var recognizeVehicleDashboardReq = new RecognizeVehicleDashboardRequest{};
  OpenApiUtil.convert(request, recognizeVehicleDashboardReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    recognizeVehicleDashboardReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var recognizeVehicleDashboardResp = recognizeVehicleDashboardWithOptions(recognizeVehicleDashboardReq, runtime);
  return recognizeVehicleDashboardResp;
}

model RecognizeVehiclePartsRequest {
  imageURL?: string(name='ImageURL'),
}

model RecognizeVehiclePartsAdvanceRequest {
  imageURLObject?: readable(name='ImageURL'),
}

model RecognizeVehiclePartsResponseBody = {
  data?: {
    elements?: [ 
      {
        boxes?: [ int32 ](name='Boxes'),
        score?: float(name='Score'),
        type?: string(name='Type'),
      }
    ](name='Elements'),
    originShapes?: [ int32 ](name='OriginShapes'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model RecognizeVehiclePartsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecognizeVehiclePartsResponseBody(name='body'),
}

async function recognizeVehiclePartsWithOptions(request: RecognizeVehiclePartsRequest, runtime: Util.RuntimeOptions): RecognizeVehiclePartsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageURL)) {
    body['ImageURL'] = request.imageURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RecognizeVehicleParts',
    version = '2019-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recognizeVehicleParts(request: RecognizeVehiclePartsRequest): RecognizeVehiclePartsResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizeVehiclePartsWithOptions(request, runtime);
}

async function recognizeVehiclePartsAdvance(request: RecognizeVehiclePartsAdvanceRequest, runtime: Util.RuntimeOptions): RecognizeVehiclePartsResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'objectdet',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var recognizeVehiclePartsReq = new RecognizeVehiclePartsRequest{};
  OpenApiUtil.convert(request, recognizeVehiclePartsReq);

  if(!Util.isUnset(request.imageURLObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageURLObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    recognizeVehiclePartsReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var recognizeVehiclePartsResp = recognizeVehiclePartsWithOptions(recognizeVehiclePartsReq, runtime);
  return recognizeVehiclePartsResp;
}

