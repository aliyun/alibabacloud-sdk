/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-qingdao = 'mongodb.aliyuncs.com',
    cn-beijing = 'mongodb.aliyuncs.com',
    cn-zhangjiakou = 'mongodb.cn-zhangjiakou.aliyuncs.com',
    cn-huhehaote = 'mongodb.cn-huhehaote.aliyuncs.com',
    cn-wulanchabu = 'mongodb.aliyuncs.com',
    cn-hangzhou = 'mongodb.aliyuncs.com',
    cn-shanghai = 'mongodb.aliyuncs.com',
    cn-shenzhen = 'mongodb.aliyuncs.com',
    cn-heyuan = 'mongodb.aliyuncs.com',
    cn-guangzhou = 'mongodb.aliyuncs.com',
    cn-chengdu = 'mongodb.cn-chengdu.aliyuncs.com',
    cn-hongkong = 'mongodb.aliyuncs.com',
    ap-northeast-1 = 'mongodb.ap-northeast-1.aliyuncs.com',
    ap-southeast-1 = 'mongodb.aliyuncs.com',
    ap-southeast-2 = 'mongodb.ap-southeast-2.aliyuncs.com',
    ap-southeast-3 = 'mongodb.ap-southeast-3.aliyuncs.com',
    ap-southeast-5 = 'mongodb.ap-southeast-5.aliyuncs.com',
    us-east-1 = 'mongodb.us-east-1.aliyuncs.com',
    us-west-1 = 'mongodb.us-west-1.aliyuncs.com',
    eu-west-1 = 'mongodb.eu-west-1.aliyuncs.com',
    eu-central-1 = 'mongodb.eu-central-1.aliyuncs.com',
    ap-south-1 = 'mongodb.ap-south-1.aliyuncs.com',
    me-east-1 = 'mongodb.me-east-1.aliyuncs.com',
    cn-hangzhou-finance = 'mongodb.aliyuncs.com',
    cn-shanghai-finance-1 = 'mongodb.aliyuncs.com',
    cn-shenzhen-finance-1 = 'mongodb.aliyuncs.com',
    cn-north-2-gov-1 = 'mongodb.aliyuncs.com',
    ap-northeast-2-pop = 'mongodb.aliyuncs.com',
    cn-beijing-finance-1 = 'mongodb.aliyuncs.com',
    cn-beijing-finance-pop = 'mongodb.aliyuncs.com',
    cn-beijing-gov-1 = 'mongodb.aliyuncs.com',
    cn-beijing-nu16-b01 = 'mongodb.aliyuncs.com',
    cn-edge-1 = 'mongodb.aliyuncs.com',
    cn-fujian = 'mongodb.aliyuncs.com',
    cn-haidian-cm12-c01 = 'mongodb.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'mongodb.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'mongodb.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'mongodb.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'mongodb.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'mongodb.aliyuncs.com',
    cn-hangzhou-test-306 = 'mongodb.aliyuncs.com',
    cn-hongkong-finance-pop = 'mongodb.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'mongodb.aliyuncs.com',
    cn-qingdao-nebula = 'mongodb.aliyuncs.com',
    cn-shanghai-et15-b01 = 'mongodb.aliyuncs.com',
    cn-shanghai-et2-b01 = 'mongodb.aliyuncs.com',
    cn-shanghai-inner = 'mongodb.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'mongodb.aliyuncs.com',
    cn-shenzhen-inner = 'mongodb.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'mongodb.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'mongodb.aliyuncs.com',
    cn-wuhan = 'mongodb.aliyuncs.com',
    cn-yushanfang = 'mongodb.aliyuncs.com',
    cn-zhangbei = 'mongodb.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'mongodb.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'mongodb.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'mongodb.aliyuncs.com',
    eu-west-1-oxs = 'mongodb.aliyuncs.com',
    rus-west-1-pop = 'mongodb.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('dds', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AllocateNodePrivateNetworkAddressRequest {
  accountName?: string(name='AccountName', description='The name of the account.

> * The name must be 4 to 16 characters in length and can contain lowercase letters, digits, and underscores (\\_). It must start with a lowercase letter.
> * You need to set the account name and password only when you apply for an endpoint for a shard or Configserver node for the first time. In this case, the account name and password are used for all shard and Configserver nodes.
> * The permissions of this account are fixed to read-only.', example='shardcsaccount'),
  accountPassword?: string(name='AccountPassword', description='The password of the account.

*   The password must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters. Special characters include `!#$%^&*()_+-=`
*   The password must be 8 to 32 characters in length.', example='Test123456'),
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the sharded cluster instance.', example='dds-bp1fa5efaa93****'),
  nodeId?: string(name='NodeId', description='The ID of the shard or Configserver node.

>  You can call the [DescribeDBInstanceAttribute](~~62010~~) operation to query the ID of the shard or Configserver node.', example='d-bp124beeb0ac****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  zoneId?: string(name='ZoneId', description='The zone ID of the instance.

>  You can call the [DescribeDBInstanceAttribute](~~62010~~) operation to query the zone ID of the instance.', example='cn-hangzhou-b'),
}

model AllocateNodePrivateNetworkAddressResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='60EEBD77-227C-5B39-86EA-D89163C5****'),
}

model AllocateNodePrivateNetworkAddressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AllocateNodePrivateNetworkAddressResponseBody(name='body'),
}

/**
  * This operation applies only to sharded cluster instances. For more information, see [Apply for an endpoint for a shard or Configserver node](~~134037~~).
  * >  The requested endpoint can only be accessed over the internal network. If you want to access the endpoint over the Internet, call the [AllocatePublicNetworkAddress](~~67602~~) operation to apply for a public endpoint.
  *
  * @param request AllocateNodePrivateNetworkAddressRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return AllocateNodePrivateNetworkAddressResponse
 */
async function allocateNodePrivateNetworkAddressWithOptions(request: AllocateNodePrivateNetworkAddressRequest, runtime: Util.RuntimeOptions): AllocateNodePrivateNetworkAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AllocateNodePrivateNetworkAddress',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * This operation applies only to sharded cluster instances. For more information, see [Apply for an endpoint for a shard or Configserver node](~~134037~~).
  * >  The requested endpoint can only be accessed over the internal network. If you want to access the endpoint over the Internet, call the [AllocatePublicNetworkAddress](~~67602~~) operation to apply for a public endpoint.
  *
  * @param request AllocateNodePrivateNetworkAddressRequest
  * @return AllocateNodePrivateNetworkAddressResponse
 */
async function allocateNodePrivateNetworkAddress(request: AllocateNodePrivateNetworkAddressRequest): AllocateNodePrivateNetworkAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateNodePrivateNetworkAddressWithOptions(request, runtime);
}

model AllocatePublicNetworkAddressRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance

> If you set this parameter to the ID of a sharded cluster instance, you must also specify the **NodeId** parameter.', example='dds-bp11483712c1****'),
  nodeId?: string(name='NodeId', description='The ID of the mongos, shard, or Configserver node in the sharded cluster instance. You can call the [DescribeDBInstanceAttribute](~~62010~~) operation to view the ID of the mongos, shard, or Configserver node.

> This parameter is required only when you specify the **DBInstanceId** parameter to the ID of a sharded cluster instance.', example='s-bp18e6d84ae3****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model AllocatePublicNetworkAddressResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='8AA45036-497F-52E7-B951-F9C7B239****'),
}

model AllocatePublicNetworkAddressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AllocatePublicNetworkAddressResponseBody(name='body'),
}

async function allocatePublicNetworkAddressWithOptions(request: AllocatePublicNetworkAddressRequest, runtime: Util.RuntimeOptions): AllocatePublicNetworkAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AllocatePublicNetworkAddress',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function allocatePublicNetworkAddress(request: AllocatePublicNetworkAddressRequest): AllocatePublicNetworkAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocatePublicNetworkAddressWithOptions(request, runtime);
}

model CheckCloudResourceAuthorizedRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bp18f7d6b6a7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  targetRegionId?: string(name='TargetRegionId', description='The region ID of the instance. You can call the [DescribeDBInstanceAttribute](~~62010~~) operation to query the region ID of the instance.', example='cn-hangzhou'),
}

model CheckCloudResourceAuthorizedResponseBody = {
  authorizationState?: int32(name='AuthorizationState', description='Indicates whether KMS keys are authorized to ApsaraDB for MongoDB instances. Valid values:

*   **0**: KMS keys are not authorized.
*   **1**: KMS keys are authorized.
*   **2**: KMS is not enabled.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A0181AC4-F186-46ED-87CA-100C70B86729'),
  roleArn?: string(name='RoleArn', description='The role information of the authorized Alibaba Resource Name (ARN).

>  This parameter is returned only when the value of the **AuthorizationState** parameter is **1**.', example='acs:ram::140****:role/aliyunrdsinstanceencryptiondefaultrole'),
}

model CheckCloudResourceAuthorizedResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckCloudResourceAuthorizedResponseBody(name='body'),
}

/**
  * Before you enable Transparent Data Encryption (TDE) by calling the [ModifyDBInstanceTDE](~~131267~~) operation, you can call this operation to check whether KMS keys are authorized to ApsaraDB for MongoDB instances.
  *
  * @param request CheckCloudResourceAuthorizedRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CheckCloudResourceAuthorizedResponse
 */
async function checkCloudResourceAuthorizedWithOptions(request: CheckCloudResourceAuthorizedRequest, runtime: Util.RuntimeOptions): CheckCloudResourceAuthorizedResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.targetRegionId)) {
    query['TargetRegionId'] = request.targetRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckCloudResourceAuthorized',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you enable Transparent Data Encryption (TDE) by calling the [ModifyDBInstanceTDE](~~131267~~) operation, you can call this operation to check whether KMS keys are authorized to ApsaraDB for MongoDB instances.
  *
  * @param request CheckCloudResourceAuthorizedRequest
  * @return CheckCloudResourceAuthorizedResponse
 */
async function checkCloudResourceAuthorized(request: CheckCloudResourceAuthorizedRequest): CheckCloudResourceAuthorizedResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkCloudResourceAuthorizedWithOptions(request, runtime);
}

model CheckRecoveryConditionRequest {
  backupId?: string(name='BackupId', description='The point in time to which the instance is restored. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

> * The value can be any time within the past seven days. The time must be earlier than the current time, but later than the time when the instance was created.
> * You must specify one of the RestoreTime and **BackupId** parameters.', example='5664****'),
  databaseNames?: string(name='DatabaseNames', description='The ID of the source instance.', example='["db1","db2"]'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the backup.

> * You can call the [DescribeBackups](~~62172~~) operation to query the ID of the backup.
> * You must specify one of the **RestoreTime** and BackupId parameters.
> * This parameter is not applicable to sharded cluster instances.', example='sg-bp179****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restoreTime?: string(name='RestoreTime', description='The name of the source database. The value is a JSON array.

>  If you do not specify this parameter, all databases are restored.', example='2022-08-22T08:00:00Z'),
  securityToken?: string(name='SecurityToken'),
  sourceDBInstance?: string(name='SourceDBInstance', description='The operation that you want to perform. Set the value to **CheckRecoveryCondition**.', example='dds-bp1378****'),
}

model CheckRecoveryConditionResponseBody = {
  DBInstanceName?: string(name='DBInstanceName', description='The ID of the request.', example='dds-bp1378****'),
  isValid?: boolean(name='IsValid', description='The ID of the instance.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the resource group.', example='D563A3E7-6010-45FE-A0CD-9283414C9657'),
}

model CheckRecoveryConditionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckRecoveryConditionResponseBody(name='body'),
}

/**
  * You can call this operation to check whether an ApsaraDB for MongoDB instance meets the data recovery conditions.
  *
  * @param request CheckRecoveryConditionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CheckRecoveryConditionResponse
 */
async function checkRecoveryConditionWithOptions(request: CheckRecoveryConditionRequest, runtime: Util.RuntimeOptions): CheckRecoveryConditionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.databaseNames)) {
    query['DatabaseNames'] = request.databaseNames;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.restoreTime)) {
    query['RestoreTime'] = request.restoreTime;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.sourceDBInstance)) {
    query['SourceDBInstance'] = request.sourceDBInstance;
  }
  if (!Util.isUnset(request.sourceDBInstance)) {
    query['SourceDBInstance'] = request.sourceDBInstance;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckRecoveryCondition',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this operation to check whether an ApsaraDB for MongoDB instance meets the data recovery conditions.
  *
  * @param request CheckRecoveryConditionRequest
  * @return CheckRecoveryConditionResponse
 */
async function checkRecoveryCondition(request: CheckRecoveryConditionRequest): CheckRecoveryConditionResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkRecoveryConditionWithOptions(request, runtime);
}

model CreateBackupRequest {
  backupMethod?: string(name='BackupMethod', description='The backup method of the instance. Default value: Physical. Valid values:

*   **Logical**
*   **Physical**

>  Only replica set instances and sharded cluster instances support this parameter. You do not need to specify this parameter for standalone instances. All standalone instances use snapshot backup.', example='Logical'),
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='d-bp2235****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model CreateBackupResponseBody = {
  backupId?: string(name='BackupId', description='The ID of the backup set.', example='5664****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='7016B12F-7F64-40A4-BAFF-013F02AC82FC'),
}

model CreateBackupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBackupResponseBody(name='body'),
}

/**
  * ## Usage
  * When you call this operation, the instance must be in the Running state.
  *
  * @param request CreateBackupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateBackupResponse
 */
async function createBackupWithOptions(request: CreateBackupRequest, runtime: Util.RuntimeOptions): CreateBackupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupMethod)) {
    query['BackupMethod'] = request.backupMethod;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBackup',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ## Usage
  * When you call this operation, the instance must be in the Running state.
  *
  * @param request CreateBackupRequest
  * @return CreateBackupResponse
 */
async function createBackup(request: CreateBackupRequest): CreateBackupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBackupWithOptions(request, runtime);
}

model CreateDBInstanceRequest {
  accountPassword?: string(name='AccountPassword', description='The network type of the instance. Set the value to VPC.', example='123456Aa'),
  autoRenew?: string(name='AutoRenew', description='The storage engine of the instance. Default value: WiredTiger. Valid values:

*   **WiredTiger**
*   **RocksDB**
*   **TerarkDB**

>  *   When you call this operation to clone an instance or restore an instance from the recycle bin, set the value of this parameter to the storage engine of the source instance.
>  *   For more information about the limits on database versions and storage engines, see [MongoDB versions and storage engines](~~61906~~).', example='true'),
  backupId?: string(name='BackupId', description='Specifies whether to enable auto-renewal for the instance. Default value: false. Valid values:

*   **true**: The instance is automatically renewed.
*   **false**: The instance is manually renewed.

> This parameter is valid and optional when the **ChargeType** parameter is set to **PrePaid**.', example='32994****'),
  businessInfo?: string(name='BusinessInfo', description='The coupon code. Default value: `youhuiquan_promotion_option_id_for_blank`.', example='{“ActivityId":"000000000"}'),
  chargeType?: string(name='ChargeType', description='The ID of the VPC.', example='PrePaid'),
  clientToken?: string(name='ClientToken', description='The version of the database engine. Valid values:

*   **6.0**
*   **5.0**
*   **4.4**
*   **4.2**
*   **4.0**

> When you call this operation to clone an instance or restore an instance from the recycle bin, set the value of this parameter to the engine version of the source instance.', example='ETnLKlblzczshOTUbOCz****'),
  clusterId?: string(name='ClusterId', description='cn', example='dhg-2x78****'),
  couponNo?: string(name='CouponNo', description='The number of **read-only nodes** in the replica set instance. Default value: **0**. Valid values: **0** to **5**.', example='youhuiquan_promotion_option_id_for_blank'),
  DBInstanceClass?: string(name='DBInstanceClass', description='The IP addresses in an IP address whitelist. Multiple IP addresses are separated by commas (,), and each IP address in the IP address whitelist must be unique. The following types of values are supported:

*   0.0.0.0/0
*   IP addresses, such as 10.23.12.24.
*   Classless Inter-Domain Routing (CIDR) blocks, such as 10.23.12.0/24. In this case, /24 indicates that the prefix of each IP address is 24-bit long. You can replace 24 with a value within the range of 1 to 32.

> *   A maximum of 1,000 IP addresses or CIDR blocks can be configured for each instance.
> *   If you enter 0.0.0.0/0, all IP addresses can access the instance. This may introduce security risks to the instance. Proceed with caution.', example='dds.mongo.standard'),
  DBInstanceDescription?: string(name='DBInstanceDescription', description='The billing method of the instance. Valid values:

*   **PostPaid**: pay-as-you-go. This is the default value.
*   **PrePaid**: subscription.

> If you set this parameter to **PrePaid**, you must also specify the **Period** parameter.', example='test'),
  DBInstanceStorage?: int32(name='DBInstanceStorage', description='The password of the root account. The password must meet the following requirements:

*   The password must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters.
*   Special characters include ! # $ % ^ & \\* ( ) \\_ + - =
*   The password of the account must be 8 to 32 characters in length.', example='10'),
  databaseNames?: string(name='DatabaseNames', description='The number of **nodes** in the replica set instance. Default value: 3. Valid values:

*   **3**
*   **5**
*   **7**', example='mongodbtest'),
  encrypted?: boolean(name='Encrypted'),
  encryptionKey?: string(name='EncryptionKey'),
  engine?: string(name='Engine', description='The storage capacity of the instance. Unit: GB.

The values that can be specified for this parameter vary based on the instance types. For more information, see [Replica set instance types](~~311410~~).', example='MongoDB'),
  engineVersion?: string(name='EngineVersion', description='The name of the instance. The name of the instance must meet the following requirements:

*   The name must start with a letter.
*   The name can contain digits, letters, underscores (\\_), and hyphens (-).
*   The name must be 2 to 256 characters in length.', example='4.4'),
  globalSecurityGroupIds?: string(name='GlobalSecurityGroupIds', description='The ID of the request.', example='g-qxieqf40xjst1ngpr3jz'),
  hiddenZoneId?: string(name='HiddenZoneId', description='Template for global IP whitelist of the instance, multiple IP whitelist templates should be separated by a comma (,) in English and cannot be repeated. (In function gray scale).', example='cn-hangzhou-i'),
  networkType?: string(name='NetworkType', description='The ID of the source instance.

> When you call this operation to clone an instance, this parameter is required. The **BackupId** or **RestoreTime** parameter is also required. When you call this operation to restore an instance from the recycle bin, this parameter is required. The **BackupId** or **RestoreTime** parameter is not required.', example='VPC'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: int32(name='Period', description='The ID of the vSwitch to which the instance is connected.', example='1'),
  provisionedIops?: long(name='ProvisionedIops'),
  readonlyReplicas?: string(name='ReadonlyReplicas', description='The storage type of the instance. Valid values:

*   **cloud_essd1** :ESSD PL1.
*   **cloud_essd2**: ESSD PL2.
*   **cloud_essd3**: ESSD PL3.
*   **local_ssd**: local SSD.', example='0'),
  regionId?: string(name='RegionId', description='The database engine of the instance. The value is fixed as **MongoDB**.', example='cn-hangzhou'),
  replicationFactor?: string(name='ReplicationFactor', description='The ID of the dedicated cluster to which the instance belongs.', example='3'),
  resourceGroupId?: string(name='ResourceGroupId', description='The zone where the secondary node resides for multi-zone deployment. Valid values:

*   **cn-hangzhou-g**: Hangzhou Zone G.
*   **cn-hangzhou-h**: Hangzhou Zone H.
*   **cn-hangzhou-i**: Hangzhou Zone I.
*   **cn-hongkong-b**: Hongkong Zone B.
*   **cn-hongkong-c**: Hongkong Zone C.
*   **cn-hongkong-d**: Hongkong Zone D.
*   **cn-wulanchabu-a**: Ulanqab Zone A.
*   **cn-wulanchabu-b**: Ulanqab Zone B.
*   **cn-wulanchabu-c**: Ulanqab Zone C.
*   **ap-southeast-1a**: Singapore Zone A.
*   **ap-southeast-1b**: Singapore Zone B.
*   **ap-southeast-1c**: Singapore Zone C.
*   **ap-southeast-5a**: Jakarta Zone A.
*   **ap-southeast-5b**: Jakarta Zone B.
*   **ap-southeast-5c**: Jakarta Zone C.
*   **eu-central-1a**: Frankfurt Zone A.
*   **eu-central-1b**: Frankfurt Zone B.
*   **eu-central-1c**: Frankfurt Zone C.

>  *   This parameter is valid and required when the **EngineVersion** parameter is set to **4.4** or **5.0**.
>  *   The value of this parameter cannot be the same as the value of the **ZoneId** or **HiddenZoneId** parameter.', example='rg-acfmyiu4ekp****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restoreTime?: string(name='RestoreTime', description='The name of the database.

> When you call this operation to clone an instance, you can set this parameter to specify the database to clone. Otherwise, all databases of the instance are cloned.', example='2022-03-13T12:11:14Z'),
  secondaryZoneId?: string(name='SecondaryZoneId', description='cn', example='cn-hangzhou-h'),
  securityIPList?: string(name='SecurityIPList', description='The subscription period of the instance. Unit: months.

Valid values: **1** to **9**, **12**, **24**, **36**, and **60**.

> When you set the **ChargeType** parameter to **PrePaid**, this parameter is valid and required.', example='192.168.xx.xx,192.168.xx.xx'),
  securityToken?: string(name='SecurityToken'),
  srcDBInstanceId?: string(name='SrcDBInstanceId', description='The business information. This is an additional parameter.', example='dds-bp1ee12ad351****'),
  storageEngine?: string(name='StorageEngine', description='The ID of the resource group to which the instance belongs.', example='WiredTiger'),
  storageType?: string(name='StorageType', description='The zone where the hidden node resides for multi-zone deployment. Valid values:

*   **cn-hangzhou-g**: Hangzhou Zone G.
*   **cn-hangzhou-h**: Hangzhou Zone H.
*   **cn-hangzhou-i**: Hangzhou Zone I.
*   **cn-hongkong-b**: Hongkong Zone B.
*   **cn-hongkong-c**: Hongkong Zone C.
*   **cn-hongkong-d**: Hongkong Zone D.
*   **cn-wulanchabu-a**: Ulanqab Zone A.
*   **cn-wulanchabu-b**: Ulanqab Zone B.
*   **cn-wulanchabu-c**: Ulanqab Zone C.
*   **ap-southeast-1a**: Singapore Zone A.
*   **ap-southeast-1b**: Singapore Zone B.
*   **ap-southeast-1c**: Singapore Zone C.
*   **ap-southeast-5a**: Jakarta Zone A.
*   **ap-southeast-5b**: Jakarta Zone B.
*   **ap-southeast-5c**: Jakarta Zone C.
*   **eu-central-1a**: Frankfurt Zone A.
*   **eu-central-1b**: Frankfurt Zone B.
*   **eu-central-1c**: Frankfurt Zone C.

>  *   This parameter is valid and required when the **EngineVersion** parameter is set to **4.4** or **5.0**.
>  *   The value of this parameter cannot be the same as the value of the **ZoneId** or **SecondaryZoneId** parameter.', example='cloud_essd1'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  vSwitchId?: string(name='VSwitchId', description='The point in time to which the instance is restored, which must be within seven days. The time is displayed in the *yyyy-MM-dd*T*HH:mm:ss*Z format (UTC time).

> When you call this operation to restore an instance to the specified time, this parameter is required. The **SrcDBInstanceId** parameter is also required.', example='vsw-bp1gzt31twhlo0sa5****'),
  vpcId?: string(name='VpcId', description='The ID of the backup set. You can call the [DescribeBackups](~~62172~~) operation to query the backup set ID.

> When you call this operation to clone an instance based on the backup set, this parameter is required. The **SrcDBInstanceId** parameter is also required.', example='vpc-bp175iuvg8nxqraf2****'),
  zoneId?: string(name='ZoneId', description='The instance type. You can also call the [DescribeAvailableResource](~~149719~~) operation to query the instance type.', example='cn-hangzhou-g'),
}

model CreateDBInstanceResponseBody = {
  DBInstanceId?: string(name='DBInstanceId', description='data.dbInstanceId', example='dds-bp144a7f2db8****'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='21077576248****'),
  requestId?: string(name='RequestId', description='The ID of the instance.', example='D8F1D721-6439-4257-A89C-F1E8E9C9****'),
}

model CreateDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDBInstanceResponseBody(name='body'),
}

/**
  * Creates or clones an ApsaraDB for MongoDB replica set instance.
  *
  * @param request CreateDBInstanceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateDBInstanceResponse
 */
async function createDBInstanceWithOptions(request: CreateDBInstanceRequest, runtime: Util.RuntimeOptions): CreateDBInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.businessInfo)) {
    query['BusinessInfo'] = request.businessInfo;
  }
  if (!Util.isUnset(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.couponNo)) {
    query['CouponNo'] = request.couponNo;
  }
  if (!Util.isUnset(request.DBInstanceClass)) {
    query['DBInstanceClass'] = request.DBInstanceClass;
  }
  if (!Util.isUnset(request.DBInstanceDescription)) {
    query['DBInstanceDescription'] = request.DBInstanceDescription;
  }
  if (!Util.isUnset(request.DBInstanceStorage)) {
    query['DBInstanceStorage'] = request.DBInstanceStorage;
  }
  if (!Util.isUnset(request.databaseNames)) {
    query['DatabaseNames'] = request.databaseNames;
  }
  if (!Util.isUnset(request.encrypted)) {
    query['Encrypted'] = request.encrypted;
  }
  if (!Util.isUnset(request.encryptionKey)) {
    query['EncryptionKey'] = request.encryptionKey;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.globalSecurityGroupIds)) {
    query['GlobalSecurityGroupIds'] = request.globalSecurityGroupIds;
  }
  if (!Util.isUnset(request.hiddenZoneId)) {
    query['HiddenZoneId'] = request.hiddenZoneId;
  }
  if (!Util.isUnset(request.networkType)) {
    query['NetworkType'] = request.networkType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.provisionedIops)) {
    query['ProvisionedIops'] = request.provisionedIops;
  }
  if (!Util.isUnset(request.readonlyReplicas)) {
    query['ReadonlyReplicas'] = request.readonlyReplicas;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.replicationFactor)) {
    query['ReplicationFactor'] = request.replicationFactor;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.restoreTime)) {
    query['RestoreTime'] = request.restoreTime;
  }
  if (!Util.isUnset(request.secondaryZoneId)) {
    query['SecondaryZoneId'] = request.secondaryZoneId;
  }
  if (!Util.isUnset(request.securityIPList)) {
    query['SecurityIPList'] = request.securityIPList;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.srcDBInstanceId)) {
    query['SrcDBInstanceId'] = request.srcDBInstanceId;
  }
  if (!Util.isUnset(request.storageEngine)) {
    query['StorageEngine'] = request.storageEngine;
  }
  if (!Util.isUnset(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDBInstance',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Creates or clones an ApsaraDB for MongoDB replica set instance.
  *
  * @param request CreateDBInstanceRequest
  * @return CreateDBInstanceResponse
 */
async function createDBInstance(request: CreateDBInstanceRequest): CreateDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDBInstanceWithOptions(request, runtime);
}

model CreateGlobalSecurityIPGroupRequest {
  GIpList?: string(name='GIpList', example='27.18.86.18,183.92.40.129'),
  globalIgName?: string(name='GlobalIgName', example='aizy'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model CreateGlobalSecurityIPGroupResponseBody = {
  globalSecurityIPGroup?: [ 
    {
      GIpList?: string(name='GIpList', example='111.207.194.217,61.149.7.154'),
      globalIgName?: string(name='GlobalIgName', example='developer'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', example='g-2ifynl1jfkdlhhxgva3q'),
      regionId?: string(name='RegionId', example='cn-hangzhou'),
    }
  ](name='GlobalSecurityIPGroup'),
  requestId?: string(name='RequestId', example='F8CA8312-530A-413A-9129-F2BB32A8D404'),
}

model CreateGlobalSecurityIPGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGlobalSecurityIPGroupResponseBody(name='body'),
}

async function createGlobalSecurityIPGroupWithOptions(request: CreateGlobalSecurityIPGroupRequest, runtime: Util.RuntimeOptions): CreateGlobalSecurityIPGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.GIpList)) {
    query['GIpList'] = request.GIpList;
  }
  if (!Util.isUnset(request.globalIgName)) {
    query['GlobalIgName'] = request.globalIgName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGlobalSecurityIPGroup',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGlobalSecurityIPGroup(request: CreateGlobalSecurityIPGroupRequest): CreateGlobalSecurityIPGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGlobalSecurityIPGroupWithOptions(request, runtime);
}

model CreateNodeRequest {
  accountName?: string(name='AccountName', description='The username of the account. The username must meet the following requirements:

* The username starts with a lowercase letter.
* The username contains lowercase letters, digits, and underscores (\\_).
* The username is 4 to 16 characters in length.

> * Keywords cannot be used as account usernames.
> * The permissions of this account are fixed at read-only.
> * The username and password are required to be set only when you apply for an endpoint for the shard node for the first time.', example='ceshi'),
  accountPassword?: string(name='AccountPassword', description='The password of the account. The password must meet the following requirements:

* The password contains at least three of the following character types: uppercase letters, lowercase letters, digits, and specific special characters.
* These special characters include ! @ # $ % ^ & \\* ( ) \\_ + - =
* The password is 8 to 32 characters in length.

>  The account password of the shard node cannot be reset.', example='123+abc'),
  autoPay?: boolean(name='AutoPay', description='Specifies whether to enable automatic payment. Default value: true. Valid values:

*   **true**: enables automatic payment. Make sure that you have sufficient balance within your account.
*   **false**: disables automatic payment. You can perform the following operations to pay for the instance: Log on to the ApsaraDB for MongoDB console. In the upper-right corner of the page, choose **Expenses** > **Orders**. On the **Orders** page, find the order and complete the payment.********

>  This parameter is required when the billing method of the instance is subscription.', example='true'),
  businessInfo?: string(name='BusinessInfo', description='The business information. This is an additional parameter.', example='{“ActivityId":"000000000"}'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='ETnLKlblzczshOTUbOCz****'),
  couponNo?: string(name='CouponNo', description='The coupon code. Default value: **youhuiquan\\_promotion\\_option\\_id\\_for\\_blank**.', example='youhuiquan_promotion_option_id_for_blank'),
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the sharded cluster instance.', example='dds-bp11501cd7b5****'),
  nodeClass?: string(name='NodeClass', description='The specifications of the shard or mongos node. For more information, see [Instance types](~~57141~~).', example='dds.shard.mid'),
  nodeStorage?: int32(name='NodeStorage', description='The disk capacity of the node. Unit: GB.

Valid values: **10** to **2000**. The value must be a multiple of 10. Unit: GB.

>  This parameter is required if the NodeType parameter is set to **shard**.', example='10'),
  nodeType?: string(name='NodeType', description='The type of the node. Valid values:

*   **shard**: shard node
*   **mongos**: mongos node', example='shard'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  readonlyReplicas?: int32(name='ReadonlyReplicas', description='The number of read-only nodes in the shard node.

Valid values: **0** to **5**. The value must be an integer. Default value: **0**.

>  This parameter is available only for ApsaraDB for MongoDB instances that are purchased on the China site (aliyun.com).', example='5'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  shardDirect?: boolean(name='ShardDirect', description='Specifies whether to apply for an endpoint for the shard node. Default value: false. Valid values:

*   **true**: applies for an endpoint for the shard node.
*   **false** : does not apply for an endpoint for the shard node.', example='false'),
}

model CreateNodeResponseBody = {
  nodeId?: string(name='NodeId', description='The ID of the node.', example='d-bp1b234bf7a4****'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='20951063702****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='7D48FB19-20CA-4725-A870-3D8F5CE6****'),
}

model CreateNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateNodeResponseBody(name='body'),
}

/**
  * Before you call this operation, make sure that you fully understand the billing methods and [pricing](https://www.alibabacloud.com/zh/product/apsaradb-for-mongodb/pricing) of ApsaraDB for MongoDB.
  * This operation is applicable only to sharded cluster instances.
  *
  * @param request CreateNodeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateNodeResponse
 */
async function createNodeWithOptions(request: CreateNodeRequest, runtime: Util.RuntimeOptions): CreateNodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.businessInfo)) {
    query['BusinessInfo'] = request.businessInfo;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.couponNo)) {
    query['CouponNo'] = request.couponNo;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.nodeClass)) {
    query['NodeClass'] = request.nodeClass;
  }
  if (!Util.isUnset(request.nodeStorage)) {
    query['NodeStorage'] = request.nodeStorage;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['NodeType'] = request.nodeType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.readonlyReplicas)) {
    query['ReadonlyReplicas'] = request.readonlyReplicas;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.shardDirect)) {
    query['ShardDirect'] = request.shardDirect;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNode',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, make sure that you fully understand the billing methods and [pricing](https://www.alibabacloud.com/zh/product/apsaradb-for-mongodb/pricing) of ApsaraDB for MongoDB.
  * This operation is applicable only to sharded cluster instances.
  *
  * @param request CreateNodeRequest
  * @return CreateNodeResponse
 */
async function createNode(request: CreateNodeRequest): CreateNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNodeWithOptions(request, runtime);
}

model CreateNodeBatchRequest {
  accountName?: string(name='AccountName', example='ceshi'),
  accountPassword?: string(name='AccountPassword', example='123+abc'),
  autoPay?: boolean(name='AutoPay', example='true'),
  businessInfo?: string(name='BusinessInfo', example='{“ActivityId":"000000000"}'),
  clientToken?: string(name='ClientToken', description='The ID of the added mongos or shard node.', example='ETnLKlblzczshOTUbOCz****'),
  couponNo?: string(name='CouponNo', example='youhuiquan_promotion_option_id_for_blank'),
  DBInstanceId?: string(name='DBInstanceId', example='dds-bp18b0934e70****'),
  fromApp?: string(name='FromApp', example='OpenApi'),
  nodesInfo?: string(name='NodesInfo'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  shardDirect?: boolean(name='ShardDirect', example='false'),
}

model CreateNodeBatchResponseBody = {
  nodeId?: string(name='NodeId', example='d-bp18f7d6b6a7****'),
  orderId?: string(name='OrderId', example='50179021707****'),
  requestId?: string(name='RequestId', example='55D41A94-1ACE-55E8-8BC7-67D622E7****'),
}

model CreateNodeBatchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateNodeBatchResponseBody(name='body'),
}

/**
  * The ID of the request.
  *
  * @param request CreateNodeBatchRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateNodeBatchResponse
 */
async function createNodeBatchWithOptions(request: CreateNodeBatchRequest, runtime: Util.RuntimeOptions): CreateNodeBatchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.businessInfo)) {
    query['BusinessInfo'] = request.businessInfo;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.couponNo)) {
    query['CouponNo'] = request.couponNo;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.fromApp)) {
    query['FromApp'] = request.fromApp;
  }
  if (!Util.isUnset(request.nodesInfo)) {
    query['NodesInfo'] = request.nodesInfo;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.shardDirect)) {
    query['ShardDirect'] = request.shardDirect;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNodeBatch',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The ID of the request.
  *
  * @param request CreateNodeBatchRequest
  * @return CreateNodeBatchResponse
 */
async function createNodeBatch(request: CreateNodeBatchRequest): CreateNodeBatchResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNodeBatchWithOptions(request, runtime);
}

model CreateShardingDBInstanceRequest {
  accountPassword?: string(name='AccountPassword', description='The password of the root account. The password must meet the following requirements:

*   The password must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters.
*   The special characters include ! # $ % ^ & \\* ( ) \\_ + - =
*   The password of the account must be 8 to 32 characters in length.', example='123456Aa'),
  autoRenew?: string(name='AutoRenew', description='Specifies whether to enable auto-renewal for the instance. Valid values:

*   **true**
*   **false** (default)

> This parameter is available and optional if you set the value of **ChargeType** to **PrePaid**.', example='true'),
  chargeType?: string(name='ChargeType', description='The billing method of the instance. Valid values:

*   **PostPaid** (default): pay-as-you-go
*   **PrePaid**: subscription

> **Period** is required if you set the value of this parameter to **PrePaid**.', example='PrePaid'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='ETnLKlblzczshOTUbOCz****'),
  configServer?: [ 
    {
      class?: string(name='Class', description='The instance type of the ConfigServer node. Valid values:

*   **mdb.shard.2x.xlarge.d**: 4 cores, 8 GB (dedicated). Only instances that run MongoDB 4.4 and later support this instance type.
*   **dds.cs.mid** :1 core, 2 GB (general-purpose). Only instances that run MongoDB 4.2 and earlier support this instance type.', example='mdb.shard.2x.xlarge.d'),
      storage?: int32(name='Storage', description='The storage space of the ConfigServer node. Unit: GB.

> The values that can be specified for this parameter vary based on the instance types. For more information, see [Sharded cluster instance types](~~311414~~).', example='20'),
    }
  ](name='ConfigServer', description='The ConfigServer nodes of the instance.'),
  DBInstanceDescription?: string(name='DBInstanceDescription', description='The name of the instance. The name of the instance must meet the following requirements:

*   The name must start with a letter.
*   It can contain digits, letters, underscores (\\_), and hyphens (-).
*   It must be 2 to 256 characters in length.', example='test'),
  encrypted?: boolean(name='Encrypted', description='Specifies whether to encrypt the disk. Valid values:

*   true
*   false

Default value: false.', example='true'),
  encryptionKey?: string(name='EncryptionKey', description='The ID of the custom key.', example='2axxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'),
  engine?: string(name='Engine', description='The database engine of the instance. Set the value to **MongoDB**.', example='MongoDB'),
  engineVersion?: string(name='EngineVersion', description='The version of the database engine. Valid values:

*   **6.0**
*   **5.0**
*   **4.4**
*   **4.2**
*   **4.0**
*   **3.4**

> 

*   For more information about the limits on database versions and storage engines, see [MongoDB versions and storage engines](~~61906~~).

*   If you call this operation to clone an instance, set the value of this parameter to the engine version of the source instance.', example='4.4'),
  globalSecurityGroupIds?: string(name='GlobalSecurityGroupIds', description='实例的全局IP白名单模板，多个IP白名单模板请用英文逗号（,）分隔，不可重复。', example='g-qxieqf40xjst1ngpr3jz'),
  hiddenZoneId?: string(name='HiddenZoneId', description='The ID of secondary zone 2 for multi-zone deployment. Valid values:

*   **cn-hangzhou-g**: Hangzhou Zone G
*   **cn-hangzhou-h**: Hangzhou Zone H
*   **cn-hangzhou-i**: Hangzhou Zone I
*   **cn-hongkong-b**: Hong Kong Zone B
*   **cn-hongkong-c**: Hong Kong Zone C
*   **cn-hongkong-d**: Hong Kong Zone D
*   **cn-wulanchabu-a**: Ulanqab Zone A
*   **cn-wulanchabu-b**: Ulanqab Zone B
*   **cn-wulanchabu-c**: Ulanqab Zone C
*   **ap-southeast-1a**: Singapore Zone A
*   **ap-southeast-1b**: Singapore Zone B
*   **ap-southeast-1c**: Singapore Zone C
*   **ap-southeast-5a**: Jakarta Zone A
*   **ap-southeast-5b**: Jakarta Zone B
*   **ap-southeast-5c**: Jakarta Zone C
*   **eu-central-1a**: Frankfurt Zone A
*   **eu-central-1b**: Frankfurt Zone B
*   **eu-central-1c**: Frankfurt Zone C

> 

*   This parameter is available and required if you set the value of **EngineVersion** to **4.4** or **5.0**.

*   The value of this parameter cannot be the same as the value of **ZoneId** or **SecondaryZoneId**.

*   For more information about the multi-zone deployment policy of a sharded cluster instance, see [Create a multi-zone sharded cluster instance](~~117865~~).', example='cn-hangzhou-i'),
  mongos?: [ 
    {
      class?: string(name='Class', description='The instance type of the mongos node. For more information, see [Sharded cluster instance types](~~311414~~).

> 

*   **N** specifies the serial number of the mongos node for which the instance type is specified. For example, **Mongos.2.Class** specifies the instance type of the second mongos node.

*   Valid values for **N**: **2** to **32**.', example='mdb.shard.2x.xlarge.d'),
    }
  ](name='Mongos', description='The mongos nodes of the instance.'),
  networkType?: string(name='NetworkType', description='The network type of the instance. Set the value to VPC.

****', example='VPC'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: int32(name='Period', description='The subscription period of the instance. Unit: month.

Valid values: 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 24, 36, and 60************************

> This parameter is available and required if you set the value of **ChargeType** to **PrePaid**.', example='1'),
  protocolType?: string(name='ProtocolType', description='The access protocol type of the instance. Valid values:

*   **mongodb**: the MongoDB protocol
*   **dynamodb**: the DynamoDB protocol', example='mongodb'),
  provisionedIops?: long(name='ProvisionedIops'),
  regionId?: string(name='RegionId', description='The region ID of the instance. You can call the [DescribeRegions](~~61933~~) operation to query the most recent region list.', example='cn-hangzhou'),
  replicaSet?: [ 
    {
      class?: string(name='Class', description='The instance type of the shard node. For more information, see [Sharded cluster instance types](~~311414~~).

> 

*   **N** specifies the serial number of the shard node for which the instance type is specified. For example, **ReplicaSet.2.Class** specifies the instance type of the second shard node.

*   Valid values for **N**: **2** to **32**.', example='dds.shard.standard'),
      readonlyReplicas?: int32(name='ReadonlyReplicas', description='The number of read-only nodes in shard node N.

Valid values: **0** to **5**. Default value: **0**.

> **N** specifies the serial number of the shard node for which you want to set the number of read-only nodes. For example, **ReplicaSet.2.ReadonlyReplicas** specifies the number of read-only nodes in the second shard node.', example='0'),
      storage?: int32(name='Storage', description='The storage space of the shard node. Unit: GB.

> 

*   The values that can be specified for this parameter vary based on the instance types. For more information, see [Sharded cluster instance types](~~311414~~).

*   **N** specifies the serial number of the shard node for which the storage space is specified. For example, **ReplicaSet.2.Storage** specifies the storage space of the second shard node.', example='10'),
    }
  ](name='ReplicaSet', description='The shard nodes of the instance.'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID. For more information, see [View the basic information of a resource group](~~151181~~).', example='rg-acfmyiu4ekp****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restoreTime?: string(name='RestoreTime', description='The point in time to restore the instance, which must be within seven days. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in Coordinated Universal Time (UTC).

> This parameter is required only if you call this operation to clone an instance. If you specify this parameter, you must also specify **SrcDBInstanceId**.', example='2022-03-08T02:30:25Z'),
  secondaryZoneId?: string(name='SecondaryZoneId', description='The ID of secondary zone 1 for multi-zone deployment. Valid values:

*   **cn-hangzhou-g**: Hangzhou Zone G
*   **cn-hangzhou-h**: Hangzhou Zone H
*   **cn-hangzhou-i**: Hangzhou Zone I
*   **cn-hongkong-b**: Hong Kong Zone B
*   **cn-hongkong-c**: Hong Kong Zone C
*   **cn-hongkong-d**: Hong Kong Zone D
*   **cn-wulanchabu-a**: Ulanqab Zone A
*   **cn-wulanchabu-b**: Ulanqab Zone B
*   **cn-wulanchabu-c**: Ulanqab Zone C
*   **ap-southeast-1a**: Singapore Zone A
*   **ap-southeast-1b**: Singapore Zone B
*   **ap-southeast-1c**: Singapore Zone C
*   **ap-southeast-5a**: Jakarta Zone A
*   **ap-southeast-5b**: Jakarta Zone B
*   **ap-southeast-5c**: Jakarta Zone C
*   **eu-central-1a**: Frankfurt Zone A
*   **eu-central-1b**: Frankfurt Zone B
*   **eu-central-1c**: Frankfurt Zone C

> 

*   This parameter is available and required if you set the value of **EngineVersion** to **4.4** or **5.0**.

*   The value of this parameter cannot be the same as the value of **ZoneId** or **HiddenZoneId**.
*   For more information about the multi-zone deployment policy of a sharded cluster instance, see [Create a multi-zone sharded cluster instance](~~117865~~).', example='cn-hangzhou-h'),
  securityIPList?: string(name='SecurityIPList', description='The IP addresses in an IP address whitelist of the instance. Multiple IP addresses are separated by commas (,), and each IP address in the IP address whitelist must be unique. The following types of values are supported:

*   0.0.0.0/0
*   IP addresses, such as 10.23.12.24.
*   CIDR blocks, such as 10.23.12.0/24. In this case, 24 indicates that the prefix of each IP address is 24-bit long. You can replace 24 with a value within the range of 1 to 32.

> 

*   A maximum of 1,000 IP addresses and CIDR blocks can be configured for each instance.

*   If you enter 0.0.0.0/0, all IP addresses can access the instance. This may introduce security risks to the instance. Proceed with caution.', example='192.168.xx.xx,192.168.xx.xx'),
  securityToken?: string(name='SecurityToken'),
  srcDBInstanceId?: string(name='SrcDBInstanceId', description='The source instance ID.

> This parameter is required only if you call this operation to clone an instance. If you specify this parameter, you must also specify **RestoreTime**.', example='dds-bp11483712c1****'),
  storageEngine?: string(name='StorageEngine', description='The storage engine of the instance. Set the value to **WiredTiger**.

> 

*   If you call this operation to clone an instance, set the value of this parameter to the storage engine of the source instance.

*   For more information about the limits on database versions and storage engines, see [MongoDB versions and storage engines](~~61906~~).', example='WiredTiger'),
  storageType?: string(name='StorageType', description='The storage type of the instance. Valid values:

*   **cloud_essd1**: ESSD PL1
*   **cloud_essd2**: ESSD PL2
*   **cloud_essd3**: ESSD PL3
*   **local_ssd**: local SSD

> 

*   Instances of MongoDB 4.4 and later support only cloud disks. **cloud_essd1** is selected if you leave this parameter empty.

*   Instances of MongoDB 4.2 and earlier support only local disks. **local_ssd** is selected if you leave this parameter empty.', example='cloud_essd1'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.', example='vsw-bp1vj604nj5a9zz74****'),
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-bp1n3i15v90el48nx****'),
  zoneId?: string(name='ZoneId', description='The zone ID of the instance. You can call the [DescribeRegions](~~61933~~) operation to query the most recent zone list.', example='cn-hangzhou-g'),
}

model CreateShardingDBInstanceResponseBody = {
  DBInstanceId?: string(name='DBInstanceId', description='The instance ID.', example='dds-bp114f14849d****'),
  orderId?: string(name='OrderId', description='The order ID.', example='21010996721****'),
  requestId?: string(name='RequestId', description='The request ID.', example='D8F1D721-6439-4257-A89C-F1E8E9C9****'),
}

model CreateShardingDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateShardingDBInstanceResponseBody(name='body'),
}

/**
  * *   Make sure that you fully understand the billing methods and [pricing](https://www.aliyun.com/price/product#/mongodb/detail) of ApsaraDB for MongoDB before you call this operation.
  * *   For more information about the instance types of ApsaraDB for MongoDB, see [Instance types](~~57141~~).
  * *   To create standalone instances and replica set instances, you can call the [CreateDBInstance](~~61763~~) operation.
  *
  * @param request CreateShardingDBInstanceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateShardingDBInstanceResponse
 */
async function createShardingDBInstanceWithOptions(request: CreateShardingDBInstanceRequest, runtime: Util.RuntimeOptions): CreateShardingDBInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configServer)) {
    query['ConfigServer'] = request.configServer;
  }
  if (!Util.isUnset(request.DBInstanceDescription)) {
    query['DBInstanceDescription'] = request.DBInstanceDescription;
  }
  if (!Util.isUnset(request.encrypted)) {
    query['Encrypted'] = request.encrypted;
  }
  if (!Util.isUnset(request.encryptionKey)) {
    query['EncryptionKey'] = request.encryptionKey;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.globalSecurityGroupIds)) {
    query['GlobalSecurityGroupIds'] = request.globalSecurityGroupIds;
  }
  if (!Util.isUnset(request.hiddenZoneId)) {
    query['HiddenZoneId'] = request.hiddenZoneId;
  }
  if (!Util.isUnset(request.mongos)) {
    query['Mongos'] = request.mongos;
  }
  if (!Util.isUnset(request.networkType)) {
    query['NetworkType'] = request.networkType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.provisionedIops)) {
    query['ProvisionedIops'] = request.provisionedIops;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.replicaSet)) {
    query['ReplicaSet'] = request.replicaSet;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.restoreTime)) {
    query['RestoreTime'] = request.restoreTime;
  }
  if (!Util.isUnset(request.secondaryZoneId)) {
    query['SecondaryZoneId'] = request.secondaryZoneId;
  }
  if (!Util.isUnset(request.securityIPList)) {
    query['SecurityIPList'] = request.securityIPList;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.srcDBInstanceId)) {
    query['SrcDBInstanceId'] = request.srcDBInstanceId;
  }
  if (!Util.isUnset(request.storageEngine)) {
    query['StorageEngine'] = request.storageEngine;
  }
  if (!Util.isUnset(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateShardingDBInstance',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   Make sure that you fully understand the billing methods and [pricing](https://www.aliyun.com/price/product#/mongodb/detail) of ApsaraDB for MongoDB before you call this operation.
  * *   For more information about the instance types of ApsaraDB for MongoDB, see [Instance types](~~57141~~).
  * *   To create standalone instances and replica set instances, you can call the [CreateDBInstance](~~61763~~) operation.
  *
  * @param request CreateShardingDBInstanceRequest
  * @return CreateShardingDBInstanceResponse
 */
async function createShardingDBInstance(request: CreateShardingDBInstanceRequest): CreateShardingDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createShardingDBInstanceWithOptions(request, runtime);
}

model DeleteDBInstanceRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='ETnLKlblzczshOTUbOCzxxxxxxxxxx'),
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bpxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DeleteDBInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='72651AF9-7897-41A7-8B67-6C15C7F26A0A'),
}

model DeleteDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDBInstanceResponseBody(name='body'),
}

/**
  * Before you call this operation, make sure that the instance meets the following requirements:
  * *   The instance is in the running state.
  * *   A pay-as-you-go instance is used.
  * > After you release an ApsaraDB for MongoDB instance, data in the instance can no longer be recovered. Proceed with caution.
  *
  * @param request DeleteDBInstanceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteDBInstanceResponse
 */
async function deleteDBInstanceWithOptions(request: DeleteDBInstanceRequest, runtime: Util.RuntimeOptions): DeleteDBInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDBInstance',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, make sure that the instance meets the following requirements:
  * *   The instance is in the running state.
  * *   A pay-as-you-go instance is used.
  * > After you release an ApsaraDB for MongoDB instance, data in the instance can no longer be recovered. Proceed with caution.
  *
  * @param request DeleteDBInstanceRequest
  * @return DeleteDBInstanceResponse
 */
async function deleteDBInstance(request: DeleteDBInstanceRequest): DeleteDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDBInstanceWithOptions(request, runtime);
}

model DeleteGlobalSecurityIPGroupRequest {
  globalIgName?: string(name='GlobalIgName', example='corp'),
  globalSecurityGroupId?: string(name='GlobalSecurityGroupId', example='g-qxieqf40xjst1ngpr3jz'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DeleteGlobalSecurityIPGroupResponseBody = {
  requestId?: string(name='RequestId', example='2F42BB4E-461F-5B55-A37C-53B1141C****'),
}

model DeleteGlobalSecurityIPGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGlobalSecurityIPGroupResponseBody(name='body'),
}

async function deleteGlobalSecurityIPGroupWithOptions(request: DeleteGlobalSecurityIPGroupRequest, runtime: Util.RuntimeOptions): DeleteGlobalSecurityIPGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.globalIgName)) {
    query['GlobalIgName'] = request.globalIgName;
  }
  if (!Util.isUnset(request.globalSecurityGroupId)) {
    query['GlobalSecurityGroupId'] = request.globalSecurityGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGlobalSecurityIPGroup',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGlobalSecurityIPGroup(request: DeleteGlobalSecurityIPGroupRequest): DeleteGlobalSecurityIPGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGlobalSecurityIPGroupWithOptions(request, runtime);
}

model DeleteNodeRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='ETnLKlblzczshOTUbOCzxxxxxxxxxx'),
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bpxxxxxxxx'),
  nodeId?: string(name='NodeId', description='The ID of the shard or mongos node to be deleted. You can call the [DescribeDBInstanceAttribute](~~61923~~) operation to query the node ID.', example='s-bpxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DeleteNodeResponseBody = {
  orderId?: string(name='OrderId', description='The order ID of the instance.', example='111111111111111'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9F9BDE64-BF30-41F3-BD29-C19CE4AB3404'),
  taskId?: int32(name='TaskId', description='The ID of the task.', example='111111111'),
}

model DeleteNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteNodeResponseBody(name='body'),
}

/**
  * Before you call this operation, make sure that the following requirements are met:
  * *   The instance is in the running state.
  * *   The instance is a sharded cluster instance.
  * *   The billing method of the instance is pay-as-you-go.
  * *   The number of the shard or mongos nodes in the instance is greater than two.
  *
  * @param request DeleteNodeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteNodeResponse
 */
async function deleteNodeWithOptions(request: DeleteNodeRequest, runtime: Util.RuntimeOptions): DeleteNodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNode',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, make sure that the following requirements are met:
  * *   The instance is in the running state.
  * *   The instance is a sharded cluster instance.
  * *   The billing method of the instance is pay-as-you-go.
  * *   The number of the shard or mongos nodes in the instance is greater than two.
  *
  * @param request DeleteNodeRequest
  * @return DeleteNodeResponse
 */
async function deleteNode(request: DeleteNodeRequest): DeleteNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNodeWithOptions(request, runtime);
}

model DescribeAccountsRequest {
  accountName?: string(name='AccountName', description='The name of the account. Set the value to **root**.', example='root'),
  DBInstanceId?: string(name='DBInstanceId', description='The instance ID.', example='dds-bp1fd530f271****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeAccountsResponseBody = {
  accounts?: {
    account?: [ 
    {
      accountDescription?: string(name='AccountDescription', description='The description of the account.

> This parameter is returned only after you configure the description of the account by calling the [ModifyAccountDescription](~~468391~~) operation.', example='account description.'),
      accountName?: string(name='AccountName', description='The name of the account.', example='root'),
      accountStatus?: string(name='AccountStatus', description='The status of the account.

*   **Unavailable**
*   **Available**', example='Available'),
      characterType?: string(name='CharacterType', description='The role of the account. Valid values:

*   **db**: shard
*   **cs**: Configserver
*   **mongos**: mongos
*   **logic:** sharded cluster instance
*   **normal:** replica set instance', example='mongos'),
      DBInstanceId?: string(name='DBInstanceId', description='The name of the instance to which the account belongs.', example='dds-bp1fd530f271****'),
    }
  ](name='Account')
  }(name='Accounts', description='The username of the account.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B562A65B-39AB-4EE8-8635-5A222054FB35'),
}

model DescribeAccountsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAccountsResponseBody(name='body'),
}

/**
  * >  You can call this operation to query only the information of the root account.
  *
  * @param request DescribeAccountsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeAccountsResponse
 */
async function describeAccountsWithOptions(request: DescribeAccountsRequest, runtime: Util.RuntimeOptions): DescribeAccountsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAccounts',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation to query only the information of the root account.
  *
  * @param request DescribeAccountsRequest
  * @return DescribeAccountsResponse
 */
async function describeAccounts(request: DescribeAccountsRequest): DescribeAccountsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAccountsWithOptions(request, runtime);
}

model DescribeActiveOperationTaskCountRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='sg-bp5689ac****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeActiveOperationTaskCountResponseBody = {
  needPop?: int32(name='NeedPop', description='Indicates whether any O&M tasks need pop-up windows to notify users actions. Valid values: 

- **0**: No O&M tasks need pop-up windows to notify users actions.
- **1**: Some O&M tasks need pop-up windows to notify users actions.', example='0'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='770D7F11-21A2-402B-9DF6-D1A620570EF9'),
  taskCount?: int32(name='TaskCount', description='The number of pending O&M tasks.', example='0'),
}

model DescribeActiveOperationTaskCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeActiveOperationTaskCountResponseBody(name='body'),
}

async function describeActiveOperationTaskCountWithOptions(request: DescribeActiveOperationTaskCountRequest, runtime: Util.RuntimeOptions): DescribeActiveOperationTaskCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeActiveOperationTaskCount',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeActiveOperationTaskCount(request: DescribeActiveOperationTaskCountRequest): DescribeActiveOperationTaskCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeActiveOperationTaskCountWithOptions(request, runtime);
}

model DescribeActiveOperationTaskTypeRequest {
  isHistory?: int32(name='IsHistory', description='Specifies whether to return all O\\&M tasks. Valid values:

*   **0**: returns only pending tasks.
*   **1**: returns all tasks.

Default value: **0**.', example='0'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmyiu4ekp****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeActiveOperationTaskTypeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C7EE83BF-7BA8-5087-BAC9-ED85ED54****'),
  typeList?: [ 
    {
      count?: int32(name='Count', description='The number of pending tasks.', example='1'),
      taskType?: string(name='TaskType', description='The type of the task. Valid values:

*   **rds\\_apsaradb\\_transfer**: instance migration
*   **rds\\_apsaradb\\_upgrade**: minor version update', example='rds_apsaradb_upgrade'),
      taskTypeInfoEn?: string(name='TaskTypeInfoEn', description='The task type (English).', example='rds_apsaradb_upgrade'),
      taskTypeInfoZh?: string(name='TaskTypeInfoZh', description='The task type (Chinese).', example='rds_apsaradb_upgrade'),
    }
  ](name='TypeList', description='The list of tasks.'),
}

model DescribeActiveOperationTaskTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeActiveOperationTaskTypeResponseBody(name='body'),
}

async function describeActiveOperationTaskTypeWithOptions(request: DescribeActiveOperationTaskTypeRequest, runtime: Util.RuntimeOptions): DescribeActiveOperationTaskTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.isHistory)) {
    query['IsHistory'] = request.isHistory;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeActiveOperationTaskType',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeActiveOperationTaskType(request: DescribeActiveOperationTaskTypeRequest): DescribeActiveOperationTaskTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeActiveOperationTaskTypeWithOptions(request, runtime);
}

model DescribeAuditLogFilterRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bp12c5b040dc****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  roleType?: string(name='RoleType', description='The role of the node in the instance. Valid values:

* **mongos**: mongos node.
* **db** : shard node.
* **logic** : logical instance.', example='logic'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeAuditLogFilterResponseBody = {
  filter?: string(name='Filter', description='The type of the audit log entries. Valid values:

*   **admin**: O\\&M and management operations
*   **slow**: slow query logs
*   **query**: query operations
*   **insert**: insert operations
*   **update**: update operations
*   **delete**: delete operations
*   **command**: protocol commands such as the aggregate method', example='admin,slow,insert,query,update,delete,command'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='7BAFB0B3-2A54-5B65-B13E-3937CF08FEE6'),
  roleType?: string(name='RoleType', description='The role of the node.', example='logic'),
}

model DescribeAuditLogFilterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAuditLogFilterResponseBody(name='body'),
}

/**
  * *   The instance must be in the running state when you call this operation.
  * *   This operation is applicable only to **general-purpose local-disk** and **dedicated local-disk** instances.
  * *   You can call this operation up to 30 times per minute. To call this operation at a higher frequency, use a Logstore. For more information, see [Manage a Logstore](~~48990~~).
  *
  * @param request DescribeAuditLogFilterRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeAuditLogFilterResponse
 */
async function describeAuditLogFilterWithOptions(request: DescribeAuditLogFilterRequest, runtime: Util.RuntimeOptions): DescribeAuditLogFilterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.roleType)) {
    query['RoleType'] = request.roleType;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAuditLogFilter',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   The instance must be in the running state when you call this operation.
  * *   This operation is applicable only to **general-purpose local-disk** and **dedicated local-disk** instances.
  * *   You can call this operation up to 30 times per minute. To call this operation at a higher frequency, use a Logstore. For more information, see [Manage a Logstore](~~48990~~).
  *
  * @param request DescribeAuditLogFilterRequest
  * @return DescribeAuditLogFilterResponse
 */
async function describeAuditLogFilter(request: DescribeAuditLogFilterRequest): DescribeAuditLogFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAuditLogFilterWithOptions(request, runtime);
}

model DescribeAuditPolicyRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bp12c5b040dc****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeAuditPolicyResponseBody = {
  logAuditStatus?: string(name='LogAuditStatus', description='Indicates whether the log audit feature is enabled. Valid values:

*   Enable
*   Disabled

Default value: Disabled.', example='Enable'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='111E7B16-0A87-4CBA-B271-F34AD61E099F'),
}

model DescribeAuditPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAuditPolicyResponseBody(name='body'),
}

/**
  * *   The instance must be in the running state when you call this operation.
  * *   This operation is applicable only to **general-purpose local-disk** and **dedicated local-disk** instances.
  * *   You can call this operation up to 30 times per minute. To call this operation at a higher frequency, use a Logstore. For more information, see [Manage a Logstore](~~48990~~).
  *
  * @param request DescribeAuditPolicyRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeAuditPolicyResponse
 */
async function describeAuditPolicyWithOptions(request: DescribeAuditPolicyRequest, runtime: Util.RuntimeOptions): DescribeAuditPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAuditPolicy',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   The instance must be in the running state when you call this operation.
  * *   This operation is applicable only to **general-purpose local-disk** and **dedicated local-disk** instances.
  * *   You can call this operation up to 30 times per minute. To call this operation at a higher frequency, use a Logstore. For more information, see [Manage a Logstore](~~48990~~).
  *
  * @param request DescribeAuditPolicyRequest
  * @return DescribeAuditPolicyResponse
 */
async function describeAuditPolicy(request: DescribeAuditPolicyRequest): DescribeAuditPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAuditPolicyWithOptions(request, runtime);
}

model DescribeAuditRecordsRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.

> If you set this parameter to the ID of a sharded cluster instance, you must also specify the **NodeId** parameter.', example='dds-bp12c5b040dc****'),
  database?: string(name='Database', description='The name of the database to be queried. By default, all databases are queried.', example='database****'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

> The end time must be within 24 hours from the start time. Otherwise, the query fails.', example='2019-03-13T13:11:14Z'),
  form?: string(name='Form', description='The form of the audit log that the operation returns. Default value: File. Valid values:

*   **File** triggers the generation of audit logs. If this parameter is set to File, only common parameters are returned.
*   **Stream**: returns data streams.', example='Stream'),
  nodeId?: string(name='NodeId', description='The ID of the mongos node or shard node whose parameter modification records you want to query in the instance. If the instance is a sharded cluster instance, you must specify this parameter.

> This parameter is valid only when you specify the **DBInstanceId** parameter to the ID of a sharded cluster instance.', example='d-bp128a003436****'),
  orderType?: string(name='OrderType', description='The order of time in which the log entries to return are sorted. Valid values:

*   **asc**: The log entries are sorted by time in ascending order.
*   **desc**: The log entries are sorted by time in descending order.', example='asc'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Valid values: any non-zero positive integer. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return per page. Default value: 30. Valid values: **30**, **50**, and **100**.', example='30'),
  queryKeywords?: string(name='QueryKeywords', description='The keywords that are used for queries. Separate multiple keywords with spaces. The maximum number of keywords is 10.', example='slow'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2019-03-13T12:11:14Z'),
  user?: string(name='User', description='The account of the database. If you do not specify this parameter, this operation returns records of all accounts.', example='test'),
}

model DescribeAuditRecordsResponseBody = {
  items?: {
    SQLRecord?: [ 
    {
      accountName?: string(name='AccountName', description='The account of the database.', example='test'),
      DBName?: string(name='DBName', description='The name of the database.', example='test123'),
      executeTime?: string(name='ExecuteTime', description='The time when the statement was executed. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2019-03-11T03:30:27Z'),
      hostAddress?: string(name='HostAddress', description='The IP addresses of the client.', example='11.xxx.xxx.xxx'),
      returnRowCounts?: long(name='ReturnRowCounts', description='The number of SQL audit log entries that are returned.', example='2'),
      syntax?: string(name='Syntax', description='The statement that was executed.', example='{ \\"atype\\" : \\"createCollection\\", \\"param\\" : { \\"ns\\" : \\"123.test1\\" }, \\"result\\": \\"OK\\" }'),
      tableName?: string(name='TableName', description='The name of the collection.', example='C1'),
      threadID?: string(name='ThreadID', description='The ID of the thread.', example='140682188297984'),
      totalExecutionTimes?: long(name='TotalExecutionTimes', description='The execution time of the statement. Unit: microseconds.', example='700'),
    }
  ](name='SQLRecord')
  }(name='Items', description='An array that consists of the information of audit log entries.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The maximum number of entries on the current page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3278BEB8-503B-4E46-8F7E-D26E040C9769'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of returned entries.', example='40'),
}

model DescribeAuditRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAuditRecordsResponseBody(name='body'),
}

/**
  * *   When you call this operation, ensure that the audit log feature of the instance is enabled. Otherwise, the operation returns an empty audit log.
  * *   This operation is applicable only to **general-purpose local-disk** and **dedicated local-disk** instances.
  * *   You can call this operation up to 30 times per minute. To call this operation at a higher frequency, use a Logstore. For more information, see [Manage a Logstore](~~48990~~).
  *
  * @param request DescribeAuditRecordsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeAuditRecordsResponse
 */
async function describeAuditRecordsWithOptions(request: DescribeAuditRecordsRequest, runtime: Util.RuntimeOptions): DescribeAuditRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.database)) {
    query['Database'] = request.database;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.form)) {
    query['Form'] = request.form;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queryKeywords)) {
    query['QueryKeywords'] = request.queryKeywords;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.user)) {
    query['User'] = request.user;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAuditRecords',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   When you call this operation, ensure that the audit log feature of the instance is enabled. Otherwise, the operation returns an empty audit log.
  * *   This operation is applicable only to **general-purpose local-disk** and **dedicated local-disk** instances.
  * *   You can call this operation up to 30 times per minute. To call this operation at a higher frequency, use a Logstore. For more information, see [Manage a Logstore](~~48990~~).
  *
  * @param request DescribeAuditRecordsRequest
  * @return DescribeAuditRecordsResponse
 */
async function describeAuditRecords(request: DescribeAuditRecordsRequest): DescribeAuditRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAuditRecordsWithOptions(request, runtime);
}

model DescribeAvailabilityZonesRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='Specifies the language of the returned values of the **RegionName** and **ZoneName** parameters. Default value: zh. Valid values:

*   **zh**: Chinese.
*   **en**: English', example='zh'),
  dbType?: string(name='DbType', description='The database engine type of the instance. Valid values:

*   **normal**: replica set instance
*   **sharding**: sharded cluster instance', example='normal'),
  excludeSecondaryZoneId?: string(name='ExcludeSecondaryZoneId'),
  excludeZoneId?: string(name='ExcludeZoneId'),
  instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the instance. Default value: PrePaid. Valid values:

*   **PrePaid**: subscription
*   **PostPaid**: pay-as-you-go', example='PrePaid'),
  mongoType?: string(name='MongoType', description='The edition of the ApsaraDB for MongoDB instance. The instance can be of a high-availability edition or beta edition.', example='dbfs'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the instance. You can call the [DescribeRegions](~~61933~~) operation to query the latest available regions.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group. For more information, see [View basic information of a resource group](~~151181~~).', example='rg-acfmx2m4rqu7pry'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  storageSupport?: string(name='StorageSupport', description='The zones to be displayed. The values include the zones in which you can create an instance that uses cloud disks, the zones in which you can create an instance that uses local disks, and the zones in which you can create an instance that uses cloud disks and local disks.', example='lcoal'),
  storageType?: string(name='StorageType', description='The storage type of the instance. Valid values:

*   **cloud_essd1**: PL1.enhanced SSD (ESSD)
*   **cloud_essd2**: PL2 ESSD.
*   **cloud_essd3**: PL3 ESSD.
*   **local_ssd**: local SSD.

> 

*   Instances of MongoDB 4.4 and later only support cloud disks. **cloud_essd1** is selected if you leave this parameter empty.

*   Instances of MongoDB 4.2 and earlier support only local disks. **local_ssd** is selected if you leave this parameter empty.', example='local_ssd'),
  zoneId?: string(name='ZoneId', description='The zone ID of the instance. You can call the [DescribeRegions](~~61933~~) operation to query available zones.', example='cn-hangzhou-b'),
}

model DescribeAvailabilityZonesResponseBody = {
  availableZones?: [ 
    {
      regionId?: string(name='RegionId', description='The ID of the region. You can call the [DescribeRegions](~~61933~~) operation to query the latest available regions.', example='cn-beijing'),
      zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-beijing-f'),
      zoneName?: string(name='ZoneName', description='The name of the zone.

The return value of the ZoneName parameter is in the language that is specified by the **AcceptLanguage** parameter. For example, if the value of the ZoneId parameter in the response is **cn-hangzhou-h**, the following values are returned for the ZoneName parameter:

*   If the value of the **AcceptLanguage** parameter is **zh**, ** H** is returned for the ZoneName parameter.
*   If the value of the **AcceptLanguage** parameter is **en**, **Hangzhou Zone H** is returned for the ZoneName parameter.', example='Hangzhou Zone H'),
    }
  ](name='AvailableZones', description='The details of the zones in which you can create ApsaraDB for MongoDB instances.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='19A13A33-0FAD-5120-8AE1-B1636F74DD80'),
}

model DescribeAvailabilityZonesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAvailabilityZonesResponseBody(name='body'),
}

/**
  * You can call this operation to query zones in which you can create an ApsaraDB for MongoDB instance.
  *
  * @param request DescribeAvailabilityZonesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeAvailabilityZonesResponse
 */
async function describeAvailabilityZonesWithOptions(request: DescribeAvailabilityZonesRequest, runtime: Util.RuntimeOptions): DescribeAvailabilityZonesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.dbType)) {
    query['DbType'] = request.dbType;
  }
  if (!Util.isUnset(request.excludeSecondaryZoneId)) {
    query['ExcludeSecondaryZoneId'] = request.excludeSecondaryZoneId;
  }
  if (!Util.isUnset(request.excludeZoneId)) {
    query['ExcludeZoneId'] = request.excludeZoneId;
  }
  if (!Util.isUnset(request.instanceChargeType)) {
    query['InstanceChargeType'] = request.instanceChargeType;
  }
  if (!Util.isUnset(request.mongoType)) {
    query['MongoType'] = request.mongoType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.storageSupport)) {
    query['StorageSupport'] = request.storageSupport;
  }
  if (!Util.isUnset(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAvailabilityZones',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this operation to query zones in which you can create an ApsaraDB for MongoDB instance.
  *
  * @param request DescribeAvailabilityZonesRequest
  * @return DescribeAvailabilityZonesResponse
 */
async function describeAvailabilityZones(request: DescribeAvailabilityZonesRequest): DescribeAvailabilityZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailabilityZonesWithOptions(request, runtime);
}

model DescribeAvailableEngineVersionRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bpxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeAvailableEngineVersionResponseBody = {
  engineVersions?: {
    engineVersion?: [ string ](name='EngineVersion')
  }(name='EngineVersions', description='The list of one or more engine versions to which an ApsaraDB for MongoDB instance can be upgraded.

>  An empty string is returned if the latest version is being used.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='52507B6B-003B-47A3-A0A3-9FE992C7A243'),
}

model DescribeAvailableEngineVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAvailableEngineVersionResponseBody(name='body'),
}

async function describeAvailableEngineVersionWithOptions(request: DescribeAvailableEngineVersionRequest, runtime: Util.RuntimeOptions): DescribeAvailableEngineVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAvailableEngineVersion',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAvailableEngineVersion(request: DescribeAvailableEngineVersionRequest): DescribeAvailableEngineVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableEngineVersionWithOptions(request, runtime);
}

model DescribeAvailableResourceRequest {
  dbType?: string(name='DbType', description='The architecture of the instance. Valid values:

*   **normal**: replica set instance
*   **sharding**: sharded cluster instance', example='sharding'),
  instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the instance. Default value: PrePaid. Valid values:

*   **PrePaid**: subscription
*   **PostPaid**: pay-as-you-go', example='PrePaid'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call the [DescribeRegions](~~61933~~) operation to query the latest available regions.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmyiu4ekp****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  storageType?: string(name='StorageType'),
  zoneId?: string(name='ZoneId', description='The ID of the zone. You can call the [DescribeRegions](~~61933~~) operation to query the available zones.', example='cn-hangzhou-h'),
}

model DescribeAvailableResourceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='344EE51D-8850-4935-B68B-58A8F4DCE3BD'),
  supportedDBTypes?: {
    supportedDBType?: [ 
    {
      availableZones?: {
        availableZone?: [ 
        {
          regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
          supportedEngineVersions?: {
            supportedEngineVersion?: [ 
            {
              supportedEngines?: {
                supportedEngine?: [ 
                {
                  engine?: string(name='Engine', description='The storage engine of the instance.', example='WiredTiger'),
                  supportedNodeTypes?: {
                    supportedNodeType?: [ 
                    {
                      availableResources?: {
                        availableResource?: [ 
                        {
                          DBInstanceStorageRange?: {
                            max?: int32(name='Max', description='The maximum storage capacity. Unit: GB.', example='16000'),
                            min?: int32(name='Min', description='The minimum storage capacity. Unit: GB.', example='20'),
                            step?: int32(name='Step', description='The step size for adjusting the storage capacity. Unit: GB.', example='10'),
                          }(name='DBInstanceStorageRange', description='The storage capacity range of the instance.'),
                          instanceClass?: string(name='InstanceClass', description='The instance family.', example='mdb.shard.2x.xlarge.d'),
                          instanceClassRemark?: string(name='InstanceClassRemark', description='The type of the instance.', example='4 cores, 8 GB (Dedicated) (Current instance type: mdb.shard.2x.xlarge.d (4 cores, 8 GB (Dedicated cloud-disk), maximum connections: 3000, maximum IOPS: min{1800 + 50 × Storage capacity, 21000}))'),
                        }
                      ](name='AvailableResource')
                      }(name='AvailableResources', description='The details of the available resources.'),
                      networkTypes?: string(name='NetworkTypes', description='The network type of the instance.', example='VPC'),
                      nodeType?: string(name='NodeType', description='The number of nodes in the instance.', example='3'),
                    }
                  ](name='SupportedNodeType')
                  }(name='SupportedNodeTypes', description='The supported instance types.'),
                }
              ](name='SupportedEngine')
              }(name='SupportedEngines', description='The supported storage engines.'),
              version?: string(name='Version', description='The database engine version of the instance.', example='4.0'),
            }
          ](name='SupportedEngineVersion')
          }(name='SupportedEngineVersions', description='The supported storage engine versions.'),
          zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-hangzhou-h'),
        }
      ](name='AvailableZone')
      }(name='AvailableZones', description='The available zones.'),
      dbType?: string(name='DbType', description='The architecture of the instance. Valid values:

*   **normal**: replica set instance
*   **sharding**: sharded cluster instance', example='sharding'),
    }
  ](name='SupportedDBType')
  }(name='SupportedDBTypes', description='The supported database types.'),
}

model DescribeAvailableResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAvailableResourceResponseBody(name='body'),
}

async function describeAvailableResourceWithOptions(request: DescribeAvailableResourceRequest, runtime: Util.RuntimeOptions): DescribeAvailableResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dbType)) {
    query['DbType'] = request.dbType;
  }
  if (!Util.isUnset(request.instanceChargeType)) {
    query['InstanceChargeType'] = request.instanceChargeType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAvailableResource',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAvailableResource(request: DescribeAvailableResourceRequest): DescribeAvailableResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableResourceWithOptions(request, runtime);
}

model DescribeBackupDBsRequest {
  backupId?: string(name='BackupId', description='The ID of the backup set.

> * You can call the [DescribeBackups](~~62172~~) operation to query the backup ID.
> * You must specify one of the **RestoreTime** and BackupId parameters.', example='5664****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. The value of this parameter must be an integer that is greater than 0. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 30. Valid values: **30**, **50**, and **100**.', example='30'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-ax68****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restoreTime?: string(name='RestoreTime', description='The point in time to which the instance is restored. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

> * The time can be a point in time within the past seven days. The time must be earlier than the current time, but later than the time when the instance was created.
> * You must specify one of the RestoreTime and **BackupId** parameters.', example='2019-08-22T12:00:00Z'),
  securityToken?: string(name='SecurityToken'),
  sourceDBInstance?: string(name='SourceDBInstance', description='The ID of the source instance.', example='dds-bp2286****'),
}

model DescribeBackupDBsResponseBody = {
  databases?: {
    database?: [ 
    {
      DBName?: string(name='DBName', description='The name of the database.', example='mongodbtest'),
    }
  ](name='Database')
  }(name='Databases', description='Details about the databases.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1AF0AD89-ED4F-44AD-B65F-BFC1D5CD9455'),
  totalCount?: int32(name='TotalCount', description='The number of returned databases.', example='5'),
}

model DescribeBackupDBsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupDBsResponseBody(name='body'),
}

/**
  * ## Precautions
  * You can call the [CreateDBInstance](~~61763~~) operation to restore a database for an ApsaraDB for MongoDB instance. For more information, see [Restore one or more databases of an ApsaraDB for MongoDB instance](~~112274~~).
  * Before you call this operation, make sure that the ApsaraDB for MongoDB instance meets the following requirements:
  * *   The instance was created after March 26, 2019.
  * *   The instance is located in the China (Qingdao), China (Beijing), China (Zhangjiakou), China (Hohhot), China (Hangzhou), China (Shanghai), China (Shenzhen), or Singapore (Singapore) region. Other regions are not supported.
  * *   The instance is a replica set instance.
  * *   The version of the database engine is 3.4, 4.0, or 4.2.
  * *   The storage engine of the instance is WiredTiger.
  *
  * @param request DescribeBackupDBsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeBackupDBsResponse
 */
async function describeBackupDBsWithOptions(request: DescribeBackupDBsRequest, runtime: Util.RuntimeOptions): DescribeBackupDBsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.restoreTime)) {
    query['RestoreTime'] = request.restoreTime;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.sourceDBInstance)) {
    query['SourceDBInstance'] = request.sourceDBInstance;
  }
  if (!Util.isUnset(request.sourceDBInstance)) {
    query['SourceDBInstance'] = request.sourceDBInstance;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupDBs',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ## Precautions
  * You can call the [CreateDBInstance](~~61763~~) operation to restore a database for an ApsaraDB for MongoDB instance. For more information, see [Restore one or more databases of an ApsaraDB for MongoDB instance](~~112274~~).
  * Before you call this operation, make sure that the ApsaraDB for MongoDB instance meets the following requirements:
  * *   The instance was created after March 26, 2019.
  * *   The instance is located in the China (Qingdao), China (Beijing), China (Zhangjiakou), China (Hohhot), China (Hangzhou), China (Shanghai), China (Shenzhen), or Singapore (Singapore) region. Other regions are not supported.
  * *   The instance is a replica set instance.
  * *   The version of the database engine is 3.4, 4.0, or 4.2.
  * *   The storage engine of the instance is WiredTiger.
  *
  * @param request DescribeBackupDBsRequest
  * @return DescribeBackupDBsResponse
 */
async function describeBackupDBs(request: DescribeBackupDBsRequest): DescribeBackupDBsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupDBsWithOptions(request, runtime);
}

model DescribeBackupPolicyRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bp16cb162771****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeBackupPolicyResponseBody = {
  backupInterval?: int32(name='BackupInterval', description='The frequency at which high-frequency backups are created. Valid values:

*   **-1**: disables high-frequency backup.
*   **15**: every 15 minutes.
*   **30**: every 30 minutes.
*   **60**: every hour.
*   **120**: every 2 hours.
*   **180**: every 3 hours.
*   **240**: every 4 hours.
*   **360**: every 6 hours.
*   **480**: every 8 hours.
*   **720**: every 12 hours.', example='-1'),
  backupRetentionPeriod?: string(name='BackupRetentionPeriod', description='The retention period of backups. Unit: days.', example='30'),
  enableBackupLog?: int32(name='EnableBackupLog', description='Indicates whether log backup is enabled. Default value: 0. Valid values:

*   **0**: disables log backup.
*   **1**: enables log backup.', example='1'),
  logBackupRetentionPeriod?: int32(name='LogBackupRetentionPeriod', description='The number of days for which to retain log backups. Valid values: 7 to 730.', example='7'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod', description='The day of a week on which to back up data. Valid values:

*   **Monday**
*   **Tuesday**
*   **Wednesday**
*   **Thursday**
*   **Friday**
*   **Saturday**
*   **Sunday**', example='Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday'),
  preferredBackupTime?: string(name='PreferredBackupTime', description='The time range to back up data. The time is in the *HH:mm*Z-*HH:mm*Z format. The time is displayed in UTC.', example='09:00Z-10:00Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='5A9464CA-F7DC-5434-90B1-DF7F197C****'),
  snapshotBackupType?: string(name='SnapshotBackupType', description='The snapshot backup type. Default value: Standard. Valid values:

*   **Flash**: single-digit second backup
*   **Standard**: standard backup', example='Standard'),
}

model DescribeBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupPolicyResponseBody(name='body'),
}

async function describeBackupPolicyWithOptions(request: DescribeBackupPolicyRequest, runtime: Util.RuntimeOptions): DescribeBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupPolicy',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupPolicy(request: DescribeBackupPolicyRequest): DescribeBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupPolicyWithOptions(request, runtime);
}

model DescribeBackupsRequest {
  backupId?: string(name='BackupId', description='The ID of the backup set. You can call the [CreateBackup](~~62171~~) operation to obtain the value of this parameter.

If you set the DBInstanceId parameter to the ID of a sharded cluster instance, the number of backup IDs is the same as the number of shards. Multiple , with commas (,) in the middle.', example='2072****,2072****,2072****'),
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.

>  If you set this parameter to the ID of a sharded cluster instance, you must also specify the **NodeId** parameter.', example='dds-bp1a7009eb24****'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.', example='2022-01-14T13:00Z'),
  nodeId?: string(name='NodeId', description='The ID of the shard node in the sharded cluster instance.

>  This parameter is valid only when **DBInstanceId** is set to the ID of a sharded cluster instance.', example='d-bp128a003436****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. The value must be an integer that is greater than 0. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: **30, 50, and 100**. Default value: **30**.', example='30'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.', example='2022-01-13T13:00Z'),
}

model DescribeBackupsResponseBody = {
  backups?: {
    backup?: [ 
    {
      backupDBNames?: string(name='BackupDBNames', description='The name of the database that has been backed up.', example='database'),
      backupDownloadURL?: string(name='BackupDownloadURL', description='The Internet download URL of the backup set. If the download URL is unavailable, this parameter is an empty string.', example='http://rdsbak-hz-v3.oss-cn-hangzhou.aliyuncs.com/custins5559****/hins1936****_data_2022052504****_qp.xb?Expires=165361****&OSSAccessKeyId=LTAI4G2wxd32KLGARf****&Signature=lkFPjOY%2F8adB18vnOCbtmT7****&Region=cn-hangzhou'),
      backupEndTime?: string(name='BackupEndTime', description='The end of the backup time range. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format and displayed in UTC.', example='2022-01-14T03:57:34Z'),
      backupId?: int32(name='BackupId', description='The ID of the backup set.', example='32102****'),
      backupIntranetDownloadURL?: string(name='BackupIntranetDownloadURL', description='The internal download URL of the backup set.

>  You can use this URL to download the backup set from on the ECS instance which is on the same network as the ApsaraDB for MongoDB instance.', example='http://rdsbak-hz-v3.oss-cn-hangzhou-internal.aliyuncs.com/custins5559*****/hins1936****_data_2022052504****_qp.xb?Expires=165361****&OSSAccessKeyId=LTAI4G2wxd32KLGARfi****&Signature=lkFPjOY%2F8adB18vnOCbtmT7ii****&Region=cn-hangzhou'),
      backupMethod?: string(name='BackupMethod', description='The backup method. Valid values:

*   **Snapshot**
*   **Physical**
*   **Logical**', example='Physical'),
      backupMode?: string(name='BackupMode', description='The backup mode.

*   **Automated**: automatic backup
*   **Manual**: manual backup', example='Automated'),
      backupSize?: long(name='BackupSize', description='The size of the backup set. Unit: bytes.', example='6168576'),
      backupStartTime?: string(name='BackupStartTime', description='The beginning of the backup time range. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format and displayed in UTC.', example='2022-01-14T03:56:17Z'),
      backupStatus?: string(name='BackupStatus', description='The status of the backup. Valid values:

*   **Success**: The backup task is successful.
*   **Failed**: The backup task failed.', example='Success'),
      backupType?: string(name='BackupType', description='The backup method.

*   **FullBackup**: a full backup
*   **IncrementalBackup**: an incremental backup', example='FullBackup'),
    }
  ](name='Backup')
  }(name='Backups', description='Details about backup sets.'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='275D43C3-F12F-5224-B375-0C6BF453BD56'),
  totalCount?: int32(name='TotalCount', description='The total number of backup sets that were returned.', example='1'),
}

model DescribeBackupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupsResponseBody(name='body'),
}

async function describeBackupsWithOptions(request: DescribeBackupsRequest, runtime: Util.RuntimeOptions): DescribeBackupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackups',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackups(request: DescribeBackupsRequest): DescribeBackupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupsWithOptions(request, runtime);
}

model DescribeClusterBackupsRequest {
  backupId?: string(name='BackupId', example='5664****'),
  DBInstanceId?: string(name='DBInstanceId', example='dds-bp16cb162771****'),
  endTime?: string(name='EndTime', example='2019-03-14T13:10Z'),
  isOnlyGetClusterBackUp?: boolean(name='IsOnlyGetClusterBackUp'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNo?: int32(name='PageNo', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  startTime?: string(name='StartTime', example='2019-03-13T12:11:14Z'),
}

model DescribeClusterBackupsResponseBody = {
  clusterBackups?: [ 
    {
      backups?: [ 
        {
          backupDownloadURL?: string(name='BackupDownloadURL'),
          backupEndTime?: string(name='BackupEndTime'),
          backupId?: string(name='BackupId'),
          backupIntranetDownloadURL?: string(name='BackupIntranetDownloadURL'),
          backupName?: string(name='BackupName'),
          backupSize?: string(name='BackupSize'),
          backupStartTime?: string(name='BackupStartTime'),
          backupStatus?: string(name='BackupStatus'),
          instanceName?: string(name='InstanceName'),
          isAvail?: string(name='IsAvail'),
        }
      ](name='Backups'),
      clusterBackupEndTime?: string(name='ClusterBackupEndTime'),
      clusterBackupId?: string(name='ClusterBackupId'),
      clusterBackupMode?: string(name='ClusterBackupMode'),
      clusterBackupSize?: string(name='ClusterBackupSize'),
      clusterBackupStartTime?: string(name='ClusterBackupStartTime'),
      clusterBackupStatus?: string(name='ClusterBackupStatus'),
      extraInfo?: {
        registryFromHistory?: string(name='RegistryFromHistory'),
      }(name='ExtraInfo'),
      isAvail?: int32(name='IsAvail', example='1'),
      progress?: string(name='Progress'),
    }
  ](name='ClusterBackups'),
  maxResults?: int32(name='MaxResults', example='10'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  requestId?: string(name='RequestId', example='2F42BB4E-461F-5B55-A37C-53B1141C****'),
}

model DescribeClusterBackupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterBackupsResponseBody(name='body'),
}

async function describeClusterBackupsWithOptions(request: DescribeClusterBackupsRequest, runtime: Util.RuntimeOptions): DescribeClusterBackupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.isOnlyGetClusterBackUp)) {
    query['IsOnlyGetClusterBackUp'] = request.isOnlyGetClusterBackUp;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterBackups',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterBackups(request: DescribeClusterBackupsRequest): DescribeClusterBackupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterBackupsWithOptions(request, runtime);
}

model DescribeClusterRecoverTimeRequest {
  DBInstanceId?: string(name='DBInstanceId', example='dds-bp18f7d6b6a7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeClusterRecoverTimeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  restoreRanges?: [ 
    {
      restoreBeginTime?: string(name='RestoreBeginTime'),
      restoreEndTime?: string(name='RestoreEndTime'),
      restoreType?: string(name='RestoreType'),
    }
  ](name='RestoreRanges'),
}

model DescribeClusterRecoverTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterRecoverTimeResponseBody(name='body'),
}

async function describeClusterRecoverTimeWithOptions(request: DescribeClusterRecoverTimeRequest, runtime: Util.RuntimeOptions): DescribeClusterRecoverTimeResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterRecoverTime',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterRecoverTime(request: DescribeClusterRecoverTimeRequest): DescribeClusterRecoverTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterRecoverTimeWithOptions(request, runtime);
}

model DescribeDBInstanceAttributeRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The instance ID.', example='dds-bp11483712c1****'),
  engine?: string(name='Engine', description='The database engine of the instance. Set the value to **MongoDB**.', example='MongoDB'),
  isDelete?: boolean(name='IsDelete', description='Specifies whether to delete the instance. Valid values:

*   **false**: queries the details of running instances.
*   **true**: queries the details of deleted instances.', example='false'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group. For more information, see [View the basic information of a resource group](~~151181~~).

> This parameter is available only if you use the China site (aliyun.com).', example='rg-acfmyiu4ekp****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeDBInstanceAttributeResponseBody = {
  DBInstances?: {
    DBInstance?: [ 
    {
      burstingEnabled?: boolean(name='BurstingEnabled'),
      capacityUnit?: string(name='CapacityUnit', description='The read and write throughput consumed by the instance.', example='100'),
      chargeType?: string(name='ChargeType', description='The billing method of the instance. Valid values:

*   **PrePaid**: subscription
*   **PostPaid**: pay-as-you-go', example='PostPaid'),
      configserverList?: {
        configserverAttribute?: [ 
        {
          connectString?: string(name='ConnectString', description='The endpoint of the Configserver node.', example='dds-bp18b0934e7053e4-cs****.mongodb.rds.aliyuncs.com'),
          maxConnections?: int32(name='MaxConnections', description='The maximum number of connections to the Configserver node.', example='1000'),
          maxIOPS?: int32(name='MaxIOPS', description='The maximum IOPS of the Configserver node.', example='1000'),
          nodeClass?: string(name='NodeClass', description='The type of the Configserver node.', example='dds.cs.mid'),
          nodeDescription?: string(name='NodeDescription', description='The name of the Configserver node.', example='testConfigserver'),
          nodeId?: string(name='NodeId', description='The ID of the Configserver node.', example='dds-bp11483712c1****-cs'),
          nodeStorage?: int32(name='NodeStorage', description='The storage capacity of the Configserver node.', example='20'),
          port?: int32(name='Port', description='The port number that is used to connect to the Configserver node.', example='3717'),
          status?: string(name='Status', description='The state of the Configserver node. For more information, see [Instance states](~~63870~~).', example='Running'),
        }
      ](name='ConfigserverAttribute')
      }(name='ConfigserverList', description='The details of the Configserver nodes.

> This parameter is returned if the instance is a sharded cluster instance.'),
      creationTime?: string(name='CreationTime', description='The time when the instance was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2022-01-02T07:43:59Z'),
      currentKernelVersion?: string(name='CurrentKernelVersion', description='The minor version of the current database in the instance.', example='5.0.5-20220721143518_0'),
      DBInstanceClass?: string(name='DBInstanceClass', description='The instance type.', example='dds.mongo.mid'),
      DBInstanceDescription?: string(name='DBInstanceDescription', description='The name of the instance.', example='Test database'),
      DBInstanceId?: string(name='DBInstanceId', description='The instance ID.', example='dds-bp11483712c1****'),
      DBInstanceOrderStatus?: string(name='DBInstanceOrderStatus', description='The status of the orders generated for the instance. Valid values:

*   **all_completed**: All orders are being produced or complete.
*   **order_unpaid**: The instance has unpaid orders.
*   **order_wait_for_produce**: The order is being delivered for production.

> The order production process includes placing an order, paying for an order, delivering an order for production, producing an order, and complete.

*   If an order is in the **order_wait_for_produce** state for a long time, an error occurs when the order is being delivered for production. The system will automatically retry.
*   The instance status change only when the order is in the producing and complete state, such as changing configurations and running.', example='all_completed'),
      DBInstanceReleaseProtection?: boolean(name='DBInstanceReleaseProtection', description='Indicates whether release protection is enabled for the instance. Valid values:

*   **true**
*   **false**', example='false'),
      DBInstanceStatus?: string(name='DBInstanceStatus', description='The state of the instance. For more information, see [Instance states](~~63870~~).', example='Running'),
      DBInstanceStorage?: int32(name='DBInstanceStorage', description='The storage capacity of the instance.', example='10'),
      DBInstanceType?: string(name='DBInstanceType', description='The architecture of the instance. Valid values:

*   **replicate**: replica set instance
*   **sharding**: sharded cluster instance', example='replicate'),
      destroyTime?: string(name='DestroyTime', description='The time when the instance data was destroyed. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2021-12-10T16:00:00Z'),
      encrypted?: boolean(name='Encrypted', description='是否开启云盘加密', example='true'),
      encryptionKey?: string(name='EncryptionKey', description='云盘加密对应的kms-key', example='07609cc3-3109-408f-a35e-c548e776da0b'),
      engine?: string(name='Engine', description='The database engine of the instance.', example='MongoDB'),
      engineVersion?: string(name='EngineVersion', description='The database engine version of the instance.

*   **6.0**
*   **5.0**
*   **4.4**
*   **4.2**
*   **4.0**', example='4.4'),
      expireTime?: string(name='ExpireTime', description='The time when the subscription instance expires. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time is displayed in UTC.

> This parameter is returned if the instance is a subscription instance.', example='2022-02-05T16:00Z'),
      hiddenZoneId?: string(name='HiddenZoneId', description='The ID of the secondary zone 2 of the instance. Valid values:

*   **cn-hangzhou-g**: Hangzhou Zone G
*   **cn-hangzhou-h**: Hangzhou Zone H
*   **cn-hangzhou-i**: Hangzhou Zone I
*   **cn-hongkong-b**: Hongkong Zone B
*   **cn-hongkong-c**: Hongkong Zone C
*   **cn-hongkong-d**: Hongkong Zone D
*   **cn-wulanchabu-a**: Ulanqab Zone A
*   **cn-wulanchabu-b**: Ulanqab Zone B
*   **cn-wulanchabu-c**: Ulanqab Zone C
*   **ap-southeast-1a**: Singapore Zone A
*   **ap-southeast-1b**: Singapore Zone B
*   **ap-southeast-1c**: Singapore Zone C
*   **ap-southeast-5a**: Jakarta Zone A
*   **ap-southeast-5b**: Jakarta Zone B
*   **ap-southeast-5c**: Jakarta Zone C
*   **eu-central-1a**: Frankfurt Zone A
*   **eu-central-1b**: Frankfurt Zone B
*   **eu-central-1c**: Frankfurt Zone C

> 

*   This parameter is returned if the instance is a replica set or sharded cluster instance that runs MongoDB 4.4 or 5.0 and uses multi-zone deployment.

*   This parameter is returned only if you use the Chine site (aliyun.com).', example='cn-hangzhou-h'),
      kindCode?: string(name='KindCode', description='The kind code of the instance. Valid values:

*   **0**: physical machine
*   **1**: Elastic Compute Service (ECS) instance
*   **2**: Docker cluster
*   **18**: Kubernetes cluster', example='1'),
      lastDowngradeTime?: string(name='LastDowngradeTime', description='The date when the last downgrade operation was performed on the instance.', example='2022-01-08'),
      lockMode?: string(name='LockMode', description='The lock state of the instance. Valid values:

*   **Unlock**: The instance is not locked.
*   **ManualLock**: The instance is manually locked.
*   **LockByExpiration**: The instance is automatically locked due to instance expiration.
*   **LockByRestoration**: The instance is automatically locked before it is rolled back.
*   **LockByDiskQuota**: The instance is automatically locked due to exhausted storage capacity.
*   **Released**: The instance is released.', example='Unlock'),
      maintainEndTime?: string(name='MaintainEndTime', description='The end time of the maintenance window. The time follows the ISO 8601 standard in the *HH:mm*Z format. The time is displayed in UTC.', example='03:00Z'),
      maintainStartTime?: string(name='MaintainStartTime', description='The start time of the maintenance window. The time follows the ISO 8601 standard in the *HH:mm*Z format. The time is displayed in UTC.', example='18:00Z'),
      maxConnections?: int32(name='MaxConnections', description='The maximum number of connections to the instance.', example='500'),
      maxIOPS?: int32(name='MaxIOPS', description='The maximum IOPS of the instance.', example='1000'),
      mongosList?: {
        mongosAttribute?: [ 
        {
          connectSting?: string(name='ConnectSting', description='The endpoint of the mongos node.', example='s-bp1d8c262a15****.mongodb.rds.aliyuncs.com'),
          maxConnections?: int32(name='MaxConnections', description='The maximum number of connections to the mongos node.', example='1000'),
          maxIOPS?: int32(name='MaxIOPS', description='The maximum IOPS of the mongos node.', example='800'),
          nodeClass?: string(name='NodeClass', description='The type of the mongos node.', example='dds.mongos.mid'),
          nodeDescription?: string(name='NodeDescription', description='The name of the mongos node.', example='mongos1'),
          nodeId?: string(name='NodeId', description='The ID of the mongos node.', example='s-bp1d8c262a15****'),
          port?: int32(name='Port', description='The port number that is used to connect to the mongos node.', example='3717'),
          status?: string(name='Status', description='The state of the mongos node. For more information, see [Instance states](~~63870~~).', example='Running'),
          VPCId?: string(name='VPCId', description='The VPC ID of the instance.

> This parameter is returned if the network type of the instance is VPC.', example='vpc-bp1n3i15v90el48nx****'),
          vSwitchId?: string(name='VSwitchId', description='The vSwitch ID of the instance.

> This parameter is returned if the network type of the instance is VPC.', example='vsw-bp1vj604nj5a9zz74****'),
          vpcCloudInstanceId?: string(name='VpcCloudInstanceId', description='The ID of the mongos node.', example='s-bp1d8c262a158****'),
        }
      ](name='MongosAttribute')
      }(name='MongosList', description='The details of the mongos nodes.

> This parameter is returned if the instance is a sharded cluster instance.'),
      networkType?: string(name='NetworkType', description='The network type of the instance. Valid values:

*   **Classic**
*   **VPC**', example='VPC'),
      protocolType?: string(name='ProtocolType', description='The access protocol type of the instance. Valid values:

*   **mongodb**
*   **dynamodb**

> This parameter is returned if the instance is a sharded cluster instance.', example='mongodb'),
      provisionedIops?: long(name='ProvisionedIops'),
      readonlyReplicas?: string(name='ReadonlyReplicas', description='The number of read-only nodes in the instance.', example='1'),
      regionId?: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou'),
      replacateId?: string(name='ReplacateId', description='The logical ID of the replica instance.

> ApsaraDB for MongoDB does not support new instances of this type. This parameter applies only to previous-version replica instances.', example='bls-m****'),
      replicaSetName?: string(name='ReplicaSetName', description='The name of the replica set instance.

> This parameter is returned if the instance is a replica set instance.', example='mgset-10ace****'),
      replicaSets?: {
        replicaSet?: [ 
        {
          connectionDomain?: string(name='ConnectionDomain', description='The endpoint of the node.', example='dds-bp11483712c1****.mongodb.rds.aliyuncs.com'),
          connectionPort?: string(name='ConnectionPort', description='The port number that is used to connect to the node.', example='3717'),
          networkType?: string(name='NetworkType', description='The network type of the instance. Valid values:

*   **Classic**
*   **VPC**', example='VPC'),
          replicaSetRole?: string(name='ReplicaSetRole', description='The role of the node. Valid values:

*   **Primary**
*   **Secondary**', example='Primary'),
          VPCCloudInstanceId?: string(name='VPCCloudInstanceId', description='The instance ID.

> This parameter is returned if the network type of the instance is VPC.', example='dds-bp11483712c1****'),
          VPCId?: string(name='VPCId', description='The VPC ID of the instance.

> This parameter is returned if the network type of the instance is VPC.', example='vpc-bp1jk5vwkcri27qme****'),
          vSwitchId?: string(name='VSwitchId', description='The vSwitch ID of the instance.

> This parameter is returned if the network type of the instance is VPC.', example='vpc-bp1jk5vwkcri27qme****'),
        }
      ](name='ReplicaSet')
      }(name='ReplicaSets', description='The details of the replica set instances.

> This parameter is returned if the instance is a replica set instance.'),
      replicationFactor?: string(name='ReplicationFactor', description='The number of nodes in the instance.

> This parameter is returned if the instance is a replica set instance.', example='3'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.

> This parameter is returned only if you use the China site (aliyun.com).', example='rg-acfmyiu4ekp****'),
      secondaryZoneId?: string(name='SecondaryZoneId', description='The ID of the secondary zone 1 of the instance. Valid values:

*   **cn-hangzhou-g**: Hangzhou Zone G
*   **cn-hangzhou-h**: Hangzhou Zone H
*   **cn-hangzhou-i**: Hangzhou Zone I
*   **cn-hongkong-b**: Hongkong Zone B
*   **cn-hongkong-c**: Hongkong Zone C
*   **cn-hongkong-d**: Hongkong Zone D
*   **cn-wulanchabu-a**: Ulanqab Zone A
*   **cn-wulanchabu-b**: Ulanqab Zone B
*   **cn-wulanchabu-c**: Ulanqab Zone C
*   **ap-southeast-1a**: Singapore Zone A
*   **ap-southeast-1b**: Singapore Zone B
*   **ap-southeast-1c**: Singapore Zone C
*   **ap-southeast-5a**: Jakarta Zone A
*   **ap-southeast-5b**: Jakarta Zone B
*   **ap-southeast-5c**: Jakarta Zone C
*   **eu-central-1a**: Frankfurt Zone A
*   **eu-central-1b**: Frankfurt Zone B
*   **eu-central-1c**: Frankfurt Zone C

> 

*   This parameter is returned if the instance is a replica set or sharded cluster instance that runs MongoDB 4.4 or 5.0 and uses multi-zone deployment.

*   This parameter is returned only if you use the Chine site (aliyun.com).', example='cn-hangzhou-i'),
      shardList?: {
        shardAttribute?: [ 
        {
          connectString?: string(name='ConnectString', description='The endpoint of the shard node.', example='d-bp1af0680a9c6d3****.mongodb.rds.aliyuncs.com:****'),
          maxConnections?: int32(name='MaxConnections', description='The maximum number of connections to the shard node.', example='8000'),
          maxIOPS?: int32(name='MaxIOPS', description='The maximum IOPS of the shard node.', example='8000'),
          nodeClass?: string(name='NodeClass', description='The type of the shard node.', example='dds.shard.mid'),
          nodeDescription?: string(name='NodeDescription', description='The name of the shard node.', example='testshard'),
          nodeId?: string(name='NodeId', description='The ID of the shard node.', example='d-bp16e09d9c5d****'),
          nodeStorage?: int32(name='NodeStorage', description='The storage capacity of the shard node.', example='10'),
          port?: int32(name='Port', description='The port number that is used to connect to the shard node.', example='3717'),
          readonlyReplicas?: int32(name='ReadonlyReplicas', description='The number of read-only nodes in the shard node. Valid values: **0** to **5**. The value must be an integer.', example='0'),
          status?: string(name='Status', description='The state of the shard node. For more information, see [Instance states](~~63870~~).', example='Running'),
        }
      ](name='ShardAttribute')
      }(name='ShardList', description='The details of the shard nodes.

> This parameter is returned if the instance is a sharded cluster instance.'),
      storageEngine?: string(name='StorageEngine', description='The storage engine of the instance.', example='WiredTiger'),
      storageType?: string(name='StorageType', description='The storage type of the instance. Valid values:

**cloud_essd1**: ESSD PL1 **cloud_essd2**: ESSD of PL2 **cloud_essd3**: ESSD of PL3 **local_ssd**: local SSD', example='cloud_essd1'),
      syncPercent?: string(name='SyncPercent'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key', description='The tag key of the instance.', example='test'),
          value?: string(name='Value', description='The tag value of the instance.', example='api'),
        }
      ](name='Tag')
      }(name='Tags', description='The details of the instance tags.'),
      useClusterBackup?: boolean(name='UseClusterBackup'),
      VPCCloudInstanceIds?: string(name='VPCCloudInstanceIds', description='The instance ID.

> This parameter is returned if the network type of the instance is VPC.', example='dds-bp11483712c1****'),
      VPCId?: string(name='VPCId', description='The VPC ID of the instance.

> This parameter is returned if the network type of the instance is VPC.', example='vpc-bp1n3i15v90el48nx****'),
      vSwitchId?: string(name='VSwitchId', description='The vSwitch ID of the instance.

> This parameter is returned if the network type of the instance is VPC.', example='vsw-bp1oo2a7isyrb8igf****'),
      vpcAuthMode?: string(name='VpcAuthMode', description='Indicates whether password-free access within the VPC is enabled. Valid values:

*   **Open**: Password-free access is enabled.
*   **Close**: Password-free access is disabled, and you must use a password for access.
*   **NotSupport**: Password-free access is not supported.', example='Open'),
      zoneId?: string(name='ZoneId', description='The zone ID of the instance.', example='cn-hangzhou-b'),
    }
  ](name='DBInstance')
  }(name='DBInstances', description='The details of the instances.'),
  requestId?: string(name='RequestId', description='The request ID.', example='A935A8EE-A6CC-53DE-98BA-20ABAA7E632B'),
}

model DescribeDBInstanceAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstanceAttributeResponseBody(name='body'),
}

async function describeDBInstanceAttributeWithOptions(request: DescribeDBInstanceAttributeRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.isDelete)) {
    query['IsDelete'] = request.isDelete;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstanceAttribute',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstanceAttribute(request: DescribeDBInstanceAttributeRequest): DescribeDBInstanceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceAttributeWithOptions(request, runtime);
}

model DescribeDBInstanceEncryptionKeyRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bp2235****'),
  encryptionKey?: string(name='EncryptionKey', description='The custom key for the instance. You can call the [DescribeUserEncryptionKeyList](~~151729~~) operation to query the list of custom keys for an ApsaraDB for MongoDB instance.', example='2axxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeDBInstanceEncryptionKeyResponseBody = {
  creator?: string(name='Creator', description='The UID of the key creator.', example='123456'),
  deleteDate?: string(name='DeleteDate', description='The scheduled time when the key for the instance will be deleted. If the value is empty, the key will not be deleted.', example='2020-07-06T18:22:03Z'),
  description?: string(name='Description', description='The description of the key for the instance.', example='key description example'),
  encryptionKey?: string(name='EncryptionKey', description='The key for the instance.', example='2axxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'),
  encryptionKeyStatus?: string(name='EncryptionKeyStatus', description='Indicates whether the key for the instance is enabled. Valid values:

*   **Enabled**
*   **Disabled**', example='Enabled'),
  keyUsage?: string(name='KeyUsage', description='The purpose of the key for the instance.', example='ENCRYPT/DECRYPT'),
  materialExpireTime?: string(name='MaterialExpireTime', description='The expiration time of the key for the instance. The time is displayed in UTC. If the value is empty, the key for the instance will not expire.', example='2020-07-06T18:22:03Z'),
  origin?: string(name='Origin', description='The source of the key for the instance.', example='Aliyun_KMS'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='783C2062-A2D3-4EA8-88AD-E43F990C23BB'),
}

model DescribeDBInstanceEncryptionKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstanceEncryptionKeyResponseBody(name='body'),
}

/**
  * ## Usage
  * When you call the DescribeDBInstanceEncryptionKey operation, the instance must have transparent data encryption (TDE) enabled in BYOK mode. You can call the [ModifyDBInstanceTDE](~~131267~~) operation to enable TDE.
  *
  * @param request DescribeDBInstanceEncryptionKeyRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDBInstanceEncryptionKeyResponse
 */
async function describeDBInstanceEncryptionKeyWithOptions(request: DescribeDBInstanceEncryptionKeyRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceEncryptionKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.encryptionKey)) {
    query['EncryptionKey'] = request.encryptionKey;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstanceEncryptionKey',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ## Usage
  * When you call the DescribeDBInstanceEncryptionKey operation, the instance must have transparent data encryption (TDE) enabled in BYOK mode. You can call the [ModifyDBInstanceTDE](~~131267~~) operation to enable TDE.
  *
  * @param request DescribeDBInstanceEncryptionKeyRequest
  * @return DescribeDBInstanceEncryptionKeyResponse
 */
async function describeDBInstanceEncryptionKey(request: DescribeDBInstanceEncryptionKeyRequest): DescribeDBInstanceEncryptionKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceEncryptionKeyWithOptions(request, runtime);
}

model DescribeDBInstanceMonitorRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bp1143f90ff3****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeDBInstanceMonitorResponseBody = {
  granularity?: string(name='Granularity', description='The collection frequency of monitoring data. The value is **1** or **300**. Unit: seconds.', example='5'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='EFD65226-08CC-4C4D-B6A4-CB3C382F67B0'),
}

model DescribeDBInstanceMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstanceMonitorResponseBody(name='body'),
}

async function describeDBInstanceMonitorWithOptions(request: DescribeDBInstanceMonitorRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstanceMonitor',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstanceMonitor(request: DescribeDBInstanceMonitorRequest): DescribeDBInstanceMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceMonitorWithOptions(request, runtime);
}

model DescribeDBInstancePerformanceRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.

>  If you set this parameter to the ID of a sharded cluster instance, you must also specify the **NodeId** parameter.', example='dds-bp2635****'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC. The end time must be later than the start time.', example='2022-06-13T11:58Z'),
  key?: string(name='Key', description='A performance metric. For more information about the valid values, see [Performance metrics](~~64048~~).

>  If you specify multiple metrics, separate them with commas (,).', example='CpuUsage'),
  nodeId?: string(name='NodeId', description='The ID of the mongos or shard node in a sharded cluster instance. You can specify this parameter to view the performance data of a single node.

>  This parameter is valid only when **DBInstanceId** is set to the ID of a sharded cluster instance.', example='d-bp2287****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  replicaSetRole?: string(name='ReplicaSetRole', description='The role of the node in a standalone or replica set instance.

* **Primary**
* **Secondary**

> * This parameter is valid only when you specify the **DBInstanceId** parameter to the ID of a standalone instance or a replica set instance.
> * If you set the **DBInstanceId** parameter to the ID of a standalone instance, the value of this parameter can only be **Primary**.', example='Primary'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  roleId?: string(name='RoleId', description='The role ID of the node in a standalone or replica set instance. You can call the [DescribeReplicaSetRole](~~62134~~) operation to query the role ID of the node.

>  This parameter is valid only when you specify the **DBInstanceId** parameter to the ID of a standalone instance or a replica set instance.', example='6025****'),
  securityToken?: string(name='SecurityToken'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.', example='2022-06-13T10:58Z'),
}

model DescribeDBInstancePerformanceResponseBody = {
  endTime?: string(name='EndTime', description='The end of the time range to query. The time is in the *yyyy-MM-dd*T*HH:mm*Z format. The time is displayed in UTC.', example='2022-06-13T11:58Z'),
  performanceKeys?: {
    performanceKey?: [ 
    {
      key?: string(name='Key', description='The performance metric.', example='CpuUsage'),
      performanceValues?: {
        performanceValue?: [ 
        {
          date?: string(name='Date', description='The date and time when the metric value was generated.', example='2022-06-13T10:58:00Z'),
          value?: string(name='Value', description='The value of the performance metric.', example='0.23'),
        }
      ](name='PerformanceValue')
      }(name='PerformanceValues', description='Details about the performance metric values.'),
      unit?: string(name='Unit', description='The unit of the performance metric.', example='%'),
      valueFormat?: string(name='ValueFormat', description='The format of the performance metric value. If the performance metric contains multiple fields, the fields are separated with **\\&amp;** symbols.

For example, if you query disk usage, the returned **ValueFormat** value is in the **ins_size\\&amp;data_size\\&amp;log_size** format.', example='cpu_usage'),
    }
  ](name='PerformanceKey')
  }(name='PerformanceKeys', description='Details about the performance metrics.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4A300BC7-6D8F-527F-A2DB-A7768D26E9AC'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. The time is in the *yyyy-MM-dd*T*HH:mm*Z format. The time is displayed in UTC.', example='2022-06-13T10:58Z'),
}

model DescribeDBInstancePerformanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstancePerformanceResponseBody(name='body'),
}

async function describeDBInstancePerformanceWithOptions(request: DescribeDBInstancePerformanceRequest, runtime: Util.RuntimeOptions): DescribeDBInstancePerformanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.replicaSetRole)) {
    query['ReplicaSetRole'] = request.replicaSetRole;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.roleId)) {
    query['RoleId'] = request.roleId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstancePerformance',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstancePerformance(request: DescribeDBInstancePerformanceRequest): DescribeDBInstancePerformanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstancePerformanceWithOptions(request, runtime);
}

model DescribeDBInstanceSSLRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The instance ID.', example='dds-bpxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeDBInstanceSSLResponseBody = {
  certCommonName?: string(name='CertCommonName', description='The name of the SSL certificate.', example='dds-bpxxxxxxxx.mongodb.rds.aliyuncs.com'),
  requestId?: string(name='RequestId', description='The request ID.', example='36BB1BC2-789C-4BBA-A519-C5B388E4B0D4'),
  SSLExpiredTime?: string(name='SSLExpiredTime', description='The time when the SSL certificate expires. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in Coordinated Universal Time (UTC).', example='2020-03-11T02:28:25Z'),
  SSLStatus?: string(name='SSLStatus', description='The status of the SSL feature. Valid values:

*   **Open**: The SSL feature is enabled.
*   **Closed**: The SSL feature is disabled.', example='Open'),
}

model DescribeDBInstanceSSLResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstanceSSLResponseBody(name='body'),
}

/**
  * Before you call this operation, make sure that the following requirements are met:
  * *   The instance is in the Running state.
  * *   The instance is a replica set instance.
  * *   The instance runs MongoDB 3.4 or later.
  *
  * @param request DescribeDBInstanceSSLRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDBInstanceSSLResponse
 */
async function describeDBInstanceSSLWithOptions(request: DescribeDBInstanceSSLRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceSSLResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstanceSSL',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, make sure that the following requirements are met:
  * *   The instance is in the Running state.
  * *   The instance is a replica set instance.
  * *   The instance runs MongoDB 3.4 or later.
  *
  * @param request DescribeDBInstanceSSLRequest
  * @return DescribeDBInstanceSSLResponse
 */
async function describeDBInstanceSSL(request: DescribeDBInstanceSSLRequest): DescribeDBInstanceSSLResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceSSLWithOptions(request, runtime);
}

model DescribeDBInstanceTDEInfoRequest {
  DBInstanceId?: string(name='DBInstanceId', example='dds-bpxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeDBInstanceTDEInfoResponseBody = {
  encryptionKey?: string(name='EncryptionKey'),
  encryptorName?: string(name='EncryptorName'),
  requestId?: string(name='RequestId', example='F4DD0E29-361B-42F2-9301-B0048CCCE5D6'),
  roleARN?: string(name='RoleARN'),
  TDEStatus?: string(name='TDEStatus', example='enabled'),
}

model DescribeDBInstanceTDEInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstanceTDEInfoResponseBody(name='body'),
}

/**
  * You can call this operation to query whether TDE is enabled for an ApsaraDB for MongoDB instance.
  *
  * @param request DescribeDBInstanceTDEInfoRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDBInstanceTDEInfoResponse
 */
async function describeDBInstanceTDEInfoWithOptions(request: DescribeDBInstanceTDEInfoRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceTDEInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstanceTDEInfo',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this operation to query whether TDE is enabled for an ApsaraDB for MongoDB instance.
  *
  * @param request DescribeDBInstanceTDEInfoRequest
  * @return DescribeDBInstanceTDEInfoResponse
 */
async function describeDBInstanceTDEInfo(request: DescribeDBInstanceTDEInfoRequest): DescribeDBInstanceTDEInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceTDEInfoWithOptions(request, runtime);
}

model DescribeDBInstancesRequest {
  chargeType?: string(name='ChargeType', description='The billing method of the instance. Valid values:

*   **PrePaid**: subscription
*   **PostPaid**: pay-as-you-go', example='PrePaid'),
  connectionDomain?: string(name='ConnectionDomain', description='The endpoint of the node. You can call the [DescribeDBInstanceAttribute](~~62010~~) operation to query the endpoint of the node.', example='dds-bp1ea17b41abecf43****.mongodb.rds.aliyuncs.com'),
  DBInstanceClass?: string(name='DBInstanceClass', description='The instance type. For more information about valid values, see [Instance types](~~57141~~).', example='dds.mongo.mid'),
  DBInstanceDescription?: string(name='DBInstanceDescription', description='The name of the instance. The name must meet the following requirements:

*   The name must start with a letter.
*   It can contain digits, letters, underscores (\\_), and hyphens (-).
*   It must be 2 to 256 characters in length.', example='Test database'),
  DBInstanceId?: string(name='DBInstanceId', description='The instance ID.', example='dds-bp199659b178****'),
  DBInstanceStatus?: string(name='DBInstanceStatus', description='The state of the instance. For more information about valid values, see [Instance states](~~63870~~).', example='Running'),
  DBInstanceType?: string(name='DBInstanceType', description='The architecture of the instance. Valid values:

*   **sharding**: sharded cluster instance
*   **replicate**: replica set or standalone instance', example='sharding'),
  DBNodeType?: string(name='DBNodeType', description='The type of the node in the instance. This parameter is used to filter standard or test instance.

1.  Valid value for a standalone or DBFS instance.
2.  Valid value for a standard instance that comes in the replica set or sharded cluster architecture: standard
3.  Valid value when all instances are displayed: default', example='default'),
  engine?: string(name='Engine', description='The database engine of the instance. Set the value to **MongoDB**.', example='MongoDB'),
  engineVersion?: string(name='EngineVersion', description='The database engine version of the instance. Valid values:

*   **5.0**
*   **4.4**
*   **4.2**
*   **4.0**
*   **3.4**', example='4.0'),
  expireTime?: string(name='ExpireTime', description='The time when the instance expires.', example='2019-12-26T16:00Z'),
  expired?: string(name='Expired', description='Specifies whether the instance has expired. Valid values:

*   **true**
*   **false**', example='true'),
  networkType?: string(name='NetworkType', description='The network type of the instance. Valid values:

*   **Classic**
*   **VPC**', example='VPC'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. The value of this parameter must be an integer that is greater than 0. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values:

*   **30** (default)
*   **50**
*   **100**', example='30'),
  regionId?: string(name='RegionId', description='The region ID of the instance. You can call the [DescribeRegions](~~61933~~) operation to query the most recent region list.', example='cn-hangzhou'),
  replicationFactor?: string(name='ReplicationFactor', description='The number of nodes in the replica set instance. Valid values:

*   **3**
*   **5**
*   **7**', example='3'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmyiu4ekp****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key of the instance. Valid values of N: **1** to **20**.

*   The key cannot start with `aliyun`, `acs:`, `http://`, or `https://`.
*   It can be up to 64 characters in length.
*   It cannot be an empty string.', example='testdatabase'),
      value?: string(name='Value', description='The tag value of the instance. Valid values of N: **1** to **20**.

*   The value cannot start with `aliyun`, `acs:`, `http://`, or `https://`.
*   The value can be up to 128 characters in length.
*   It can be an empty string.', example='apitest'),
    }
  ](name='Tag', description='The tags of the instance.'),
  vSwitchId?: string(name='VSwitchId', description='The vSwitch ID of the instance.', example='vsw-bp1vj604nj5a9zz74****'),
  vpcId?: string(name='VpcId', description='The VPC ID of the instance.', example='vpc-bp1n3i15v90el48nx****'),
  zoneId?: string(name='ZoneId', description='The zone ID of the instance. You can call the [DescribeRegions](~~61933~~) operation to query the most recent zone list.', example='cn-hangzhou-b'),
}

model DescribeDBInstancesResponseBody = {
  DBInstances?: {
    DBInstance?: [ 
    {
      capacityUnit?: string(name='CapacityUnit', description='The read and write throughput consumed by the instance.

> This parameter is returned when the instance is a serverless instance.', example='100'),
      chargeType?: string(name='ChargeType', description='The billing method of the instance. Valid values:

*   **PrePaid**: subscription
*   **PostPaid**: pay-as-you-go', example='PrePaid'),
      creationTime?: string(name='CreationTime', description='The time when the instance was created. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2021-03-25T02:18:00Z'),
      DBInstanceClass?: string(name='DBInstanceClass', description='The instance type.', example='dds.mongo.mid'),
      DBInstanceDescription?: string(name='DBInstanceDescription', description='The description of the instance.', example='Test database'),
      DBInstanceId?: string(name='DBInstanceId', description='The instance ID.', example='dds-bp18b0934e70****'),
      DBInstanceStatus?: string(name='DBInstanceStatus', description='The status of the instance. For more information, see [Instance states](~~63870~~).', example='Running'),
      DBInstanceStorage?: int32(name='DBInstanceStorage', description='The storage capacity of the instance.', example='20'),
      DBInstanceType?: string(name='DBInstanceType', description='The architecture of the instance. Valid values:

*   **sharding**: sharded cluster instance
*   **replicate**: replica set or standalone instance', example='sharding'),
      destroyTime?: string(name='DestroyTime', description='The time when the instance data was destroyed. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.

> 

*   Subscription instances are released 15 days after expiration. After the instances are released, the data of the instances is deleted and cannot be restored.

*   Pay-as-you-go instances are locked after the payments have been overdue for longer than 24 hours. The instances are released after the payments have been overdue for longer than 15 days. The data of released instances is deleted and cannot be restored.', example='2021-12-10T16:00:00Z'),
      engine?: string(name='Engine', description='The database engine of the instance.', example='MongoDB'),
      engineVersion?: string(name='EngineVersion', description='The database engine version of the instance. Valid values:

*   **5.0**
*   **4.4**
*   **4.2**
*   **4.0**
*   **3.4**', example='4.2'),
      expireTime?: string(name='ExpireTime', description='The time when the instance expires. The time is in the *yyyy-MM-dd*T*HH:mm*Z format. The time is displayed in UTC.', example='2021-11-25T16:00Z'),
      hiddenZoneId?: string(name='HiddenZoneId', description='The ID of the secondary zone 2 of the instance. Valid values:

*   **cn-hangzhou-g**: Hangzhou Zone G
*   **cn-hangzhou-h**: Hangzhou Zone H
*   **cn-hangzhou-i**: Hangzhou Zone I
*   **cn-hongkong-b**: Hongkong Zone B
*   **cn-hongkong-c**: Hongkong Zone C
*   **cn-hongkong-d**: Hongkong Zone D
*   **cn-wulanchabu-a**: Ulanqab Zone A
*   **cn-wulanchabu-b**: Ulanqab Zone B
*   **cn-wulanchabu-c**: Ulanqab Zone C
*   **ap-southeast-1a**: Singapore Zone A
*   **ap-southeast-1b**: Singapore Zone B
*   **ap-southeast-1c**: Singapore Zone C
*   **ap-southeast-5a**: Jakarta Zone A
*   **ap-southeast-5b**: Jakarta Zone B
*   **ap-southeast-5c**: Jakarta Zone C
*   **eu-central-1a**: Frankfurt Zone A
*   **eu-central-1b**: Frankfurt Zone B
*   **eu-central-1c**: Frankfurt Zone C

> 

*   This parameter is returned if the instance is a replica set or sharded cluster instance that runs MongoDB 4.4 or 5.0 and uses multi-zone deployment.

*   This parameter is returned only if you use the Chine site (aliyun.com).', example='cn-hangzhou-h'),
      kindCode?: string(name='KindCode', description='The kind code of the instance. Valid values:

*   **0**: physical machine
*   **1**: ECS instance
*   **2**: Docker cluster
*   **18**: Kubernetes cluster', example='1'),
      lastDowngradeTime?: string(name='LastDowngradeTime', description='The date when the last downgrade operation was performed.', example='2021-05-08'),
      lockMode?: string(name='LockMode', description='The lock state of the instance. Valid values:

*   **Unlock**: The cluster is not locked.
*   **ManualLock**: The instance is manually locked.
*   **LockByExpiration**: The instance is automatically locked due to instance expiration.
*   **LockByRestoration**: The instance is automatically locked before it is rolled back.
*   **LockByDiskQuota**: The instance is automatically locked due to exhausted storage capacity.
*   **Released**: The instance is released. After an instance is released, the instance cannot be unlocked. You can only restore the backup data of the instance to a new instance. This process requires a long period of time.', example='Unlock'),
      mongosList?: {
        mongosAttribute?: [ 
        {
          nodeClass?: string(name='NodeClass', description='The type of the mongos node.', example='dds.mongos.standard'),
          nodeDescription?: string(name='NodeDescription', description='The description of the mongos node.', example='testmongosnode'),
          nodeId?: string(name='NodeId', description='The ID of the mongos node.', example='s-bp10e3b0d02f****'),
        }
      ](name='MongosAttribute')
      }(name='MongosList', description='The details of the mongos nodes.

> This parameter is returned if the instance is a sharded cluster instance.'),
      networkType?: string(name='NetworkType', description='The network type of the instance. Valid values:

*   **Classic**
*   **VPC**', example='Classic'),
      regionId?: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou'),
      replicationFactor?: string(name='ReplicationFactor', description='The number of nodes in the instance.

> This parameter is returned if the instance is a replica set instance.', example='3'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmyiu4ekp****'),
      secondaryZoneId?: string(name='SecondaryZoneId', description='The ID of the secondary zone 1 of the instance. Valid values:

*   **cn-hangzhou-g**: Hangzhou Zone G
*   **cn-hangzhou-h**: Hangzhou Zone H
*   **cn-hangzhou-i**: Hangzhou Zone I
*   **cn-hongkong-b**: Hongkong Zone B
*   **cn-hongkong-c**: Hongkong Zone C
*   **cn-hongkong-d**: Hongkong Zone D
*   **cn-wulanchabu-a**: Ulanqab Zone A
*   **cn-wulanchabu-b**: Ulanqab Zone B
*   **cn-wulanchabu-c**: Ulanqab Zone C
*   **ap-southeast-1a**: Singapore Zone A
*   **ap-southeast-1b**: Singapore Zone B
*   **ap-southeast-1c**: Singapore Zone C
*   **ap-southeast-5a**: Jakarta Zone A
*   **ap-southeast-5b**: Jakarta Zone B
*   **ap-southeast-5c**: Jakarta Zone C
*   **eu-central-1a**: Frankfurt Zone A
*   **eu-central-1b**: Frankfurt Zone B
*   **eu-central-1c**: Frankfurt Zone C

> 

*   This parameter is returned if the instance is a replica set or sharded cluster instance that runs MongoDB 4.4 or 5.0 and uses multi-zone deployment.

*   This parameter is returned only if you use the Chine site (aliyun.com).', example='cn-hangzhou-i'),
      shardList?: {
        shardAttribute?: [ 
        {
          nodeClass?: string(name='NodeClass', description='The type of the shard node.', example='dds.shard.mid'),
          nodeDescription?: string(name='NodeDescription', description='The description of the shard node.', example='testshardnode'),
          nodeId?: string(name='NodeId', description='The ID of the shard node.', example='d-bp1cac6f2083****'),
          nodeStorage?: int32(name='NodeStorage', description='The storage capacity of the shard node. Unit: GB.', example='10'),
          readonlyReplicas?: int32(name='ReadonlyReplicas', description='The number of read-only nodes in the shard node. Valid values: **0** to **5**.', example='2'),
        }
      ](name='ShardAttribute')
      }(name='ShardList', description='The details of the shard nodes.

> This parameter is returned if the instance is a sharded cluster instance.'),
      storageType?: string(name='StorageType', description='The storage type of the instance. Valid values:

*   **cloud_essd**: enhanced SSD (ESSD)
*   **local_ssd**: local SSD', example='local_ssd'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key', description='The tag key.', example='test'),
          value?: string(name='Value', description='The tag value.', example='api'),
        }
      ](name='Tag')
      }(name='Tags', description='The details of the resource tags.'),
      vpcAuthMode?: string(name='VpcAuthMode', description='Indicates whether password-free access within a VPC is enabled. Valid values:

*   **Open**: Password-free access is enabled.
*   **Close**: Password-free access is disabled.', example='Close'),
      zoneId?: string(name='ZoneId', description='The zone ID of the instance.', example='cn-hangzhou-g'),
    }
  ](name='DBInstance')
  }(name='DBInstances', description='The details of the instances.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned on each page.', example='30'),
  requestId?: string(name='RequestId', description='The request ID.', example='0E4FE33F-5510-5758-8FA7-A6672CDE****'),
  totalCount?: int32(name='TotalCount', description='The number of instances in the query results.', example='5'),
}

model DescribeDBInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstancesResponseBody(name='body'),
}

/**
  * The list of replica set and standalone instances is displayed when the **DBInstanceType** parameter uses the default value **replicate**. To query a list of sharded cluster instances, you must set the **DBInstanceType** parameter to **sharding**.
  *
  * @param request DescribeDBInstancesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDBInstancesResponse
 */
async function describeDBInstancesWithOptions(request: DescribeDBInstancesRequest, runtime: Util.RuntimeOptions): DescribeDBInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.connectionDomain)) {
    query['ConnectionDomain'] = request.connectionDomain;
  }
  if (!Util.isUnset(request.DBInstanceClass)) {
    query['DBInstanceClass'] = request.DBInstanceClass;
  }
  if (!Util.isUnset(request.DBInstanceDescription)) {
    query['DBInstanceDescription'] = request.DBInstanceDescription;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceStatus)) {
    query['DBInstanceStatus'] = request.DBInstanceStatus;
  }
  if (!Util.isUnset(request.DBInstanceType)) {
    query['DBInstanceType'] = request.DBInstanceType;
  }
  if (!Util.isUnset(request.DBNodeType)) {
    query['DBNodeType'] = request.DBNodeType;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.expireTime)) {
    query['ExpireTime'] = request.expireTime;
  }
  if (!Util.isUnset(request.expired)) {
    query['Expired'] = request.expired;
  }
  if (!Util.isUnset(request.networkType)) {
    query['NetworkType'] = request.networkType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.replicationFactor)) {
    query['ReplicationFactor'] = request.replicationFactor;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstances',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The list of replica set and standalone instances is displayed when the **DBInstanceType** parameter uses the default value **replicate**. To query a list of sharded cluster instances, you must set the **DBInstanceType** parameter to **sharding**.
  *
  * @param request DescribeDBInstancesRequest
  * @return DescribeDBInstancesResponse
 */
async function describeDBInstances(request: DescribeDBInstancesRequest): DescribeDBInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstancesWithOptions(request, runtime);
}

model DescribeDBInstancesOverviewRequest {
  chargeType?: string(name='ChargeType', description='The billing method of the instance. Valid values:

*   **PrePaid**: subscription
*   **PostPaid**: pay-as-you-go', example='PostPaid'),
  engineVersion?: string(name='EngineVersion', description='The database engine version of the instance. Valid values: **5.0**, **4.4**, **4.2**, **4.0**, and **3.4**.', example='4.0'),
  instanceClass?: string(name='InstanceClass', description='The instance type of the instance. The instance type varies based on the instance architecture. For more information about instance types supported by different instance architectures, see the following topics:

*   [Standalone instance types](~~311407~~)
*   [Replica set instance types](~~311410~~)
*   [Sharded cluster instance types](~~311414~~)', example='dds.mongo.2xlarge'),
  instanceIds?: string(name='InstanceIds', description='The ID of the instance for which you want to query the overview information.

> * If you do not specify this parameter, the overview information of all instances under this account is queried.
> * Separate the instance IDs with commas (,).', example='dds-bp12c5b040dc****'),
  instanceStatus?: string(name='InstanceStatus', description='The state of the instance. For more information about valid values, see [Instance states](~~63870~~).', example='Running'),
  instanceType?: string(name='InstanceType', description='The category of the instance. Valid values:

- **sharding**: sharded cluster instance
- **replicate**: replica set or standalone instance

> * To query the overview information of a sharded cluster instance, you must set the parameter to **sharding**.
> * If you do not specify this parameter, the overview information of all instances under this account is queried.', example='replicate'),
  networkType?: string(name='NetworkType', description='The network type of the instance. Valid values:

*   **Classic**
*   **VPC**', example='Classic'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the instance. You can call the [DescribeRegions](~~61933~~) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group. For more information, see [View basic information of a resource group](~~151181~~).', example='rg-acfmyiu4ekp****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.', example='vsw-bp1e7clcw529l773d****'),
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-bp1nme44gek34slfc****'),
  zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-hangzhou-b'),
}

model DescribeDBInstancesOverviewResponseBody = {
  DBInstances?: [ 
    {
      capacityUnit?: string(name='CapacityUnit', description='The I/O throughput consumed by the instance.

> * This parameter is returned when the instance is a serverless instance.
> * Serverless instances are available only in the China site (aliyun.com).', example='100'),
      chargeType?: string(name='ChargeType', description='The billing method of the instance. Valid values:

*   **PrePaid**: subscription
*   **PostPaid**: pay-as-you-go', example='PrePaid'),
      creationTime?: string(name='CreationTime', description='The time when the instance was created. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2022-01-05T03:18:53Z'),
      DBInstanceClass?: string(name='DBInstanceClass', description='The instance type of the instance. The instance type varies based on the instance architecture. For more information about instance types supported by different instance architectures, see the following topics:

*   [Standalone instance types](~~311407~~)
*   [Replica set instance types](~~311410~~)
*   [Sharded cluster instance types](~~311414~~)', example='dds.mongo.mid'),
      DBInstanceDescription?: string(name='DBInstanceDescription', description='The description of the instance.', example='test db'),
      DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bp12c5b040dc****'),
      DBInstanceStatus?: string(name='DBInstanceStatus', description='The state of the instance. For more information about valid values, see [Instance states](~~63870~~).', example='Running'),
      DBInstanceStorage?: int32(name='DBInstanceStorage', description='The storage capacity of the instance.', example='20'),
      DBInstanceType?: string(name='DBInstanceType', description='The category of the instance. Valid values:

*   **sharding**: sharded cluster instance
*   **replicate**: replica set or standalone instance', example='replicate'),
      destroyTime?: string(name='DestroyTime', description='The time when the instance data was destroyed. The time is in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2021-12-10T16:00:00Z'),
      engine?: string(name='Engine', description='The database engine of the instance. Set the value to **MongoDB**.', example='MongoDB'),
      engineVersion?: string(name='EngineVersion', description='The database engine version of the instance.', example='4.2'),
      expireTime?: string(name='ExpireTime', description='The time when the instance expires. The time is in the *yyyy-MM-dd*T*HH:mm*Z format. The time is displayed in UTC.', example='2022-02-05T16:00Z'),
      kindCode?: string(name='KindCode', description='The kind code of the instance. Valid values:

*   **0**: physical machine
*   **1**: Elastic Compute Service (ECS) instance
*   **2**: Docker cluster
*   **18**: Kubernetes cluster', example='0'),
      lastDowngradeTime?: string(name='LastDowngradeTime', description='The last time when the instance was downgraded.', example='2021-05-08'),
      lockMode?: string(name='LockMode', description='Indicates whether the instance is locked. Valid values:

*   **Unlock**: The instance is not locked.
*   **ManualLock**: The cluster is manually locked.
*   **LockByExpiration**: The instance is automatically locked after it expires.
*   **LockByRestoration**: The instance is automatically locked before it is rolled back.
*   **LockByDiskQuota**: The instance is automatically locked after the storage capacity is exhausted.
*   **Released**: The instance is released. After an instance is released, the instance cannot be unlocked. You can only restore the backup data of the instance to a new instance. This process requires an extended period of time.', example='Unlock'),
      mongosList?: [ 
        {
          nodeClass?: string(name='NodeClass', description='The type of the mongos node.', example='dds.mongos.standard'),
          nodeDescription?: string(name='NodeDescription', description='The description of the mongos node.', example='mongos node describe.'),
          nodeId?: string(name='NodeId', description='The ID of the mongos node.', example='s-bp10e3b0d02f****'),
        }
      ](name='MongosList', description='Details about the mongos node.

>  This parameter is returned if the instance is a sharded cluster instance.'),
      networkType?: string(name='NetworkType', description='The network type of the instance. Valid values:

*   **Classic**
*   **VPC**', example='VPC'),
      regionId?: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou'),
      replicationFactor?: string(name='ReplicationFactor', description='The number of nodes in the instance.

>  This parameter is returned if the instance is a replica set instance.', example='3'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfm22cdcgc****'),
      shardList?: [ 
        {
          nodeClass?: string(name='NodeClass', description='The instance type of the shard node.', example='dds.shard.mid'),
          nodeDescription?: string(name='NodeDescription', description='The description of the shard node.', example='testshard'),
          nodeId?: string(name='NodeId', description='The ID of the shard node.', example='d-bp1cac6f2083****'),
          nodeStorage?: int32(name='NodeStorage', description='The storage capacity of the shard node. Unit: GB.', example='10'),
          readonlyReplicas?: int32(name='ReadonlyReplicas', description='The number of read-only nodes in the shard node. Valid values: **0** to **5**.', example='2'),
        }
      ](name='ShardList', description='Details about the shard node.

>  This parameter is returned if the instance is a sharded cluster instance.'),
      tags?: [ 
        {
          key?: string(name='Key', description='The key of tag N of the instance. Valid values of N: **1** to **20**.

*   The key cannot start with `aliyun`, `acs:`, `http://`, or `https://`.
*   The key can be up to 64 characters in length.
*   The key cannot be an empty string.', example='testdatabase'),
          value?: string(name='Value', description='The value of tag N of the instance. Valid values of N: **1** to **20**.

*   The value cannot start with `aliyun`, `acs:`, `http://`, or `https://`.
*   The value can be up to 128 characters in length.
*   The value can be an empty string.', example='apitest'),
        }
      ](name='Tags', description='The tags of the instance.'),
      vpcAuthMode?: string(name='VpcAuthMode', description='Indicates whether password-free access within a VPC is enabled. Valid values:

*   **Open**: Password-free access is enabled.
*   **Close**: Password-free access is disabled.', example='Open'),
      zoneId?: string(name='ZoneId', description='The zone ID of the instance.', example='cn-hangzhou-i'),
    }
  ](name='DBInstances', description='Details about the instances.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='52820D2B-B2DD-59F0-BDF2-83EC19C6F1CA'),
  totalCount?: string(name='TotalCount', description='The number of instances in the query result.', example='1'),
}

model DescribeDBInstancesOverviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstancesOverviewResponseBody(name='body'),
}

/**
  * *   If you do not specify an instance when you call this operation, the overview information of all instances in the specified region within this account is returned.
  * *   Paged query is disabled for this operation.
  *
  * @param request DescribeDBInstancesOverviewRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDBInstancesOverviewResponse
 */
async function describeDBInstancesOverviewWithOptions(request: DescribeDBInstancesOverviewRequest, runtime: Util.RuntimeOptions): DescribeDBInstancesOverviewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.instanceClass)) {
    query['InstanceClass'] = request.instanceClass;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.instanceStatus)) {
    query['InstanceStatus'] = request.instanceStatus;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.networkType)) {
    query['NetworkType'] = request.networkType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstancesOverview',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   If you do not specify an instance when you call this operation, the overview information of all instances in the specified region within this account is returned.
  * *   Paged query is disabled for this operation.
  *
  * @param request DescribeDBInstancesOverviewRequest
  * @return DescribeDBInstancesOverviewResponse
 */
async function describeDBInstancesOverview(request: DescribeDBInstancesOverviewRequest): DescribeDBInstancesOverviewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstancesOverviewWithOptions(request, runtime);
}

model DescribeErrorLogRecordsRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.

>  If you set this parameter to the ID of a sharded cluster instance, you must also specify the **NodeId** parameter.', example='dds-bp12c5b040dc****'),
  DBName?: string(name='DBName', description='The name of the database.', example='mongodbtest'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time and within 24 hours from the start time. Specify the time in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.', example='2019-01-02T12:10Z'),
  nodeId?: string(name='NodeId', description='The ID of the mongos node or shard node whose error logs you want to query in the instance. If the instance is a sharded cluster instance, you must specify this parameter.

>  This parameter is valid only when **DBInstanceId** is set to the ID of a sharded cluster instance.', example='d-bp128a003436****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. The value must be an integer that is greater than 0. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: **30** to **100**.', example='30'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group. For more information, see [View basic information of a resource group](~~151181~~).', example='rg-acfmyiu4ekp****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  roleType?: string(name='RoleType', description='The role of the node whose error logs you want to query in the instance. Valid values:

*   **primary**
*   **secondary**

>  If you set the **NodeId** parameter to the ID of a mongos node, the RoleType parameter must be set to **primary**.', example='primary'),
  securityToken?: string(name='SecurityToken'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.', example='2019-01-01T12:10Z'),
}

model DescribeErrorLogRecordsResponseBody = {
  engine?: string(name='Engine', description='The database engine.', example='MongoDB'),
  items?: {
    logRecords?: [ 
    {
      category?: string(name='Category', description='The category of the log entry. Valid values:

*   NETWORK: network connection log
*   ACCESS: access control log
*   \\-: general log
*   COMMAND: slow query log
*   SHARDING: sharded cluster log
*   STORAGE: storage engine log
*   CONNPOOL: connection pool log
*   ASIO: asynchronous I/O operation log
*   WRITE: slow update log', example='NETWORK'),
      connInfo?: string(name='ConnInfo', description='The connection information of the log entry.', example='conn18xxxxxx'),
      content?: string(name='Content', description='The content of the log entry.', example='xxxxxxxx'),
      createTime?: string(name='CreateTime', description='The time when the log entry was generated. The time is in the *yyyy-MM-dd*T*HH:mm:ss***Z format. The time is displayed in UTC.', example='2019-02-26T12:09:34Z'),
      id?: int32(name='Id', description='The ID of the log entry.', example='1111111111'),
    }
  ](name='LogRecords')
  }(name='Items', description='Details about the log entries returned.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='68BCBEC2-1E66-471F-A1A8-E3C60C0A80B0'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of entries.', example='1'),
}

model DescribeErrorLogRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeErrorLogRecordsResponseBody(name='body'),
}

/**
  * *   This operation is applicable only to **general-purpose local-disk** and **dedicated local-disk** instances.
  * *   You can call this operation up to 30 times per minute. To call this operation at a higher frequency, use a Logstore. For more information, see [Manage a Logstore](~~48990~~).
  *
  * @param request DescribeErrorLogRecordsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeErrorLogRecordsResponse
 */
async function describeErrorLogRecordsWithOptions(request: DescribeErrorLogRecordsRequest, runtime: Util.RuntimeOptions): DescribeErrorLogRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.roleType)) {
    query['RoleType'] = request.roleType;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeErrorLogRecords',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   This operation is applicable only to **general-purpose local-disk** and **dedicated local-disk** instances.
  * *   You can call this operation up to 30 times per minute. To call this operation at a higher frequency, use a Logstore. For more information, see [Manage a Logstore](~~48990~~).
  *
  * @param request DescribeErrorLogRecordsRequest
  * @return DescribeErrorLogRecordsResponse
 */
async function describeErrorLogRecords(request: DescribeErrorLogRecordsRequest): DescribeErrorLogRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeErrorLogRecordsWithOptions(request, runtime);
}

model DescribeGlobalSecurityIPGroupRequest {
  globalSecurityGroupId?: string(name='GlobalSecurityGroupId', example='g-hedmu8kg9nsabw6u42rv'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeGlobalSecurityIPGroupResponseBody = {
  globalSecurityIPGroup?: [ 
    {
      DBInstances?: [ string ](name='DBInstances'),
      GIpList?: string(name='GIpList', example='117.12.202.19'),
      globalIgName?: string(name='GlobalIgName', example='dev_baoxian_k8s_bj'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', example='g-sdgwqyp4f5j1x3qk7yvm'),
      regionId?: string(name='RegionId', example='cn-hangzhou'),
    }
  ](name='GlobalSecurityIPGroup'),
  requestId?: string(name='RequestId', example='72651AF9-7897-41A7-8B67-6C15C7F26A0A'),
}

model DescribeGlobalSecurityIPGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGlobalSecurityIPGroupResponseBody(name='body'),
}

async function describeGlobalSecurityIPGroupWithOptions(request: DescribeGlobalSecurityIPGroupRequest, runtime: Util.RuntimeOptions): DescribeGlobalSecurityIPGroupResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGlobalSecurityIPGroup',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGlobalSecurityIPGroup(request: DescribeGlobalSecurityIPGroupRequest): DescribeGlobalSecurityIPGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGlobalSecurityIPGroupWithOptions(request, runtime);
}

model DescribeGlobalSecurityIPGroupRelationRequest {
  DBClusterId?: string(name='DBClusterId', example='dds-2ze6069764423m0l'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeGlobalSecurityIPGroupRelationResponseBody = {
  DBClusterId?: string(name='DBClusterId', example='dds-2ze6069764423m0l'),
  globalSecurityIPGroupRel?: [ 
    {
      GIpList?: string(name='GIpList', example='27.16.214.10,111.60.117.181'),
      globalIgName?: string(name='GlobalIgName', example='dev_baoxian_k8s_bj'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', example='g-gfurfpsh4ycbrm2avst7'),
      regionId?: string(name='RegionId', example='cn-hongkong'),
    }
  ](name='GlobalSecurityIPGroupRel'),
  requestId?: string(name='RequestId', example='F8CA8312-530A-413A-9129-F2BB32A8D404'),
}

model DescribeGlobalSecurityIPGroupRelationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGlobalSecurityIPGroupRelationResponseBody(name='body'),
}

async function describeGlobalSecurityIPGroupRelationWithOptions(request: DescribeGlobalSecurityIPGroupRelationRequest, runtime: Util.RuntimeOptions): DescribeGlobalSecurityIPGroupRelationResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGlobalSecurityIPGroupRelation',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGlobalSecurityIPGroupRelation(request: DescribeGlobalSecurityIPGroupRelationRequest): DescribeGlobalSecurityIPGroupRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGlobalSecurityIPGroupRelationWithOptions(request, runtime);
}

model DescribeInstanceAutoRenewalAttributeRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bp567b****'),
  DBInstanceType?: string(name='DBInstanceType', description='The category of the instance. Valid values:

*   **replicate**: the standalone or replica set instance
*   **sharding**: the sharded cluster instance

Default value: **replicate**.', example='replicate'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: long(name='PageNumber', description='The number of the page to return. The value must be a positive integer that does not exceed the maximum value of the Integer parameter. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page. Valid values: **30**, **50**, and **100**.

>  Default value: **30**.', example='30'),
  regionId?: string(name='RegionId', description='The region ID of the instance. You can call the [DescribeDBInstanceAttribute](~~62010~~) operation to query the region ID of the instance.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeInstanceAutoRenewalAttributeResponseBody = {
  items?: {
    item?: [ 
    {
      autoRenew?: string(name='AutoRenew', description='Indicates whether auto-renewal is enabled for the instance. Valid values:

*   **true**: Auto-renewal is enabled for the instance.
*   **false**: Auto-renewal is disabled for the instance.', example='true'),
      DBInstanceType?: string(name='DBInstanceType', description='The category of the instance. Valid values:

*   **replicate**: the standalone or replica set instance
*   **sharding**: the sharded cluster instance', example='replicate'),
      dbInstanceId?: string(name='DbInstanceId', description='The ID of the instance.', example='dds-bp2568*****'),
      duration?: string(name='Duration', description='The auto-renewal period. Unit: months.

> * This parameter is ruturned only when the returned value of the **AutoRenew** parameter is **true**.
> * You can call the [ModifyInstanceAutoRenewalAttribute](~~145979~~) operation to modify the auto-renewal period.', example='1'),
      regionId?: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou'),
    }
  ](name='Item')
  }(name='Items', description='Details about returned entries.'),
  itemsNumbers?: int32(name='ItemsNumbers', description='The total number of entries returned.', example='2'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of entries that were returned on the current page.', example='2'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='FAB5CB3B-DB9D-473A-9DF1-F57B6B9CB949'),
}

model DescribeInstanceAutoRenewalAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceAutoRenewalAttributeResponseBody(name='body'),
}

/**
  * This operation is applicable to subscription instances.
  *
  * @param request DescribeInstanceAutoRenewalAttributeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeInstanceAutoRenewalAttributeResponse
 */
async function describeInstanceAutoRenewalAttributeWithOptions(request: DescribeInstanceAutoRenewalAttributeRequest, runtime: Util.RuntimeOptions): DescribeInstanceAutoRenewalAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceType)) {
    query['DBInstanceType'] = request.DBInstanceType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceAutoRenewalAttribute',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * This operation is applicable to subscription instances.
  *
  * @param request DescribeInstanceAutoRenewalAttributeRequest
  * @return DescribeInstanceAutoRenewalAttributeResponse
 */
async function describeInstanceAutoRenewalAttribute(request: DescribeInstanceAutoRenewalAttributeRequest): DescribeInstanceAutoRenewalAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceAutoRenewalAttributeWithOptions(request, runtime);
}

model DescribeKernelReleaseNotesRequest {
  kernelVersion?: string(name='KernelVersion', description='The number of the minor database version. For example: **mongodb\\_20180522\\_0.4.8**.

*   If you specify this parameter, a list of version numbers later than the version specified is returned.
*   If you do not specify this parameter, a list of all the version numbers is returned.', example='mongodb_20180522_0.4.8'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeKernelReleaseNotesResponseBody = {
  releaseNotes?: {
    releaseNote?: [ 
    {
      kernelVersion?: string(name='KernelVersion', description='The version number.', example='mongodb_20180619_0.4.9'),
      releaseNote?: string(name='ReleaseNote', description='Publishes the log.', example='test release note.'),
    }
  ](name='ReleaseNote')
  }(name='ReleaseNotes', description='The list of version release notes.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F01D4DDA-CB72-4083-B399-AF4642294FE6'),
}

model DescribeKernelReleaseNotesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeKernelReleaseNotesResponseBody(name='body'),
}

async function describeKernelReleaseNotesWithOptions(request: DescribeKernelReleaseNotesRequest, runtime: Util.RuntimeOptions): DescribeKernelReleaseNotesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.kernelVersion)) {
    query['KernelVersion'] = request.kernelVersion;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeKernelReleaseNotes',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeKernelReleaseNotes(request: DescribeKernelReleaseNotesRequest): DescribeKernelReleaseNotesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeKernelReleaseNotesWithOptions(request, runtime);
}

model DescribeMongoDBLogConfigRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance. You can call the [DescribeDBInstances](~~61939~~) operation to query the ID of the instance.', example='dds-bp12c5b040dc****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeMongoDBLogConfigResponseBody = {
  enableAudit?: boolean(name='EnableAudit', description='Indicates whether to enable the audit log feature is enabled.

*   **true**
*   **false**', example='true'),
  isEtlMetaExist?: int32(name='IsEtlMetaExist', description='Indicates whether a rule to distribute logs to Logtail is created. For more information, see [Logtail overview](~~28979~~). Valid values:

*   **1**: A rule to distribute logs to Logtail is created.
*   **0** or **null**: A rule to distribute logs to Logtail is not created.', example='1'),
  isUserProjectLogstoreExist?: int32(name='IsUserProjectLogstoreExist', description='Indicates whether a Log Service project exists in the current region. Valid values:

*   **1**: A Log Service project exists in the current region.
*   **0** or **null**: A Log Service project does not exist in the current region.', example='1'),
  preserveStorageForStandard?: long(name='PreserveStorageForStandard', description='The maximum storage space for the formal edition of the audit log feature. If the value is **-1**, no maximum is set.', example='-1'),
  preserveStorageForTrail?: long(name='PreserveStorageForTrail', description='The maximum storage space for the free trial edition of the audit log feature. Unit: bytes. You can set the maximum up to 107,374,182,400 bytes.', example='107374182400'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='664ECE26-658A-47C5-88F6-870B0132E8D2'),
  serviceType?: string(name='ServiceType', description='The type of the audit log feature. Valid values:

*   **Trail**: the free trial edition
*   **Standard**: the official edition', example='Standard'),
  ttlForStandard?: long(name='TtlForStandard', description='The retention period for the official edition of the audit log feature. Valid values: 1 to 365 days.', example='30'),
  ttlForTrail?: long(name='TtlForTrail', description='The retention period for the free trial edition of the audit log feature.', example='1'),
  usedStorageForStandard?: long(name='UsedStorageForStandard', description='The used storage space for the formal edition of the audit log feature. Unit: bytes.', example='20163'),
  usedStorageForTrail?: long(name='UsedStorageForTrail', description='The used storage space for the free trial edition of the audit log feature. Unit: bytes.', example='12548178759'),
  userProjectName?: string(name='UserProjectName', description='The name of the Log Service project.', example='nosql-176498472570****-cn-hangzhou'),
}

model DescribeMongoDBLogConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMongoDBLogConfigResponseBody(name='body'),
}

/**
  * This operation is applicable only to **general-purpose local-disk** and **dedicated local-disk** instances.
  * This operation depends on the audit log feature of ApsaraDB for MongoDB. You can enable the audit log feature based on your business needs. For more information, see [Enable the audit log feature](~~59903~~)
  * *   Starting from January 6, 2022, the official edition of the audit log feature has been launched in all regions, and new applications for the free trial edition have ended. For more information, see [Notice on official launch of the pay-as-you-go audit log feature and no more application for the free trial edition](~~377480~~)
  * *   The official edition is charged based on the storage usage and retention period. For more information, see the [Pricing](https://www.alibabacloud.com/product/apsaradb-for-mongodb/pricing) tab of the ApsaraDB for MongoDB product page.
  *
  * @param request DescribeMongoDBLogConfigRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeMongoDBLogConfigResponse
 */
async function describeMongoDBLogConfigWithOptions(request: DescribeMongoDBLogConfigRequest, runtime: Util.RuntimeOptions): DescribeMongoDBLogConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMongoDBLogConfig',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * This operation is applicable only to **general-purpose local-disk** and **dedicated local-disk** instances.
  * This operation depends on the audit log feature of ApsaraDB for MongoDB. You can enable the audit log feature based on your business needs. For more information, see [Enable the audit log feature](~~59903~~)
  * *   Starting from January 6, 2022, the official edition of the audit log feature has been launched in all regions, and new applications for the free trial edition have ended. For more information, see [Notice on official launch of the pay-as-you-go audit log feature and no more application for the free trial edition](~~377480~~)
  * *   The official edition is charged based on the storage usage and retention period. For more information, see the [Pricing](https://www.alibabacloud.com/product/apsaradb-for-mongodb/pricing) tab of the ApsaraDB for MongoDB product page.
  *
  * @param request DescribeMongoDBLogConfigRequest
  * @return DescribeMongoDBLogConfigResponse
 */
async function describeMongoDBLogConfig(request: DescribeMongoDBLogConfigRequest): DescribeMongoDBLogConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMongoDBLogConfigWithOptions(request, runtime);
}

model DescribeParameterModificationHistoryRequest {
  characterType?: string(name='CharacterType', description='The role of the instance. Valid values:

*   **db**: shard
*   **cs**: Configserver
*   **mongos**: mongos
*   **logic**: sharded cluster instance', example='mongos'),
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.

>  If you set this parameter to the ID of a sharded cluster instance, you must also specify the **NodeId** parameter.', example='dds-bp2235****'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2019-01-02T12:10:10Z'),
  nodeId?: string(name='NodeId', description='The ID of the mongos node or shard node whose parameter modification records you want to query in the instance. If the instance is a sharded cluster instance, you must specify this parameter.

>  This parameter is valid only when **DBInstanceId** is set to the ID of a sharded cluster instance.', example='d-bp1158****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2019-01-01T12:10:10Z'),
}

model DescribeParameterModificationHistoryResponseBody = {
  historicalParameters?: {
    historicalParameter?: [ 
    {
      modifyTime?: string(name='ModifyTime', description='The time when the parameter was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2019-03-12T07:58:24Z'),
      newParameterValue?: string(name='NewParameterValue', description='The parameter value after modification.', example='200'),
      oldParameterValue?: string(name='OldParameterValue', description='The parameter value before modification.', example='100'),
      parameterName?: string(name='ParameterName', description='The name of the modified parameter.', example='operationProfiling.slowOpThresholdMs'),
    }
  ](name='HistoricalParameter')
  }(name='HistoricalParameters', description='Details about the parameter modification records.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B1BB6E0E-B4EF-4145-81FA-A07719860248'),
}

model DescribeParameterModificationHistoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeParameterModificationHistoryResponseBody(name='body'),
}

async function describeParameterModificationHistoryWithOptions(request: DescribeParameterModificationHistoryRequest, runtime: Util.RuntimeOptions): DescribeParameterModificationHistoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.characterType)) {
    query['CharacterType'] = request.characterType;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeParameterModificationHistory',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeParameterModificationHistory(request: DescribeParameterModificationHistoryRequest): DescribeParameterModificationHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeParameterModificationHistoryWithOptions(request, runtime);
}

model DescribeParameterTemplatesRequest {
  engine?: string(name='Engine', description='The database engine of the instance. Set the value to **MongoDB**.', example='mongodb'),
  engineVersion?: string(name='EngineVersion', description='The database engine version of the instance. Valid values:

*   **5.0**
*   **4.4**
*   **4.2**
*   **4.0**
*   **3.4**', example='5.0'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the instance. You can call the [DescribeRegions](~~61933~~) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeParameterTemplatesResponseBody = {
  engine?: string(name='Engine', description='The database engine of the instance.', example='mongodb'),
  engineVersion?: string(name='EngineVersion', description='The database engine version of the instance.', example='5.0'),
  parameterCount?: string(name='ParameterCount', description='The number of parameters that are supported by the instance.', example='10'),
  parameters?: {
    templateRecord?: [ 
    {
      checkingCode?: string(name='CheckingCode', description='The value range of modifiable parameters.', example='[0-65536]'),
      forceModify?: boolean(name='ForceModify', description='Indicates whether the parameter is modifiable.

*   **false**: The parameter cannot be modified.
*   **true**: The parameter can be modified.', example='true'),
      forceRestart?: boolean(name='ForceRestart', description='Indicates whether a restart is required for parameter modifications to take effect.

*   **false**: A restart is not required. Parameter modifications immediately take effect.
*   **true**: A restart is required for parameter modifications to take effect.', example='false'),
      parameterDescription?: string(name='ParameterDescription', description='The description of the parameter.', example='The threshold in milliseconds at which the database profiler considers a query slow, default is 100.'),
      parameterName?: string(name='ParameterName', description='The name of the parameter.', example='net.compression.compressors'),
      parameterValue?: string(name='ParameterValue', description='The default value of the parameter.', example='100'),
    }
  ](name='TemplateRecord')
  }(name='Parameters', description='Details about the parameter templates.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BDA54203-9D61-54A3-A568-D281F785****'),
}

model DescribeParameterTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeParameterTemplatesResponseBody(name='body'),
}

async function describeParameterTemplatesWithOptions(request: DescribeParameterTemplatesRequest, runtime: Util.RuntimeOptions): DescribeParameterTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeParameterTemplates',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeParameterTemplates(request: DescribeParameterTemplatesRequest): DescribeParameterTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeParameterTemplatesWithOptions(request, runtime);
}

model DescribeParametersRequest {
  characterType?: string(name='CharacterType', description='The role of the instance. Valid values:

*   db: a shard node.
*   cs: a Configserver node.
*   mongos: a mongos node.', example='mongos'),
  DBInstanceId?: string(name='DBInstanceId', description='The instance ID.

>  If you set this parameter to the ID of a sharded cluster instance, you must also specify the **NodeId** parameter.', example='dds-bpxxxxxxxx'),
  extraParam?: string(name='ExtraParam', description='The parameter that is available in the future.', example='terrform'),
  nodeId?: string(name='NodeId', description='The ID of the mongos or shard node in the specified sharded cluster instance.

>  This parameter is valid only when you specify the **DBInstanceId** parameter to the ID of a sharded cluster instance.', example='d-bpxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeParametersResponseBody = {
  configParameters?: {
    parameter?: [ 
    {
      checkingCode?: string(name='CheckingCode', description='The valid values of the parameter.', example='[0-65536]'),
      forceRestart?: boolean(name='ForceRestart', description='Indicates whether a restart is required for parameter modifications to take effect. Valid values:

*   **false**: A restart is not required. Modifications take effect immediately.
*   **true**: A restart is required for parameter modifications to take effect.', example='true'),
      modifiableStatus?: boolean(name='ModifiableStatus', description='Indicates whether the parameter value can be modified. Valid values:

*   **false**: The parameter value cannot be modified.
*   **true**: The parameter value can be modified.', example='true'),
      parameterDescription?: string(name='ParameterDescription', description='The description of the parameter.', example='The threshold in milliseconds at which the database profiler considers a query slow, default is 100.'),
      parameterName?: string(name='ParameterName', description='The name of the parameter.', example='operationProfiling.slowOpThresholdMs'),
      parameterValue?: string(name='ParameterValue', description='The value of the parameter.', example='200'),
    }
  ](name='Parameter')
  }(name='ConfigParameters', description='The settings of parameters that are being configured.'),
  engine?: string(name='Engine', description='The database engine of the instance. Default value: **mongodb**.', example='mongodb'),
  engineVersion?: string(name='EngineVersion', description='The database engine version of the instance.', example='4.0'),
  requestId?: string(name='RequestId', description='The request ID.', example='3ADD0C7D-2D2A-4F15-88FF-E7AC9B9FDCC8'),
  runningParameters?: {
    parameter?: [ 
    {
      characterType?: string(name='CharacterType', description='The role of the instance. Valid values:

*   **db**: a shard node.
*   **cs**: a Configserver node.
*   **mongos**: a mongos node.', example='db'),
      checkingCode?: string(name='CheckingCode', description='The valid values of the parameter.', example='[33554432-268435456]'),
      forceRestart?: string(name='ForceRestart', description='Indicates whether a restart is required for parameter modifications to take effect. Valid values:

*   **false**: A restart is not required. Modifications take effect immediately.
*   **true**: A restart is required for parameter modifications to take effect.', example='false'),
      modifiableStatus?: string(name='ModifiableStatus', description='Indicates whether the parameter value can be modified. Valid values:

*   **false**: The parameter value cannot be modified.
*   **true**: The parameter value can be modified.', example='true'),
      parameterDescription?: string(name='ParameterDescription', description='The description of the parameter.', example='The maximum memory bytes that sort stage may use, default is 33554432(i.e. 32MB)'),
      parameterName?: string(name='ParameterName', description='The name of the parameter.', example='setParameter.internalQueryExecMaxBlockingSortBytes'),
      parameterValue?: string(name='ParameterValue', description='The value of the parameter.', example='33554432'),
    }
  ](name='Parameter')
  }(name='RunningParameters', description='The settings of the parameters that have taken effect.'),
}

model DescribeParametersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeParametersResponseBody(name='body'),
}

async function describeParametersWithOptions(request: DescribeParametersRequest, runtime: Util.RuntimeOptions): DescribeParametersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.characterType)) {
    query['CharacterType'] = request.characterType;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.extraParam)) {
    query['ExtraParam'] = request.extraParam;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeParameters',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeParameters(request: DescribeParametersRequest): DescribeParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeParametersWithOptions(request, runtime);
}

model DescribePriceRequest {
  businessInfo?: string(name='BusinessInfo', description='The business information. This is an additional parameter.', example='{"AccountPassword":"Pw123456","DBInstanceDescription":"test"}'),
  commodityCode?: string(name='CommodityCode', description='The code of the instance. Valid values:

*   **dds**: a replica set instance that uses the pay-as-you-go billing method
*   **badds**: a replica set instance that uses the subscription billing method
*   **dds_sharding**: a sharded cluster instance that uses the pay-as-you-go billing method
*   **badds_sharding**: a sharded cluster instance that uses the subscription billing method
*   **badds_sharding_intl**: a sharded cluster instance that uses the subscription billing method and is available on the International site (alibabacloud.com)
*   **badds_sharding_jp**: a sharded cluster instance that uses the subscription billing method and is available on the Japan site (jp.alibabacloud.com)', example='badds'),
  couponNo?: string(name='CouponNo', description='The coupon code. Default value: **youhuiquan_promotion_option_id_for_blank**.', example='youhuiquan_promotion_option_id_for_blank'),
  DBInstances?: string(name='DBInstances', description='A JSON string that contains the details of the ApsaraDB for MongoDB instance. For more information, see the [DBInstances](~~197291~~) parameter in the DescribePrice operation.', example='[ { "DBInstanceId":"dds-bp1b6e54e7cc****", "RegionId":"cn-hangzhou", "ZoneId":"cn-hangzhou-h", "Engine":"MongoDB", "EngineVersion":" 5.0", "DBInstanceClass":"mdb.shard.2x.xlarge.d", "DBInstanceStorage":30, "ChargeType":"PrePaid", "Period":1, "StorageType":"cloud_essd1" } ]'),
  orderParamOut?: string(name='OrderParamOut', description='Specifies whether to return the OrderParams parameter. Valid values:

*   **false** (default)
*   **true**', example='true'),
  orderType?: string(name='OrderType', description='The order type. Valid values:

*   **BUY**
*   **UPGRADE**
*   **RENEW**', example='BUY'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  productCode?: string(name='ProductCode', description='The code of the service. Default value: **dds**.', example='dds'),
  regionId?: string(name='RegionId', description='The region ID of the instance. You can call the [DescribeRegions](~~61933~~) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group. For more information, see [View basic information of a resource group](~~151181~~).', example='rg-acfmyiu4ekp****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribePriceResponseBody = {
  order?: {
    coupons?: {
      coupon?: [ 
      {
        activityCategory?: string(name='ActivityCategory', description='The billing method to which the coupon was applied. Valid values: **payondemand**: subscription. **payasyougo**: pay-as-you-go.', example='payondemand'),
        couponNo?: string(name='CouponNo', description='The coupon ID.', example='youhuiquan_promotion_option_id_for_blank'),
        description?: string(name='Description', description='The description of the coupon.', example='ceshi'),
        isSelected?: string(name='IsSelected', description='Indicates whether the coupon was selected. Valid values:

*   **true**
*   **false**', example='true'),
        name?: string(name='Name', description='The coupon name.', example='youhuiquan111'),
        optionCode?: string(name='OptionCode', description='The code of the coupon.', example='youhui_quan'),
        promotionOptionCode?: string(name='PromotionOptionCode', description='The promotional option code.', example='youhui_quan'),
        promotionRuleIdList?: {
          promotionRuleId?: [ long ](name='PromotionRuleId')
        }(name='PromotionRuleIdList', description='The rules that match the coupon.'),
      }
    ](name='Coupon')
    }(name='Coupons', description='The coupons.'),
    currency?: string(name='Currency', description='The currency.', example='USD'),
    discountAmount?: string(name='DiscountAmount', description='The discount amount of the order.', example='322.4'),
    originalAmount?: string(name='OriginalAmount', description='The original price of the order.', example='322.4'),
    ruleIds?: {
      ruleId?: [ string ](name='RuleId')
    }(name='RuleIds', description='The rules of the order.'),
    showDiscountInfo?: boolean(name='ShowDiscountInfo'),
    tradeAmount?: string(name='TradeAmount', description='The final price of the order.', example='0'),
  }(name='Order', description='The order.'),
  orderParams?: string(name='OrderParams', description='The order parameters.

> This parameter is returned only when the **OrderParamOut** parameter is set to **true**.', example='{\\"autoPay\\":false}"'),
  requestId?: string(name='RequestId', description='The request ID.', example='27227A3D-6B86-56F3-9E03-9E60F001CE12'),
  rules?: {
    rule?: [ 
    {
      name?: string(name='Name', description='The name of the rule.', example='demoname'),
      ruleDescId?: long(name='RuleDescId', description='The ID of the policy.', example='2075****'),
      title?: string(name='Title', description='The title of the rule.', example='demo'),
    }
  ](name='Rule')
  }(name='Rules', description='The promotion rules.'),
  subOrders?: {
    subOrder?: [ 
    {
      discountAmount?: string(name='DiscountAmount', description='The discount amount of the order.', example='322.4'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='dds-bp1b6e54e7cc****'),
      originalAmount?: string(name='OriginalAmount', description='The original price of the order.', example='322.4'),
      ruleIds?: {
        ruleId?: [ string ](name='RuleId')
      }(name='RuleIds', description='The promotion rules.'),
      tradeAmount?: string(name='TradeAmount', description='The actual price of the order.', example='0'),
    }
  ](name='SubOrder')
  }(name='SubOrders', description='The coupon rules.'),
  traceId?: string(name='TraceId', description='The ID of the trace.', example='27227A3D-6B87-56F3-9E03-9E60F001****'),
}

model DescribePriceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePriceResponseBody(name='body'),
}

async function describePriceWithOptions(request: DescribePriceRequest, runtime: Util.RuntimeOptions): DescribePriceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.businessInfo)) {
    query['BusinessInfo'] = request.businessInfo;
  }
  if (!Util.isUnset(request.commodityCode)) {
    query['CommodityCode'] = request.commodityCode;
  }
  if (!Util.isUnset(request.couponNo)) {
    query['CouponNo'] = request.couponNo;
  }
  if (!Util.isUnset(request.DBInstances)) {
    query['DBInstances'] = request.DBInstances;
  }
  if (!Util.isUnset(request.orderParamOut)) {
    query['OrderParamOut'] = request.orderParamOut;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePrice',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePrice(request: DescribePriceRequest): DescribePriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePriceWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='Specifies the language of the returned **RegionName** and **ZoneName** values. Default value: zh. Valid values:

*   **zh**: Chinese.
*   **en**: English', example='zh'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the region.

>  If you do not specify this parameter, all supported regions are queried.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeRegionsResponseBody = {
  regions?: {
    ddsRegion?: [ 
    {
      endPoint?: string(name='EndPoint'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
      regionName?: string(name='RegionName', description='The name of the region.

The return value of the LocalName parameter is in the language that is specified by the **AcceptLanguage** parameter.', example='China (Hangzhou)'),
      zones?: {
        zone?: [ 
        {
          vpcEnabled?: boolean(name='VpcEnabled', description='Indicates whether a virtual private cloud (VPC) is supported. Valid values:

*   **true**: VPC is supported.
*   **false**: VPC is not supported.', example='true'),
          zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-hangzhou-h'),
          zoneName?: string(name='ZoneName', description='The name of the zone.

The return value of the LocalName parameter is in the language that is specified by the **AcceptLanguage** parameter.', example='Hangzhou Zone H'),
        }
      ](name='Zone')
      }(name='Zones', description='Details about the zones.'),
    }
  ](name='DdsRegion')
  }(name='Regions', description='Details about the regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4E46C22C-D3B7-4DB8-9C76-63851BE68E20'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

/**
  * >  To query available regions and zones where ApsaraDB for MongoDB instances can be created, call the [DescribeAvailableResource](~~149719~~) operation.
  *
  * @param request DescribeRegionsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeRegionsResponse
 */
async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  To query available regions and zones where ApsaraDB for MongoDB instances can be created, call the [DescribeAvailableResource](~~149719~~) operation.
  *
  * @param request DescribeRegionsRequest
  * @return DescribeRegionsResponse
 */
async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeRenewalPriceRequest {
  businessInfo?: string(name='BusinessInfo', description='The business information. This is an additional parameter.', example='{“ActivityId":"000000000"}'),
  couponNo?: string(name='CouponNo', description='The coupon code. Default value: **youhuiquan_promotion_option_id_for_blank**.', example='youhuiquan_promotion_option_id_for_blank'),
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bp12c5b040dc****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeRenewalPriceResponseBody = {
  order?: {
    coupons?: {
      coupon?: [ 
      {
        couponNo?: string(name='CouponNo', description='The coupon number.', example='youhuiquan_promotion_option_id_for_blank'),
        description?: string(name='Description', description='The description of the coupon.', example='coupondemo'),
        isSelected?: string(name='IsSelected', description='Indicates whether the coupon was selected.', example='true'),
        name?: string(name='Name', description='The name of the coupon.', example='youhuiquan111'),
      }
    ](name='Coupon')
    }(name='Coupons', description='Details about the coupons.'),
    currency?: string(name='Currency', description='The type of the currency. Valid values:

*   USD: United States dollar
*   JPY: Japanese Yen', example='USD'),
    discountAmount?: float(name='DiscountAmount', description='The discount amount of the order.', example='1144.8'),
    originalAmount?: float(name='OriginalAmount', description='The original price of the order.', example='1144.8'),
    ruleIds?: {
      ruleId?: [ string ](name='RuleId')
    }(name='RuleIds', description='The IDs of the matched rules.'),
    tradeAmount?: float(name='TradeAmount', description='The actual price of the order.', example='0'),
  }(name='Order', description='The list of orders.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='EFD65226-08CC-4C4D-B6A4-CB3C382F67B0'),
  rules?: {
    rule?: [ 
    {
      name?: string(name='Name', description='The name of the rule.', example='demoname'),
      ruleDescId?: long(name='RuleDescId', description='The ID of the rule.', example='11111111'),
      title?: string(name='Title', description='The title of the rule.', example='demo'),
    }
  ](name='Rule')
  }(name='Rules', description='Details about the promotion rules.'),
  subOrders?: {
    subOrder?: [ 
    {
      discountAmount?: float(name='DiscountAmount', description='The discount amount of the order.', example='1144.8'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='dds-bp12c5b040dc****'),
      originalAmount?: float(name='OriginalAmount', description='The original price of the order.', example='1144.8'),
      ruleIds?: {
        ruleId?: [ string ](name='RuleId')
      }(name='RuleIds', description='The IDs of the matched rules.'),
      tradeAmount?: float(name='TradeAmount', description='The actual price of the order.', example='0'),
    }
  ](name='SubOrder')
  }(name='SubOrders', description='The rules matching the coupons.'),
}

model DescribeRenewalPriceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRenewalPriceResponseBody(name='body'),
}

/**
  * This operation is applicable to subscription instances.
  *
  * @param request DescribeRenewalPriceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeRenewalPriceResponse
 */
async function describeRenewalPriceWithOptions(request: DescribeRenewalPriceRequest, runtime: Util.RuntimeOptions): DescribeRenewalPriceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.businessInfo)) {
    query['BusinessInfo'] = request.businessInfo;
  }
  if (!Util.isUnset(request.couponNo)) {
    query['CouponNo'] = request.couponNo;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRenewalPrice',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * This operation is applicable to subscription instances.
  *
  * @param request DescribeRenewalPriceRequest
  * @return DescribeRenewalPriceResponse
 */
async function describeRenewalPrice(request: DescribeRenewalPriceRequest): DescribeRenewalPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRenewalPriceWithOptions(request, runtime);
}

model DescribeReplicaSetRoleRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bpxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeReplicaSetRoleResponseBody = {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bpxxxxxxxx'),
  replicaSets?: {
    replicaSet?: [ 
    {
      connectionDomain?: string(name='ConnectionDomain', description='The endpoint of the node.', example='dds-bpxxxxxxxx.mongodb.rds.aliyuncs.com'),
      connectionPort?: string(name='ConnectionPort', description='The port of the node.', example='3717'),
      expiredTime?: string(name='ExpiredTime', description='The remaining duration of the classic network endpoint. Unit: seconds.', example='1209582'),
      networkType?: string(name='NetworkType', description='The network type. Valid values:

*   **VPC**
*   **Classic**
*   **Public**', example='VPC'),
      replicaSetRole?: string(name='ReplicaSetRole', description='The role of the node in the replica set.

*   **Primary**
*   **Secondary**', example='Primary'),
      roleId?: string(name='RoleId', description='The role ID of the node.', example='651xxxxx'),
    }
  ](name='ReplicaSet')
  }(name='ReplicaSets', description='Details about the replica set roles.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='DB4A0595-FCA9-437F-B2BB-25DBFC009D3E'),
}

model DescribeReplicaSetRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeReplicaSetRoleResponseBody(name='body'),
}

/**
  * This operation is applicable to replica set instances and standalone instances, but not to sharded cluster instances.
  *
  * @param request DescribeReplicaSetRoleRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeReplicaSetRoleResponse
 */
async function describeReplicaSetRoleWithOptions(request: DescribeReplicaSetRoleRequest, runtime: Util.RuntimeOptions): DescribeReplicaSetRoleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeReplicaSetRole',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * This operation is applicable to replica set instances and standalone instances, but not to sharded cluster instances.
  *
  * @param request DescribeReplicaSetRoleRequest
  * @return DescribeReplicaSetRoleResponse
 */
async function describeReplicaSetRole(request: DescribeReplicaSetRoleRequest): DescribeReplicaSetRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeReplicaSetRoleWithOptions(request, runtime);
}

model DescribeRoleZoneInfoRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bpxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeRoleZoneInfoResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='728B9A96-E262-4AE5-915E-3A51CCE2FDA9'),
  zoneInfos?: {
    zoneInfo?: [ 
    {
      insName?: string(name='InsName', description='The ID of the node.', example='dds-bpxxxxxxxx'),
      nodeType?: string(name='NodeType', description='The type of the node. Valid values:

*   **normal**
*   **configServer**
*   **shard**
*   **mongos**

>  Valid value for replica set instances: **normal**. Valid values for replica set instances: **configServer**, **shard**, and **mongos**.', example='normal'),
      roleId?: string(name='RoleId', description='The ID of the role.', example='83xxxxx'),
      roleType?: string(name='RoleType', description='The role of the node. Valid values:

*   **Primary**
*   **Secondary**
*   **Hidden**', example='Primary'),
      zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-e'),
    }
  ](name='ZoneInfo')
  }(name='ZoneInfos', description='An array that consists of information of nodes in the zone.'),
}

model DescribeRoleZoneInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRoleZoneInfoResponseBody(name='body'),
}

/**
  * >  For more information, see [View the zone of a node](~~123825~~).
  * This operation is applicable only to replica set and sharded cluster instances, but not to standalone instances.
  *
  * @param request DescribeRoleZoneInfoRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeRoleZoneInfoResponse
 */
async function describeRoleZoneInfoWithOptions(request: DescribeRoleZoneInfoRequest, runtime: Util.RuntimeOptions): DescribeRoleZoneInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRoleZoneInfo',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  For more information, see [View the zone of a node](~~123825~~).
  * This operation is applicable only to replica set and sharded cluster instances, but not to standalone instances.
  *
  * @param request DescribeRoleZoneInfoRequest
  * @return DescribeRoleZoneInfoResponse
 */
async function describeRoleZoneInfo(request: DescribeRoleZoneInfoRequest): DescribeRoleZoneInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRoleZoneInfoWithOptions(request, runtime);
}

model DescribeRunningLogRecordsRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.

>  If you set this parameter to the ID of a sharded cluster instance, you must also specify the **NodeId** parameter.', example='dds-bpxxxxxxxx'),
  DBName?: string(name='DBName', description='The name of the database.', example='mongodbtest'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.

>  The end time must be later than the start time and within 24 hours from the start time. Otherwise, the query fails.', example='2019-01-01T13:10Z'),
  nodeId?: string(name='NodeId', description='The ID of the mongos node or shard node whose operational logs you want to query in the instance. If the instance is a sharded cluster instance, you must specify this parameter.

>  This parameter is valid only when **DBInstanceId** is set to the ID of a sharded cluster instance.', example='d-bpxxxxxxxx'),
  orderType?: string(name='OrderType', description='The order of time in which the operational log entries to return are sorted. Valid values:

*   asc: The log entries are sorted by time in ascending order.
*   desc: The log entries are sorted by time in descending order.', example='asc'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. The value must be an integer that is greater than 0. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: **30** to **100**.', example='30'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='sg-bpxxxxxxxxxxxxxxxxxx'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  roleId?: string(name='RoleId', description='The role ID of the node. You can call the [DescribeReplicaSetRole](~~62134~~) operation to query the role ID.', example='651xxxxx'),
  roleType?: string(name='RoleType', description='The role of the node whose error logs you want to query in the instance. Valid values:

*   **primary**
*   **secondary**

>  If you set the **NodeId** parameter to the ID of a mongos node, the **RoleType** parameter must be set to **primary**.', example='primary'),
  securityToken?: string(name='SecurityToken'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.', example='2019-01-01T12:10Z'),
}

model DescribeRunningLogRecordsResponseBody = {
  engine?: string(name='Engine', description='The database engine.', example='MongoDB'),
  items?: {
    logRecords?: [ 
    {
      category?: string(name='Category', description='The category of the log entry. Valid values:', example='NETWORK'),
      connInfo?: string(name='ConnInfo', description='The connection information of the log entry.', example='conn18xxxxxx'),
      content?: string(name='Content', description='The content of the log entry.', example='end connection 11.xxx.xxx.xx:3xxxx (0 connections now open)\\n'),
      createTime?: string(name='CreateTime', description='The time when the log entry was generated. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2019-02-26T12:09:34Z'),
    }
  ](name='LogRecords')
  }(name='Items', description='Details about the operational log entries.'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of entries returned per page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='45D2B592-DEBA-4347-BBF3-47FF6C97DBBC'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of entries.', example='2'),
}

model DescribeRunningLogRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRunningLogRecordsResponseBody(name='body'),
}

/**
  * *   This operation is applicable only to **general-purpose local-disk** and **dedicated local-disk** instances.
  * *   You can call this operation up to 30 times per minute. To call this operation at a higher frequency, use a Logstore. For more information, see [Manage a Logstore](~~48990~~).
  *
  * @param request DescribeRunningLogRecordsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeRunningLogRecordsResponse
 */
async function describeRunningLogRecordsWithOptions(request: DescribeRunningLogRecordsRequest, runtime: Util.RuntimeOptions): DescribeRunningLogRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.roleId)) {
    query['RoleId'] = request.roleId;
  }
  if (!Util.isUnset(request.roleType)) {
    query['RoleType'] = request.roleType;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRunningLogRecords',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   This operation is applicable only to **general-purpose local-disk** and **dedicated local-disk** instances.
  * *   You can call this operation up to 30 times per minute. To call this operation at a higher frequency, use a Logstore. For more information, see [Manage a Logstore](~~48990~~).
  *
  * @param request DescribeRunningLogRecordsRequest
  * @return DescribeRunningLogRecordsResponse
 */
async function describeRunningLogRecords(request: DescribeRunningLogRecordsRequest): DescribeRunningLogRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRunningLogRecordsWithOptions(request, runtime);
}

model DescribeSecurityGroupConfigurationRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bpxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeSecurityGroupConfigurationResponseBody = {
  items?: {
    rdsEcsSecurityGroupRel?: [ 
    {
      netType?: string(name='NetType', description='The network type of the ECS security group. Valid values:

*   **vpc**
*   **classic**', example='vpc'),
      regionId?: string(name='RegionId', description='The region ID of the ECS security group.', example='cn-hangzhou'),
      securityGroupId?: string(name='SecurityGroupId', description='The ID of the ECS security group.', example='sg-bpxxxxxxxx'),
    }
  ](name='RdsEcsSecurityGroupRel')
  }(name='Items', description='Details about the ECS security groups.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3C4A2494-85C4-45C5-93CF-548DB3375193'),
}

model DescribeSecurityGroupConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSecurityGroupConfigurationResponseBody(name='body'),
}

async function describeSecurityGroupConfigurationWithOptions(request: DescribeSecurityGroupConfigurationRequest, runtime: Util.RuntimeOptions): DescribeSecurityGroupConfigurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecurityGroupConfiguration',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSecurityGroupConfiguration(request: DescribeSecurityGroupConfigurationRequest): DescribeSecurityGroupConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecurityGroupConfigurationWithOptions(request, runtime);
}

model DescribeSecurityIpsRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bpxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeSecurityIpsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='FC724D23-2962-479E-ABB1-606C935AE7FD'),
  securityIpGroups?: {
    securityIpGroup?: [ 
    {
      securityIpGroupAttribute?: string(name='SecurityIpGroupAttribute', description='The attribute of the IP whitelist. This parameter is empty by default.', example='hidden'),
      securityIpGroupName?: string(name='SecurityIpGroupName', description='The name of the IP whitelist.', example='default'),
      securityIpList?: string(name='SecurityIpList', description='The IP addresses in the whitelist.', example='47.xxx.xxx.xx,100.xxx.xxx.0/24'),
    }
  ](name='SecurityIpGroup')
  }(name='SecurityIpGroups', description='An array that consists of the information of IP whitelists.'),
  securityIps?: string(name='SecurityIps', description='The IP addresses in the default whitelist.', example='47.xxx.xxx.xx,100.xxx.xxx.0/24'),
}

model DescribeSecurityIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSecurityIpsResponseBody(name='body'),
}

async function describeSecurityIpsWithOptions(request: DescribeSecurityIpsRequest, runtime: Util.RuntimeOptions): DescribeSecurityIpsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecurityIps',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSecurityIps(request: DescribeSecurityIpsRequest): DescribeSecurityIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecurityIpsWithOptions(request, runtime);
}

model DescribeShardingNetworkAddressRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of an instance.', example='dds-bpxxxxxxxx'),
  nodeId?: string(name='NodeId', description='A sharded cluster instance consists of three components: mongos, shard, and Configserver.

>  You can call the [DescribeDBInstanceAttribute](~~62010~~) operation to query the ID of the mongos, shard, or Configserverr node.', example='d-bpxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeShardingNetworkAddressResponseBody = {
  compatibleConnections?: {
    compatibleConnection?: [ 
    {
      expiredTime?: string(name='ExpiredTime', description='The remaining duration of the classic network address. Unit: seconds.', example='2591963'),
      IPAddress?: string(name='IPAddress', description='The IP address of the instance.', example='10.140.xxx.xx'),
      networkAddress?: string(name='NetworkAddress', description='The endpoint of the instance.', example='dds-bpxxxxxxxxxxxxxx.mongodb.rds.aliyuncs.com'),
      networkType?: string(name='NetworkType', description='The network type. Valid values:

*   **VPC**
*   **Classic**
*   **Public**: pubic endpoint', example='VPC'),
      port?: string(name='Port', description='The port number.', example='3717'),
      VPCId?: string(name='VPCId', description='The ID of the VPC.

>  This parameter is returned when the network type is **VPC**.', example='vpc-bpxxxxxxxx'),
      vswitchId?: string(name='VswitchId', description='The vSwitch ID of the VPC.

>  This parameter is returned when the network type is **VPC**.', example='vsw-bpxxxxxxxx'),
    }
  ](name='CompatibleConnection')
  }(name='CompatibleConnections', description='An array that consists of the endpoints of DynamoDB instances.'),
  networkAddresses?: {
    networkAddress?: [ 
    {
      expiredTime?: string(name='ExpiredTime', description='The remaining duration of the classic network address. Unit: seconds.', example='2591963'),
      IPAddress?: string(name='IPAddress', description='The IP address of the instance.', example='10.140.xxx.xx'),
      networkAddress?: string(name='NetworkAddress', description='The endpoint of the instance.', example='s-bpxxxxxxxx.mongodb.rds.aliyuncs.com'),
      networkType?: string(name='NetworkType', description='The network type. Valid values:

- **VPC**
- **Classic**
- **Public**: pubic endpoint', example='VPC'),
      nodeId?: string(name='NodeId', description='The ID of the mongos.', example='s-bpxxxxxxxx'),
      nodeType?: string(name='NodeType', description='The type of the node. Valid values:

- **mongos**
- **shard**
- **configserver**', example='mongos'),
      port?: string(name='Port', description='The port number.', example='3717'),
      role?: string(name='Role', description='The role of the node. Valid values:

- Primary
- Secondary', example='Primary'),
      VPCId?: string(name='VPCId', description='The ID of the VPC.

>  This parameter is returned when the network type is **VPC**.', example='vpc-bpxxxxxxxx'),
      vswitchId?: string(name='VswitchId', description='The vSwitch ID of the VPC.

>  This parameter is returned when the network type is **VPC**.', example='vsw-bpxxxxxxxx'),
    }
  ](name='NetworkAddress')
  }(name='NetworkAddresses', description='An array that consists of the endpoints of ApsaraDB for MongoDB instances.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='18D8AAFD-6BEB-420F-8164-810CB0C0AA39'),
}

model DescribeShardingNetworkAddressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeShardingNetworkAddressResponseBody(name='body'),
}

/**
  * This operation supports sharded cluster instances only.
  *
  * @param request DescribeShardingNetworkAddressRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeShardingNetworkAddressResponse
 */
async function describeShardingNetworkAddressWithOptions(request: DescribeShardingNetworkAddressRequest, runtime: Util.RuntimeOptions): DescribeShardingNetworkAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeShardingNetworkAddress',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * This operation supports sharded cluster instances only.
  *
  * @param request DescribeShardingNetworkAddressRequest
  * @return DescribeShardingNetworkAddressResponse
 */
async function describeShardingNetworkAddress(request: DescribeShardingNetworkAddressRequest): DescribeShardingNetworkAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeShardingNetworkAddressWithOptions(request, runtime);
}

model DescribeSlowLogRecordsRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.

> If you set this parameter to the ID of a sharded cluster instance, you must also specify the `NodeId` parameter.', example='dds-bp1fc7e65108****'),
  DBName?: string(name='DBName', description='The name of the database.', example='mongodbtest'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.

> 

*   The end time must be later than the start time.

*   The end time must be within 24 hours from the start time. Otherwise, the query fails.', example='2021-08-16T14:13Z'),
  nodeId?: string(name='NodeId', description='The ID of the shard node.

> This parameter is required only when you specify the `DBInstanceId` parameter to the ID of a sharded cluster instance.', example='d-bp18b06ebc21****'),
  orderType?: string(name='OrderType', description='The order of time in which the log entries to return are sorted. Valid values:

*   asc: The log entries are sorted by time in ascending order.
*   desc: The log entries are sorted by time in descending order.', example='asc'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. The value of this parameter must be an integer that is greater than 0. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: **30** to **100**.', example='30'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmyiu4ekp****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.', example='2021-08-15T14:13Z'),
}

model DescribeSlowLogRecordsResponseBody = {
  engine?: string(name='Engine', description='The database engine.', example='MongoDB'),
  items?: {
    logRecords?: [ 
    {
      accountName?: string(name='AccountName', description='The username of the database account that performs the operation.', example='test'),
      DBName?: string(name='DBName', description='The name of the database.', example='mongodbtest'),
      docsExamined?: long(name='DocsExamined', description='The number of documents that are scanned during the operation.', example='1000000'),
      executionStartTime?: string(name='ExecutionStartTime', description='The start time of the operation. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2019-02-25T 01:41:28Z'),
      hostAddress?: string(name='HostAddress', description='The host IP address that is used to connect to the database.', example='192.168.XX.XX'),
      keysExamined?: long(name='KeysExamined', description='The number of rows involved in index scans.', example='0'),
      queryTimes?: string(name='QueryTimes', description='The execution time of the statement. Unit: milliseconds.', example='600'),
      returnRowCounts?: long(name='ReturnRowCounts', description='The number of rows returned by the SQL statement.', example='0'),
      SQLText?: string(name='SQLText', description='The SQL statement that is executed during the slow operation.', example='{\\"op\\":\\"query\\",\\"ns\\":\\"mongodbtest.customer\\",\\"query\\":{\\"find\\":\\"customer\\",\\"filter\\":{\\"name\\":\\"jack\\"}}}'),
      tableName?: string(name='TableName', description='The name of the collection.', example='C1'),
    }
  ](name='LogRecords')
  }(name='Items', description='Details of the slow query logs.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page. The value must be an integer that is greater than 0. Default value: **1**.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of slow query log entries returned on the page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='8076C4BA-DDBD-529C-BFF4-D8620C3F****'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of returned entries.', example='1'),
}

model DescribeSlowLogRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSlowLogRecordsResponseBody(name='body'),
}

/**
  * *   This operation is applicable only to **general-purpose local-disk** and **dedicated local-disk** instances.
  * *   You can call this operation up to 30 times per minute. To call this operation at a higher frequency, use a Logstore. For more information, see [Manage a Logstore](~~48990~~).
  *
  * @param request DescribeSlowLogRecordsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeSlowLogRecordsResponse
 */
async function describeSlowLogRecordsWithOptions(request: DescribeSlowLogRecordsRequest, runtime: Util.RuntimeOptions): DescribeSlowLogRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSlowLogRecords',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   This operation is applicable only to **general-purpose local-disk** and **dedicated local-disk** instances.
  * *   You can call this operation up to 30 times per minute. To call this operation at a higher frequency, use a Logstore. For more information, see [Manage a Logstore](~~48990~~).
  *
  * @param request DescribeSlowLogRecordsRequest
  * @return DescribeSlowLogRecordsResponse
 */
async function describeSlowLogRecords(request: DescribeSlowLogRecordsRequest): DescribeSlowLogRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSlowLogRecordsWithOptions(request, runtime);
}

model DescribeTagsRequest {
  nextToken?: string(name='NextToken', description='The token used to start the next query to retrieve more results.

>  This parameter is not required in the first query. If not all results are returned in one query, you can pass in the NextToken value returned in the previous query to perform the query again.', example='212db86****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the instance. You can call the [DescribeRegions](~~61933~~) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='dds-bp17e7a04960****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType', description='The resource type. Set the value to **INSTANCE**.', example='INSTANCE'),
}

model DescribeTagsResponseBody = {
  nextToken?: string(name='NextToken', description='The token used to start the next query.

>  If not all results are returned in the first query, this parameter is returned. You can pass in the value of this parameter in the next query.', example='212db86****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='EEDBE38F-5CF5-4316-AAC2-35817BA60D68'),
  tags?: [ 
    {
      tagKey?: string(name='TagKey', description='The key of the tag.', example='newKey'),
      tagValues?: [ string ](name='TagValues', description='The values of the tags.'),
    }
  ](name='Tags', description='Details about the tags.'),
}

model DescribeTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTagsResponseBody(name='body'),
}

async function describeTagsWithOptions(request: DescribeTagsRequest, runtime: Util.RuntimeOptions): DescribeTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTags',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTags(request: DescribeTagsRequest): DescribeTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTagsWithOptions(request, runtime);
}

model DescribeUserEncryptionKeyListRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bpxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  targetRegionId?: string(name='TargetRegionId', description='The zone ID of the instance. You can call the [DescribeRegions](~~61933~~) operation to query the most recent zone list.', example='cn-shanghai'),
}

model DescribeUserEncryptionKeyListResponseBody = {
  keyIds?: {
    keyId?: [ string ](name='KeyId')
  }(name='KeyIds', description='The list of custom keys.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='7CD51DA4-A499-43CE-B9B5-20CD4FDC648E'),
}

model DescribeUserEncryptionKeyListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUserEncryptionKeyListResponseBody(name='body'),
}

/**
  * You can use the custom key obtained by calling the DescribeUserEncryptionKeyList operation to enable TDE. For more information, see [ModifyDBInstanceTDE](~~131267~~).
  *
  * @param request DescribeUserEncryptionKeyListRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeUserEncryptionKeyListResponse
 */
async function describeUserEncryptionKeyListWithOptions(request: DescribeUserEncryptionKeyListRequest, runtime: Util.RuntimeOptions): DescribeUserEncryptionKeyListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.targetRegionId)) {
    query['TargetRegionId'] = request.targetRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUserEncryptionKeyList',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can use the custom key obtained by calling the DescribeUserEncryptionKeyList operation to enable TDE. For more information, see [ModifyDBInstanceTDE](~~131267~~).
  *
  * @param request DescribeUserEncryptionKeyListRequest
  * @return DescribeUserEncryptionKeyListResponse
 */
async function describeUserEncryptionKeyList(request: DescribeUserEncryptionKeyListRequest): DescribeUserEncryptionKeyListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserEncryptionKeyListWithOptions(request, runtime);
}

model DestroyInstanceRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='ETnLKlblzczshOTUbOCz****'),
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.

> **InstanceId** and **DBInstanceId** serve the same function. You need only to specify one of them.', example='dds-bp147acd4783****'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> **InstanceId** and **DBInstanceId** serve the same function. You need only to specify one of them.', example='dds-bp147acd4783****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of a resource group.', example='rg-acfmyiu4ekp****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DestroyInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='65BDA532-28AF-4122-AA39-B382721E****'),
}

model DestroyInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DestroyInstanceResponseBody(name='body'),
}

/**
  * Before you call this operation, make sure that the instance meets the following requirements:
  * *   The billing method of the instance is subscription.
  * *   The instance has expired and is in the **Locking** state.
  *
  * @param request DestroyInstanceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DestroyInstanceResponse
 */
async function destroyInstanceWithOptions(request: DestroyInstanceRequest, runtime: Util.RuntimeOptions): DestroyInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DestroyInstance',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, make sure that the instance meets the following requirements:
  * *   The billing method of the instance is subscription.
  * *   The instance has expired and is in the **Locking** state.
  *
  * @param request DestroyInstanceRequest
  * @return DestroyInstanceResponse
 */
async function destroyInstance(request: DestroyInstanceRequest): DestroyInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return destroyInstanceWithOptions(request, runtime);
}

model EvaluateResourceRequest {
  DBInstanceClass?: string(name='DBInstanceClass', description='The stype of the instance.

> This parameter is required when you check whether resources are sufficient for creating or upgrading a replica set instance. For more information about instance types, see [Instance types](~~57141~~).', example='dds.mongo.mid'),
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance. This parameter is required when you check whether resources are sufficient for upgrading an instance.', example='dds-bp14bf67a76d****'),
  engine?: string(name='Engine', description='The database engine of the instance. Set the value to **MongoDB**.', example='MongoDB'),
  engineVersion?: string(name='EngineVersion', description='The version of the database engine. Valid values:

*   **5.0**
*   **4.4**
*   **4.2**
*   **4.0**
*   **3.4**', example='4.0'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  readonlyReplicas?: string(name='ReadonlyReplicas', description='The number of read-only nodes in the instance. Valid values: **1** to **5**.

> This parameter is not required for standalone or serverless instances.', example='1'),
  regionId?: string(name='RegionId', description='The region ID of the instance. You can call the [DescribeRegions](~~61933~~) operation to query the region ID.', example='cn-hangzhou'),
  replicationFactor?: string(name='ReplicationFactor', description='The number of nodes in the instance.

*   Set the value to **1** for standalone instances.
*   Valid values for replica set instances: **3**, **5**, and **7**

> This parameter is not required for serverless instances.', example='3'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  shardsInfo?: string(name='ShardsInfo', description='The node information about the sharded cluster instance. This parameter is required when you check whether resources are sufficient for creating or upgrading a sharded cluster instance.

To check whether resources are sufficient for creating a sharded cluster instance, specify the specifications of each node in the instance. The value must be a JSON string. Example:

    {
         "ConfigSvrs":
             [{"Storage":20,"DBInstanceClass":"dds.cs.mid"}],
         "Mongos":
             [{"DBInstanceClass":"dds.mongos.standard"},{"DBInstanceClass":"dds.mongos.standard"}],
         "Shards":
             [{"Storage":50,"DBInstanceClass":"dds.shard.standard"},{"Storage":50,"DBInstanceClass":"dds.shard.standard"},   {"Storage":50,"DBInstanceClass":"dds.shard.standard"}]
     }

Parameters in the example:

*   ConfigSvrs: the Configserver node.
*   Mongos: the mongos node.
*   Shards: the shard node.
*   Storage: the storage space of the node.
*   DBInstanceClass: the instance type of the node. For more information, see [Sharded cluster instance types](~~311414~~).

To check whether resources are sufficient for upgrading a single node of a sharded cluster instance, specify only the information about the node to be upgraded. The value must be a JSON string. Example:

    {
         "NodeId": "d-bp147c4d9ca7****", "NodeClass": "dds.shard.standard"
    } 

Parameters in the example:

*   NodeId: the ID of the node.
*   NodeClass: the instance type of the node. For more information, see [Sharded cluster instance types](~~311414~~).', example='{"NodeId": "d-bp147c4d9ca7****", "NodeClass": "dds.shard.standard"}'),
  storage?: string(name='Storage', description='副本集的存储空间，单位为GB。
> 实例规格为云盘型时，该参数必填。</props>', example='10'),
  zoneId?: string(name='ZoneId', description='The zone ID of the instance. You can call the [DescribeRegions](~~61933~~) operation to query the zone ID.', example='cn-hangzhou-h'),
}

model EvaluateResourceResponseBody = {
  DBInstanceAvailable?: string(name='DBInstanceAvailable', description='Indicates whether the resources are sufficient in the region. Valid values:

*   **1**: The resources are sufficient.
*   **0**: The resources are insufficient.', example='1'),
  engine?: string(name='Engine', description='The database engine of the instance. Only MongoDB is returned.', example='MongoDB'),
  engineVersion?: string(name='EngineVersion', description='The version of the database engine.', example='4.0'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='AE2DE465-E45F-481F-ABD8-37D64173****'),
}

model EvaluateResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EvaluateResourceResponseBody(name='body'),
}

/**
  * This operation is applicable to replica set instances and sharded cluster instances. You can call this operation to check whether resources are sufficient for creating an instance, upgrading a replica set or sharded cluster instance, or upgrading a single node of the sharded cluster instance.
  * > You can call this operation a maximum of 200 times per minute.
  *
  * @param request EvaluateResourceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return EvaluateResourceResponse
 */
async function evaluateResourceWithOptions(request: EvaluateResourceRequest, runtime: Util.RuntimeOptions): EvaluateResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceClass)) {
    query['DBInstanceClass'] = request.DBInstanceClass;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.readonlyReplicas)) {
    query['ReadonlyReplicas'] = request.readonlyReplicas;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.replicationFactor)) {
    query['ReplicationFactor'] = request.replicationFactor;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.shardsInfo)) {
    query['ShardsInfo'] = request.shardsInfo;
  }
  if (!Util.isUnset(request.storage)) {
    query['Storage'] = request.storage;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EvaluateResource',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * This operation is applicable to replica set instances and sharded cluster instances. You can call this operation to check whether resources are sufficient for creating an instance, upgrading a replica set or sharded cluster instance, or upgrading a single node of the sharded cluster instance.
  * > You can call this operation a maximum of 200 times per minute.
  *
  * @param request EvaluateResourceRequest
  * @return EvaluateResourceResponse
 */
async function evaluateResource(request: EvaluateResourceRequest): EvaluateResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return evaluateResourceWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', description='The token used to start the next query to retrieve more results.

>  This parameter is not required in the first query. If not all results are returned in one query, you can pass in the **NextToken** value returned in the previous query to perform the query again.', example='212db86****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the instance. You can call the [DescribeDBInstanceAttribute](~~62010~~) operation to query the region ID of the instance.', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId', description='The resource IDs. You must specify this parameter or the Tag parameter.', example='dds-bpxxxxxxxx'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType', description='The resource type. Set the value to **INSTANCE**.', example='INSTANCE'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of tag.', example='env'),
      value?: string(name='Value', description='The value of tag.', example='dev'),
    }
  ](name='Tag', description='The tags that are attached to the resources.'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', description='The token used to start the next query.

>  If not all results are returned in the first query, this parameter is returned. You can pass in the returned value of this parameter in the next query.', example='212db86****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='96017AF2-9AB1-4BC9-88D2-7966B3CD****'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId', description='The ID of the resource. It is the ID of the ApsaraDB for MongoDB instance.', example='dds-bp17e7a04960****'),
      resourceType?: string(name='ResourceType', description='The resource type. The return value is fixed to **ALIYUN: KVSTORE: INSTANCE**, indicating an ApsaraDB for MongoDB instance.', example='ALIYUN::DDS::INSTANCE'),
      tagKey?: string(name='TagKey', description='The key of the tag.', example='Environment'),
      tagValue?: string(name='TagValue', description='The value of the tag.', example='dev'),
    }
  ](name='TagResource')
  }(name='TagResources', description='Details about the tags of the instance.'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model MigrateAvailableZoneRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.

> If the instance is deployed in a VPC, you must specify the **Vswitch** parameter.', example='dds-bp1ece71ff2f****'),
  effectiveTime?: string(name='EffectiveTime', description='The time when the instance is migrated to the destination zone. Valid values:

*   **Immediately**: The instance is immediately migrated to the destination zone.
*   **MaintainTime**: The instance is migrated to the destination zone during the maintenance window of the instance.

Default value: **Immediately**.', example='Immediately'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vswitch?: string(name='Vswitch', description='The ID of the vSwitch in the destination zone.

> If the instance is deployed in a VPC, you must specify this parameter.', example='vsw-bp1buy0h9myt5i9e7****'),
  zoneId?: string(name='ZoneId', description='The ID of the destination zone.

> 

*   The source zone and the destination zone belong to the same region.

*   You can call the [DescribeRegions](~~61933~~) operation to query the zone ID.', example='cn-hangzhou-b'),
}

model MigrateAvailableZoneResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0FDDC511-7252-4A4A-ADDA-5CB1BF63****'),
}

model MigrateAvailableZoneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MigrateAvailableZoneResponseBody(name='body'),
}

/**
  * *   This operation is available only for replica set instances that run MongoDB 4.2 or earlier and sharded cluster instances.
  * *   If you have applied for a public endpoint for the ApsaraDB for MongoDB instance, you must call the [ReleasePublicNetworkAddress](~~67604~~) operation to release the public endpoint before you call the MigrateAvailableZone operation.
  * *   Transparent data encryption (TDE) is disabled for the ApsaraDB for MongoDB instance.
  * *   The source zone and the destination zone belong to the same region.
  * *   A vSwitch is created in the destination zone. This prerequisite must be met if the instance resides in a virtual private cloud (VPC). For more information about how to create a vSwitch, see [Work with vSwitches](~~65387~~).
  *
  * @param request MigrateAvailableZoneRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return MigrateAvailableZoneResponse
 */
async function migrateAvailableZoneWithOptions(request: MigrateAvailableZoneRequest, runtime: Util.RuntimeOptions): MigrateAvailableZoneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.effectiveTime)) {
    query['EffectiveTime'] = request.effectiveTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vswitch)) {
    query['Vswitch'] = request.vswitch;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MigrateAvailableZone',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   This operation is available only for replica set instances that run MongoDB 4.2 or earlier and sharded cluster instances.
  * *   If you have applied for a public endpoint for the ApsaraDB for MongoDB instance, you must call the [ReleasePublicNetworkAddress](~~67604~~) operation to release the public endpoint before you call the MigrateAvailableZone operation.
  * *   Transparent data encryption (TDE) is disabled for the ApsaraDB for MongoDB instance.
  * *   The source zone and the destination zone belong to the same region.
  * *   A vSwitch is created in the destination zone. This prerequisite must be met if the instance resides in a virtual private cloud (VPC). For more information about how to create a vSwitch, see [Work with vSwitches](~~65387~~).
  *
  * @param request MigrateAvailableZoneRequest
  * @return MigrateAvailableZoneResponse
 */
async function migrateAvailableZone(request: MigrateAvailableZoneRequest): MigrateAvailableZoneResponse {
  var runtime = new Util.RuntimeOptions{};
  return migrateAvailableZoneWithOptions(request, runtime);
}

model MigrateToOtherZoneRequest {
  effectiveTime?: string(name='EffectiveTime', description='The time when the instance is migrated to the destination zone. Valid values:

*   **Immediately**: The instance is immediately migrated to the destination zone.
*   **MaintainTime**: The instance is migrated during the maintenance period of the instance.

Default value: **Immediately**.', example='Immediately'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

>  If the network type of the instance is VPC, you must specify the **Vswitch** parameter .', example='dds-bp2658****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch in the destination zone.

>  This parameter is valid and required only when the network type of the instance is VPC.', example='vsw-bp67ac****'),
  zoneId?: string(name='ZoneId', description='The ID of the destination zone to which you want to migrate the ApsaraDB for MongoDB instance.

> * The destination and source zones must be in one region.
> * You can call [DescribeRegions](~~61933~~) to query the zone IDs.', example='cn-hangzhou-b'),
}

model MigrateToOtherZoneResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0FDDC511-7252-4A4A-ADDA-5CB1BF63873D'),
}

model MigrateToOtherZoneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MigrateToOtherZoneResponseBody(name='body'),
}

/**
  * This operation is applicable only to replica set instances, but not to standalone instances or sharded cluster instances.
  * >  If you have applied for a public endpoint of the instance, you must first call the [ReleasePublicNetworkAddress](~~67604~~) operation to release the public endpoint.
  *
  * @param request MigrateToOtherZoneRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return MigrateToOtherZoneResponse
 */
async function migrateToOtherZoneWithOptions(request: MigrateToOtherZoneRequest, runtime: Util.RuntimeOptions): MigrateToOtherZoneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.effectiveTime)) {
    query['EffectiveTime'] = request.effectiveTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MigrateToOtherZone',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * This operation is applicable only to replica set instances, but not to standalone instances or sharded cluster instances.
  * >  If you have applied for a public endpoint of the instance, you must first call the [ReleasePublicNetworkAddress](~~67604~~) operation to release the public endpoint.
  *
  * @param request MigrateToOtherZoneRequest
  * @return MigrateToOtherZoneResponse
 */
async function migrateToOtherZone(request: MigrateToOtherZoneRequest): MigrateToOtherZoneResponse {
  var runtime = new Util.RuntimeOptions{};
  return migrateToOtherZoneWithOptions(request, runtime);
}

model ModifyAccountDescriptionRequest {
  accountDescription?: string(name='AccountDescription', description='The description of the account.

*   It cannot start with http:// or https://.
*   It must start with a letter.
*   It must be 2 to 256 characters in length, and can contain letters, digits, underscores (\\_), and hyphens (-).', example='superadmin'),
  accountName?: string(name='AccountName', description='The name of the account for which you want to modify the description.', example='root'),
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bp2356****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyAccountDescriptionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='59DE9FC2-7B40-45CF-9011-7327A8A771A2'),
}

model ModifyAccountDescriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyAccountDescriptionResponseBody(name='body'),
}

async function modifyAccountDescriptionWithOptions(request: ModifyAccountDescriptionRequest, runtime: Util.RuntimeOptions): ModifyAccountDescriptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountDescription)) {
    query['AccountDescription'] = request.accountDescription;
  }
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAccountDescription',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyAccountDescription(request: ModifyAccountDescriptionRequest): ModifyAccountDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAccountDescriptionWithOptions(request, runtime);
}

model ModifyAuditLogFilterRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bp12c5b040dc****'),
  filter?: string(name='Filter', description='The type of the audit log entries to be collected. Valid values:

*   **admin**: O\\&M and management operations
*   **slow**: slow query logs
*   **query**: query operations
*   **insert**: insert operations
*   **update**: update operations
*   **delete**: delete operations
*   **command**: protocol commands such as the aggregate method', example='insert,query,update,delete'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  roleType?: string(name='RoleType', description='The role of the node in the instance. Valid values:

*   **primary**
*   **secondary**', example='primary'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyAuditLogFilterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='E209BE2B-F264-4B9D-81F6-A5A5FB1FBF28'),
}

model ModifyAuditLogFilterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyAuditLogFilterResponseBody(name='body'),
}

/**
  * *   The instance must be in the running state when you call this operation.
  * *   This operation is applicable only to **general-purpose local-disk** and **dedicated local-disk** instances.
  * *   You can call this operation up to 30 times per minute. To call this operation at a higher frequency, use a Logstore. For more information, see [Manage a Logstore](~~48990~~).
  *
  * @param request ModifyAuditLogFilterRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyAuditLogFilterResponse
 */
async function modifyAuditLogFilterWithOptions(request: ModifyAuditLogFilterRequest, runtime: Util.RuntimeOptions): ModifyAuditLogFilterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.roleType)) {
    query['RoleType'] = request.roleType;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAuditLogFilter',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   The instance must be in the running state when you call this operation.
  * *   This operation is applicable only to **general-purpose local-disk** and **dedicated local-disk** instances.
  * *   You can call this operation up to 30 times per minute. To call this operation at a higher frequency, use a Logstore. For more information, see [Manage a Logstore](~~48990~~).
  *
  * @param request ModifyAuditLogFilterRequest
  * @return ModifyAuditLogFilterResponse
 */
async function modifyAuditLogFilter(request: ModifyAuditLogFilterRequest): ModifyAuditLogFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAuditLogFilterWithOptions(request, runtime);
}

model ModifyAuditPolicyRequest {
  auditLogSwitchSource?: string(name='AuditLogSwitchSource', description='The request source for the audit log feature. Set the value to **Console**.', example='Console'),
  auditStatus?: string(name='AuditStatus', description='Specifies whether the audit log feature is enabled. Valid values:

*   **enable**
*   **disabled**', example='enable'),
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bp1785659e3f****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  serviceType?: string(name='ServiceType', description='The type of the audit log feature. Valid values:

*   **Trail**: the free trial edition
*   **Standard**: the official edition

>  Default value: **Trial**. Starting from January 6, 2022, the official edition of the audit log feature has been launched in all regions, and new applications for the free trial edition have ended. We recommend that you set this parameter to **Standard**.', example='Standard'),
  storagePeriod?: int32(name='StoragePeriod', description='The log retention period. Valid values: 1 to 365 days. Default value: 30 days.', example='30'),
}

model ModifyAuditPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='DC04D812-F18D-4568-9B88-F260D9590116'),
}

model ModifyAuditPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyAuditPolicyResponseBody(name='body'),
}

/**
  * *   This operation is applicable only to **general-purpose local-disk** and **dedicated local-disk** instances.
  * *   You can call this operation up to 30 times per minute. To call this operation at a higher frequency, use a Logstore. For more information, see [Manage a Logstore](~~48990~~).
  *
  * @param request ModifyAuditPolicyRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyAuditPolicyResponse
 */
async function modifyAuditPolicyWithOptions(request: ModifyAuditPolicyRequest, runtime: Util.RuntimeOptions): ModifyAuditPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.auditLogSwitchSource)) {
    query['AuditLogSwitchSource'] = request.auditLogSwitchSource;
  }
  if (!Util.isUnset(request.auditStatus)) {
    query['AuditStatus'] = request.auditStatus;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.serviceType)) {
    query['ServiceType'] = request.serviceType;
  }
  if (!Util.isUnset(request.storagePeriod)) {
    query['StoragePeriod'] = request.storagePeriod;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAuditPolicy',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   This operation is applicable only to **general-purpose local-disk** and **dedicated local-disk** instances.
  * *   You can call this operation up to 30 times per minute. To call this operation at a higher frequency, use a Logstore. For more information, see [Manage a Logstore](~~48990~~).
  *
  * @param request ModifyAuditPolicyRequest
  * @return ModifyAuditPolicyResponse
 */
async function modifyAuditPolicy(request: ModifyAuditPolicyRequest): ModifyAuditPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAuditPolicyWithOptions(request, runtime);
}

model ModifyBackupPolicyRequest {
  backupInterval?: string(name='BackupInterval', description='The frequency at which high-frequency backups are created. Valid values:

*   **-1**: disables high-frequency backup.
*   **15**: every 15 minutes.
*   **30**: every 30 minutes.
*   **60**: every hour.
*   **120**: every 2 hours.
*   **180**: every 3 hours.
*   **240**: every 4 hours.
*   **360**: every 6 hours.
*   **480**: every 8 hours.
*   **720**: every 12 hours.

> * If **SnapshotBackupType** is set to **Standard**, this parameter is set to **-1** and cannot be changed.
> * High-frequency backup takes effect only when **SnapshotBackupType** is set to **Flash** and the value of this parameter is greater than 0.', example='-1'),
  backupRetentionPeriod?: long(name='BackupRetentionPeriod', description='The retention period of full backups.

> * If your instance is created before September 10, 2021, backups are retained for seven days by default.
> * If your instance is created after September 10, 2021, backups are retained for 30 days by default.', example='30'),
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bp16cb162771****'),
  enableBackupLog?: long(name='EnableBackupLog', description='Specifies whether to enable log backup. Default value: 0. Valid values:

*   **0**: disables log backup.
*   **1**: enables log backup.', example='0'),
  logBackupRetentionPeriod?: long(name='LogBackupRetentionPeriod', description='The number of days for which log backups are retained. Default value: 7.

Valid values: 7 to 730.', example='7'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod', description='The day of a week on which to back up data. Valid values:

*   **Monday**
*   **Tuesday**
*   **Wednesday**
*   **Thursday**
*   **Friday**
*   **Saturday**
*   **Sunday**

>  Separate multiple values with commas (,).', example='Monday,Wednesday,Friday,Sunday'),
  preferredBackupTime?: string(name='PreferredBackupTime', description='The time range to back up data. Specify the time in the *HH:mm*Z-*HH:mm*Z format. The time must be in UTC.

>  The time range is 1 hour.', example='03:00Z-04:00Z'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  snapshotBackupType?: string(name='SnapshotBackupType', description='The snapshot backup type. Default value: Standard. Valid values:

*   **Flash**: single-digit second backup
*   **Standard**: standard backup', example='Standard'),
}

model ModifyBackupPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='644A359C-B871-4DD3-97B5-ED91EF5809C2'),
}

model ModifyBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyBackupPolicyResponseBody(name='body'),
}

async function modifyBackupPolicyWithOptions(request: ModifyBackupPolicyRequest, runtime: Util.RuntimeOptions): ModifyBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupInterval)) {
    query['BackupInterval'] = request.backupInterval;
  }
  if (!Util.isUnset(request.backupRetentionPeriod)) {
    query['BackupRetentionPeriod'] = request.backupRetentionPeriod;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.enableBackupLog)) {
    query['EnableBackupLog'] = request.enableBackupLog;
  }
  if (!Util.isUnset(request.logBackupRetentionPeriod)) {
    query['LogBackupRetentionPeriod'] = request.logBackupRetentionPeriod;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.preferredBackupPeriod)) {
    query['PreferredBackupPeriod'] = request.preferredBackupPeriod;
  }
  if (!Util.isUnset(request.preferredBackupTime)) {
    query['PreferredBackupTime'] = request.preferredBackupTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.snapshotBackupType)) {
    query['SnapshotBackupType'] = request.snapshotBackupType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyBackupPolicy',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyBackupPolicy(request: ModifyBackupPolicyRequest): ModifyBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBackupPolicyWithOptions(request, runtime);
}

model ModifyDBInstanceConnectionStringRequest {
  currentConnectionString?: string(name='CurrentConnectionString', description='The current connection string, which is to be modified.', example='s-bpxxxxxxxx.mongodb.rds.aliyuncs.com'),
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.

>  If you set this parameter to the ID of a sharded cluster instance, you must also specify the **NodeId** parameter.', example='dds-bpxxxxxxxx'),
  newConnectionString?: string(name='NewConnectionString', description='The new connection string. It must be 8 to 64 characters in length and can contain letters and digits. It must start with a lowercase letter.

>  You need only to specify the prefix of the connection string. The content other than the prefix cannot be modified.', example='aliyuntest111'),
  newPort?: int32(name='NewPort', description='this parameter can be used. The new port should be within the range of 1000 to 65535.
>When the DBInstanceId parameter is passed in as a cloud disk instance ID', example='3310'),
  nodeId?: string(name='NodeId', description='The ID of the mongos in the specified sharded cluster instance. Only one mongos ID can be specified in each call.

>  This parameter is valid only if you set the **DBInstanceId** parameter to the ID of a sharded cluster instance.', example='s-bpxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyDBInstanceConnectionStringResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='FF36A84C-0694-42D0-861D-C383E8E4FAAF'),
}

model ModifyDBInstanceConnectionStringResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceConnectionStringResponseBody(name='body'),
}

async function modifyDBInstanceConnectionStringWithOptions(request: ModifyDBInstanceConnectionStringRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceConnectionStringResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentConnectionString)) {
    query['CurrentConnectionString'] = request.currentConnectionString;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.newConnectionString)) {
    query['NewConnectionString'] = request.newConnectionString;
  }
  if (!Util.isUnset(request.newPort)) {
    query['NewPort'] = request.newPort;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceConnectionString',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBInstanceConnectionString(request: ModifyDBInstanceConnectionStringRequest): ModifyDBInstanceConnectionStringResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceConnectionStringWithOptions(request, runtime);
}

model ModifyDBInstanceDescriptionRequest {
  DBInstanceDescription?: string(name='DBInstanceDescription', description='The name of the instance.

> 

*   The name cannot start with `http://` or `https://`.

*   The name must start with a letter.

*   The name must be 2 to 256 characters in length, and can contain letters, underscores (\\_), hyphens (-), and digits.', example='testdata'),
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance

> To modify the name of a shard or mongos node in a sharded cluster instance, you must also specify the **NodeId** parameter.', example='dds-bp2234****'),
  nodeId?: string(name='NodeId', description='The ID of the shard or mongos node in the sharded cluster instance.

> This parameter is valid only if you set the **DBInstanceId** parameter to the ID of a sharded cluster instance.', example='d-bp89067****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyDBInstanceDescriptionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='06F8F642-4009-4FFC-80C4-9D67DBF7B74E'),
}

model ModifyDBInstanceDescriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceDescriptionResponseBody(name='body'),
}

async function modifyDBInstanceDescriptionWithOptions(request: ModifyDBInstanceDescriptionRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceDescriptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceDescription)) {
    query['DBInstanceDescription'] = request.DBInstanceDescription;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceDescription',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBInstanceDescription(request: ModifyDBInstanceDescriptionRequest): ModifyDBInstanceDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceDescriptionWithOptions(request, runtime);
}

model ModifyDBInstanceMaintainTimeRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bpac2345****'),
  maintainEndTime?: string(name='MaintainEndTime', description='The end time of the maintenance window. Specify the time in the *HH:mmZ* format. The time must be in UTC.

>  The end time must be later than the start time of the maintenance window.', example='02:00Z'),
  maintainStartTime?: string(name='MaintainStartTime', description='The start time of the maintenance window. Specify the time in the *HH:mm*Z format. The time must be in UTC.', example='01:00Z'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyDBInstanceMaintainTimeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='A9310426-C763-42A2-A3AD-70A8DA204531'),
}

model ModifyDBInstanceMaintainTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceMaintainTimeResponseBody(name='body'),
}

async function modifyDBInstanceMaintainTimeWithOptions(request: ModifyDBInstanceMaintainTimeRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceMaintainTimeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.maintainEndTime)) {
    query['MaintainEndTime'] = request.maintainEndTime;
  }
  if (!Util.isUnset(request.maintainStartTime)) {
    query['MaintainStartTime'] = request.maintainStartTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceMaintainTime',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBInstanceMaintainTime(request: ModifyDBInstanceMaintainTimeRequest): ModifyDBInstanceMaintainTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceMaintainTimeWithOptions(request, runtime);
}

model ModifyDBInstanceMonitorRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bpxxxxxxxx'),
  granularity?: string(name='Granularity', description='The collection frequency of monitoring data. Valid values: **1** or **300**. Unit: seconds.', example='1'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyDBInstanceMonitorResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='EFD65226-08CC-4C4D-B6A4-CB3C382F67B0'),
}

model ModifyDBInstanceMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceMonitorResponseBody(name='body'),
}

/**
  * >  This operation is applicable only to the ApsaraDB for MongoDB console of the previous version due to the change in the frequency at which the monitoring data of an ApsaraDB for MongoDB instance is collected.
  * Before you call this operation, make sure that the following requirements are met:
  * *   The instance is a replica set or sharded cluster instance.
  * *   The instance runs MongoDB 3.4 (the latest minor version) or 4.0.
  *
  * @param request ModifyDBInstanceMonitorRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyDBInstanceMonitorResponse
 */
async function modifyDBInstanceMonitorWithOptions(request: ModifyDBInstanceMonitorRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.granularity)) {
    query['Granularity'] = request.granularity;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceMonitor',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  This operation is applicable only to the ApsaraDB for MongoDB console of the previous version due to the change in the frequency at which the monitoring data of an ApsaraDB for MongoDB instance is collected.
  * Before you call this operation, make sure that the following requirements are met:
  * *   The instance is a replica set or sharded cluster instance.
  * *   The instance runs MongoDB 3.4 (the latest minor version) or 4.0.
  *
  * @param request ModifyDBInstanceMonitorRequest
  * @return ModifyDBInstanceMonitorResponse
 */
async function modifyDBInstanceMonitor(request: ModifyDBInstanceMonitorRequest): ModifyDBInstanceMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceMonitorWithOptions(request, runtime);
}

model ModifyDBInstanceNetExpireTimeRequest {
  category?: string(name='Category'),
  classicExpendExpiredDays?: int32(name='ClassicExpendExpiredDays', description='The retention period of the original classic network address. Valid values: **14**, **30**, **60**, and** 120**. Unit: day.', example='30'),
  connectionString?: string(name='ConnectionString', description='The connection string of the instance', example='dds-bpxxxxxxxx.mongodb.rds.aliyuncs.com'),
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bpxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyDBInstanceNetExpireTimeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='459E7D5C-38DA-4E14-9C82-5B5AF693DBAB'),
}

model ModifyDBInstanceNetExpireTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceNetExpireTimeResponseBody(name='body'),
}

/**
  * Before you call this operation, make sure that the following requirements are met:
  * *   The instance is in the running state.
  * *   The network of the instance is in hybrid access mode.
  * >  This operation is applicable only to replica set and sharded cluster instances, but not to standalone instances.
  *
  * @param request ModifyDBInstanceNetExpireTimeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyDBInstanceNetExpireTimeResponse
 */
async function modifyDBInstanceNetExpireTimeWithOptions(request: ModifyDBInstanceNetExpireTimeRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceNetExpireTimeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.classicExpendExpiredDays)) {
    query['ClassicExpendExpiredDays'] = request.classicExpendExpiredDays;
  }
  if (!Util.isUnset(request.connectionString)) {
    query['ConnectionString'] = request.connectionString;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceNetExpireTime',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, make sure that the following requirements are met:
  * *   The instance is in the running state.
  * *   The network of the instance is in hybrid access mode.
  * >  This operation is applicable only to replica set and sharded cluster instances, but not to standalone instances.
  *
  * @param request ModifyDBInstanceNetExpireTimeRequest
  * @return ModifyDBInstanceNetExpireTimeResponse
 */
async function modifyDBInstanceNetExpireTime(request: ModifyDBInstanceNetExpireTimeRequest): ModifyDBInstanceNetExpireTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceNetExpireTimeWithOptions(request, runtime);
}

model ModifyDBInstanceNetworkTypeRequest {
  classicExpiredDays?: int32(name='ClassicExpiredDays', description='The retention period of the original classic network address when you change the network type to VPC. Valid values: **14**, **30**, **60**, and **120**. Unit: days.

>  This parameter is required when the **NetworkType** parameter is set to **VPC** and the **RetainClassic** parameter is set to **True**.', example='30'),
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bp11483712c1****'),
  networkType?: string(name='NetworkType', description='The network type to switch to. Valid values:

*   **VPC**
*   **Classic**', example='VPC'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  retainClassic?: string(name='RetainClassic', description='Specifies whether to retain the original classic network address when you change the network type to VPC. Valid values:

- **True**: retains the original classic network address.
- **False**: does not retain the original classic network address.

> * This parameter is required when the **NetworkType** parameter is set to **VPC**.
> * If you set this parameter to **True**, you must also specify the **ClassicExpiredDays** parameter.', example='False'),
  securityToken?: string(name='SecurityToken'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.

>  This parameter is required when the **NetworkType** parameter is set to **VPC**.', example='vsw-bp1vj604nj5a9zz74****'),
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).

>  This parameter is required when the **NetworkType** parameter is set to **VPC**.', example='vpc-bp1n3i15v90el48nx****'),
  zoneId?: string(name='ZoneId', description='The zone ID of the instance. You can call the [DescribeRegions](~~468365~~) operation to query the most recent zone list.', example='cn-hangzhou-b'),
}

model ModifyDBInstanceNetworkTypeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='D0E605FD-6ECE-5FBE-84A4-99AAB1B8****'),
}

model ModifyDBInstanceNetworkTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceNetworkTypeResponseBody(name='body'),
}

/**
  * This operation is applicable only to replica set instances and sharded cluster instances.
  *
  * @param request ModifyDBInstanceNetworkTypeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyDBInstanceNetworkTypeResponse
 */
async function modifyDBInstanceNetworkTypeWithOptions(request: ModifyDBInstanceNetworkTypeRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceNetworkTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.classicExpiredDays)) {
    query['ClassicExpiredDays'] = request.classicExpiredDays;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.networkType)) {
    query['NetworkType'] = request.networkType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.retainClassic)) {
    query['RetainClassic'] = request.retainClassic;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceNetworkType',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * This operation is applicable only to replica set instances and sharded cluster instances.
  *
  * @param request ModifyDBInstanceNetworkTypeRequest
  * @return ModifyDBInstanceNetworkTypeResponse
 */
async function modifyDBInstanceNetworkType(request: ModifyDBInstanceNetworkTypeRequest): ModifyDBInstanceNetworkTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceNetworkTypeWithOptions(request, runtime);
}

model ModifyDBInstanceSSLRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bp2235****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  SSLAction?: string(name='SSLAction', description='The operation on the SSL feature. Valid values: Valid values:

*   **Open**: enables SSL encryption.
*   **Close**: disables SSL encryption.
*   **Update**: updates the SSL certificate.', example='Open'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyDBInstanceSSLResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6D806B11-078F-4154-BF9F-844F56D08964'),
}

model ModifyDBInstanceSSLResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceSSLResponseBody(name='body'),
}

/**
  * ## Usage
  * Before you call this operation, make sure that the following requirements are met:
  * *   The instance is in the running state.
  * *   The instance is a replica set instance.
  * *   The engine version of the instance is \\<ph props="intl">3.4 or 4.0\\</ph>\\<ph props="china">3.4, 4.0, or 4.2\\</ph>.
  * >  When you enable or disable SSL encryption or update the SSL certificate, the instance restarts. We recommend that you call this operation during off-peak hours.
  *
  * @param request ModifyDBInstanceSSLRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyDBInstanceSSLResponse
 */
async function modifyDBInstanceSSLWithOptions(request: ModifyDBInstanceSSLRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceSSLResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.SSLAction)) {
    query['SSLAction'] = request.SSLAction;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceSSL',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ## Usage
  * Before you call this operation, make sure that the following requirements are met:
  * *   The instance is in the running state.
  * *   The instance is a replica set instance.
  * *   The engine version of the instance is \\<ph props="intl">3.4 or 4.0\\</ph>\\<ph props="china">3.4, 4.0, or 4.2\\</ph>.
  * >  When you enable or disable SSL encryption or update the SSL certificate, the instance restarts. We recommend that you call this operation during off-peak hours.
  *
  * @param request ModifyDBInstanceSSLRequest
  * @return ModifyDBInstanceSSLResponse
 */
async function modifyDBInstanceSSL(request: ModifyDBInstanceSSLRequest): ModifyDBInstanceSSLResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceSSLWithOptions(request, runtime);
}

model ModifyDBInstanceSpecRequest {
  autoPay?: boolean(name='AutoPay', description='Specifies whether to enable automatic payment. Default value: true. Valid values:

*   **true**: enables automatic payment. Make sure that your Alibaba Cloud account has a sufficient balance.
*   **false**: disables automatic payment. You can perform the following operations to pay for the instance: Log on to the ApsaraDB for MongoDB console. In the upper-right corner of the page, choose **Expenses** > **User Center**. In the left-side navigation pane, choose **Order Management** > **Order**. On the **Orders for Services** tab, find the order and pay for the order.', example='true'),
  businessInfo?: string(name='BusinessInfo', description='The business information.', example='{“ActivityId":"000000000"}'),
  couponNo?: string(name='CouponNo', description='The coupon code. Default value: `youhuiquan_promotion_option_id_for_blank`.', example='youhuiquan_promotion_option_id_for_blank'),
  DBInstanceClass?: string(name='DBInstanceClass', description='The instance type. For more information, see [Instance types](~~57141~~). You can also call the [DescribeAvailableResource](~~149719~~) operation to view instance types.

> You must specify at least one of the DBInstanceClass and **DBInstanceStorage** parameters.', example='dds.sn4.xlarge.1'),
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bp1ea17b41ab****'),
  DBInstanceStorage?: string(name='DBInstanceStorage', description='The storage capacity of the instance. Valid values: 10 to 3000. The value must be a multiple of 10. Unit: GB. The values that can be specified for this parameter are subject to the instance types. For more information, see [Instance types](~~57141~~).

> 

*   You must specify at least one of the DBInstanceStorage and **DBInstanceClass** parameters.

*   Storage capacity can be scaled down only for pay-as-you-go replica set instances. The new storage capacity you specify must be greater than the used storage capacity.', example='50'),
  effectiveTime?: string(name='EffectiveTime', description='The time when the changed configurations take effect. Default value: Immediately. Valid values:

*   **Immediately**: The configurations immediately take effect.
*   **MaintainTime**: The configurations take effect during the maintenance window of the instance.', example='Immediately'),
  extraParam?: string(name='ExtraParam', description='Additional parameter', example='async'),
  orderType?: string(name='OrderType', description='The type of the configuration change. Default value: DOWNGRADE. Valid values:

*   **UPGRADE**
*   **DOWNGRADE**

> This parameter can be configured only when the billing method of the instance is subscription.', example='UPGRADE'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  readonlyReplicas?: string(name='ReadonlyReplicas', description='The number of read-only nodes. Valid values: **0** to **5**.

If your instance has only **Classic Network** and **VPC** endpoints, you must apply for a public endpoint or release the classic network endpoint for the instance before you can change the **Read-only Nodes** value.

> You can go to the **Database Connections** page to view the types of networks that are enabled.', example='1'),
  replicationFactor?: string(name='ReplicationFactor', description='The number of nodes in the instance.

*   Valid values of replica set instances: **3**, **5**, and **7**
*   Valid values of standalone instances: **1**

> This parameter is not required for a serverless instance which is only available on the China site (aliyun.com).', example='3'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyDBInstanceSpecResponseBody = {
  orderId?: string(name='OrderId', description='The ID of the order.', example='21012408824****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1E9F1104-19E7-59F0-AB7F-F4EBFDEA****'),
}

model ModifyDBInstanceSpecResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceSpecResponseBody(name='body'),
}

/**
  * Before you call this operation, make sure that you understand the billing methods and [pricing](https://www.alibabacloud.com/zh/product/apsaradb-for-mongodb/pricing) of ApsaraDB for MongoDB.
  * This operation applies only to standalone and replica set instances. To modify the specifications of sharded cluster instances, you can call the [ModifyNodeSpec](~~61911~~), [CreateNode](~~61922~~), [DeleteNode](~~61816~~), or [ModifyNodeSpecBatch](~~61923~~) operation.
  *
  * @param request ModifyDBInstanceSpecRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyDBInstanceSpecResponse
 */
async function modifyDBInstanceSpecWithOptions(request: ModifyDBInstanceSpecRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceSpecResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.businessInfo)) {
    query['BusinessInfo'] = request.businessInfo;
  }
  if (!Util.isUnset(request.couponNo)) {
    query['CouponNo'] = request.couponNo;
  }
  if (!Util.isUnset(request.DBInstanceClass)) {
    query['DBInstanceClass'] = request.DBInstanceClass;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceStorage)) {
    query['DBInstanceStorage'] = request.DBInstanceStorage;
  }
  if (!Util.isUnset(request.effectiveTime)) {
    query['EffectiveTime'] = request.effectiveTime;
  }
  if (!Util.isUnset(request.extraParam)) {
    query['ExtraParam'] = request.extraParam;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.readonlyReplicas)) {
    query['ReadonlyReplicas'] = request.readonlyReplicas;
  }
  if (!Util.isUnset(request.replicationFactor)) {
    query['ReplicationFactor'] = request.replicationFactor;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceSpec',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, make sure that you understand the billing methods and [pricing](https://www.alibabacloud.com/zh/product/apsaradb-for-mongodb/pricing) of ApsaraDB for MongoDB.
  * This operation applies only to standalone and replica set instances. To modify the specifications of sharded cluster instances, you can call the [ModifyNodeSpec](~~61911~~), [CreateNode](~~61922~~), [DeleteNode](~~61816~~), or [ModifyNodeSpecBatch](~~61923~~) operation.
  *
  * @param request ModifyDBInstanceSpecRequest
  * @return ModifyDBInstanceSpecResponse
 */
async function modifyDBInstanceSpec(request: ModifyDBInstanceSpecRequest): ModifyDBInstanceSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceSpecWithOptions(request, runtime);
}

model ModifyDBInstanceTDERequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bpxxxxxxxx'),
  encryptionKey?: string(name='EncryptionKey', description='The ID of the custom key.', example='749c1df7-xxxx-xxxx-xxxx-xxxxxxxxxxxx'),
  encryptorName?: string(name='EncryptorName', description='The encryption method. Set the value to **aes-256-cbc**.

> This parameter is valid only when the **TEDStatus** parameter is set to **enabled**.', example='aes-256-cbc'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  roleARN?: string(name='RoleARN', description='The Alibaba Cloud Resource Name (ARN) of the specified Resource Access Management (RAM) role. The ARN is displayed in the `acs:ram::$accountID:role/$roleName` format.

> 

*   `$accountID`: specifies the ID of the Alibaba Cloud account. To view the account ID, log on to the Alibaba Cloud Management Console, move your pointer over your profile picture in the upper-right corner, and then click Security Settings.

*   `$roleName`: specifies the name of the RAM role. To view the RAM role name, log on to the RAM console. In the left-side navigation pane, choose Identities > Roles. On the Roles page, view the name of the RAM role.', example='acs:ram::123456789012****:role/adminrole'),
  securityToken?: string(name='SecurityToken'),
  TDEStatus?: string(name='TDEStatus', description='The TDE status. When the value of this parameter is set to **Enabled**, TDE is enabled.

> You cannot disable TDE after it is enabled. Proceed with caution.', example='enabled'),
}

model ModifyDBInstanceTDEResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='434D7127-6229-4355-BA50-7A3685A725DF'),
}

model ModifyDBInstanceTDEResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceTDEResponseBody(name='body'),
}

/**
  * TDE allows you to perform real-time I/O encryption and decryption on data files. Data is encrypted before it is written to a disk and is decrypted when it is read from the disk to the memory. For more information, see [Configure TDE](~~131048~~).
  * > You cannot disable TDE after it is enabled.
  * Before you call this API operation, make sure that the ApsaraDB for MongoDB instance meets the following requirements:
  * *   The instance is a replica set or sharded cluster instance.
  * *   The storage engine of the instance is WiredTiger.
  * *   The database engine version of the instance is 4.0 or 4.2. If the database engine version is earlier than 4.0, you can call the [UpgradeDBInstanceEngineVersion](~~67608~~) operation to upgrade the database engine.
  *
  * @param request ModifyDBInstanceTDERequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyDBInstanceTDEResponse
 */
async function modifyDBInstanceTDEWithOptions(request: ModifyDBInstanceTDERequest, runtime: Util.RuntimeOptions): ModifyDBInstanceTDEResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.encryptionKey)) {
    query['EncryptionKey'] = request.encryptionKey;
  }
  if (!Util.isUnset(request.encryptorName)) {
    query['EncryptorName'] = request.encryptorName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.roleARN)) {
    query['RoleARN'] = request.roleARN;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.TDEStatus)) {
    query['TDEStatus'] = request.TDEStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceTDE',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * TDE allows you to perform real-time I/O encryption and decryption on data files. Data is encrypted before it is written to a disk and is decrypted when it is read from the disk to the memory. For more information, see [Configure TDE](~~131048~~).
  * > You cannot disable TDE after it is enabled.
  * Before you call this API operation, make sure that the ApsaraDB for MongoDB instance meets the following requirements:
  * *   The instance is a replica set or sharded cluster instance.
  * *   The storage engine of the instance is WiredTiger.
  * *   The database engine version of the instance is 4.0 or 4.2. If the database engine version is earlier than 4.0, you can call the [UpgradeDBInstanceEngineVersion](~~67608~~) operation to upgrade the database engine.
  *
  * @param request ModifyDBInstanceTDERequest
  * @return ModifyDBInstanceTDEResponse
 */
async function modifyDBInstanceTDE(request: ModifyDBInstanceTDERequest): ModifyDBInstanceTDEResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceTDEWithOptions(request, runtime);
}

model ModifyGlobalSecurityIPGroupRequest {
  GIpList?: string(name='GIpList', example='27.16.214.10,111.60.117.181'),
  globalIgName?: string(name='GlobalIgName', example='dps'),
  globalSecurityGroupId?: string(name='GlobalSecurityGroupId', example='g-fwjk62egbsrp4sftxmmr'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyGlobalSecurityIPGroupResponseBody = {
  requestId?: string(name='RequestId', example='A0181AC4-F186-46ED-87CA-100C70B86729'),
}

model ModifyGlobalSecurityIPGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyGlobalSecurityIPGroupResponseBody(name='body'),
}

async function modifyGlobalSecurityIPGroupWithOptions(request: ModifyGlobalSecurityIPGroupRequest, runtime: Util.RuntimeOptions): ModifyGlobalSecurityIPGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.GIpList)) {
    query['GIpList'] = request.GIpList;
  }
  if (!Util.isUnset(request.globalIgName)) {
    query['GlobalIgName'] = request.globalIgName;
  }
  if (!Util.isUnset(request.globalSecurityGroupId)) {
    query['GlobalSecurityGroupId'] = request.globalSecurityGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyGlobalSecurityIPGroup',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyGlobalSecurityIPGroup(request: ModifyGlobalSecurityIPGroupRequest): ModifyGlobalSecurityIPGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGlobalSecurityIPGroupWithOptions(request, runtime);
}

model ModifyGlobalSecurityIPGroupNameRequest {
  globalIgName?: string(name='GlobalIgName', example='prod_baoxian_k8s'),
  globalSecurityGroupId?: string(name='GlobalSecurityGroupId', example='g-xmtncwkrzqqoe59dzljb'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyGlobalSecurityIPGroupNameResponseBody = {
  globalSecurityIPGroup?: [ 
    {
      GIpList?: string(name='GIpList', example='222.70.197.187'),
      globalIgName?: string(name='GlobalIgName', example='def'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', example='g-qiawi8ec1urcx9swoy37'),
      regionId?: string(name='RegionId', example='cn-shanghai'),
    }
  ](name='GlobalSecurityIPGroup'),
  requestId?: string(name='RequestId', example='F8CA8312-530A-413A-9129-F2BB32A8D404'),
}

model ModifyGlobalSecurityIPGroupNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyGlobalSecurityIPGroupNameResponseBody(name='body'),
}

async function modifyGlobalSecurityIPGroupNameWithOptions(request: ModifyGlobalSecurityIPGroupNameRequest, runtime: Util.RuntimeOptions): ModifyGlobalSecurityIPGroupNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.globalIgName)) {
    query['GlobalIgName'] = request.globalIgName;
  }
  if (!Util.isUnset(request.globalSecurityGroupId)) {
    query['GlobalSecurityGroupId'] = request.globalSecurityGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyGlobalSecurityIPGroupName',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyGlobalSecurityIPGroupName(request: ModifyGlobalSecurityIPGroupNameRequest): ModifyGlobalSecurityIPGroupNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGlobalSecurityIPGroupNameWithOptions(request, runtime);
}

model ModifyGlobalSecurityIPGroupRelationRequest {
  DBClusterId?: string(name='DBClusterId', example='dds-2ze6069764423m0l'),
  globalSecurityGroupId?: string(name='GlobalSecurityGroupId', example='g-u0qdtybfvxhaxrrhk4n7'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyGlobalSecurityIPGroupRelationResponseBody = {
  requestId?: string(name='RequestId', example='52820D2B-B2DD-59F0-BDF2-83EC19C6F1CA'),
}

model ModifyGlobalSecurityIPGroupRelationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyGlobalSecurityIPGroupRelationResponseBody(name='body'),
}

async function modifyGlobalSecurityIPGroupRelationWithOptions(request: ModifyGlobalSecurityIPGroupRelationRequest, runtime: Util.RuntimeOptions): ModifyGlobalSecurityIPGroupRelationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.globalSecurityGroupId)) {
    query['GlobalSecurityGroupId'] = request.globalSecurityGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyGlobalSecurityIPGroupRelation',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyGlobalSecurityIPGroupRelation(request: ModifyGlobalSecurityIPGroupRelationRequest): ModifyGlobalSecurityIPGroupRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGlobalSecurityIPGroupRelationWithOptions(request, runtime);
}

model ModifyInstanceAutoRenewalAttributeRequest {
  autoRenew?: string(name='AutoRenew', description='Specifies whether to enable auto-renewal. Valid values:

*   **true**
*   **false**

>  If this parameter is set to **true**, you must set the **Duration** parameter.', example='true'),
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bp15da1923e3****'),
  duration?: string(name='Duration', description='The auto-renewal period. Valid values: **1** to **12**. Unit: month.

>  This parameter is valid only when **AutoRenew** is set to **true**.', example='1'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the instance. You can call the [DescribeDBInstanceAttribute](~~62010~~) operation to query the region ID of the instance.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyInstanceAutoRenewalAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='EFD65226-08CC-4C4D-B6A4-CB3C382F67B0'),
}

model ModifyInstanceAutoRenewalAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyInstanceAutoRenewalAttributeResponseBody(name='body'),
}

/**
  * Before you call this operation, make sure that you fully understand the billing methods and [pricing](https://www.alibabacloud.com/zh/product/apsaradb-for-mongodb/pricing).
  * This operation is applicable to subscription instances.
  * >  When auto-renewal is enabled, your payment will be collected nine days before the expiration date of ApsaraDB for MongoDB. Ensure that your account has sufficient balance.
  *
  * @param request ModifyInstanceAutoRenewalAttributeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyInstanceAutoRenewalAttributeResponse
 */
async function modifyInstanceAutoRenewalAttributeWithOptions(request: ModifyInstanceAutoRenewalAttributeRequest, runtime: Util.RuntimeOptions): ModifyInstanceAutoRenewalAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstanceAutoRenewalAttribute',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, make sure that you fully understand the billing methods and [pricing](https://www.alibabacloud.com/zh/product/apsaradb-for-mongodb/pricing).
  * This operation is applicable to subscription instances.
  * >  When auto-renewal is enabled, your payment will be collected nine days before the expiration date of ApsaraDB for MongoDB. Ensure that your account has sufficient balance.
  *
  * @param request ModifyInstanceAutoRenewalAttributeRequest
  * @return ModifyInstanceAutoRenewalAttributeResponse
 */
async function modifyInstanceAutoRenewalAttribute(request: ModifyInstanceAutoRenewalAttributeRequest): ModifyInstanceAutoRenewalAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceAutoRenewalAttributeWithOptions(request, runtime);
}

model ModifyInstanceVpcAuthModeRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The operation that you want to perform. Set the value to **ModifyInstanceVpcAuthMode**.', example='dds-bpxxxxxxxx'),
  nodeId?: string(name='NodeId', description='The ID of the instance.', example='s-bpxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  vpcAuthMode?: string(name='VpcAuthMode', description='The ID of the mongos node in the specified sharded cluster instance.

>  This parameter can be used only when the instance type is sharded cluster.', example='Open'),
}

model ModifyInstanceVpcAuthModeResponseBody = {
  requestId?: string(name='RequestId', description='Specifies whether to enable authentication to allow access within a VPC. Valid values:

*   **Open**: enables password-free access.
*   **Close**: disables password-free access.', example='BA51E9D9-B14A-4542-B6E6-7DE00BECCB8C'),
}

model ModifyInstanceVpcAuthModeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyInstanceVpcAuthModeResponseBody(name='body'),
}

/**
  * You can call this operation to enable or disable password-free access from the same VPC as an ApsaraDB for MongoDB instance.
  *
  * @param request ModifyInstanceVpcAuthModeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyInstanceVpcAuthModeResponse
 */
async function modifyInstanceVpcAuthModeWithOptions(request: ModifyInstanceVpcAuthModeRequest, runtime: Util.RuntimeOptions): ModifyInstanceVpcAuthModeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.vpcAuthMode)) {
    query['VpcAuthMode'] = request.vpcAuthMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstanceVpcAuthMode',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this operation to enable or disable password-free access from the same VPC as an ApsaraDB for MongoDB instance.
  *
  * @param request ModifyInstanceVpcAuthModeRequest
  * @return ModifyInstanceVpcAuthModeResponse
 */
async function modifyInstanceVpcAuthMode(request: ModifyInstanceVpcAuthModeRequest): ModifyInstanceVpcAuthModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceVpcAuthModeWithOptions(request, runtime);
}

model ModifyNodeSpecRequest {
  autoPay?: boolean(name='AutoPay', description='Specifies whether to enable automatic payment. Default value: true. Valid values:

*   **true**: enables automatic payment. Make sure that you have sufficient balance within your account.
*   **false**: disables automatic payment.', example='true'),
  businessInfo?: string(name='BusinessInfo', description='The business information. This is an additional parameter.', example='{“ActivityId":"000000000"}'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='ETnLKlblzczshOTUbOCz****'),
  couponNo?: string(name='CouponNo', description='The coupon code. Default value: `youhuiquan_promotion_option_id_for_blank`.', example='youhuiquan_promotion_option_id_for_blank'),
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bp1c0b990184****'),
  effectiveTime?: string(name='EffectiveTime', description='The time when the changed configurations take effect. Default value: Immediately. Valid values:

*   **Immediately**: The new configurations immediately take effect.
*   **MaintainTime**: The new configurations take effect during the maintenance window of the instance.', example='Immediately'),
  fromApp?: string(name='FromApp', description='The source of the request. Valid values:

*   **OpenApi**: the ApsaraDB for MongoDB API
*   **mongo_buy**: the ApsaraDB for MongoDB console', example='OpenApi'),
  nodeClass?: string(name='NodeClass', description='The specifications of the shard or mongos node. For more information, see [Instance types](~~57141~~).', example='dds.mongos.standard'),
  nodeId?: string(name='NodeId', description='The ID of the shard or mongos node in the sharded cluster instance. You can call the [DescribeDBInstanceAttribute](~~62010~~) operation to query the node ID.

> If you set this parameter to the ID of the shard node, you must also specify the **NodeStorage** parameter.', example='s-bp143e1b1637****'),
  nodeStorage?: int32(name='NodeStorage', description='The storage capacity of the shard node. Unit: GB.

*   Valid values are **10** to **2000** if the instance uses local SSDs.
*   Valid values are **20** to **16000** if the instance uses enhanced SSDs (ESSDs) at PL1.

> The value must be a multiple of 10.', example='20'),
  orderType?: string(name='OrderType', description='The order type. Valid values:

*   **UPGRADE**
*   **DOWNGRADE**', example='UPGRADE'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  readonlyReplicas?: int32(name='ReadonlyReplicas', description='The number of read-only nodes in the shard node.

Valid values: **0** to **5**. The value must be an integer. Default value: **0**.', example='5'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  switchTime?: string(name='SwitchTime', description='The execution time. Specify the time in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2022-01-05T03:18:53Z'),
}

model ModifyNodeSpecResponseBody = {
  orderId?: string(name='OrderId', description='The ID of the order.', example='21084641369****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='61B05CCF-EBAB-4BF3-BA67-D77256A721E2'),
}

model ModifyNodeSpecResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyNodeSpecResponseBody(name='body'),
}

/**
  * Before you call this operation, make sure that you understand the billing methods and [pricing](https://www.alibabacloud.com/zh/product/apsaradb-for-mongodb/pricing) of ApsaraDB for MongoDB.
  * > This operation is applicable only to sharded cluster instances.
  *
  * @param request ModifyNodeSpecRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyNodeSpecResponse
 */
async function modifyNodeSpecWithOptions(request: ModifyNodeSpecRequest, runtime: Util.RuntimeOptions): ModifyNodeSpecResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.businessInfo)) {
    query['BusinessInfo'] = request.businessInfo;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.couponNo)) {
    query['CouponNo'] = request.couponNo;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.effectiveTime)) {
    query['EffectiveTime'] = request.effectiveTime;
  }
  if (!Util.isUnset(request.fromApp)) {
    query['FromApp'] = request.fromApp;
  }
  if (!Util.isUnset(request.nodeClass)) {
    query['NodeClass'] = request.nodeClass;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.nodeStorage)) {
    query['NodeStorage'] = request.nodeStorage;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.readonlyReplicas)) {
    query['ReadonlyReplicas'] = request.readonlyReplicas;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.switchTime)) {
    query['SwitchTime'] = request.switchTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyNodeSpec',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, make sure that you understand the billing methods and [pricing](https://www.alibabacloud.com/zh/product/apsaradb-for-mongodb/pricing) of ApsaraDB for MongoDB.
  * > This operation is applicable only to sharded cluster instances.
  *
  * @param request ModifyNodeSpecRequest
  * @return ModifyNodeSpecResponse
 */
async function modifyNodeSpec(request: ModifyNodeSpecRequest): ModifyNodeSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNodeSpecWithOptions(request, runtime);
}

model ModifyNodeSpecBatchRequest {
  autoPay?: boolean(name='AutoPay', description='Specifies whether to enable automatic payment for the instance. Valid values:

*   **true**: enables automatic payment. Make sure that you have sufficient balance within your account.
*   **false**: disables automatic payment. You can perform the following operations to pay for the instance: Log on to the ApsaraDB for MongoDB console. In the upper-right corner of the page, choose **Expenses** > User Center to go to the **Billing Management** console. In the left-side navigation pane, click **Orders**. On the **Orders** page, find the order and complete the payment.

Default value: **true**.', example='true'),
  businessInfo?: string(name='BusinessInfo', description='The business information.', example='{“ActivityId":"000000000"}'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='ETnLKlblzczshOTUbOCz****'),
  couponNo?: string(name='CouponNo', description='The coupon code. Default value: `youhuiquan_promotion_option_id_for_blank`.', example='youhuiquan_promotion_option_id_for_blank'),
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance whose configurations you want to modify.', example='dds-bp1337621e8f****'),
  effectiveTime?: string(name='EffectiveTime', description='The time when the modified configurations take effect. Valid values:

*   **Immediately**: The configurations immediately take effect.
*   **MaintainTime**: The configurations take effect during the maintenance window of the instance.

> 

*   You can call the [ModifyDBInstanceMaintainTime](~~62008~~) operation to modify the maintenance window of an instance.

*   You can call the [DescribeDBInstanceAttribute](~~62010~~) operation to view the maintenance window of an instance.

Default value: **Immediately**.', example='Immediately'),
  nodesInfo?: string(name='NodesInfo', description='The configuration information of the mongos nodes or shard nodes whose configurations you want to modify. For more information, see [Instance types](~~57141~~).', example='{"Shards":[{"DBInstanceClass":"dds.shard.mid","DBInstanceName":"d-bp14ae4572fd****","Storage":20},{"DBInstanceClass":"dds.shard.mid","DBInstanceName":"d-bp19f4f92dc5****","Storage":30}]}'),
  orderType?: string(name='OrderType', description='The type of configuration modifications. Valid values:

*   **UPGRADE**
*   **DOWNGRADE**

> This parameter is available only if the billing method of the instance is subscription.', example='UPGRADE'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call the [DescribeRegions](~~61933~~) operation to query the latest available regions.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyNodeSpecBatchResponseBody = {
  orderId?: string(name='OrderId', description='The ID of the order.', example='21012719476****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0637BC25-6895-5500-871F-1127CA34****'),
}

model ModifyNodeSpecBatchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyNodeSpecBatchResponseBody(name='body'),
}

/**
  * Make sure that you fully understand the billing methods and [pricing](https://www.aliyun.com/price/product#/mongodb/detail) of ApsaraDB for MongoDB before you call this operation.
  * This operation is applicable to only sharded cluster instances.
  *
  * @param request ModifyNodeSpecBatchRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyNodeSpecBatchResponse
 */
async function modifyNodeSpecBatchWithOptions(request: ModifyNodeSpecBatchRequest, runtime: Util.RuntimeOptions): ModifyNodeSpecBatchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.businessInfo)) {
    query['BusinessInfo'] = request.businessInfo;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.couponNo)) {
    query['CouponNo'] = request.couponNo;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.effectiveTime)) {
    query['EffectiveTime'] = request.effectiveTime;
  }
  if (!Util.isUnset(request.nodesInfo)) {
    query['NodesInfo'] = request.nodesInfo;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyNodeSpecBatch',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Make sure that you fully understand the billing methods and [pricing](https://www.aliyun.com/price/product#/mongodb/detail) of ApsaraDB for MongoDB before you call this operation.
  * This operation is applicable to only sharded cluster instances.
  *
  * @param request ModifyNodeSpecBatchRequest
  * @return ModifyNodeSpecBatchResponse
 */
async function modifyNodeSpecBatch(request: ModifyNodeSpecBatchRequest): ModifyNodeSpecBatchResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNodeSpecBatchWithOptions(request, runtime);
}

model ModifyParametersRequest {
  characterType?: string(name='CharacterType', description='The role of the instance. Valid values:

*   **db**: a shard node
*   **cs**: a Configserver node
*   **mongos**: a mongos node
*   **logic**: a sharded cluster instance', example='db'),
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.

>  If you set this parameter to the ID of a sharded cluster instance, you must also specify the NodeId parameter.', example='dds-bp19f409d75****'),
  nodeId?: string(name='NodeId', description='The ID of the mongos or shard node in the specified sharded cluster instance.

>  This parameter is valid only when DBInstanceId is set to the ID of a sharded cluster instance.', example='d-bp1b7bb3bbe****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  parameters?: string(name='Parameters', description='The instance parameters that you want to modify and their values. Specify this parameter in a JSON string. Sample format: {"ParameterName1":"ParameterValue1","ParameterName2":"ParameterValue2"}.

>  You can call the [DescribeParameterTemplates](~~67618~~) operation to query a list of default parameter templates.', example='{"operationProfiling.mode":"all","operationProfiling.slowOpThresholdMs":"200"}'),
  regionId?: string(name='RegionId', description='The region ID of the instance. You can call the [DescribeRegions](~~61933~~) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyParametersResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='36923CC2-DDAB-4B48-A144-DA92C1E19537'),
}

model ModifyParametersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyParametersResponseBody(name='body'),
}

/**
  * ## Precautions
  * *   The instance must be in the Running state when you call this operation.
  * *   If you call this operation to modify specific instance parameters and the modification for part of the parameters can take effect only after an instance restart, the instance is automatically restarted after this operation is called. You can call the [DescribeParameterTemplates](~~67618~~) operation to query the parameters that take effect only after the instance is restarted.
  *
  * @param request ModifyParametersRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyParametersResponse
 */
async function modifyParametersWithOptions(request: ModifyParametersRequest, runtime: Util.RuntimeOptions): ModifyParametersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.characterType)) {
    query['CharacterType'] = request.characterType;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameters)) {
    query['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyParameters',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ## Precautions
  * *   The instance must be in the Running state when you call this operation.
  * *   If you call this operation to modify specific instance parameters and the modification for part of the parameters can take effect only after an instance restart, the instance is automatically restarted after this operation is called. You can call the [DescribeParameterTemplates](~~67618~~) operation to query the parameters that take effect only after the instance is restarted.
  *
  * @param request ModifyParametersRequest
  * @return ModifyParametersResponse
 */
async function modifyParameters(request: ModifyParametersRequest): ModifyParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyParametersWithOptions(request, runtime);
}

model ModifyResourceGroupRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bp1366caac83****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the instance. You can call the [DescribeRegions](~~61933~~) operation to query the region ID.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group. For more information, see [View basic information of a resource group](~~151181~~).', example='rg-acfmyiu4ekp****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyResourceGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5DD0DEC3-24A1-5268-8E0B-5B264CA1****'),
}

model ModifyResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyResourceGroupResponseBody(name='body'),
}

/**
  * Resource Management allows you to build an organizational structure for resources based on your business requirements. You can use resource directories, folders, accounts, and resource groups to hierarchically organize and manage resources. For more information, see [What is Resource Management?](~~94475~~)
  *
  * @param request ModifyResourceGroupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyResourceGroupResponse
 */
async function modifyResourceGroupWithOptions(request: ModifyResourceGroupRequest, runtime: Util.RuntimeOptions): ModifyResourceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyResourceGroup',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Resource Management allows you to build an organizational structure for resources based on your business requirements. You can use resource directories, folders, accounts, and resource groups to hierarchically organize and manage resources. For more information, see [What is Resource Management?](~~94475~~)
  *
  * @param request ModifyResourceGroupRequest
  * @return ModifyResourceGroupResponse
 */
async function modifyResourceGroup(request: ModifyResourceGroupRequest): ModifyResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyResourceGroupWithOptions(request, runtime);
}

model ModifySecurityGroupConfigurationRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bpxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the ECS security group.

> * You can bind up to 10 ECS security groups to an ApsaraDB for MongoDB instance.
> * You can call the [DescribeSecurityGroup](~~25556~~) operation of ECS to query the security groups in the specified region.', example='sg-bpxxxxxxxx'),
  securityToken?: string(name='SecurityToken'),
}

model ModifySecurityGroupConfigurationResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='E062C482-1A4B-469E-938C-96D28CFAE42E'),
}

model ModifySecurityGroupConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifySecurityGroupConfigurationResponseBody(name='body'),
}

/**
  * >  For a sharded cluster instance, the bound ECS security group takes effect only for mongos nodes.
  *
  * @param request ModifySecurityGroupConfigurationRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifySecurityGroupConfigurationResponse
 */
async function modifySecurityGroupConfigurationWithOptions(request: ModifySecurityGroupConfigurationRequest, runtime: Util.RuntimeOptions): ModifySecurityGroupConfigurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifySecurityGroupConfiguration',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  For a sharded cluster instance, the bound ECS security group takes effect only for mongos nodes.
  *
  * @param request ModifySecurityGroupConfigurationRequest
  * @return ModifySecurityGroupConfigurationResponse
 */
async function modifySecurityGroupConfiguration(request: ModifySecurityGroupConfigurationRequest): ModifySecurityGroupConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySecurityGroupConfigurationWithOptions(request, runtime);
}

model ModifySecurityIpsRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of an instance.', example='dds-bp*****'),
  modifyMode?: string(name='ModifyMode', description='The method of modification. Valid values:

*   **Cover**: overwrites the whitelist.
*   **Append**: appends data to the whitelist.
*   **Delete**: deletes the whitelist.

The default value is **Cover**.', example='Append'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityIpGroupAttribute?: string(name='SecurityIpGroupAttribute', description='The attributes of an IP address whitelist. It can contain a maximum of 120 characters in length and can contain uppercase letters, lowercase letters, and digits.

This parameter is empty by default.', example='test'),
  securityIpGroupName?: string(name='SecurityIpGroupName', description='The name of the IP address whitelist to be modified. The default value is **default**.', example='allowserver'),
  securityIps?: string(name='SecurityIps', description='The IP addresses in an IP address whitelist. Separate multiple IP addresses with commas (,). You can add a maximum of 1,000 different IP addresses to a whitelist. You can add IP addresses in one of the following two formats:

*   IP addresses. Example: 10.23.12.24.
*   Classless Inter-Domain Routing (CIDR) blocks, such as 10.23.12.24/24, where 24 indicates that the prefix of the CIDR block is 24-bit long. You can replace 24 with a value within the range of 1 to 32.', example='127.0.0.1/24,127.0.0.1'),
  securityToken?: string(name='SecurityToken'),
}

model ModifySecurityIpsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='61B05CCF-EBAB-4BF3-BA67-D77256A721E2'),
}

model ModifySecurityIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifySecurityIpsResponseBody(name='body'),
}

async function modifySecurityIpsWithOptions(request: ModifySecurityIpsRequest, runtime: Util.RuntimeOptions): ModifySecurityIpsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.modifyMode)) {
    query['ModifyMode'] = request.modifyMode;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityIpGroupAttribute)) {
    query['SecurityIpGroupAttribute'] = request.securityIpGroupAttribute;
  }
  if (!Util.isUnset(request.securityIpGroupName)) {
    query['SecurityIpGroupName'] = request.securityIpGroupName;
  }
  if (!Util.isUnset(request.securityIps)) {
    query['SecurityIps'] = request.securityIps;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifySecurityIps',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifySecurityIps(request: ModifySecurityIpsRequest): ModifySecurityIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySecurityIpsWithOptions(request, runtime);
}

model ReleaseNodePrivateNetworkAddressRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the sharded cluster instance.', example='dds-bp1a7009eb24****'),
  networkType?: string(name='NetworkType', description='The network type of the internal endpoint. Valid values:

*   **VPC**
*   **Classic**

>  You can call the [DescribeShardingNetworkAddress](~~62135~~) operation to query the network type of the internal endpoint.', example='VPC'),
  nodeId?: string(name='NodeId', description='The ID of the shard or Configserver node.

>  You can call the [DescribeDBInstanceAttribute](~~62010~~) operation to query the ID of the shard or Configserver node.', example='d-bp128a003436****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ReleaseNodePrivateNetworkAddressResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0FDDC511-7252-4A4A-ADDA-5CB1BF63873D'),
}

model ReleaseNodePrivateNetworkAddressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReleaseNodePrivateNetworkAddressResponseBody(name='body'),
}

/**
  * *   This operation can be used to release the internal endpoint of a shard or Configserver node in a sharded cluster instance. For more information, see [Release the endpoint of a shard or Configserver node](~~134067~~).
  * *   To release the public endpoint of a shard or Configserver node in a sharded cluster instance, you can call the [ReleasePublicNetworkAddress](~~67604~~) operation.
  *
  * @param request ReleaseNodePrivateNetworkAddressRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ReleaseNodePrivateNetworkAddressResponse
 */
async function releaseNodePrivateNetworkAddressWithOptions(request: ReleaseNodePrivateNetworkAddressRequest, runtime: Util.RuntimeOptions): ReleaseNodePrivateNetworkAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.networkType)) {
    query['NetworkType'] = request.networkType;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseNodePrivateNetworkAddress',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   This operation can be used to release the internal endpoint of a shard or Configserver node in a sharded cluster instance. For more information, see [Release the endpoint of a shard or Configserver node](~~134067~~).
  * *   To release the public endpoint of a shard or Configserver node in a sharded cluster instance, you can call the [ReleasePublicNetworkAddress](~~67604~~) operation.
  *
  * @param request ReleaseNodePrivateNetworkAddressRequest
  * @return ReleaseNodePrivateNetworkAddressResponse
 */
async function releaseNodePrivateNetworkAddress(request: ReleaseNodePrivateNetworkAddressRequest): ReleaseNodePrivateNetworkAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseNodePrivateNetworkAddressWithOptions(request, runtime);
}

model ReleasePublicNetworkAddressRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.

>  If you set this parameter to the ID of a sharded cluster instance, you must also specify the **NodeId** parameter.', example='dds-bp2235****'),
  nodeId?: string(name='NodeId', description='A sharded cluster instance consists of three components: mongos, shard, and Configserver.

> * This parameter is valid only if you set the **DBInstanceId** parameter to the ID of a sharded cluster instance.
> * You can call the [DescribeDBInstanceAttribute](~~62010~~) operation to query the ID of the mongos, shard, or Configserver node.', example='s-bp2235****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ReleasePublicNetworkAddressResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='1D6AFE36-1AF5-4DE4-A954-672159D4CC69'),
}

model ReleasePublicNetworkAddressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReleasePublicNetworkAddressResponseBody(name='body'),
}

async function releasePublicNetworkAddressWithOptions(request: ReleasePublicNetworkAddressRequest, runtime: Util.RuntimeOptions): ReleasePublicNetworkAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleasePublicNetworkAddress',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function releasePublicNetworkAddress(request: ReleasePublicNetworkAddressRequest): ReleasePublicNetworkAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return releasePublicNetworkAddressWithOptions(request, runtime);
}

model RenewDBInstanceRequest {
  autoPay?: boolean(name='AutoPay', description='Specifies whether to enable automatic payment for the instance. Valid values:

*   **true**: enables automatic payment. Make sure that you have sufficient balance within your account.
*   **false**: disables automatic payment. You must perform the following operations to pay for the instance: Payment instructions: Log on to the console. In the upper-right corner, click **Billing Management** and select **Billing Management** from the drop-down list. The Billing Management page appears. In the left-side navigation pane, click **Bills**. On the Unpaid tab, click Make a Payment in the Actions column corresponding to the bill you want to pay.

Default value: **true**.', example='true'),
  businessInfo?: string(name='BusinessInfo', description='The business information.', example='{“ActivityId":"000000000"}'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='ETnLKlblzczshOTUbOCzxxxxxxxxxx'),
  couponNo?: string(name='CouponNo', description='The coupon code. Default value: **youhuiquan_promotion_option_id_for_blank**.', example='1111111111111111'),
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bpxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: int32(name='Period', description='The period you set for the instance to implement payment renewal. Unit: months. Valid values: **1-9, 12, 24, and 36**.', example='1'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model RenewDBInstanceResponseBody = {
  orderId?: string(name='OrderId', description='The ID of the order.', example='203317xxxxxxxx'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B118EF45-9633-4EE3-8405-42ED4373721B'),
}

model RenewDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RenewDBInstanceResponseBody(name='body'),
}

/**
  * Make sure that you fully understand the billing methods and [pricing](https://www.alibabacloud.com/zh/product/apsaradb-for-mongodb/pricing) of ApsaraDB for MongoDB before you call this operation.
  * This parameter is only applicable to Subscription instances.
  *
  * @param request RenewDBInstanceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return RenewDBInstanceResponse
 */
async function renewDBInstanceWithOptions(request: RenewDBInstanceRequest, runtime: Util.RuntimeOptions): RenewDBInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.businessInfo)) {
    query['BusinessInfo'] = request.businessInfo;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.couponNo)) {
    query['CouponNo'] = request.couponNo;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RenewDBInstance',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Make sure that you fully understand the billing methods and [pricing](https://www.alibabacloud.com/zh/product/apsaradb-for-mongodb/pricing) of ApsaraDB for MongoDB before you call this operation.
  * This parameter is only applicable to Subscription instances.
  *
  * @param request RenewDBInstanceRequest
  * @return RenewDBInstanceResponse
 */
async function renewDBInstance(request: RenewDBInstanceRequest): RenewDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return renewDBInstanceWithOptions(request, runtime);
}

model ResetAccountPasswordRequest {
  accountName?: string(name='AccountName', description='The operation that you want to perform. Set the value to **ResetAccountPassword**.', example='root'),
  accountPassword?: string(name='AccountPassword', description='The ID of the instance.', example='Ali!123456'),
  characterType?: string(name='CharacterType', description='The type of the database account. Valid values:

*   mongos: an account that can be used to log on to mongos
*   shard: an account that can be used to log on to shards', example='db'),
  DBInstanceId?: string(name='DBInstanceId', description='com.aliyun.abs.dds.service.v20151201.domain.ResetDdsAccountPasswordRequest', example='dds-bpxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ResetAccountPasswordResponseBody = {
  requestId?: string(name='RequestId', description='The account for which you want to reset the password. Set the value to **root**.', example='06CBD06E-ABC9-4121-AB93-3C3820B3E7E6'),
}

model ResetAccountPasswordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResetAccountPasswordResponseBody(name='body'),
}

/**
  * >  This operation can reset only the password of the root account of an instance.
  *
  * @param request ResetAccountPasswordRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ResetAccountPasswordResponse
 */
async function resetAccountPasswordWithOptions(request: ResetAccountPasswordRequest, runtime: Util.RuntimeOptions): ResetAccountPasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.characterType)) {
    query['CharacterType'] = request.characterType;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetAccountPassword',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  This operation can reset only the password of the root account of an instance.
  *
  * @param request ResetAccountPasswordRequest
  * @return ResetAccountPasswordResponse
 */
async function resetAccountPassword(request: ResetAccountPasswordRequest): ResetAccountPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetAccountPasswordWithOptions(request, runtime);
}

model RestartDBInstanceRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The instance ID.', example='dds-bpxxxxxxxx'),
  nodeId?: string(name='NodeId', description='The ID of the shard or mongos node in the sharded cluster instance.

> The sharded cluster instance is restarted if you do not specify this parameter.', example='d-bpxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model RestartDBInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='149C517D-B586-47BE-A107-8673E0ED77C6'),
}

model RestartDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestartDBInstanceResponseBody(name='body'),
}

/**
  * This operation can also be used to restart an instance, or restart a shard or mongos node in a sharded cluster instance.
  *
  * @param request RestartDBInstanceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return RestartDBInstanceResponse
 */
async function restartDBInstanceWithOptions(request: RestartDBInstanceRequest, runtime: Util.RuntimeOptions): RestartDBInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestartDBInstance',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * This operation can also be used to restart an instance, or restart a shard or mongos node in a sharded cluster instance.
  *
  * @param request RestartDBInstanceRequest
  * @return RestartDBInstanceResponse
 */
async function restartDBInstance(request: RestartDBInstanceRequest): RestartDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartDBInstanceWithOptions(request, runtime);
}

model RestoreDBInstanceRequest {
  backupId?: int32(name='BackupId', description='The ID of the backup.

>  You can call the [DescribeBackups](~~62172~~) operation to query the backup ID.', example='22536****'),
  DBInstanceId?: string(name='DBInstanceId', description='The ID of an instance.', example='dds-bp2356****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model RestoreDBInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='973DCB8F-56B3-4102-8777-3A90495927F7'),
}

model RestoreDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestoreDBInstanceResponseBody(name='body'),
}

/**
  * This operation is applicable to replica set instances, but cannot be called on standalone instances or sharded cluster instances. You can use the following methods to clone an instance: [Create an instance from a backup](~~55013~~) to clone a standalone instance. Call the [CreateShardingDBInstance](~~61884~~) operation to clone a sharded cluster instance.
  * >  This operation overwrites the data of the current instance, and the data cannot be recovered. Exercise caution when performing this operation.
  *
  * @param request RestoreDBInstanceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return RestoreDBInstanceResponse
 */
async function restoreDBInstanceWithOptions(request: RestoreDBInstanceRequest, runtime: Util.RuntimeOptions): RestoreDBInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestoreDBInstance',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * This operation is applicable to replica set instances, but cannot be called on standalone instances or sharded cluster instances. You can use the following methods to clone an instance: [Create an instance from a backup](~~55013~~) to clone a standalone instance. Call the [CreateShardingDBInstance](~~61884~~) operation to clone a sharded cluster instance.
  * >  This operation overwrites the data of the current instance, and the data cannot be recovered. Exercise caution when performing this operation.
  *
  * @param request RestoreDBInstanceRequest
  * @return RestoreDBInstanceResponse
 */
async function restoreDBInstance(request: RestoreDBInstanceRequest): RestoreDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return restoreDBInstanceWithOptions(request, runtime);
}

model SwitchDBInstanceHARequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance', example='dds-bpxxxxxxxx'),
  nodeId?: string(name='NodeId', description='The ID of the shard node in the sharded cluster instance.

> You must specify this parameter if you set the **DBInstanceId** parameter to the ID of a sharded cluster instance.', example='d-bpxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  roleIds?: string(name='RoleIds', description='The IDs of the roles who switch the primary and secondary nodes for the instance. You can call the [DescribeRoleZoneInfo](~~123802~~) operation to view the IDs and information of roles of nodes.

> 

*   Separate role IDs with commas (,). If this parameter is not specified, the primary and secondary nodes are switched.

*   If you set the **DBInstanceId** parameter to the ID of a sharded cluster instance, the roles who switch the primary and secondary nodes for the instance must belong to one shard node.', example='972xxxx,972xxxx'),
  securityToken?: string(name='SecurityToken'),
  switchMode?: int32(name='SwitchMode', description='The time when the primary and secondary nodes are switched. Valid values:

*   0: The primary and secondary nodes are immediately switched.
*   1: The primary and secondary nodes are switched during the O\\&M time period.', example='0'),
}

model SwitchDBInstanceHAResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='26BD4E5F-BDB4-47BA-B232-413AA78CFA8F'),
}

model SwitchDBInstanceHAResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SwitchDBInstanceHAResponseBody(name='body'),
}

/**
  * The instance must be running when you call this operation.
  * > 
  * *   This operation is applicable to replica set instances and sharded cluster instances, but cannot be performed on standalone instances.
  * *   On replica set instances, the switch is performed between instances. On sharded cluster instances, the switch is performed between shards.
  *
  * @param request SwitchDBInstanceHARequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return SwitchDBInstanceHAResponse
 */
async function switchDBInstanceHAWithOptions(request: SwitchDBInstanceHARequest, runtime: Util.RuntimeOptions): SwitchDBInstanceHAResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.roleIds)) {
    query['RoleIds'] = request.roleIds;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.switchMode)) {
    query['SwitchMode'] = request.switchMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SwitchDBInstanceHA',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The instance must be running when you call this operation.
  * > 
  * *   This operation is applicable to replica set instances and sharded cluster instances, but cannot be performed on standalone instances.
  * *   On replica set instances, the switch is performed between instances. On sharded cluster instances, the switch is performed between shards.
  *
  * @param request SwitchDBInstanceHARequest
  * @return SwitchDBInstanceHAResponse
 */
async function switchDBInstanceHA(request: SwitchDBInstanceHARequest): SwitchDBInstanceHAResponse {
  var runtime = new Util.RuntimeOptions{};
  return switchDBInstanceHAWithOptions(request, runtime);
}

model TagResourcesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the instance. You can call the [DescribeDBInstanceAttribute](~~62010~~) operation to query the region ID of the instance.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmyiu4ekp****'),
  resourceId?: [ string ](name='ResourceId', description='The list of resource IDs.', example='dds-bpxxxxxxxx'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType', description='The resource type. Set the value to **INSTANCE**.', example='INSTANCE'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of tag.

N specifies the serial number of the tag. The following example shows how to calculate consumption intervals:

- **Tag.1.Key** specifies the key of the first tag.
- **Tag.2.Key** specifies the key of the second tag.', example='Development team'),
      value?: string(name='Value', description='The value of tag.

N specifies the serial number of the tag. The following example shows how to calculate consumption intervals: 

- **Tag.1.Value** specifies the value of the first tag.
- **Tag.2.Value** specifies the value of the second tag.', example='MongoDB 4.0 environment'),
    }
  ](name='Tag', description='The tags that are attached to the resources.'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0FDDC511-7252-4A4A-ADDA-5CB1BF63****'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

/**
  * You can create multiple tags and bind them to multiple instances. This allows you to classify and filter instances by tag.
  * *   A tag consists of a key and a value. Each key must be unique in a region for an Alibaba Cloud account. Different keys can have the same value.
  * *   If the tag you specify does not exist, this tag is automatically created and bound to the specified instance.
  * *   If a tag that has the same key is already bound to the instance, the new tag overwrites the existing tag.
  * *   You can bind up to 20 tags to each instance.
  * *   You can bind tags to up to 50 instances each time you call the operation.
  *
  * @param request TagResourcesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return TagResourcesResponse
 */
async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can create multiple tags and bind them to multiple instances. This allows you to classify and filter instances by tag.
  * *   A tag consists of a key and a value. Each key must be unique in a region for an Alibaba Cloud account. Different keys can have the same value.
  * *   If the tag you specify does not exist, this tag is automatically created and bound to the specified instance.
  * *   If a tag that has the same key is already bound to the instance, the new tag overwrites the existing tag.
  * *   You can bind up to 20 tags to each instance.
  * *   You can bind tags to up to 50 instances each time you call the operation.
  *
  * @param request TagResourcesRequest
  * @return TagResourcesResponse
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model TransferClusterBackupRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model TransferClusterBackupResponseBody = {
  alreadyDone?: string(name='AlreadyDone'),
  requestId?: string(name='RequestId'),
}

model TransferClusterBackupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TransferClusterBackupResponseBody(name='body'),
}

async function transferClusterBackupWithOptions(request: TransferClusterBackupRequest, runtime: Util.RuntimeOptions): TransferClusterBackupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TransferClusterBackup',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function transferClusterBackup(request: TransferClusterBackupRequest): TransferClusterBackupResponse {
  var runtime = new Util.RuntimeOptions{};
  return transferClusterBackupWithOptions(request, runtime);
}

model TransformInstanceChargeTypeRequest {
  autoPay?: boolean(name='AutoPay', description='Specifies whether to enable automatic payment. Valid values:

*   **true**
*   **false**

> Default value: **true**.', example='true'),
  autoRenew?: string(name='AutoRenew', description='Specifies whether to enable auto-renewal. Valid values:

*   **true**
*   **false**

> Default value: **false**.', example='false'),
  businessInfo?: string(name='BusinessInfo', description='The business information. This is an additional parameter.', example='{“ActivityId":"000000000"}'),
  chargeType?: string(name='ChargeType', description='The billing method of the instance. Valid values:

*   **PrePaid**: subscription
*   **PostPaid**: pay-as-you-go', example='PrePaid'),
  couponNo?: string(name='CouponNo', description='The coupon code. Default value: `youhuiquan_promotion_option_id_for_blank`.', example='youhuiquan_promotion_option_id_for_blank'),
  instanceId?: string(name='InstanceId', description='The ID of the instance', example='dds-2ze55b3ec56c****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: long(name='Period', description='The subscription duration of the instance. Unit: months. Valid values: **1, 2, 3, 4, 5, 6, 7, 8, 9******, **12**, **24**, and **36**.', example='1'),
  pricingCycle?: string(name='PricingCycle', example='Month'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model TransformInstanceChargeTypeResponseBody = {
  orderId?: string(name='OrderId', description='The ID of the order.', example='21084641369****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='D8F1D721-6439-4257-A89C-F1E8E9C9****'),
}

model TransformInstanceChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TransformInstanceChargeTypeResponseBody(name='body'),
}

/**
  * Before you call this operation, make sure that you understand the billing methods and [pricing](https://www.aliyun.com/price/product#/mongodb/detail) of ApsaraDB for MongoDB.
  * Before you call this API operation, make sure that the ApsaraDB for MongoDB instance meets the following requirements:
  * *   The instance is in the Running state.
  * *   Your instance has no unpaid billing method change orders.
  * *   The instance type is available for purchase. For more information about unavailable instance types, see [Instance types](~~57141~~).
  * > To change the billing method of an instance whose instance type is no longer available to purchase, call the [ModifyDBInstanceSpec](~~61816~~) or [ModifyNodeSpec](~~61923~~) operation to first change the instance type.
  *
  * @param request TransformInstanceChargeTypeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return TransformInstanceChargeTypeResponse
 */
async function transformInstanceChargeTypeWithOptions(request: TransformInstanceChargeTypeRequest, runtime: Util.RuntimeOptions): TransformInstanceChargeTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.businessInfo)) {
    query['BusinessInfo'] = request.businessInfo;
  }
  if (!Util.isUnset(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.couponNo)) {
    query['CouponNo'] = request.couponNo;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TransformInstanceChargeType',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, make sure that you understand the billing methods and [pricing](https://www.aliyun.com/price/product#/mongodb/detail) of ApsaraDB for MongoDB.
  * Before you call this API operation, make sure that the ApsaraDB for MongoDB instance meets the following requirements:
  * *   The instance is in the Running state.
  * *   Your instance has no unpaid billing method change orders.
  * *   The instance type is available for purchase. For more information about unavailable instance types, see [Instance types](~~57141~~).
  * > To change the billing method of an instance whose instance type is no longer available to purchase, call the [ModifyDBInstanceSpec](~~61816~~) or [ModifyNodeSpec](~~61923~~) operation to first change the instance type.
  *
  * @param request TransformInstanceChargeTypeRequest
  * @return TransformInstanceChargeTypeResponse
 */
async function transformInstanceChargeType(request: TransformInstanceChargeTypeRequest): TransformInstanceChargeTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return transformInstanceChargeTypeWithOptions(request, runtime);
}

model TransformToPrePaidRequest {
  autoPay?: boolean(name='AutoPay', description='Specifies whether to enable automatic payment. Valid values:

*   **true**: enables automatic payment.
*   **false**: disables automatic payment. For more information, see [Renew an ApsaraDB for MongoDB subscription instance](~~85052~~).

>  Default value: **true**.', example='true'),
  autoRenew?: string(name='AutoRenew', description='Specifies whether to enable auto-renewal for the instance. Valid values:

*   **true**
*   **false**

>  Default value: **false**.', example='true'),
  businessInfo?: string(name='BusinessInfo', description='The business information. This is an additional parameter.', example='{“ActivityId":"000000000"}'),
  couponNo?: string(name='CouponNo', description='The coupon code. Default value: `youhuiquan_promotion_option_id_for_blank`.', example='youhuiquan_promotion_option_id_for_blank'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='dds-bp1366caac83****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: long(name='Period', description='The subscription duration of the instance. Unit: months. Valid values: **1, 2, 3, 4, 5, 6, 7, 8, 9******, **12**, **24**, and **36**.', example='1'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model TransformToPrePaidResponseBody = {
  orderId?: string(name='OrderId', description='The ID of the order.', example='21022019252****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2F42BB4E-461F-5B55-A37C-53B1141C****'),
}

model TransformToPrePaidResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TransformToPrePaidResponseBody(name='body'),
}

/**
  * Before you call this operation, make sure that you understand the billing methods and [pricing](https://www.alibabacloud.com/zh/product/apsaradb-for-mongodb/pricing).
  * A subscription instance cannot be changed to a pay-as-you-go instance. To avoid wasting resources, proceed with caution.
  * Before you call this API operation, make sure that the ApsaraDB for MongoDB instance meets the following requirements:
  * *   The instance is in the running state.
  * *   The billing method of the instance is pay-as-you-go.
  * *   The instance has no unpaid subscription orders.
  * *   The instance type is available for purchase. For more information about unavailable instance types, see [Instance types](~~57141~~).
  * >  To change the billing method of an instance whose instance type is no longer available to subscription, call the [ModifyDBInstanceSpec](~~61816~~) or [ModifyNodeSpec](~~61923~~) operation to first change the instance type.
  *
  * @param request TransformToPrePaidRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return TransformToPrePaidResponse
 */
async function transformToPrePaidWithOptions(request: TransformToPrePaidRequest, runtime: Util.RuntimeOptions): TransformToPrePaidResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.businessInfo)) {
    query['BusinessInfo'] = request.businessInfo;
  }
  if (!Util.isUnset(request.couponNo)) {
    query['CouponNo'] = request.couponNo;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TransformToPrePaid',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, make sure that you understand the billing methods and [pricing](https://www.alibabacloud.com/zh/product/apsaradb-for-mongodb/pricing).
  * A subscription instance cannot be changed to a pay-as-you-go instance. To avoid wasting resources, proceed with caution.
  * Before you call this API operation, make sure that the ApsaraDB for MongoDB instance meets the following requirements:
  * *   The instance is in the running state.
  * *   The billing method of the instance is pay-as-you-go.
  * *   The instance has no unpaid subscription orders.
  * *   The instance type is available for purchase. For more information about unavailable instance types, see [Instance types](~~57141~~).
  * >  To change the billing method of an instance whose instance type is no longer available to subscription, call the [ModifyDBInstanceSpec](~~61816~~) or [ModifyNodeSpec](~~61923~~) operation to first change the instance type.
  *
  * @param request TransformToPrePaidRequest
  * @return TransformToPrePaidResponse
 */
async function transformToPrePaid(request: TransformToPrePaidRequest): TransformToPrePaidResponse {
  var runtime = new Util.RuntimeOptions{};
  return transformToPrePaidWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to remove all tags from the instances. Valid values:

*   **true**: removes all tags from the instances.
*   **false**: does not remove all tags from the instances.

> 

*   Default value: **false**.

*   If you specify the **TagKey** parameter together with this parameter, this parameter does not take effect.', example='false'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the instance. You can call the [DescribeDBInstanceAttribute](~~62010~~) operation to query the region ID of the instance.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='sg-bpxxxxxxxxxxxxxxxxxx'),
  resourceId?: [ string ](name='ResourceId', description='The resource IDs.', example='dds-bpxxxxxxxx'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType', description='The resource type. Set the value to **INSTANCE**.', example='INSTANCE'),
  tagKey?: [ string ](name='TagKey', description='The tag keys of the resource.'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='FA3A7F36-DB57-4281-8935-4B9DF61554EB'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

/**
  * > 
  * *   You can remove up to 20 tags at a time.
  * *   If you remove a tag from all instances, the tag is automatically deleted.
  *
  * @param request UntagResourcesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UntagResourcesResponse
 */
async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   You can remove up to 20 tags at a time.
  * *   If you remove a tag from all instances, the tag is automatically deleted.
  *
  * @param request UntagResourcesRequest
  * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpgradeDBInstanceEngineVersionRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bpxxxxxxxx'),
  engineVersion?: string(name='EngineVersion', description='The database version to which you want to upgrade. Valid values: **3.4**, **4.0**, and **4.2**.

>  This database version must be later than the current database version of the instance.', example='4.0'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model UpgradeDBInstanceEngineVersionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C4907B00-A208-4E0C-A636-AA85140E406C'),
}

model UpgradeDBInstanceEngineVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeDBInstanceEngineVersionResponseBody(name='body'),
}

/**
  * The instance must be in the running state when you call this operation.
  * > * The available database versions depend on the storage engine used by the instance. For more information, see [Upgrades of MongoDB major versions](~~398673~~). You can also call the [DescribeAvailableEngineVersion](~~141355~~) operation to query the available database versions.
  * > * You cannot downgrade the MongoDB version of an instance after you upgrade it.
  * > * The instance is automatically restarted for two to three times during the upgrade process. Make sure that you upgrade the instance during off-peak hours.
  *
  * @param request UpgradeDBInstanceEngineVersionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpgradeDBInstanceEngineVersionResponse
 */
async function upgradeDBInstanceEngineVersionWithOptions(request: UpgradeDBInstanceEngineVersionRequest, runtime: Util.RuntimeOptions): UpgradeDBInstanceEngineVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeDBInstanceEngineVersion',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The instance must be in the running state when you call this operation.
  * > * The available database versions depend on the storage engine used by the instance. For more information, see [Upgrades of MongoDB major versions](~~398673~~). You can also call the [DescribeAvailableEngineVersion](~~141355~~) operation to query the available database versions.
  * > * You cannot downgrade the MongoDB version of an instance after you upgrade it.
  * > * The instance is automatically restarted for two to three times during the upgrade process. Make sure that you upgrade the instance during off-peak hours.
  *
  * @param request UpgradeDBInstanceEngineVersionRequest
  * @return UpgradeDBInstanceEngineVersionResponse
 */
async function upgradeDBInstanceEngineVersion(request: UpgradeDBInstanceEngineVersionRequest): UpgradeDBInstanceEngineVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeDBInstanceEngineVersionWithOptions(request, runtime);
}

model UpgradeDBInstanceKernelVersionRequest {
  DBInstanceId?: string(name='DBInstanceId', description='The ID of the instance.', example='dds-bp2235****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model UpgradeDBInstanceKernelVersionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='27B9A130-7C4B-40D9-84E8-2FC081097AAC'),
}

model UpgradeDBInstanceKernelVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeDBInstanceKernelVersionResponseBody(name='body'),
}

/**
  * When you call the UpgradeDBInstanceKernelVersion operation, the instance must be in the Running state.
  * > * The UpgradeDBInstanceKernelVersion operation is applicable to replica set and sharded cluster instances, but not to standalone instances.
  * > * The instance will be restarted once during the upgrade. Call this operation during off-peak hours.
  *
  * @param request UpgradeDBInstanceKernelVersionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpgradeDBInstanceKernelVersionResponse
 */
async function upgradeDBInstanceKernelVersionWithOptions(request: UpgradeDBInstanceKernelVersionRequest, runtime: Util.RuntimeOptions): UpgradeDBInstanceKernelVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeDBInstanceKernelVersion',
    version = '2015-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * When you call the UpgradeDBInstanceKernelVersion operation, the instance must be in the Running state.
  * > * The UpgradeDBInstanceKernelVersion operation is applicable to replica set and sharded cluster instances, but not to standalone instances.
  * > * The instance will be restarted once during the upgrade. Call this operation during off-peak hours.
  *
  * @param request UpgradeDBInstanceKernelVersionRequest
  * @return UpgradeDBInstanceKernelVersionResponse
 */
async function upgradeDBInstanceKernelVersion(request: UpgradeDBInstanceKernelVersionRequest): UpgradeDBInstanceKernelVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeDBInstanceKernelVersionWithOptions(request, runtime);
}

