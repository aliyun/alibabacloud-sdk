/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Dds';
  @version = '2015-12-01';
  @endpointRule = '';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AllocateNodePrivateNetworkAddressRequest {
  regionId?: string(name='RegionId', position='Host'),
  accountName?: string(name='AccountName', position='Query'),
  accountPassword?: string(name='AccountPassword', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  nodeId: string(name='NodeId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model AllocateNodePrivateNetworkAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model AllocateNodePrivateNetworkAddressResponse = {
  headers: map[string]string(name='headers'),
  body: AllocateNodePrivateNetworkAddressResponseBody(name='body'),
}

async function allocateNodePrivateNetworkAddress(request: AllocateNodePrivateNetworkAddressRequest): AllocateNodePrivateNetworkAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AllocateNodePrivateNetworkAddress', 'POST', '/', 'json', false, 'json', request);
}

model AllocatePublicNetworkAddressRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model AllocatePublicNetworkAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model AllocatePublicNetworkAddressResponse = {
  headers: map[string]string(name='headers'),
  body: AllocatePublicNetworkAddressResponseBody(name='body'),
}

async function allocatePublicNetworkAddress(request: AllocatePublicNetworkAddressRequest): AllocatePublicNetworkAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AllocatePublicNetworkAddress', 'POST', '/', 'json', false, 'json', request);
}

model CheckCloudResourceAuthorizedRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  targetRegionId: string(name='TargetRegionId', position='Query'),
}

model CheckCloudResourceAuthorizedResponseBody = {
  authorizationState?: int32(name='AuthorizationState'),
  requestId?: string(name='RequestId'),
  roleArn?: string(name='RoleArn'),
}

model CheckCloudResourceAuthorizedResponse = {
  headers: map[string]string(name='headers'),
  body: CheckCloudResourceAuthorizedResponseBody(name='body'),
}

async function checkCloudResourceAuthorized(request: CheckCloudResourceAuthorizedRequest): CheckCloudResourceAuthorizedResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckCloudResourceAuthorized', 'POST', '/', 'json', false, 'json', request);
}

model CheckRecoveryConditionRequest {
  backupId?: string(name='BackupId', position='Query'),
  databaseNames?: string(name='DatabaseNames', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  restoreTime?: string(name='RestoreTime', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  sourceDBInstance: string(name='SourceDBInstance', position='Query'),
}

model CheckRecoveryConditionResponseBody = {
  DBInstanceName?: string(name='DBInstanceName'),
  isValid?: boolean(name='IsValid'),
  requestId?: string(name='RequestId'),
}

model CheckRecoveryConditionResponse = {
  headers: map[string]string(name='headers'),
  body: CheckRecoveryConditionResponseBody(name='body'),
}

async function checkRecoveryCondition(request: CheckRecoveryConditionRequest): CheckRecoveryConditionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckRecoveryCondition', 'POST', '/', 'json', false, 'json', request);
}

model CreateBackupRequest {
  regionId?: string(name='RegionId', position='Host'),
  backupMethod?: string(name='BackupMethod', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model CreateBackupResponseBody = {
  backupId?: string(name='BackupId'),
  requestId?: string(name='RequestId'),
}

model CreateBackupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBackupResponseBody(name='body'),
}

async function createBackup(request: CreateBackupRequest): CreateBackupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateBackup', 'POST', '/', 'json', false, 'json', request);
}

model CreateDBInstanceRequest {
  accountPassword?: string(name='AccountPassword', position='Query'),
  autoRenew?: string(name='AutoRenew', position='Query'),
  backupId?: string(name='BackupId', position='Query'),
  businessInfo?: string(name='BusinessInfo', position='Query'),
  chargeType?: string(name='ChargeType', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  couponNo?: string(name='CouponNo', position='Query'),
  DBInstanceClass: string(name='DBInstanceClass', position='Query'),
  DBInstanceDescription?: string(name='DBInstanceDescription', position='Query'),
  DBInstanceStorage: int32(name='DBInstanceStorage', position='Query'),
  databaseNames?: string(name='DatabaseNames', position='Query'),
  engine: string(name='Engine', position='Query'),
  engineVersion: string(name='EngineVersion', position='Query'),
  hiddenZoneId?: string(name='HiddenZoneId', position='Query'),
  networkType?: string(name='NetworkType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  readonlyReplicas?: string(name='ReadonlyReplicas', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  replicationFactor?: string(name='ReplicationFactor', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  restoreTime?: string(name='RestoreTime', position='Query'),
  secondaryZoneId?: string(name='SecondaryZoneId', position='Query'),
  securityIPList?: string(name='SecurityIPList', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  srcDBInstanceId?: string(name='SrcDBInstanceId', position='Query'),
  storageEngine?: string(name='StorageEngine', position='Query'),
  storageType?: string(name='StorageType', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model CreateDBInstanceResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDBInstanceResponseBody(name='body'),
}

async function createDBInstance(request: CreateDBInstanceRequest): CreateDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model CreateNodeRequest {
  regionId?: string(name='RegionId', position='Host'),
  accountName?: string(name='AccountName', position='Query'),
  accountPassword?: string(name='AccountPassword', position='Query'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  businessInfo?: string(name='BusinessInfo', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  couponNo?: string(name='CouponNo', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  nodeClass: string(name='NodeClass', position='Query'),
  nodeStorage?: int32(name='NodeStorage', position='Query'),
  nodeType: string(name='NodeType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  readonlyReplicas?: int32(name='ReadonlyReplicas', minimum=0, maximum=5, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  shardDirect?: boolean(name='ShardDirect', position='Query'),
}

model CreateNodeResponseBody = {
  nodeId?: string(name='NodeId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateNodeResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNodeResponseBody(name='body'),
}

async function createNode(request: CreateNodeRequest): CreateNodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateNode', 'POST', '/', 'json', false, 'json', request);
}

model CreateNodeBatchRequest {
  regionId?: string(name='RegionId', position='Host'),
  accountName?: string(name='AccountName', position='Query'),
  accountPassword?: string(name='AccountPassword', position='Query'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  businessInfo?: string(name='BusinessInfo', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  couponNo?: string(name='CouponNo', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  fromApp?: string(name='FromApp', position='Query'),
  nodesInfo: string(name='NodesInfo', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  shardDirect?: boolean(name='ShardDirect', position='Query'),
}

model CreateNodeBatchResponseBody = {
  nodeId?: string(name='NodeId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateNodeBatchResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNodeBatchResponseBody(name='body'),
}

async function createNodeBatch(request: CreateNodeBatchRequest): CreateNodeBatchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateNodeBatch', 'POST', '/', 'json', false, 'json', request);
}

model CreateShardingDBInstanceRequest {
  accountPassword?: string(name='AccountPassword', position='Query'),
  autoRenew?: string(name='AutoRenew', position='Query'),
  chargeType?: string(name='ChargeType', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  configServer: [ 
    {
      class: string(name='Class'),
      storage: int32(name='Storage'),
    }
  ](name='ConfigServer', position='Query'),
  DBInstanceDescription?: string(name='DBInstanceDescription', position='Query'),
  engine: string(name='Engine', position='Query'),
  engineVersion: string(name='EngineVersion', position='Query'),
  hiddenZoneId?: string(name='HiddenZoneId', position='Query'),
  mongos: [ 
    {
      class: string(name='Class'),
    }
  ](name='Mongos', position='Query'),
  networkType?: string(name='NetworkType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  protocolType?: string(name='ProtocolType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  replicaSet: [ 
    {
      class: string(name='Class'),
      readonlyReplicas?: int32(name='ReadonlyReplicas', minimum=0, maximum=5),
      storage: int32(name='Storage'),
    }
  ](name='ReplicaSet', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  restoreTime?: string(name='RestoreTime', position='Query'),
  secondaryZoneId?: string(name='SecondaryZoneId', position='Query'),
  securityIPList?: string(name='SecurityIPList', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  srcDBInstanceId?: string(name='SrcDBInstanceId', position='Query'),
  storageEngine?: string(name='StorageEngine', position='Query'),
  storageType?: string(name='StorageType', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model CreateShardingDBInstanceResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateShardingDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateShardingDBInstanceResponseBody(name='body'),
}

async function createShardingDBInstance(request: CreateShardingDBInstanceRequest): CreateShardingDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateShardingDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDBInstanceRequest {
  regionId?: string(name='RegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DeleteDBInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDBInstanceResponseBody(name='body'),
}

async function deleteDBInstance(request: DeleteDBInstanceRequest): DeleteDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model DeleteNodeRequest {
  regionId?: string(name='RegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  nodeId: string(name='NodeId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DeleteNodeResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
  taskId?: int32(name='TaskId'),
}

model DeleteNodeResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNodeResponseBody(name='body'),
}

async function deleteNode(request: DeleteNodeRequest): DeleteNodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteNode', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAccountsRequest {
  regionId?: string(name='RegionId', position='Host'),
  accountName?: string(name='AccountName', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeAccountsResponseBody = {
  accounts?: {
    account?: [ 
    {
      accountDescription?: string(name='AccountDescription'),
      accountName?: string(name='AccountName'),
      accountStatus?: string(name='AccountStatus'),
      characterType?: string(name='CharacterType'),
      DBInstanceId?: string(name='DBInstanceId'),
    }
  ](name='Account')
  }(name='Accounts'),
  requestId?: string(name='RequestId'),
}

model DescribeAccountsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAccountsResponseBody(name='body'),
}

async function describeAccounts(request: DescribeAccountsRequest): DescribeAccountsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAccounts', 'POST', '/', 'json', false, 'json', request);
}

model DescribeActiveOperationTaskCountRequest {
  regionId?: string(name='RegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeActiveOperationTaskCountResponseBody = {
  needPop?: int32(name='NeedPop'),
  requestId?: string(name='RequestId'),
  taskCount?: int32(name='TaskCount'),
}

model DescribeActiveOperationTaskCountResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeActiveOperationTaskCountResponseBody(name='body'),
}

async function describeActiveOperationTaskCount(request: DescribeActiveOperationTaskCountRequest): DescribeActiveOperationTaskCountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeActiveOperationTaskCount', 'POST', '/', 'json', false, 'json', request);
}

model DescribeActiveOperationTaskTypeRequest {
  regionId?: string(name='RegionId', position='Host'),
  isHistory?: int32(name='IsHistory', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeActiveOperationTaskTypeResponseBody = {
  requestId?: string(name='RequestId'),
  typeList?: [ 
    {
      count?: int32(name='Count'),
      taskType?: string(name='TaskType'),
      taskTypeInfoEn?: string(name='TaskTypeInfoEn'),
      taskTypeInfoZh?: string(name='TaskTypeInfoZh'),
    }
  ](name='TypeList'),
}

model DescribeActiveOperationTaskTypeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeActiveOperationTaskTypeResponseBody(name='body'),
}

async function describeActiveOperationTaskType(request: DescribeActiveOperationTaskTypeRequest): DescribeActiveOperationTaskTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeActiveOperationTaskType', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAuditLogFilterRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  roleType?: string(name='RoleType', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeAuditLogFilterResponseBody = {
  filter?: string(name='Filter'),
  requestId?: string(name='RequestId'),
  roleType?: string(name='RoleType'),
}

model DescribeAuditLogFilterResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAuditLogFilterResponseBody(name='body'),
}

async function describeAuditLogFilter(request: DescribeAuditLogFilterRequest): DescribeAuditLogFilterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAuditLogFilter', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAuditPolicyRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeAuditPolicyResponseBody = {
  logAuditStatus?: string(name='LogAuditStatus'),
  requestId?: string(name='RequestId'),
}

model DescribeAuditPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAuditPolicyResponseBody(name='body'),
}

async function describeAuditPolicy(request: DescribeAuditPolicyRequest): DescribeAuditPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAuditPolicy', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAuditRecordsRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  database?: string(name='Database', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  form?: string(name='Form', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  orderType?: string(name='OrderType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  queryKeywords?: string(name='QueryKeywords', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  startTime: string(name='StartTime', position='Query'),
  user?: string(name='User', position='Query'),
}

model DescribeAuditRecordsResponseBody = {
  items?: {
    SQLRecord?: [ 
    {
      accountName?: string(name='AccountName'),
      DBName?: string(name='DBName'),
      executeTime?: string(name='ExecuteTime'),
      hostAddress?: string(name='HostAddress'),
      returnRowCounts?: long(name='ReturnRowCounts'),
      syntax?: string(name='Syntax'),
      tableName?: string(name='TableName'),
      threadID?: string(name='ThreadID'),
      totalExecutionTimes?: long(name='TotalExecutionTimes'),
    }
  ](name='SQLRecord')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeAuditRecordsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAuditRecordsResponseBody(name='body'),
}

async function describeAuditRecords(request: DescribeAuditRecordsRequest): DescribeAuditRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAuditRecords', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAvailableEngineVersionRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeAvailableEngineVersionResponseBody = {
  engineVersions?: {
    engineVersion?: [ string ](name='EngineVersion')
  }(name='EngineVersions'),
  requestId?: string(name='RequestId'),
}

model DescribeAvailableEngineVersionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAvailableEngineVersionResponseBody(name='body'),
}

async function describeAvailableEngineVersion(request: DescribeAvailableEngineVersionRequest): DescribeAvailableEngineVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAvailableEngineVersion', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAvailableResourceRequest {
  dbType?: string(name='DbType', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeAvailableResourceResponseBody = {
  requestId?: string(name='RequestId'),
  supportedDBTypes?: {
    supportedDBType?: [ 
    {
      availableZones?: {
        availableZone?: [ 
        {
          regionId?: string(name='RegionId'),
          supportedEngineVersions?: {
            supportedEngineVersion?: [ 
            {
              supportedEngines?: {
                supportedEngine?: [ 
                {
                  engine?: string(name='Engine'),
                  supportedNodeTypes?: {
                    supportedNodeType?: [ 
                    {
                      availableResources?: {
                        availableResource?: [ 
                        {
                          DBInstanceStorageRange?: {
                            max?: int32(name='Max'),
                            min?: int32(name='Min'),
                            step?: int32(name='Step'),
                          }(name='DBInstanceStorageRange'),
                          instanceClass?: string(name='InstanceClass'),
                          instanceClassRemark?: string(name='InstanceClassRemark'),
                        }
                      ](name='AvailableResource')
                      }(name='AvailableResources'),
                      networkTypes?: string(name='NetworkTypes'),
                      nodeType?: string(name='NodeType'),
                    }
                  ](name='SupportedNodeType')
                  }(name='SupportedNodeTypes'),
                }
              ](name='SupportedEngine')
              }(name='SupportedEngines'),
              version?: string(name='Version'),
            }
          ](name='SupportedEngineVersion')
          }(name='SupportedEngineVersions'),
          zoneId?: string(name='ZoneId'),
        }
      ](name='AvailableZone')
      }(name='AvailableZones'),
      dbType?: string(name='DbType'),
    }
  ](name='SupportedDBType')
  }(name='SupportedDBTypes'),
}

model DescribeAvailableResourceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAvailableResourceResponseBody(name='body'),
}

async function describeAvailableResource(request: DescribeAvailableResourceRequest): DescribeAvailableResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAvailableResource', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBackupDBsRequest {
  backupId?: string(name='BackupId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  restoreTime?: string(name='RestoreTime', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  sourceDBInstance: string(name='SourceDBInstance', position='Query'),
}

model DescribeBackupDBsResponseBody = {
  databases?: {
    database?: [ 
    {
      DBName?: string(name='DBName'),
    }
  ](name='Database')
  }(name='Databases'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeBackupDBsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBackupDBsResponseBody(name='body'),
}

async function describeBackupDBs(request: DescribeBackupDBsRequest): DescribeBackupDBsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBackupDBs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBackupPolicyRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeBackupPolicyResponseBody = {
  backupInterval?: int32(name='BackupInterval'),
  backupRetentionPeriod?: string(name='BackupRetentionPeriod'),
  enableBackupLog?: int32(name='EnableBackupLog'),
  logBackupRetentionPeriod?: int32(name='LogBackupRetentionPeriod'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod'),
  preferredBackupTime?: string(name='PreferredBackupTime'),
  requestId?: string(name='RequestId'),
  snapshotBackupType?: string(name='SnapshotBackupType'),
}

model DescribeBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBackupPolicyResponseBody(name='body'),
}

async function describeBackupPolicy(request: DescribeBackupPolicyRequest): DescribeBackupPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBackupPolicy', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBackupsRequest {
  regionId?: string(name='RegionId', position='Host'),
  backupId?: string(name='BackupId', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model DescribeBackupsResponseBody = {
  backups?: {
    backup?: [ 
    {
      backupDBNames?: string(name='BackupDBNames'),
      backupDownloadURL?: string(name='BackupDownloadURL'),
      backupEndTime?: string(name='BackupEndTime'),
      backupId?: int32(name='BackupId'),
      backupIntranetDownloadURL?: string(name='BackupIntranetDownloadURL'),
      backupMethod?: string(name='BackupMethod'),
      backupMode?: string(name='BackupMode'),
      backupSize?: long(name='BackupSize'),
      backupStartTime?: string(name='BackupStartTime'),
      backupStatus?: string(name='BackupStatus'),
      backupType?: string(name='BackupType'),
    }
  ](name='Backup')
  }(name='Backups'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeBackupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBackupsResponseBody(name='body'),
}

async function describeBackups(request: DescribeBackupsRequest): DescribeBackupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBackups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceAttributeRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  engine?: string(name='Engine', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeDBInstanceAttributeResponseBody = {
  DBInstances?: {
    DBInstance?: [ 
    {
      capacityUnit?: string(name='CapacityUnit'),
      chargeType?: string(name='ChargeType'),
      configserverList?: {
        configserverAttribute?: [ 
        {
          connectString?: string(name='ConnectString'),
          maxConnections?: int32(name='MaxConnections'),
          maxIOPS?: int32(name='MaxIOPS'),
          nodeClass?: string(name='NodeClass'),
          nodeDescription?: string(name='NodeDescription'),
          nodeId?: string(name='NodeId'),
          nodeStorage?: int32(name='NodeStorage'),
          port?: int32(name='Port'),
          status?: string(name='Status'),
        }
      ](name='ConfigserverAttribute')
      }(name='ConfigserverList'),
      creationTime?: string(name='CreationTime'),
      currentKernelVersion?: string(name='CurrentKernelVersion'),
      DBInstanceClass?: string(name='DBInstanceClass'),
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceId?: string(name='DBInstanceId'),
      DBInstanceReleaseProtection?: boolean(name='DBInstanceReleaseProtection'),
      DBInstanceStatus?: string(name='DBInstanceStatus'),
      DBInstanceStorage?: int32(name='DBInstanceStorage'),
      DBInstanceType?: string(name='DBInstanceType'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      expireTime?: string(name='ExpireTime'),
      hiddenZoneId?: string(name='HiddenZoneId'),
      kindCode?: string(name='KindCode'),
      lastDowngradeTime?: string(name='LastDowngradeTime'),
      lockMode?: string(name='LockMode'),
      maintainEndTime?: string(name='MaintainEndTime'),
      maintainStartTime?: string(name='MaintainStartTime'),
      maxConnections?: int32(name='MaxConnections'),
      maxIOPS?: int32(name='MaxIOPS'),
      mongosList?: {
        mongosAttribute?: [ 
        {
          connectSting?: string(name='ConnectSting'),
          maxConnections?: int32(name='MaxConnections'),
          maxIOPS?: int32(name='MaxIOPS'),
          nodeClass?: string(name='NodeClass'),
          nodeDescription?: string(name='NodeDescription'),
          nodeId?: string(name='NodeId'),
          port?: int32(name='Port'),
          status?: string(name='Status'),
          VPCId?: string(name='VPCId'),
          vSwitchId?: string(name='VSwitchId'),
          vpcCloudInstanceId?: string(name='VpcCloudInstanceId'),
        }
      ](name='MongosAttribute')
      }(name='MongosList'),
      networkType?: string(name='NetworkType'),
      protocolType?: string(name='ProtocolType'),
      readonlyReplicas?: string(name='ReadonlyReplicas'),
      regionId?: string(name='RegionId'),
      replacateId?: string(name='ReplacateId'),
      replicaSetName?: string(name='ReplicaSetName'),
      replicaSets?: {
        replicaSet?: [ 
        {
          connectionDomain?: string(name='ConnectionDomain'),
          connectionPort?: string(name='ConnectionPort'),
          networkType?: string(name='NetworkType'),
          replicaSetRole?: string(name='ReplicaSetRole'),
          VPCCloudInstanceId?: string(name='VPCCloudInstanceId'),
          VPCId?: string(name='VPCId'),
          vSwitchId?: string(name='VSwitchId'),
        }
      ](name='ReplicaSet')
      }(name='ReplicaSets'),
      replicationFactor?: string(name='ReplicationFactor'),
      resourceGroupId?: string(name='ResourceGroupId'),
      secondaryZoneId?: string(name='SecondaryZoneId'),
      shardList?: {
        shardAttribute?: [ 
        {
          connectString?: string(name='ConnectString'),
          maxConnections?: int32(name='MaxConnections'),
          maxIOPS?: int32(name='MaxIOPS'),
          nodeClass?: string(name='NodeClass'),
          nodeDescription?: string(name='NodeDescription'),
          nodeId?: string(name='NodeId'),
          nodeStorage?: int32(name='NodeStorage'),
          port?: int32(name='Port'),
          readonlyReplicas?: int32(name='ReadonlyReplicas'),
          status?: string(name='Status'),
        }
      ](name='ShardAttribute')
      }(name='ShardList'),
      storageEngine?: string(name='StorageEngine'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      VPCCloudInstanceIds?: string(name='VPCCloudInstanceIds'),
      VPCId?: string(name='VPCId'),
      vSwitchId?: string(name='VSwitchId'),
      vpcAuthMode?: string(name='VpcAuthMode'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='DBInstance')
  }(name='DBInstances'),
  requestId?: string(name='RequestId'),
}

model DescribeDBInstanceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceAttributeResponseBody(name='body'),
}

async function describeDBInstanceAttribute(request: DescribeDBInstanceAttributeRequest): DescribeDBInstanceAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceEncryptionKeyRequest {
  regionId?: string(name='RegionId', position='Host'),
  targetRegionId?: string(name='TargetRegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  encryptionKey?: string(name='EncryptionKey', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeDBInstanceEncryptionKeyResponseBody = {
  creator?: string(name='Creator'),
  deleteDate?: string(name='DeleteDate'),
  description?: string(name='Description'),
  encryptionKey?: string(name='EncryptionKey'),
  encryptionKeyStatus?: string(name='EncryptionKeyStatus'),
  keyUsage?: string(name='KeyUsage'),
  materialExpireTime?: string(name='MaterialExpireTime'),
  origin?: string(name='Origin'),
  requestId?: string(name='RequestId'),
}

model DescribeDBInstanceEncryptionKeyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceEncryptionKeyResponseBody(name='body'),
}

async function describeDBInstanceEncryptionKey(request: DescribeDBInstanceEncryptionKeyRequest): DescribeDBInstanceEncryptionKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceEncryptionKey', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceMonitorRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeDBInstanceMonitorResponseBody = {
  granularity?: string(name='Granularity'),
  requestId?: string(name='RequestId'),
}

model DescribeDBInstanceMonitorResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceMonitorResponseBody(name='body'),
}

async function describeDBInstanceMonitor(request: DescribeDBInstanceMonitorRequest): DescribeDBInstanceMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceMonitor', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstancePerformanceRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  key: string(name='Key', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  replicaSetRole?: string(name='ReplicaSetRole', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  roleId?: string(name='RoleId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeDBInstancePerformanceResponseBody = {
  endTime?: string(name='EndTime'),
  performanceKeys?: {
    performanceKey?: [ 
    {
      key?: string(name='Key'),
      performanceValues?: {
        performanceValue?: [ 
        {
          date?: string(name='Date'),
          value?: string(name='Value'),
        }
      ](name='PerformanceValue')
      }(name='PerformanceValues'),
      unit?: string(name='Unit'),
      valueFormat?: string(name='ValueFormat'),
    }
  ](name='PerformanceKey')
  }(name='PerformanceKeys'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
}

model DescribeDBInstancePerformanceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstancePerformanceResponseBody(name='body'),
}

async function describeDBInstancePerformance(request: DescribeDBInstancePerformanceRequest): DescribeDBInstancePerformanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstancePerformance', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceSSLRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeDBInstanceSSLResponseBody = {
  certCommonName?: string(name='CertCommonName'),
  requestId?: string(name='RequestId'),
  SSLExpiredTime?: string(name='SSLExpiredTime'),
  SSLStatus?: string(name='SSLStatus'),
}

model DescribeDBInstanceSSLResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceSSLResponseBody(name='body'),
}

async function describeDBInstanceSSL(request: DescribeDBInstanceSSLRequest): DescribeDBInstanceSSLResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceSSL', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceTDEInfoRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeDBInstanceTDEInfoResponseBody = {
  requestId?: string(name='RequestId'),
  TDEStatus?: string(name='TDEStatus'),
}

model DescribeDBInstanceTDEInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceTDEInfoResponseBody(name='body'),
}

async function describeDBInstanceTDEInfo(request: DescribeDBInstanceTDEInfoRequest): DescribeDBInstanceTDEInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceTDEInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstancesRequest {
  chargeType?: string(name='ChargeType', position='Query'),
  connectionDomain?: string(name='ConnectionDomain', position='Query'),
  DBInstanceClass?: string(name='DBInstanceClass', position='Query'),
  DBInstanceDescription?: string(name='DBInstanceDescription', position='Query'),
  DBInstanceId?: string(name='DBInstanceId', position='Query'),
  DBInstanceStatus?: string(name='DBInstanceStatus', position='Query'),
  DBInstanceType?: string(name='DBInstanceType', position='Query'),
  engine?: string(name='Engine', position='Query'),
  engineVersion?: string(name='EngineVersion', position='Query'),
  expireTime?: string(name='ExpireTime', position='Query'),
  expired?: string(name='Expired', position='Query'),
  networkType?: string(name='NetworkType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  replicationFactor?: string(name='ReplicationFactor', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeDBInstancesResponseBody = {
  DBInstances?: {
    DBInstance?: [ 
    {
      capacityUnit?: string(name='CapacityUnit'),
      chargeType?: string(name='ChargeType'),
      creationTime?: string(name='CreationTime'),
      DBInstanceClass?: string(name='DBInstanceClass'),
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceId?: string(name='DBInstanceId'),
      DBInstanceStatus?: string(name='DBInstanceStatus'),
      DBInstanceStorage?: int32(name='DBInstanceStorage'),
      DBInstanceType?: string(name='DBInstanceType'),
      destroyTime?: string(name='DestroyTime'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      expireTime?: string(name='ExpireTime'),
      hiddenZoneId?: string(name='HiddenZoneId'),
      kindCode?: string(name='KindCode'),
      lastDowngradeTime?: string(name='LastDowngradeTime'),
      lockMode?: string(name='LockMode'),
      mongosList?: {
        mongosAttribute?: [ 
        {
          nodeClass?: string(name='NodeClass'),
          nodeDescription?: string(name='NodeDescription'),
          nodeId?: string(name='NodeId'),
        }
      ](name='MongosAttribute')
      }(name='MongosList'),
      networkType?: string(name='NetworkType'),
      regionId?: string(name='RegionId'),
      replicationFactor?: string(name='ReplicationFactor'),
      resourceGroupId?: string(name='ResourceGroupId'),
      secondaryZoneId?: string(name='SecondaryZoneId'),
      shardList?: {
        shardAttribute?: [ 
        {
          nodeClass?: string(name='NodeClass'),
          nodeDescription?: string(name='NodeDescription'),
          nodeId?: string(name='NodeId'),
          nodeStorage?: int32(name='NodeStorage'),
          readonlyReplicas?: int32(name='ReadonlyReplicas'),
        }
      ](name='ShardAttribute')
      }(name='ShardList'),
      storageType?: string(name='StorageType'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      vpcAuthMode?: string(name='VpcAuthMode'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='DBInstance')
  }(name='DBInstances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeDBInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstancesResponseBody(name='body'),
}

async function describeDBInstances(request: DescribeDBInstancesRequest): DescribeDBInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstancesOverviewRequest {
  chargeType?: string(name='ChargeType', position='Query'),
  engineVersion?: string(name='EngineVersion', position='Query'),
  instanceClass?: string(name='InstanceClass', position='Query'),
  instanceIds?: string(name='InstanceIds', position='Query'),
  instanceStatus?: string(name='InstanceStatus', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  networkType?: string(name='NetworkType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeDBInstancesOverviewResponseBody = {
  DBInstances?: [ 
    {
      capacityUnit?: string(name='CapacityUnit'),
      chargeType?: string(name='ChargeType'),
      creationTime?: string(name='CreationTime'),
      DBInstanceClass?: string(name='DBInstanceClass'),
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceId?: string(name='DBInstanceId'),
      DBInstanceStatus?: string(name='DBInstanceStatus'),
      DBInstanceStorage?: int32(name='DBInstanceStorage'),
      DBInstanceType?: string(name='DBInstanceType'),
      destroyTime?: string(name='DestroyTime'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      expireTime?: string(name='ExpireTime'),
      kindCode?: string(name='KindCode'),
      lastDowngradeTime?: string(name='LastDowngradeTime'),
      lockMode?: string(name='LockMode'),
      mongosList?: [ 
        {
          nodeClass?: string(name='NodeClass'),
          nodeDescription?: string(name='NodeDescription'),
          nodeId?: string(name='NodeId'),
        }
      ](name='MongosList'),
      networkType?: string(name='NetworkType'),
      regionId?: string(name='RegionId'),
      replicationFactor?: string(name='ReplicationFactor'),
      resourceGroupId?: string(name='ResourceGroupId'),
      shardList?: [ 
        {
          nodeClass?: string(name='NodeClass'),
          nodeDescription?: string(name='NodeDescription'),
          nodeId?: string(name='NodeId'),
          nodeStorage?: int32(name='NodeStorage'),
          readonlyReplicas?: int32(name='ReadonlyReplicas'),
        }
      ](name='ShardList'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      vpcAuthMode?: string(name='VpcAuthMode'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='DBInstances'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model DescribeDBInstancesOverviewResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstancesOverviewResponseBody(name='body'),
}

async function describeDBInstancesOverview(request: DescribeDBInstancesOverviewRequest): DescribeDBInstancesOverviewResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstancesOverview', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDedicatedClusterInstanceListRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  dedicatedHostName?: string(name='DedicatedHostName', position='Query'),
  engine?: string(name='Engine', position='Query'),
  engineVersion?: string(name='EngineVersion', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  instanceNetType?: string(name='InstanceNetType', position='Query'),
  instanceStatus?: string(name='InstanceStatus', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeDedicatedClusterInstanceListResponseBody = {
  instances?: {
    dbInstance?: [ 
    {
      characterType?: string(name='CharacterType'),
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      createTime?: string(name='CreateTime'),
      customId?: string(name='CustomId'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      instanceClass?: string(name='InstanceClass'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      instanceNodeList?: {
        instanceNodes?: [ 
        {
          dedicatedHostName?: string(name='DedicatedHostName'),
          insName?: string(name='InsName'),
          nodeId?: int32(name='NodeId'),
          nodeIp?: string(name='NodeIp'),
          nodeType?: string(name='NodeType'),
          port?: int32(name='Port'),
          role?: string(name='Role'),
          zoneId?: string(name='ZoneId'),
        }
      ](name='InstanceNodes')
      }(name='InstanceNodeList'),
      instanceStatus?: string(name='InstanceStatus'),
      maintainEndTime?: string(name='MaintainEndTime'),
      maintainStartTime?: string(name='MaintainStartTime'),
      region?: string(name='Region'),
      regionId?: string(name='RegionId'),
      storageType?: string(name='StorageType'),
      vpcId?: string(name='VpcId'),
      vswitchId?: string(name='VswitchId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='dbInstance')
  }(name='Instances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeDedicatedClusterInstanceListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDedicatedClusterInstanceListResponseBody(name='body'),
}

async function describeDedicatedClusterInstanceList(request: DescribeDedicatedClusterInstanceListRequest): DescribeDedicatedClusterInstanceListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDedicatedClusterInstanceList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeErrorLogRecordsRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBName?: string(name='DBName', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=30, maximum=100, position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  roleType?: string(name='RoleType', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeErrorLogRecordsResponseBody = {
  engine?: string(name='Engine'),
  items?: {
    logRecords?: [ 
    {
      category?: string(name='Category'),
      connInfo?: string(name='ConnInfo'),
      content?: string(name='Content'),
      createTime?: string(name='CreateTime'),
      id?: int32(name='Id'),
    }
  ](name='LogRecords')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeErrorLogRecordsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeErrorLogRecordsResponseBody(name='body'),
}

async function describeErrorLogRecords(request: DescribeErrorLogRecordsRequest): DescribeErrorLogRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeErrorLogRecords', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceAutoRenewalAttributeRequest {
  DBInstanceId?: string(name='DBInstanceId', position='Query'),
  DBInstanceType?: string(name='DBInstanceType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeInstanceAutoRenewalAttributeResponseBody = {
  items?: {
    item?: [ 
    {
      autoRenew?: string(name='AutoRenew'),
      DBInstanceType?: string(name='DBInstanceType'),
      dbInstanceId?: string(name='DbInstanceId'),
      duration?: string(name='Duration'),
      regionId?: string(name='RegionId'),
    }
  ](name='Item')
  }(name='Items'),
  itemsNumbers?: int32(name='ItemsNumbers'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceAutoRenewalAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceAutoRenewalAttributeResponseBody(name='body'),
}

async function describeInstanceAutoRenewalAttribute(request: DescribeInstanceAutoRenewalAttributeRequest): DescribeInstanceAutoRenewalAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceAutoRenewalAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeKernelReleaseNotesRequest {
  regionId?: string(name='RegionId', position='Host'),
  kernelVersion?: string(name='KernelVersion', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeKernelReleaseNotesResponseBody = {
  releaseNotes?: {
    releaseNote?: [ 
    {
      kernelVersion?: string(name='KernelVersion'),
      releaseNote?: string(name='ReleaseNote'),
    }
  ](name='ReleaseNote')
  }(name='ReleaseNotes'),
  requestId?: string(name='RequestId'),
}

model DescribeKernelReleaseNotesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeKernelReleaseNotesResponseBody(name='body'),
}

async function describeKernelReleaseNotes(request: DescribeKernelReleaseNotesRequest): DescribeKernelReleaseNotesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeKernelReleaseNotes', 'POST', '/', 'json', false, 'json', request);
}

model DescribeMongoDBLogConfigRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeMongoDBLogConfigResponseBody = {
  enableAudit?: boolean(name='EnableAudit'),
  isEtlMetaExist?: int32(name='IsEtlMetaExist'),
  isUserProjectLogstoreExist?: int32(name='IsUserProjectLogstoreExist'),
  preserveStorageForStandard?: long(name='PreserveStorageForStandard'),
  preserveStorageForTrail?: long(name='PreserveStorageForTrail'),
  requestId?: string(name='RequestId'),
  serviceType?: string(name='ServiceType'),
  ttlForStandard?: long(name='TtlForStandard'),
  ttlForTrail?: long(name='TtlForTrail'),
  usedStorageForStandard?: long(name='UsedStorageForStandard'),
  usedStorageForTrail?: long(name='UsedStorageForTrail'),
  userProjectName?: string(name='UserProjectName'),
}

model DescribeMongoDBLogConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMongoDBLogConfigResponseBody(name='body'),
}

async function describeMongoDBLogConfig(request: DescribeMongoDBLogConfigRequest): DescribeMongoDBLogConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMongoDBLogConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeParameterModificationHistoryRequest {
  regionId?: string(name='RegionId', position='Host'),
  characterType?: string(name='CharacterType', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeParameterModificationHistoryResponseBody = {
  historicalParameters?: {
    historicalParameter?: [ 
    {
      modifyTime?: string(name='ModifyTime'),
      newParameterValue?: string(name='NewParameterValue'),
      oldParameterValue?: string(name='OldParameterValue'),
      parameterName?: string(name='ParameterName'),
    }
  ](name='HistoricalParameter')
  }(name='HistoricalParameters'),
  requestId?: string(name='RequestId'),
}

model DescribeParameterModificationHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeParameterModificationHistoryResponseBody(name='body'),
}

async function describeParameterModificationHistory(request: DescribeParameterModificationHistoryRequest): DescribeParameterModificationHistoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeParameterModificationHistory', 'POST', '/', 'json', false, 'json', request);
}

model DescribeParameterTemplatesRequest {
  engine: string(name='Engine', position='Query'),
  engineVersion: string(name='EngineVersion', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeParameterTemplatesResponseBody = {
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  parameterCount?: string(name='ParameterCount'),
  parameters?: {
    templateRecord?: [ 
    {
      checkingCode?: string(name='CheckingCode'),
      forceModify?: boolean(name='ForceModify'),
      forceRestart?: boolean(name='ForceRestart'),
      parameterDescription?: string(name='ParameterDescription'),
      parameterName?: string(name='ParameterName'),
      parameterValue?: string(name='ParameterValue'),
    }
  ](name='TemplateRecord')
  }(name='Parameters'),
  requestId?: string(name='RequestId'),
}

model DescribeParameterTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeParameterTemplatesResponseBody(name='body'),
}

async function describeParameterTemplates(request: DescribeParameterTemplatesRequest): DescribeParameterTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeParameterTemplates', 'POST', '/', 'json', false, 'json', request);
}

model DescribeParametersRequest {
  characterType?: string(name='CharacterType', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeParametersResponseBody = {
  configParameters?: {
    parameter?: [ 
    {
      checkingCode?: string(name='CheckingCode'),
      forceRestart?: boolean(name='ForceRestart'),
      modifiableStatus?: boolean(name='ModifiableStatus'),
      parameterDescription?: string(name='ParameterDescription'),
      parameterName?: string(name='ParameterName'),
      parameterValue?: string(name='ParameterValue'),
    }
  ](name='Parameter')
  }(name='ConfigParameters'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  requestId?: string(name='RequestId'),
  runningParameters?: {
    parameter?: [ 
    {
      checkingCode?: string(name='CheckingCode'),
      forceRestart?: string(name='ForceRestart'),
      modifiableStatus?: string(name='ModifiableStatus'),
      parameterDescription?: string(name='ParameterDescription'),
      parameterName?: string(name='ParameterName'),
      parameterValue?: string(name='ParameterValue'),
    }
  ](name='Parameter')
  }(name='RunningParameters'),
}

model DescribeParametersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeParametersResponseBody(name='body'),
}

async function describeParameters(request: DescribeParametersRequest): DescribeParametersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeParameters', 'POST', '/', 'json', false, 'json', request);
}

model DescribePriceRequest {
  businessInfo?: string(name='BusinessInfo', position='Query'),
  commodityCode?: string(name='CommodityCode', position='Query'),
  couponNo?: string(name='CouponNo', position='Query'),
  DBInstances: string(name='DBInstances', position='Query'),
  orderParamOut?: string(name='OrderParamOut', position='Query'),
  orderType: string(name='OrderType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  productCode?: string(name='ProductCode', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribePriceResponseBody = {
  order?: {
    coupons?: {
      coupon?: [ 
      {
        couponNo?: string(name='CouponNo'),
        description?: string(name='Description'),
        isSelected?: string(name='IsSelected'),
        name?: string(name='Name'),
      }
    ](name='Coupon')
    }(name='Coupons'),
    currency?: string(name='Currency'),
    discountAmount?: string(name='DiscountAmount'),
    originalAmount?: string(name='OriginalAmount'),
    ruleIds?: {
      ruleId?: [ string ](name='RuleId')
    }(name='RuleIds'),
    tradeAmount?: string(name='TradeAmount'),
  }(name='Order'),
  orderParams?: string(name='OrderParams'),
  requestId?: string(name='RequestId'),
  rules?: {
    rule?: [ 
    {
      name?: string(name='Name'),
      ruleDescId?: long(name='RuleDescId'),
      title?: string(name='Title'),
    }
  ](name='Rule')
  }(name='Rules'),
  subOrders?: {
    subOrder?: [ 
    {
      discountAmount?: string(name='DiscountAmount'),
      instanceId?: string(name='InstanceId'),
      originalAmount?: string(name='OriginalAmount'),
      ruleIds?: {
        ruleId?: [ string ](name='RuleId')
      }(name='RuleIds'),
      tradeAmount?: string(name='TradeAmount'),
    }
  ](name='SubOrder')
  }(name='SubOrders'),
  traceId?: string(name='TraceId'),
}

model DescribePriceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePriceResponseBody(name='body'),
}

async function describePrice(request: DescribePriceRequest): DescribePriceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePrice', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeRegionsResponseBody = {
  regions?: {
    ddsRegion?: [ 
    {
      regionId?: string(name='RegionId'),
      regionName?: string(name='RegionName'),
      zones?: {
        zone?: [ 
        {
          vpcEnabled?: boolean(name='VpcEnabled'),
          zoneId?: string(name='ZoneId'),
          zoneName?: string(name='ZoneName'),
        }
      ](name='Zone')
      }(name='Zones'),
    }
  ](name='DdsRegion')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRegions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRenewalPriceRequest {
  regionId?: string(name='RegionId', position='Host'),
  businessInfo?: string(name='BusinessInfo', position='Query'),
  couponNo?: string(name='CouponNo', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeRenewalPriceResponseBody = {
  order?: {
    coupons?: {
      coupon?: [ 
      {
        couponNo?: string(name='CouponNo'),
        description?: string(name='Description'),
        isSelected?: string(name='IsSelected'),
        name?: string(name='Name'),
      }
    ](name='Coupon')
    }(name='Coupons'),
    currency?: string(name='Currency'),
    discountAmount?: float(name='DiscountAmount'),
    originalAmount?: float(name='OriginalAmount'),
    ruleIds?: {
      ruleId?: [ string ](name='RuleId')
    }(name='RuleIds'),
    tradeAmount?: float(name='TradeAmount'),
  }(name='Order'),
  requestId?: string(name='RequestId'),
  rules?: {
    rule?: [ 
    {
      name?: string(name='Name'),
      ruleDescId?: long(name='RuleDescId'),
      title?: string(name='Title'),
    }
  ](name='Rule')
  }(name='Rules'),
  subOrders?: {
    subOrder?: [ 
    {
      discountAmount?: float(name='DiscountAmount'),
      instanceId?: string(name='InstanceId'),
      originalAmount?: float(name='OriginalAmount'),
      ruleIds?: {
        ruleId?: [ string ](name='RuleId')
      }(name='RuleIds'),
      tradeAmount?: float(name='TradeAmount'),
    }
  ](name='SubOrder')
  }(name='SubOrders'),
}

model DescribeRenewalPriceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRenewalPriceResponseBody(name='body'),
}

async function describeRenewalPrice(request: DescribeRenewalPriceRequest): DescribeRenewalPriceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRenewalPrice', 'POST', '/', 'json', false, 'json', request);
}

model DescribeReplicaSetRoleRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeReplicaSetRoleResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  replicaSets?: {
    replicaSet?: [ 
    {
      connectionDomain?: string(name='ConnectionDomain'),
      connectionPort?: string(name='ConnectionPort'),
      expiredTime?: string(name='ExpiredTime'),
      networkType?: string(name='NetworkType'),
      replicaSetRole?: string(name='ReplicaSetRole'),
      roleId?: string(name='RoleId'),
    }
  ](name='ReplicaSet')
  }(name='ReplicaSets'),
  requestId?: string(name='RequestId'),
}

model DescribeReplicaSetRoleResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeReplicaSetRoleResponseBody(name='body'),
}

async function describeReplicaSetRole(request: DescribeReplicaSetRoleRequest): DescribeReplicaSetRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeReplicaSetRole', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRoleZoneInfoRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeRoleZoneInfoResponseBody = {
  requestId?: string(name='RequestId'),
  zoneInfos?: {
    zoneInfo?: [ 
    {
      insName?: string(name='InsName'),
      nodeType?: string(name='NodeType'),
      roleId?: string(name='RoleId'),
      roleType?: string(name='RoleType'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='ZoneInfo')
  }(name='ZoneInfos'),
}

model DescribeRoleZoneInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRoleZoneInfoResponseBody(name='body'),
}

async function describeRoleZoneInfo(request: DescribeRoleZoneInfoRequest): DescribeRoleZoneInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRoleZoneInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRunningLogRecordsRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBName?: string(name='DBName', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  orderType?: string(name='OrderType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=30, maximum=100, position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  roleId?: string(name='RoleId', position='Query'),
  roleType?: string(name='RoleType', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeRunningLogRecordsResponseBody = {
  engine?: string(name='Engine'),
  items?: {
    logRecords?: [ 
    {
      category?: string(name='Category'),
      connInfo?: string(name='ConnInfo'),
      content?: string(name='Content'),
      createTime?: string(name='CreateTime'),
      id?: int32(name='Id'),
    }
  ](name='LogRecords')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeRunningLogRecordsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRunningLogRecordsResponseBody(name='body'),
}

async function describeRunningLogRecords(request: DescribeRunningLogRecordsRequest): DescribeRunningLogRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRunningLogRecords', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSecurityGroupConfigurationRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeSecurityGroupConfigurationResponseBody = {
  items?: {
    rdsEcsSecurityGroupRel?: [ 
    {
      netType?: string(name='NetType'),
      regionId?: string(name='RegionId'),
      securityGroupId?: string(name='SecurityGroupId'),
    }
  ](name='RdsEcsSecurityGroupRel')
  }(name='Items'),
  requestId?: string(name='RequestId'),
}

model DescribeSecurityGroupConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSecurityGroupConfigurationResponseBody(name='body'),
}

async function describeSecurityGroupConfiguration(request: DescribeSecurityGroupConfigurationRequest): DescribeSecurityGroupConfigurationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSecurityGroupConfiguration', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSecurityIpsRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeSecurityIpsResponseBody = {
  requestId?: string(name='RequestId'),
  securityIpGroups?: {
    securityIpGroup?: [ 
    {
      securityIpGroupAttribute?: string(name='SecurityIpGroupAttribute'),
      securityIpGroupName?: string(name='SecurityIpGroupName'),
      securityIpList?: string(name='SecurityIpList'),
    }
  ](name='SecurityIpGroup')
  }(name='SecurityIpGroups'),
  securityIps?: string(name='SecurityIps'),
}

model DescribeSecurityIpsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSecurityIpsResponseBody(name='body'),
}

async function describeSecurityIps(request: DescribeSecurityIpsRequest): DescribeSecurityIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSecurityIps', 'POST', '/', 'json', false, 'json', request);
}

model DescribeShardingNetworkAddressRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeShardingNetworkAddressResponseBody = {
  compatibleConnections?: {
    compatibleConnection?: [ 
    {
      expiredTime?: string(name='ExpiredTime'),
      IPAddress?: string(name='IPAddress'),
      networkAddress?: string(name='NetworkAddress'),
      networkType?: string(name='NetworkType'),
      port?: string(name='Port'),
      VPCId?: string(name='VPCId'),
      vswitchId?: string(name='VswitchId'),
    }
  ](name='CompatibleConnection')
  }(name='CompatibleConnections'),
  networkAddresses?: {
    networkAddress?: [ 
    {
      expiredTime?: string(name='ExpiredTime'),
      IPAddress?: string(name='IPAddress'),
      networkAddress?: string(name='NetworkAddress'),
      networkType?: string(name='NetworkType'),
      nodeId?: string(name='NodeId'),
      nodeType?: string(name='NodeType'),
      port?: string(name='Port'),
      role?: string(name='Role'),
      VPCId?: string(name='VPCId'),
      vswitchId?: string(name='VswitchId'),
    }
  ](name='NetworkAddress')
  }(name='NetworkAddresses'),
  requestId?: string(name='RequestId'),
}

model DescribeShardingNetworkAddressResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeShardingNetworkAddressResponseBody(name='body'),
}

async function describeShardingNetworkAddress(request: DescribeShardingNetworkAddressRequest): DescribeShardingNetworkAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeShardingNetworkAddress', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSlowLogRecordsRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBName?: string(name='DBName', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  orderType?: string(name='OrderType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=30, maximum=100, position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeSlowLogRecordsResponseBody = {
  engine?: string(name='Engine'),
  items?: {
    logRecords?: [ 
    {
      accountName?: string(name='AccountName'),
      DBName?: string(name='DBName'),
      docsExamined?: long(name='DocsExamined'),
      executionStartTime?: string(name='ExecutionStartTime'),
      hostAddress?: string(name='HostAddress'),
      keysExamined?: long(name='KeysExamined'),
      queryTimes?: string(name='QueryTimes'),
      returnRowCounts?: long(name='ReturnRowCounts'),
      SQLText?: string(name='SQLText'),
      tableName?: string(name='TableName'),
    }
  ](name='LogRecords')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeSlowLogRecordsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSlowLogRecordsResponseBody(name='body'),
}

async function describeSlowLogRecords(request: DescribeSlowLogRecordsRequest): DescribeSlowLogRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSlowLogRecords', 'POST', '/', 'json', false, 'json', request);
}

model DescribeTagsRequest {
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
}

model DescribeTagsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tags?: [ 
    {
      tagKey?: string(name='TagKey'),
      tagValues?: [ string ](name='TagValues'),
    }
  ](name='Tags'),
}

model DescribeTagsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTagsResponseBody(name='body'),
}

async function describeTags(request: DescribeTagsRequest): DescribeTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTags', 'POST', '/', 'json', false, 'json', request);
}

model DescribeUserEncryptionKeyListRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  targetRegionId?: string(name='TargetRegionId', position='Query'),
}

model DescribeUserEncryptionKeyListResponseBody = {
  keyIds?: {
    keyId?: [ string ](name='KeyId')
  }(name='KeyIds'),
  requestId?: string(name='RequestId'),
}

model DescribeUserEncryptionKeyListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUserEncryptionKeyListResponseBody(name='body'),
}

async function describeUserEncryptionKeyList(request: DescribeUserEncryptionKeyListRequest): DescribeUserEncryptionKeyListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUserEncryptionKeyList', 'POST', '/', 'json', false, 'json', request);
}

model DestroyInstanceRequest {
  regionId?: string(name='RegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId?: string(name='DBInstanceId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DestroyInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DestroyInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DestroyInstanceResponseBody(name='body'),
}

async function destroyInstance(request: DestroyInstanceRequest): DestroyInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DestroyInstance', 'POST', '/', 'json', false, 'json', request);
}

model EvaluateResourceRequest {
  DBInstanceClass?: string(name='DBInstanceClass', position='Query'),
  DBInstanceId?: string(name='DBInstanceId', position='Query'),
  engine?: string(name='Engine', position='Query'),
  engineVersion: string(name='EngineVersion', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  readonlyReplicas?: string(name='ReadonlyReplicas', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  replicationFactor?: string(name='ReplicationFactor', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  shardsInfo?: string(name='ShardsInfo', position='Query'),
  zoneId: string(name='ZoneId', position='Query'),
}

model EvaluateResourceResponseBody = {
  DBInstanceAvailable?: string(name='DBInstanceAvailable'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  requestId?: string(name='RequestId'),
}

model EvaluateResourceResponse = {
  headers: map[string]string(name='headers'),
  body: EvaluateResourceResponseBody(name='body'),
}

async function evaluateResource(request: EvaluateResourceRequest): EvaluateResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EvaluateResource', 'POST', '/', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId?: [ string ](name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', '/', 'json', false, 'json', request);
}

model MigrateAvailableZoneRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  effectiveTime?: string(name='EffectiveTime', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vswitch?: string(name='Vswitch', position='Query'),
  zoneId: string(name='ZoneId', position='Query'),
}

model MigrateAvailableZoneResponseBody = {
  requestId?: string(name='RequestId'),
}

model MigrateAvailableZoneResponse = {
  headers: map[string]string(name='headers'),
  body: MigrateAvailableZoneResponseBody(name='body'),
}

async function migrateAvailableZone(request: MigrateAvailableZoneRequest): MigrateAvailableZoneResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'MigrateAvailableZone', 'POST', '/', 'json', false, 'json', request);
}

model MigrateToOtherZoneRequest {
  effectiveTime?: string(name='EffectiveTime', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  zoneId: string(name='ZoneId', position='Query'),
}

model MigrateToOtherZoneResponseBody = {
  requestId?: string(name='RequestId'),
}

model MigrateToOtherZoneResponse = {
  headers: map[string]string(name='headers'),
  body: MigrateToOtherZoneResponseBody(name='body'),
}

async function migrateToOtherZone(request: MigrateToOtherZoneRequest): MigrateToOtherZoneResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'MigrateToOtherZone', 'POST', '/', 'json', false, 'json', request);
}

model ModifyAccountDescriptionRequest {
  regionId?: string(name='RegionId', position='Host'),
  accountDescription: string(name='AccountDescription', position='Query'),
  accountName: string(name='AccountName', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ModifyAccountDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyAccountDescriptionResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyAccountDescriptionResponseBody(name='body'),
}

async function modifyAccountDescription(request: ModifyAccountDescriptionRequest): ModifyAccountDescriptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyAccountDescription', 'POST', '/', 'json', false, 'json', request);
}

model ModifyAuditLogFilterRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  filter: string(name='Filter', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  roleType?: string(name='RoleType', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ModifyAuditLogFilterResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyAuditLogFilterResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyAuditLogFilterResponseBody(name='body'),
}

async function modifyAuditLogFilter(request: ModifyAuditLogFilterRequest): ModifyAuditLogFilterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyAuditLogFilter', 'POST', '/', 'json', false, 'json', request);
}

model ModifyAuditPolicyRequest {
  regionId?: string(name='RegionId', position='Host'),
  auditLogSwitchSource?: string(name='AuditLogSwitchSource', position='Query'),
  auditStatus: string(name='AuditStatus', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  serviceType?: string(name='ServiceType', position='Query'),
  storagePeriod?: int32(name='StoragePeriod', minimum=1, maximum=365, position='Query'),
}

model ModifyAuditPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyAuditPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyAuditPolicyResponseBody(name='body'),
}

async function modifyAuditPolicy(request: ModifyAuditPolicyRequest): ModifyAuditPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyAuditPolicy', 'POST', '/', 'json', false, 'json', request);
}

model ModifyBackupPolicyRequest {
  regionId?: string(name='RegionId', position='Host'),
  backupInterval?: string(name='BackupInterval', position='Query'),
  backupRetentionPeriod?: long(name='BackupRetentionPeriod', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  enableBackupLog?: long(name='EnableBackupLog', position='Query'),
  logBackupRetentionPeriod?: long(name='LogBackupRetentionPeriod', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  preferredBackupPeriod: string(name='PreferredBackupPeriod', position='Query'),
  preferredBackupTime: string(name='PreferredBackupTime', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  snapshotBackupType?: string(name='SnapshotBackupType', position='Query'),
}

model ModifyBackupPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyBackupPolicyResponseBody(name='body'),
}

async function modifyBackupPolicy(request: ModifyBackupPolicyRequest): ModifyBackupPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyBackupPolicy', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceConnectionStringRequest {
  regionId?: string(name='RegionId', position='Host'),
  currentConnectionString: string(name='CurrentConnectionString', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  newConnectionString: string(name='NewConnectionString', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ModifyDBInstanceConnectionStringResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceConnectionStringResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceConnectionStringResponseBody(name='body'),
}

async function modifyDBInstanceConnectionString(request: ModifyDBInstanceConnectionStringRequest): ModifyDBInstanceConnectionStringResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceConnectionString', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceDescriptionRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceDescription: string(name='DBInstanceDescription', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ModifyDBInstanceDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceDescriptionResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceDescriptionResponseBody(name='body'),
}

async function modifyDBInstanceDescription(request: ModifyDBInstanceDescriptionRequest): ModifyDBInstanceDescriptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceDescription', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceMaintainTimeRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  maintainEndTime: string(name='MaintainEndTime', position='Query'),
  maintainStartTime: string(name='MaintainStartTime', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ModifyDBInstanceMaintainTimeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceMaintainTimeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceMaintainTimeResponseBody(name='body'),
}

async function modifyDBInstanceMaintainTime(request: ModifyDBInstanceMaintainTimeRequest): ModifyDBInstanceMaintainTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceMaintainTime', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceMonitorRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  granularity: string(name='Granularity', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ModifyDBInstanceMonitorResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceMonitorResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceMonitorResponseBody(name='body'),
}

async function modifyDBInstanceMonitor(request: ModifyDBInstanceMonitorRequest): ModifyDBInstanceMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceMonitor', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceNetExpireTimeRequest {
  regionId?: string(name='RegionId', position='Host'),
  classicExpendExpiredDays: int32(name='ClassicExpendExpiredDays', position='Query'),
  connectionString?: string(name='ConnectionString', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ModifyDBInstanceNetExpireTimeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceNetExpireTimeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceNetExpireTimeResponseBody(name='body'),
}

async function modifyDBInstanceNetExpireTime(request: ModifyDBInstanceNetExpireTimeRequest): ModifyDBInstanceNetExpireTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceNetExpireTime', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceNetworkTypeRequest {
  regionId?: string(name='RegionId', position='Host'),
  classicExpiredDays?: int32(name='ClassicExpiredDays', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  networkType: string(name='NetworkType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  retainClassic?: string(name='RetainClassic', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model ModifyDBInstanceNetworkTypeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceNetworkTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceNetworkTypeResponseBody(name='body'),
}

async function modifyDBInstanceNetworkType(request: ModifyDBInstanceNetworkTypeRequest): ModifyDBInstanceNetworkTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceNetworkType', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceSSLRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  SSLAction: string(name='SSLAction', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ModifyDBInstanceSSLResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceSSLResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceSSLResponseBody(name='body'),
}

async function modifyDBInstanceSSL(request: ModifyDBInstanceSSLRequest): ModifyDBInstanceSSLResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceSSL', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceSpecRequest {
  regionId?: string(name='RegionId', position='Host'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  businessInfo?: string(name='BusinessInfo', position='Query'),
  couponNo?: string(name='CouponNo', position='Query'),
  DBInstanceClass?: string(name='DBInstanceClass', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBInstanceStorage?: string(name='DBInstanceStorage', position='Query'),
  effectiveTime?: string(name='EffectiveTime', position='Query'),
  orderType?: string(name='OrderType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  readonlyReplicas?: string(name='ReadonlyReplicas', position='Query'),
  replicationFactor?: string(name='ReplicationFactor', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ModifyDBInstanceSpecResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceSpecResponseBody(name='body'),
}

async function modifyDBInstanceSpec(request: ModifyDBInstanceSpecRequest): ModifyDBInstanceSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceSpec', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceTDERequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  encryptionKey?: string(name='EncryptionKey', position='Query'),
  encryptorName?: string(name='EncryptorName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  roleARN?: string(name='RoleARN', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  TDEStatus: string(name='TDEStatus', position='Query'),
}

model ModifyDBInstanceTDEResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceTDEResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceTDEResponseBody(name='body'),
}

async function modifyDBInstanceTDE(request: ModifyDBInstanceTDERequest): ModifyDBInstanceTDEResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceTDE', 'POST', '/', 'json', false, 'json', request);
}

model ModifyInstanceAutoRenewalAttributeRequest {
  autoRenew: string(name='AutoRenew', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  duration?: string(name='Duration', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ModifyInstanceAutoRenewalAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceAutoRenewalAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceAutoRenewalAttributeResponseBody(name='body'),
}

async function modifyInstanceAutoRenewalAttribute(request: ModifyInstanceAutoRenewalAttributeRequest): ModifyInstanceAutoRenewalAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceAutoRenewalAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyInstanceVpcAuthModeRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  vpcAuthMode?: string(name='VpcAuthMode', position='Query'),
}

model ModifyInstanceVpcAuthModeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceVpcAuthModeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceVpcAuthModeResponseBody(name='body'),
}

async function modifyInstanceVpcAuthMode(request: ModifyInstanceVpcAuthModeRequest): ModifyInstanceVpcAuthModeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceVpcAuthMode', 'POST', '/', 'json', false, 'json', request);
}

model ModifyNodeSpecRequest {
  regionId?: string(name='RegionId', position='Host'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  businessInfo?: string(name='BusinessInfo', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  couponNo?: string(name='CouponNo', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  effectiveTime?: string(name='EffectiveTime', position='Query'),
  fromApp?: string(name='FromApp', position='Query'),
  nodeClass?: string(name='NodeClass', position='Query'),
  nodeId: string(name='NodeId', position='Query'),
  nodeStorage?: int32(name='NodeStorage', position='Query'),
  orderType?: string(name='OrderType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  readonlyReplicas?: int32(name='ReadonlyReplicas', minimum=0, maximum=5, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  switchTime?: string(name='SwitchTime', position='Query'),
}

model ModifyNodeSpecResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyNodeSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNodeSpecResponseBody(name='body'),
}

async function modifyNodeSpec(request: ModifyNodeSpecRequest): ModifyNodeSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyNodeSpec', 'POST', '/', 'json', false, 'json', request);
}

model ModifyNodeSpecBatchRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  businessInfo?: string(name='BusinessInfo', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  couponNo?: string(name='CouponNo', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  effectiveTime?: string(name='EffectiveTime', position='Query'),
  nodesInfo: string(name='NodesInfo', position='Query'),
  orderType?: string(name='OrderType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ModifyNodeSpecBatchResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyNodeSpecBatchResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNodeSpecBatchResponseBody(name='body'),
}

async function modifyNodeSpecBatch(request: ModifyNodeSpecBatchRequest): ModifyNodeSpecBatchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyNodeSpecBatch', 'POST', '/', 'json', false, 'json', request);
}

model ModifyParametersRequest {
  characterType?: string(name='CharacterType', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  parameters: string(name='Parameters', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ModifyParametersResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyParametersResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyParametersResponseBody(name='body'),
}

async function modifyParameters(request: ModifyParametersRequest): ModifyParametersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyParameters', 'POST', '/', 'json', false, 'json', request);
}

model ModifyResourceGroupRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ModifyResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyResourceGroupResponseBody(name='body'),
}

async function modifyResourceGroup(request: ModifyResourceGroupRequest): ModifyResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyResourceGroup', 'POST', '/', 'json', false, 'json', request);
}

model ModifySecurityGroupConfigurationRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId: string(name='SecurityGroupId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ModifySecurityGroupConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySecurityGroupConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySecurityGroupConfigurationResponseBody(name='body'),
}

async function modifySecurityGroupConfiguration(request: ModifySecurityGroupConfigurationRequest): ModifySecurityGroupConfigurationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySecurityGroupConfiguration', 'POST', '/', 'json', false, 'json', request);
}

model ModifySecurityIpsRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  modifyMode?: string(name='ModifyMode', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityIpGroupAttribute?: string(name='SecurityIpGroupAttribute', position='Query'),
  securityIpGroupName?: string(name='SecurityIpGroupName', position='Query'),
  securityIps: string(name='SecurityIps', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ModifySecurityIpsResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySecurityIpsResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySecurityIpsResponseBody(name='body'),
}

async function modifySecurityIps(request: ModifySecurityIpsRequest): ModifySecurityIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySecurityIps', 'POST', '/', 'json', false, 'json', request);
}

model ReleaseNodePrivateNetworkAddressRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  networkType?: string(name='NetworkType', position='Query'),
  nodeId: string(name='NodeId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ReleaseNodePrivateNetworkAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseNodePrivateNetworkAddressResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseNodePrivateNetworkAddressResponseBody(name='body'),
}

async function releaseNodePrivateNetworkAddress(request: ReleaseNodePrivateNetworkAddressRequest): ReleaseNodePrivateNetworkAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleaseNodePrivateNetworkAddress', 'POST', '/', 'json', false, 'json', request);
}

model ReleasePublicNetworkAddressRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ReleasePublicNetworkAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleasePublicNetworkAddressResponse = {
  headers: map[string]string(name='headers'),
  body: ReleasePublicNetworkAddressResponseBody(name='body'),
}

async function releasePublicNetworkAddress(request: ReleasePublicNetworkAddressRequest): ReleasePublicNetworkAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleasePublicNetworkAddress', 'POST', '/', 'json', false, 'json', request);
}

model RenewDBInstanceRequest {
  regionId?: string(name='RegionId', position='Host'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  businessInfo?: string(name='BusinessInfo', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  couponNo?: string(name='CouponNo', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period: int32(name='Period', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model RenewDBInstanceResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model RenewDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RenewDBInstanceResponseBody(name='body'),
}

async function renewDBInstance(request: RenewDBInstanceRequest): RenewDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RenewDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model ResetAccountPasswordRequest {
  regionId?: string(name='RegionId', position='Host'),
  accountName: string(name='AccountName', position='Query'),
  accountPassword: string(name='AccountPassword', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ResetAccountPasswordResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetAccountPasswordResponse = {
  headers: map[string]string(name='headers'),
  body: ResetAccountPasswordResponseBody(name='body'),
}

async function resetAccountPassword(request: ResetAccountPasswordRequest): ResetAccountPasswordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetAccountPassword', 'POST', '/', 'json', false, 'json', request);
}

model RestartDBInstanceRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model RestartDBInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model RestartDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RestartDBInstanceResponseBody(name='body'),
}

async function restartDBInstance(request: RestartDBInstanceRequest): RestartDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RestartDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model RestoreDBInstanceRequest {
  regionId?: string(name='RegionId', position='Host'),
  backupId: int32(name='BackupId', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model RestoreDBInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model RestoreDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RestoreDBInstanceResponseBody(name='body'),
}

async function restoreDBInstance(request: RestoreDBInstanceRequest): RestoreDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RestoreDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model SwitchDBInstanceHARequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  roleIds?: string(name='RoleIds', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  switchMode?: int32(name='SwitchMode', minimum=0, maximum=1, position='Query'),
}

model SwitchDBInstanceHAResponseBody = {
  requestId?: string(name='RequestId'),
}

model SwitchDBInstanceHAResponse = {
  headers: map[string]string(name='headers'),
  body: SwitchDBInstanceHAResponseBody(name='body'),
}

async function switchDBInstanceHA(request: SwitchDBInstanceHARequest): SwitchDBInstanceHAResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SwitchDBInstanceHA', 'POST', '/', 'json', false, 'json', request);
}

model TagResourcesRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag: [ 
    {
      key: string(name='Key'),
      value: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagResources', 'POST', '/', 'json', false, 'json', request);
}

model TransformToPrePaidRequest {
  regionId?: string(name='RegionId', position='Host'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  autoRenew?: string(name='AutoRenew', position='Query'),
  businessInfo?: string(name='BusinessInfo', position='Query'),
  couponNo?: string(name='CouponNo', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period: long(name='Period', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model TransformToPrePaidResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model TransformToPrePaidResponse = {
  headers: map[string]string(name='headers'),
  body: TransformToPrePaidResponseBody(name='body'),
}

async function transformToPrePaid(request: TransformToPrePaidRequest): TransformToPrePaidResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TransformToPrePaid', 'POST', '/', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  all?: boolean(name='All', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tagKey?: [ string ](name='TagKey', position='Query'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UntagResources', 'POST', '/', 'json', false, 'json', request);
}

model UpgradeDBInstanceEngineVersionRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  engineVersion: string(name='EngineVersion', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model UpgradeDBInstanceEngineVersionResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpgradeDBInstanceEngineVersionResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeDBInstanceEngineVersionResponseBody(name='body'),
}

async function upgradeDBInstanceEngineVersion(request: UpgradeDBInstanceEngineVersionRequest): UpgradeDBInstanceEngineVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpgradeDBInstanceEngineVersion', 'POST', '/', 'json', false, 'json', request);
}

model UpgradeDBInstanceKernelVersionRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model UpgradeDBInstanceKernelVersionResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpgradeDBInstanceKernelVersionResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeDBInstanceKernelVersionResponseBody(name='body'),
}

async function upgradeDBInstanceKernelVersion(request: UpgradeDBInstanceKernelVersionRequest): UpgradeDBInstanceKernelVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpgradeDBInstanceKernelVersion', 'POST', '/', 'json', false, 'json', request);
}

