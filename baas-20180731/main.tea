/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @signatureAlgorithm = 'v2';
  @endpointRule = 'regional';
  @endpointMap = {
    cn-qingdao = 'baas.aliyuncs.com',
    cn-beijing = 'baas.aliyuncs.com',
    cn-zhangjiakou = 'baas.aliyuncs.com',
    cn-huhehaote = 'baas.aliyuncs.com',
    cn-shanghai = 'baas.aliyuncs.com',
    cn-shenzhen = 'baas.aliyuncs.com',
    cn-hongkong = 'baas.ap-southeast-1.aliyuncs.com',
    ap-southeast-2 = 'baas.ap-southeast-1.aliyuncs.com',
    ap-northeast-1 = 'baas.ap-southeast-1.aliyuncs.com',
    eu-west-1 = 'baas.ap-southeast-1.aliyuncs.com',
    us-west-1 = 'baas.ap-southeast-1.aliyuncs.com',
    us-east-1 = 'baas.ap-southeast-1.aliyuncs.com',
    eu-central-1 = 'baas.ap-southeast-1.aliyuncs.com',
    ap-south-1 = 'baas.ap-southeast-1.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('baas', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AntChainPurposeResponse {
  chainPurposeExtend?: string(name='ChainPurposeExtend'),
  chainPurposeItem?: string(name='ChainPurposeItem'),
  createTime?: string(name='CreateTime'),
  purpose?: string(name='Purpose'),
  recordList?: [
    ChainPurpose
  ](name='RecordList'),
  status?: string(name='Status'),
}

model AntChainPurposeResponseAli {
  recordList?: [
    ChainPurposeInfoAli
  ](name='RecordList'),
  status?: string(name='Status'),
}

model ChainPurpose {
  extend?: boolean(name='Extend'),
  id?: string(name='Id'),
  item?: boolean(name='Item'),
  key?: string(name='Key'),
  name?: string(name='Name'),
  purposeItem?: string(name='PurposeItem'),
  status?: string(name='Status'),
  time?: string(name='Time'),
}

model ChainPurposeInfoAli {
  chainPurposeExtend?: string(name='ChainPurposeExtend'),
  chainPurposeItem?: string(name='ChainPurposeItem'),
  id?: string(name='Id'),
  key?: string(name='Key'),
  purpose?: string(name='Purpose'),
  status?: string(name='Status'),
  time?: string(name='Time'),
}

model ChainPurposeListAli {
  extend?: boolean(name='Extend', example='false'),
  id?: string(name='Id', example='10001'),
  item?: boolean(name='Item', example='false'),
  key?: string(name='Key', example='FIN'),
  purpose?: string(name='Purpose', example='金融'),
}

model CheckPointStructBody {
  errorCount?: string(name='ErrorCount'),
  height?: string(name='Height'),
  index?: string(name='Index'),
  lastError?: string(name='LastError'),
  totalCount?: string(name='TotalCount'),
  type?: string(name='Type'),
}

model CommonResponsePageableStructBody {
  current?: string(name='Current'),
  list?: [
    TriggerLogDTOStructBody
  ](name='List'),
  pageSize?: string(name='PageSize'),
  total?: string(name='Total'),
}

model PositionStructBody {
  errorCount?: string(name='ErrorCount'),
  height?: string(name='Height'),
  index?: string(name='Index'),
  lastError?: string(name='LastError'),
  type?: string(name='Type'),
}

model TriggerDTOStructBody {
  checkpoint?: CheckPointStructBody(name='Checkpoint'),
  createTime?: string(name='CreateTime'),
  errorMessage?: string(name='ErrorMessage'),
  name?: string(name='Name'),
  option?: string(name='Option'),
  pendingErrorLogs?: string(name='PendingErrorLogs'),
  source?: string(name='Source'),
  status?: string(name='Status'),
  type?: string(name='Type'),
}

model TriggerLogDTOStructBody {
  createTime?: string(name='CreateTime'),
  modifyTime?: string(name='ModifyTime'),
  position?: PositionStructBody(name='Position'),
  status?: string(name='Status'),
  uuid?: string(name='Uuid'),
}

model AcceptEthereumInvitationRequest {
  code?: string(name='Code', description='This parameter is required.'),
  token?: string(name='Token', description='This parameter is required.'),
}

model AcceptEthereumInvitationResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model AcceptEthereumInvitationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AcceptEthereumInvitationResponseBody(name='body'),
}

/**
 * @param request AcceptEthereumInvitationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AcceptEthereumInvitationResponse
 */
async function acceptEthereumInvitationWithOptions(request: AcceptEthereumInvitationRequest, runtime: Util.RuntimeOptions): AcceptEthereumInvitationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.code)) {
    body['Code'] = request.code;
  }
  if (!Util.isUnset(request.token)) {
    body['Token'] = request.token;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AcceptEthereumInvitation',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AcceptEthereumInvitationRequest
 * @return AcceptEthereumInvitationResponse
 */
async function acceptEthereumInvitation(request: AcceptEthereumInvitationRequest): AcceptEthereumInvitationResponse {
  var runtime = new Util.RuntimeOptions{};
  return acceptEthereumInvitationWithOptions(request, runtime);
}

model AcceptInvitationRequest {
  code?: string(name='Code', description='This parameter is required.', example='bank'),
  isAccepted?: boolean(name='IsAccepted', example='true'),
}

model AcceptInvitationResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='3240E00A-F7B6-4B27-B8B9-E3F459071376'),
  success?: boolean(name='Success', example='true'),
}

model AcceptInvitationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AcceptInvitationResponseBody(name='body'),
}

/**
 * @param request AcceptInvitationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AcceptInvitationResponse
 */
async function acceptInvitationWithOptions(request: AcceptInvitationRequest, runtime: Util.RuntimeOptions): AcceptInvitationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.code)) {
    body['Code'] = request.code;
  }
  if (!Util.isUnset(request.isAccepted)) {
    body['IsAccepted'] = request.isAccepted;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AcceptInvitation',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AcceptInvitationRequest
 * @return AcceptInvitationResponse
 */
async function acceptInvitation(request: AcceptInvitationRequest): AcceptInvitationResponse {
  var runtime = new Util.RuntimeOptions{};
  return acceptInvitationWithOptions(request, runtime);
}

model AddAntChainSubnetMemberCheckRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.'),
}

model AddAntChainSubnetMemberCheckResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: {
    consortiumMemberInfoList?: [ 
      {
        memberId?: string(name='MemberId'),
        memberName?: string(name='MemberName'),
      }
    ](name='ConsortiumMemberInfoList'),
  }(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model AddAntChainSubnetMemberCheckResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddAntChainSubnetMemberCheckResponseBody(name='body'),
}

/**
 * @param request AddAntChainSubnetMemberCheckRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddAntChainSubnetMemberCheckResponse
 */
async function addAntChainSubnetMemberCheckWithOptions(request: AddAntChainSubnetMemberCheckRequest, runtime: Util.RuntimeOptions): AddAntChainSubnetMemberCheckResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddAntChainSubnetMemberCheck',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddAntChainSubnetMemberCheckRequest
 * @return AddAntChainSubnetMemberCheckResponse
 */
async function addAntChainSubnetMemberCheck(request: AddAntChainSubnetMemberCheckRequest): AddAntChainSubnetMemberCheckResponse {
  var runtime = new Util.RuntimeOptions{};
  return addAntChainSubnetMemberCheckWithOptions(request, runtime);
}

model AddAntChainSubnetNodeCheckRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.'),
}

model AddAntChainSubnetNodeCheckResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      nodeId?: string(name='NodeId'),
      nodeName?: string(name='NodeName'),
    }
  ](name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model AddAntChainSubnetNodeCheckResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddAntChainSubnetNodeCheckResponseBody(name='body'),
}

/**
 * @param request AddAntChainSubnetNodeCheckRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddAntChainSubnetNodeCheckResponse
 */
async function addAntChainSubnetNodeCheckWithOptions(request: AddAntChainSubnetNodeCheckRequest, runtime: Util.RuntimeOptions): AddAntChainSubnetNodeCheckResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddAntChainSubnetNodeCheck',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddAntChainSubnetNodeCheckRequest
 * @return AddAntChainSubnetNodeCheckResponse
 */
async function addAntChainSubnetNodeCheck(request: AddAntChainSubnetNodeCheckRequest): AddAntChainSubnetNodeCheckResponse {
  var runtime = new Util.RuntimeOptions{};
  return addAntChainSubnetNodeCheckWithOptions(request, runtime);
}

model AddEthereumNodeRequest {
  description?: string(name='Description'),
  ethereumId?: string(name='EthereumId', description='This parameter is required.'),
  externalNode?: boolean(name='ExternalNode'),
  nodeName?: string(name='NodeName'),
}

model AddEthereumNodeResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    createTime?: long(name='CreateTime'),
    creator?: string(name='Creator'),
    description?: string(name='Description'),
    ethereumId?: string(name='EthereumId'),
    ethereumName?: string(name='EthereumName'),
    id?: string(name='Id'),
    networkId?: string(name='NetworkId'),
    nodeName?: string(name='NodeName'),
    publicIp?: string(name='PublicIp'),
    regionId?: string(name='RegionId'),
    rpcPort?: int32(name='RpcPort'),
    state?: string(name='State'),
    wsPort?: int32(name='WsPort'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model AddEthereumNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddEthereumNodeResponseBody(name='body'),
}

/**
 * @param request AddEthereumNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddEthereumNodeResponse
 */
async function addEthereumNodeWithOptions(request: AddEthereumNodeRequest, runtime: Util.RuntimeOptions): AddEthereumNodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.ethereumId)) {
    body['EthereumId'] = request.ethereumId;
  }
  if (!Util.isUnset(request.externalNode)) {
    body['ExternalNode'] = request.externalNode;
  }
  if (!Util.isUnset(request.nodeName)) {
    body['NodeName'] = request.nodeName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddEthereumNode',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddEthereumNodeRequest
 * @return AddEthereumNodeResponse
 */
async function addEthereumNode(request: AddEthereumNodeRequest): AddEthereumNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return addEthereumNodeWithOptions(request, runtime);
}

model AddFabricExternalOrganizationToChannelRequest {
  channelId?: string(name='ChannelId', description='This parameter is required.'),
  description?: string(name='Description'),
  joinRequest?: string(name='JoinRequest', description='This parameter is required.'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model AddFabricExternalOrganizationToChannelResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    content?: {
      addedOrganizations?: [ 
        {
          anchorPeers?: [ 
            {
              host?: string(name='Host'),
              port?: int32(name='Port'),
            }
          ](name='AnchorPeers'),
          crls?: string(name='Crls'),
          mspId?: string(name='MspId'),
          mspType?: string(name='MspType'),
          orderer?: boolean(name='Orderer'),
          ordererNodes?: [ 
            {
              address?: string(name='Address'),
              certificate?: string(name='Certificate'),
              key?: string(name='Key'),
              tlsroot?: string(name='Tlsroot'),
            }
          ](name='OrdererNodes'),
          rootCertificates?: string(name='RootCertificates'),
          tlsRootCertificates?: string(name='TlsRootCertificates'),
        }
      ](name='AddedOrganizations'),
      chaincodeSpecPkg?: {
        cs?: {
          input?: string(name='Input'),
          name?: string(name='Name'),
          path?: string(name='Path'),
          type?: int32(name='Type'),
          version?: string(name='Version'),
        }(name='Cs'),
        policy?: string(name='Policy'),
        sha256?: string(name='Sha256'),
      }(name='ChaincodeSpecPkg'),
      ordererConfig?: {
        batchTimeout?: string(name='BatchTimeout'),
        maxMessageCount?: int32(name='MaxMessageCount'),
        preferredMaxBytes?: int32(name='PreferredMaxBytes'),
      }(name='OrdererConfig'),
      raw?: string(name='Raw'),
      removedOrganizations?: [ 
        {
          anchorPeers?: [ 
            {
              host?: string(name='Host'),
              port?: int32(name='Port'),
            }
          ](name='AnchorPeers'),
          crls?: string(name='Crls'),
          mspId?: string(name='MspId'),
          mspType?: string(name='MspType'),
          orderer?: boolean(name='Orderer'),
          ordererNodes?: [ 
            {
              address?: string(name='Address'),
              certificate?: string(name='Certificate'),
              key?: string(name='Key'),
              tlsroot?: string(name='Tlsroot'),
            }
          ](name='OrdererNodes'),
          rootCertificates?: string(name='RootCertificates'),
          tlsRootCertificates?: string(name='TlsRootCertificates'),
        }
      ](name='RemovedOrganizations'),
      rwSets?: string(name='RwSets'),
    }(name='Content'),
    createTime?: long(name='CreateTime'),
    creator?: string(name='Creator'),
    description?: string(name='Description'),
    status?: string(name='Status'),
    taskId?: string(name='TaskId'),
    type?: string(name='Type'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model AddFabricExternalOrganizationToChannelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddFabricExternalOrganizationToChannelResponseBody(name='body'),
}

/**
 * @param request AddFabricExternalOrganizationToChannelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddFabricExternalOrganizationToChannelResponse
 */
async function addFabricExternalOrganizationToChannelWithOptions(request: AddFabricExternalOrganizationToChannelRequest, runtime: Util.RuntimeOptions): AddFabricExternalOrganizationToChannelResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.joinRequest)) {
    body['JoinRequest'] = request.joinRequest;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddFabricExternalOrganizationToChannel',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddFabricExternalOrganizationToChannelRequest
 * @return AddFabricExternalOrganizationToChannelResponse
 */
async function addFabricExternalOrganizationToChannel(request: AddFabricExternalOrganizationToChannelRequest): AddFabricExternalOrganizationToChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return addFabricExternalOrganizationToChannelWithOptions(request, runtime);
}

model AddFabricOrganizationToExternalChannelRequest {
  joinResponse?: string(name='JoinResponse', description='This parameter is required.'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model AddFabricOrganizationToExternalChannelResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      m?: int32(name='M'),
      n?: int32(name='N'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model AddFabricOrganizationToExternalChannelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddFabricOrganizationToExternalChannelResponseBody(name='body'),
}

/**
 * @param request AddFabricOrganizationToExternalChannelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddFabricOrganizationToExternalChannelResponse
 */
async function addFabricOrganizationToExternalChannelWithOptions(request: AddFabricOrganizationToExternalChannelRequest, runtime: Util.RuntimeOptions): AddFabricOrganizationToExternalChannelResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.joinResponse)) {
    body['JoinResponse'] = request.joinResponse;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddFabricOrganizationToExternalChannel',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddFabricOrganizationToExternalChannelRequest
 * @return AddFabricOrganizationToExternalChannelResponse
 */
async function addFabricOrganizationToExternalChannel(request: AddFabricOrganizationToExternalChannelRequest): AddFabricOrganizationToExternalChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return addFabricOrganizationToExternalChannelWithOptions(request, runtime);
}

model ApplyAntChainRequest {
  bizid?: string(name='Bizid'),
  consortiumId?: string(name='ConsortiumId'),
  uploadReq?: string(name='UploadReq'),
}

model ApplyAntChainResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model ApplyAntChainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ApplyAntChainResponseBody(name='body'),
}

/**
 * @param request ApplyAntChainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ApplyAntChainResponse
 */
async function applyAntChainWithOptions(request: ApplyAntChainRequest, runtime: Util.RuntimeOptions): ApplyAntChainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.uploadReq)) {
    body['UploadReq'] = request.uploadReq;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ApplyAntChain',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ApplyAntChainRequest
 * @return ApplyAntChainResponse
 */
async function applyAntChain(request: ApplyAntChainRequest): ApplyAntChainResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyAntChainWithOptions(request, runtime);
}

model ApplyAntChainCertificateRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  uploadReq?: string(name='UploadReq', description='This parameter is required.'),
}

model ApplyAntChainCertificateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model ApplyAntChainCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ApplyAntChainCertificateResponseBody(name='body'),
}

/**
 * @param request ApplyAntChainCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ApplyAntChainCertificateResponse
 */
async function applyAntChainCertificateWithOptions(request: ApplyAntChainCertificateRequest, runtime: Util.RuntimeOptions): ApplyAntChainCertificateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.uploadReq)) {
    body['UploadReq'] = request.uploadReq;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ApplyAntChainCertificate',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ApplyAntChainCertificateRequest
 * @return ApplyAntChainCertificateResponse
 */
async function applyAntChainCertificate(request: ApplyAntChainCertificateRequest): ApplyAntChainCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyAntChainCertificateWithOptions(request, runtime);
}

model ApplyAntChainCertificateWithKeyAutoCreationRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  commonName?: string(name='CommonName', description='This parameter is required.'),
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.'),
  countryName?: string(name='CountryName', description='This parameter is required.'),
  localityName?: string(name='LocalityName', description='This parameter is required.'),
  organizationName?: string(name='OrganizationName', description='This parameter is required.'),
  organizationUnitName?: string(name='OrganizationUnitName', description='This parameter is required.'),
  password?: string(name='Password', description='This parameter is required.'),
  stateOrProvinceName?: string(name='StateOrProvinceName', description='This parameter is required.'),
}

model ApplyAntChainCertificateWithKeyAutoCreationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    downloadPath?: {
      caCrtUrl?: string(name='CaCrtUrl'),
      clientCrtUrl?: string(name='ClientCrtUrl'),
      sdkUrl?: string(name='SdkUrl'),
      trustCaUrl?: string(name='TrustCaUrl'),
    }(name='DownloadPath'),
    privateKey?: string(name='PrivateKey'),
  }(name='Result'),
}

model ApplyAntChainCertificateWithKeyAutoCreationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ApplyAntChainCertificateWithKeyAutoCreationResponseBody(name='body'),
}

/**
 * @param request ApplyAntChainCertificateWithKeyAutoCreationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ApplyAntChainCertificateWithKeyAutoCreationResponse
 */
async function applyAntChainCertificateWithKeyAutoCreationWithOptions(request: ApplyAntChainCertificateWithKeyAutoCreationRequest, runtime: Util.RuntimeOptions): ApplyAntChainCertificateWithKeyAutoCreationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.commonName)) {
    body['CommonName'] = request.commonName;
  }
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.countryName)) {
    body['CountryName'] = request.countryName;
  }
  if (!Util.isUnset(request.localityName)) {
    body['LocalityName'] = request.localityName;
  }
  if (!Util.isUnset(request.organizationName)) {
    body['OrganizationName'] = request.organizationName;
  }
  if (!Util.isUnset(request.organizationUnitName)) {
    body['OrganizationUnitName'] = request.organizationUnitName;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.stateOrProvinceName)) {
    body['StateOrProvinceName'] = request.stateOrProvinceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ApplyAntChainCertificateWithKeyAutoCreation',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ApplyAntChainCertificateWithKeyAutoCreationRequest
 * @return ApplyAntChainCertificateWithKeyAutoCreationResponse
 */
async function applyAntChainCertificateWithKeyAutoCreation(request: ApplyAntChainCertificateWithKeyAutoCreationRequest): ApplyAntChainCertificateWithKeyAutoCreationResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyAntChainCertificateWithKeyAutoCreationWithOptions(request, runtime);
}

model ApplyAntChainWithKeyAutoCreationRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  commonName?: string(name='CommonName', description='This parameter is required.'),
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.'),
  countryName?: string(name='CountryName', description='This parameter is required.'),
  localityName?: string(name='LocalityName', description='This parameter is required.'),
  organizationName?: string(name='OrganizationName', description='This parameter is required.'),
  organizationUnitName?: string(name='OrganizationUnitName', description='This parameter is required.'),
  password?: string(name='Password', description='This parameter is required.'),
  stateOrProvinceName?: string(name='StateOrProvinceName', description='This parameter is required.'),
}

model ApplyAntChainWithKeyAutoCreationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    downloadPath?: {
      caCrtUrl?: string(name='CaCrtUrl'),
      clientCrtUrl?: string(name='ClientCrtUrl'),
      sdkUrl?: string(name='SdkUrl'),
      trustCaUrl?: string(name='TrustCaUrl'),
    }(name='DownloadPath'),
    privateKey?: string(name='PrivateKey'),
  }(name='Result'),
}

model ApplyAntChainWithKeyAutoCreationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ApplyAntChainWithKeyAutoCreationResponseBody(name='body'),
}

/**
 * @param request ApplyAntChainWithKeyAutoCreationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ApplyAntChainWithKeyAutoCreationResponse
 */
async function applyAntChainWithKeyAutoCreationWithOptions(request: ApplyAntChainWithKeyAutoCreationRequest, runtime: Util.RuntimeOptions): ApplyAntChainWithKeyAutoCreationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.commonName)) {
    body['CommonName'] = request.commonName;
  }
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.countryName)) {
    body['CountryName'] = request.countryName;
  }
  if (!Util.isUnset(request.localityName)) {
    body['LocalityName'] = request.localityName;
  }
  if (!Util.isUnset(request.organizationName)) {
    body['OrganizationName'] = request.organizationName;
  }
  if (!Util.isUnset(request.organizationUnitName)) {
    body['OrganizationUnitName'] = request.organizationUnitName;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.stateOrProvinceName)) {
    body['StateOrProvinceName'] = request.stateOrProvinceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ApplyAntChainWithKeyAutoCreation',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ApplyAntChainWithKeyAutoCreationRequest
 * @return ApplyAntChainWithKeyAutoCreationResponse
 */
async function applyAntChainWithKeyAutoCreation(request: ApplyAntChainWithKeyAutoCreationRequest): ApplyAntChainWithKeyAutoCreationResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyAntChainWithKeyAutoCreationWithOptions(request, runtime);
}

model ApplyBlockchainRequest {
  account?: string(name='Account'),
  accountPubKey?: string(name='AccountPubKey'),
  accountRecoverPubKey?: string(name='AccountRecoverPubKey'),
  blockchain?: string(name='Blockchain'),
  uploadReq?: string(name='UploadReq'),
}

model ApplyBlockchainResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model ApplyBlockchainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ApplyBlockchainResponseBody(name='body'),
}

/**
 * @param request ApplyBlockchainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ApplyBlockchainResponse
 */
async function applyBlockchainWithOptions(request: ApplyBlockchainRequest, runtime: Util.RuntimeOptions): ApplyBlockchainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.account)) {
    body['Account'] = request.account;
  }
  if (!Util.isUnset(request.accountPubKey)) {
    body['AccountPubKey'] = request.accountPubKey;
  }
  if (!Util.isUnset(request.accountRecoverPubKey)) {
    body['AccountRecoverPubKey'] = request.accountRecoverPubKey;
  }
  if (!Util.isUnset(request.blockchain)) {
    body['Blockchain'] = request.blockchain;
  }
  if (!Util.isUnset(request.uploadReq)) {
    body['UploadReq'] = request.uploadReq;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ApplyBlockchain',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ApplyBlockchainRequest
 * @return ApplyBlockchainResponse
 */
async function applyBlockchain(request: ApplyBlockchainRequest): ApplyBlockchainResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyBlockchainWithOptions(request, runtime);
}

model ApplyBlockchainWithKeyAutoCreationRequest {
  bizid?: string(name='Bizid'),
  commonName?: string(name='CommonName'),
  countryName?: string(name='CountryName'),
  localityName?: string(name='LocalityName'),
  organizationName?: string(name='OrganizationName'),
  organizationUnitName?: string(name='OrganizationUnitName'),
  password?: string(name='Password'),
  stateOrProvinceName?: string(name='StateOrProvinceName'),
}

model ApplyBlockchainWithKeyAutoCreationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    downloadPath?: {
      bizviewUrl?: string(name='BizviewUrl'),
      certUrl?: string(name='CertUrl'),
      sdkUrl?: string(name='SdkUrl'),
    }(name='DownloadPath'),
    privateKey?: string(name='PrivateKey'),
  }(name='Result'),
}

model ApplyBlockchainWithKeyAutoCreationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ApplyBlockchainWithKeyAutoCreationResponseBody(name='body'),
}

/**
 * @param request ApplyBlockchainWithKeyAutoCreationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ApplyBlockchainWithKeyAutoCreationResponse
 */
async function applyBlockchainWithKeyAutoCreationWithOptions(request: ApplyBlockchainWithKeyAutoCreationRequest, runtime: Util.RuntimeOptions): ApplyBlockchainWithKeyAutoCreationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.commonName)) {
    body['CommonName'] = request.commonName;
  }
  if (!Util.isUnset(request.countryName)) {
    body['CountryName'] = request.countryName;
  }
  if (!Util.isUnset(request.localityName)) {
    body['LocalityName'] = request.localityName;
  }
  if (!Util.isUnset(request.organizationName)) {
    body['OrganizationName'] = request.organizationName;
  }
  if (!Util.isUnset(request.organizationUnitName)) {
    body['OrganizationUnitName'] = request.organizationUnitName;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.stateOrProvinceName)) {
    body['StateOrProvinceName'] = request.stateOrProvinceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ApplyBlockchainWithKeyAutoCreation',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ApplyBlockchainWithKeyAutoCreationRequest
 * @return ApplyBlockchainWithKeyAutoCreationResponse
 */
async function applyBlockchainWithKeyAutoCreation(request: ApplyBlockchainWithKeyAutoCreationRequest): ApplyBlockchainWithKeyAutoCreationResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyBlockchainWithKeyAutoCreationWithOptions(request, runtime);
}

model ApplyPublicAntChainRequest {
  bizid?: string(name='Bizid'),
  consortiumId?: string(name='ConsortiumId'),
  uploadReq?: string(name='UploadReq'),
}

model ApplyPublicAntChainResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model ApplyPublicAntChainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ApplyPublicAntChainResponseBody(name='body'),
}

/**
 * @param request ApplyPublicAntChainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ApplyPublicAntChainResponse
 */
async function applyPublicAntChainWithOptions(request: ApplyPublicAntChainRequest, runtime: Util.RuntimeOptions): ApplyPublicAntChainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.uploadReq)) {
    body['UploadReq'] = request.uploadReq;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ApplyPublicAntChain',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ApplyPublicAntChainRequest
 * @return ApplyPublicAntChainResponse
 */
async function applyPublicAntChain(request: ApplyPublicAntChainRequest): ApplyPublicAntChainResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyPublicAntChainWithOptions(request, runtime);
}

model ApplyPublicAntChainWithKeyAutoCreationRequest {
  bizid?: string(name='Bizid'),
  commonName?: string(name='CommonName'),
  countryName?: string(name='CountryName'),
  localityName?: string(name='LocalityName'),
  organizationName?: string(name='OrganizationName'),
  organizationUnitName?: string(name='OrganizationUnitName'),
  password?: string(name='Password'),
  stateOrProvinceName?: string(name='StateOrProvinceName'),
}

model ApplyPublicAntChainWithKeyAutoCreationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    downloadPath?: {
      caCrtUrl?: string(name='CaCrtUrl'),
      clientCrtUrl?: string(name='ClientCrtUrl'),
      sdkUrl?: string(name='SdkUrl'),
      trustCaUrl?: string(name='TrustCaUrl'),
    }(name='DownloadPath'),
    privateKey?: string(name='PrivateKey'),
  }(name='Result'),
}

model ApplyPublicAntChainWithKeyAutoCreationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ApplyPublicAntChainWithKeyAutoCreationResponseBody(name='body'),
}

/**
 * @param request ApplyPublicAntChainWithKeyAutoCreationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ApplyPublicAntChainWithKeyAutoCreationResponse
 */
async function applyPublicAntChainWithKeyAutoCreationWithOptions(request: ApplyPublicAntChainWithKeyAutoCreationRequest, runtime: Util.RuntimeOptions): ApplyPublicAntChainWithKeyAutoCreationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.commonName)) {
    body['CommonName'] = request.commonName;
  }
  if (!Util.isUnset(request.countryName)) {
    body['CountryName'] = request.countryName;
  }
  if (!Util.isUnset(request.localityName)) {
    body['LocalityName'] = request.localityName;
  }
  if (!Util.isUnset(request.organizationName)) {
    body['OrganizationName'] = request.organizationName;
  }
  if (!Util.isUnset(request.organizationUnitName)) {
    body['OrganizationUnitName'] = request.organizationUnitName;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.stateOrProvinceName)) {
    body['StateOrProvinceName'] = request.stateOrProvinceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ApplyPublicAntChainWithKeyAutoCreation',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ApplyPublicAntChainWithKeyAutoCreationRequest
 * @return ApplyPublicAntChainWithKeyAutoCreationResponse
 */
async function applyPublicAntChainWithKeyAutoCreation(request: ApplyPublicAntChainWithKeyAutoCreationRequest): ApplyPublicAntChainWithKeyAutoCreationResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyPublicAntChainWithKeyAutoCreationWithOptions(request, runtime);
}

model ApproveEthereumInviteeRequest {
  id?: string(name='Id', description='This parameter is required.'),
  invitee?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='Invitee', description='This parameter is required.'),
}

model ApproveEthereumInviteeResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model ApproveEthereumInviteeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ApproveEthereumInviteeResponseBody(name='body'),
}

/**
 * @param request ApproveEthereumInviteeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ApproveEthereumInviteeResponse
 */
async function approveEthereumInviteeWithOptions(request: ApproveEthereumInviteeRequest, runtime: Util.RuntimeOptions): ApproveEthereumInviteeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.invitee)) {
    body['Invitee'] = request.invitee;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ApproveEthereumInvitee',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ApproveEthereumInviteeRequest
 * @return ApproveEthereumInviteeResponse
 */
async function approveEthereumInvitee(request: ApproveEthereumInviteeRequest): ApproveEthereumInviteeResponse {
  var runtime = new Util.RuntimeOptions{};
  return approveEthereumInviteeWithOptions(request, runtime);
}

model ApproveFabricChaincodeDefinitionRequest {
  chaincodeId?: string(name='ChaincodeId'),
  chaincodePackageId?: string(name='ChaincodePackageId'),
  location?: string(name='Location'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model ApproveFabricChaincodeDefinitionResponseBody = {
  chaincodeDefinitionId?: string(name='ChaincodeDefinitionId'),
  chaincodePackageId?: string(name='ChaincodePackageId'),
  errorCode?: int32(name='ErrorCode'),
  initRequired?: boolean(name='InitRequired'),
  requestId?: string(name='RequestId'),
  result?: {
    chaincodeId?: string(name='ChaincodeId'),
    channelName?: string(name='ChannelName'),
    consortiumId?: string(name='ConsortiumId'),
    createTime?: string(name='CreateTime'),
    deployTime?: string(name='DeployTime'),
    endorsePolicy?: string(name='EndorsePolicy'),
    input?: string(name='Input'),
    install?: boolean(name='Install'),
    message?: string(name='Message'),
    name?: string(name='Name'),
    path?: string(name='Path'),
    providerId?: string(name='ProviderId'),
    providerName?: string(name='ProviderName'),
    state?: string(name='State'),
    type?: int32(name='Type'),
    version?: string(name='Version'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model ApproveFabricChaincodeDefinitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ApproveFabricChaincodeDefinitionResponseBody(name='body'),
}

/**
 * @param request ApproveFabricChaincodeDefinitionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ApproveFabricChaincodeDefinitionResponse
 */
async function approveFabricChaincodeDefinitionWithOptions(request: ApproveFabricChaincodeDefinitionRequest, runtime: Util.RuntimeOptions): ApproveFabricChaincodeDefinitionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.chaincodeId)) {
    body['ChaincodeId'] = request.chaincodeId;
  }
  if (!Util.isUnset(request.chaincodePackageId)) {
    body['ChaincodePackageId'] = request.chaincodePackageId;
  }
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ApproveFabricChaincodeDefinition',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ApproveFabricChaincodeDefinitionRequest
 * @return ApproveFabricChaincodeDefinitionResponse
 */
async function approveFabricChaincodeDefinition(request: ApproveFabricChaincodeDefinitionRequest): ApproveFabricChaincodeDefinitionResponse {
  var runtime = new Util.RuntimeOptions{};
  return approveFabricChaincodeDefinitionWithOptions(request, runtime);
}

model BatchAddAntChainMiniAppQRCodeAuthorizedUsersRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  phoneList?: map[string]any(name='PhoneList', description='This parameter is required.'),
}

model BatchAddAntChainMiniAppQRCodeAuthorizedUsersShrinkRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  phoneListShrink?: string(name='PhoneList', description='This parameter is required.'),
}

model BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponseBody(name='body'),
}

/**
 * @param tmpReq BatchAddAntChainMiniAppQRCodeAuthorizedUsersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse
 */
async function batchAddAntChainMiniAppQRCodeAuthorizedUsersWithOptions(tmpReq: BatchAddAntChainMiniAppQRCodeAuthorizedUsersRequest, runtime: Util.RuntimeOptions): BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse {
  Util.validateModel(tmpReq);
  var request = new BatchAddAntChainMiniAppQRCodeAuthorizedUsersShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.phoneList)) {
    request.phoneListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.phoneList, 'PhoneList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.phoneListShrink)) {
    body['PhoneList'] = request.phoneListShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchAddAntChainMiniAppQRCodeAuthorizedUsers',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchAddAntChainMiniAppQRCodeAuthorizedUsersRequest
 * @return BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse
 */
async function batchAddAntChainMiniAppQRCodeAuthorizedUsers(request: BatchAddAntChainMiniAppQRCodeAuthorizedUsersRequest): BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchAddAntChainMiniAppQRCodeAuthorizedUsersWithOptions(request, runtime);
}

model BindFabricManagementChaincodeRequest {
  chaincodeId?: string(name='ChaincodeId', description='This parameter is required.'),
  channelId?: string(name='ChannelId', description='This parameter is required.'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model BindFabricManagementChaincodeResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    input?: string(name='Input'),
    name?: string(name='Name'),
    path?: long(name='Path'),
    type?: int32(name='Type'),
    version?: string(name='Version'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model BindFabricManagementChaincodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BindFabricManagementChaincodeResponseBody(name='body'),
}

/**
 * @param request BindFabricManagementChaincodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BindFabricManagementChaincodeResponse
 */
async function bindFabricManagementChaincodeWithOptions(request: BindFabricManagementChaincodeRequest, runtime: Util.RuntimeOptions): BindFabricManagementChaincodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.chaincodeId)) {
    body['ChaincodeId'] = request.chaincodeId;
  }
  if (!Util.isUnset(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BindFabricManagementChaincode',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BindFabricManagementChaincodeRequest
 * @return BindFabricManagementChaincodeResponse
 */
async function bindFabricManagementChaincode(request: BindFabricManagementChaincodeRequest): BindFabricManagementChaincodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindFabricManagementChaincodeWithOptions(request, runtime);
}

model CheckConsortiumDomainRequest {
  domainCode?: string(name='DomainCode', description='This parameter is required.', example='bank'),
}

model CheckConsortiumDomainResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='CD264CC8-B892-4CDC-BD31-7D179EE6E396'),
  result?: {
    domain?: string(name='Domain', example='bank'),
    prompt?: string(name='Prompt', example='OK'),
    valid?: boolean(name='Valid', example='true'),
  }(name='Result'),
  success?: boolean(name='Success', example='true'),
}

model CheckConsortiumDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckConsortiumDomainResponseBody(name='body'),
}

/**
 * @param request CheckConsortiumDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckConsortiumDomainResponse
 */
async function checkConsortiumDomainWithOptions(request: CheckConsortiumDomainRequest, runtime: Util.RuntimeOptions): CheckConsortiumDomainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.domainCode)) {
    body['DomainCode'] = request.domainCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CheckConsortiumDomain',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CheckConsortiumDomainRequest
 * @return CheckConsortiumDomainResponse
 */
async function checkConsortiumDomain(request: CheckConsortiumDomainRequest): CheckConsortiumDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkConsortiumDomainWithOptions(request, runtime);
}

model CheckOrganizationDomainRequest {
  domain?: string(name='Domain', example='bank'),
  domainCode?: string(name='DomainCode', example='bank'),
}

model CheckOrganizationDomainResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='CD264CC8-B892-4CDC-BD31-7D179EE6E396'),
  result?: {
    domain?: string(name='Domain', example='bank'),
    prompt?: string(name='Prompt', example='OK'),
    valid?: boolean(name='Valid', example='true'),
  }(name='Result'),
  success?: boolean(name='Success', example='true'),
}

model CheckOrganizationDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckOrganizationDomainResponseBody(name='body'),
}

/**
 * @param request CheckOrganizationDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckOrganizationDomainResponse
 */
async function checkOrganizationDomainWithOptions(request: CheckOrganizationDomainRequest, runtime: Util.RuntimeOptions): CheckOrganizationDomainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.domain)) {
    body['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.domainCode)) {
    body['DomainCode'] = request.domainCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CheckOrganizationDomain',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CheckOrganizationDomainRequest
 * @return CheckOrganizationDomainResponse
 */
async function checkOrganizationDomain(request: CheckOrganizationDomainRequest): CheckOrganizationDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkOrganizationDomainWithOptions(request, runtime);
}

model ConfirmConsortiumMemberRequest {
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.', example='consortium-aaaaaa-akpcsjjac2jd'),
  organization?: [ 
    {
      id?: string(name='Id', example='peers-aaaaaa1-1oxw31d046jtl'),
    }
  ](name='Organization', description='This parameter is required.'),
}

model ConfirmConsortiumMemberResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='50B3ACF3-CE12-433C-A834-9E8C657A4934'),
  result?: boolean(name='Result', example='true'),
  success?: boolean(name='Success', example='true'),
}

model ConfirmConsortiumMemberResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConfirmConsortiumMemberResponseBody(name='body'),
}

/**
 * @param request ConfirmConsortiumMemberRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfirmConsortiumMemberResponse
 */
async function confirmConsortiumMemberWithOptions(request: ConfirmConsortiumMemberRequest, runtime: Util.RuntimeOptions): ConfirmConsortiumMemberResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consortiumId)) {
    query['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.organization)) {
    query['Organization'] = request.organization;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfirmConsortiumMember',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ConfirmConsortiumMemberRequest
 * @return ConfirmConsortiumMemberResponse
 */
async function confirmConsortiumMember(request: ConfirmConsortiumMemberRequest): ConfirmConsortiumMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return confirmConsortiumMemberWithOptions(request, runtime);
}

model CopyAntChainContractProjectRequest {
  projectDescription?: string(name='ProjectDescription'),
  projectId?: string(name='ProjectId', description='This parameter is required.'),
  projectName?: string(name='ProjectName', description='This parameter is required.'),
  projectVersion?: string(name='ProjectVersion', description='This parameter is required.'),
}

model CopyAntChainContractProjectResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    consortiumId?: string(name='ConsortiumId'),
    createTime?: long(name='CreateTime'),
    projectDescription?: string(name='ProjectDescription'),
    projectId?: string(name='ProjectId'),
    projectName?: string(name='ProjectName'),
    projectVersion?: string(name='ProjectVersion'),
    updateTime?: long(name='UpdateTime'),
  }(name='Result'),
}

model CopyAntChainContractProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CopyAntChainContractProjectResponseBody(name='body'),
}

/**
 * @param request CopyAntChainContractProjectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CopyAntChainContractProjectResponse
 */
async function copyAntChainContractProjectWithOptions(request: CopyAntChainContractProjectRequest, runtime: Util.RuntimeOptions): CopyAntChainContractProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.projectDescription)) {
    body['ProjectDescription'] = request.projectDescription;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.projectVersion)) {
    body['ProjectVersion'] = request.projectVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CopyAntChainContractProject',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CopyAntChainContractProjectRequest
 * @return CopyAntChainContractProjectResponse
 */
async function copyAntChainContractProject(request: CopyAntChainContractProjectRequest): CopyAntChainContractProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return copyAntChainContractProjectWithOptions(request, runtime);
}

model CreateAccessTokenRequest {
  accessTokenLifetime?: string(name='AccessTokenLifetime', description='This parameter is required.'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
  refreshTokenLifetime?: string(name='RefreshTokenLifetime', description='This parameter is required.'),
  scope?: string(name='Scope', description='This parameter is required.'),
}

model CreateAccessTokenResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    accessToken?: string(name='AccessToken'),
    expiresIn?: long(name='ExpiresIn'),
    refreshToken?: string(name='RefreshToken'),
    tokenType?: string(name='TokenType'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model CreateAccessTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAccessTokenResponseBody(name='body'),
}

/**
 * @param request CreateAccessTokenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAccessTokenResponse
 */
async function createAccessTokenWithOptions(request: CreateAccessTokenRequest, runtime: Util.RuntimeOptions): CreateAccessTokenResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accessTokenLifetime)) {
    body['AccessTokenLifetime'] = request.accessTokenLifetime;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.refreshTokenLifetime)) {
    body['RefreshTokenLifetime'] = request.refreshTokenLifetime;
  }
  if (!Util.isUnset(request.scope)) {
    body['Scope'] = request.scope;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAccessToken',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateAccessTokenRequest
 * @return CreateAccessTokenResponse
 */
async function createAccessToken(request: CreateAccessTokenRequest): CreateAccessTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAccessTokenWithOptions(request, runtime);
}

model CreateAccountRequest {
  account?: string(name='Account'),
  accountPubKey?: string(name='AccountPubKey'),
  accountRecoverPubKey?: string(name='AccountRecoverPubKey'),
  bizid?: string(name='Bizid'),
}

model CreateAccountResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model CreateAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAccountResponseBody(name='body'),
}

/**
 * @param request CreateAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAccountResponse
 */
async function createAccountWithOptions(request: CreateAccountRequest, runtime: Util.RuntimeOptions): CreateAccountResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.account)) {
    body['Account'] = request.account;
  }
  if (!Util.isUnset(request.accountPubKey)) {
    body['AccountPubKey'] = request.accountPubKey;
  }
  if (!Util.isUnset(request.accountRecoverPubKey)) {
    body['AccountRecoverPubKey'] = request.accountRecoverPubKey;
  }
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAccount',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateAccountRequest
 * @return CreateAccountResponse
 */
async function createAccount(request: CreateAccountRequest): CreateAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAccountWithOptions(request, runtime);
}

model CreateAccountWithKeyPairAutoCreationRequest {
  account?: string(name='Account'),
  bizid?: string(name='Bizid'),
  password?: string(name='Password'),
}

model CreateAccountWithKeyPairAutoCreationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    accountPrivateKey?: string(name='AccountPrivateKey'),
    accountPublicKey?: string(name='AccountPublicKey'),
    accountRecoverPrivateKey?: string(name='AccountRecoverPrivateKey'),
    accountRecoverPublicKey?: string(name='AccountRecoverPublicKey'),
  }(name='Result'),
}

model CreateAccountWithKeyPairAutoCreationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAccountWithKeyPairAutoCreationResponseBody(name='body'),
}

/**
 * @param request CreateAccountWithKeyPairAutoCreationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAccountWithKeyPairAutoCreationResponse
 */
async function createAccountWithKeyPairAutoCreationWithOptions(request: CreateAccountWithKeyPairAutoCreationRequest, runtime: Util.RuntimeOptions): CreateAccountWithKeyPairAutoCreationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.account)) {
    body['Account'] = request.account;
  }
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAccountWithKeyPairAutoCreation',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateAccountWithKeyPairAutoCreationRequest
 * @return CreateAccountWithKeyPairAutoCreationResponse
 */
async function createAccountWithKeyPairAutoCreation(request: CreateAccountWithKeyPairAutoCreationRequest): CreateAccountWithKeyPairAutoCreationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAccountWithKeyPairAutoCreationWithOptions(request, runtime);
}

model CreateAntChainRequest {
  antChainName?: string(name='AntChainName', description='This parameter is required.'),
  blockchainRegionId?: string(name='BlockchainRegionId', description='This parameter is required.'),
  cipherSuit?: string(name='CipherSuit', description='This parameter is required.'),
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.'),
  liveTime?: int32(name='LiveTime', description='This parameter is required.'),
  merkleTreeSuit?: string(name='MerkleTreeSuit', description='This parameter is required.'),
  nodeNum?: int32(name='NodeNum', description='This parameter is required.'),
  resourceSize?: int32(name='ResourceSize', description='This parameter is required.'),
  tlsAlgo?: string(name='TlsAlgo', description='This parameter is required.'),
}

model CreateAntChainResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    antChainId?: string(name='AntChainId'),
  }(name='Result'),
}

model CreateAntChainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAntChainResponseBody(name='body'),
}

/**
 * @param request CreateAntChainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAntChainResponse
 */
async function createAntChainWithOptions(request: CreateAntChainRequest, runtime: Util.RuntimeOptions): CreateAntChainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainName)) {
    body['AntChainName'] = request.antChainName;
  }
  if (!Util.isUnset(request.blockchainRegionId)) {
    body['BlockchainRegionId'] = request.blockchainRegionId;
  }
  if (!Util.isUnset(request.cipherSuit)) {
    body['CipherSuit'] = request.cipherSuit;
  }
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.liveTime)) {
    body['LiveTime'] = request.liveTime;
  }
  if (!Util.isUnset(request.merkleTreeSuit)) {
    body['MerkleTreeSuit'] = request.merkleTreeSuit;
  }
  if (!Util.isUnset(request.nodeNum)) {
    body['NodeNum'] = request.nodeNum;
  }
  if (!Util.isUnset(request.resourceSize)) {
    body['ResourceSize'] = request.resourceSize;
  }
  if (!Util.isUnset(request.tlsAlgo)) {
    body['TlsAlgo'] = request.tlsAlgo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAntChain',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateAntChainRequest
 * @return CreateAntChainResponse
 */
async function createAntChain(request: CreateAntChainRequest): CreateAntChainResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAntChainWithOptions(request, runtime);
}

model CreateAntChainAccountRequest {
  account?: string(name='Account'),
  accountPubKey?: string(name='AccountPubKey'),
  accountRecoverPubKey?: string(name='AccountRecoverPubKey'),
  antChainId?: string(name='AntChainId'),
}

model CreateAntChainAccountResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    account?: string(name='Account'),
    antChainId?: string(name='AntChainId'),
  }(name='Result'),
}

model CreateAntChainAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAntChainAccountResponseBody(name='body'),
}

/**
 * @param request CreateAntChainAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAntChainAccountResponse
 */
async function createAntChainAccountWithOptions(request: CreateAntChainAccountRequest, runtime: Util.RuntimeOptions): CreateAntChainAccountResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.account)) {
    body['Account'] = request.account;
  }
  if (!Util.isUnset(request.accountPubKey)) {
    body['AccountPubKey'] = request.accountPubKey;
  }
  if (!Util.isUnset(request.accountRecoverPubKey)) {
    body['AccountRecoverPubKey'] = request.accountRecoverPubKey;
  }
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAntChainAccount',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateAntChainAccountRequest
 * @return CreateAntChainAccountResponse
 */
async function createAntChainAccount(request: CreateAntChainAccountRequest): CreateAntChainAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAntChainAccountWithOptions(request, runtime);
}

model CreateAntChainAccountWithKeyPairAutoCreationRequest {
  account?: string(name='Account'),
  antChainId?: string(name='AntChainId'),
  password?: string(name='Password'),
  recoverPassword?: string(name='RecoverPassword'),
}

model CreateAntChainAccountWithKeyPairAutoCreationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    account?: string(name='Account'),
    accountPrivateKey?: string(name='AccountPrivateKey'),
    accountPublicKey?: string(name='AccountPublicKey'),
    accountRecoverPrivateKey?: string(name='AccountRecoverPrivateKey'),
    accountRecoverPublicKey?: string(name='AccountRecoverPublicKey'),
    antChainId?: string(name='AntChainId'),
  }(name='Result'),
}

model CreateAntChainAccountWithKeyPairAutoCreationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAntChainAccountWithKeyPairAutoCreationResponseBody(name='body'),
}

/**
 * @param request CreateAntChainAccountWithKeyPairAutoCreationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAntChainAccountWithKeyPairAutoCreationResponse
 */
async function createAntChainAccountWithKeyPairAutoCreationWithOptions(request: CreateAntChainAccountWithKeyPairAutoCreationRequest, runtime: Util.RuntimeOptions): CreateAntChainAccountWithKeyPairAutoCreationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.account)) {
    body['Account'] = request.account;
  }
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.recoverPassword)) {
    body['RecoverPassword'] = request.recoverPassword;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAntChainAccountWithKeyPairAutoCreation',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateAntChainAccountWithKeyPairAutoCreationRequest
 * @return CreateAntChainAccountWithKeyPairAutoCreationResponse
 */
async function createAntChainAccountWithKeyPairAutoCreation(request: CreateAntChainAccountWithKeyPairAutoCreationRequest): CreateAntChainAccountWithKeyPairAutoCreationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAntChainAccountWithKeyPairAutoCreationWithOptions(request, runtime);
}

model CreateAntChainConsortiumRequest {
  consortiumDescription?: string(name='ConsortiumDescription'),
  consortiumName?: string(name='ConsortiumName', description='This parameter is required.'),
}

model CreateAntChainConsortiumResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    consortiumId?: string(name='ConsortiumId'),
  }(name='Result'),
}

model CreateAntChainConsortiumResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAntChainConsortiumResponseBody(name='body'),
}

/**
 * @param request CreateAntChainConsortiumRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAntChainConsortiumResponse
 */
async function createAntChainConsortiumWithOptions(request: CreateAntChainConsortiumRequest, runtime: Util.RuntimeOptions): CreateAntChainConsortiumResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.consortiumDescription)) {
    body['ConsortiumDescription'] = request.consortiumDescription;
  }
  if (!Util.isUnset(request.consortiumName)) {
    body['ConsortiumName'] = request.consortiumName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAntChainConsortium',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateAntChainConsortiumRequest
 * @return CreateAntChainConsortiumResponse
 */
async function createAntChainConsortium(request: CreateAntChainConsortiumRequest): CreateAntChainConsortiumResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAntChainConsortiumWithOptions(request, runtime);
}

model CreateAntChainContractContentRequest {
  content?: string(name='Content'),
  contentName?: string(name='ContentName', description='This parameter is required.'),
  isDirectory?: boolean(name='IsDirectory', description='This parameter is required.'),
  parentContentId?: string(name='ParentContentId'),
  projectId?: string(name='ProjectId', description='This parameter is required.'),
}

model CreateAntChainContractContentResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    content?: string(name='Content'),
    contentId?: string(name='ContentId'),
    contentName?: string(name='ContentName'),
    createTime?: string(name='CreateTime'),
    isDirectory?: boolean(name='IsDirectory'),
    parentContentId?: string(name='ParentContentId'),
    projectId?: string(name='ProjectId'),
    updateTime?: string(name='UpdateTime'),
  }(name='Result'),
}

model CreateAntChainContractContentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAntChainContractContentResponseBody(name='body'),
}

/**
 * @param request CreateAntChainContractContentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAntChainContractContentResponse
 */
async function createAntChainContractContentWithOptions(request: CreateAntChainContractContentRequest, runtime: Util.RuntimeOptions): CreateAntChainContractContentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.contentName)) {
    body['ContentName'] = request.contentName;
  }
  if (!Util.isUnset(request.isDirectory)) {
    body['IsDirectory'] = request.isDirectory;
  }
  if (!Util.isUnset(request.parentContentId)) {
    body['ParentContentId'] = request.parentContentId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAntChainContractContent',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateAntChainContractContentRequest
 * @return CreateAntChainContractContentResponse
 */
async function createAntChainContractContent(request: CreateAntChainContractContentRequest): CreateAntChainContractContentResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAntChainContractContentWithOptions(request, runtime);
}

model CreateAntChainContractProjectRequest {
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.'),
  projectDescription?: string(name='ProjectDescription'),
  projectName?: string(name='ProjectName', description='This parameter is required.'),
  projectVersion?: string(name='ProjectVersion', description='This parameter is required.'),
}

model CreateAntChainContractProjectResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    consortiumId?: string(name='ConsortiumId'),
    createTime?: long(name='CreateTime'),
    projectDescription?: string(name='ProjectDescription'),
    projectId?: string(name='ProjectId'),
    projectName?: string(name='ProjectName'),
    projectVersion?: string(name='ProjectVersion'),
    updateTime?: long(name='UpdateTime'),
  }(name='Result'),
}

model CreateAntChainContractProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAntChainContractProjectResponseBody(name='body'),
}

/**
 * @param request CreateAntChainContractProjectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAntChainContractProjectResponse
 */
async function createAntChainContractProjectWithOptions(request: CreateAntChainContractProjectRequest, runtime: Util.RuntimeOptions): CreateAntChainContractProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.projectDescription)) {
    body['ProjectDescription'] = request.projectDescription;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.projectVersion)) {
    body['ProjectVersion'] = request.projectVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAntChainContractProject',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateAntChainContractProjectRequest
 * @return CreateAntChainContractProjectResponse
 */
async function createAntChainContractProject(request: CreateAntChainContractProjectRequest): CreateAntChainContractProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAntChainContractProjectWithOptions(request, runtime);
}

model CreateBlockchainRequest {
  bizid?: string(name='Bizid'),
  blockchainRegionId?: string(name='BlockchainRegionId'),
  blockchainType?: string(name='BlockchainType'),
  cipherSuit?: string(name='CipherSuit'),
  liveTime?: int32(name='LiveTime'),
  machineNum?: int32(name='MachineNum'),
  merkleTreeSuit?: string(name='MerkleTreeSuit'),
  size?: int32(name='Size'),
  tlsAlgo?: string(name='TlsAlgo'),
}

model CreateBlockchainResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model CreateBlockchainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateBlockchainResponseBody(name='body'),
}

/**
 * @param request CreateBlockchainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBlockchainResponse
 */
async function createBlockchainWithOptions(request: CreateBlockchainRequest, runtime: Util.RuntimeOptions): CreateBlockchainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.blockchainRegionId)) {
    body['BlockchainRegionId'] = request.blockchainRegionId;
  }
  if (!Util.isUnset(request.blockchainType)) {
    body['BlockchainType'] = request.blockchainType;
  }
  if (!Util.isUnset(request.cipherSuit)) {
    body['CipherSuit'] = request.cipherSuit;
  }
  if (!Util.isUnset(request.liveTime)) {
    body['LiveTime'] = request.liveTime;
  }
  if (!Util.isUnset(request.machineNum)) {
    body['MachineNum'] = request.machineNum;
  }
  if (!Util.isUnset(request.merkleTreeSuit)) {
    body['MerkleTreeSuit'] = request.merkleTreeSuit;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  if (!Util.isUnset(request.tlsAlgo)) {
    body['TlsAlgo'] = request.tlsAlgo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateBlockchain',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateBlockchainRequest
 * @return CreateBlockchainResponse
 */
async function createBlockchain(request: CreateBlockchainRequest): CreateBlockchainResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBlockchainWithOptions(request, runtime);
}

model CreateBlockchainApplicationRequest {
  bizid?: string(name='Bizid'),
  blockchainRegionId?: string(name='BlockchainRegionId'),
  blockchainType?: string(name='BlockchainType'),
  cipherSuit?: string(name='CipherSuit'),
  liveTime?: int32(name='LiveTime'),
  machineNum?: int32(name='MachineNum'),
  merkleTreeSuit?: string(name='MerkleTreeSuit'),
  size?: int32(name='Size'),
  tlsAlgo?: string(name='TlsAlgo'),
}

model CreateBlockchainApplicationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model CreateBlockchainApplicationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateBlockchainApplicationResponseBody(name='body'),
}

/**
 * @param request CreateBlockchainApplicationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBlockchainApplicationResponse
 */
async function createBlockchainApplicationWithOptions(request: CreateBlockchainApplicationRequest, runtime: Util.RuntimeOptions): CreateBlockchainApplicationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.blockchainRegionId)) {
    body['BlockchainRegionId'] = request.blockchainRegionId;
  }
  if (!Util.isUnset(request.blockchainType)) {
    body['BlockchainType'] = request.blockchainType;
  }
  if (!Util.isUnset(request.cipherSuit)) {
    body['CipherSuit'] = request.cipherSuit;
  }
  if (!Util.isUnset(request.liveTime)) {
    body['LiveTime'] = request.liveTime;
  }
  if (!Util.isUnset(request.machineNum)) {
    body['MachineNum'] = request.machineNum;
  }
  if (!Util.isUnset(request.merkleTreeSuit)) {
    body['MerkleTreeSuit'] = request.merkleTreeSuit;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  if (!Util.isUnset(request.tlsAlgo)) {
    body['TlsAlgo'] = request.tlsAlgo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateBlockchainApplication',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateBlockchainApplicationRequest
 * @return CreateBlockchainApplicationResponse
 */
async function createBlockchainApplication(request: CreateBlockchainApplicationRequest): CreateBlockchainApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBlockchainApplicationWithOptions(request, runtime);
}

model CreateBlockchainApplyRequest {
  bizid?: string(name='Bizid'),
  liveTime?: int32(name='LiveTime'),
  machineNum?: int32(name='MachineNum'),
  size?: int32(name='Size'),
}

model CreateBlockchainApplyResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model CreateBlockchainApplyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateBlockchainApplyResponseBody(name='body'),
}

/**
 * @param request CreateBlockchainApplyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBlockchainApplyResponse
 */
async function createBlockchainApplyWithOptions(request: CreateBlockchainApplyRequest, runtime: Util.RuntimeOptions): CreateBlockchainApplyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.liveTime)) {
    body['LiveTime'] = request.liveTime;
  }
  if (!Util.isUnset(request.machineNum)) {
    body['MachineNum'] = request.machineNum;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateBlockchainApply',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateBlockchainApplyRequest
 * @return CreateBlockchainApplyResponse
 */
async function createBlockchainApply(request: CreateBlockchainApplyRequest): CreateBlockchainApplyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBlockchainApplyWithOptions(request, runtime);
}

model CreateChaincodeRequest {
  channelId?: string(name='ChannelId', description='This parameter is required.', example='chan-first-channel-1w55v3u39x2xz'),
  consortiumId?: string(name='ConsortiumId', example='consortium-aaaaaa-akpcsjjac2jd'),
  endorsePolicy?: string(name='EndorsePolicy', example='OR (\\\\"aaaaaa1MSP.peer\\\\")'),
  location?: string(name='Location', example='cn-hangzhou'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.', example='peers-aaaaaa1-1oxw31d046jtl'),
  ossBucket?: string(name='OssBucket', description='This parameter is required.', example='https://chaincode.oss-cn-beijing.aliyuncs.com'),
  ossUrl?: string(name='OssUrl', description='This parameter is required.', example='aaaaaa1/a0cf8729-7d47-44c9-9ed5-6d2fdfc8dc2c/sacc.cc'),
}

model CreateChaincodeResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='CD264CC8-B892-4CDC-BD31-7D179EE6E396'),
  result?: {
    chaincodeId?: string(name='ChaincodeId', example='code-sacc-1pr09q7jmo0np'),
    channelName?: string(name='ChannelName', example='first-channel'),
    consortiumId?: string(name='ConsortiumId', example='consortium-aaaaaa-akpcsjjac2jd'),
    createTime?: string(name='CreateTime', example='1544766801000'),
    deployTime?: string(name='DeployTime', example='1544766801000'),
    endorsePolicy?: string(name='EndorsePolicy', example='OR (\\\\"aaaaaa1MSP.peer\\\\")'),
    input?: string(name='Input', example='string'),
    install?: boolean(name='Install', example='true'),
    message?: string(name='Message', example='string'),
    name?: string(name='Name', example='sacc'),
    path?: string(name='Path', example='go-sdk-demo/chaincode/src'),
    providerId?: string(name='ProviderId', example='peers-aaaaaa1-1oxw31d046jtl'),
    providerName?: string(name='ProviderName', example='peers-aaaaaa1-1oxw31d046jtl'),
    state?: string(name='State', example='Instantiatable'),
    type?: int32(name='Type', example='1'),
    version?: string(name='Version', example='1.0'),
  }(name='Result'),
  success?: boolean(name='Success', example='true'),
}

model CreateChaincodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateChaincodeResponseBody(name='body'),
}

/**
 * @param request CreateChaincodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateChaincodeResponse
 */
async function createChaincodeWithOptions(request: CreateChaincodeRequest, runtime: Util.RuntimeOptions): CreateChaincodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.endorsePolicy)) {
    body['EndorsePolicy'] = request.endorsePolicy;
  }
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.ossBucket)) {
    body['OssBucket'] = request.ossBucket;
  }
  if (!Util.isUnset(request.ossUrl)) {
    body['OssUrl'] = request.ossUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateChaincode',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateChaincodeRequest
 * @return CreateChaincodeResponse
 */
async function createChaincode(request: CreateChaincodeRequest): CreateChaincodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createChaincodeWithOptions(request, runtime);
}

model CreateChannelRequest {
  batchTimeout?: int32(name='BatchTimeout', example='2'),
  channelName?: string(name='ChannelName', description='This parameter is required.', example='channelx'),
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.', example='consortium-aaaaaa-akpcsjjac2jd'),
  maxMessageCount?: int32(name='MaxMessageCount', example='2'),
  organization?: [ 
    {
      id?: string(name='Id', example='peers-aaaaaa1-1oxw31d046jtl'),
    }
  ](name='Organization', description='This parameter is required.'),
  preferredMaxBytes?: int32(name='PreferredMaxBytes', example='2'),
}

model CreateChannelResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: {
    batchTimeout?: int32(name='BatchTimeout', example='2'),
    blockCount?: int32(name='BlockCount', example='2'),
    chaincodeCount?: int32(name='ChaincodeCount', example='2'),
    channelId?: string(name='ChannelId', example='chan-channelx-1l1hmckuuisxo'),
    consortiumId?: string(name='ConsortiumId', example='consortium-aaaaaa-akpcsjjac2jd'),
    consortiumName?: string(name='ConsortiumName', example='aaaaaa'),
    createTime?: string(name='CreateTime', example='1544768139624'),
    maxMessageCount?: int32(name='MaxMessageCount', example='2'),
    memberCount?: int32(name='MemberCount', example='1'),
    name?: string(name='Name', example='channelx'),
    ownerBid?: string(name='OwnerBid', example='26842'),
    ownerName?: string(name='OwnerName', example='uid-'),
    ownerUid?: int32(name='OwnerUid', example='1234'),
    preferredMaxBytes?: int32(name='PreferredMaxBytes', example='2'),
    requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
    state?: string(name='State', example='Pending'),
    supportConfig?: boolean(name='SupportConfig', example='true'),
    updateTime?: string(name='UpdateTime', example='1544768139624'),
  }(name='Result'),
  success?: boolean(name='Success', example='true'),
}

model CreateChannelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateChannelResponseBody(name='body'),
}

/**
 * @param request CreateChannelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateChannelResponse
 */
async function createChannelWithOptions(request: CreateChannelRequest, runtime: Util.RuntimeOptions): CreateChannelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channelName)) {
    query['ChannelName'] = request.channelName;
  }
  if (!Util.isUnset(request.consortiumId)) {
    query['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.organization)) {
    query['Organization'] = request.organization;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.batchTimeout)) {
    body['BatchTimeout'] = request.batchTimeout;
  }
  if (!Util.isUnset(request.maxMessageCount)) {
    body['MaxMessageCount'] = request.maxMessageCount;
  }
  if (!Util.isUnset(request.preferredMaxBytes)) {
    body['PreferredMaxBytes'] = request.preferredMaxBytes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateChannel',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateChannelRequest
 * @return CreateChannelResponse
 */
async function createChannel(request: CreateChannelRequest): CreateChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return createChannelWithOptions(request, runtime);
}

model CreateChannelMemberRequest {
  channelId?: string(name='ChannelId', description='This parameter is required.', example='chan-channelx-1l1hmckuuisxo'),
  organization?: [ 
    {
      id?: string(name='Id', example='peers-aaaaaa1-1oxw31d046jtl'),
    }
  ](name='Organization', description='This parameter is required.'),
}

model CreateChannelMemberResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: boolean(name='Result', example='true'),
  success?: boolean(name='Success', example='true'),
}

model CreateChannelMemberResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateChannelMemberResponseBody(name='body'),
}

/**
 * @param request CreateChannelMemberRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateChannelMemberResponse
 */
async function createChannelMemberWithOptions(request: CreateChannelMemberRequest, runtime: Util.RuntimeOptions): CreateChannelMemberResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channelId)) {
    query['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.organization)) {
    query['Organization'] = request.organization;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateChannelMember',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateChannelMemberRequest
 * @return CreateChannelMemberResponse
 */
async function createChannelMember(request: CreateChannelMemberRequest): CreateChannelMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return createChannelMemberWithOptions(request, runtime);
}

model CreateCloudIntegrationServiceTokenRequest {
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
  service?: string(name='Service', description='This parameter is required.'),
}

model CreateCloudIntegrationServiceTokenResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model CreateCloudIntegrationServiceTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCloudIntegrationServiceTokenResponseBody(name='body'),
}

/**
 * @param request CreateCloudIntegrationServiceTokenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCloudIntegrationServiceTokenResponse
 */
async function createCloudIntegrationServiceTokenWithOptions(request: CreateCloudIntegrationServiceTokenRequest, runtime: Util.RuntimeOptions): CreateCloudIntegrationServiceTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.service)) {
    query['Service'] = request.service;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCloudIntegrationServiceToken',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateCloudIntegrationServiceTokenRequest
 * @return CreateCloudIntegrationServiceTokenResponse
 */
async function createCloudIntegrationServiceToken(request: CreateCloudIntegrationServiceTokenRequest): CreateCloudIntegrationServiceTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCloudIntegrationServiceTokenWithOptions(request, runtime);
}

model CreateCloudServiceIntegrationRequest {
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model CreateCloudServiceIntegrationResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model CreateCloudServiceIntegrationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCloudServiceIntegrationResponseBody(name='body'),
}

/**
 * @param request CreateCloudServiceIntegrationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCloudServiceIntegrationResponse
 */
async function createCloudServiceIntegrationWithOptions(request: CreateCloudServiceIntegrationRequest, runtime: Util.RuntimeOptions): CreateCloudServiceIntegrationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCloudServiceIntegration',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateCloudServiceIntegrationRequest
 * @return CreateCloudServiceIntegrationResponse
 */
async function createCloudServiceIntegration(request: CreateCloudServiceIntegrationRequest): CreateCloudServiceIntegrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCloudServiceIntegrationWithOptions(request, runtime);
}

model CreateCloudServiceSessionRequest {
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model CreateCloudServiceSessionResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model CreateCloudServiceSessionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCloudServiceSessionResponseBody(name='body'),
}

/**
 * @param request CreateCloudServiceSessionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCloudServiceSessionResponse
 */
async function createCloudServiceSessionWithOptions(request: CreateCloudServiceSessionRequest, runtime: Util.RuntimeOptions): CreateCloudServiceSessionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCloudServiceSession',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateCloudServiceSessionRequest
 * @return CreateCloudServiceSessionResponse
 */
async function createCloudServiceSession(request: CreateCloudServiceSessionRequest): CreateCloudServiceSessionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCloudServiceSessionWithOptions(request, runtime);
}

model CreateConsortiumRequest {
  channelPolicy?: string(name='ChannelPolicy', description='This parameter is required.', example='Any'),
  description?: string(name='Description', example='some'),
  domain?: string(name='Domain', description='This parameter is required.', example='helloworld'),
  duration?: int32(name='Duration', example='24'),
  location?: string(name='Location', description='This parameter is required.', example='cn-hangzhou'),
  majorVersion?: string(name='MajorVersion'),
  name?: string(name='Name', description='This parameter is required.', example='helloworld'),
  ordererType?: string(name='OrdererType', description='This parameter is required.', example='Kafka'),
  orderersCount?: int32(name='OrderersCount', example='2'),
  organization?: [ 
    {
      id?: string(name='Id', example='peers-yidio-1tuigx42b1goc'),
    }
  ](name='Organization'),
  peersCount?: int32(name='PeersCount', example='2'),
  pricingCycle?: string(name='PricingCycle', example='12'),
  specName?: string(name='SpecName', description='This parameter is required.', example='basic'),
  zoneId?: string(name='ZoneId', example='zone'),
}

model CreateConsortiumResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: {
    channelCount?: int32(name='ChannelCount', example='0'),
    channelPolicy?: string(name='ChannelPolicy', example='Any'),
    clusterState?: string(name='ClusterState', example='Pending'),
    codeName?: string(name='CodeName', example='lianmenyumingyi'),
    consortiumId?: string(name='ConsortiumId', example='consortium-lianmenyumingyi-hc5d1bwlulg7'),
    createTime?: string(name='CreateTime', example='1544086901984'),
    description?: string(name='Description', example='string'),
    domain?: string(name='Domain', example='hello'),
    memberCount?: int32(name='MemberCount', example='2'),
    name?: string(name='Name', example='hello'),
    ordererCount?: int32(name='OrdererCount', example='1'),
    ordererType?: string(name='OrdererType', example='Kafka'),
    ownerBid?: string(name='OwnerBid', example='26842'),
    ownerUid?: long(name='OwnerUid', example='1019556'),
    regionId?: string(name='RegionId', example='cn-hangzhou'),
    serviceState?: string(name='ServiceState', example='Pending'),
    specName?: string(name='SpecName', example='basic'),
    zoneId?: string(name='ZoneId', example='zone'),
  }(name='Result'),
  success?: boolean(name='Success', example='true'),
}

model CreateConsortiumResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateConsortiumResponseBody(name='body'),
}

/**
 * @param request CreateConsortiumRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateConsortiumResponse
 */
async function createConsortiumWithOptions(request: CreateConsortiumRequest, runtime: Util.RuntimeOptions): CreateConsortiumResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.channelPolicy)) {
    body['ChannelPolicy'] = request.channelPolicy;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.domain)) {
    body['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.duration)) {
    body['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  if (!Util.isUnset(request.majorVersion)) {
    body['MajorVersion'] = request.majorVersion;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.ordererType)) {
    body['OrdererType'] = request.ordererType;
  }
  if (!Util.isUnset(request.orderersCount)) {
    body['OrderersCount'] = request.orderersCount;
  }
  if (!Util.isUnset(request.organization)) {
    body['Organization'] = request.organization;
  }
  if (!Util.isUnset(request.peersCount)) {
    body['PeersCount'] = request.peersCount;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    body['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.specName)) {
    body['SpecName'] = request.specName;
  }
  if (!Util.isUnset(request.zoneId)) {
    body['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateConsortium',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateConsortiumRequest
 * @return CreateConsortiumResponse
 */
async function createConsortium(request: CreateConsortiumRequest): CreateConsortiumResponse {
  var runtime = new Util.RuntimeOptions{};
  return createConsortiumWithOptions(request, runtime);
}

model CreateConsortiumMemberRequest {
  code?: string(name='Code', example='200'),
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.', example='consortium-aaaaaa-akpcsjjac2jd'),
  organization?: [ 
    {
      id?: string(name='Id', example='peers-aaaaaa1-1oxw31d046jtl'),
    }
  ](name='Organization', description='This parameter is required.'),
}

model CreateConsortiumMemberResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: boolean(name='Result', example='true'),
  success?: boolean(name='Success', example='true'),
}

model CreateConsortiumMemberResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateConsortiumMemberResponseBody(name='body'),
}

/**
 * @param request CreateConsortiumMemberRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateConsortiumMemberResponse
 */
async function createConsortiumMemberWithOptions(request: CreateConsortiumMemberRequest, runtime: Util.RuntimeOptions): CreateConsortiumMemberResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.code)) {
    query['Code'] = request.code;
  }
  if (!Util.isUnset(request.consortiumId)) {
    query['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.organization)) {
    query['Organization'] = request.organization;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateConsortiumMember',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateConsortiumMemberRequest
 * @return CreateConsortiumMemberResponse
 */
async function createConsortiumMember(request: CreateConsortiumMemberRequest): CreateConsortiumMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return createConsortiumMemberWithOptions(request, runtime);
}

model CreateEcosphereRequest {
  channelPolicy?: string(name='ChannelPolicy', description='This parameter is required.', example='Any'),
  consortiumName?: string(name='ConsortiumName', description='This parameter is required.', example='Name'),
  description?: string(name='Description', example='string'),
  duration?: int32(name='Duration', example='12'),
  location?: string(name='Location', description='This parameter is required.', example='cn-hangzhou'),
  majorVersion?: string(name='MajorVersion'),
  ordererDomain?: string(name='OrdererDomain', description='This parameter is required.', example='hello'),
  ordererType?: string(name='OrdererType', description='This parameter is required.', example='Kafka'),
  orderersCount?: int32(name='OrderersCount', example='2'),
  organization?: [ 
    {
      description?: string(name='Description', example='string'),
      domain?: string(name='Domain', example='domain1'),
      name?: string(name='Name', example='name1'),
    }
  ](name='Organization', description='This parameter is required.'),
  peersCount?: int32(name='PeersCount', example='2'),
  pricingCycle?: string(name='PricingCycle'),
  specName?: string(name='SpecName', description='This parameter is required.', example='basic'),
  zoneId?: string(name='ZoneId', example='cn-hangzhou'),
}

model CreateEcosphereResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  errorMessage?: string(name='ErrorMessage', example='ok'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: {
    channelCount?: int32(name='ChannelCount', example='2'),
    channelPolicy?: string(name='ChannelPolicy', example='Any'),
    clusterState?: string(name='ClusterState', example='Pending'),
    code?: string(name='Code', example='200'),
    consortiumId?: string(name='ConsortiumId', example='consortium-lianmenyumingyi-hc5d1bwlulg7'),
    createTime?: string(name='CreateTime', example='1544411108000'),
    description?: string(name='Description', example='hello'),
    domain?: string(name='Domain', example='hello'),
    memberCount?: int32(name='MemberCount', example='2'),
    name?: string(name='Name', example='hello'),
    ordererCount?: int32(name='OrdererCount', example='2'),
    ordererType?: string(name='OrdererType', example='Kafka'),
    organizations?: [ 
      {
        clusterState?: string(name='ClusterState', example='Pending'),
        code?: string(name='Code', example='200'),
        createTime?: string(name='CreateTime', example='1544411108000'),
        description?: string(name='Description', example='string'),
        domain?: string(name='Domain', example='string'),
        name?: string(name='Name', example='string'),
        serviceState?: string(name='ServiceState', example='Pending'),
      }
    ](name='Organizations'),
    ownerBid?: string(name='OwnerBid', example='26842'),
    ownerUid?: long(name='OwnerUid', example='144566'),
    regionId?: string(name='RegionId', example='cn-hangzhou'),
    serviceState?: string(name='ServiceState', example='Pending'),
    specName?: string(name='SpecName', example='basic'),
    specification?: {
      name?: string(name='Name', example='basic'),
      numOfNodes?: int32(name='NumOfNodes', example='2'),
      title?: string(name='Title', example='basic'),
    }(name='Specification'),
    zoneId?: string(name='ZoneId', example='zone'),
  }(name='Result'),
  success?: boolean(name='Success', example='true'),
}

model CreateEcosphereResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateEcosphereResponseBody(name='body'),
}

/**
 * @param request CreateEcosphereRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEcosphereResponse
 */
async function createEcosphereWithOptions(request: CreateEcosphereRequest, runtime: Util.RuntimeOptions): CreateEcosphereResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.channelPolicy)) {
    body['ChannelPolicy'] = request.channelPolicy;
  }
  if (!Util.isUnset(request.consortiumName)) {
    body['ConsortiumName'] = request.consortiumName;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.duration)) {
    body['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  if (!Util.isUnset(request.majorVersion)) {
    body['MajorVersion'] = request.majorVersion;
  }
  if (!Util.isUnset(request.ordererDomain)) {
    body['OrdererDomain'] = request.ordererDomain;
  }
  if (!Util.isUnset(request.ordererType)) {
    body['OrdererType'] = request.ordererType;
  }
  if (!Util.isUnset(request.orderersCount)) {
    body['OrderersCount'] = request.orderersCount;
  }
  if (!Util.isUnset(request.organization)) {
    body['Organization'] = request.organization;
  }
  if (!Util.isUnset(request.peersCount)) {
    body['PeersCount'] = request.peersCount;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    body['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.specName)) {
    body['SpecName'] = request.specName;
  }
  if (!Util.isUnset(request.zoneId)) {
    body['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateEcosphere',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateEcosphereRequest
 * @return CreateEcosphereResponse
 */
async function createEcosphere(request: CreateEcosphereRequest): CreateEcosphereResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEcosphereWithOptions(request, runtime);
}

model CreateEthereumRequest {
  consensus?: string(name='Consensus', description='This parameter is required.'),
  description?: string(name='Description'),
  difficulty?: string(name='Difficulty'),
  gas?: string(name='Gas'),
  name?: string(name='Name', description='This parameter is required.'),
  networkId?: string(name='NetworkId'),
  node?: [ 
    {
      name?: string(name='Name'),
    }
  ](name='Node', description='This parameter is required.'),
  region?: string(name='Region'),
}

model CreateEthereumResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    consensus?: string(name='Consensus'),
    creator?: string(name='Creator'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    networkId?: string(name='NetworkId'),
    regionId?: string(name='RegionId'),
    state?: string(name='State'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model CreateEthereumResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateEthereumResponseBody(name='body'),
}

/**
 * @param request CreateEthereumRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEthereumResponse
 */
async function createEthereumWithOptions(request: CreateEthereumRequest, runtime: Util.RuntimeOptions): CreateEthereumResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.consensus)) {
    body['Consensus'] = request.consensus;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.difficulty)) {
    body['Difficulty'] = request.difficulty;
  }
  if (!Util.isUnset(request.gas)) {
    body['Gas'] = request.gas;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.networkId)) {
    body['NetworkId'] = request.networkId;
  }
  if (!Util.isUnset(request.node)) {
    body['Node'] = request.node;
  }
  if (!Util.isUnset(request.region)) {
    body['Region'] = request.region;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateEthereum',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateEthereumRequest
 * @return CreateEthereumResponse
 */
async function createEthereum(request: CreateEthereumRequest): CreateEthereumResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEthereumWithOptions(request, runtime);
}

model CreateEthereumInvitationRequest {
  ethereumId?: string(name='EthereumId', description='This parameter is required.'),
}

model CreateEthereumInvitationResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    code?: string(name='Code'),
    createTime?: string(name='CreateTime'),
    expireTime?: string(name='ExpireTime'),
    token?: string(name='Token'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model CreateEthereumInvitationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateEthereumInvitationResponseBody(name='body'),
}

/**
 * @param request CreateEthereumInvitationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEthereumInvitationResponse
 */
async function createEthereumInvitationWithOptions(request: CreateEthereumInvitationRequest, runtime: Util.RuntimeOptions): CreateEthereumInvitationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ethereumId)) {
    body['EthereumId'] = request.ethereumId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateEthereumInvitation',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateEthereumInvitationRequest
 * @return CreateEthereumInvitationResponse
 */
async function createEthereumInvitation(request: CreateEthereumInvitationRequest): CreateEthereumInvitationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEthereumInvitationWithOptions(request, runtime);
}

model CreateFabricChaincodePackageRequest {
  location?: string(name='Location'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
  ossBucket?: string(name='OssBucket', description='This parameter is required.'),
  ossUrl?: string(name='OssUrl', description='This parameter is required.'),
}

model CreateFabricChaincodePackageResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: {
    chaincodePackageId?: int32(name='ChaincodePackageId'),
    checksum?: string(name='Checksum'),
    deleteTime?: long(name='DeleteTime'),
    deleted?: boolean(name='Deleted'),
    installTime?: long(name='InstallTime'),
    label?: string(name='Label'),
    md5sum?: string(name='Md5sum'),
    organizationId?: string(name='OrganizationId'),
    ossBucket?: string(name='OssBucket'),
    ossURL?: string(name='OssURL'),
    providerBid?: string(name='ProviderBid'),
    providerUid?: long(name='ProviderUid'),
    state?: string(name='State'),
    type?: string(name='Type'),
    typeString?: boolean(name='TypeString'),
    uploadTime?: long(name='UploadTime'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model CreateFabricChaincodePackageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFabricChaincodePackageResponseBody(name='body'),
}

/**
 * @param request CreateFabricChaincodePackageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFabricChaincodePackageResponse
 */
async function createFabricChaincodePackageWithOptions(request: CreateFabricChaincodePackageRequest, runtime: Util.RuntimeOptions): CreateFabricChaincodePackageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.ossBucket)) {
    body['OssBucket'] = request.ossBucket;
  }
  if (!Util.isUnset(request.ossUrl)) {
    body['OssUrl'] = request.ossUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFabricChaincodePackage',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateFabricChaincodePackageRequest
 * @return CreateFabricChaincodePackageResponse
 */
async function createFabricChaincodePackage(request: CreateFabricChaincodePackageRequest): CreateFabricChaincodePackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFabricChaincodePackageWithOptions(request, runtime);
}

model CreateOrganizationRequest {
  description?: string(name='Description', example='description'),
  domain?: string(name='Domain', description='This parameter is required.', example='domain'),
  duration?: int32(name='Duration', example='24'),
  location?: string(name='Location', description='This parameter is required.', example='cn-hangzhou'),
  majorVersion?: string(name='MajorVersion'),
  name?: string(name='Name', description='This parameter is required.', example='name'),
  peersCount?: int32(name='PeersCount', example='2'),
  pricingCycle?: string(name='PricingCycle'),
  specName?: string(name='SpecName', description='This parameter is required.', example='basic'),
}

model CreateOrganizationResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: {
    clusterState?: string(name='ClusterState', example='Pending'),
    codeName?: string(name='CodeName', example='name'),
    consortiumCount?: int32(name='ConsortiumCount', example='2'),
    createTime?: string(name='CreateTime', example='1533025590'),
    description?: string(name='Description', example='Description'),
    domain?: string(name='Domain', example='Domain'),
    name?: string(name='Name', example='Name'),
    organizationId?: string(name='OrganizationId', example='peers-aaaaaa2-1eqnj5o5w9dt3'),
    ownerBid?: string(name='OwnerBid', example='2544'),
    ownerName?: string(name='OwnerName', example='uid-23434'),
    ownerUid?: int32(name='OwnerUid', example='23434'),
    peerCount?: int32(name='PeerCount', example='2'),
    regionId?: string(name='RegionId', example='cn-hangzhou'),
    requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
    serviceState?: string(name='ServiceState', example='Running'),
    specName?: string(name='SpecName', example='basic'),
    userCount?: int32(name='UserCount', example='2'),
    zoneId?: string(name='ZoneId', example='zone'),
  }(name='Result'),
  success?: boolean(name='Success', example='true'),
}

model CreateOrganizationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOrganizationResponseBody(name='body'),
}

/**
 * @param request CreateOrganizationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOrganizationResponse
 */
async function createOrganizationWithOptions(request: CreateOrganizationRequest, runtime: Util.RuntimeOptions): CreateOrganizationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.location)) {
    query['Location'] = request.location;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.peersCount)) {
    query['PeersCount'] = request.peersCount;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.specName)) {
    query['SpecName'] = request.specName;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.majorVersion)) {
    body['MajorVersion'] = request.majorVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrganization',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateOrganizationRequest
 * @return CreateOrganizationResponse
 */
async function createOrganization(request: CreateOrganizationRequest): CreateOrganizationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrganizationWithOptions(request, runtime);
}

model CreateOrganizationUserRequest {
  attrs?: string(name='Attrs', example='a'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.', example='peers-yidio-1tuigx42b****'),
  password?: string(name='Password', example='password'),
  username?: string(name='Username', description='This parameter is required.', example='username'),
}

model CreateOrganizationUserResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: {
    createTime?: string(name='CreateTime', example='1544086901984'),
    expireTime?: string(name='ExpireTime', example='1544411108000'),
    fullname?: string(name='Fullname', example='fullname'),
    organizationId?: string(name='OrganizationId', example='peers-yidio-1tuigx42b****'),
    password?: string(name='Password', example='password'),
    username?: string(name='Username', example='username'),
  }(name='Result'),
  success?: boolean(name='Success', example='true'),
}

model CreateOrganizationUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOrganizationUserResponseBody(name='body'),
}

/**
 * @param request CreateOrganizationUserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOrganizationUserResponse
 */
async function createOrganizationUserWithOptions(request: CreateOrganizationUserRequest, runtime: Util.RuntimeOptions): CreateOrganizationUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.attrs)) {
    body['Attrs'] = request.attrs;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.username)) {
    body['Username'] = request.username;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrganizationUser',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateOrganizationUserRequest
 * @return CreateOrganizationUserResponse
 */
async function createOrganizationUser(request: CreateOrganizationUserRequest): CreateOrganizationUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrganizationUserWithOptions(request, runtime);
}

model CreateOwnAccountRequest {
  bizid?: string(name='Bizid'),
  identity?: string(name='Identity'),
  publicKey?: string(name='PublicKey'),
  recoveryKey?: string(name='RecoveryKey'),
}

model CreateOwnAccountResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model CreateOwnAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOwnAccountResponseBody(name='body'),
}

/**
 * @param request CreateOwnAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOwnAccountResponse
 */
async function createOwnAccountWithOptions(request: CreateOwnAccountRequest, runtime: Util.RuntimeOptions): CreateOwnAccountResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.identity)) {
    body['Identity'] = request.identity;
  }
  if (!Util.isUnset(request.publicKey)) {
    body['PublicKey'] = request.publicKey;
  }
  if (!Util.isUnset(request.recoveryKey)) {
    body['RecoveryKey'] = request.recoveryKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOwnAccount',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateOwnAccountRequest
 * @return CreateOwnAccountResponse
 */
async function createOwnAccount(request: CreateOwnAccountRequest): CreateOwnAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOwnAccountWithOptions(request, runtime);
}

model CreatePublicAccountWithKeyPairAutoCreationRequest {
  account?: string(name='Account'),
  bizid?: string(name='Bizid'),
  password?: string(name='Password'),
  recoverPassword?: string(name='RecoverPassword'),
}

model CreatePublicAccountWithKeyPairAutoCreationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    accountPrivateKey?: string(name='AccountPrivateKey'),
    accountPublicKey?: string(name='AccountPublicKey'),
    accountRecoverPrivateKey?: string(name='AccountRecoverPrivateKey'),
    accountRecoverPublicKey?: string(name='AccountRecoverPublicKey'),
  }(name='Result'),
}

model CreatePublicAccountWithKeyPairAutoCreationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePublicAccountWithKeyPairAutoCreationResponseBody(name='body'),
}

/**
 * @param request CreatePublicAccountWithKeyPairAutoCreationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePublicAccountWithKeyPairAutoCreationResponse
 */
async function createPublicAccountWithKeyPairAutoCreationWithOptions(request: CreatePublicAccountWithKeyPairAutoCreationRequest, runtime: Util.RuntimeOptions): CreatePublicAccountWithKeyPairAutoCreationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.account)) {
    body['Account'] = request.account;
  }
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.recoverPassword)) {
    body['RecoverPassword'] = request.recoverPassword;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePublicAccountWithKeyPairAutoCreation',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreatePublicAccountWithKeyPairAutoCreationRequest
 * @return CreatePublicAccountWithKeyPairAutoCreationResponse
 */
async function createPublicAccountWithKeyPairAutoCreation(request: CreatePublicAccountWithKeyPairAutoCreationRequest): CreatePublicAccountWithKeyPairAutoCreationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPublicAccountWithKeyPairAutoCreationWithOptions(request, runtime);
}

model CreatePublicAntChainAccountRequest {
  account?: string(name='Account'),
  accountPubKey?: string(name='AccountPubKey'),
  accountRecoverPubKey?: string(name='AccountRecoverPubKey'),
  bizid?: string(name='Bizid'),
}

model CreatePublicAntChainAccountResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model CreatePublicAntChainAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePublicAntChainAccountResponseBody(name='body'),
}

/**
 * @param request CreatePublicAntChainAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePublicAntChainAccountResponse
 */
async function createPublicAntChainAccountWithOptions(request: CreatePublicAntChainAccountRequest, runtime: Util.RuntimeOptions): CreatePublicAntChainAccountResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.account)) {
    body['Account'] = request.account;
  }
  if (!Util.isUnset(request.accountPubKey)) {
    body['AccountPubKey'] = request.accountPubKey;
  }
  if (!Util.isUnset(request.accountRecoverPubKey)) {
    body['AccountRecoverPubKey'] = request.accountRecoverPubKey;
  }
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePublicAntChainAccount',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreatePublicAntChainAccountRequest
 * @return CreatePublicAntChainAccountResponse
 */
async function createPublicAntChainAccount(request: CreatePublicAntChainAccountRequest): CreatePublicAntChainAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPublicAntChainAccountWithOptions(request, runtime);
}

model CreateSmartContractJobResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    accessId?: string(name='AccessId'),
    dir?: int32(name='Dir'),
    expire?: long(name='Expire'),
    host?: string(name='Host'),
    jobID?: string(name='JobID'),
    policy?: string(name='Policy'),
    signature?: string(name='Signature'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model CreateSmartContractJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSmartContractJobResponseBody(name='body'),
}

/**
 * @param request CreateSmartContractJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSmartContractJobResponse
 */
async function createSmartContractJobWithOptions(runtime: Util.RuntimeOptions): CreateSmartContractJobResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'CreateSmartContractJob',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return CreateSmartContractJobResponse
 */
async function createSmartContractJob(): CreateSmartContractJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSmartContractJobWithOptions(runtime);
}

model CreateTriggerRequest {
  channelId?: string(name='ChannelId', description='This parameter is required.'),
  name?: string(name='Name', description='This parameter is required.'),
  options?: string(name='Options'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
  source?: string(name='Source', description='This parameter is required.'),
  status?: string(name='Status'),
  type?: string(name='Type', description='This parameter is required.'),
}

model CreateTriggerResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    channelId?: string(name='ChannelId'),
    channelName?: string(name='ChannelName'),
    createTime?: long(name='CreateTime'),
    errorMessage?: string(name='ErrorMessage'),
    name?: string(name='Name'),
    options?: string(name='Options'),
    source?: string(name='Source'),
    status?: int32(name='Status'),
    type?: string(name='Type'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model CreateTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateTriggerResponseBody(name='body'),
}

/**
 * @param request CreateTriggerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTriggerResponse
 */
async function createTriggerWithOptions(request: CreateTriggerRequest, runtime: Util.RuntimeOptions): CreateTriggerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.options)) {
    body['Options'] = request.options;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.source)) {
    body['Source'] = request.source;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTrigger',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateTriggerRequest
 * @return CreateTriggerResponse
 */
async function createTrigger(request: CreateTriggerRequest): CreateTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTriggerWithOptions(request, runtime);
}

model DeleteAntChainConsortiumRequest {
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.'),
}

model DeleteAntChainConsortiumResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model DeleteAntChainConsortiumResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAntChainConsortiumResponseBody(name='body'),
}

/**
 * @param request DeleteAntChainConsortiumRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAntChainConsortiumResponse
 */
async function deleteAntChainConsortiumWithOptions(request: DeleteAntChainConsortiumRequest, runtime: Util.RuntimeOptions): DeleteAntChainConsortiumResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAntChainConsortium',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteAntChainConsortiumRequest
 * @return DeleteAntChainConsortiumResponse
 */
async function deleteAntChainConsortium(request: DeleteAntChainConsortiumRequest): DeleteAntChainConsortiumResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAntChainConsortiumWithOptions(request, runtime);
}

model DeleteAntChainContractContentRequest {
  contentId?: string(name='ContentId', description='This parameter is required.'),
}

model DeleteAntChainContractContentResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model DeleteAntChainContractContentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAntChainContractContentResponseBody(name='body'),
}

/**
 * @param request DeleteAntChainContractContentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAntChainContractContentResponse
 */
async function deleteAntChainContractContentWithOptions(request: DeleteAntChainContractContentRequest, runtime: Util.RuntimeOptions): DeleteAntChainContractContentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.contentId)) {
    body['ContentId'] = request.contentId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAntChainContractContent',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteAntChainContractContentRequest
 * @return DeleteAntChainContractContentResponse
 */
async function deleteAntChainContractContent(request: DeleteAntChainContractContentRequest): DeleteAntChainContractContentResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAntChainContractContentWithOptions(request, runtime);
}

model DeleteAntChainContractProjectRequest {
  projectId?: string(name='ProjectId', description='This parameter is required.'),
}

model DeleteAntChainContractProjectResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model DeleteAntChainContractProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAntChainContractProjectResponseBody(name='body'),
}

/**
 * @param request DeleteAntChainContractProjectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAntChainContractProjectResponse
 */
async function deleteAntChainContractProjectWithOptions(request: DeleteAntChainContractProjectRequest, runtime: Util.RuntimeOptions): DeleteAntChainContractProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAntChainContractProject',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteAntChainContractProjectRequest
 * @return DeleteAntChainContractProjectResponse
 */
async function deleteAntChainContractProject(request: DeleteAntChainContractProjectRequest): DeleteAntChainContractProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAntChainContractProjectWithOptions(request, runtime);
}

model DeleteAntChainMiniAppQRCodeAuthorizedUserRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  phone?: string(name='Phone', description='This parameter is required.'),
}

model DeleteAntChainMiniAppQRCodeAuthorizedUserResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model DeleteAntChainMiniAppQRCodeAuthorizedUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAntChainMiniAppQRCodeAuthorizedUserResponseBody(name='body'),
}

/**
 * @param request DeleteAntChainMiniAppQRCodeAuthorizedUserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAntChainMiniAppQRCodeAuthorizedUserResponse
 */
async function deleteAntChainMiniAppQRCodeAuthorizedUserWithOptions(request: DeleteAntChainMiniAppQRCodeAuthorizedUserRequest, runtime: Util.RuntimeOptions): DeleteAntChainMiniAppQRCodeAuthorizedUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.phone)) {
    body['Phone'] = request.phone;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAntChainMiniAppQRCodeAuthorizedUser',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteAntChainMiniAppQRCodeAuthorizedUserRequest
 * @return DeleteAntChainMiniAppQRCodeAuthorizedUserResponse
 */
async function deleteAntChainMiniAppQRCodeAuthorizedUser(request: DeleteAntChainMiniAppQRCodeAuthorizedUserRequest): DeleteAntChainMiniAppQRCodeAuthorizedUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAntChainMiniAppQRCodeAuthorizedUserWithOptions(request, runtime);
}

model DeleteChaincodeRequest {
  chaincodeId?: string(name='ChaincodeId', example='code-sacc-1pr09q7jm****'),
}

model DeleteChaincodeResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='@guid'),
  success?: boolean(name='Success', example='true'),
}

model DeleteChaincodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteChaincodeResponseBody(name='body'),
}

/**
 * @param request DeleteChaincodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteChaincodeResponse
 */
async function deleteChaincodeWithOptions(request: DeleteChaincodeRequest, runtime: Util.RuntimeOptions): DeleteChaincodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.chaincodeId)) {
    body['ChaincodeId'] = request.chaincodeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteChaincode',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteChaincodeRequest
 * @return DeleteChaincodeResponse
 */
async function deleteChaincode(request: DeleteChaincodeRequest): DeleteChaincodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteChaincodeWithOptions(request, runtime);
}

model DeleteGovernanceTaskRequest {
  channelId?: string(name='ChannelId', description='This parameter is required.'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
  taskId?: string(name='TaskId', description='This parameter is required.'),
}

model DeleteGovernanceTaskResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    channelName?: string(name='ChannelName'),
    content?: {
      addedOrganizations?: [ 
        {
          anchorPeers?: [ 
            {
              host?: string(name='Host'),
              port?: int32(name='Port'),
            }
          ](name='AnchorPeers'),
          crls?: string(name='Crls'),
          mspId?: string(name='MspId'),
          mspType?: string(name='MspType'),
          orderer?: boolean(name='Orderer'),
          ordererNodes?: [ 
            {
              address?: string(name='Address'),
              certificate?: string(name='Certificate'),
              key?: string(name='Key'),
              tlsroot?: string(name='Tlsroot'),
            }
          ](name='OrdererNodes'),
          rootCertificates?: string(name='RootCertificates'),
          tlsRootCertificates?: string(name='TlsRootCertificates'),
        }
      ](name='AddedOrganizations'),
      chaincodeSpecPkg?: {
        cs?: {
          input?: string(name='Input'),
          name?: string(name='Name'),
          path?: string(name='Path'),
          type?: int32(name='Type'),
          version?: string(name='Version'),
        }(name='Cs'),
        policy?: string(name='Policy'),
        sha256?: string(name='Sha256'),
      }(name='ChaincodeSpecPkg'),
      ordererConfig?: {
        batchTimeout?: string(name='BatchTimeout'),
        maxMessageCount?: int32(name='MaxMessageCount'),
        preferredMaxBytes?: int32(name='PreferredMaxBytes'),
      }(name='OrdererConfig'),
      raw?: string(name='Raw'),
      removedOrganizations?: [ 
        {
          anchorPeers?: [ 
            {
              host?: string(name='Host'),
              port?: int32(name='Port'),
            }
          ](name='AnchorPeers'),
          crls?: string(name='Crls'),
          mspId?: string(name='MspId'),
          mspType?: string(name='MspType'),
          orderer?: boolean(name='Orderer'),
          ordererNodes?: [ 
            {
              address?: string(name='Address'),
              certificate?: string(name='Certificate'),
              key?: string(name='Key'),
              tlsroot?: string(name='Tlsroot'),
            }
          ](name='OrdererNodes'),
          rootCertificates?: string(name='RootCertificates'),
          tlsRootCertificates?: string(name='TlsRootCertificates'),
        }
      ](name='RemovedOrganizations'),
      rwSets?: string(name='RwSets'),
    }(name='Content'),
    createTime?: long(name='CreateTime'),
    creator?: string(name='Creator'),
    description?: string(name='Description'),
    status?: string(name='Status'),
    taskId?: string(name='TaskId'),
    type?: string(name='Type'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteGovernanceTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteGovernanceTaskResponseBody(name='body'),
}

/**
 * @param request DeleteGovernanceTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteGovernanceTaskResponse
 */
async function deleteGovernanceTaskWithOptions(request: DeleteGovernanceTaskRequest, runtime: Util.RuntimeOptions): DeleteGovernanceTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGovernanceTask',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteGovernanceTaskRequest
 * @return DeleteGovernanceTaskResponse
 */
async function deleteGovernanceTask(request: DeleteGovernanceTaskRequest): DeleteGovernanceTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGovernanceTaskWithOptions(request, runtime);
}

model DeleteTriggerRequest {
  channelId?: string(name='ChannelId', description='This parameter is required.'),
  name?: string(name='Name', description='This parameter is required.'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model DeleteTriggerResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    channelId?: string(name='ChannelId'),
    channelName?: string(name='ChannelName'),
    checkpoint?: {
      errorCount?: long(name='ErrorCount'),
      height?: long(name='Height'),
      index?: long(name='Index'),
      type?: string(name='Type'),
    }(name='Checkpoint'),
    createTime?: long(name='CreateTime'),
    errorMessage?: string(name='ErrorMessage'),
    name?: string(name='Name'),
    options?: string(name='Options'),
    source?: string(name='Source'),
    status?: int32(name='Status'),
    type?: string(name='Type'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTriggerResponseBody(name='body'),
}

/**
 * @param request DeleteTriggerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTriggerResponse
 */
async function deleteTriggerWithOptions(request: DeleteTriggerRequest, runtime: Util.RuntimeOptions): DeleteTriggerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channelId)) {
    query['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTrigger',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteTriggerRequest
 * @return DeleteTriggerResponse
 */
async function deleteTrigger(request: DeleteTriggerRequest): DeleteTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTriggerWithOptions(request, runtime);
}

model DescribeAntChainAccountsRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
}

model DescribeAntChainAccountsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    accounts?: [ 
      {
        account?: string(name='Account'),
        accountPublicKey?: string(name='AccountPublicKey'),
        accountRecoveryKey?: string(name='AccountRecoveryKey'),
        accountStatus?: string(name='AccountStatus'),
        antChainId?: string(name='AntChainId'),
      }
    ](name='Accounts'),
    pagination?: {
      pageNumber?: int32(name='PageNumber'),
      pageSize?: int32(name='PageSize'),
      totalCount?: int32(name='TotalCount'),
    }(name='Pagination'),
  }(name='Result'),
}

model DescribeAntChainAccountsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainAccountsResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainAccountsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainAccountsResponse
 */
async function describeAntChainAccountsWithOptions(request: DescribeAntChainAccountsRequest, runtime: Util.RuntimeOptions): DescribeAntChainAccountsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainAccounts',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainAccountsRequest
 * @return DescribeAntChainAccountsResponse
 */
async function describeAntChainAccounts(request: DescribeAntChainAccountsRequest): DescribeAntChainAccountsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainAccountsWithOptions(request, runtime);
}

model DescribeAntChainAccountsNewRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  consortiumId?: string(name='ConsortiumId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
}

model DescribeAntChainAccountsNewResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: {
    accounts?: [ 
      {
        account?: string(name='Account'),
        accountPublicKey?: string(name='AccountPublicKey'),
        accountRecoveryKey?: string(name='AccountRecoveryKey'),
        accountStatus?: string(name='AccountStatus'),
        antChainId?: string(name='AntChainId'),
        createTime?: long(name='CreateTime'),
        memberName?: string(name='MemberName'),
      }
    ](name='Accounts'),
    consortiumAdmin?: boolean(name='ConsortiumAdmin'),
    pagination?: {
      pageNumber?: int32(name='PageNumber'),
      pageSize?: int32(name='PageSize'),
      totalCount?: int32(name='TotalCount'),
    }(name='Pagination'),
  }(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model DescribeAntChainAccountsNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainAccountsNewResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainAccountsNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainAccountsNewResponse
 */
async function describeAntChainAccountsNewWithOptions(request: DescribeAntChainAccountsNewRequest, runtime: Util.RuntimeOptions): DescribeAntChainAccountsNewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainAccountsNew',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainAccountsNewRequest
 * @return DescribeAntChainAccountsNewResponse
 */
async function describeAntChainAccountsNew(request: DescribeAntChainAccountsNewRequest): DescribeAntChainAccountsNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainAccountsNewWithOptions(request, runtime);
}

model DescribeAntChainApplicationsRequest {
  bizid?: string(name='Bizid'),
  current?: int32(name='Current'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
}

model DescribeAntChainApplicationsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    applyHistoryList?: [ 
      {
        bizid?: string(name='Bizid'),
        createtime?: long(name='Createtime'),
        id?: int32(name='Id'),
        rejectReason?: string(name='RejectReason'),
        reqAddr?: string(name='ReqAddr'),
        signedAddr?: string(name='SignedAddr'),
        status?: int32(name='Status'),
        updatetime?: long(name='Updatetime'),
        username?: string(name='Username'),
      }
    ](name='ApplyHistoryList'),
    pagination?: {
      current?: int32(name='Current'),
      pageSize?: int32(name='PageSize'),
      total?: int32(name='Total'),
    }(name='Pagination'),
  }(name='Result'),
}

model DescribeAntChainApplicationsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainApplicationsResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainApplicationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainApplicationsResponse
 */
async function describeAntChainApplicationsWithOptions(request: DescribeAntChainApplicationsRequest, runtime: Util.RuntimeOptions): DescribeAntChainApplicationsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainApplications',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainApplicationsRequest
 * @return DescribeAntChainApplicationsResponse
 */
async function describeAntChainApplications(request: DescribeAntChainApplicationsRequest): DescribeAntChainApplicationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainApplicationsWithOptions(request, runtime);
}

model DescribeAntChainBlockRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  height?: long(name='Height', description='This parameter is required.'),
}

model DescribeAntChainBlockResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    antChainId?: string(name='AntChainId'),
    blockHash?: string(name='BlockHash'),
    createTime?: long(name='CreateTime'),
    height?: int32(name='Height'),
    previousHash?: string(name='PreviousHash'),
    rootTxHash?: string(name='RootTxHash'),
    transSummaryList?: string(name='TransSummaryList'),
    transactionSize?: int32(name='TransactionSize'),
    version?: long(name='Version'),
  }(name='Result'),
}

model DescribeAntChainBlockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainBlockResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainBlockRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainBlockResponse
 */
async function describeAntChainBlockWithOptions(request: DescribeAntChainBlockRequest, runtime: Util.RuntimeOptions): DescribeAntChainBlockResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.height)) {
    body['Height'] = request.height;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainBlock',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainBlockRequest
 * @return DescribeAntChainBlockResponse
 */
async function describeAntChainBlock(request: DescribeAntChainBlockRequest): DescribeAntChainBlockResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainBlockWithOptions(request, runtime);
}

model DescribeAntChainBlockNewRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  consortiumId?: string(name='ConsortiumId'),
  height?: long(name='Height', description='This parameter is required.'),
}

model DescribeAntChainBlockNewResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: {
    antChainId?: string(name='AntChainId'),
    blockHash?: string(name='BlockHash'),
    createTime?: long(name='CreateTime'),
    height?: int32(name='Height'),
    previousHash?: string(name='PreviousHash'),
    rootTxHash?: string(name='RootTxHash'),
    transSummaryList?: [ 
      {
        alias?: string(name='Alias'),
        blockHash?: string(name='BlockHash'),
        category?: int32(name='Category'),
        createTime?: long(name='CreateTime'),
        from?: string(name='From'),
        gasUsed?: long(name='GasUsed'),
        hash?: string(name='Hash'),
        height?: long(name='Height'),
        referenceCount?: int32(name='ReferenceCount'),
        to?: string(name='To'),
        transTypeV10?: string(name='TransTypeV10'),
        transTypeV6?: string(name='TransTypeV6'),
      }
    ](name='TransSummaryList'),
    transactionSize?: int32(name='TransactionSize'),
    version?: long(name='Version'),
  }(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model DescribeAntChainBlockNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainBlockNewResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainBlockNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainBlockNewResponse
 */
async function describeAntChainBlockNewWithOptions(request: DescribeAntChainBlockNewRequest, runtime: Util.RuntimeOptions): DescribeAntChainBlockNewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.height)) {
    body['Height'] = request.height;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainBlockNew',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainBlockNewRequest
 * @return DescribeAntChainBlockNewResponse
 */
async function describeAntChainBlockNew(request: DescribeAntChainBlockNewRequest): DescribeAntChainBlockNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainBlockNewWithOptions(request, runtime);
}

model DescribeAntChainCertificateApplicationsRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  status?: string(name='Status', description='This parameter is required.'),
}

model DescribeAntChainCertificateApplicationsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    certificateApplications?: [ 
      {
        antChainId?: string(name='AntChainId'),
        bid?: string(name='Bid'),
        createtime?: long(name='Createtime'),
        status?: string(name='Status'),
        updatetime?: long(name='Updatetime'),
        username?: string(name='Username'),
      }
    ](name='CertificateApplications'),
    pagination?: {
      pageNumber?: int32(name='PageNumber'),
      pageSize?: int32(name='PageSize'),
      totalCount?: int32(name='TotalCount'),
    }(name='Pagination'),
  }(name='Result'),
}

model DescribeAntChainCertificateApplicationsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainCertificateApplicationsResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainCertificateApplicationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainCertificateApplicationsResponse
 */
async function describeAntChainCertificateApplicationsWithOptions(request: DescribeAntChainCertificateApplicationsRequest, runtime: Util.RuntimeOptions): DescribeAntChainCertificateApplicationsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainCertificateApplications',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainCertificateApplicationsRequest
 * @return DescribeAntChainCertificateApplicationsResponse
 */
async function describeAntChainCertificateApplications(request: DescribeAntChainCertificateApplicationsRequest): DescribeAntChainCertificateApplicationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainCertificateApplicationsWithOptions(request, runtime);
}

model DescribeAntChainCertificateApplicationsNewRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  consortiumId?: string(name='ConsortiumId'),
  pageNumber?: int32(name='PageNumber', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  status?: string(name='Status', description='This parameter is required.'),
}

model DescribeAntChainCertificateApplicationsNewResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: {
    certificateApplications?: [ 
      {
        antChainId?: string(name='AntChainId'),
        bid?: string(name='Bid'),
        createtime?: long(name='Createtime'),
        status?: string(name='Status'),
        updatetime?: long(name='Updatetime'),
        username?: string(name='Username'),
      }
    ](name='CertificateApplications'),
    pagination?: {
      pageNumber?: int32(name='PageNumber'),
      pageSize?: int32(name='PageSize'),
      totalCount?: int32(name='TotalCount'),
    }(name='Pagination'),
  }(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model DescribeAntChainCertificateApplicationsNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainCertificateApplicationsNewResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainCertificateApplicationsNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainCertificateApplicationsNewResponse
 */
async function describeAntChainCertificateApplicationsNewWithOptions(request: DescribeAntChainCertificateApplicationsNewRequest, runtime: Util.RuntimeOptions): DescribeAntChainCertificateApplicationsNewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainCertificateApplicationsNew',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainCertificateApplicationsNewRequest
 * @return DescribeAntChainCertificateApplicationsNewResponse
 */
async function describeAntChainCertificateApplicationsNew(request: DescribeAntChainCertificateApplicationsNewRequest): DescribeAntChainCertificateApplicationsNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainCertificateApplicationsNewWithOptions(request, runtime);
}

model DescribeAntChainConfigOptionsRequest {
  purpose?: string(name='Purpose'),
}

model DescribeAntChainConfigOptionsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: map[string]any(name='Result'),
}

model DescribeAntChainConfigOptionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainConfigOptionsResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainConfigOptionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainConfigOptionsResponse
 */
async function describeAntChainConfigOptionsWithOptions(request: DescribeAntChainConfigOptionsRequest, runtime: Util.RuntimeOptions): DescribeAntChainConfigOptionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.purpose)) {
    query['Purpose'] = request.purpose;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainConfigOptions',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainConfigOptionsRequest
 * @return DescribeAntChainConfigOptionsResponse
 */
async function describeAntChainConfigOptions(request: DescribeAntChainConfigOptionsRequest): DescribeAntChainConfigOptionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainConfigOptionsWithOptions(request, runtime);
}

model DescribeAntChainConsortiumsRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
}

model DescribeAntChainConsortiumsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    antConsortiums?: [ 
      {
        chainNum?: long(name='ChainNum'),
        consortiumDescription?: string(name='ConsortiumDescription'),
        consortiumId?: string(name='ConsortiumId'),
        consortiumName?: string(name='ConsortiumName'),
        createTime?: long(name='CreateTime'),
        isEmptyConsortium?: boolean(name='IsEmptyConsortium'),
        memberNum?: long(name='MemberNum'),
        role?: string(name='Role'),
        status?: string(name='Status'),
      }
    ](name='AntConsortiums'),
    pagination?: {
      pageNumber?: int32(name='PageNumber'),
      pageSize?: int32(name='PageSize'),
      totalCount?: int32(name='TotalCount'),
    }(name='Pagination'),
  }(name='Result'),
}

model DescribeAntChainConsortiumsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainConsortiumsResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainConsortiumsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainConsortiumsResponse
 */
async function describeAntChainConsortiumsWithOptions(request: DescribeAntChainConsortiumsRequest, runtime: Util.RuntimeOptions): DescribeAntChainConsortiumsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainConsortiums',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainConsortiumsRequest
 * @return DescribeAntChainConsortiumsResponse
 */
async function describeAntChainConsortiums(request: DescribeAntChainConsortiumsRequest): DescribeAntChainConsortiumsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainConsortiumsWithOptions(request, runtime);
}

model DescribeAntChainConsortiumsNewRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
}

model DescribeAntChainConsortiumsNewResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: {
    antConsortiums?: [ 
      {
        chainNum?: long(name='ChainNum'),
        consortiumDescription?: string(name='ConsortiumDescription'),
        consortiumId?: string(name='ConsortiumId'),
        consortiumName?: string(name='ConsortiumName'),
        createTime?: long(name='CreateTime'),
        isEmptyConsortium?: boolean(name='IsEmptyConsortium'),
        memberNum?: long(name='MemberNum'),
        role?: string(name='Role'),
        status?: string(name='Status'),
      }
    ](name='AntConsortiums'),
    pagination?: {
      pageNumber?: int32(name='PageNumber'),
      pageSize?: int32(name='PageSize'),
      totalCount?: int32(name='TotalCount'),
    }(name='Pagination'),
  }(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model DescribeAntChainConsortiumsNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainConsortiumsNewResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainConsortiumsNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainConsortiumsNewResponse
 */
async function describeAntChainConsortiumsNewWithOptions(request: DescribeAntChainConsortiumsNewRequest, runtime: Util.RuntimeOptions): DescribeAntChainConsortiumsNewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainConsortiumsNew',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainConsortiumsNewRequest
 * @return DescribeAntChainConsortiumsNewResponse
 */
async function describeAntChainConsortiumsNew(request: DescribeAntChainConsortiumsNewRequest): DescribeAntChainConsortiumsNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainConsortiumsNewWithOptions(request, runtime);
}

model DescribeAntChainContractProjectContentTreeRequest {
  projectId?: string(name='ProjectId', description='This parameter is required.'),
}

model DescribeAntChainContractProjectContentTreeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    children?: [  map[string]any ](name='Children'),
    projectDescription?: string(name='ProjectDescription'),
    projectId?: string(name='ProjectId'),
    projectName?: string(name='ProjectName'),
    projectVersion?: string(name='ProjectVersion'),
  }(name='Result'),
}

model DescribeAntChainContractProjectContentTreeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainContractProjectContentTreeResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainContractProjectContentTreeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainContractProjectContentTreeResponse
 */
async function describeAntChainContractProjectContentTreeWithOptions(request: DescribeAntChainContractProjectContentTreeRequest, runtime: Util.RuntimeOptions): DescribeAntChainContractProjectContentTreeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainContractProjectContentTree',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainContractProjectContentTreeRequest
 * @return DescribeAntChainContractProjectContentTreeResponse
 */
async function describeAntChainContractProjectContentTree(request: DescribeAntChainContractProjectContentTreeRequest): DescribeAntChainContractProjectContentTreeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainContractProjectContentTreeWithOptions(request, runtime);
}

model DescribeAntChainContractProjectContentTreeNewRequest {
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.'),
  projectId?: string(name='ProjectId', description='This parameter is required.'),
}

model DescribeAntChainContractProjectContentTreeNewResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model DescribeAntChainContractProjectContentTreeNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainContractProjectContentTreeNewResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainContractProjectContentTreeNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainContractProjectContentTreeNewResponse
 */
async function describeAntChainContractProjectContentTreeNewWithOptions(request: DescribeAntChainContractProjectContentTreeNewRequest, runtime: Util.RuntimeOptions): DescribeAntChainContractProjectContentTreeNewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainContractProjectContentTreeNew',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainContractProjectContentTreeNewRequest
 * @return DescribeAntChainContractProjectContentTreeNewResponse
 */
async function describeAntChainContractProjectContentTreeNew(request: DescribeAntChainContractProjectContentTreeNewRequest): DescribeAntChainContractProjectContentTreeNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainContractProjectContentTreeNewWithOptions(request, runtime);
}

model DescribeAntChainContractProjectsRequest {
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
}

model DescribeAntChainContractProjectsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    contractProjects?: [ 
      {
        consortiumId?: string(name='ConsortiumId'),
        createTime?: long(name='CreateTime'),
        projectDescription?: string(name='ProjectDescription'),
        projectId?: string(name='ProjectId'),
        projectName?: string(name='ProjectName'),
        projectVersion?: string(name='ProjectVersion'),
        updateTime?: long(name='UpdateTime'),
      }
    ](name='ContractProjects'),
    pagination?: {
      pageNumber?: int32(name='PageNumber'),
      pageSize?: int32(name='PageSize'),
      totalCount?: int32(name='TotalCount'),
    }(name='Pagination'),
  }(name='Result'),
}

model DescribeAntChainContractProjectsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainContractProjectsResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainContractProjectsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainContractProjectsResponse
 */
async function describeAntChainContractProjectsWithOptions(request: DescribeAntChainContractProjectsRequest, runtime: Util.RuntimeOptions): DescribeAntChainContractProjectsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainContractProjects',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainContractProjectsRequest
 * @return DescribeAntChainContractProjectsResponse
 */
async function describeAntChainContractProjects(request: DescribeAntChainContractProjectsRequest): DescribeAntChainContractProjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainContractProjectsWithOptions(request, runtime);
}

model DescribeAntChainContractProjectsNewRequest {
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
}

model DescribeAntChainContractProjectsNewResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: {
    contractProjects?: [ 
      {
        consortiumId?: string(name='ConsortiumId'),
        createTime?: long(name='CreateTime'),
        projectDescription?: string(name='ProjectDescription'),
        projectId?: string(name='ProjectId'),
        projectName?: string(name='ProjectName'),
        projectVersion?: string(name='ProjectVersion'),
        updateTime?: long(name='UpdateTime'),
      }
    ](name='ContractProjects'),
    pagination?: {
      pageNumber?: int32(name='PageNumber'),
      pageSize?: int32(name='PageSize'),
      totalCount?: int32(name='TotalCount'),
    }(name='Pagination'),
  }(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model DescribeAntChainContractProjectsNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainContractProjectsNewResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainContractProjectsNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainContractProjectsNewResponse
 */
async function describeAntChainContractProjectsNewWithOptions(request: DescribeAntChainContractProjectsNewRequest, runtime: Util.RuntimeOptions): DescribeAntChainContractProjectsNewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainContractProjectsNew',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainContractProjectsNewRequest
 * @return DescribeAntChainContractProjectsNewResponse
 */
async function describeAntChainContractProjectsNew(request: DescribeAntChainContractProjectsNewRequest): DescribeAntChainContractProjectsNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainContractProjectsNewWithOptions(request, runtime);
}

model DescribeAntChainDownloadPathsRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
}

model DescribeAntChainDownloadPathsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    caCrtUrl?: string(name='CaCrtUrl'),
    clientCrtUrl?: string(name='ClientCrtUrl'),
    sdkUrl?: string(name='SdkUrl'),
    trustCaUrl?: string(name='TrustCaUrl'),
  }(name='Result'),
}

model DescribeAntChainDownloadPathsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainDownloadPathsResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainDownloadPathsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainDownloadPathsResponse
 */
async function describeAntChainDownloadPathsWithOptions(request: DescribeAntChainDownloadPathsRequest, runtime: Util.RuntimeOptions): DescribeAntChainDownloadPathsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainDownloadPaths',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainDownloadPathsRequest
 * @return DescribeAntChainDownloadPathsResponse
 */
async function describeAntChainDownloadPaths(request: DescribeAntChainDownloadPathsRequest): DescribeAntChainDownloadPathsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainDownloadPathsWithOptions(request, runtime);
}

model DescribeAntChainDownloadPathsNewRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  consortiumId?: string(name='ConsortiumId'),
}

model DescribeAntChainDownloadPathsNewResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: {
    caCrtUrl?: string(name='CaCrtUrl'),
    clientCrtUrl?: string(name='ClientCrtUrl'),
    sdkUrl?: string(name='SdkUrl'),
    trustCaUrl?: string(name='TrustCaUrl'),
  }(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model DescribeAntChainDownloadPathsNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainDownloadPathsNewResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainDownloadPathsNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainDownloadPathsNewResponse
 */
async function describeAntChainDownloadPathsNewWithOptions(request: DescribeAntChainDownloadPathsNewRequest, runtime: Util.RuntimeOptions): DescribeAntChainDownloadPathsNewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainDownloadPathsNew',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainDownloadPathsNewRequest
 * @return DescribeAntChainDownloadPathsNewResponse
 */
async function describeAntChainDownloadPathsNew(request: DescribeAntChainDownloadPathsNewRequest): DescribeAntChainDownloadPathsNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainDownloadPathsNewWithOptions(request, runtime);
}

model DescribeAntChainInformationRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
}

model DescribeAntChainInformationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    abnormalNodes?: int32(name='AbnormalNodes'),
    antChainId?: string(name='AntChainId'),
    blockHeight?: int32(name='BlockHeight'),
    createTime?: long(name='CreateTime'),
    isRole?: boolean(name='IsRole'),
    nodeInfos?: [ 
      {
        blockHeight?: long(name='BlockHeight'),
        nodeName?: string(name='NodeName'),
        status?: boolean(name='Status'),
        version?: string(name='Version'),
      }
    ](name='NodeInfos'),
    nodeNumber?: int32(name='NodeNumber'),
    normal?: boolean(name='Normal'),
    transactionSum?: int32(name='TransactionSum'),
    version?: string(name='Version'),
  }(name='Result'),
}

model DescribeAntChainInformationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainInformationResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainInformationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainInformationResponse
 */
async function describeAntChainInformationWithOptions(request: DescribeAntChainInformationRequest, runtime: Util.RuntimeOptions): DescribeAntChainInformationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainInformation',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainInformationRequest
 * @return DescribeAntChainInformationResponse
 */
async function describeAntChainInformation(request: DescribeAntChainInformationRequest): DescribeAntChainInformationResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainInformationWithOptions(request, runtime);
}

model DescribeAntChainInformationNewRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  consortiumId?: string(name='ConsortiumId'),
}

model DescribeAntChainInformationNewResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: {
    abnormalNodes?: int32(name='AbnormalNodes'),
    antChainId?: string(name='AntChainId'),
    blockHeight?: int32(name='BlockHeight'),
    createTime?: long(name='CreateTime'),
    isRole?: boolean(name='IsRole'),
    nodeInfos?: [ 
      {
        blockHeight?: long(name='BlockHeight'),
        nodeName?: string(name='NodeName'),
        status?: boolean(name='Status'),
        version?: string(name='Version'),
      }
    ](name='NodeInfos'),
    nodeNumber?: int32(name='NodeNumber'),
    normal?: boolean(name='Normal'),
    transactionSum?: int32(name='TransactionSum'),
    version?: string(name='Version'),
  }(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model DescribeAntChainInformationNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainInformationNewResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainInformationNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainInformationNewResponse
 */
async function describeAntChainInformationNewWithOptions(request: DescribeAntChainInformationNewRequest, runtime: Util.RuntimeOptions): DescribeAntChainInformationNewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainInformationNew',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainInformationNewRequest
 * @return DescribeAntChainInformationNewResponse
 */
async function describeAntChainInformationNew(request: DescribeAntChainInformationNewRequest): DescribeAntChainInformationNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainInformationNewWithOptions(request, runtime);
}

model DescribeAntChainLatestBlocksRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
}

model DescribeAntChainLatestBlocksResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [  map[string]any ](name='Result'),
}

model DescribeAntChainLatestBlocksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainLatestBlocksResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainLatestBlocksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainLatestBlocksResponse
 */
async function describeAntChainLatestBlocksWithOptions(request: DescribeAntChainLatestBlocksRequest, runtime: Util.RuntimeOptions): DescribeAntChainLatestBlocksResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainLatestBlocks',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainLatestBlocksRequest
 * @return DescribeAntChainLatestBlocksResponse
 */
async function describeAntChainLatestBlocks(request: DescribeAntChainLatestBlocksRequest): DescribeAntChainLatestBlocksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainLatestBlocksWithOptions(request, runtime);
}

model DescribeAntChainLatestBlocksNewRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  consortiumId?: string(name='ConsortiumId'),
}

model DescribeAntChainLatestBlocksNewResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      alias?: string(name='Alias'),
      bizData?: string(name='BizData'),
      blockHash?: string(name='BlockHash'),
      createTime?: long(name='CreateTime'),
      height?: long(name='Height'),
      previousHash?: string(name='PreviousHash'),
      rootTxHash?: string(name='RootTxHash'),
      size?: long(name='Size'),
      transactionSize?: long(name='TransactionSize'),
      version?: long(name='Version'),
    }
  ](name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model DescribeAntChainLatestBlocksNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainLatestBlocksNewResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainLatestBlocksNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainLatestBlocksNewResponse
 */
async function describeAntChainLatestBlocksNewWithOptions(request: DescribeAntChainLatestBlocksNewRequest, runtime: Util.RuntimeOptions): DescribeAntChainLatestBlocksNewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainLatestBlocksNew',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainLatestBlocksNewRequest
 * @return DescribeAntChainLatestBlocksNewResponse
 */
async function describeAntChainLatestBlocksNew(request: DescribeAntChainLatestBlocksNewRequest): DescribeAntChainLatestBlocksNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainLatestBlocksNewWithOptions(request, runtime);
}

model DescribeAntChainLatestTransactionDigestsRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
}

model DescribeAntChainLatestTransactionDigestsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [  map[string]any ](name='Result'),
}

model DescribeAntChainLatestTransactionDigestsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainLatestTransactionDigestsResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainLatestTransactionDigestsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainLatestTransactionDigestsResponse
 */
async function describeAntChainLatestTransactionDigestsWithOptions(request: DescribeAntChainLatestTransactionDigestsRequest, runtime: Util.RuntimeOptions): DescribeAntChainLatestTransactionDigestsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainLatestTransactionDigests',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainLatestTransactionDigestsRequest
 * @return DescribeAntChainLatestTransactionDigestsResponse
 */
async function describeAntChainLatestTransactionDigests(request: DescribeAntChainLatestTransactionDigestsRequest): DescribeAntChainLatestTransactionDigestsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainLatestTransactionDigestsWithOptions(request, runtime);
}

model DescribeAntChainLatestTransactionDigestsNewRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  consortiumId?: string(name='ConsortiumId'),
}

model DescribeAntChainLatestTransactionDigestsNewResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model DescribeAntChainLatestTransactionDigestsNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainLatestTransactionDigestsNewResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainLatestTransactionDigestsNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainLatestTransactionDigestsNewResponse
 */
async function describeAntChainLatestTransactionDigestsNewWithOptions(request: DescribeAntChainLatestTransactionDigestsNewRequest, runtime: Util.RuntimeOptions): DescribeAntChainLatestTransactionDigestsNewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainLatestTransactionDigestsNew',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainLatestTransactionDigestsNewRequest
 * @return DescribeAntChainLatestTransactionDigestsNewResponse
 */
async function describeAntChainLatestTransactionDigestsNew(request: DescribeAntChainLatestTransactionDigestsNewRequest): DescribeAntChainLatestTransactionDigestsNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainLatestTransactionDigestsNewWithOptions(request, runtime);
}

model DescribeAntChainMembersRequest {
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
}

model DescribeAntChainMembersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    members?: [ 
      {
        joinTime?: long(name='JoinTime'),
        memberId?: string(name='MemberId'),
        memberName?: string(name='MemberName'),
        role?: string(name='Role'),
        status?: string(name='Status'),
      }
    ](name='Members'),
    pagination?: {
      pageNumber?: int32(name='PageNumber'),
      pageSize?: int32(name='PageSize'),
      totalCount?: int32(name='TotalCount'),
    }(name='Pagination'),
  }(name='Result'),
}

model DescribeAntChainMembersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainMembersResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainMembersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainMembersResponse
 */
async function describeAntChainMembersWithOptions(request: DescribeAntChainMembersRequest, runtime: Util.RuntimeOptions): DescribeAntChainMembersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainMembers',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainMembersRequest
 * @return DescribeAntChainMembersResponse
 */
async function describeAntChainMembers(request: DescribeAntChainMembersRequest): DescribeAntChainMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainMembersWithOptions(request, runtime);
}

model DescribeAntChainMembersNewRequest {
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
}

model DescribeAntChainMembersNewResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: {
    members?: [ 
      {
        joinTime?: long(name='JoinTime'),
        memberId?: string(name='MemberId'),
        memberName?: string(name='MemberName'),
        role?: string(name='Role'),
        status?: string(name='Status'),
      }
    ](name='Members'),
    pagination?: {
      pageNumber?: int32(name='PageNumber'),
      pageSize?: int32(name='PageSize'),
      totalCount?: int32(name='TotalCount'),
    }(name='Pagination'),
  }(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model DescribeAntChainMembersNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainMembersNewResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainMembersNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainMembersNewResponse
 */
async function describeAntChainMembersNewWithOptions(request: DescribeAntChainMembersNewRequest, runtime: Util.RuntimeOptions): DescribeAntChainMembersNewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainMembersNew',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainMembersNewRequest
 * @return DescribeAntChainMembersNewResponse
 */
async function describeAntChainMembersNew(request: DescribeAntChainMembersNewRequest): DescribeAntChainMembersNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainMembersNewWithOptions(request, runtime);
}

model DescribeAntChainMiniAppBrowserQRCodeAccessLogRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  QRCodeType?: string(name='QRCodeType', description='This parameter is required.'),
}

model DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    accessAlipayAccountCount?: long(name='AccessAlipayAccountCount'),
    accessCount?: long(name='AccessCount'),
  }(name='Result'),
}

model DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainMiniAppBrowserQRCodeAccessLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse
 */
async function describeAntChainMiniAppBrowserQRCodeAccessLogWithOptions(request: DescribeAntChainMiniAppBrowserQRCodeAccessLogRequest, runtime: Util.RuntimeOptions): DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.QRCodeType)) {
    body['QRCodeType'] = request.QRCodeType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainMiniAppBrowserQRCodeAccessLog',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainMiniAppBrowserQRCodeAccessLogRequest
 * @return DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse
 */
async function describeAntChainMiniAppBrowserQRCodeAccessLog(request: DescribeAntChainMiniAppBrowserQRCodeAccessLogRequest): DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainMiniAppBrowserQRCodeAccessLogWithOptions(request, runtime);
}

model DescribeAntChainMiniAppBrowserQRCodeAccessLogNewRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  QRCodeType?: string(name='QRCodeType', description='This parameter is required.'),
}

model DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: {
    accessAlipayAccountCount?: long(name='AccessAlipayAccountCount'),
    accessCount?: long(name='AccessCount'),
  }(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainMiniAppBrowserQRCodeAccessLogNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponse
 */
async function describeAntChainMiniAppBrowserQRCodeAccessLogNewWithOptions(request: DescribeAntChainMiniAppBrowserQRCodeAccessLogNewRequest, runtime: Util.RuntimeOptions): DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.QRCodeType)) {
    body['QRCodeType'] = request.QRCodeType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainMiniAppBrowserQRCodeAccessLogNew',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainMiniAppBrowserQRCodeAccessLogNewRequest
 * @return DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponse
 */
async function describeAntChainMiniAppBrowserQRCodeAccessLogNew(request: DescribeAntChainMiniAppBrowserQRCodeAccessLogNewRequest): DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainMiniAppBrowserQRCodeAccessLogNewWithOptions(request, runtime);
}

model DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  QRCodeType?: string(name='QRCodeType', description='This parameter is required.'),
}

model DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    antChainId?: string(name='AntChainId'),
    authorizationType?: string(name='AuthorizationType'),
    authorizedUserList?: [ 
      {
        gmtAuthorized?: string(name='GmtAuthorized'),
        phone?: string(name='Phone'),
      }
    ](name='AuthorizedUserList'),
    pagination?: {
      pageNumber?: int32(name='PageNumber'),
      pageSize?: int32(name='PageSize'),
      totalCount?: int32(name='TotalCount'),
    }(name='Pagination'),
    QRCodeType?: string(name='QRCodeType'),
  }(name='Result'),
}

model DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse
 */
async function describeAntChainMiniAppBrowserQRCodeAuthorizedUsersWithOptions(request: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersRequest, runtime: Util.RuntimeOptions): DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.QRCodeType)) {
    body['QRCodeType'] = request.QRCodeType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsers',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersRequest
 * @return DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse
 */
async function describeAntChainMiniAppBrowserQRCodeAuthorizedUsers(request: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersRequest): DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainMiniAppBrowserQRCodeAuthorizedUsersWithOptions(request, runtime);
}

model DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  QRCodeType?: string(name='QRCodeType', description='This parameter is required.'),
}

model DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: {
    antChainId?: string(name='AntChainId'),
    authorizationType?: string(name='AuthorizationType'),
    authorizedUserList?: [ 
      {
        gmtAuthorized?: string(name='GmtAuthorized'),
        phone?: string(name='Phone'),
        userId?: long(name='UserId'),
      }
    ](name='AuthorizedUserList'),
    pagination?: {
      pageNumber?: int32(name='PageNumber'),
      pageSize?: int32(name='PageSize'),
      totalCount?: int32(name='TotalCount'),
    }(name='Pagination'),
    QRCodeType?: string(name='QRCodeType'),
  }(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponse
 */
async function describeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewWithOptions(request: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewRequest, runtime: Util.RuntimeOptions): DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.QRCodeType)) {
    body['QRCodeType'] = request.QRCodeType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNew',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewRequest
 * @return DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponse
 */
async function describeAntChainMiniAppBrowserQRCodeAuthorizedUsersNew(request: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewRequest): DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewWithOptions(request, runtime);
}

model DescribeAntChainMiniAppBrowserTransactionQRCodeRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  transactionHash?: string(name='TransactionHash', description='This parameter is required.'),
}

model DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    antChainId?: string(name='AntChainId'),
    base64QRCodePNG?: string(name='Base64QRCodePNG'),
    QRCodeContent?: string(name='QRCodeContent'),
    transactionHash?: string(name='TransactionHash'),
  }(name='Result'),
}

model DescribeAntChainMiniAppBrowserTransactionQRCodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainMiniAppBrowserTransactionQRCodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainMiniAppBrowserTransactionQRCodeResponse
 */
async function describeAntChainMiniAppBrowserTransactionQRCodeWithOptions(request: DescribeAntChainMiniAppBrowserTransactionQRCodeRequest, runtime: Util.RuntimeOptions): DescribeAntChainMiniAppBrowserTransactionQRCodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.transactionHash)) {
    body['TransactionHash'] = request.transactionHash;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainMiniAppBrowserTransactionQRCode',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainMiniAppBrowserTransactionQRCodeRequest
 * @return DescribeAntChainMiniAppBrowserTransactionQRCodeResponse
 */
async function describeAntChainMiniAppBrowserTransactionQRCode(request: DescribeAntChainMiniAppBrowserTransactionQRCodeRequest): DescribeAntChainMiniAppBrowserTransactionQRCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainMiniAppBrowserTransactionQRCodeWithOptions(request, runtime);
}

model DescribeAntChainMiniAppBrowserTransactionQRCodeNewRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  contractId?: string(name='ContractId'),
  transactionHash?: string(name='TransactionHash', description='This parameter is required.'),
}

model DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: {
    antChainId?: string(name='AntChainId'),
    base64QRCodePNG?: string(name='Base64QRCodePNG'),
    QRCodeContent?: string(name='QRCodeContent'),
    transactionHash?: string(name='TransactionHash'),
  }(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainMiniAppBrowserTransactionQRCodeNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse
 */
async function describeAntChainMiniAppBrowserTransactionQRCodeNewWithOptions(request: DescribeAntChainMiniAppBrowserTransactionQRCodeNewRequest, runtime: Util.RuntimeOptions): DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.contractId)) {
    body['ContractId'] = request.contractId;
  }
  if (!Util.isUnset(request.transactionHash)) {
    body['TransactionHash'] = request.transactionHash;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainMiniAppBrowserTransactionQRCodeNew',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainMiniAppBrowserTransactionQRCodeNewRequest
 * @return DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse
 */
async function describeAntChainMiniAppBrowserTransactionQRCodeNew(request: DescribeAntChainMiniAppBrowserTransactionQRCodeNewRequest): DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainMiniAppBrowserTransactionQRCodeNewWithOptions(request, runtime);
}

model DescribeAntChainNodesNewRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  consortiumId?: string(name='ConsortiumId'),
}

model DescribeAntChainNodesNewResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model DescribeAntChainNodesNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainNodesNewResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainNodesNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainNodesNewResponse
 */
async function describeAntChainNodesNewWithOptions(request: DescribeAntChainNodesNewRequest, runtime: Util.RuntimeOptions): DescribeAntChainNodesNewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainNodesNew',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainNodesNewRequest
 * @return DescribeAntChainNodesNewResponse
 */
async function describeAntChainNodesNew(request: DescribeAntChainNodesNewRequest): DescribeAntChainNodesNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainNodesNewWithOptions(request, runtime);
}

model DescribeAntChainQRCodeAuthorizationRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  QRCodeType?: string(name='QRCodeType', description='This parameter is required.'),
}

model DescribeAntChainQRCodeAuthorizationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    antChainId?: string(name='AntChainId'),
    authorizationType?: string(name='AuthorizationType'),
    QRCodeType?: string(name='QRCodeType'),
  }(name='Result'),
}

model DescribeAntChainQRCodeAuthorizationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainQRCodeAuthorizationResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainQRCodeAuthorizationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainQRCodeAuthorizationResponse
 */
async function describeAntChainQRCodeAuthorizationWithOptions(request: DescribeAntChainQRCodeAuthorizationRequest, runtime: Util.RuntimeOptions): DescribeAntChainQRCodeAuthorizationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.QRCodeType)) {
    body['QRCodeType'] = request.QRCodeType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainQRCodeAuthorization',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainQRCodeAuthorizationRequest
 * @return DescribeAntChainQRCodeAuthorizationResponse
 */
async function describeAntChainQRCodeAuthorization(request: DescribeAntChainQRCodeAuthorizationRequest): DescribeAntChainQRCodeAuthorizationResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainQRCodeAuthorizationWithOptions(request, runtime);
}

model DescribeAntChainQRCodeAuthorizationNewRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  QRCodeType?: string(name='QRCodeType', description='This parameter is required.'),
}

model DescribeAntChainQRCodeAuthorizationNewResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: {
    antChainId?: string(name='AntChainId'),
    authorizationType?: string(name='AuthorizationType'),
    QRCodeType?: string(name='QRCodeType'),
  }(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model DescribeAntChainQRCodeAuthorizationNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainQRCodeAuthorizationNewResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainQRCodeAuthorizationNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainQRCodeAuthorizationNewResponse
 */
async function describeAntChainQRCodeAuthorizationNewWithOptions(request: DescribeAntChainQRCodeAuthorizationNewRequest, runtime: Util.RuntimeOptions): DescribeAntChainQRCodeAuthorizationNewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.QRCodeType)) {
    body['QRCodeType'] = request.QRCodeType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainQRCodeAuthorizationNew',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainQRCodeAuthorizationNewRequest
 * @return DescribeAntChainQRCodeAuthorizationNewResponse
 */
async function describeAntChainQRCodeAuthorizationNew(request: DescribeAntChainQRCodeAuthorizationNewRequest): DescribeAntChainQRCodeAuthorizationNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainQRCodeAuthorizationNewWithOptions(request, runtime);
}

model DescribeAntChainRegionNamesRequest {
  locale?: string(name='Locale'),
}

model DescribeAntChainRegionNamesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      regionId?: string(name='RegionId'),
      regionName?: string(name='RegionName'),
    }
  ](name='Result'),
}

model DescribeAntChainRegionNamesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainRegionNamesResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainRegionNamesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainRegionNamesResponse
 */
async function describeAntChainRegionNamesWithOptions(request: DescribeAntChainRegionNamesRequest, runtime: Util.RuntimeOptions): DescribeAntChainRegionNamesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.locale)) {
    body['Locale'] = request.locale;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainRegionNames',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainRegionNamesRequest
 * @return DescribeAntChainRegionNamesResponse
 */
async function describeAntChainRegionNames(request: DescribeAntChainRegionNamesRequest): DescribeAntChainRegionNamesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainRegionNamesWithOptions(request, runtime);
}

model DescribeAntChainRegionsForSaleResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      regionId?: string(name='RegionId'),
      typeList?: [ string ](name='TypeList'),
    }
  ](name='Result'),
}

model DescribeAntChainRegionsForSaleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainRegionsForSaleResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainRegionsForSaleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainRegionsForSaleResponse
 */
async function describeAntChainRegionsForSaleWithOptions(runtime: Util.RuntimeOptions): DescribeAntChainRegionsForSaleResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeAntChainRegionsForSale',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeAntChainRegionsForSaleResponse
 */
async function describeAntChainRegionsForSale(): DescribeAntChainRegionsForSaleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainRegionsForSaleWithOptions(runtime);
}

model DescribeAntChainResourceTypesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      cpu?: int32(name='Cpu'),
      disk?: int32(name='Disk'),
      memory?: int32(name='Memory'),
      typeId?: int32(name='TypeId'),
    }
  ](name='Result'),
}

model DescribeAntChainResourceTypesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainResourceTypesResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainResourceTypesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainResourceTypesResponse
 */
async function describeAntChainResourceTypesWithOptions(runtime: Util.RuntimeOptions): DescribeAntChainResourceTypesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeAntChainResourceTypes',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeAntChainResourceTypesResponse
 */
async function describeAntChainResourceTypes(): DescribeAntChainResourceTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainResourceTypesWithOptions(runtime);
}

model DescribeAntChainRestRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  consortiumId?: string(name='ConsortiumId'),
}

model DescribeAntChainRestResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      accessId?: string(name='AccessId'),
      createTime?: long(name='CreateTime'),
      updateTime?: long(name='UpdateTime'),
    }
  ](name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model DescribeAntChainRestResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainRestResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainRestRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainRestResponse
 */
async function describeAntChainRestWithOptions(request: DescribeAntChainRestRequest, runtime: Util.RuntimeOptions): DescribeAntChainRestResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainRest',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainRestRequest
 * @return DescribeAntChainRestResponse
 */
async function describeAntChainRest(request: DescribeAntChainRestRequest): DescribeAntChainRestResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainRestWithOptions(request, runtime);
}

model DescribeAntChainSubnetListRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.'),
}

model DescribeAntChainSubnetListResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: {
    antChainId?: string(name='AntChainId'),
    blockchainName?: string(name='BlockchainName'),
    blockchainSubnetList?: [ 
      {
        antChainId?: string(name='AntChainId'),
        blockHeight?: long(name='BlockHeight'),
        consortiumMember?: boolean(name='ConsortiumMember'),
        createTime?: long(name='CreateTime'),
        groupId?: string(name='GroupId'),
        monitor?: boolean(name='Monitor'),
        name?: string(name='Name'),
        nodeSum?: int32(name='NodeSum'),
        rest?: string(name='Rest'),
        status?: string(name='Status'),
        transactionSum?: long(name='TransactionSum'),
      }
    ](name='BlockchainSubnetList'),
    consortiumAdmin?: boolean(name='ConsortiumAdmin'),
  }(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model DescribeAntChainSubnetListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainSubnetListResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainSubnetListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainSubnetListResponse
 */
async function describeAntChainSubnetListWithOptions(request: DescribeAntChainSubnetListRequest, runtime: Util.RuntimeOptions): DescribeAntChainSubnetListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainSubnetList',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainSubnetListRequest
 * @return DescribeAntChainSubnetListResponse
 */
async function describeAntChainSubnetList(request: DescribeAntChainSubnetListRequest): DescribeAntChainSubnetListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainSubnetListWithOptions(request, runtime);
}

model DescribeAntChainSubnetMemberListRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.'),
  pageNumber?: string(name='PageNumber', description='This parameter is required.'),
  pageSize?: string(name='PageSize', description='This parameter is required.'),
}

model DescribeAntChainSubnetMemberListResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: {
    consortiumAdmin?: boolean(name='ConsortiumAdmin'),
    consortiumMemberInfoList?: [ 
      {
        joinTime?: long(name='JoinTime'),
        memberId?: string(name='MemberId'),
        memberName?: string(name='MemberName'),
        role?: string(name='Role'),
        status?: string(name='Status'),
      }
    ](name='ConsortiumMemberInfoList'),
    pagination?: {
      pageNumber?: long(name='PageNumber'),
      pageSize?: long(name='PageSize'),
      totalCount?: long(name='TotalCount'),
    }(name='Pagination'),
  }(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model DescribeAntChainSubnetMemberListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainSubnetMemberListResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainSubnetMemberListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainSubnetMemberListResponse
 */
async function describeAntChainSubnetMemberListWithOptions(request: DescribeAntChainSubnetMemberListRequest, runtime: Util.RuntimeOptions): DescribeAntChainSubnetMemberListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainSubnetMemberList',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainSubnetMemberListRequest
 * @return DescribeAntChainSubnetMemberListResponse
 */
async function describeAntChainSubnetMemberList(request: DescribeAntChainSubnetMemberListRequest): DescribeAntChainSubnetMemberListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainSubnetMemberListWithOptions(request, runtime);
}

model DescribeAntChainSubnetNodeListRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.'),
}

model DescribeAntChainSubnetNodeListResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      chainNodeInfoList?: [ 
        {
          diskTotal?: string(name='DiskTotal'),
          diskUse?: string(name='DiskUse'),
          nodeId?: string(name='NodeId'),
          nodeIp?: string(name='NodeIp'),
          nodeName?: string(name='NodeName'),
          nodePort?: string(name='NodePort'),
          nodeSource?: string(name='NodeSource'),
          nodeState?: string(name='NodeState'),
          nodeType?: string(name='NodeType'),
          publicKey?: string(name='PublicKey'),
        }
      ](name='ChainNodeInfoList'),
      consortiumAdmin?: boolean(name='ConsortiumAdmin'),
    }
  ](name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model DescribeAntChainSubnetNodeListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainSubnetNodeListResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainSubnetNodeListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainSubnetNodeListResponse
 */
async function describeAntChainSubnetNodeListWithOptions(request: DescribeAntChainSubnetNodeListRequest, runtime: Util.RuntimeOptions): DescribeAntChainSubnetNodeListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainSubnetNodeList',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainSubnetNodeListRequest
 * @return DescribeAntChainSubnetNodeListResponse
 */
async function describeAntChainSubnetNodeList(request: DescribeAntChainSubnetNodeListRequest): DescribeAntChainSubnetNodeListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainSubnetNodeListWithOptions(request, runtime);
}

model DescribeAntChainTransactionRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  hash?: string(name='Hash', description='This parameter is required.'),
}

model DescribeAntChainTransactionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    blockHash?: string(name='BlockHash'),
    blockHeight?: long(name='BlockHeight'),
    blockVersion?: string(name='BlockVersion'),
    createTime?: long(name='CreateTime'),
    hash?: string(name='Hash'),
    transaction?: {
      data?: string(name='Data'),
      extentions?: [ string ](name='Extentions'),
      from?: string(name='From'),
      gas?: string(name='Gas'),
      hash?: string(name='Hash'),
      nonce?: string(name='Nonce'),
      period?: long(name='Period'),
      signatures?: [ string ](name='Signatures'),
      timestamp?: long(name='Timestamp'),
      to?: string(name='To'),
      txType?: string(name='TxType'),
      value?: string(name='Value'),
    }(name='Transaction'),
  }(name='Result'),
}

model DescribeAntChainTransactionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainTransactionResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainTransactionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainTransactionResponse
 */
async function describeAntChainTransactionWithOptions(request: DescribeAntChainTransactionRequest, runtime: Util.RuntimeOptions): DescribeAntChainTransactionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.hash)) {
    body['Hash'] = request.hash;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainTransaction',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainTransactionRequest
 * @return DescribeAntChainTransactionResponse
 */
async function describeAntChainTransaction(request: DescribeAntChainTransactionRequest): DescribeAntChainTransactionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainTransactionWithOptions(request, runtime);
}

model DescribeAntChainTransactionNewRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  consortiumId?: string(name='ConsortiumId'),
  hash?: string(name='Hash', description='This parameter is required.'),
}

model DescribeAntChainTransactionNewResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: {
    blockHash?: string(name='BlockHash'),
    blockHeight?: long(name='BlockHeight'),
    blockVersion?: string(name='BlockVersion'),
    createTime?: long(name='CreateTime'),
    hash?: string(name='Hash'),
    transaction?: {
      data?: string(name='Data'),
      extentions?: [ string ](name='Extentions'),
      from?: string(name='From'),
      gas?: string(name='Gas'),
      hash?: string(name='Hash'),
      nonce?: string(name='Nonce'),
      period?: long(name='Period'),
      signatures?: [ string ](name='Signatures'),
      timestamp?: long(name='Timestamp'),
      to?: string(name='To'),
      txType?: string(name='TxType'),
      value?: string(name='Value'),
    }(name='Transaction'),
  }(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model DescribeAntChainTransactionNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainTransactionNewResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainTransactionNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainTransactionNewResponse
 */
async function describeAntChainTransactionNewWithOptions(request: DescribeAntChainTransactionNewRequest, runtime: Util.RuntimeOptions): DescribeAntChainTransactionNewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.hash)) {
    body['Hash'] = request.hash;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainTransactionNew',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainTransactionNewRequest
 * @return DescribeAntChainTransactionNewResponse
 */
async function describeAntChainTransactionNew(request: DescribeAntChainTransactionNewRequest): DescribeAntChainTransactionNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainTransactionNewWithOptions(request, runtime);
}

model DescribeAntChainTransactionReceiptNewRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  consortiumId?: string(name='ConsortiumId'),
  hash?: string(name='Hash', description='This parameter is required.'),
}

model DescribeAntChainTransactionReceiptNewResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: {
    data?: string(name='Data'),
    gasUsed?: string(name='GasUsed'),
    logs?: [ string ](name='Logs'),
    result?: long(name='Result'),
  }(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model DescribeAntChainTransactionReceiptNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainTransactionReceiptNewResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainTransactionReceiptNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainTransactionReceiptNewResponse
 */
async function describeAntChainTransactionReceiptNewWithOptions(request: DescribeAntChainTransactionReceiptNewRequest, runtime: Util.RuntimeOptions): DescribeAntChainTransactionReceiptNewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.hash)) {
    body['Hash'] = request.hash;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainTransactionReceiptNew',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainTransactionReceiptNewRequest
 * @return DescribeAntChainTransactionReceiptNewResponse
 */
async function describeAntChainTransactionReceiptNew(request: DescribeAntChainTransactionReceiptNewRequest): DescribeAntChainTransactionReceiptNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainTransactionReceiptNewWithOptions(request, runtime);
}

model DescribeAntChainTransactionStatisticsRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  end?: long(name='End'),
  start?: long(name='Start'),
}

model DescribeAntChainTransactionStatisticsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      antChainId?: string(name='AntChainId'),
      creatTime?: long(name='CreatTime'),
      dt?: long(name='Dt'),
      lastSumBlockHeight?: long(name='LastSumBlockHeight'),
      transCount?: long(name='TransCount'),
    }
  ](name='Result'),
}

model DescribeAntChainTransactionStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainTransactionStatisticsResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainTransactionStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainTransactionStatisticsResponse
 */
async function describeAntChainTransactionStatisticsWithOptions(request: DescribeAntChainTransactionStatisticsRequest, runtime: Util.RuntimeOptions): DescribeAntChainTransactionStatisticsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.end)) {
    body['End'] = request.end;
  }
  if (!Util.isUnset(request.start)) {
    body['Start'] = request.start;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainTransactionStatistics',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainTransactionStatisticsRequest
 * @return DescribeAntChainTransactionStatisticsResponse
 */
async function describeAntChainTransactionStatistics(request: DescribeAntChainTransactionStatisticsRequest): DescribeAntChainTransactionStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainTransactionStatisticsWithOptions(request, runtime);
}

model DescribeAntChainTransactionStatisticsNewRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  consortiumId?: string(name='ConsortiumId'),
  end?: long(name='End'),
  start?: long(name='Start'),
}

model DescribeAntChainTransactionStatisticsNewResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      antChainId?: string(name='AntChainId'),
      creatTime?: long(name='CreatTime'),
      dt?: long(name='Dt'),
      lastSumBlockHeight?: long(name='LastSumBlockHeight'),
      transCount?: long(name='TransCount'),
    }
  ](name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model DescribeAntChainTransactionStatisticsNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainTransactionStatisticsNewResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainTransactionStatisticsNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainTransactionStatisticsNewResponse
 */
async function describeAntChainTransactionStatisticsNewWithOptions(request: DescribeAntChainTransactionStatisticsNewRequest, runtime: Util.RuntimeOptions): DescribeAntChainTransactionStatisticsNewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.end)) {
    body['End'] = request.end;
  }
  if (!Util.isUnset(request.start)) {
    body['Start'] = request.start;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainTransactionStatisticsNew',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainTransactionStatisticsNewRequest
 * @return DescribeAntChainTransactionStatisticsNewResponse
 */
async function describeAntChainTransactionStatisticsNew(request: DescribeAntChainTransactionStatisticsNewRequest): DescribeAntChainTransactionStatisticsNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainTransactionStatisticsNewWithOptions(request, runtime);
}

model DescribeAntChainsRequest {
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
}

model DescribeAntChainsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    antChains?: [ 
      {
        antChainId?: string(name='AntChainId'),
        antChainName?: string(name='AntChainName'),
        chainType?: string(name='ChainType'),
        cipherSuit?: string(name='CipherSuit'),
        createTime?: long(name='CreateTime'),
        expireTime?: long(name='ExpireTime'),
        isAdmin?: boolean(name='IsAdmin'),
        memberStatus?: string(name='MemberStatus'),
        merkleTreeSuit?: string(name='MerkleTreeSuit'),
        network?: string(name='Network'),
        nodeNum?: int32(name='NodeNum'),
        regionId?: string(name='RegionId'),
        resourceSize?: string(name='ResourceSize'),
        tlsAlgo?: string(name='TlsAlgo'),
        version?: string(name='Version'),
      }
    ](name='AntChains'),
    isExist?: boolean(name='IsExist'),
    pagination?: {
      pageNumber?: int32(name='PageNumber'),
      pageSize?: int32(name='PageSize'),
      totalCount?: int32(name='TotalCount'),
    }(name='Pagination'),
  }(name='Result'),
}

model DescribeAntChainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainsResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainsResponse
 */
async function describeAntChainsWithOptions(request: DescribeAntChainsRequest, runtime: Util.RuntimeOptions): DescribeAntChainsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChains',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainsRequest
 * @return DescribeAntChainsResponse
 */
async function describeAntChains(request: DescribeAntChainsRequest): DescribeAntChainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainsWithOptions(request, runtime);
}

model DescribeAntChainsNewRequest {
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
}

model DescribeAntChainsNewResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: {
    antChains?: [ 
      {
        antChainId?: string(name='AntChainId'),
        antChainName?: string(name='AntChainName'),
        chainType?: string(name='ChainType'),
        cipherSuit?: string(name='CipherSuit'),
        createTime?: long(name='CreateTime'),
        expireTime?: long(name='ExpireTime'),
        instanceId?: string(name='InstanceId'),
        isAdmin?: boolean(name='IsAdmin'),
        memberStatus?: string(name='MemberStatus'),
        merkleTreeSuit?: string(name='MerkleTreeSuit'),
        monitorStatus?: boolean(name='MonitorStatus'),
        network?: string(name='Network'),
        nodeNum?: int32(name='NodeNum'),
        regionId?: string(name='RegionId'),
        resourceSize?: string(name='ResourceSize'),
        restStatus?: string(name='RestStatus'),
        tlsAlgo?: string(name='TlsAlgo'),
        version?: string(name='Version'),
      }
    ](name='AntChains'),
    isExist?: boolean(name='IsExist'),
    pagination?: {
      pageNumber?: int32(name='PageNumber'),
      pageSize?: int32(name='PageSize'),
      totalCount?: int32(name='TotalCount'),
    }(name='Pagination'),
  }(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  success?: boolean(name='Success'),
}

model DescribeAntChainsNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntChainsNewResponseBody(name='body'),
}

/**
 * @param request DescribeAntChainsNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntChainsNewResponse
 */
async function describeAntChainsNewWithOptions(request: DescribeAntChainsNewRequest, runtime: Util.RuntimeOptions): DescribeAntChainsNewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntChainsNew',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntChainsNewRequest
 * @return DescribeAntChainsNewResponse
 */
async function describeAntChainsNew(request: DescribeAntChainsNewRequest): DescribeAntChainsNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntChainsNewWithOptions(request, runtime);
}

model DescribeAntRegionsRequest {
  locale?: string(name='Locale'),
}

model DescribeAntRegionsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      localName?: string(name='LocalName'),
      regionId?: string(name='RegionId'),
    }
  ](name='Result'),
}

model DescribeAntRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntRegionsResponseBody(name='body'),
}

/**
 * @param request DescribeAntRegionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntRegionsResponse
 */
async function describeAntRegionsWithOptions(request: DescribeAntRegionsRequest, runtime: Util.RuntimeOptions): DescribeAntRegionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.locale)) {
    body['Locale'] = request.locale;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntRegions',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAntRegionsRequest
 * @return DescribeAntRegionsResponse
 */
async function describeAntRegions(request: DescribeAntRegionsRequest): DescribeAntRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntRegionsWithOptions(request, runtime);
}

model DescribeAppliesRequest {
  bizid?: string(name='Bizid'),
  current?: int32(name='Current'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
}

model DescribeAppliesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    applyHistoryList?: [ 
      {
        bizid?: string(name='Bizid'),
        createtime?: long(name='Createtime'),
        id?: int32(name='Id'),
        rejectReason?: string(name='RejectReason'),
        reqAddr?: string(name='ReqAddr'),
        signedAddr?: string(name='SignedAddr'),
        status?: int32(name='Status'),
        updatetime?: long(name='Updatetime'),
        username?: string(name='Username'),
      }
    ](name='ApplyHistoryList'),
    pagination?: {
      current?: int32(name='Current'),
      pageSize?: int32(name='PageSize'),
      total?: int32(name='Total'),
    }(name='Pagination'),
  }(name='Result'),
}

model DescribeAppliesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAppliesResponseBody(name='body'),
}

/**
 * @param request DescribeAppliesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAppliesResponse
 */
async function describeAppliesWithOptions(request: DescribeAppliesRequest, runtime: Util.RuntimeOptions): DescribeAppliesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeApplies',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAppliesRequest
 * @return DescribeAppliesResponse
 */
async function describeApplies(request: DescribeAppliesRequest): DescribeAppliesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAppliesWithOptions(request, runtime);
}

model DescribeBcSchemaRequest {
  bizid?: string(name='Bizid'),
}

model DescribeBcSchemaResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    responses?: [ 
      {
        category?: string(name='Category'),
        categoryName?: string(name='CategoryName'),
        description?: string(name='Description'),
        properties?: {
          count?: int32(name='Count'),
          dataSource?: [ 
            {
              allowNull?: int32(name='AllowNull'),
              annotation?: string(name='Annotation'),
              field?: string(name='Field'),
              indexes?: int32(name='Indexes'),
              key?: int32(name='Key'),
              length?: int32(name='Length'),
              reg?: string(name='Reg'),
              type?: string(name='Type'),
            }
          ](name='DataSource'),
        }(name='Properties'),
      }
    ](name='Responses'),
    schema?: {
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      id?: long(name='Id'),
      isTemplate?: boolean(name='IsTemplate'),
      name?: string(name='Name'),
      updateTime?: long(name='UpdateTime'),
      version?: long(name='Version'),
    }(name='Schema'),
  }(name='Result'),
}

model DescribeBcSchemaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBcSchemaResponseBody(name='body'),
}

/**
 * @param request DescribeBcSchemaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBcSchemaResponse
 */
async function describeBcSchemaWithOptions(request: DescribeBcSchemaRequest, runtime: Util.RuntimeOptions): DescribeBcSchemaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBcSchema',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeBcSchemaRequest
 * @return DescribeBcSchemaResponse
 */
async function describeBcSchema(request: DescribeBcSchemaRequest): DescribeBcSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBcSchemaWithOptions(request, runtime);
}

model DescribeBlockRequest {
  bizid?: string(name='Bizid'),
  height?: long(name='Height'),
}

model DescribeBlockResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    alias?: string(name='Alias'),
    blockHash?: string(name='BlockHash'),
    createTime?: long(name='CreateTime'),
    height?: int32(name='Height'),
    previousHash?: string(name='PreviousHash'),
    rootTxHash?: string(name='RootTxHash'),
    transSummaryList?: string(name='TransSummaryList'),
    transactionSize?: int32(name='TransactionSize'),
    version?: long(name='Version'),
  }(name='Result'),
}

model DescribeBlockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBlockResponseBody(name='body'),
}

/**
 * @param request DescribeBlockRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBlockResponse
 */
async function describeBlockWithOptions(request: DescribeBlockRequest, runtime: Util.RuntimeOptions): DescribeBlockResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.height)) {
    body['Height'] = request.height;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBlock',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeBlockRequest
 * @return DescribeBlockResponse
 */
async function describeBlock(request: DescribeBlockRequest): DescribeBlockResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBlockWithOptions(request, runtime);
}

model DescribeBlockchainApplicationRequest {
  bizid?: string(name='Bizid'),
  current?: int32(name='Current'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
}

model DescribeBlockchainApplicationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    applyHistoryList?: [ 
      {
        bizid?: string(name='Bizid'),
        createtime?: long(name='Createtime'),
        id?: int32(name='Id'),
        rejectReason?: string(name='RejectReason'),
        reqAddr?: string(name='ReqAddr'),
        signedAddr?: string(name='SignedAddr'),
        status?: int32(name='Status'),
        updatetime?: long(name='Updatetime'),
        username?: string(name='Username'),
      }
    ](name='ApplyHistoryList'),
    pagination?: {
      current?: int32(name='Current'),
      pageSize?: int32(name='PageSize'),
      total?: int32(name='Total'),
    }(name='Pagination'),
  }(name='Result'),
}

model DescribeBlockchainApplicationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBlockchainApplicationResponseBody(name='body'),
}

/**
 * @param request DescribeBlockchainApplicationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBlockchainApplicationResponse
 */
async function describeBlockchainApplicationWithOptions(request: DescribeBlockchainApplicationRequest, runtime: Util.RuntimeOptions): DescribeBlockchainApplicationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBlockchainApplication',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeBlockchainApplicationRequest
 * @return DescribeBlockchainApplicationResponse
 */
async function describeBlockchainApplication(request: DescribeBlockchainApplicationRequest): DescribeBlockchainApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBlockchainApplicationWithOptions(request, runtime);
}

model DescribeBlockchainConfigOptionRequest {
  purpose?: string(name='Purpose'),
}

model DescribeBlockchainConfigOptionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: map[string]any(name='Result'),
}

model DescribeBlockchainConfigOptionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBlockchainConfigOptionResponseBody(name='body'),
}

/**
 * @param request DescribeBlockchainConfigOptionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBlockchainConfigOptionResponse
 */
async function describeBlockchainConfigOptionWithOptions(request: DescribeBlockchainConfigOptionRequest, runtime: Util.RuntimeOptions): DescribeBlockchainConfigOptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.purpose)) {
    query['Purpose'] = request.purpose;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBlockchainConfigOption',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeBlockchainConfigOptionRequest
 * @return DescribeBlockchainConfigOptionResponse
 */
async function describeBlockchainConfigOption(request: DescribeBlockchainConfigOptionRequest): DescribeBlockchainConfigOptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBlockchainConfigOptionWithOptions(request, runtime);
}

model DescribeBlockchainCreateTaskRequest {
  current?: int32(name='Current'),
  pageSize?: int32(name='PageSize'),
}

model DescribeBlockchainCreateTaskResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    blockchainCreateTasks?: [ 
      {
        bizid?: string(name='Bizid'),
        createTime?: long(name='CreateTime'),
        memo?: string(name='Memo'),
        name?: string(name='Name'),
        status?: string(name='Status'),
      }
    ](name='BlockchainCreateTasks'),
    pagination?: {
      current?: int32(name='Current'),
      pageSize?: int32(name='PageSize'),
      total?: int32(name='Total'),
    }(name='Pagination'),
  }(name='Result'),
}

model DescribeBlockchainCreateTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBlockchainCreateTaskResponseBody(name='body'),
}

/**
 * @param request DescribeBlockchainCreateTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBlockchainCreateTaskResponse
 */
async function describeBlockchainCreateTaskWithOptions(request: DescribeBlockchainCreateTaskRequest, runtime: Util.RuntimeOptions): DescribeBlockchainCreateTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBlockchainCreateTask',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeBlockchainCreateTaskRequest
 * @return DescribeBlockchainCreateTaskResponse
 */
async function describeBlockchainCreateTask(request: DescribeBlockchainCreateTaskRequest): DescribeBlockchainCreateTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBlockchainCreateTaskWithOptions(request, runtime);
}

model DescribeBlockchainCreationConfigOptionsRequest {
  purpose?: string(name='Purpose'),
}

model DescribeBlockchainCreationConfigOptionsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: map[string]any(name='Result'),
}

model DescribeBlockchainCreationConfigOptionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBlockchainCreationConfigOptionsResponseBody(name='body'),
}

/**
 * @param request DescribeBlockchainCreationConfigOptionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBlockchainCreationConfigOptionsResponse
 */
async function describeBlockchainCreationConfigOptionsWithOptions(request: DescribeBlockchainCreationConfigOptionsRequest, runtime: Util.RuntimeOptions): DescribeBlockchainCreationConfigOptionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.purpose)) {
    query['Purpose'] = request.purpose;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBlockchainCreationConfigOptions',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeBlockchainCreationConfigOptionsRequest
 * @return DescribeBlockchainCreationConfigOptionsResponse
 */
async function describeBlockchainCreationConfigOptions(request: DescribeBlockchainCreationConfigOptionsRequest): DescribeBlockchainCreationConfigOptionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBlockchainCreationConfigOptionsWithOptions(request, runtime);
}

model DescribeBlockchainInfoRequest {
  bizid?: string(name='Bizid'),
}

model DescribeBlockchainInfoResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    abnormalNodes?: int32(name='AbnormalNodes'),
    bizid?: string(name='Bizid'),
    blockHeight?: int32(name='BlockHeight'),
    createTime?: long(name='CreateTime'),
    isRole?: boolean(name='IsRole'),
    nodeInfoList?: [ 
      {
        blockHeight?: long(name='BlockHeight'),
        nodeName?: string(name='NodeName'),
        status?: boolean(name='Status'),
        version?: string(name='Version'),
      }
    ](name='NodeInfoList'),
    nodeNumber?: int32(name='NodeNumber'),
    normal?: boolean(name='Normal'),
    transactionSum?: int32(name='TransactionSum'),
    version?: string(name='Version'),
  }(name='Result'),
}

model DescribeBlockchainInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBlockchainInfoResponseBody(name='body'),
}

/**
 * @param request DescribeBlockchainInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBlockchainInfoResponse
 */
async function describeBlockchainInfoWithOptions(request: DescribeBlockchainInfoRequest, runtime: Util.RuntimeOptions): DescribeBlockchainInfoResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBlockchainInfo',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeBlockchainInfoRequest
 * @return DescribeBlockchainInfoResponse
 */
async function describeBlockchainInfo(request: DescribeBlockchainInfoRequest): DescribeBlockchainInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBlockchainInfoWithOptions(request, runtime);
}

model DescribeBlockchainSchemaRequest {
  bizid?: string(name='Bizid'),
}

model DescribeBlockchainSchemaResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    responses?: [ 
      {
        category?: string(name='Category'),
        categoryName?: string(name='CategoryName'),
        description?: string(name='Description'),
        properties?: {
          count?: int32(name='Count'),
          dataSource?: [ 
            {
              allowNull?: int32(name='AllowNull'),
              annotation?: string(name='Annotation'),
              field?: string(name='Field'),
              indexes?: int32(name='Indexes'),
              key?: int32(name='Key'),
              length?: int32(name='Length'),
              reg?: string(name='Reg'),
              type?: string(name='Type'),
            }
          ](name='DataSource'),
        }(name='Properties'),
      }
    ](name='Responses'),
    schema?: {
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      id?: long(name='Id'),
      isTemplate?: boolean(name='IsTemplate'),
      name?: string(name='Name'),
      updateTime?: long(name='UpdateTime'),
      version?: long(name='Version'),
    }(name='Schema'),
  }(name='Result'),
}

model DescribeBlockchainSchemaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBlockchainSchemaResponseBody(name='body'),
}

/**
 * @param request DescribeBlockchainSchemaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBlockchainSchemaResponse
 */
async function describeBlockchainSchemaWithOptions(request: DescribeBlockchainSchemaRequest, runtime: Util.RuntimeOptions): DescribeBlockchainSchemaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBlockchainSchema',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeBlockchainSchemaRequest
 * @return DescribeBlockchainSchemaResponse
 */
async function describeBlockchainSchema(request: DescribeBlockchainSchemaRequest): DescribeBlockchainSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBlockchainSchemaWithOptions(request, runtime);
}

model DescribeBlockchainSchemaDetailRequest {
  bizid?: string(name='Bizid'),
  schemaId?: long(name='SchemaId'),
}

model DescribeBlockchainSchemaDetailResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    responses?: [ 
      {
        category?: string(name='Category'),
        categoryName?: string(name='CategoryName'),
        description?: string(name='Description'),
        properties?: {
          count?: int32(name='Count'),
          dataSource?: [ 
            {
              allowNull?: int32(name='AllowNull'),
              annotation?: string(name='Annotation'),
              field?: string(name='Field'),
              indexes?: int32(name='Indexes'),
              key?: int32(name='Key'),
              length?: int32(name='Length'),
              reg?: string(name='Reg'),
              type?: string(name='Type'),
            }
          ](name='DataSource'),
        }(name='Properties'),
      }
    ](name='Responses'),
    schema?: {
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      id?: long(name='Id'),
      isTemplate?: boolean(name='IsTemplate'),
      name?: string(name='Name'),
      updateTime?: long(name='UpdateTime'),
      version?: long(name='Version'),
    }(name='Schema'),
  }(name='Result'),
}

model DescribeBlockchainSchemaDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBlockchainSchemaDetailResponseBody(name='body'),
}

/**
 * @param request DescribeBlockchainSchemaDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBlockchainSchemaDetailResponse
 */
async function describeBlockchainSchemaDetailWithOptions(request: DescribeBlockchainSchemaDetailRequest, runtime: Util.RuntimeOptions): DescribeBlockchainSchemaDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.schemaId)) {
    body['SchemaId'] = request.schemaId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBlockchainSchemaDetail',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeBlockchainSchemaDetailRequest
 * @return DescribeBlockchainSchemaDetailResponse
 */
async function describeBlockchainSchemaDetail(request: DescribeBlockchainSchemaDetailRequest): DescribeBlockchainSchemaDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBlockchainSchemaDetailWithOptions(request, runtime);
}

model DescribeBlockchainSchemaFileOSSPropertiesRequest {
  bizid?: string(name='Bizid'),
}

model DescribeBlockchainSchemaFileOSSPropertiesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    accessKeyId?: string(name='AccessKeyId'),
    accessKeySecret?: string(name='AccessKeySecret'),
    bucketName?: string(name='BucketName'),
    endpoint?: string(name='Endpoint'),
    folderName?: string(name='FolderName'),
  }(name='Result'),
}

model DescribeBlockchainSchemaFileOSSPropertiesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBlockchainSchemaFileOSSPropertiesResponseBody(name='body'),
}

/**
 * @param request DescribeBlockchainSchemaFileOSSPropertiesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBlockchainSchemaFileOSSPropertiesResponse
 */
async function describeBlockchainSchemaFileOSSPropertiesWithOptions(request: DescribeBlockchainSchemaFileOSSPropertiesRequest, runtime: Util.RuntimeOptions): DescribeBlockchainSchemaFileOSSPropertiesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBlockchainSchemaFileOSSProperties',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeBlockchainSchemaFileOSSPropertiesRequest
 * @return DescribeBlockchainSchemaFileOSSPropertiesResponse
 */
async function describeBlockchainSchemaFileOSSProperties(request: DescribeBlockchainSchemaFileOSSPropertiesRequest): DescribeBlockchainSchemaFileOSSPropertiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBlockchainSchemaFileOSSPropertiesWithOptions(request, runtime);
}

model DescribeBlockchainSchemaTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    schemaList?: [ 
      {
        createTime?: long(name='CreateTime'),
        description?: string(name='Description'),
        id?: long(name='Id'),
        isTemplate?: int32(name='IsTemplate'),
        name?: string(name='Name'),
        updateTime?: long(name='UpdateTime'),
        version?: long(name='Version'),
      }
    ](name='SchemaList'),
  }(name='Result'),
}

model DescribeBlockchainSchemaTemplatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBlockchainSchemaTemplatesResponseBody(name='body'),
}

/**
 * @param request DescribeBlockchainSchemaTemplatesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBlockchainSchemaTemplatesResponse
 */
async function describeBlockchainSchemaTemplatesWithOptions(runtime: Util.RuntimeOptions): DescribeBlockchainSchemaTemplatesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeBlockchainSchemaTemplates',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeBlockchainSchemaTemplatesResponse
 */
async function describeBlockchainSchemaTemplates(): DescribeBlockchainSchemaTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBlockchainSchemaTemplatesWithOptions(runtime);
}

model DescribeCSIGatewayEndpointRequest {
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model DescribeCSIGatewayEndpointResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeCSIGatewayEndpointResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCSIGatewayEndpointResponseBody(name='body'),
}

/**
 * @param request DescribeCSIGatewayEndpointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCSIGatewayEndpointResponse
 */
async function describeCSIGatewayEndpointWithOptions(request: DescribeCSIGatewayEndpointRequest, runtime: Util.RuntimeOptions): DescribeCSIGatewayEndpointResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCSIGatewayEndpoint',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeCSIGatewayEndpointRequest
 * @return DescribeCSIGatewayEndpointResponse
 */
async function describeCSIGatewayEndpoint(request: DescribeCSIGatewayEndpointRequest): DescribeCSIGatewayEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCSIGatewayEndpointWithOptions(request, runtime);
}

model DescribeCandidateOrganizationsRequest {
  location?: string(name='Location', example='DescribeCandidateOrganizations'),
}

model DescribeCandidateOrganizationsResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: [ 
    {
      clusterState?: string(name='ClusterState', example='Running'),
      organizationId?: string(name='OrganizationId', example='peers-1oxw31d04****'),
      organizationName?: string(name='OrganizationName', example='org1'),
      serviceState?: string(name='ServiceState', example='Running'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeCandidateOrganizationsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCandidateOrganizationsResponseBody(name='body'),
}

/**
 * @param request DescribeCandidateOrganizationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCandidateOrganizationsResponse
 */
async function describeCandidateOrganizationsWithOptions(request: DescribeCandidateOrganizationsRequest, runtime: Util.RuntimeOptions): DescribeCandidateOrganizationsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCandidateOrganizations',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeCandidateOrganizationsRequest
 * @return DescribeCandidateOrganizationsResponse
 */
async function describeCandidateOrganizations(request: DescribeCandidateOrganizationsRequest): DescribeCandidateOrganizationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCandidateOrganizationsWithOptions(request, runtime);
}

model DescribeChaincodeCollectionConfigRequest {
  chaincodeId?: string(name='ChaincodeId', description='This parameter is required.'),
  location?: string(name='Location'),
}

model DescribeChaincodeCollectionConfigResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeChaincodeCollectionConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeChaincodeCollectionConfigResponseBody(name='body'),
}

/**
 * @param request DescribeChaincodeCollectionConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeChaincodeCollectionConfigResponse
 */
async function describeChaincodeCollectionConfigWithOptions(request: DescribeChaincodeCollectionConfigRequest, runtime: Util.RuntimeOptions): DescribeChaincodeCollectionConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.chaincodeId)) {
    body['ChaincodeId'] = request.chaincodeId;
  }
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeChaincodeCollectionConfig',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeChaincodeCollectionConfigRequest
 * @return DescribeChaincodeCollectionConfigResponse
 */
async function describeChaincodeCollectionConfig(request: DescribeChaincodeCollectionConfigRequest): DescribeChaincodeCollectionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeChaincodeCollectionConfigWithOptions(request, runtime);
}

model DescribeChaincodeDefinitionTaskRequest {
  chaincodeId?: string(name='ChaincodeId', description='This parameter is required.'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model DescribeChaincodeDefinitionTaskResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    approvers?: [ string ](name='Approvers'),
    channelName?: string(name='ChannelName'),
    content?: {
      chaincodeDefinition?: {
        chaincodePackageId?: string(name='ChaincodePackageId'),
        collectionConfig?: string(name='CollectionConfig'),
        endorsementPolicy?: string(name='EndorsementPolicy'),
        initRequired?: boolean(name='InitRequired'),
        name?: string(name='Name'),
        sequence?: long(name='Sequence'),
        version?: string(name='Version'),
      }(name='ChaincodeDefinition'),
    }(name='Content'),
    createTime?: long(name='CreateTime'),
    creator?: string(name='Creator'),
    description?: string(name='Description'),
    status?: string(name='Status'),
    taskId?: string(name='TaskId'),
    type?: string(name='Type'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeChaincodeDefinitionTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeChaincodeDefinitionTaskResponseBody(name='body'),
}

/**
 * @param request DescribeChaincodeDefinitionTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeChaincodeDefinitionTaskResponse
 */
async function describeChaincodeDefinitionTaskWithOptions(request: DescribeChaincodeDefinitionTaskRequest, runtime: Util.RuntimeOptions): DescribeChaincodeDefinitionTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.chaincodeId)) {
    body['ChaincodeId'] = request.chaincodeId;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeChaincodeDefinitionTask',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeChaincodeDefinitionTaskRequest
 * @return DescribeChaincodeDefinitionTaskResponse
 */
async function describeChaincodeDefinitionTask(request: DescribeChaincodeDefinitionTaskRequest): DescribeChaincodeDefinitionTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeChaincodeDefinitionTaskWithOptions(request, runtime);
}

model DescribeChaincodeUploadPolicyRequest {
  organizationId?: string(name='OrganizationId', description='This parameter is required.', example='peers-aaaaaa1-1oxw31d04****'),
}

model DescribeChaincodeUploadPolicyResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: {
    accessId?: string(name='AccessId', example='accessId'),
    dir?: string(name='Dir', example='test3/4bd1de21-2fff-4405-a8e9-f864c4bee24f'),
    expire?: int32(name='Expire', example='1533025590'),
    host?: string(name='Host', example='https://chaincode.oss-cn-beijing.aliyuncs.com'),
    policy?: string(name='Policy', example='eyJleHBpcmF0aW9uIjoiMjAxOC0wNy0zMVQwODoyNjozMC40NzdaIiwiY29uZGl'),
    signature?: string(name='Signature', example='signature'),
  }(name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeChaincodeUploadPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeChaincodeUploadPolicyResponseBody(name='body'),
}

/**
 * @param request DescribeChaincodeUploadPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeChaincodeUploadPolicyResponse
 */
async function describeChaincodeUploadPolicyWithOptions(request: DescribeChaincodeUploadPolicyRequest, runtime: Util.RuntimeOptions): DescribeChaincodeUploadPolicyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeChaincodeUploadPolicy',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeChaincodeUploadPolicyRequest
 * @return DescribeChaincodeUploadPolicyResponse
 */
async function describeChaincodeUploadPolicy(request: DescribeChaincodeUploadPolicyRequest): DescribeChaincodeUploadPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeChaincodeUploadPolicyWithOptions(request, runtime);
}

model DescribeChannelChaincodesRequest {
  channelId?: string(name='ChannelId', description='This parameter is required.'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model DescribeChannelChaincodesResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      binding?: boolean(name='Binding'),
      chaincodeId?: string(name='ChaincodeId'),
      channelId?: string(name='ChannelId'),
      channelName?: string(name='ChannelName'),
      consortiumId?: string(name='ConsortiumId'),
      createTime?: string(name='CreateTime'),
      creator?: string(name='Creator'),
      deployTime?: string(name='DeployTime'),
      endorsePolicy?: string(name='EndorsePolicy'),
      installed?: string(name='Installed'),
      management?: boolean(name='Management'),
      message?: string(name='Message'),
      name?: string(name='Name'),
      state?: string(name='State'),
      version?: string(name='Version'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model DescribeChannelChaincodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeChannelChaincodesResponseBody(name='body'),
}

/**
 * @param request DescribeChannelChaincodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeChannelChaincodesResponse
 */
async function describeChannelChaincodesWithOptions(request: DescribeChannelChaincodesRequest, runtime: Util.RuntimeOptions): DescribeChannelChaincodesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeChannelChaincodes',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeChannelChaincodesRequest
 * @return DescribeChannelChaincodesResponse
 */
async function describeChannelChaincodes(request: DescribeChannelChaincodesRequest): DescribeChannelChaincodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeChannelChaincodesWithOptions(request, runtime);
}

model DescribeChannelMembersRequest {
  channelId?: string(name='ChannelId', description='This parameter is required.', example='chan-channelx-1l1hmckuu****'),
  organizationId?: string(name='OrganizationId'),
}

model DescribeChannelMembersResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: [ 
    {
      acceptTime?: string(name='AcceptTime', example='1544411108000'),
      channelId?: string(name='ChannelId', example='chan-channelx-1l1hmckuuisxo'),
      description?: string(name='Description', example='description'),
      domain?: string(name='Domain', example='hello'),
      inviteTime?: string(name='InviteTime', example='1544411108000'),
      name?: string(name='Name', example='name'),
      organizationId?: string(name='OrganizationId', example='peers-aaaaaa1-1oxw31d046jtl'),
      state?: string(name='State', example='Running'),
      withPeer?: boolean(name='WithPeer', example='true'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeChannelMembersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeChannelMembersResponseBody(name='body'),
}

/**
 * @param request DescribeChannelMembersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeChannelMembersResponse
 */
async function describeChannelMembersWithOptions(request: DescribeChannelMembersRequest, runtime: Util.RuntimeOptions): DescribeChannelMembersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channelId)) {
    query['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeChannelMembers',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeChannelMembersRequest
 * @return DescribeChannelMembersResponse
 */
async function describeChannelMembers(request: DescribeChannelMembersRequest): DescribeChannelMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeChannelMembersWithOptions(request, runtime);
}

model DescribeChannelTriggersRequest {
  channelId?: string(name='ChannelId', description='This parameter is required.'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model DescribeChannelTriggersResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      channelId?: string(name='ChannelId'),
      channelName?: string(name='ChannelName'),
      checkpoint?: {
        errorCount?: long(name='ErrorCount'),
        height?: long(name='Height'),
        index?: long(name='Index'),
        type?: string(name='Type'),
      }(name='Checkpoint'),
      createTime?: long(name='CreateTime'),
      errorMessage?: string(name='ErrorMessage'),
      name?: string(name='Name'),
      options?: string(name='Options'),
      source?: string(name='Source'),
      status?: int32(name='Status'),
      type?: string(name='Type'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model DescribeChannelTriggersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeChannelTriggersResponseBody(name='body'),
}

/**
 * @param request DescribeChannelTriggersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeChannelTriggersResponse
 */
async function describeChannelTriggersWithOptions(request: DescribeChannelTriggersRequest, runtime: Util.RuntimeOptions): DescribeChannelTriggersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channelId)) {
    query['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeChannelTriggers',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeChannelTriggersRequest
 * @return DescribeChannelTriggersResponse
 */
async function describeChannelTriggers(request: DescribeChannelTriggersRequest): DescribeChannelTriggersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeChannelTriggersWithOptions(request, runtime);
}

model DescribeCloudIntegrationServiceTokenRequest {
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
  service?: string(name='Service', description='This parameter is required.'),
}

model DescribeCloudIntegrationServiceTokenResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    history?: [ 
      {
        service?: string(name='Service'),
        token?: string(name='Token'),
        type?: string(name='Type'),
      }
    ](name='History'),
    service?: string(name='Service'),
    token?: string(name='Token'),
    type?: string(name='Type'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeCloudIntegrationServiceTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudIntegrationServiceTokenResponseBody(name='body'),
}

/**
 * @param request DescribeCloudIntegrationServiceTokenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCloudIntegrationServiceTokenResponse
 */
async function describeCloudIntegrationServiceTokenWithOptions(request: DescribeCloudIntegrationServiceTokenRequest, runtime: Util.RuntimeOptions): DescribeCloudIntegrationServiceTokenResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.service)) {
    body['Service'] = request.service;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCloudIntegrationServiceToken',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeCloudIntegrationServiceTokenRequest
 * @return DescribeCloudIntegrationServiceTokenResponse
 */
async function describeCloudIntegrationServiceToken(request: DescribeCloudIntegrationServiceTokenRequest): DescribeCloudIntegrationServiceTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudIntegrationServiceTokenWithOptions(request, runtime);
}

model DescribeCloudServiceOrganizationStatusRequest {
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model DescribeCloudServiceOrganizationStatusResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      grantPrivilegeUrl?: string(name='GrantPrivilegeUrl'),
      organizationId?: string(name='OrganizationId'),
      serviceOpenStatus?: boolean(name='ServiceOpenStatus'),
      serviceOpenUrl?: string(name='ServiceOpenUrl'),
      servicePrivilegeStatus?: boolean(name='ServicePrivilegeStatus'),
      serviceType?: string(name='ServiceType'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model DescribeCloudServiceOrganizationStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudServiceOrganizationStatusResponseBody(name='body'),
}

/**
 * @param request DescribeCloudServiceOrganizationStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCloudServiceOrganizationStatusResponse
 */
async function describeCloudServiceOrganizationStatusWithOptions(request: DescribeCloudServiceOrganizationStatusRequest, runtime: Util.RuntimeOptions): DescribeCloudServiceOrganizationStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCloudServiceOrganizationStatus',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeCloudServiceOrganizationStatusRequest
 * @return DescribeCloudServiceOrganizationStatusResponse
 */
async function describeCloudServiceOrganizationStatus(request: DescribeCloudServiceOrganizationStatusRequest): DescribeCloudServiceOrganizationStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudServiceOrganizationStatusWithOptions(request, runtime);
}

model DescribeCloudServiceTypeStatusRequest {
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
  serviceType?: string(name='ServiceType', description='This parameter is required.'),
}

model DescribeCloudServiceTypeStatusResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    grantPrivilegeUrl?: string(name='GrantPrivilegeUrl'),
    organizationId?: string(name='OrganizationId'),
    serviceOpenStatus?: boolean(name='ServiceOpenStatus'),
    serviceOpenUrl?: string(name='ServiceOpenUrl'),
    servicePrivilegeStatus?: boolean(name='ServicePrivilegeStatus'),
    serviceType?: string(name='ServiceType'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeCloudServiceTypeStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudServiceTypeStatusResponseBody(name='body'),
}

/**
 * @param request DescribeCloudServiceTypeStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCloudServiceTypeStatusResponse
 */
async function describeCloudServiceTypeStatusWithOptions(request: DescribeCloudServiceTypeStatusRequest, runtime: Util.RuntimeOptions): DescribeCloudServiceTypeStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.serviceType)) {
    body['ServiceType'] = request.serviceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCloudServiceTypeStatus',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeCloudServiceTypeStatusRequest
 * @return DescribeCloudServiceTypeStatusResponse
 */
async function describeCloudServiceTypeStatus(request: DescribeCloudServiceTypeStatusRequest): DescribeCloudServiceTypeStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudServiceTypeStatusWithOptions(request, runtime);
}

model DescribeConsortiumAdminStatusRequest {
  location?: string(name='Location', example='cn-hangzhou'),
}

model DescribeConsortiumAdminStatusResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: [ 
    {
      consortiumAdministrator?: boolean(name='ConsortiumAdministrator', example='true'),
      consortiumId?: string(name='ConsortiumId', example='consortium-lianmenyumingyi-hc5d1bwlulg7'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeConsortiumAdminStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeConsortiumAdminStatusResponseBody(name='body'),
}

/**
 * @param request DescribeConsortiumAdminStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeConsortiumAdminStatusResponse
 */
async function describeConsortiumAdminStatusWithOptions(request: DescribeConsortiumAdminStatusRequest, runtime: Util.RuntimeOptions): DescribeConsortiumAdminStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeConsortiumAdminStatus',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeConsortiumAdminStatusRequest
 * @return DescribeConsortiumAdminStatusResponse
 */
async function describeConsortiumAdminStatus(request: DescribeConsortiumAdminStatusRequest): DescribeConsortiumAdminStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeConsortiumAdminStatusWithOptions(request, runtime);
}

model DescribeConsortiumChaincodesRequest {
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.', example='consortium-lianmenyumingyi-hc5d1bwlulg7'),
  location?: string(name='Location', example='cn-hangzhou'),
}

model DescribeConsortiumChaincodesResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: [ 
    {
      chaincodeId?: string(name='ChaincodeId', example='code-sacc-1pr09q7jmo0np'),
      channelId?: string(name='ChannelId', example='chan-channelx-1l1hmckuuisxo'),
      channelName?: string(name='ChannelName', example='cname'),
      consortiumId?: string(name='ConsortiumId', example='consortium-lianmenyumingyi-hc5d1bwlulg7'),
      createTime?: string(name='CreateTime', example='1544411108000'),
      deployTime?: string(name='DeployTime', example='1544411108000'),
      endorsePolicy?: string(name='EndorsePolicy', example='OR (\\\\"aaaaaa1MSP.peer\\\\")'),
      input?: string(name='Input', example='input'),
      install?: boolean(name='Install', example='true'),
      management?: boolean(name='Management'),
      message?: string(name='Message', example='ok'),
      name?: string(name='Name', example='sacc'),
      path?: string(name='Path', example='go-sdk-demo/chaincode/src'),
      providerId?: string(name='ProviderId', example='peers-aaaaaa2-1eqnj5o5w9dt3'),
      providerName?: string(name='ProviderName', example='name'),
      state?: string(name='State', example='Instantiatable'),
      type?: int32(name='Type', example='1'),
      version?: string(name='Version', example='1.0'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeConsortiumChaincodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeConsortiumChaincodesResponseBody(name='body'),
}

/**
 * @param request DescribeConsortiumChaincodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeConsortiumChaincodesResponse
 */
async function describeConsortiumChaincodesWithOptions(request: DescribeConsortiumChaincodesRequest, runtime: Util.RuntimeOptions): DescribeConsortiumChaincodesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeConsortiumChaincodes',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeConsortiumChaincodesRequest
 * @return DescribeConsortiumChaincodesResponse
 */
async function describeConsortiumChaincodes(request: DescribeConsortiumChaincodesRequest): DescribeConsortiumChaincodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeConsortiumChaincodesWithOptions(request, runtime);
}

model DescribeConsortiumChannelsRequest {
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.', example='consortium-lianmenyumingyi-hc5d1bwlulg7'),
  location?: string(name='Location', example='cn-hangzhou'),
}

model DescribeConsortiumChannelsResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: [ 
    {
      batchTimeout?: int32(name='BatchTimeout', example='2'),
      blockCount?: int32(name='BlockCount', example='2'),
      chaincodeCount?: int32(name='ChaincodeCount', example='2'),
      channelId?: string(name='ChannelId', example='chan-channelx-1l1hmckuuisxo'),
      consortiumId?: string(name='ConsortiumId', example='consortium-lianmenyumingyi-hc5d1bwlulg7'),
      consortiumName?: string(name='ConsortiumName', example='name'),
      createTime?: string(name='CreateTime', example='1544411108000'),
      deleteTime?: string(name='DeleteTime', example='1544411108000'),
      deleted?: boolean(name='Deleted', example='true'),
      hybird?: boolean(name='Hybird'),
      id?: int32(name='Id', description='Id', example='2'),
      maxMessageCount?: int32(name='MaxMessageCount', example='2'),
      memberCount?: int32(name='MemberCount', example='2'),
      memberJoinedCount?: string(name='MemberJoinedCount', example='3'),
      name?: string(name='Name', example='name'),
      needJoined?: boolean(name='NeedJoined', example='true'),
      ownerBid?: string(name='OwnerBid', example='26842'),
      ownerName?: string(name='OwnerName', example='uid-*'),
      ownerUid?: int32(name='OwnerUid', example='212'),
      preferredMaxBytes?: int32(name='PreferredMaxBytes', example='2'),
      requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
      state?: string(name='State', example='Running'),
      supportChannelConfig?: boolean(name='SupportChannelConfig', example='true'),
      updateTime?: string(name='UpdateTime', example='1544411108000'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeConsortiumChannelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeConsortiumChannelsResponseBody(name='body'),
}

/**
 * @param request DescribeConsortiumChannelsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeConsortiumChannelsResponse
 */
async function describeConsortiumChannelsWithOptions(request: DescribeConsortiumChannelsRequest, runtime: Util.RuntimeOptions): DescribeConsortiumChannelsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consortiumId)) {
    query['ConsortiumId'] = request.consortiumId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeConsortiumChannels',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeConsortiumChannelsRequest
 * @return DescribeConsortiumChannelsResponse
 */
async function describeConsortiumChannels(request: DescribeConsortiumChannelsRequest): DescribeConsortiumChannelsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeConsortiumChannelsWithOptions(request, runtime);
}

model DescribeConsortiumConfigResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: {
    channelPolicy?: [ string ](name='ChannelPolicy'),
    ordererType?: [ string ](name='OrdererType'),
  }(name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeConsortiumConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeConsortiumConfigResponseBody(name='body'),
}

/**
 * @param request DescribeConsortiumConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeConsortiumConfigResponse
 */
async function describeConsortiumConfigWithOptions(runtime: Util.RuntimeOptions): DescribeConsortiumConfigResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeConsortiumConfig',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeConsortiumConfigResponse
 */
async function describeConsortiumConfig(): DescribeConsortiumConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeConsortiumConfigWithOptions(runtime);
}

model DescribeConsortiumDeletableRequest {
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.', example='consortium-lianmenyumingyi-hc5d1bwl****'),
  location?: string(name='Location', example='cn-hangzhou'),
}

model DescribeConsortiumDeletableResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: {
    codeName?: string(name='CodeName', example='codename'),
    consortiumId?: string(name='ConsortiumId', example='consortium-lianmenyumingyi-hc5d1bwlulg7'),
    deletable?: boolean(name='Deletable', example='true'),
    description?: string(name='Description', example='description'),
    domain?: string(name='Domain', example='domain'),
    name?: string(name='Name', example='name'),
    regionId?: string(name='RegionId', example='cn-hangzhou'),
    state?: string(name='State', example='Running'),
    zoneId?: string(name='ZoneId', example='zone'),
  }(name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeConsortiumDeletableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeConsortiumDeletableResponseBody(name='body'),
}

/**
 * @param request DescribeConsortiumDeletableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeConsortiumDeletableResponse
 */
async function describeConsortiumDeletableWithOptions(request: DescribeConsortiumDeletableRequest, runtime: Util.RuntimeOptions): DescribeConsortiumDeletableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consortiumId)) {
    query['ConsortiumId'] = request.consortiumId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeConsortiumDeletable',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeConsortiumDeletableRequest
 * @return DescribeConsortiumDeletableResponse
 */
async function describeConsortiumDeletable(request: DescribeConsortiumDeletableRequest): DescribeConsortiumDeletableResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeConsortiumDeletableWithOptions(request, runtime);
}

model DescribeConsortiumMemberApprovalRequest {
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.', example='consortium-lianmenyumingyi-hc5d1bwlulg7'),
  location?: string(name='Location', example='cn-hangzhou'),
}

model DescribeConsortiumMemberApprovalResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: [ 
    {
      channelCreatePolicy?: string(name='ChannelCreatePolicy', example='Any'),
      confirmTime?: string(name='ConfirmTime', example='1544411108000'),
      consortiumId?: string(name='ConsortiumId', example='consortium-lianmenyumingyi-hc5d1bwlulg7'),
      consortiumName?: string(name='ConsortiumName', example='name'),
      domainName?: string(name='DomainName', example='domain'),
      organizationId?: string(name='OrganizationId', example='peers-aaaaaa2-1eqnj5o5w9dt3'),
      organizationName?: string(name='OrganizationName', example='orgname'),
      state?: string(name='State', example='Running'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeConsortiumMemberApprovalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeConsortiumMemberApprovalResponseBody(name='body'),
}

/**
 * @param request DescribeConsortiumMemberApprovalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeConsortiumMemberApprovalResponse
 */
async function describeConsortiumMemberApprovalWithOptions(request: DescribeConsortiumMemberApprovalRequest, runtime: Util.RuntimeOptions): DescribeConsortiumMemberApprovalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consortiumId)) {
    query['ConsortiumId'] = request.consortiumId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeConsortiumMemberApproval',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeConsortiumMemberApprovalRequest
 * @return DescribeConsortiumMemberApprovalResponse
 */
async function describeConsortiumMemberApproval(request: DescribeConsortiumMemberApprovalRequest): DescribeConsortiumMemberApprovalResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeConsortiumMemberApprovalWithOptions(request, runtime);
}

model DescribeConsortiumMembersRequest {
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.', example='consortium-lianmenyumingyi-hc5d1bwl****'),
  location?: string(name='Location', example='cn-hangzhou'),
}

model DescribeConsortiumMembersResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: [ 
    {
      consortiumId?: string(name='ConsortiumId', example='consortium-lianmenyumingyi-hc5d1bwlulg7'),
      description?: string(name='Description', example='Description'),
      domain?: string(name='Domain', example='Domain'),
      joinedTime?: string(name='JoinedTime', example='1544411108000'),
      name?: string(name='Name', example='name'),
      organizationId?: string(name='OrganizationId', example='peers-aaaaaa2-1eqnj5o5w9dt3'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeConsortiumMembersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeConsortiumMembersResponseBody(name='body'),
}

/**
 * @param request DescribeConsortiumMembersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeConsortiumMembersResponse
 */
async function describeConsortiumMembersWithOptions(request: DescribeConsortiumMembersRequest, runtime: Util.RuntimeOptions): DescribeConsortiumMembersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeConsortiumMembers',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeConsortiumMembersRequest
 * @return DescribeConsortiumMembersResponse
 */
async function describeConsortiumMembers(request: DescribeConsortiumMembersRequest): DescribeConsortiumMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeConsortiumMembersWithOptions(request, runtime);
}

model DescribeConsortiumOrderersRequest {
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.', example='DescribeConsortiumOrderers'),
  location?: string(name='Location', example='cn-hangzhou'),
}

model DescribeConsortiumOrderersResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: [ 
    {
      createTime?: string(name='CreateTime', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
      domain?: string(name='Domain', example='domain'),
      instanceType?: string(name='InstanceType', example='ecs.n1.small'),
      name?: string(name='Name', example='order1'),
      port?: int32(name='Port', example='7050'),
      updateTime?: string(name='UpdateTime', example='1544411108000'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeConsortiumOrderersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeConsortiumOrderersResponseBody(name='body'),
}

/**
 * @param request DescribeConsortiumOrderersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeConsortiumOrderersResponse
 */
async function describeConsortiumOrderersWithOptions(request: DescribeConsortiumOrderersRequest, runtime: Util.RuntimeOptions): DescribeConsortiumOrderersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeConsortiumOrderers',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeConsortiumOrderersRequest
 * @return DescribeConsortiumOrderersResponse
 */
async function describeConsortiumOrderers(request: DescribeConsortiumOrderersRequest): DescribeConsortiumOrderersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeConsortiumOrderersWithOptions(request, runtime);
}

model DescribeConsortiumSpecsResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: [ 
    {
      enable?: boolean(name='Enable', example='true'),
      name?: string(name='Name', example='basic'),
      title?: string(name='Title'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeConsortiumSpecsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeConsortiumSpecsResponseBody(name='body'),
}

/**
 * @param request DescribeConsortiumSpecsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeConsortiumSpecsResponse
 */
async function describeConsortiumSpecsWithOptions(runtime: Util.RuntimeOptions): DescribeConsortiumSpecsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeConsortiumSpecs',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeConsortiumSpecsResponse
 */
async function describeConsortiumSpecs(): DescribeConsortiumSpecsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeConsortiumSpecsWithOptions(runtime);
}

model DescribeConsortiumsRequest {
  consortiumId?: string(name='ConsortiumId', example='consortium-lianmenyumingyi-hc5d1bwl****'),
  location?: string(name='Location', example='cn-hangzhou'),
  tag?: [ 
    {
      key?: string(name='Key', description='This parameter is required.'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model DescribeConsortiumsResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: [ 
    {
      CAName?: string(name='CAName'),
      CAUrl?: string(name='CAUrl'),
      channelCount?: int32(name='ChannelCount', example='2'),
      channelPolicy?: string(name='ChannelPolicy', example='any'),
      codeName?: string(name='CodeName', example='code'),
      consortiumId?: string(name='ConsortiumId', example='consortium-lianmenyumingyi-hc5d1bwl****'),
      createTime?: string(name='CreateTime', example='1544411108000'),
      domain?: string(name='Domain', example='domain'),
      expireState?: string(name='ExpireState'),
      expiredTime?: string(name='ExpiredTime', example='1544411108000'),
      hybrid?: boolean(name='Hybrid', example='true'),
      MSP?: string(name='MSP'),
      majorVersion?: string(name='MajorVersion'),
      name?: string(name='Name', example='name'),
      ordererCount?: int32(name='OrdererCount'),
      organizationCount?: int32(name='OrganizationCount', example='2'),
      ownerBid?: string(name='OwnerBid', example='26842'),
      ownerName?: string(name='OwnerName', example='ownername'),
      ownerUid?: long(name='OwnerUid', example='1287126'),
      regionId?: string(name='RegionId', example='cn-hangzhou'),
      requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
      specName?: string(name='SpecName', example='basic'),
      state?: string(name='State', example='Pending'),
      supportChannelConfig?: boolean(name='SupportChannelConfig', example='true'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeConsortiumsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeConsortiumsResponseBody(name='body'),
}

/**
 * @param request DescribeConsortiumsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeConsortiumsResponse
 */
async function describeConsortiumsWithOptions(request: DescribeConsortiumsRequest, runtime: Util.RuntimeOptions): DescribeConsortiumsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consortiumId)) {
    query['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeConsortiums',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeConsortiumsRequest
 * @return DescribeConsortiumsResponse
 */
async function describeConsortiums(request: DescribeConsortiumsRequest): DescribeConsortiumsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeConsortiumsWithOptions(request, runtime);
}

model DescribeDownloadPathsRequest {
  bizid?: string(name='Bizid'),
}

model DescribeDownloadPathsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    bizviewUrl?: string(name='BizviewUrl'),
    certUrl?: string(name='CertUrl'),
    sdkUrl?: string(name='SdkUrl'),
  }(name='Result'),
}

model DescribeDownloadPathsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDownloadPathsResponseBody(name='body'),
}

/**
 * @param request DescribeDownloadPathsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDownloadPathsResponse
 */
async function describeDownloadPathsWithOptions(request: DescribeDownloadPathsRequest, runtime: Util.RuntimeOptions): DescribeDownloadPathsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDownloadPaths',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeDownloadPathsRequest
 * @return DescribeDownloadPathsResponse
 */
async function describeDownloadPaths(request: DescribeDownloadPathsRequest): DescribeDownloadPathsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDownloadPathsWithOptions(request, runtime);
}

model DescribeDownloadPathsOfContractChainRequest {
  bizid?: string(name='Bizid'),
}

model DescribeDownloadPathsOfContractChainResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    caUrl?: string(name='CaUrl'),
    certUrl?: string(name='CertUrl'),
    trustCaUrl?: string(name='TrustCaUrl'),
  }(name='Result'),
}

model DescribeDownloadPathsOfContractChainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDownloadPathsOfContractChainResponseBody(name='body'),
}

/**
 * @param request DescribeDownloadPathsOfContractChainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDownloadPathsOfContractChainResponse
 */
async function describeDownloadPathsOfContractChainWithOptions(request: DescribeDownloadPathsOfContractChainRequest, runtime: Util.RuntimeOptions): DescribeDownloadPathsOfContractChainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDownloadPathsOfContractChain',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeDownloadPathsOfContractChainRequest
 * @return DescribeDownloadPathsOfContractChainResponse
 */
async function describeDownloadPathsOfContractChain(request: DescribeDownloadPathsOfContractChainRequest): DescribeDownloadPathsOfContractChainResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDownloadPathsOfContractChainWithOptions(request, runtime);
}

model DescribeDownloadPathsOfNotaryChainRequest {
  bizid?: string(name='Bizid'),
}

model DescribeDownloadPathsOfNotaryChainResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    bizviewUrl?: string(name='BizviewUrl'),
    certUrl?: string(name='CertUrl'),
    sdkUrl?: string(name='SdkUrl'),
  }(name='Result'),
}

model DescribeDownloadPathsOfNotaryChainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDownloadPathsOfNotaryChainResponseBody(name='body'),
}

/**
 * @param request DescribeDownloadPathsOfNotaryChainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDownloadPathsOfNotaryChainResponse
 */
async function describeDownloadPathsOfNotaryChainWithOptions(request: DescribeDownloadPathsOfNotaryChainRequest, runtime: Util.RuntimeOptions): DescribeDownloadPathsOfNotaryChainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDownloadPathsOfNotaryChain',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeDownloadPathsOfNotaryChainRequest
 * @return DescribeDownloadPathsOfNotaryChainResponse
 */
async function describeDownloadPathsOfNotaryChain(request: DescribeDownloadPathsOfNotaryChainRequest): DescribeDownloadPathsOfNotaryChainResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDownloadPathsOfNotaryChainWithOptions(request, runtime);
}

model DescribeEcosphereSpecsResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: [ 
    {
      enable?: boolean(name='Enable', example='true'),
      name?: string(name='Name', example='enterprise'),
      title?: string(name='Title'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeEcosphereSpecsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEcosphereSpecsResponseBody(name='body'),
}

/**
 * @param request DescribeEcosphereSpecsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEcosphereSpecsResponse
 */
async function describeEcosphereSpecsWithOptions(runtime: Util.RuntimeOptions): DescribeEcosphereSpecsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeEcosphereSpecs',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeEcosphereSpecsResponse
 */
async function describeEcosphereSpecs(): DescribeEcosphereSpecsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEcosphereSpecsWithOptions(runtime);
}

model DescribeEthereumRequest {
  id?: string(name='Id', description='This parameter is required.'),
}

model DescribeEthereumResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    consensus?: string(name='Consensus'),
    creator?: string(name='Creator'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    networkId?: string(name='NetworkId'),
    regionId?: string(name='RegionId'),
    state?: string(name='State'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeEthereumResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEthereumResponseBody(name='body'),
}

/**
 * @param request DescribeEthereumRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEthereumResponse
 */
async function describeEthereumWithOptions(request: DescribeEthereumRequest, runtime: Util.RuntimeOptions): DescribeEthereumResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEthereum',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeEthereumRequest
 * @return DescribeEthereumResponse
 */
async function describeEthereum(request: DescribeEthereumRequest): DescribeEthereumResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEthereumWithOptions(request, runtime);
}

model DescribeEthereumClientUsersRequest {
  nodeId?: string(name='NodeId', description='This parameter is required.'),
}

model DescribeEthereumClientUsersResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      username?: string(name='Username'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model DescribeEthereumClientUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEthereumClientUsersResponseBody(name='body'),
}

/**
 * @param request DescribeEthereumClientUsersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEthereumClientUsersResponse
 */
async function describeEthereumClientUsersWithOptions(request: DescribeEthereumClientUsersRequest, runtime: Util.RuntimeOptions): DescribeEthereumClientUsersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEthereumClientUsers',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeEthereumClientUsersRequest
 * @return DescribeEthereumClientUsersResponse
 */
async function describeEthereumClientUsers(request: DescribeEthereumClientUsersRequest): DescribeEthereumClientUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEthereumClientUsersWithOptions(request, runtime);
}

model DescribeEthereumDeletableRequest {
  ethereumId?: string(name='EthereumId', description='This parameter is required.'),
}

model DescribeEthereumDeletableResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    deletable?: boolean(name='Deletable'),
    ethereumId?: string(name='EthereumId'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeEthereumDeletableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEthereumDeletableResponseBody(name='body'),
}

/**
 * @param request DescribeEthereumDeletableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEthereumDeletableResponse
 */
async function describeEthereumDeletableWithOptions(request: DescribeEthereumDeletableRequest, runtime: Util.RuntimeOptions): DescribeEthereumDeletableResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ethereumId)) {
    body['EthereumId'] = request.ethereumId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEthereumDeletable',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeEthereumDeletableRequest
 * @return DescribeEthereumDeletableResponse
 */
async function describeEthereumDeletable(request: DescribeEthereumDeletableRequest): DescribeEthereumDeletableResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEthereumDeletableWithOptions(request, runtime);
}

model DescribeEthereumInvitaionRequest {
  token?: string(name='Token', description='This parameter is required.'),
}

model DescribeEthereumInvitaionResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    consensus?: string(name='Consensus'),
    createTime?: string(name='CreateTime'),
    creator?: string(name='Creator'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    networkId?: string(name='NetworkId'),
    regionId?: string(name='RegionId'),
    state?: string(name='State'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeEthereumInvitaionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEthereumInvitaionResponseBody(name='body'),
}

/**
 * @param request DescribeEthereumInvitaionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEthereumInvitaionResponse
 */
async function describeEthereumInvitaionWithOptions(request: DescribeEthereumInvitaionRequest, runtime: Util.RuntimeOptions): DescribeEthereumInvitaionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.token)) {
    body['Token'] = request.token;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEthereumInvitaion',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeEthereumInvitaionRequest
 * @return DescribeEthereumInvitaionResponse
 */
async function describeEthereumInvitaion(request: DescribeEthereumInvitaionRequest): DescribeEthereumInvitaionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEthereumInvitaionWithOptions(request, runtime);
}

model DescribeEthereumInviteeRequest {
  id?: string(name='Id', description='This parameter is required.'),
}

model DescribeEthereumInviteeResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      createTime?: string(name='CreateTime'),
      creator?: string(name='Creator'),
      description?: string(name='Description'),
      ethereumId?: string(name='EthereumId'),
      ethereumName?: string(name='EthereumName'),
      id?: string(name='Id'),
      networkId?: long(name='NetworkId'),
      nodeName?: string(name='NodeName'),
      publicIp?: string(name='PublicIp'),
      regionId?: string(name='RegionId'),
      rpcPort?: string(name='RpcPort'),
      state?: string(name='State'),
      wsPort?: string(name='WsPort'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model DescribeEthereumInviteeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEthereumInviteeResponseBody(name='body'),
}

/**
 * @param request DescribeEthereumInviteeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEthereumInviteeResponse
 */
async function describeEthereumInviteeWithOptions(request: DescribeEthereumInviteeRequest, runtime: Util.RuntimeOptions): DescribeEthereumInviteeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEthereumInvitee',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeEthereumInviteeRequest
 * @return DescribeEthereumInviteeResponse
 */
async function describeEthereumInvitee(request: DescribeEthereumInviteeRequest): DescribeEthereumInviteeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEthereumInviteeWithOptions(request, runtime);
}

model DescribeEthereumNodeRequest {
  id?: string(name='Id', description='This parameter is required.'),
}

model DescribeEthereumNodeResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    createTime?: long(name='CreateTime'),
    creator?: string(name='Creator'),
    description?: string(name='Description'),
    ethereumId?: string(name='EthereumId'),
    ethereumName?: string(name='EthereumName'),
    id?: string(name='Id'),
    networkId?: string(name='NetworkId'),
    nodeName?: string(name='NodeName'),
    publicIp?: string(name='PublicIp'),
    regionId?: string(name='RegionId'),
    rpcPort?: int32(name='RpcPort'),
    state?: string(name='State'),
    wsPort?: int32(name='WsPort'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeEthereumNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEthereumNodeResponseBody(name='body'),
}

/**
 * @param request DescribeEthereumNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEthereumNodeResponse
 */
async function describeEthereumNodeWithOptions(request: DescribeEthereumNodeRequest, runtime: Util.RuntimeOptions): DescribeEthereumNodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEthereumNode',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeEthereumNodeRequest
 * @return DescribeEthereumNodeResponse
 */
async function describeEthereumNode(request: DescribeEthereumNodeRequest): DescribeEthereumNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEthereumNodeWithOptions(request, runtime);
}

model DescribeEthereumNodeConfigurationRequest {
  nodeId?: string(name='NodeId', description='This parameter is required.'),
}

model DescribeEthereumNodeConfigurationResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      genesisJson?: string(name='GenesisJson'),
      IP?: string(name='IP'),
      nodePub?: string(name='NodePub'),
      p2pPort?: int32(name='P2pPort'),
      permissionedNodesJson?: string(name='PermissionedNodesJson'),
      raftPort?: int32(name='RaftPort'),
      rpcPort?: int32(name='RpcPort'),
      staticNodesJson?: string(name='StaticNodesJson'),
      TMJson?: string(name='TMJson'),
      TMPort?: int32(name='TMPort'),
      TMPub?: string(name='TMPub'),
      WSPort?: int32(name='WSPort'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model DescribeEthereumNodeConfigurationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEthereumNodeConfigurationResponseBody(name='body'),
}

/**
 * @param request DescribeEthereumNodeConfigurationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEthereumNodeConfigurationResponse
 */
async function describeEthereumNodeConfigurationWithOptions(request: DescribeEthereumNodeConfigurationRequest, runtime: Util.RuntimeOptions): DescribeEthereumNodeConfigurationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEthereumNodeConfiguration',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeEthereumNodeConfigurationRequest
 * @return DescribeEthereumNodeConfigurationResponse
 */
async function describeEthereumNodeConfiguration(request: DescribeEthereumNodeConfigurationRequest): DescribeEthereumNodeConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEthereumNodeConfigurationWithOptions(request, runtime);
}

model DescribeEthereumNodeInfoRequest {
  nodeId?: string(name='NodeId', description='This parameter is required.'),
}

model DescribeEthereumNodeInfoResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeEthereumNodeInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEthereumNodeInfoResponseBody(name='body'),
}

/**
 * @param request DescribeEthereumNodeInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEthereumNodeInfoResponse
 */
async function describeEthereumNodeInfoWithOptions(request: DescribeEthereumNodeInfoRequest, runtime: Util.RuntimeOptions): DescribeEthereumNodeInfoResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEthereumNodeInfo',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeEthereumNodeInfoRequest
 * @return DescribeEthereumNodeInfoResponse
 */
async function describeEthereumNodeInfo(request: DescribeEthereumNodeInfoRequest): DescribeEthereumNodeInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEthereumNodeInfoWithOptions(request, runtime);
}

model DescribeEthereumNodeLogsRequest {
  lines?: string(name='Lines'),
  nodeId?: string(name='NodeId', description='This parameter is required.'),
  target?: string(name='Target'),
}

model DescribeEthereumNodeLogsResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeEthereumNodeLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEthereumNodeLogsResponseBody(name='body'),
}

/**
 * @param request DescribeEthereumNodeLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEthereumNodeLogsResponse
 */
async function describeEthereumNodeLogsWithOptions(request: DescribeEthereumNodeLogsRequest, runtime: Util.RuntimeOptions): DescribeEthereumNodeLogsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.lines)) {
    body['Lines'] = request.lines;
  }
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.target)) {
    body['Target'] = request.target;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEthereumNodeLogs',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeEthereumNodeLogsRequest
 * @return DescribeEthereumNodeLogsResponse
 */
async function describeEthereumNodeLogs(request: DescribeEthereumNodeLogsRequest): DescribeEthereumNodeLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEthereumNodeLogsWithOptions(request, runtime);
}

model DescribeEthereumNodesResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      consensus?: string(name='Consensus'),
      createTime?: string(name='CreateTime'),
      creator?: string(name='Creator'),
      description?: string(name='Description'),
      ethereumId?: string(name='EthereumId'),
      ethereumName?: string(name='EthereumName'),
      external?: boolean(name='External'),
      id?: string(name='Id'),
      networkId?: long(name='NetworkId'),
      nodeName?: string(name='NodeName'),
      publicIp?: string(name='PublicIp'),
      regionId?: string(name='RegionId'),
      rpcPort?: string(name='RpcPort'),
      state?: string(name='State'),
      validator?: boolean(name='Validator'),
      wsPort?: string(name='WsPort'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model DescribeEthereumNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEthereumNodesResponseBody(name='body'),
}

/**
 * @param request DescribeEthereumNodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEthereumNodesResponse
 */
async function describeEthereumNodesWithOptions(runtime: Util.RuntimeOptions): DescribeEthereumNodesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeEthereumNodes',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeEthereumNodesResponse
 */
async function describeEthereumNodes(): DescribeEthereumNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEthereumNodesWithOptions(runtime);
}

model DescribeEthereumsResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      consensus?: string(name='Consensus'),
      createTime?: long(name='CreateTime'),
      creator?: string(name='Creator'),
      deletable?: boolean(name='Deletable'),
      description?: string(name='Description'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      networkId?: string(name='NetworkId'),
      nodeNumber?: int32(name='NodeNumber'),
      regionId?: string(name='RegionId'),
      state?: string(name='State'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model DescribeEthereumsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEthereumsResponseBody(name='body'),
}

/**
 * @param request DescribeEthereumsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEthereumsResponse
 */
async function describeEthereumsWithOptions(runtime: Util.RuntimeOptions): DescribeEthereumsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeEthereums',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeEthereumsResponse
 */
async function describeEthereums(): DescribeEthereumsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEthereumsWithOptions(runtime);
}

model DescribeExplorerRequest {
  exBody?: string(name='ExBody'),
  exMethod?: string(name='ExMethod', description='This parameter is required.'),
  exUrl?: string(name='ExUrl'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model DescribeExplorerResponseBody = {
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeExplorerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeExplorerResponseBody(name='body'),
}

/**
 * @param request DescribeExplorerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeExplorerResponse
 */
async function describeExplorerWithOptions(request: DescribeExplorerRequest, runtime: Util.RuntimeOptions): DescribeExplorerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.exBody)) {
    query['ExBody'] = request.exBody;
  }
  if (!Util.isUnset(request.exMethod)) {
    query['ExMethod'] = request.exMethod;
  }
  if (!Util.isUnset(request.exUrl)) {
    query['ExUrl'] = request.exUrl;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExplorer',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeExplorerRequest
 * @return DescribeExplorerResponse
 */
async function describeExplorer(request: DescribeExplorerRequest): DescribeExplorerResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExplorerWithOptions(request, runtime);
}

model DescribeExplorerURLRequest {
  nodeId?: string(name='NodeId', description='This parameter is required.'),
}

model DescribeExplorerURLResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeExplorerURLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeExplorerURLResponseBody(name='body'),
}

/**
 * @param request DescribeExplorerURLRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeExplorerURLResponse
 */
async function describeExplorerURLWithOptions(request: DescribeExplorerURLRequest, runtime: Util.RuntimeOptions): DescribeExplorerURLResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExplorerURL',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeExplorerURLRequest
 * @return DescribeExplorerURLResponse
 */
async function describeExplorerURL(request: DescribeExplorerURLRequest): DescribeExplorerURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExplorerURLWithOptions(request, runtime);
}

model DescribeFabricChaincodeEndorsePolicyRequest {
  chaincodeName?: string(name='ChaincodeName', description='This parameter is required.'),
  channelId?: string(name='ChannelId'),
  organizationId?: string(name='OrganizationId'),
}

model DescribeFabricChaincodeEndorsePolicyResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeFabricChaincodeEndorsePolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeFabricChaincodeEndorsePolicyResponseBody(name='body'),
}

/**
 * @param request DescribeFabricChaincodeEndorsePolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFabricChaincodeEndorsePolicyResponse
 */
async function describeFabricChaincodeEndorsePolicyWithOptions(request: DescribeFabricChaincodeEndorsePolicyRequest, runtime: Util.RuntimeOptions): DescribeFabricChaincodeEndorsePolicyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.chaincodeName)) {
    body['ChaincodeName'] = request.chaincodeName;
  }
  if (!Util.isUnset(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFabricChaincodeEndorsePolicy',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeFabricChaincodeEndorsePolicyRequest
 * @return DescribeFabricChaincodeEndorsePolicyResponse
 */
async function describeFabricChaincodeEndorsePolicy(request: DescribeFabricChaincodeEndorsePolicyRequest): DescribeFabricChaincodeEndorsePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFabricChaincodeEndorsePolicyWithOptions(request, runtime);
}

model DescribeFabricChaincodeLogsRequest {
  chaincodeId?: string(name='ChaincodeId'),
  lines?: string(name='Lines'),
  offset?: int32(name='Offset'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
  peerName?: string(name='PeerName', description='This parameter is required.'),
}

model DescribeFabricChaincodeLogsResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeFabricChaincodeLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeFabricChaincodeLogsResponseBody(name='body'),
}

/**
 * @param request DescribeFabricChaincodeLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFabricChaincodeLogsResponse
 */
async function describeFabricChaincodeLogsWithOptions(request: DescribeFabricChaincodeLogsRequest, runtime: Util.RuntimeOptions): DescribeFabricChaincodeLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.chaincodeId)) {
    query['ChaincodeId'] = request.chaincodeId;
  }
  if (!Util.isUnset(request.lines)) {
    query['Lines'] = request.lines;
  }
  if (!Util.isUnset(request.offset)) {
    query['Offset'] = request.offset;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.peerName)) {
    query['PeerName'] = request.peerName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFabricChaincodeLogs',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeFabricChaincodeLogsRequest
 * @return DescribeFabricChaincodeLogsResponse
 */
async function describeFabricChaincodeLogs(request: DescribeFabricChaincodeLogsRequest): DescribeFabricChaincodeLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFabricChaincodeLogsWithOptions(request, runtime);
}

model DescribeFabricChannelConfigRequest {
  channelId?: string(name='ChannelId', description='This parameter is required.'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model DescribeFabricChannelConfigResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    absoluteMaxBytes?: long(name='AbsoluteMaxBytes'),
    batchTimeout?: string(name='BatchTimeout'),
    maxMessageCount?: long(name='MaxMessageCount'),
    preferredMaxBytes?: long(name='PreferredMaxBytes'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeFabricChannelConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeFabricChannelConfigResponseBody(name='body'),
}

/**
 * @param request DescribeFabricChannelConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFabricChannelConfigResponse
 */
async function describeFabricChannelConfigWithOptions(request: DescribeFabricChannelConfigRequest, runtime: Util.RuntimeOptions): DescribeFabricChannelConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFabricChannelConfig',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeFabricChannelConfigRequest
 * @return DescribeFabricChannelConfigResponse
 */
async function describeFabricChannelConfig(request: DescribeFabricChannelConfigRequest): DescribeFabricChannelConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFabricChannelConfigWithOptions(request, runtime);
}

model DescribeFabricChannelOrdererRequest {
  channelId?: string(name='ChannelId', description='This parameter is required.'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model DescribeFabricChannelOrdererResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      address?: string(name='Address'),
      certificate?: string(name='Certificate'),
      key?: string(name='Key'),
      tlsroot?: string(name='Tlsroot'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model DescribeFabricChannelOrdererResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeFabricChannelOrdererResponseBody(name='body'),
}

/**
 * @param request DescribeFabricChannelOrdererRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFabricChannelOrdererResponse
 */
async function describeFabricChannelOrdererWithOptions(request: DescribeFabricChannelOrdererRequest, runtime: Util.RuntimeOptions): DescribeFabricChannelOrdererResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFabricChannelOrderer',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeFabricChannelOrdererRequest
 * @return DescribeFabricChannelOrdererResponse
 */
async function describeFabricChannelOrderer(request: DescribeFabricChannelOrdererRequest): DescribeFabricChannelOrdererResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFabricChannelOrdererWithOptions(request, runtime);
}

model DescribeFabricChannelOrganizationsRequest {
  channelId?: string(name='ChannelId', description='This parameter is required.'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model DescribeFabricChannelOrganizationsResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    anchorPeers?: [ 
      {
        host?: string(name='Host'),
        port?: int32(name='Port'),
      }
    ](name='AnchorPeers'),
    crls?: string(name='Crls'),
    mspId?: string(name='MspId'),
    mspType?: string(name='MspType'),
    orderer?: boolean(name='Orderer'),
    ordererNodes?: [ 
      {
        address?: string(name='Address'),
        certificate?: string(name='Certificate'),
        key?: string(name='Key'),
        tlsroot?: string(name='Tlsroot'),
      }
    ](name='OrdererNodes'),
    rootCertificates?: string(name='RootCertificates'),
    tlsRootCertificates?: string(name='TlsRootCertificates'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeFabricChannelOrganizationsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeFabricChannelOrganizationsResponseBody(name='body'),
}

/**
 * @param request DescribeFabricChannelOrganizationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFabricChannelOrganizationsResponse
 */
async function describeFabricChannelOrganizationsWithOptions(request: DescribeFabricChannelOrganizationsRequest, runtime: Util.RuntimeOptions): DescribeFabricChannelOrganizationsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFabricChannelOrganizations',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeFabricChannelOrganizationsRequest
 * @return DescribeFabricChannelOrganizationsResponse
 */
async function describeFabricChannelOrganizations(request: DescribeFabricChannelOrganizationsRequest): DescribeFabricChannelOrganizationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFabricChannelOrganizationsWithOptions(request, runtime);
}

model DescribeFabricJoinRequestRequest {
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model DescribeFabricJoinRequestResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeFabricJoinRequestResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeFabricJoinRequestResponseBody(name='body'),
}

/**
 * @param request DescribeFabricJoinRequestRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFabricJoinRequestResponse
 */
async function describeFabricJoinRequestWithOptions(request: DescribeFabricJoinRequestRequest, runtime: Util.RuntimeOptions): DescribeFabricJoinRequestResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFabricJoinRequest',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeFabricJoinRequestRequest
 * @return DescribeFabricJoinRequestResponse
 */
async function describeFabricJoinRequest(request: DescribeFabricJoinRequestRequest): DescribeFabricJoinRequestResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFabricJoinRequestWithOptions(request, runtime);
}

model DescribeFabricJoinResponseRequest {
  channelId?: string(name='ChannelId', description='This parameter is required.'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model DescribeFabricJoinResponseResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeFabricJoinResponseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeFabricJoinResponseResponseBody(name='body'),
}

/**
 * @param request DescribeFabricJoinResponseRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFabricJoinResponseResponse
 */
async function describeFabricJoinResponseWithOptions(request: DescribeFabricJoinResponseRequest, runtime: Util.RuntimeOptions): DescribeFabricJoinResponseResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFabricJoinResponse',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeFabricJoinResponseRequest
 * @return DescribeFabricJoinResponseResponse
 */
async function describeFabricJoinResponse(request: DescribeFabricJoinResponseRequest): DescribeFabricJoinResponseResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFabricJoinResponseWithOptions(request, runtime);
}

model DescribeFabricManagementChaincodesRequest {
  channelId?: string(name='ChannelId', description='This parameter is required.'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model DescribeFabricManagementChaincodesResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      input?: string(name='Input'),
      name?: string(name='Name'),
      path?: long(name='Path'),
      type?: int32(name='Type'),
      version?: string(name='Version'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model DescribeFabricManagementChaincodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeFabricManagementChaincodesResponseBody(name='body'),
}

/**
 * @param request DescribeFabricManagementChaincodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFabricManagementChaincodesResponse
 */
async function describeFabricManagementChaincodesWithOptions(request: DescribeFabricManagementChaincodesRequest, runtime: Util.RuntimeOptions): DescribeFabricManagementChaincodesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFabricManagementChaincodes',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeFabricManagementChaincodesRequest
 * @return DescribeFabricManagementChaincodesResponse
 */
async function describeFabricManagementChaincodes(request: DescribeFabricManagementChaincodesRequest): DescribeFabricManagementChaincodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFabricManagementChaincodesWithOptions(request, runtime);
}

model DescribeFabricOrganizationChaincodePackageRequest {
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model DescribeFabricOrganizationChaincodePackageResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
  success?: boolean(name='Success'),
}

model DescribeFabricOrganizationChaincodePackageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeFabricOrganizationChaincodePackageResponseBody(name='body'),
}

/**
 * @param request DescribeFabricOrganizationChaincodePackageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFabricOrganizationChaincodePackageResponse
 */
async function describeFabricOrganizationChaincodePackageWithOptions(request: DescribeFabricOrganizationChaincodePackageRequest, runtime: Util.RuntimeOptions): DescribeFabricOrganizationChaincodePackageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFabricOrganizationChaincodePackage',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeFabricOrganizationChaincodePackageRequest
 * @return DescribeFabricOrganizationChaincodePackageResponse
 */
async function describeFabricOrganizationChaincodePackage(request: DescribeFabricOrganizationChaincodePackageRequest): DescribeFabricOrganizationChaincodePackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFabricOrganizationChaincodePackageWithOptions(request, runtime);
}

model DescribeFabricOrganizationEgressRequest {
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model DescribeFabricOrganizationEgressResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
  success?: boolean(name='Success'),
}

model DescribeFabricOrganizationEgressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeFabricOrganizationEgressResponseBody(name='body'),
}

/**
 * @param request DescribeFabricOrganizationEgressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFabricOrganizationEgressResponse
 */
async function describeFabricOrganizationEgressWithOptions(request: DescribeFabricOrganizationEgressRequest, runtime: Util.RuntimeOptions): DescribeFabricOrganizationEgressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFabricOrganizationEgress',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeFabricOrganizationEgressRequest
 * @return DescribeFabricOrganizationEgressResponse
 */
async function describeFabricOrganizationEgress(request: DescribeFabricOrganizationEgressRequest): DescribeFabricOrganizationEgressResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFabricOrganizationEgressWithOptions(request, runtime);
}

model DescribeFabricPeerChannelsRequest {
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model DescribeFabricPeerChannelsResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
  success?: boolean(name='Success'),
}

model DescribeFabricPeerChannelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeFabricPeerChannelsResponseBody(name='body'),
}

/**
 * @param request DescribeFabricPeerChannelsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFabricPeerChannelsResponse
 */
async function describeFabricPeerChannelsWithOptions(request: DescribeFabricPeerChannelsRequest, runtime: Util.RuntimeOptions): DescribeFabricPeerChannelsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFabricPeerChannels',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeFabricPeerChannelsRequest
 * @return DescribeFabricPeerChannelsResponse
 */
async function describeFabricPeerChannels(request: DescribeFabricPeerChannelsRequest): DescribeFabricPeerChannelsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFabricPeerChannelsWithOptions(request, runtime);
}

model DescribeGovernanceTaskRequest {
  channelId?: string(name='ChannelId', description='This parameter is required.'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
  taskId?: string(name='TaskId', description='This parameter is required.'),
}

model DescribeGovernanceTaskResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    channelName?: string(name='ChannelName'),
    content?: {
      addedOrganizations?: [ 
        {
          anchorPeers?: [ 
            {
              host?: string(name='Host'),
              port?: int32(name='Port'),
            }
          ](name='AnchorPeers'),
          crls?: string(name='Crls'),
          mspId?: string(name='MspId'),
          mspType?: string(name='MspType'),
          orderer?: boolean(name='Orderer'),
          ordererNodes?: [ 
            {
              address?: string(name='Address'),
              certificate?: string(name='Certificate'),
              key?: string(name='Key'),
              tlsroot?: string(name='Tlsroot'),
            }
          ](name='OrdererNodes'),
          rootCertificates?: string(name='RootCertificates'),
          tlsRootCertificates?: string(name='TlsRootCertificates'),
        }
      ](name='AddedOrganizations'),
      chaincodeSpecPkg?: {
        cs?: {
          input?: string(name='Input'),
          name?: string(name='Name'),
          path?: string(name='Path'),
          type?: int32(name='Type'),
          version?: string(name='Version'),
        }(name='Cs'),
        policy?: string(name='Policy'),
        sha256?: string(name='Sha256'),
      }(name='ChaincodeSpecPkg'),
      ordererConfig?: {
        batchTimeout?: string(name='BatchTimeout'),
        maxMessageCount?: int32(name='MaxMessageCount'),
        preferredMaxBytes?: int32(name='PreferredMaxBytes'),
      }(name='OrdererConfig'),
      raw?: string(name='Raw'),
      removedOrganizations?: [ 
        {
          anchorPeers?: [ 
            {
              host?: string(name='Host'),
              port?: int32(name='Port'),
            }
          ](name='AnchorPeers'),
          crls?: string(name='Crls'),
          mspId?: string(name='MspId'),
          mspType?: string(name='MspType'),
          orderer?: boolean(name='Orderer'),
          ordererNodes?: [ 
            {
              address?: string(name='Address'),
              certificate?: string(name='Certificate'),
              key?: string(name='Key'),
              tlsroot?: string(name='Tlsroot'),
            }
          ](name='OrdererNodes'),
          rootCertificates?: string(name='RootCertificates'),
          tlsRootCertificates?: string(name='TlsRootCertificates'),
        }
      ](name='RemovedOrganizations'),
      rwSets?: string(name='RwSets'),
    }(name='Content'),
    createTime?: long(name='CreateTime'),
    creator?: string(name='Creator'),
    description?: string(name='Description'),
    status?: string(name='Status'),
    taskId?: string(name='TaskId'),
    type?: string(name='Type'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeGovernanceTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGovernanceTaskResponseBody(name='body'),
}

/**
 * @param request DescribeGovernanceTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGovernanceTaskResponse
 */
async function describeGovernanceTaskWithOptions(request: DescribeGovernanceTaskRequest, runtime: Util.RuntimeOptions): DescribeGovernanceTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGovernanceTask',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeGovernanceTaskRequest
 * @return DescribeGovernanceTaskResponse
 */
async function describeGovernanceTask(request: DescribeGovernanceTaskRequest): DescribeGovernanceTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGovernanceTaskWithOptions(request, runtime);
}

model DescribeGovernanceTasksRequest {
  channelId?: string(name='ChannelId', description='This parameter is required.'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model DescribeGovernanceTasksResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      channelName?: string(name='ChannelName'),
      content?: {
        addedOrganizations?: [ 
          {
            anchorPeers?: [ 
              {
                host?: string(name='Host'),
                port?: int32(name='Port'),
              }
            ](name='AnchorPeers'),
            crls?: string(name='Crls'),
            mspId?: string(name='MspId'),
            mspType?: string(name='MspType'),
            orderer?: boolean(name='Orderer'),
            ordererNodes?: [ 
              {
                address?: string(name='Address'),
                certificate?: string(name='Certificate'),
                key?: string(name='Key'),
                tlsroot?: string(name='Tlsroot'),
              }
            ](name='OrdererNodes'),
            rootCertificates?: string(name='RootCertificates'),
            tlsRootCertificates?: string(name='TlsRootCertificates'),
          }
        ](name='AddedOrganizations'),
        chaincodeSpecPkg?: {
          cs?: {
            input?: string(name='Input'),
            name?: string(name='Name'),
            path?: string(name='Path'),
            type?: int32(name='Type'),
            version?: string(name='Version'),
          }(name='Cs'),
          policy?: string(name='Policy'),
          sha256?: string(name='Sha256'),
        }(name='ChaincodeSpecPkg'),
        ordererConfig?: {
          batchTimeout?: string(name='BatchTimeout'),
          maxMessageCount?: int32(name='MaxMessageCount'),
          preferredMaxBytes?: int32(name='PreferredMaxBytes'),
        }(name='OrdererConfig'),
        raw?: string(name='Raw'),
        removedOrganizations?: [ 
          {
            anchorPeers?: [ 
              {
                host?: string(name='Host'),
                port?: int32(name='Port'),
              }
            ](name='AnchorPeers'),
            crls?: string(name='Crls'),
            mspId?: string(name='MspId'),
            mspType?: string(name='MspType'),
            orderer?: boolean(name='Orderer'),
            ordererNodes?: [ 
              {
                address?: string(name='Address'),
                certificate?: string(name='Certificate'),
                key?: string(name='Key'),
                tlsroot?: string(name='Tlsroot'),
              }
            ](name='OrdererNodes'),
            rootCertificates?: string(name='RootCertificates'),
            tlsRootCertificates?: string(name='TlsRootCertificates'),
          }
        ](name='RemovedOrganizations'),
        rwSets?: string(name='RwSets'),
      }(name='Content'),
      createTime?: long(name='CreateTime'),
      creator?: string(name='Creator'),
      description?: string(name='Description'),
      status?: string(name='Status'),
      taskId?: string(name='TaskId'),
      type?: string(name='Type'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model DescribeGovernanceTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGovernanceTasksResponseBody(name='body'),
}

/**
 * @param request DescribeGovernanceTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGovernanceTasksResponse
 */
async function describeGovernanceTasksWithOptions(request: DescribeGovernanceTasksRequest, runtime: Util.RuntimeOptions): DescribeGovernanceTasksResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGovernanceTasks',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeGovernanceTasksRequest
 * @return DescribeGovernanceTasksResponse
 */
async function describeGovernanceTasks(request: DescribeGovernanceTasksRequest): DescribeGovernanceTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGovernanceTasksWithOptions(request, runtime);
}

model DescribeInvitationCodeRequest {
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.', example='consortium-lianmenyumingyi-hc5d1bwl****'),
}

model DescribeInvitationCodeResponseBody = {
  dynamicCode?: string(name='DynamicCode', example='11'),
  dynamicMessage?: string(name='DynamicMessage', example='11'),
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: {
    accepted?: boolean(name='Accepted', example='true'),
    code?: string(name='Code', example='code'),
    consortiumId?: string(name='ConsortiumId', example='consortium-lianmenyumingyi-hc5d1bwlulg7'),
    email?: string(name='Email', example='abc@126.com'),
    expireTime?: string(name='ExpireTime', example='1544411108000'),
    id?: int32(name='Id', description='Id', example='2'),
    sendTime?: string(name='SendTime', example='1544411108000'),
    senderBid?: string(name='SenderBid', example='27534'),
    senderId?: long(name='SenderId', example='26345345'),
    senderName?: string(name='SenderName', example='uid-35324'),
    url?: string(name='Url', description='URL', example='http://baas.console.aliyun.test/invite?code=92e7ef1934892'),
  }(name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeInvitationCodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInvitationCodeResponseBody(name='body'),
}

/**
 * @param request DescribeInvitationCodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInvitationCodeResponse
 */
async function describeInvitationCodeWithOptions(request: DescribeInvitationCodeRequest, runtime: Util.RuntimeOptions): DescribeInvitationCodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInvitationCode',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeInvitationCodeRequest
 * @return DescribeInvitationCodeResponse
 */
async function describeInvitationCode(request: DescribeInvitationCodeRequest): DescribeInvitationCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInvitationCodeWithOptions(request, runtime);
}

model DescribeInvitationListRequest {
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.', example='consortium-lianmenyumingyi-hc5d1bwl****'),
}

model DescribeInvitationListResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: [ 
    {
      code?: string(name='Code', example='200'),
      consortiumId?: string(name='ConsortiumId', example='consortium-lianmenyumingyi-hc5d1bwlulg7'),
      email?: string(name='Email', example='abc@alibaba.com'),
      expireTime?: string(name='ExpireTime', example='1544411108000'),
      sendTime?: string(name='SendTime', example='1544411108000'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeInvitationListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInvitationListResponseBody(name='body'),
}

/**
 * @param request DescribeInvitationListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInvitationListResponse
 */
async function describeInvitationListWithOptions(request: DescribeInvitationListRequest, runtime: Util.RuntimeOptions): DescribeInvitationListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInvitationList',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeInvitationListRequest
 * @return DescribeInvitationListResponse
 */
async function describeInvitationList(request: DescribeInvitationListRequest): DescribeInvitationListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInvitationListWithOptions(request, runtime);
}

model DescribeInviterRequest {
  code?: string(name='Code', description='This parameter is required.', example='200'),
}

model DescribeInviterResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: {
    consortiumId?: string(name='ConsortiumId', example='consortium-lianmenyumingyi-hc5d1bwl****'),
    consortiumName?: string(name='ConsortiumName', example='name'),
    expireTime?: string(name='ExpireTime', example='1544411108000'),
    inviterId?: long(name='InviterId', example='3524234'),
    inviterName?: string(name='InviterName', example='name'),
  }(name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeInviterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInviterResponseBody(name='body'),
}

/**
 * @description ****
 *
 * @param request DescribeInviterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInviterResponse
 */
async function describeInviterWithOptions(request: DescribeInviterRequest, runtime: Util.RuntimeOptions): DescribeInviterResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.code)) {
    body['Code'] = request.code;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInviter',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @description ****
 *
 * @param request DescribeInviterRequest
 * @return DescribeInviterResponse
 */
async function describeInviter(request: DescribeInviterRequest): DescribeInviterResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInviterWithOptions(request, runtime);
}

model DescribeLatest15BlocksRequest {
  bizid?: string(name='Bizid'),
}

model DescribeLatest15BlocksResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [  map[string]any ](name='Result'),
}

model DescribeLatest15BlocksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLatest15BlocksResponseBody(name='body'),
}

/**
 * @param request DescribeLatest15BlocksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLatest15BlocksResponse
 */
async function describeLatest15BlocksWithOptions(request: DescribeLatest15BlocksRequest, runtime: Util.RuntimeOptions): DescribeLatest15BlocksResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLatest15Blocks',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeLatest15BlocksRequest
 * @return DescribeLatest15BlocksResponse
 */
async function describeLatest15Blocks(request: DescribeLatest15BlocksRequest): DescribeLatest15BlocksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLatest15BlocksWithOptions(request, runtime);
}

model DescribeLatest15TransDigestsRequest {
  bizid?: string(name='Bizid'),
}

model DescribeLatest15TransDigestsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [  map[string]any ](name='Result'),
}

model DescribeLatest15TransDigestsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLatest15TransDigestsResponseBody(name='body'),
}

/**
 * @param request DescribeLatest15TransDigestsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLatest15TransDigestsResponse
 */
async function describeLatest15TransDigestsWithOptions(request: DescribeLatest15TransDigestsRequest, runtime: Util.RuntimeOptions): DescribeLatest15TransDigestsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLatest15TransDigests',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeLatest15TransDigestsRequest
 * @return DescribeLatest15TransDigestsResponse
 */
async function describeLatest15TransDigests(request: DescribeLatest15TransDigestsRequest): DescribeLatest15TransDigestsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLatest15TransDigestsWithOptions(request, runtime);
}

model DescribeLatestBlocksRequest {
  bizid?: string(name='Bizid'),
}

model DescribeLatestBlocksResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [  map[string]any ](name='Result'),
}

model DescribeLatestBlocksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLatestBlocksResponseBody(name='body'),
}

/**
 * @param request DescribeLatestBlocksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLatestBlocksResponse
 */
async function describeLatestBlocksWithOptions(request: DescribeLatestBlocksRequest, runtime: Util.RuntimeOptions): DescribeLatestBlocksResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLatestBlocks',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeLatestBlocksRequest
 * @return DescribeLatestBlocksResponse
 */
async function describeLatestBlocks(request: DescribeLatestBlocksRequest): DescribeLatestBlocksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLatestBlocksWithOptions(request, runtime);
}

model DescribeLatestTransactionDigestsRequest {
  bizid?: string(name='Bizid'),
}

model DescribeLatestTransactionDigestsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [  map[string]any ](name='Result'),
}

model DescribeLatestTransactionDigestsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLatestTransactionDigestsResponseBody(name='body'),
}

/**
 * @param request DescribeLatestTransactionDigestsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLatestTransactionDigestsResponse
 */
async function describeLatestTransactionDigestsWithOptions(request: DescribeLatestTransactionDigestsRequest, runtime: Util.RuntimeOptions): DescribeLatestTransactionDigestsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLatestTransactionDigests',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeLatestTransactionDigestsRequest
 * @return DescribeLatestTransactionDigestsResponse
 */
async function describeLatestTransactionDigests(request: DescribeLatestTransactionDigestsRequest): DescribeLatestTransactionDigestsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLatestTransactionDigestsWithOptions(request, runtime);
}

model DescribeMemberRoleRequest {
  bizid?: string(name='Bizid'),
}

model DescribeMemberRoleResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    role?: int32(name='Role'),
  }(name='Result'),
}

model DescribeMemberRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeMemberRoleResponseBody(name='body'),
}

/**
 * @param request DescribeMemberRoleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeMemberRoleResponse
 */
async function describeMemberRoleWithOptions(request: DescribeMemberRoleRequest, runtime: Util.RuntimeOptions): DescribeMemberRoleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMemberRole',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeMemberRoleRequest
 * @return DescribeMemberRoleResponse
 */
async function describeMemberRole(request: DescribeMemberRoleRequest): DescribeMemberRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMemberRoleWithOptions(request, runtime);
}

model DescribeMembersRequest {
  bizid?: string(name='Bizid'),
  current?: int32(name='Current'),
  pageSize?: int32(name='PageSize'),
}

model DescribeMembersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    memberList?: [ string ](name='MemberList'),
    pagination?: {
      current?: int32(name='Current'),
      pageSize?: int32(name='PageSize'),
      total?: int32(name='Total'),
    }(name='Pagination'),
  }(name='Result'),
}

model DescribeMembersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeMembersResponseBody(name='body'),
}

/**
 * @param request DescribeMembersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeMembersResponse
 */
async function describeMembersWithOptions(request: DescribeMembersRequest, runtime: Util.RuntimeOptions): DescribeMembersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMembers',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeMembersRequest
 * @return DescribeMembersResponse
 */
async function describeMembers(request: DescribeMembersRequest): DescribeMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMembersWithOptions(request, runtime);
}

model DescribeMetricRequest {
  bizid?: string(name='Bizid'),
  innerIp?: string(name='InnerIp'),
  metric?: string(name='Metric'),
  period?: string(name='Period'),
  port?: string(name='Port'),
  timeArea?: string(name='TimeArea'),
}

model DescribeMetricResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model DescribeMetricResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeMetricResponseBody(name='body'),
}

/**
 * @param request DescribeMetricRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeMetricResponse
 */
async function describeMetricWithOptions(request: DescribeMetricRequest, runtime: Util.RuntimeOptions): DescribeMetricResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizid)) {
    query['Bizid'] = request.bizid;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.innerIp)) {
    body['InnerIp'] = request.innerIp;
  }
  if (!Util.isUnset(request.metric)) {
    body['Metric'] = request.metric;
  }
  if (!Util.isUnset(request.period)) {
    body['Period'] = request.period;
  }
  if (!Util.isUnset(request.port)) {
    body['Port'] = request.port;
  }
  if (!Util.isUnset(request.timeArea)) {
    body['TimeArea'] = request.timeArea;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMetric',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeMetricRequest
 * @return DescribeMetricResponse
 */
async function describeMetric(request: DescribeMetricRequest): DescribeMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricWithOptions(request, runtime);
}

model DescribeMyBlockchainsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      bizid?: string(name='Bizid'),
      createtime?: long(name='Createtime'),
      id?: int32(name='Id'),
      rejectReason?: string(name='RejectReason'),
      reqAddr?: string(name='ReqAddr'),
      signedAddr?: string(name='SignedAddr'),
      status?: int32(name='Status'),
      updatetime?: long(name='Updatetime'),
      username?: string(name='Username'),
    }
  ](name='Result'),
}

model DescribeMyBlockchainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeMyBlockchainsResponseBody(name='body'),
}

/**
 * @param request DescribeMyBlockchainsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeMyBlockchainsResponse
 */
async function describeMyBlockchainsWithOptions(runtime: Util.RuntimeOptions): DescribeMyBlockchainsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeMyBlockchains',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeMyBlockchainsResponse
 */
async function describeMyBlockchains(): DescribeMyBlockchainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMyBlockchainsWithOptions(runtime);
}

model DescribeMyBlockchanInfosResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      abnormalNodes?: int32(name='AbnormalNodes'),
      bizid?: string(name='Bizid'),
      blockHeight?: int32(name='BlockHeight'),
      createTime?: long(name='CreateTime'),
      isRole?: boolean(name='IsRole'),
      name?: string(name='Name'),
      nodeInfoList?: [ 
        {
          blockHeight?: long(name='BlockHeight'),
          nodeName?: string(name='NodeName'),
          status?: boolean(name='Status'),
          version?: string(name='Version'),
        }
      ](name='NodeInfoList'),
      nodeNumber?: int32(name='NodeNumber'),
      normal?: boolean(name='Normal'),
      transactionSum?: int32(name='TransactionSum'),
      version?: string(name='Version'),
    }
  ](name='Result'),
}

model DescribeMyBlockchanInfosResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeMyBlockchanInfosResponseBody(name='body'),
}

/**
 * @param request DescribeMyBlockchanInfosRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeMyBlockchanInfosResponse
 */
async function describeMyBlockchanInfosWithOptions(runtime: Util.RuntimeOptions): DescribeMyBlockchanInfosResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeMyBlockchanInfos',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeMyBlockchanInfosResponse
 */
async function describeMyBlockchanInfos(): DescribeMyBlockchanInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMyBlockchanInfosWithOptions(runtime);
}

model DescribeMySuccessAppliesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      abnormalNodes?: int32(name='AbnormalNodes'),
      bizid?: string(name='Bizid'),
      blockHeight?: int32(name='BlockHeight'),
      createTime?: long(name='CreateTime'),
      isRole?: boolean(name='IsRole'),
      name?: string(name='Name'),
      nodeInfoList?: [ 
        {
          blockHeight?: long(name='BlockHeight'),
          nodeName?: string(name='NodeName'),
          status?: boolean(name='Status'),
          version?: string(name='Version'),
        }
      ](name='NodeInfoList'),
      nodeNumber?: int32(name='NodeNumber'),
      normal?: boolean(name='Normal'),
      transactionSum?: int32(name='TransactionSum'),
      version?: string(name='Version'),
    }
  ](name='Result'),
}

model DescribeMySuccessAppliesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeMySuccessAppliesResponseBody(name='body'),
}

/**
 * @param request DescribeMySuccessAppliesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeMySuccessAppliesResponse
 */
async function describeMySuccessAppliesWithOptions(runtime: Util.RuntimeOptions): DescribeMySuccessAppliesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeMySuccessApplies',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeMySuccessAppliesResponse
 */
async function describeMySuccessApplies(): DescribeMySuccessAppliesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMySuccessAppliesWithOptions(runtime);
}

model DescribeMySuccessfulApplicationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      abnormalNodes?: int32(name='AbnormalNodes'),
      bizid?: string(name='Bizid'),
      blockHeight?: int32(name='BlockHeight'),
      createTime?: long(name='CreateTime'),
      isRole?: boolean(name='IsRole'),
      name?: string(name='Name'),
      nodeInfoList?: [ 
        {
          blockHeight?: long(name='BlockHeight'),
          nodeName?: string(name='NodeName'),
          status?: boolean(name='Status'),
          version?: string(name='Version'),
        }
      ](name='NodeInfoList'),
      nodeNumber?: int32(name='NodeNumber'),
      normal?: boolean(name='Normal'),
      transactionSum?: int32(name='TransactionSum'),
      version?: string(name='Version'),
    }
  ](name='Result'),
}

model DescribeMySuccessfulApplicationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeMySuccessfulApplicationResponseBody(name='body'),
}

/**
 * @param request DescribeMySuccessfulApplicationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeMySuccessfulApplicationResponse
 */
async function describeMySuccessfulApplicationWithOptions(runtime: Util.RuntimeOptions): DescribeMySuccessfulApplicationResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeMySuccessfulApplication',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeMySuccessfulApplicationResponse
 */
async function describeMySuccessfulApplication(): DescribeMySuccessfulApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMySuccessfulApplicationWithOptions(runtime);
}

model DescribeNetstatURLRequest {
  id?: string(name='Id', description='This parameter is required.'),
}

model DescribeNetstatURLResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeNetstatURLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeNetstatURLResponseBody(name='body'),
}

/**
 * @param request DescribeNetstatURLRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeNetstatURLResponse
 */
async function describeNetstatURLWithOptions(request: DescribeNetstatURLRequest, runtime: Util.RuntimeOptions): DescribeNetstatURLResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNetstatURL',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeNetstatURLRequest
 * @return DescribeNetstatURLResponse
 */
async function describeNetstatURL(request: DescribeNetstatURLRequest): DescribeNetstatURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNetstatURLWithOptions(request, runtime);
}

model DescribeOrdererLogsRequest {
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.'),
  lines?: string(name='Lines'),
  ordererName?: string(name='OrdererName', description='This parameter is required.'),
}

model DescribeOrdererLogsResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeOrdererLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeOrdererLogsResponseBody(name='body'),
}

/**
 * @param request DescribeOrdererLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeOrdererLogsResponse
 */
async function describeOrdererLogsWithOptions(request: DescribeOrdererLogsRequest, runtime: Util.RuntimeOptions): DescribeOrdererLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consortiumId)) {
    query['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.lines)) {
    query['Lines'] = request.lines;
  }
  if (!Util.isUnset(request.ordererName)) {
    query['OrdererName'] = request.ordererName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOrdererLogs',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeOrdererLogsRequest
 * @return DescribeOrdererLogsResponse
 */
async function describeOrdererLogs(request: DescribeOrdererLogsRequest): DescribeOrdererLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOrdererLogsWithOptions(request, runtime);
}

model DescribeOrganizationRequest {
  location?: string(name='Location', example='cn-hangzhou'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.', example='peers-aaaaaa2-1eqnj5o5w****'),
  tag?: [ 
    {
      key?: string(name='Key', description='This parameter is required.'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model DescribeOrganizationResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: {
    CAName?: string(name='CAName', example='ca'),
    CAUrl?: string(name='CAUrl', example='asad'),
    codeName?: string(name='CodeName', example='name'),
    consortiumCount?: int32(name='ConsortiumCount', example='2'),
    createTime?: string(name='CreateTime', example='1533025590'),
    description?: string(name='Description', example='Description'),
    domain?: string(name='Domain', example='Domain'),
    expiredTime?: string(name='ExpiredTime'),
    MSP?: string(name='MSP', example='name'),
    name?: string(name='Name', example='Name'),
    organizationId?: string(name='OrganizationId', example='peers-aaaaaa2-1eqnj5o5w9dt3'),
    ownerBid?: string(name='OwnerBid', example='2544'),
    ownerName?: string(name='OwnerName', example='uid-23434'),
    ownerUid?: long(name='OwnerUid', example='23434'),
    peerCount?: int32(name='PeerCount', example='2'),
    regionId?: string(name='RegionId', example='cn-hangzhou'),
    requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
    specName?: string(name='SpecName', example='basic'),
    state?: string(name='State', example='Running'),
    tags?: [ 
      {
        key?: string(name='Key'),
        value?: string(name='Value'),
      }
    ](name='Tags'),
    userCount?: int32(name='UserCount', example='2'),
    zoneId?: string(name='ZoneId', example='zone'),
  }(name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeOrganizationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeOrganizationResponseBody(name='body'),
}

/**
 * @param request DescribeOrganizationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeOrganizationResponse
 */
async function describeOrganizationWithOptions(request: DescribeOrganizationRequest, runtime: Util.RuntimeOptions): DescribeOrganizationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOrganization',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeOrganizationRequest
 * @return DescribeOrganizationResponse
 */
async function describeOrganization(request: DescribeOrganizationRequest): DescribeOrganizationResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOrganizationWithOptions(request, runtime);
}

model DescribeOrganizationChaincodesRequest {
  location?: string(name='Location', example='cn-hangzhou'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.', example='peers-aaaaaa2-1eqnj5o5w****'),
}

model DescribeOrganizationChaincodesResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: [ 
    {
      binding?: boolean(name='Binding'),
      chaincodeId?: string(name='ChaincodeId', example='code-sacc-1pr09q7jmo0np'),
      chaincodePackageId?: string(name='ChaincodePackageId'),
      channelId?: string(name='ChannelId', example='chan-first-channel-31hlgpen5k5lig'),
      channelName?: string(name='ChannelName', example='first-channel'),
      consortiumId?: string(name='ConsortiumId', example='consortium-lianmenyumingyi-hc5d1bwlulg7'),
      createTime?: string(name='CreateTime', example='1533025590'),
      creator?: string(name='Creator', example='uid-23425'),
      deployTime?: string(name='DeployTime', example='1533025590'),
      endorsePolicy?: string(name='EndorsePolicy', example='OR (&#39;perf9141MSP.member&#39;)'),
      installed?: string(name='Installed', example='Installed'),
      management?: boolean(name='Management'),
      message?: string(name='Message', example='OK'),
      name?: string(name='Name', example='mycc'),
      state?: string(name='State', example='Running'),
      version?: string(name='Version', example='0.3'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeOrganizationChaincodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeOrganizationChaincodesResponseBody(name='body'),
}

/**
 * @param request DescribeOrganizationChaincodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeOrganizationChaincodesResponse
 */
async function describeOrganizationChaincodesWithOptions(request: DescribeOrganizationChaincodesRequest, runtime: Util.RuntimeOptions): DescribeOrganizationChaincodesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOrganizationChaincodes',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeOrganizationChaincodesRequest
 * @return DescribeOrganizationChaincodesResponse
 */
async function describeOrganizationChaincodes(request: DescribeOrganizationChaincodesRequest): DescribeOrganizationChaincodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOrganizationChaincodesWithOptions(request, runtime);
}

model DescribeOrganizationChannelsRequest {
  location?: string(name='Location', example='cn-hangzhou'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.', example='peers-aaaaaa2-1eqnj5o5****'),
}

model DescribeOrganizationChannelsResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: [ 
    {
      batchTimeout?: int32(name='BatchTimeout', example='2'),
      blockCount?: int32(name='BlockCount', example='3'),
      chaincodeCount?: int32(name='ChaincodeCount', example='2'),
      channelId?: string(name='ChannelId', example='chan-channelx-1l1hmckuuisxo'),
      consortiumId?: string(name='ConsortiumId', example='consortium-lianmenyumingyi-hc5d1bwlulg7'),
      consortiumName?: string(name='ConsortiumName', example='name'),
      createTime?: string(name='CreateTime', example='1533025590'),
      deleteTime?: string(name='DeleteTime', example='1533025590'),
      deleted?: boolean(name='Deleted', example='true'),
      hybird?: boolean(name='Hybird'),
      maxMessageCount?: int32(name='MaxMessageCount', example='3'),
      memberCount?: int32(name='MemberCount', example='3'),
      name?: string(name='Name', example='name'),
      ownerBid?: string(name='OwnerBid', example='253'),
      ownerName?: string(name='OwnerName', example='uid-5324'),
      ownerUid?: int32(name='OwnerUid', example='5324'),
      preferredMaxBytes?: int32(name='PreferredMaxBytes', example='4'),
      requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
      state?: string(name='State', example='Running'),
      supportChannelConfig?: boolean(name='SupportChannelConfig', example='true'),
      updateTime?: string(name='UpdateTime', example='1533025590'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeOrganizationChannelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeOrganizationChannelsResponseBody(name='body'),
}

/**
 * @description ****
 *
 * @param request DescribeOrganizationChannelsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeOrganizationChannelsResponse
 */
async function describeOrganizationChannelsWithOptions(request: DescribeOrganizationChannelsRequest, runtime: Util.RuntimeOptions): DescribeOrganizationChannelsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOrganizationChannels',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @description ****
 *
 * @param request DescribeOrganizationChannelsRequest
 * @return DescribeOrganizationChannelsResponse
 */
async function describeOrganizationChannels(request: DescribeOrganizationChannelsRequest): DescribeOrganizationChannelsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOrganizationChannelsWithOptions(request, runtime);
}

model DescribeOrganizationDeletableRequest {
  location?: string(name='Location', example='cn-hangzhou'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.', example='peers-aaaaaa2-1eqnj5o5w****'),
}

model DescribeOrganizationDeletableResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: {
    codeName?: string(name='CodeName', example='name'),
    deletable?: boolean(name='Deletable', example='false'),
    description?: string(name='Description', example='desc'),
    domain?: string(name='Domain', example='domain'),
    name?: string(name='Name', example='orgname'),
    organizationId?: string(name='OrganizationId', example='peers-aaaaaa2-1eqnj5o5w****'),
    regionId?: string(name='RegionId', example='cn-hangzhou'),
    state?: string(name='State', example='Running'),
    zoneId?: string(name='ZoneId', example='zone'),
  }(name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeOrganizationDeletableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeOrganizationDeletableResponseBody(name='body'),
}

/**
 * @param request DescribeOrganizationDeletableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeOrganizationDeletableResponse
 */
async function describeOrganizationDeletableWithOptions(request: DescribeOrganizationDeletableRequest, runtime: Util.RuntimeOptions): DescribeOrganizationDeletableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOrganizationDeletable',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeOrganizationDeletableRequest
 * @return DescribeOrganizationDeletableResponse
 */
async function describeOrganizationDeletable(request: DescribeOrganizationDeletableRequest): DescribeOrganizationDeletableResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOrganizationDeletableWithOptions(request, runtime);
}

model DescribeOrganizationMembersRequest {
  location?: string(name='Location', example='cn-hangzhou'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.', example='peers-aaaaaa2-1eqnj5o5w****'),
}

model DescribeOrganizationMembersResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: [ 
    {
      consortiumId?: string(name='ConsortiumId', example='consortium-lianmenyumingyi-hc5d1bwl****'),
      consortiumName?: string(name='ConsortiumName', example='name'),
      description?: string(name='Description', example='desc'),
      domain?: string(name='Domain', example='domain'),
      id?: string(name='Id', description='Id', example='3'),
      joinedTime?: string(name='JoinedTime', example='1533025590'),
      name?: string(name='Name', example='name'),
      state?: string(name='State', example='Running'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeOrganizationMembersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeOrganizationMembersResponseBody(name='body'),
}

/**
 * @param request DescribeOrganizationMembersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeOrganizationMembersResponse
 */
async function describeOrganizationMembersWithOptions(request: DescribeOrganizationMembersRequest, runtime: Util.RuntimeOptions): DescribeOrganizationMembersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOrganizationMembers',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeOrganizationMembersRequest
 * @return DescribeOrganizationMembersResponse
 */
async function describeOrganizationMembers(request: DescribeOrganizationMembersRequest): DescribeOrganizationMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOrganizationMembersWithOptions(request, runtime);
}

model DescribeOrganizationPeersRequest {
  location?: string(name='Location', example='cn-hangzhou'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.', example='peers-aaaaaa2-1eqnj5o5w****'),
}

model DescribeOrganizationPeersResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: [ 
    {
      createTime?: string(name='CreateTime', example='1533025590'),
      domain?: string(name='Domain', example='domain'),
      instanceType?: string(name='InstanceType', example='basic'),
      internetIp?: string(name='InternetIp', example='10.0.0.2'),
      intranetIp?: string(name='IntranetIp', example='10.0.0.2'),
      isAnchor?: boolean(name='IsAnchor', example='false'),
      name?: string(name='Name', example='name'),
      port?: int32(name='Port', example='1234'),
      updateTime?: string(name='UpdateTime', example='1533025590'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeOrganizationPeersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeOrganizationPeersResponseBody(name='body'),
}

/**
 * @param request DescribeOrganizationPeersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeOrganizationPeersResponse
 */
async function describeOrganizationPeersWithOptions(request: DescribeOrganizationPeersRequest, runtime: Util.RuntimeOptions): DescribeOrganizationPeersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOrganizationPeers',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeOrganizationPeersRequest
 * @return DescribeOrganizationPeersResponse
 */
async function describeOrganizationPeers(request: DescribeOrganizationPeersRequest): DescribeOrganizationPeersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOrganizationPeersWithOptions(request, runtime);
}

model DescribeOrganizationSpecsResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: [ 
    {
      enable?: boolean(name='Enable', example='true'),
      name?: string(name='Name', example='basic'),
      title?: string(name='Title'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeOrganizationSpecsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeOrganizationSpecsResponseBody(name='body'),
}

/**
 * @param request DescribeOrganizationSpecsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeOrganizationSpecsResponse
 */
async function describeOrganizationSpecsWithOptions(runtime: Util.RuntimeOptions): DescribeOrganizationSpecsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeOrganizationSpecs',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeOrganizationSpecsResponse
 */
async function describeOrganizationSpecs(): DescribeOrganizationSpecsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOrganizationSpecsWithOptions(runtime);
}

model DescribeOrganizationTriggersRequest {
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model DescribeOrganizationTriggersResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      channelId?: string(name='ChannelId'),
      channelName?: string(name='ChannelName'),
      checkpoint?: {
        errorCount?: long(name='ErrorCount'),
        height?: long(name='Height'),
        index?: long(name='Index'),
        type?: string(name='Type'),
      }(name='Checkpoint'),
      createTime?: long(name='CreateTime'),
      errorMessage?: string(name='ErrorMessage'),
      name?: string(name='Name'),
      options?: string(name='Options'),
      source?: string(name='Source'),
      status?: int32(name='Status'),
      type?: string(name='Type'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model DescribeOrganizationTriggersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeOrganizationTriggersResponseBody(name='body'),
}

/**
 * @param request DescribeOrganizationTriggersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeOrganizationTriggersResponse
 */
async function describeOrganizationTriggersWithOptions(request: DescribeOrganizationTriggersRequest, runtime: Util.RuntimeOptions): DescribeOrganizationTriggersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOrganizationTriggers',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeOrganizationTriggersRequest
 * @return DescribeOrganizationTriggersResponse
 */
async function describeOrganizationTriggers(request: DescribeOrganizationTriggersRequest): DescribeOrganizationTriggersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOrganizationTriggersWithOptions(request, runtime);
}

model DescribeOrganizationUserCertsRequest {
  organizationId?: string(name='OrganizationId', description='This parameter is required.', example='peers-aaaaaa2-1eqnj5o5w****'),
  username?: string(name='Username', description='This parameter is required.', example='username'),
}

model DescribeOrganizationUserCertsResponseBody = {
  dynamicCode?: string(name='DynamicCode', example='11'),
  dynamicMessage?: string(name='DynamicMessage', example='11'),
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: {
    certificates?: [ 
      {
        certData?: string(name='CertData', example='aa'),
        issuer?: string(name='Issuer', example='aa'),
        name?: string(name='Name', example='aa'),
        scope?: string(name='Scope', example='aa'),
        subject?: string(name='Subject', example='aa'),
        validFrom?: string(name='ValidFrom', example='aa'),
        validTo?: string(name='ValidTo', example='aaa'),
      }
    ](name='Certificates'),
    keyPair?: {
      privateKey?: string(name='PrivateKey', example='aa'),
      publicKey?: string(name='PublicKey', example='aa'),
    }(name='KeyPair'),
  }(name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeOrganizationUserCertsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeOrganizationUserCertsResponseBody(name='body'),
}

/**
 * @param request DescribeOrganizationUserCertsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeOrganizationUserCertsResponse
 */
async function describeOrganizationUserCertsWithOptions(request: DescribeOrganizationUserCertsRequest, runtime: Util.RuntimeOptions): DescribeOrganizationUserCertsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.username)) {
    body['Username'] = request.username;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOrganizationUserCerts',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeOrganizationUserCertsRequest
 * @return DescribeOrganizationUserCertsResponse
 */
async function describeOrganizationUserCerts(request: DescribeOrganizationUserCertsRequest): DescribeOrganizationUserCertsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOrganizationUserCertsWithOptions(request, runtime);
}

model DescribeOrganizationUsersRequest {
  location?: string(name='Location', example='cn-hangzhou'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.', example='peers-aaaaaa2-1eqnj5o5w****'),
}

model DescribeOrganizationUsersResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: [ 
    {
      attrs?: string(name='Attrs', example='a'),
      callerBid?: string(name='CallerBid', example='23425'),
      callerUid?: long(name='CallerUid', example='35645'),
      createTime?: string(name='CreateTime', example='1533025590'),
      expireTime?: string(name='ExpireTime', example='1533025590'),
      fullName?: string(name='FullName', example='name'),
      organizationId?: string(name='OrganizationId', example='peers-aaaaaa2-1eqnj5o5w9dt3'),
      regionId?: string(name='RegionId', example='cn-hangzhou'),
      username?: string(name='Username', example='username'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeOrganizationUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeOrganizationUsersResponseBody(name='body'),
}

/**
 * @param request DescribeOrganizationUsersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeOrganizationUsersResponse
 */
async function describeOrganizationUsersWithOptions(request: DescribeOrganizationUsersRequest, runtime: Util.RuntimeOptions): DescribeOrganizationUsersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOrganizationUsers',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeOrganizationUsersRequest
 * @return DescribeOrganizationUsersResponse
 */
async function describeOrganizationUsers(request: DescribeOrganizationUsersRequest): DescribeOrganizationUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOrganizationUsersWithOptions(request, runtime);
}

model DescribeOrganizationsRequest {
  location?: string(name='Location', example='cn-hangzhou'),
  tag?: [ 
    {
      key?: string(name='Key', description='This parameter is required.'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model DescribeOrganizationsResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: [ 
    {
      codeName?: string(name='CodeName', example='name'),
      consortiumCount?: int32(name='ConsortiumCount', example='2'),
      createTime?: string(name='CreateTime', example='1533025590'),
      description?: string(name='Description', example='desc'),
      domain?: string(name='Domain', example='domain'),
      expireState?: string(name='ExpireState'),
      expiredTime?: string(name='ExpiredTime', example='1533025590'),
      hybrid?: boolean(name='Hybrid', example='true'),
      majorVersion?: string(name='MajorVersion'),
      name?: string(name='Name', example='name'),
      organizationId?: string(name='OrganizationId', example='peers-aaaaaa2-1eqnj5o5w9dt3'),
      ownerBid?: string(name='OwnerBid', example='bid'),
      ownerName?: string(name='OwnerName', example='name'),
      ownerUid?: long(name='OwnerUid', example='1232'),
      peerCount?: int32(name='PeerCount', example='2'),
      regionId?: string(name='RegionId', example='cn-hangzhou'),
      requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
      specName?: string(name='SpecName', example='basic'),
      state?: string(name='State', example='Running'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      userCount?: int32(name='UserCount', example='3'),
      zoneId?: string(name='ZoneId', example='zone'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeOrganizationsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeOrganizationsResponseBody(name='body'),
}

/**
 * @param request DescribeOrganizationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeOrganizationsResponse
 */
async function describeOrganizationsWithOptions(request: DescribeOrganizationsRequest, runtime: Util.RuntimeOptions): DescribeOrganizationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOrganizations',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeOrganizationsRequest
 * @return DescribeOrganizationsResponse
 */
async function describeOrganizations(request: DescribeOrganizationsRequest): DescribeOrganizationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOrganizationsWithOptions(request, runtime);
}

model DescribeOrgnaizationChaincodesRequest {
  location?: string(name='Location'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model DescribeOrgnaizationChaincodesResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      chaincodeId?: string(name='ChaincodeId'),
      channelId?: string(name='ChannelId'),
      channelName?: string(name='ChannelName'),
      createTime?: string(name='CreateTime'),
      creator?: string(name='Creator'),
      deployTime?: string(name='DeployTime'),
      endorsePolicy?: string(name='EndorsePolicy'),
      installed?: string(name='Installed'),
      message?: string(name='Message'),
      name?: string(name='Name'),
      state?: string(name='State'),
      version?: string(name='Version'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model DescribeOrgnaizationChaincodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeOrgnaizationChaincodesResponseBody(name='body'),
}

/**
 * @param request DescribeOrgnaizationChaincodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeOrgnaizationChaincodesResponse
 */
async function describeOrgnaizationChaincodesWithOptions(request: DescribeOrgnaizationChaincodesRequest, runtime: Util.RuntimeOptions): DescribeOrgnaizationChaincodesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOrgnaizationChaincodes',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeOrgnaizationChaincodesRequest
 * @return DescribeOrgnaizationChaincodesResponse
 */
async function describeOrgnaizationChaincodes(request: DescribeOrgnaizationChaincodesRequest): DescribeOrgnaizationChaincodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOrgnaizationChaincodesWithOptions(request, runtime);
}

model DescribeOssPropertiesRequest {
  bizid?: string(name='Bizid'),
}

model DescribeOssPropertiesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    accessKeyId?: string(name='AccessKeyId'),
    accessKeySecret?: string(name='AccessKeySecret'),
    bucketName?: string(name='BucketName'),
    endpoint?: string(name='Endpoint'),
    folderName?: string(name='FolderName'),
  }(name='Result'),
}

model DescribeOssPropertiesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeOssPropertiesResponseBody(name='body'),
}

/**
 * @param request DescribeOssPropertiesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeOssPropertiesResponse
 */
async function describeOssPropertiesWithOptions(request: DescribeOssPropertiesRequest, runtime: Util.RuntimeOptions): DescribeOssPropertiesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOssProperties',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeOssPropertiesRequest
 * @return DescribeOssPropertiesResponse
 */
async function describeOssProperties(request: DescribeOssPropertiesRequest): DescribeOssPropertiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOssPropertiesWithOptions(request, runtime);
}

model DescribePeerLogsRequest {
  lines?: string(name='Lines'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
  peerName?: string(name='PeerName', description='This parameter is required.'),
}

model DescribePeerLogsResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model DescribePeerLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePeerLogsResponseBody(name='body'),
}

/**
 * @param request DescribePeerLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePeerLogsResponse
 */
async function describePeerLogsWithOptions(request: DescribePeerLogsRequest, runtime: Util.RuntimeOptions): DescribePeerLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lines)) {
    query['Lines'] = request.lines;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.peerName)) {
    query['PeerName'] = request.peerName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePeerLogs',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribePeerLogsRequest
 * @return DescribePeerLogsResponse
 */
async function describePeerLogs(request: DescribePeerLogsRequest): DescribePeerLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePeerLogsWithOptions(request, runtime);
}

model DescribePublicAntChainContractProjectContentTreeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    children?: [  map[string]any ](name='Children'),
  }(name='Result'),
}

model DescribePublicAntChainContractProjectContentTreeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePublicAntChainContractProjectContentTreeResponseBody(name='body'),
}

/**
 * @param request DescribePublicAntChainContractProjectContentTreeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePublicAntChainContractProjectContentTreeResponse
 */
async function describePublicAntChainContractProjectContentTreeWithOptions(runtime: Util.RuntimeOptions): DescribePublicAntChainContractProjectContentTreeResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribePublicAntChainContractProjectContentTree',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribePublicAntChainContractProjectContentTreeResponse
 */
async function describePublicAntChainContractProjectContentTree(): DescribePublicAntChainContractProjectContentTreeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePublicAntChainContractProjectContentTreeWithOptions(runtime);
}

model DescribePublicAntChainDownloadPathsRequest {
  bizid?: string(name='Bizid'),
}

model DescribePublicAntChainDownloadPathsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    caCrtUrl?: string(name='CaCrtUrl'),
    clientCrtUrl?: string(name='ClientCrtUrl'),
    sdkUrl?: string(name='SdkUrl'),
    trustCaUrl?: string(name='TrustCaUrl'),
  }(name='Result'),
}

model DescribePublicAntChainDownloadPathsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePublicAntChainDownloadPathsResponseBody(name='body'),
}

/**
 * @param request DescribePublicAntChainDownloadPathsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePublicAntChainDownloadPathsResponse
 */
async function describePublicAntChainDownloadPathsWithOptions(request: DescribePublicAntChainDownloadPathsRequest, runtime: Util.RuntimeOptions): DescribePublicAntChainDownloadPathsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribePublicAntChainDownloadPaths',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribePublicAntChainDownloadPathsRequest
 * @return DescribePublicAntChainDownloadPathsResponse
 */
async function describePublicAntChainDownloadPaths(request: DescribePublicAntChainDownloadPathsRequest): DescribePublicAntChainDownloadPathsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePublicAntChainDownloadPathsWithOptions(request, runtime);
}

model DescribePublicCloudIDEEnvConfigsRequest {
  bizid?: string(name='Bizid'),
}

model DescribePublicCloudIDEEnvConfigsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      bizid?: string(name='Bizid'),
      name?: string(name='Name'),
      trialAccount?: string(name='TrialAccount'),
      trialAccountPrivateKey?: string(name='TrialAccountPrivateKey'),
      version?: string(name='Version'),
    }
  ](name='Result'),
}

model DescribePublicCloudIDEEnvConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePublicCloudIDEEnvConfigsResponseBody(name='body'),
}

/**
 * @param request DescribePublicCloudIDEEnvConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePublicCloudIDEEnvConfigsResponse
 */
async function describePublicCloudIDEEnvConfigsWithOptions(request: DescribePublicCloudIDEEnvConfigsRequest, runtime: Util.RuntimeOptions): DescribePublicCloudIDEEnvConfigsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribePublicCloudIDEEnvConfigs',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribePublicCloudIDEEnvConfigsRequest
 * @return DescribePublicCloudIDEEnvConfigsResponse
 */
async function describePublicCloudIDEEnvConfigs(request: DescribePublicCloudIDEEnvConfigsRequest): DescribePublicCloudIDEEnvConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePublicCloudIDEEnvConfigsWithOptions(request, runtime);
}

model DescribeQRCodeAccessLogRequest {
  bizid?: string(name='Bizid'),
}

model DescribeQRCodeAccessLogResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    accessAlipayAccountCount?: long(name='AccessAlipayAccountCount'),
    accessCount?: long(name='AccessCount'),
  }(name='Result'),
}

model DescribeQRCodeAccessLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeQRCodeAccessLogResponseBody(name='body'),
}

/**
 * @param request DescribeQRCodeAccessLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeQRCodeAccessLogResponse
 */
async function describeQRCodeAccessLogWithOptions(request: DescribeQRCodeAccessLogRequest, runtime: Util.RuntimeOptions): DescribeQRCodeAccessLogResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeQRCodeAccessLog',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeQRCodeAccessLogRequest
 * @return DescribeQRCodeAccessLogResponse
 */
async function describeQRCodeAccessLog(request: DescribeQRCodeAccessLogRequest): DescribeQRCodeAccessLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeQRCodeAccessLogWithOptions(request, runtime);
}

model DescribeQRCodeAuthorityRequest {
  bizid?: string(name='Bizid'),
}

model DescribeQRCodeAuthorityResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DescribeQRCodeAuthorityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeQRCodeAuthorityResponseBody(name='body'),
}

/**
 * @param request DescribeQRCodeAuthorityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeQRCodeAuthorityResponse
 */
async function describeQRCodeAuthorityWithOptions(request: DescribeQRCodeAuthorityRequest, runtime: Util.RuntimeOptions): DescribeQRCodeAuthorityResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeQRCodeAuthority',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeQRCodeAuthorityRequest
 * @return DescribeQRCodeAuthorityResponse
 */
async function describeQRCodeAuthority(request: DescribeQRCodeAuthorityRequest): DescribeQRCodeAuthorityResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeQRCodeAuthorityWithOptions(request, runtime);
}

model DescribeRegionsResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='29857326-A574-49A7-897C-E428471D79D6'),
  result?: [ 
    {
      id?: int32(name='Id', description='Id', example='1'),
      online?: boolean(name='Online', example='true'),
      regionId?: string(name='RegionId', example='cn-hangzhou'),
      title?: string(name='Title'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

/**
 * @param request DescribeRegionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRegionsResponse
 */
async function describeRegionsWithOptions(runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeRegionsResponse
 */
async function describeRegions(): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(runtime);
}

model DescribeResourceTypeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      cpu?: int32(name='Cpu'),
      disk?: int32(name='Disk'),
      memory?: int32(name='Memory'),
      typeId?: int32(name='TypeId'),
      typeName?: string(name='TypeName'),
    }
  ](name='Result'),
}

model DescribeResourceTypeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeResourceTypeResponseBody(name='body'),
}

/**
 * @param request DescribeResourceTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeResourceTypeResponse
 */
async function describeResourceTypeWithOptions(runtime: Util.RuntimeOptions): DescribeResourceTypeResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeResourceType',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeResourceTypeResponse
 */
async function describeResourceType(): DescribeResourceTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeResourceTypeWithOptions(runtime);
}

model DescribeResourceTypesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      cpu?: int32(name='Cpu'),
      disk?: int32(name='Disk'),
      memory?: int32(name='Memory'),
      typeId?: int32(name='TypeId'),
      typeName?: string(name='TypeName'),
    }
  ](name='Result'),
}

model DescribeResourceTypesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeResourceTypesResponseBody(name='body'),
}

/**
 * @param request DescribeResourceTypesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeResourceTypesResponse
 */
async function describeResourceTypesWithOptions(runtime: Util.RuntimeOptions): DescribeResourceTypesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeResourceTypes',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeResourceTypesResponse
 */
async function describeResourceTypes(): DescribeResourceTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeResourceTypesWithOptions(runtime);
}

model DescribeRootDomainResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: string(name='Result', example='onaliyunbaas.com'),
  success?: boolean(name='Success', example='true'),
}

model DescribeRootDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRootDomainResponseBody(name='body'),
}

/**
 * @param request DescribeRootDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRootDomainResponse
 */
async function describeRootDomainWithOptions(runtime: Util.RuntimeOptions): DescribeRootDomainResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeRootDomain',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeRootDomainResponse
 */
async function describeRootDomain(): DescribeRootDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRootDomainWithOptions(runtime);
}

model DescribeSchemaDetailRequest {
  bizid?: string(name='Bizid'),
  schemaId?: long(name='SchemaId'),
}

model DescribeSchemaDetailResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    responses?: [ 
      {
        category?: string(name='Category'),
        categoryName?: string(name='CategoryName'),
        description?: string(name='Description'),
        properties?: {
          count?: int32(name='Count'),
          dataSource?: [ 
            {
              allowNull?: int32(name='AllowNull'),
              annotation?: string(name='Annotation'),
              field?: string(name='Field'),
              indexes?: int32(name='Indexes'),
              key?: int32(name='Key'),
              length?: int32(name='Length'),
              reg?: string(name='Reg'),
              type?: string(name='Type'),
            }
          ](name='DataSource'),
        }(name='Properties'),
      }
    ](name='Responses'),
    schema?: {
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      id?: long(name='Id'),
      isTemplate?: boolean(name='IsTemplate'),
      name?: string(name='Name'),
      updateTime?: long(name='UpdateTime'),
      version?: long(name='Version'),
    }(name='Schema'),
  }(name='Result'),
}

model DescribeSchemaDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSchemaDetailResponseBody(name='body'),
}

/**
 * @param request DescribeSchemaDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSchemaDetailResponse
 */
async function describeSchemaDetailWithOptions(request: DescribeSchemaDetailRequest, runtime: Util.RuntimeOptions): DescribeSchemaDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.schemaId)) {
    body['SchemaId'] = request.schemaId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSchemaDetail',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeSchemaDetailRequest
 * @return DescribeSchemaDetailResponse
 */
async function describeSchemaDetail(request: DescribeSchemaDetailRequest): DescribeSchemaDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSchemaDetailWithOptions(request, runtime);
}

model DescribeSmartContractJobStatusRequest {
  jobId?: string(name='JobId', description='This parameter is required.'),
}

model DescribeSmartContractJobStatusResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeSmartContractJobStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSmartContractJobStatusResponseBody(name='body'),
}

/**
 * @param request DescribeSmartContractJobStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSmartContractJobStatusResponse
 */
async function describeSmartContractJobStatusWithOptions(request: DescribeSmartContractJobStatusRequest, runtime: Util.RuntimeOptions): DescribeSmartContractJobStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.jobId)) {
    body['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSmartContractJobStatus',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeSmartContractJobStatusRequest
 * @return DescribeSmartContractJobStatusResponse
 */
async function describeSmartContractJobStatus(request: DescribeSmartContractJobStatusRequest): DescribeSmartContractJobStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSmartContractJobStatusWithOptions(request, runtime);
}

model DescribeSmartContractJobsRequest {
  size?: int32(name='Size', description='This parameter is required.'),
  start?: int32(name='Start', description='This parameter is required.'),
}

model DescribeSmartContractJobsResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    content?: [ 
      {
        createTime?: long(name='CreateTime'),
        finishedTime?: long(name='FinishedTime'),
        jobId?: string(name='JobId'),
        name?: string(name='Name'),
        sourceType?: string(name='SourceType'),
        status?: string(name='Status'),
        userBid?: string(name='UserBid'),
        userId?: long(name='UserId'),
      }
    ](name='Content'),
    first?: boolean(name='First'),
    last?: boolean(name='Last'),
    numberOfElements?: int32(name='NumberOfElements'),
    size?: int32(name='Size'),
    totalElements?: int32(name='TotalElements'),
    totalPages?: int32(name='TotalPages'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeSmartContractJobsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSmartContractJobsResponseBody(name='body'),
}

/**
 * @param request DescribeSmartContractJobsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSmartContractJobsResponse
 */
async function describeSmartContractJobsWithOptions(request: DescribeSmartContractJobsRequest, runtime: Util.RuntimeOptions): DescribeSmartContractJobsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  if (!Util.isUnset(request.start)) {
    body['Start'] = request.start;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSmartContractJobs',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeSmartContractJobsRequest
 * @return DescribeSmartContractJobsResponse
 */
async function describeSmartContractJobs(request: DescribeSmartContractJobsRequest): DescribeSmartContractJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSmartContractJobsWithOptions(request, runtime);
}

model DescribeSmartContractJobsByNameRequest {
  name?: string(name='Name'),
  size?: int32(name='Size'),
  start?: int32(name='Start', description='This parameter is required.'),
}

model DescribeSmartContractJobsByNameResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    content?: [ 
      {
        createTime?: long(name='CreateTime'),
        finishedTime?: long(name='FinishedTime'),
        jobId?: string(name='JobId'),
        name?: string(name='Name'),
        sourceType?: string(name='SourceType'),
        status?: string(name='Status'),
        userBid?: string(name='UserBid'),
        userId?: string(name='UserId'),
      }
    ](name='Content'),
    first?: boolean(name='First'),
    last?: boolean(name='Last'),
    numberOfElements?: int32(name='NumberOfElements'),
    size?: int32(name='Size'),
    totalElements?: int32(name='TotalElements'),
    totalPages?: int32(name='TotalPages'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeSmartContractJobsByNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSmartContractJobsByNameResponseBody(name='body'),
}

/**
 * @param request DescribeSmartContractJobsByNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSmartContractJobsByNameResponse
 */
async function describeSmartContractJobsByNameWithOptions(request: DescribeSmartContractJobsByNameRequest, runtime: Util.RuntimeOptions): DescribeSmartContractJobsByNameResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  if (!Util.isUnset(request.start)) {
    body['Start'] = request.start;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSmartContractJobsByName',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeSmartContractJobsByNameRequest
 * @return DescribeSmartContractJobsByNameResponse
 */
async function describeSmartContractJobsByName(request: DescribeSmartContractJobsByNameRequest): DescribeSmartContractJobsByNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSmartContractJobsByNameWithOptions(request, runtime);
}

model DescribeSmartContractResultRequest {
  jobId?: string(name='JobId', description='This parameter is required.'),
}

model DescribeSmartContractResultResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeSmartContractResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSmartContractResultResponseBody(name='body'),
}

/**
 * @param request DescribeSmartContractResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSmartContractResultResponse
 */
async function describeSmartContractResultWithOptions(request: DescribeSmartContractResultRequest, runtime: Util.RuntimeOptions): DescribeSmartContractResultResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.jobId)) {
    body['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSmartContractResult',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeSmartContractResultRequest
 * @return DescribeSmartContractResultResponse
 */
async function describeSmartContractResult(request: DescribeSmartContractResultRequest): DescribeSmartContractResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSmartContractResultWithOptions(request, runtime);
}

model DescribeSmartContractResultContentRequest {
  jobId?: string(name='JobId', description='This parameter is required.'),
}

model DescribeSmartContractResultContentResponseBody = {
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      diagnostics?: [ 
        {
          advice?: string(name='Advice'),
          code?: string(name='Code'),
          detail?: string(name='Detail'),
          message?: string(name='Message'),
          range?: [ 
            {
              character?: int32(name='Character'),
              line?: int32(name='Line'),
            }
          ](name='Range'),
          severity?: int32(name='Severity'),
          source?: string(name='Source'),
          trace?: [ 
            {
              location?: {
                range?: [ 
                  {
                    character?: int32(name='Character'),
                    line?: int32(name='Line'),
                  }
                ](name='Range'),
                uri?: string(name='Uri'),
              }(name='Location'),
              message?: string(name='Message'),
            }
          ](name='Trace'),
        }
      ](name='Diagnostics'),
      uri?: string(name='Uri'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model DescribeSmartContractResultContentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSmartContractResultContentResponseBody(name='body'),
}

/**
 * @param request DescribeSmartContractResultContentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSmartContractResultContentResponse
 */
async function describeSmartContractResultContentWithOptions(request: DescribeSmartContractResultContentRequest, runtime: Util.RuntimeOptions): DescribeSmartContractResultContentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.jobId)) {
    body['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSmartContractResultContent',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeSmartContractResultContentRequest
 * @return DescribeSmartContractResultContentResponse
 */
async function describeSmartContractResultContent(request: DescribeSmartContractResultContentRequest): DescribeSmartContractResultContentResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSmartContractResultContentWithOptions(request, runtime);
}

model DescribeSubscribeCloudServiceIntegrationStateRequest {
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model DescribeSubscribeCloudServiceIntegrationStateResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeSubscribeCloudServiceIntegrationStateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSubscribeCloudServiceIntegrationStateResponseBody(name='body'),
}

/**
 * @param request DescribeSubscribeCloudServiceIntegrationStateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSubscribeCloudServiceIntegrationStateResponse
 */
async function describeSubscribeCloudServiceIntegrationStateWithOptions(request: DescribeSubscribeCloudServiceIntegrationStateRequest, runtime: Util.RuntimeOptions): DescribeSubscribeCloudServiceIntegrationStateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSubscribeCloudServiceIntegrationState',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeSubscribeCloudServiceIntegrationStateRequest
 * @return DescribeSubscribeCloudServiceIntegrationStateResponse
 */
async function describeSubscribeCloudServiceIntegrationState(request: DescribeSubscribeCloudServiceIntegrationStateRequest): DescribeSubscribeCloudServiceIntegrationStateResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSubscribeCloudServiceIntegrationStateWithOptions(request, runtime);
}

model DescribeTasksResponseBody = {
  dynamicCode?: string(name='DynamicCode', example='111'),
  dynamicMessage?: string(name='DynamicMessage', example='111'),
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: [ 
    {
      action?: string(name='Action', example='action'),
      assignee?: string(name='Assignee'),
      handled?: boolean(name='Handled', example='false'),
      operationType?: string(name='OperationType', example='type'),
      requestTime?: long(name='RequestTime', example='1533025590'),
      responseTime?: string(name='ResponseTime', example='1533025590'),
      result?: string(name='Result', example='result'),
      sender?: string(name='Sender', example='sender'),
      target?: string(name='Target', example='target'),
      taskId?: int32(name='TaskId', example='33'),
      taskState?: string(name='TaskState'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DescribeTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTasksResponseBody(name='body'),
}

/**
 * @param request DescribeTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTasksResponse
 */
async function describeTasksWithOptions(runtime: Util.RuntimeOptions): DescribeTasksResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeTasks',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeTasksResponse
 */
async function describeTasks(): DescribeTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTasksWithOptions(runtime);
}

model DescribeTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    schemaList?: [ 
      {
        createTime?: long(name='CreateTime'),
        description?: string(name='Description'),
        id?: long(name='Id'),
        isTemplate?: int32(name='IsTemplate'),
        name?: string(name='Name'),
        updateTime?: long(name='UpdateTime'),
        version?: long(name='Version'),
      }
    ](name='SchemaList'),
  }(name='Result'),
}

model DescribeTemplatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTemplatesResponseBody(name='body'),
}

/**
 * @param request DescribeTemplatesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTemplatesResponse
 */
async function describeTemplatesWithOptions(runtime: Util.RuntimeOptions): DescribeTemplatesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeTemplates',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeTemplatesResponse
 */
async function describeTemplates(): DescribeTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTemplatesWithOptions(runtime);
}

model DescribeTransactionRequest {
  bizid?: string(name='Bizid'),
  hash?: string(name='Hash'),
}

model DescribeTransactionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    blockHash?: string(name='BlockHash'),
    blockHeight?: long(name='BlockHeight'),
    blockVersion?: int32(name='BlockVersion'),
    category?: int32(name='Category'),
    content?: string(name='Content'),
    contentHash?: string(name='ContentHash'),
    createTime?: long(name='CreateTime'),
    hash?: string(name='Hash'),
    keyName?: string(name='KeyName'),
    keyWrap?: string(name='KeyWrap'),
    nonce?: string(name='Nonce'),
    referenceCount?: int32(name='ReferenceCount'),
    referenceList?: [ string ](name='ReferenceList'),
    transTypeV6?: string(name='TransTypeV6'),
    transactionV10?: {
      data?: string(name='Data'),
      extentions?: [ string ](name='Extentions'),
      from?: string(name='From'),
      gas?: string(name='Gas'),
      hash?: string(name='Hash'),
      nonce?: string(name='Nonce'),
      period?: long(name='Period'),
      signatureList?: [ string ](name='SignatureList'),
      timestamp?: long(name='Timestamp'),
      to?: string(name='To'),
      txType?: string(name='TxType'),
      value?: string(name='Value'),
    }(name='TransactionV10'),
  }(name='Result'),
}

model DescribeTransactionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTransactionResponseBody(name='body'),
}

/**
 * @param request DescribeTransactionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTransactionResponse
 */
async function describeTransactionWithOptions(request: DescribeTransactionRequest, runtime: Util.RuntimeOptions): DescribeTransactionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.hash)) {
    body['Hash'] = request.hash;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTransaction',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeTransactionRequest
 * @return DescribeTransactionResponse
 */
async function describeTransaction(request: DescribeTransactionRequest): DescribeTransactionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTransactionWithOptions(request, runtime);
}

model DescribeTransactionFor2CBrowserRequest {
  alipayAuthCode?: string(name='AlipayAuthCode', description='This parameter is required.'),
  bizid?: string(name='Bizid', description='This parameter is required.'),
  hash?: string(name='Hash', description='This parameter is required.'),
}

model DescribeTransactionFor2CBrowserResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    blockHash?: string(name='BlockHash'),
    blockHeight?: long(name='BlockHeight'),
    blockVersion?: int32(name='BlockVersion'),
    category?: int32(name='Category'),
    content?: string(name='Content'),
    contentHash?: string(name='ContentHash'),
    createTime?: long(name='CreateTime'),
    hash?: string(name='Hash'),
    keyName?: string(name='KeyName'),
    keyWrap?: string(name='KeyWrap'),
    nonce?: string(name='Nonce'),
    referenceCount?: int32(name='ReferenceCount'),
    referenceList?: [ string ](name='ReferenceList'),
    transTypeV6?: string(name='TransTypeV6'),
    transactionV10?: {
      data?: string(name='Data'),
      extentions?: [ string ](name='Extentions'),
      from?: string(name='From'),
      gas?: string(name='Gas'),
      hash?: string(name='Hash'),
      nonce?: string(name='Nonce'),
      period?: long(name='Period'),
      signatureList?: [ string ](name='SignatureList'),
      timestamp?: long(name='Timestamp'),
      to?: string(name='To'),
      txType?: string(name='TxType'),
      value?: string(name='Value'),
    }(name='TransactionV10'),
  }(name='Result'),
}

model DescribeTransactionFor2CBrowserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTransactionFor2CBrowserResponseBody(name='body'),
}

/**
 * @param request DescribeTransactionFor2CBrowserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTransactionFor2CBrowserResponse
 */
async function describeTransactionFor2CBrowserWithOptions(request: DescribeTransactionFor2CBrowserRequest, runtime: Util.RuntimeOptions): DescribeTransactionFor2CBrowserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.alipayAuthCode)) {
    body['AlipayAuthCode'] = request.alipayAuthCode;
  }
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.hash)) {
    body['Hash'] = request.hash;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTransactionFor2CBrowser',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeTransactionFor2CBrowserRequest
 * @return DescribeTransactionFor2CBrowserResponse
 */
async function describeTransactionFor2CBrowser(request: DescribeTransactionFor2CBrowserRequest): DescribeTransactionFor2CBrowserResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTransactionFor2CBrowserWithOptions(request, runtime);
}

model DescribeTransactionQRCodeRequest {
  bizid?: string(name='Bizid'),
  hash?: string(name='Hash'),
}

model DescribeTransactionQRCodeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model DescribeTransactionQRCodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTransactionQRCodeResponseBody(name='body'),
}

/**
 * @param request DescribeTransactionQRCodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTransactionQRCodeResponse
 */
async function describeTransactionQRCodeWithOptions(request: DescribeTransactionQRCodeRequest, runtime: Util.RuntimeOptions): DescribeTransactionQRCodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.hash)) {
    body['Hash'] = request.hash;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTransactionQRCode',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeTransactionQRCodeRequest
 * @return DescribeTransactionQRCodeResponse
 */
async function describeTransactionQRCode(request: DescribeTransactionQRCodeRequest): DescribeTransactionQRCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTransactionQRCodeWithOptions(request, runtime);
}

model DescribeTransactionReceiptFor2CBrowserRequest {
  alipayAuthCode?: string(name='AlipayAuthCode'),
  bizid?: string(name='Bizid'),
  hash?: string(name='Hash'),
}

model DescribeTransactionReceiptFor2CBrowserResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    data?: string(name='Data'),
    gasUsed?: string(name='GasUsed'),
    logs?: [ string ](name='Logs'),
    result?: long(name='Result'),
  }(name='Result'),
}

model DescribeTransactionReceiptFor2CBrowserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTransactionReceiptFor2CBrowserResponseBody(name='body'),
}

/**
 * @param request DescribeTransactionReceiptFor2CBrowserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTransactionReceiptFor2CBrowserResponse
 */
async function describeTransactionReceiptFor2CBrowserWithOptions(request: DescribeTransactionReceiptFor2CBrowserRequest, runtime: Util.RuntimeOptions): DescribeTransactionReceiptFor2CBrowserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.alipayAuthCode)) {
    body['AlipayAuthCode'] = request.alipayAuthCode;
  }
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.hash)) {
    body['Hash'] = request.hash;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTransactionReceiptFor2CBrowser',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeTransactionReceiptFor2CBrowserRequest
 * @return DescribeTransactionReceiptFor2CBrowserResponse
 */
async function describeTransactionReceiptFor2CBrowser(request: DescribeTransactionReceiptFor2CBrowserRequest): DescribeTransactionReceiptFor2CBrowserResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTransactionReceiptFor2CBrowserWithOptions(request, runtime);
}

model DescribeTriggerRequest {
  channelId?: string(name='ChannelId', description='This parameter is required.'),
  name?: string(name='Name', description='This parameter is required.'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model DescribeTriggerResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    channelId?: string(name='ChannelId'),
    channelName?: string(name='ChannelName'),
    checkpoint?: {
      errorCount?: long(name='ErrorCount'),
      height?: long(name='Height'),
      index?: long(name='Index'),
      type?: string(name='Type'),
    }(name='Checkpoint'),
    createTime?: long(name='CreateTime'),
    errorMessage?: string(name='ErrorMessage'),
    name?: string(name='Name'),
    options?: string(name='Options'),
    source?: string(name='Source'),
    status?: int32(name='Status'),
    type?: string(name='Type'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTriggerResponseBody(name='body'),
}

/**
 * @param request DescribeTriggerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTriggerResponse
 */
async function describeTriggerWithOptions(request: DescribeTriggerRequest, runtime: Util.RuntimeOptions): DescribeTriggerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channelId)) {
    query['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTrigger',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeTriggerRequest
 * @return DescribeTriggerResponse
 */
async function describeTrigger(request: DescribeTriggerRequest): DescribeTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTriggerWithOptions(request, runtime);
}

model DestroyConsortiumRequest {
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.'),
}

model DestroyConsortiumResponseBody = {
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    consortiumId?: string(name='ConsortiumId'),
    name?: string(name='Name'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DestroyConsortiumResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DestroyConsortiumResponseBody(name='body'),
}

/**
 * @param request DestroyConsortiumRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DestroyConsortiumResponse
 */
async function destroyConsortiumWithOptions(request: DestroyConsortiumRequest, runtime: Util.RuntimeOptions): DestroyConsortiumResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DestroyConsortium',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DestroyConsortiumRequest
 * @return DestroyConsortiumResponse
 */
async function destroyConsortium(request: DestroyConsortiumRequest): DestroyConsortiumResponse {
  var runtime = new Util.RuntimeOptions{};
  return destroyConsortiumWithOptions(request, runtime);
}

model DestroyEthereumRequest {
  ethereumId?: string(name='EthereumId', description='This parameter is required.'),
}

model DestroyEthereumResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    consensus?: string(name='Consensus'),
    creator?: string(name='Creator'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    networkId?: string(name='NetworkId'),
    regionId?: string(name='RegionId'),
    state?: string(name='State'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DestroyEthereumResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DestroyEthereumResponseBody(name='body'),
}

/**
 * @param request DestroyEthereumRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DestroyEthereumResponse
 */
async function destroyEthereumWithOptions(request: DestroyEthereumRequest, runtime: Util.RuntimeOptions): DestroyEthereumResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ethereumId)) {
    body['EthereumId'] = request.ethereumId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DestroyEthereum',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DestroyEthereumRequest
 * @return DestroyEthereumResponse
 */
async function destroyEthereum(request: DestroyEthereumRequest): DestroyEthereumResponse {
  var runtime = new Util.RuntimeOptions{};
  return destroyEthereumWithOptions(request, runtime);
}

model DestroyOrganizationRequest {
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model DestroyOrganizationResponseBody = {
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    name?: string(name='Name'),
    organizationId?: string(name='OrganizationId'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DestroyOrganizationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DestroyOrganizationResponseBody(name='body'),
}

/**
 * @param request DestroyOrganizationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DestroyOrganizationResponse
 */
async function destroyOrganizationWithOptions(request: DestroyOrganizationRequest, runtime: Util.RuntimeOptions): DestroyOrganizationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DestroyOrganization',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DestroyOrganizationRequest
 * @return DestroyOrganizationResponse
 */
async function destroyOrganization(request: DestroyOrganizationRequest): DestroyOrganizationResponse {
  var runtime = new Util.RuntimeOptions{};
  return destroyOrganizationWithOptions(request, runtime);
}

model DownloadAllRequest {
  bizid?: string(name='Bizid'),
}

model DownloadAllResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    bizviewUrl?: string(name='BizviewUrl'),
    certUrl?: string(name='CertUrl'),
    sdkUrl?: string(name='SdkUrl'),
  }(name='Result'),
}

model DownloadAllResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DownloadAllResponseBody(name='body'),
}

/**
 * @param request DownloadAllRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DownloadAllResponse
 */
async function downloadAllWithOptions(request: DownloadAllRequest, runtime: Util.RuntimeOptions): DownloadAllResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DownloadAll',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DownloadAllRequest
 * @return DownloadAllResponse
 */
async function downloadAll(request: DownloadAllRequest): DownloadAllResponse {
  var runtime = new Util.RuntimeOptions{};
  return downloadAllWithOptions(request, runtime);
}

model DownloadBizviewRequest {
  bizid?: string(name='Bizid'),
}

model DownloadBizviewResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model DownloadBizviewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DownloadBizviewResponseBody(name='body'),
}

/**
 * @param request DownloadBizviewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DownloadBizviewResponse
 */
async function downloadBizviewWithOptions(request: DownloadBizviewRequest, runtime: Util.RuntimeOptions): DownloadBizviewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DownloadBizview',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DownloadBizviewRequest
 * @return DownloadBizviewResponse
 */
async function downloadBizview(request: DownloadBizviewRequest): DownloadBizviewResponse {
  var runtime = new Util.RuntimeOptions{};
  return downloadBizviewWithOptions(request, runtime);
}

model DownloadFabricChannelSDKRequest {
  channelId?: string(name='ChannelId'),
  location?: string(name='Location'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
  username?: string(name='Username', description='This parameter is required.'),
}

model DownloadFabricChannelSDKResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      content?: string(name='Content'),
      path?: string(name='Path'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model DownloadFabricChannelSDKResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DownloadFabricChannelSDKResponseBody(name='body'),
}

/**
 * @param request DownloadFabricChannelSDKRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DownloadFabricChannelSDKResponse
 */
async function downloadFabricChannelSDKWithOptions(request: DownloadFabricChannelSDKRequest, runtime: Util.RuntimeOptions): DownloadFabricChannelSDKResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.username)) {
    query['Username'] = request.username;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DownloadFabricChannelSDK',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DownloadFabricChannelSDKRequest
 * @return DownloadFabricChannelSDKResponse
 */
async function downloadFabricChannelSDK(request: DownloadFabricChannelSDKRequest): DownloadFabricChannelSDKResponse {
  var runtime = new Util.RuntimeOptions{};
  return downloadFabricChannelSDKWithOptions(request, runtime);
}

model DownloadOrganizationSDKRequest {
  location?: string(name='Location', example='cn-hangzhou'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.', example='peers-aaaaaa2-1eqnj5o5w****'),
  username?: string(name='Username', example='user'),
}

model DownloadOrganizationSDKResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: [ 
    {
      content?: string(name='Content', example='base64string'),
      path?: string(name='Path', example='dir/file'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model DownloadOrganizationSDKResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DownloadOrganizationSDKResponseBody(name='body'),
}

/**
 * @param request DownloadOrganizationSDKRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DownloadOrganizationSDKResponse
 */
async function downloadOrganizationSDKWithOptions(request: DownloadOrganizationSDKRequest, runtime: Util.RuntimeOptions): DownloadOrganizationSDKResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.username)) {
    query['Username'] = request.username;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DownloadOrganizationSDK',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DownloadOrganizationSDKRequest
 * @return DownloadOrganizationSDKResponse
 */
async function downloadOrganizationSDK(request: DownloadOrganizationSDKRequest): DownloadOrganizationSDKResponse {
  var runtime = new Util.RuntimeOptions{};
  return downloadOrganizationSDKWithOptions(request, runtime);
}

model DownloadSDK2Request {
  bizid?: string(name='Bizid'),
}

model DownloadSDK2ResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model DownloadSDK2Response = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DownloadSDK2ResponseBody(name='body'),
}

/**
 * @param request DownloadSDK2Request
 * @param runtime runtime options for this request RuntimeOptions
 * @return DownloadSDK2Response
 */
async function downloadSDK2WithOptions(request: DownloadSDK2Request, runtime: Util.RuntimeOptions): DownloadSDK2Response {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DownloadSDK2',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DownloadSDK2Request
 * @return DownloadSDK2Response
 */
async function downloadSDK2(request: DownloadSDK2Request): DownloadSDK2Response {
  var runtime = new Util.RuntimeOptions{};
  return downloadSDK2WithOptions(request, runtime);
}

model DownloadSdkRequest {
  bizid?: string(name='Bizid'),
}

model DownloadSdkResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model DownloadSdkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DownloadSdkResponseBody(name='body'),
}

/**
 * @param request DownloadSdkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DownloadSdkResponse
 */
async function downloadSdkWithOptions(request: DownloadSdkRequest, runtime: Util.RuntimeOptions): DownloadSdkResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DownloadSdk',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DownloadSdkRequest
 * @return DownloadSdkResponse
 */
async function downloadSdk(request: DownloadSdkRequest): DownloadSdkResponse {
  var runtime = new Util.RuntimeOptions{};
  return downloadSdkWithOptions(request, runtime);
}

model DownloadSignedDataRequest {
  bizid?: string(name='Bizid'),
  path?: string(name='Path'),
}

model DownloadSignedDataResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model DownloadSignedDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DownloadSignedDataResponseBody(name='body'),
}

/**
 * @param request DownloadSignedDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DownloadSignedDataResponse
 */
async function downloadSignedDataWithOptions(request: DownloadSignedDataRequest, runtime: Util.RuntimeOptions): DownloadSignedDataResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.path)) {
    body['Path'] = request.path;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DownloadSignedData',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DownloadSignedDataRequest
 * @return DownloadSignedDataResponse
 */
async function downloadSignedData(request: DownloadSignedDataRequest): DownloadSignedDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return downloadSignedDataWithOptions(request, runtime);
}

model DuplicateAntChainContractProjectRequest {
  description?: string(name='Description'),
  name?: string(name='Name'),
  projectId?: string(name='ProjectId'),
  projectVersion?: string(name='ProjectVersion'),
}

model DuplicateAntChainContractProjectResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    consortiumId?: string(name='ConsortiumId'),
    description?: string(name='Description'),
    gmtCreate?: long(name='GmtCreate'),
    gmtModified?: long(name='GmtModified'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    version?: string(name='Version'),
  }(name='Result'),
}

model DuplicateAntChainContractProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DuplicateAntChainContractProjectResponseBody(name='body'),
}

/**
 * @param request DuplicateAntChainContractProjectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DuplicateAntChainContractProjectResponse
 */
async function duplicateAntChainContractProjectWithOptions(request: DuplicateAntChainContractProjectRequest, runtime: Util.RuntimeOptions): DuplicateAntChainContractProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectVersion)) {
    body['ProjectVersion'] = request.projectVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DuplicateAntChainContractProject',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DuplicateAntChainContractProjectRequest
 * @return DuplicateAntChainContractProjectResponse
 */
async function duplicateAntChainContractProject(request: DuplicateAntChainContractProjectRequest): DuplicateAntChainContractProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return duplicateAntChainContractProjectWithOptions(request, runtime);
}

model FreezeAccountRequest {
  account?: string(name='Account'),
  bizid?: string(name='Bizid'),
}

model FreezeAccountResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model FreezeAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: FreezeAccountResponseBody(name='body'),
}

/**
 * @param request FreezeAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return FreezeAccountResponse
 */
async function freezeAccountWithOptions(request: FreezeAccountRequest, runtime: Util.RuntimeOptions): FreezeAccountResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.account)) {
    body['Account'] = request.account;
  }
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FreezeAccount',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request FreezeAccountRequest
 * @return FreezeAccountResponse
 */
async function freezeAccount(request: FreezeAccountRequest): FreezeAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return freezeAccountWithOptions(request, runtime);
}

model FreezeAntChainAccountRequest {
  account?: string(name='Account', description='This parameter is required.'),
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
}

model FreezeAntChainAccountResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model FreezeAntChainAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: FreezeAntChainAccountResponseBody(name='body'),
}

/**
 * @param request FreezeAntChainAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return FreezeAntChainAccountResponse
 */
async function freezeAntChainAccountWithOptions(request: FreezeAntChainAccountRequest, runtime: Util.RuntimeOptions): FreezeAntChainAccountResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.account)) {
    body['Account'] = request.account;
  }
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FreezeAntChainAccount',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request FreezeAntChainAccountRequest
 * @return FreezeAntChainAccountResponse
 */
async function freezeAntChainAccount(request: FreezeAntChainAccountRequest): FreezeAntChainAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return freezeAntChainAccountWithOptions(request, runtime);
}

model GetAppliesRequest {
  bizid?: string(name='Bizid'),
  current?: int32(name='Current'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
}

model GetAppliesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    applyHistoryList?: [ 
      {
        bizid?: string(name='Bizid'),
        createtime?: long(name='Createtime'),
        id?: int32(name='Id'),
        rejectReason?: string(name='RejectReason'),
        reqAddr?: string(name='ReqAddr'),
        signedAddr?: string(name='SignedAddr'),
        status?: int32(name='Status'),
        updatetime?: long(name='Updatetime'),
        username?: string(name='Username'),
      }
    ](name='ApplyHistoryList'),
    pagination?: {
      current?: int32(name='Current'),
      pageSize?: int32(name='PageSize'),
      total?: int32(name='Total'),
    }(name='Pagination'),
  }(name='Result'),
}

model GetAppliesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAppliesResponseBody(name='body'),
}

/**
 * @param request GetAppliesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAppliesResponse
 */
async function getAppliesWithOptions(request: GetAppliesRequest, runtime: Util.RuntimeOptions): GetAppliesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetApplies',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetAppliesRequest
 * @return GetAppliesResponse
 */
async function getApplies(request: GetAppliesRequest): GetAppliesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAppliesWithOptions(request, runtime);
}

model GetBcSchemaRequest {
  bizid?: string(name='Bizid'),
}

model GetBcSchemaResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    responses?: [ 
      {
        category?: string(name='Category'),
        categoryName?: string(name='CategoryName'),
        description?: string(name='Description'),
        properties?: {
          count?: int32(name='Count'),
          dataSource?: [ 
            {
              allowNull?: int32(name='AllowNull'),
              annotation?: string(name='Annotation'),
              field?: string(name='Field'),
              indexes?: int32(name='Indexes'),
              key?: int32(name='Key'),
              length?: int32(name='Length'),
              reg?: string(name='Reg'),
              type?: string(name='Type'),
            }
          ](name='DataSource'),
        }(name='Properties'),
      }
    ](name='Responses'),
    schema?: {
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      id?: long(name='Id'),
      isTemplate?: boolean(name='IsTemplate'),
      name?: string(name='Name'),
      updateTime?: long(name='UpdateTime'),
      version?: long(name='Version'),
    }(name='Schema'),
  }(name='Result'),
}

model GetBcSchemaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetBcSchemaResponseBody(name='body'),
}

/**
 * @param request GetBcSchemaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetBcSchemaResponse
 */
async function getBcSchemaWithOptions(request: GetBcSchemaRequest, runtime: Util.RuntimeOptions): GetBcSchemaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetBcSchema',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetBcSchemaRequest
 * @return GetBcSchemaResponse
 */
async function getBcSchema(request: GetBcSchemaRequest): GetBcSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBcSchemaWithOptions(request, runtime);
}

model GetBlockchainCreateTaskRequest {
  current?: int32(name='Current'),
  pageSize?: int32(name='PageSize'),
}

model GetBlockchainCreateTaskResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    blockchainCreateTasks?: {
      blockchainCreateTasks?: [ 
      {
        bizid?: string(name='Bizid'),
        createTime?: long(name='CreateTime'),
        memo?: string(name='Memo'),
        name?: string(name='Name'),
        status?: string(name='Status'),
      }
    ](name='BlockchainCreateTasks')
    }(name='BlockchainCreateTasks'),
    pagination?: {
      current?: int32(name='Current'),
      pageSize?: int32(name='PageSize'),
      total?: int32(name='Total'),
    }(name='Pagination'),
  }(name='Result'),
}

model GetBlockchainCreateTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetBlockchainCreateTaskResponseBody(name='body'),
}

/**
 * @param request GetBlockchainCreateTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetBlockchainCreateTaskResponse
 */
async function getBlockchainCreateTaskWithOptions(request: GetBlockchainCreateTaskRequest, runtime: Util.RuntimeOptions): GetBlockchainCreateTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetBlockchainCreateTask',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetBlockchainCreateTaskRequest
 * @return GetBlockchainCreateTaskResponse
 */
async function getBlockchainCreateTask(request: GetBlockchainCreateTaskRequest): GetBlockchainCreateTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBlockchainCreateTaskWithOptions(request, runtime);
}

model GetBlockchainInfoRequest {
  bizid?: string(name='Bizid'),
}

model GetBlockchainInfoResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    abnormalNodes?: int32(name='AbnormalNodes'),
    bizid?: string(name='Bizid'),
    blockHeight?: int32(name='BlockHeight'),
    createTime?: long(name='CreateTime'),
    isRole?: boolean(name='IsRole'),
    nodeInfoList?: [ 
      {
        blockHeight?: long(name='BlockHeight'),
        nodeName?: string(name='NodeName'),
        status?: boolean(name='Status'),
        version?: string(name='Version'),
      }
    ](name='NodeInfoList'),
    nodeNumber?: int32(name='NodeNumber'),
    normal?: boolean(name='Normal'),
    transactionSum?: int32(name='TransactionSum'),
    version?: string(name='Version'),
  }(name='Result'),
}

model GetBlockchainInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetBlockchainInfoResponseBody(name='body'),
}

/**
 * @param request GetBlockchainInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetBlockchainInfoResponse
 */
async function getBlockchainInfoWithOptions(request: GetBlockchainInfoRequest, runtime: Util.RuntimeOptions): GetBlockchainInfoResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetBlockchainInfo',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetBlockchainInfoRequest
 * @return GetBlockchainInfoResponse
 */
async function getBlockchainInfo(request: GetBlockchainInfoRequest): GetBlockchainInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBlockchainInfoWithOptions(request, runtime);
}

model GetMyBlockchainsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      bizid?: string(name='Bizid'),
      createtime?: long(name='Createtime'),
      id?: int32(name='Id'),
      rejectReason?: string(name='RejectReason'),
      reqAddr?: string(name='ReqAddr'),
      signedAddr?: string(name='SignedAddr'),
      status?: int32(name='Status'),
      updatetime?: long(name='Updatetime'),
      username?: string(name='Username'),
    }
  ](name='Result'),
}

model GetMyBlockchainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMyBlockchainsResponseBody(name='body'),
}

/**
 * @param request GetMyBlockchainsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMyBlockchainsResponse
 */
async function getMyBlockchainsWithOptions(runtime: Util.RuntimeOptions): GetMyBlockchainsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetMyBlockchains',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return GetMyBlockchainsResponse
 */
async function getMyBlockchains(): GetMyBlockchainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMyBlockchainsWithOptions(runtime);
}

model GetMySuccessAppliesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      abnormalNodes?: int32(name='AbnormalNodes'),
      bizid?: string(name='Bizid'),
      blockHeight?: int32(name='BlockHeight'),
      createTime?: long(name='CreateTime'),
      isRole?: boolean(name='IsRole'),
      name?: string(name='Name'),
      nodeInfoList?: [ 
        {
          blockHeight?: long(name='BlockHeight'),
          nodeName?: string(name='NodeName'),
          status?: boolean(name='Status'),
          version?: string(name='Version'),
        }
      ](name='NodeInfoList'),
      nodeNumber?: int32(name='NodeNumber'),
      normal?: boolean(name='Normal'),
      transactionSum?: int32(name='TransactionSum'),
      version?: string(name='Version'),
    }
  ](name='Result'),
}

model GetMySuccessAppliesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMySuccessAppliesResponseBody(name='body'),
}

/**
 * @param request GetMySuccessAppliesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMySuccessAppliesResponse
 */
async function getMySuccessAppliesWithOptions(runtime: Util.RuntimeOptions): GetMySuccessAppliesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetMySuccessApplies',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return GetMySuccessAppliesResponse
 */
async function getMySuccessApplies(): GetMySuccessAppliesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMySuccessAppliesWithOptions(runtime);
}

model GetOssPropertiesRequest {
  bizid?: string(name='Bizid'),
}

model GetOssPropertiesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    accessKeyId?: string(name='AccessKeyId'),
    accessKeySecret?: string(name='AccessKeySecret'),
    bucketName?: string(name='BucketName'),
    endpoint?: string(name='Endpoint'),
    folderName?: string(name='FolderName'),
  }(name='Result'),
}

model GetOssPropertiesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetOssPropertiesResponseBody(name='body'),
}

/**
 * @param request GetOssPropertiesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOssPropertiesResponse
 */
async function getOssPropertiesWithOptions(request: GetOssPropertiesRequest, runtime: Util.RuntimeOptions): GetOssPropertiesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetOssProperties',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetOssPropertiesRequest
 * @return GetOssPropertiesResponse
 */
async function getOssProperties(request: GetOssPropertiesRequest): GetOssPropertiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOssPropertiesWithOptions(request, runtime);
}

model GetTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    schemaList?: [ 
      {
        createTime?: long(name='CreateTime'),
        description?: string(name='Description'),
        id?: long(name='Id'),
        isTemplate?: int32(name='IsTemplate'),
        name?: string(name='Name'),
        updateTime?: long(name='UpdateTime'),
        version?: long(name='Version'),
      }
    ](name='SchemaList'),
  }(name='Result'),
}

model GetTemplatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTemplatesResponseBody(name='body'),
}

/**
 * @param request GetTemplatesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTemplatesResponse
 */
async function getTemplatesWithOptions(runtime: Util.RuntimeOptions): GetTemplatesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetTemplates',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return GetTemplatesResponse
 */
async function getTemplates(): GetTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTemplatesWithOptions(runtime);
}

model InstallChaincodeRequest {
  chaincodeId?: string(name='ChaincodeId', description='This parameter is required.', example='chan-channelx-1l1hmckuuisxo'),
  location?: string(name='Location', example='cn-hangzhou'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.', example='peers-aaaaaa2-1eqnj5o5w9dt3'),
}

model InstallChaincodeResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: {
    chaincodeId?: string(name='ChaincodeId', example='cc-198jejf8f8chi8'),
    channelName?: string(name='ChannelName', example='mychannel'),
    consortiumId?: string(name='ConsortiumId', example='consortium-lianmenyumingyi-hc5d1bwlulg7'),
    createTime?: string(name='CreateTime', example='1533025590'),
    deployTime?: string(name='DeployTime', example='1533025590'),
    endorsePolicy?: string(name='EndorsePolicy', example='OR ("perf9141MSP.member")'),
    input?: string(name='Input', example='input'),
    install?: boolean(name='Install', example='false'),
    message?: string(name='Message', example='ok'),
    name?: string(name='Name', example='sacc'),
    path?: string(name='Path', example='github.com/hyperledger/fabric-samples/chaincode/sacc'),
    providerId?: string(name='ProviderId', example='providerid'),
    providerName?: string(name='ProviderName', example='prividername'),
    state?: string(name='State', example='Pending'),
    type?: int32(name='Type', example='1'),
    version?: string(name='Version', example='1.0'),
  }(name='Result'),
  success?: boolean(name='Success', example='true'),
}

model InstallChaincodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InstallChaincodeResponseBody(name='body'),
}

/**
 * @param request InstallChaincodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstallChaincodeResponse
 */
async function installChaincodeWithOptions(request: InstallChaincodeRequest, runtime: Util.RuntimeOptions): InstallChaincodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.chaincodeId)) {
    body['ChaincodeId'] = request.chaincodeId;
  }
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'InstallChaincode',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request InstallChaincodeRequest
 * @return InstallChaincodeResponse
 */
async function installChaincode(request: InstallChaincodeRequest): InstallChaincodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return installChaincodeWithOptions(request, runtime);
}

model InstallFabricChaincodePackageRequest {
  chaincodePackageId?: string(name='ChaincodePackageId', description='This parameter is required.'),
  location?: string(name='Location'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model InstallFabricChaincodePackageResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: {
    chaincodePackageId?: string(name='ChaincodePackageId'),
    checksum?: string(name='Checksum'),
    deleteTime?: long(name='DeleteTime'),
    deleted?: boolean(name='Deleted'),
    installTime?: long(name='InstallTime'),
    label?: string(name='Label'),
    md5sum?: string(name='Md5sum'),
    organizationId?: string(name='OrganizationId'),
    ossBucket?: string(name='OssBucket'),
    ossURL?: string(name='OssURL'),
    providerBid?: string(name='ProviderBid'),
    providerUid?: long(name='ProviderUid'),
    state?: string(name='State'),
    type?: int32(name='Type'),
    typeName?: string(name='TypeName'),
    uploadTime?: long(name='UploadTime'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model InstallFabricChaincodePackageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InstallFabricChaincodePackageResponseBody(name='body'),
}

/**
 * @param request InstallFabricChaincodePackageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstallFabricChaincodePackageResponse
 */
async function installFabricChaincodePackageWithOptions(request: InstallFabricChaincodePackageRequest, runtime: Util.RuntimeOptions): InstallFabricChaincodePackageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.chaincodePackageId)) {
    body['ChaincodePackageId'] = request.chaincodePackageId;
  }
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'InstallFabricChaincodePackage',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request InstallFabricChaincodePackageRequest
 * @return InstallFabricChaincodePackageResponse
 */
async function installFabricChaincodePackage(request: InstallFabricChaincodePackageRequest): InstallFabricChaincodePackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return installFabricChaincodePackageWithOptions(request, runtime);
}

model InstantiateChaincodeRequest {
  chaincodeId?: string(name='ChaincodeId', description='This parameter is required.', example='cc-198jejf8f8****'),
  collectionConfig?: string(name='CollectionConfig', example='string'),
  endorsePolicy?: string(name='EndorsePolicy', example='OR (&#39;perf9141MSP.member&#39;)'),
  location?: string(name='Location', example='cn-hangzhou'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.', example='peers-aaaaaa2-1eqnj5o5w****'),
}

model InstantiateChaincodeResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: {
    chaincodeId?: string(name='ChaincodeId', example='cc-198jejf8f8chi8'),
    channelName?: string(name='ChannelName', example='channelname'),
    consortiumId?: string(name='ConsortiumId', example='consortium-lianmenyumingyi-hc5d1bwlulg7'),
    createTime?: string(name='CreateTime', example='1533025590'),
    deployTime?: string(name='DeployTime', example='1533025590'),
    endorsePolicy?: string(name='EndorsePolicy', example='OR (\\\\"aaaaaa1MSP.peer\\\\")'),
    input?: string(name='Input', example='input'),
    install?: boolean(name='Install', example='false'),
    message?: string(name='Message', example='ok'),
    name?: string(name='Name', example='sacc'),
    path?: string(name='Path', example='go-sdk-demo/chaincode/src'),
    providerId?: string(name='ProviderId', example='id'),
    providerName?: string(name='ProviderName', example='name'),
    state?: string(name='State', example='Running'),
    type?: int32(name='Type', example='1'),
    version?: string(name='Version', example='1.0'),
  }(name='Result'),
  success?: boolean(name='Success', example='true'),
}

model InstantiateChaincodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InstantiateChaincodeResponseBody(name='body'),
}

/**
 * @param request InstantiateChaincodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstantiateChaincodeResponse
 */
async function instantiateChaincodeWithOptions(request: InstantiateChaincodeRequest, runtime: Util.RuntimeOptions): InstantiateChaincodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.chaincodeId)) {
    body['ChaincodeId'] = request.chaincodeId;
  }
  if (!Util.isUnset(request.collectionConfig)) {
    body['CollectionConfig'] = request.collectionConfig;
  }
  if (!Util.isUnset(request.endorsePolicy)) {
    body['EndorsePolicy'] = request.endorsePolicy;
  }
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'InstantiateChaincode',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request InstantiateChaincodeRequest
 * @return InstantiateChaincodeResponse
 */
async function instantiateChaincode(request: InstantiateChaincodeRequest): InstantiateChaincodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return instantiateChaincodeWithOptions(request, runtime);
}

model InviteUserRequest {
  bid?: string(name='Bid'),
  bizid?: string(name='Bizid'),
  userEmail?: string(name='UserEmail'),
  userId?: long(name='UserId'),
}

model InviteUserResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    bid?: string(name='Bid'),
    bizid?: string(name='Bizid'),
    code?: string(name='Code'),
    createTime?: long(name='CreateTime'),
    email?: string(name='Email'),
    fromBid?: string(name='FromBid'),
    fromUserId?: int32(name='FromUserId'),
    status?: int32(name='Status'),
    updateTime?: long(name='UpdateTime'),
    userId?: int32(name='UserId'),
  }(name='Result'),
}

model InviteUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InviteUserResponseBody(name='body'),
}

/**
 * @param request InviteUserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InviteUserResponse
 */
async function inviteUserWithOptions(request: InviteUserRequest, runtime: Util.RuntimeOptions): InviteUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bid)) {
    body['Bid'] = request.bid;
  }
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.userEmail)) {
    body['UserEmail'] = request.userEmail;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'InviteUser',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request InviteUserRequest
 * @return InviteUserResponse
 */
async function inviteUser(request: InviteUserRequest): InviteUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return inviteUserWithOptions(request, runtime);
}

model JoinChannelRequest {
  channelId?: string(name='ChannelId', description='This parameter is required.', example='chan-channelx-1l1hmckuu****'),
  do?: string(name='Do', description='This parameter is required.', example='accept'),
  location?: string(name='Location', example='cn-hangzhou'),
}

model JoinChannelResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: [ 
    {
      acceptTime?: string(name='AcceptTime', example='1533025590'),
      approveTime?: string(name='ApproveTime', example='1533025590'),
      channelId?: string(name='ChannelId', example='channelid'),
      confirmTime?: string(name='ConfirmTime', example='1533025590'),
      destroyTime?: string(name='DestroyTime', example='1533025590'),
      inviteTime?: string(name='InviteTime', example='1533025590'),
      organizationId?: string(name='OrganizationId', example='peers-aaaaaa2-1eqnj5o5w9dt3'),
      state?: string(name='State', example='Running'),
      withPeer?: boolean(name='WithPeer', example='true'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model JoinChannelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: JoinChannelResponseBody(name='body'),
}

/**
 * @description ****
 *
 * @param request JoinChannelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return JoinChannelResponse
 */
async function joinChannelWithOptions(request: JoinChannelRequest, runtime: Util.RuntimeOptions): JoinChannelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channelId)) {
    query['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.do)) {
    query['Do'] = request.do;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'JoinChannel',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @description ****
 *
 * @param request JoinChannelRequest
 * @return JoinChannelResponse
 */
async function joinChannel(request: JoinChannelRequest): JoinChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return joinChannelWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType', description='This parameter is required.'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResources'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesResponseBody(name='body'),
}

/**
 * @param request ListTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesResponse
 */
async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListTagResourcesRequest
 * @return ListTagResourcesResponse
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ModifyTriggerRequest {
  channelId?: string(name='ChannelId', description='This parameter is required.'),
  name?: string(name='Name', description='This parameter is required.'),
  options?: string(name='Options'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
  source?: string(name='Source'),
  status?: string(name='Status', description='This parameter is required.'),
}

model ModifyTriggerResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    channelId?: string(name='ChannelId'),
    channelName?: string(name='ChannelName'),
    checkpoint?: {
      errorCount?: long(name='ErrorCount'),
      height?: long(name='Height'),
      index?: long(name='Index'),
      type?: string(name='Type'),
    }(name='Checkpoint'),
    createTime?: long(name='CreateTime'),
    errorMessage?: string(name='ErrorMessage'),
    name?: string(name='Name'),
    options?: string(name='Options'),
    source?: string(name='Source'),
    status?: int32(name='Status'),
    type?: string(name='Type'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model ModifyTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyTriggerResponseBody(name='body'),
}

/**
 * @param request ModifyTriggerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyTriggerResponse
 */
async function modifyTriggerWithOptions(request: ModifyTriggerRequest, runtime: Util.RuntimeOptions): ModifyTriggerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.options)) {
    body['Options'] = request.options;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.source)) {
    body['Source'] = request.source;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyTrigger',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ModifyTriggerRequest
 * @return ModifyTriggerResponse
 */
async function modifyTrigger(request: ModifyTriggerRequest): ModifyTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyTriggerWithOptions(request, runtime);
}

model OperateUserRequest {
  bid?: string(name='Bid'),
  bizid?: string(name='Bizid'),
  operation?: int32(name='Operation'),
  userName?: string(name='UserName'),
}

model OperateUserResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model OperateUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OperateUserResponseBody(name='body'),
}

/**
 * @param request OperateUserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateUserResponse
 */
async function operateUserWithOptions(request: OperateUserRequest, runtime: Util.RuntimeOptions): OperateUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bid)) {
    body['Bid'] = request.bid;
  }
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.operation)) {
    body['Operation'] = request.operation;
  }
  if (!Util.isUnset(request.userName)) {
    body['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'OperateUser',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request OperateUserRequest
 * @return OperateUserResponse
 */
async function operateUser(request: OperateUserRequest): OperateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateUserWithOptions(request, runtime);
}

model ProcessCloudIDEContractTransactionRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  transaction?: string(name='Transaction', description='This parameter is required.'),
}

model ProcessCloudIDEContractTransactionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model ProcessCloudIDEContractTransactionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ProcessCloudIDEContractTransactionResponseBody(name='body'),
}

/**
 * @param request ProcessCloudIDEContractTransactionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ProcessCloudIDEContractTransactionResponse
 */
async function processCloudIDEContractTransactionWithOptions(request: ProcessCloudIDEContractTransactionRequest, runtime: Util.RuntimeOptions): ProcessCloudIDEContractTransactionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.transaction)) {
    body['Transaction'] = request.transaction;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ProcessCloudIDEContractTransaction',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ProcessCloudIDEContractTransactionRequest
 * @return ProcessCloudIDEContractTransactionResponse
 */
async function processCloudIDEContractTransaction(request: ProcessCloudIDEContractTransactionRequest): ProcessCloudIDEContractTransactionResponse {
  var runtime = new Util.RuntimeOptions{};
  return processCloudIDEContractTransactionWithOptions(request, runtime);
}

model ProcessPublicCloudIDEContractTransactionRequest {
  bizid?: string(name='Bizid'),
  transaction?: string(name='Transaction'),
}

model ProcessPublicCloudIDEContractTransactionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model ProcessPublicCloudIDEContractTransactionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ProcessPublicCloudIDEContractTransactionResponseBody(name='body'),
}

/**
 * @param request ProcessPublicCloudIDEContractTransactionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ProcessPublicCloudIDEContractTransactionResponse
 */
async function processPublicCloudIDEContractTransactionWithOptions(request: ProcessPublicCloudIDEContractTransactionRequest, runtime: Util.RuntimeOptions): ProcessPublicCloudIDEContractTransactionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.transaction)) {
    body['Transaction'] = request.transaction;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ProcessPublicCloudIDEContractTransaction',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ProcessPublicCloudIDEContractTransactionRequest
 * @return ProcessPublicCloudIDEContractTransactionResponse
 */
async function processPublicCloudIDEContractTransaction(request: ProcessPublicCloudIDEContractTransactionRequest): ProcessPublicCloudIDEContractTransactionResponse {
  var runtime = new Util.RuntimeOptions{};
  return processPublicCloudIDEContractTransactionWithOptions(request, runtime);
}

model QueryBlockRequest {
  bizid?: string(name='Bizid'),
  height?: long(name='Height'),
}

model QueryBlockResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    alias?: string(name='Alias'),
    blockHash?: string(name='BlockHash'),
    createTime?: long(name='CreateTime'),
    height?: int32(name='Height'),
    previousHash?: string(name='PreviousHash'),
    rootTxHash?: string(name='RootTxHash'),
    transSummaryList?: string(name='TransSummaryList'),
    transactionSize?: int32(name='TransactionSize'),
  }(name='Result'),
}

model QueryBlockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryBlockResponseBody(name='body'),
}

/**
 * @param request QueryBlockRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryBlockResponse
 */
async function queryBlockWithOptions(request: QueryBlockRequest, runtime: Util.RuntimeOptions): QueryBlockResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.height)) {
    body['Height'] = request.height;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryBlock',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryBlockRequest
 * @return QueryBlockResponse
 */
async function queryBlock(request: QueryBlockRequest): QueryBlockResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryBlockWithOptions(request, runtime);
}

model QueryConsortiumDeletableRequest {
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.'),
  location?: string(name='Location'),
}

model QueryConsortiumDeletableResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    codeName?: string(name='CodeName'),
    consortiumId?: string(name='ConsortiumId'),
    deletable?: boolean(name='Deletable'),
    description?: string(name='Description'),
    domain?: string(name='Domain'),
    name?: string(name='Name'),
    regionId?: string(name='RegionId'),
    state?: string(name='State'),
    zoneId?: string(name='ZoneId'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryConsortiumDeletableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryConsortiumDeletableResponseBody(name='body'),
}

/**
 * @param request QueryConsortiumDeletableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryConsortiumDeletableResponse
 */
async function queryConsortiumDeletableWithOptions(request: QueryConsortiumDeletableRequest, runtime: Util.RuntimeOptions): QueryConsortiumDeletableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consortiumId)) {
    query['ConsortiumId'] = request.consortiumId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryConsortiumDeletable',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryConsortiumDeletableRequest
 * @return QueryConsortiumDeletableResponse
 */
async function queryConsortiumDeletable(request: QueryConsortiumDeletableRequest): QueryConsortiumDeletableResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryConsortiumDeletableWithOptions(request, runtime);
}

model QueryEthereumDeletableRequest {
  ethereumId?: string(name='EthereumId', description='This parameter is required.'),
}

model QueryEthereumDeletableResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    deletable?: boolean(name='Deletable'),
    ethereumId?: string(name='EthereumId'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryEthereumDeletableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryEthereumDeletableResponseBody(name='body'),
}

/**
 * @param request QueryEthereumDeletableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryEthereumDeletableResponse
 */
async function queryEthereumDeletableWithOptions(request: QueryEthereumDeletableRequest, runtime: Util.RuntimeOptions): QueryEthereumDeletableResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ethereumId)) {
    body['EthereumId'] = request.ethereumId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryEthereumDeletable',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryEthereumDeletableRequest
 * @return QueryEthereumDeletableResponse
 */
async function queryEthereumDeletable(request: QueryEthereumDeletableRequest): QueryEthereumDeletableResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEthereumDeletableWithOptions(request, runtime);
}

model QueryMetricRequest {
  bizid?: string(name='Bizid'),
  innerIp?: string(name='InnerIp'),
  metric?: string(name='Metric'),
  period?: string(name='Period'),
  port?: string(name='Port'),
  timeArea?: string(name='TimeArea'),
}

model QueryMetricResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model QueryMetricResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMetricResponseBody(name='body'),
}

/**
 * @param request QueryMetricRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMetricResponse
 */
async function queryMetricWithOptions(request: QueryMetricRequest, runtime: Util.RuntimeOptions): QueryMetricResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizid)) {
    query['Bizid'] = request.bizid;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.innerIp)) {
    body['InnerIp'] = request.innerIp;
  }
  if (!Util.isUnset(request.metric)) {
    body['Metric'] = request.metric;
  }
  if (!Util.isUnset(request.period)) {
    body['Period'] = request.period;
  }
  if (!Util.isUnset(request.port)) {
    body['Port'] = request.port;
  }
  if (!Util.isUnset(request.timeArea)) {
    body['TimeArea'] = request.timeArea;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryMetric',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryMetricRequest
 * @return QueryMetricResponse
 */
async function queryMetric(request: QueryMetricRequest): QueryMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMetricWithOptions(request, runtime);
}

model QueryOrganizationDeletableRequest {
  location?: string(name='Location'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model QueryOrganizationDeletableResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    codeName?: string(name='CodeName'),
    deletable?: boolean(name='Deletable'),
    description?: string(name='Description'),
    domain?: string(name='Domain'),
    name?: string(name='Name'),
    organizationId?: string(name='OrganizationId'),
    regionId?: string(name='RegionId'),
    state?: string(name='State'),
    zoneId?: string(name='ZoneId'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryOrganizationDeletableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryOrganizationDeletableResponseBody(name='body'),
}

/**
 * @param request QueryOrganizationDeletableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryOrganizationDeletableResponse
 */
async function queryOrganizationDeletableWithOptions(request: QueryOrganizationDeletableRequest, runtime: Util.RuntimeOptions): QueryOrganizationDeletableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryOrganizationDeletable',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryOrganizationDeletableRequest
 * @return QueryOrganizationDeletableResponse
 */
async function queryOrganizationDeletable(request: QueryOrganizationDeletableRequest): QueryOrganizationDeletableResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOrganizationDeletableWithOptions(request, runtime);
}

model QueryTransactionRequest {
  bizid?: string(name='Bizid'),
  hash?: string(name='Hash'),
}

model QueryTransactionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    blockHeight?: long(name='BlockHeight'),
    blockVersion?: int32(name='BlockVersion'),
    category?: int32(name='Category'),
    content?: string(name='Content'),
    contentHash?: string(name='ContentHash'),
    createTime?: long(name='CreateTime'),
    hash?: string(name='Hash'),
    keyName?: string(name='KeyName'),
    keyWrap?: string(name='KeyWrap'),
    nonce?: string(name='Nonce'),
    referenceCount?: int32(name='ReferenceCount'),
    referenceList?: {
      data?: string(name='Data'),
      length?: int32(name='Length'),
      type?: int32(name='Type'),
    }(name='ReferenceList'),
    type?: int32(name='Type'),
  }(name='Result'),
}

model QueryTransactionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryTransactionResponseBody(name='body'),
}

/**
 * @param request QueryTransactionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryTransactionResponse
 */
async function queryTransactionWithOptions(request: QueryTransactionRequest, runtime: Util.RuntimeOptions): QueryTransactionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.hash)) {
    body['Hash'] = request.hash;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryTransaction',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryTransactionRequest
 * @return QueryTransactionResponse
 */
async function queryTransaction(request: QueryTransactionRequest): QueryTransactionResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTransactionWithOptions(request, runtime);
}

model RejectUserRequest {
  bid?: string(name='Bid'),
  bizid?: string(name='Bizid'),
  reason?: string(name='Reason'),
  userName?: string(name='UserName'),
}

model RejectUserResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model RejectUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RejectUserResponseBody(name='body'),
}

/**
 * @param request RejectUserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RejectUserResponse
 */
async function rejectUserWithOptions(request: RejectUserRequest, runtime: Util.RuntimeOptions): RejectUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bid)) {
    body['Bid'] = request.bid;
  }
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.reason)) {
    body['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.userName)) {
    body['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RejectUser',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request RejectUserRequest
 * @return RejectUserResponse
 */
async function rejectUser(request: RejectUserRequest): RejectUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return rejectUserWithOptions(request, runtime);
}

model RenameBlockchainRequest {
  bizid?: string(name='Bizid'),
  newName?: string(name='NewName'),
}

model RenameBlockchainResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model RenameBlockchainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RenameBlockchainResponseBody(name='body'),
}

/**
 * @param request RenameBlockchainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RenameBlockchainResponse
 */
async function renameBlockchainWithOptions(request: RenameBlockchainRequest, runtime: Util.RuntimeOptions): RenameBlockchainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.newName)) {
    body['NewName'] = request.newName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RenameBlockchain',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request RenameBlockchainRequest
 * @return RenameBlockchainResponse
 */
async function renameBlockchain(request: RenameBlockchainRequest): RenameBlockchainResponse {
  var runtime = new Util.RuntimeOptions{};
  return renameBlockchainWithOptions(request, runtime);
}

model ResetAntChainCertificateRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
}

model ResetAntChainCertificateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model ResetAntChainCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetAntChainCertificateResponseBody(name='body'),
}

/**
 * @param request ResetAntChainCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetAntChainCertificateResponse
 */
async function resetAntChainCertificateWithOptions(request: ResetAntChainCertificateRequest, runtime: Util.RuntimeOptions): ResetAntChainCertificateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ResetAntChainCertificate',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ResetAntChainCertificateRequest
 * @return ResetAntChainCertificateResponse
 */
async function resetAntChainCertificate(request: ResetAntChainCertificateRequest): ResetAntChainCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetAntChainCertificateWithOptions(request, runtime);
}

model ResetAntChainUserCertificateRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  bid?: string(name='Bid', description='This parameter is required.'),
  operation?: int32(name='Operation', description='This parameter is required.'),
  username?: string(name='Username', description='This parameter is required.'),
}

model ResetAntChainUserCertificateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model ResetAntChainUserCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetAntChainUserCertificateResponseBody(name='body'),
}

/**
 * @param request ResetAntChainUserCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetAntChainUserCertificateResponse
 */
async function resetAntChainUserCertificateWithOptions(request: ResetAntChainUserCertificateRequest, runtime: Util.RuntimeOptions): ResetAntChainUserCertificateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.bid)) {
    body['Bid'] = request.bid;
  }
  if (!Util.isUnset(request.operation)) {
    body['Operation'] = request.operation;
  }
  if (!Util.isUnset(request.username)) {
    body['Username'] = request.username;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ResetAntChainUserCertificate',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ResetAntChainUserCertificateRequest
 * @return ResetAntChainUserCertificateResponse
 */
async function resetAntChainUserCertificate(request: ResetAntChainUserCertificateRequest): ResetAntChainUserCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetAntChainUserCertificateWithOptions(request, runtime);
}

model ResetCertificateRequest {
  bizid?: string(name='Bizid'),
}

model ResetCertificateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model ResetCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetCertificateResponseBody(name='body'),
}

/**
 * @param request ResetCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetCertificateResponse
 */
async function resetCertificateWithOptions(request: ResetCertificateRequest, runtime: Util.RuntimeOptions): ResetCertificateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ResetCertificate',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ResetCertificateRequest
 * @return ResetCertificateResponse
 */
async function resetCertificate(request: ResetCertificateRequest): ResetCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetCertificateWithOptions(request, runtime);
}

model ResetOrganizationUserPasswordRequest {
  location?: string(name='Location', example='username'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.', example='peers-aaaaaa2-1eqnj5o5w****'),
  password?: string(name='Password', example='password'),
  username?: string(name='Username', description='This parameter is required.', example='username'),
}

model ResetOrganizationUserPasswordResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: {
    createTime?: string(name='CreateTime', example='1533025590'),
    expireTime?: string(name='ExpireTime', example='1533025590'),
    fullname?: string(name='Fullname', example='username'),
    organizationId?: string(name='OrganizationId', example='peers-aaaaaa2-1eqnj5o5w****'),
    password?: string(name='Password', example='password'),
    username?: string(name='Username', example='username'),
  }(name='Result'),
  success?: boolean(name='Success', example='true'),
}

model ResetOrganizationUserPasswordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetOrganizationUserPasswordResponseBody(name='body'),
}

/**
 * @param request ResetOrganizationUserPasswordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetOrganizationUserPasswordResponse
 */
async function resetOrganizationUserPasswordWithOptions(request: ResetOrganizationUserPasswordRequest, runtime: Util.RuntimeOptions): ResetOrganizationUserPasswordResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.username)) {
    body['Username'] = request.username;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ResetOrganizationUserPassword',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ResetOrganizationUserPasswordRequest
 * @return ResetOrganizationUserPasswordResponse
 */
async function resetOrganizationUserPassword(request: ResetOrganizationUserPasswordRequest): ResetOrganizationUserPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetOrganizationUserPasswordWithOptions(request, runtime);
}

model ResetPublicAntChainCertificateRequest {
  bizid?: string(name='Bizid'),
}

model ResetPublicAntChainCertificateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model ResetPublicAntChainCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetPublicAntChainCertificateResponseBody(name='body'),
}

/**
 * @param request ResetPublicAntChainCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetPublicAntChainCertificateResponse
 */
async function resetPublicAntChainCertificateWithOptions(request: ResetPublicAntChainCertificateRequest, runtime: Util.RuntimeOptions): ResetPublicAntChainCertificateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ResetPublicAntChainCertificate',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ResetPublicAntChainCertificateRequest
 * @return ResetPublicAntChainCertificateResponse
 */
async function resetPublicAntChainCertificate(request: ResetPublicAntChainCertificateRequest): ResetPublicAntChainCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetPublicAntChainCertificateWithOptions(request, runtime);
}

model ResetUserRequest {
  bid?: string(name='Bid'),
  bizid?: string(name='Bizid'),
  operation?: int32(name='Operation'),
  userName?: string(name='UserName'),
}

model ResetUserResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model ResetUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetUserResponseBody(name='body'),
}

/**
 * @param request ResetUserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetUserResponse
 */
async function resetUserWithOptions(request: ResetUserRequest, runtime: Util.RuntimeOptions): ResetUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bid)) {
    body['Bid'] = request.bid;
  }
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.operation)) {
    body['Operation'] = request.operation;
  }
  if (!Util.isUnset(request.userName)) {
    body['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ResetUser',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ResetUserRequest
 * @return ResetUserResponse
 */
async function resetUser(request: ResetUserRequest): ResetUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetUserWithOptions(request, runtime);
}

model SchemaDetailRequest {
  bizid?: string(name='Bizid'),
  schemaId?: long(name='SchemaId'),
}

model SchemaDetailResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    responses?: [ 
      {
        category?: string(name='Category'),
        categoryName?: string(name='CategoryName'),
        description?: string(name='Description'),
        properties?: {
          count?: int32(name='Count'),
          dataSource?: [ 
            {
              allowNull?: int32(name='AllowNull'),
              annotation?: string(name='Annotation'),
              field?: string(name='Field'),
              indexes?: int32(name='Indexes'),
              key?: int32(name='Key'),
              length?: int32(name='Length'),
              reg?: string(name='Reg'),
              type?: string(name='Type'),
            }
          ](name='DataSource'),
        }(name='Properties'),
      }
    ](name='Responses'),
    schema?: {
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      id?: long(name='Id'),
      isTemplate?: boolean(name='IsTemplate'),
      name?: string(name='Name'),
      updateTime?: long(name='UpdateTime'),
      version?: long(name='Version'),
    }(name='Schema'),
  }(name='Result'),
}

model SchemaDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SchemaDetailResponseBody(name='body'),
}

/**
 * @param request SchemaDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SchemaDetailResponse
 */
async function schemaDetailWithOptions(request: SchemaDetailRequest, runtime: Util.RuntimeOptions): SchemaDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.schemaId)) {
    body['SchemaId'] = request.schemaId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SchemaDetail',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SchemaDetailRequest
 * @return SchemaDetailResponse
 */
async function schemaDetail(request: SchemaDetailRequest): SchemaDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return schemaDetailWithOptions(request, runtime);
}

model StartSmartContractJobRequest {
  jobId?: string(name='JobId', description='This parameter is required.'),
  jobName?: string(name='JobName', description='This parameter is required.'),
  sourceOpt?: string(name='SourceOpt'),
  sourceType?: string(name='SourceType', description='This parameter is required.'),
}

model StartSmartContractJobResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model StartSmartContractJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartSmartContractJobResponseBody(name='body'),
}

/**
 * @param request StartSmartContractJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartSmartContractJobResponse
 */
async function startSmartContractJobWithOptions(request: StartSmartContractJobRequest, runtime: Util.RuntimeOptions): StartSmartContractJobResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.jobId)) {
    body['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.jobName)) {
    body['JobName'] = request.jobName;
  }
  if (!Util.isUnset(request.sourceOpt)) {
    body['SourceOpt'] = request.sourceOpt;
  }
  if (!Util.isUnset(request.sourceType)) {
    body['SourceType'] = request.sourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartSmartContractJob',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request StartSmartContractJobRequest
 * @return StartSmartContractJobResponse
 */
async function startSmartContractJob(request: StartSmartContractJobRequest): StartSmartContractJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return startSmartContractJobWithOptions(request, runtime);
}

model SubmitFabricChaincodeDefinitionRequest {
  chaincodePackageId?: string(name='ChaincodePackageId', description='This parameter is required.'),
  chaincodeVersion?: string(name='ChaincodeVersion', description='This parameter is required.'),
  channelId?: string(name='ChannelId', description='This parameter is required.'),
  collectionConfig?: string(name='CollectionConfig'),
  endorsePolicy?: string(name='EndorsePolicy'),
  initRequired?: boolean(name='InitRequired'),
  location?: string(name='Location'),
  name?: string(name='Name', description='This parameter is required.'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model SubmitFabricChaincodeDefinitionResponseBody = {
  chaincodeDefinitionId?: string(name='ChaincodeDefinitionId'),
  chaincodePackageId?: string(name='ChaincodePackageId'),
  errorCode?: int32(name='ErrorCode'),
  initRequired?: boolean(name='InitRequired'),
  requestId?: string(name='RequestId'),
  result?: {
    chaincodeId?: string(name='ChaincodeId'),
    channelName?: string(name='ChannelName'),
    consortiumId?: string(name='ConsortiumId'),
    createTime?: string(name='CreateTime'),
    deployTime?: string(name='DeployTime'),
    endorsePolicy?: string(name='EndorsePolicy'),
    input?: string(name='Input'),
    install?: boolean(name='Install'),
    message?: string(name='Message'),
    name?: string(name='Name'),
    path?: string(name='Path'),
    providerId?: string(name='ProviderId'),
    providerName?: string(name='ProviderName'),
    state?: string(name='State'),
    type?: int32(name='Type'),
    version?: string(name='Version'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model SubmitFabricChaincodeDefinitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SubmitFabricChaincodeDefinitionResponseBody(name='body'),
}

/**
 * @param request SubmitFabricChaincodeDefinitionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SubmitFabricChaincodeDefinitionResponse
 */
async function submitFabricChaincodeDefinitionWithOptions(request: SubmitFabricChaincodeDefinitionRequest, runtime: Util.RuntimeOptions): SubmitFabricChaincodeDefinitionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.chaincodePackageId)) {
    body['ChaincodePackageId'] = request.chaincodePackageId;
  }
  if (!Util.isUnset(request.chaincodeVersion)) {
    body['ChaincodeVersion'] = request.chaincodeVersion;
  }
  if (!Util.isUnset(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.collectionConfig)) {
    body['CollectionConfig'] = request.collectionConfig;
  }
  if (!Util.isUnset(request.endorsePolicy)) {
    body['EndorsePolicy'] = request.endorsePolicy;
  }
  if (!Util.isUnset(request.initRequired)) {
    body['InitRequired'] = request.initRequired;
  }
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SubmitFabricChaincodeDefinition',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SubmitFabricChaincodeDefinitionRequest
 * @return SubmitFabricChaincodeDefinitionResponse
 */
async function submitFabricChaincodeDefinition(request: SubmitFabricChaincodeDefinitionRequest): SubmitFabricChaincodeDefinitionResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitFabricChaincodeDefinitionWithOptions(request, runtime);
}

model SyncFabricChaincodeStatusRequest {
  chaincodeId?: string(name='ChaincodeId', description='This parameter is required.'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model SyncFabricChaincodeStatusResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    chaincodeId?: string(name='ChaincodeId'),
    input?: string(name='Input'),
    name?: string(name='Name'),
    path?: long(name='Path'),
    state?: string(name='State'),
    type?: int32(name='Type'),
    version?: string(name='Version'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model SyncFabricChaincodeStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SyncFabricChaincodeStatusResponseBody(name='body'),
}

/**
 * @param request SyncFabricChaincodeStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SyncFabricChaincodeStatusResponse
 */
async function syncFabricChaincodeStatusWithOptions(request: SyncFabricChaincodeStatusRequest, runtime: Util.RuntimeOptions): SyncFabricChaincodeStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.chaincodeId)) {
    body['ChaincodeId'] = request.chaincodeId;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SyncFabricChaincodeStatus',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SyncFabricChaincodeStatusRequest
 * @return SyncFabricChaincodeStatusResponse
 */
async function syncFabricChaincodeStatus(request: SyncFabricChaincodeStatusRequest): SyncFabricChaincodeStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return syncFabricChaincodeStatusWithOptions(request, runtime);
}

model SynchronizeChaincodeRequest {
  chaincodeId?: string(name='ChaincodeId', description='This parameter is required.', example='code-sacc-1pr09q7jm****'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.', example='peers-aaaaaa2-1eqnj5o5w****'),
}

model SynchronizeChaincodeResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='1890FA4F-067A-4CE9-AC9B-2BD2E58FB5D3'),
  result?: {
    chaincodeId?: string(name='ChaincodeId', example='code-sacc-1pr09q7jm****'),
    channelName?: string(name='ChannelName', example='chan-channelx-1l1hmckuuisxo'),
    consortiumId?: string(name='ConsortiumId', example='consortium-lianmenyumingyi-hc5d1bwl****'),
    createTime?: string(name='CreateTime', example='1533025590'),
    deployTime?: string(name='DeployTime', example='1533025590'),
    endorsePolicy?: string(name='EndorsePolicy', example='OR (\\\\"aaaaaa1MSP.peer\\\\")'),
    input?: string(name='Input', example='input'),
    install?: boolean(name='Install', example='false'),
    message?: string(name='Message', example='ok'),
    name?: string(name='Name', example='sacc'),
    path?: string(name='Path', example='go-sdk-demo/chaincode/src'),
    providerId?: string(name='ProviderId', example='provider'),
    providerName?: string(name='ProviderName', example='name'),
    state?: string(name='State', example='Running'),
    type?: int32(name='Type', example='1'),
    version?: string(name='Version', example='1.0'),
  }(name='Result'),
  success?: boolean(name='Success', example='true'),
}

model SynchronizeChaincodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SynchronizeChaincodeResponseBody(name='body'),
}

/**
 * @param request SynchronizeChaincodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SynchronizeChaincodeResponse
 */
async function synchronizeChaincodeWithOptions(request: SynchronizeChaincodeRequest, runtime: Util.RuntimeOptions): SynchronizeChaincodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.chaincodeId)) {
    body['ChaincodeId'] = request.chaincodeId;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SynchronizeChaincode',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SynchronizeChaincodeRequest
 * @return SynchronizeChaincodeResponse
 */
async function synchronizeChaincode(request: SynchronizeChaincodeRequest): SynchronizeChaincodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return synchronizeChaincodeWithOptions(request, runtime);
}

model TagResourcesRequest {
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType', description='This parameter is required.'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TagResourcesResponseBody(name='body'),
}

/**
 * @param request TagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesResponse
 */
async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request TagResourcesRequest
 * @return TagResourcesResponse
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UnfreezeAccountRequest {
  account?: string(name='Account'),
  bizid?: string(name='Bizid'),
}

model UnfreezeAccountResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model UnfreezeAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnfreezeAccountResponseBody(name='body'),
}

/**
 * @param request UnfreezeAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnfreezeAccountResponse
 */
async function unfreezeAccountWithOptions(request: UnfreezeAccountRequest, runtime: Util.RuntimeOptions): UnfreezeAccountResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.account)) {
    body['Account'] = request.account;
  }
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UnfreezeAccount',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UnfreezeAccountRequest
 * @return UnfreezeAccountResponse
 */
async function unfreezeAccount(request: UnfreezeAccountRequest): UnfreezeAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return unfreezeAccountWithOptions(request, runtime);
}

model UnfreezeAntChainAccountRequest {
  account?: string(name='Account', description='This parameter is required.'),
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
}

model UnfreezeAntChainAccountResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model UnfreezeAntChainAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnfreezeAntChainAccountResponseBody(name='body'),
}

/**
 * @param request UnfreezeAntChainAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnfreezeAntChainAccountResponse
 */
async function unfreezeAntChainAccountWithOptions(request: UnfreezeAntChainAccountRequest, runtime: Util.RuntimeOptions): UnfreezeAntChainAccountResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.account)) {
    body['Account'] = request.account;
  }
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UnfreezeAntChainAccount',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UnfreezeAntChainAccountRequest
 * @return UnfreezeAntChainAccountResponse
 */
async function unfreezeAntChainAccount(request: UnfreezeAntChainAccountRequest): UnfreezeAntChainAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return unfreezeAntChainAccountWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType', description='This parameter is required.'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UntagResourcesResponseBody(name='body'),
}

/**
 * @param request UntagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UntagResourcesResponse
 */
async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UntagResourcesRequest
 * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateAntChainRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  antChainName?: string(name='AntChainName', description='This parameter is required.'),
}

model UpdateAntChainResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model UpdateAntChainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAntChainResponseBody(name='body'),
}

/**
 * @param request UpdateAntChainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAntChainResponse
 */
async function updateAntChainWithOptions(request: UpdateAntChainRequest, runtime: Util.RuntimeOptions): UpdateAntChainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.antChainName)) {
    body['AntChainName'] = request.antChainName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAntChain',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateAntChainRequest
 * @return UpdateAntChainResponse
 */
async function updateAntChain(request: UpdateAntChainRequest): UpdateAntChainResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAntChainWithOptions(request, runtime);
}

model UpdateAntChainConsortiumRequest {
  consortiumDescription?: string(name='ConsortiumDescription'),
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.'),
  consortiumName?: string(name='ConsortiumName', description='This parameter is required.'),
}

model UpdateAntChainConsortiumResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model UpdateAntChainConsortiumResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAntChainConsortiumResponseBody(name='body'),
}

/**
 * @param request UpdateAntChainConsortiumRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAntChainConsortiumResponse
 */
async function updateAntChainConsortiumWithOptions(request: UpdateAntChainConsortiumRequest, runtime: Util.RuntimeOptions): UpdateAntChainConsortiumResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.consortiumDescription)) {
    body['ConsortiumDescription'] = request.consortiumDescription;
  }
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.consortiumName)) {
    body['ConsortiumName'] = request.consortiumName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAntChainConsortium',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateAntChainConsortiumRequest
 * @return UpdateAntChainConsortiumResponse
 */
async function updateAntChainConsortium(request: UpdateAntChainConsortiumRequest): UpdateAntChainConsortiumResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAntChainConsortiumWithOptions(request, runtime);
}

model UpdateAntChainContractContentRequest {
  content?: string(name='Content'),
  contentId?: string(name='ContentId', description='This parameter is required.'),
  contentName?: string(name='ContentName'),
  parentContentId?: string(name='ParentContentId'),
}

model UpdateAntChainContractContentResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model UpdateAntChainContractContentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAntChainContractContentResponseBody(name='body'),
}

/**
 * @param request UpdateAntChainContractContentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAntChainContractContentResponse
 */
async function updateAntChainContractContentWithOptions(request: UpdateAntChainContractContentRequest, runtime: Util.RuntimeOptions): UpdateAntChainContractContentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.contentId)) {
    body['ContentId'] = request.contentId;
  }
  if (!Util.isUnset(request.contentName)) {
    body['ContentName'] = request.contentName;
  }
  if (!Util.isUnset(request.parentContentId)) {
    body['ParentContentId'] = request.parentContentId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAntChainContractContent',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateAntChainContractContentRequest
 * @return UpdateAntChainContractContentResponse
 */
async function updateAntChainContractContent(request: UpdateAntChainContractContentRequest): UpdateAntChainContractContentResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAntChainContractContentWithOptions(request, runtime);
}

model UpdateAntChainContractProjectRequest {
  projectDescription?: string(name='ProjectDescription'),
  projectId?: string(name='ProjectId', description='This parameter is required.'),
  projectName?: string(name='ProjectName'),
  projectVersion?: string(name='ProjectVersion'),
}

model UpdateAntChainContractProjectResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model UpdateAntChainContractProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAntChainContractProjectResponseBody(name='body'),
}

/**
 * @param request UpdateAntChainContractProjectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAntChainContractProjectResponse
 */
async function updateAntChainContractProjectWithOptions(request: UpdateAntChainContractProjectRequest, runtime: Util.RuntimeOptions): UpdateAntChainContractProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.projectDescription)) {
    body['ProjectDescription'] = request.projectDescription;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.projectVersion)) {
    body['ProjectVersion'] = request.projectVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAntChainContractProject',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateAntChainContractProjectRequest
 * @return UpdateAntChainContractProjectResponse
 */
async function updateAntChainContractProject(request: UpdateAntChainContractProjectRequest): UpdateAntChainContractProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAntChainContractProjectWithOptions(request, runtime);
}

model UpdateAntChainMemberRequest {
  consortiumId?: string(name='ConsortiumId', description='This parameter is required.'),
  memberId?: string(name='MemberId', description='This parameter is required.'),
  memberName?: string(name='MemberName', description='This parameter is required.'),
}

model UpdateAntChainMemberResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model UpdateAntChainMemberResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAntChainMemberResponseBody(name='body'),
}

/**
 * @param request UpdateAntChainMemberRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAntChainMemberResponse
 */
async function updateAntChainMemberWithOptions(request: UpdateAntChainMemberRequest, runtime: Util.RuntimeOptions): UpdateAntChainMemberResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.consortiumId)) {
    body['ConsortiumId'] = request.consortiumId;
  }
  if (!Util.isUnset(request.memberId)) {
    body['MemberId'] = request.memberId;
  }
  if (!Util.isUnset(request.memberName)) {
    body['MemberName'] = request.memberName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAntChainMember',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateAntChainMemberRequest
 * @return UpdateAntChainMemberResponse
 */
async function updateAntChainMember(request: UpdateAntChainMemberRequest): UpdateAntChainMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAntChainMemberWithOptions(request, runtime);
}

model UpdateAntChainQRCodeAuthorizationRequest {
  antChainId?: string(name='AntChainId', description='This parameter is required.'),
  authorizationType?: string(name='AuthorizationType', description='This parameter is required.'),
  QRCodeType?: string(name='QRCodeType', description='This parameter is required.'),
}

model UpdateAntChainQRCodeAuthorizationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model UpdateAntChainQRCodeAuthorizationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAntChainQRCodeAuthorizationResponseBody(name='body'),
}

/**
 * @param request UpdateAntChainQRCodeAuthorizationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAntChainQRCodeAuthorizationResponse
 */
async function updateAntChainQRCodeAuthorizationWithOptions(request: UpdateAntChainQRCodeAuthorizationRequest, runtime: Util.RuntimeOptions): UpdateAntChainQRCodeAuthorizationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.antChainId)) {
    body['AntChainId'] = request.antChainId;
  }
  if (!Util.isUnset(request.authorizationType)) {
    body['AuthorizationType'] = request.authorizationType;
  }
  if (!Util.isUnset(request.QRCodeType)) {
    body['QRCodeType'] = request.QRCodeType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAntChainQRCodeAuthorization',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateAntChainQRCodeAuthorizationRequest
 * @return UpdateAntChainQRCodeAuthorizationResponse
 */
async function updateAntChainQRCodeAuthorization(request: UpdateAntChainQRCodeAuthorizationRequest): UpdateAntChainQRCodeAuthorizationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAntChainQRCodeAuthorizationWithOptions(request, runtime);
}

model UpdateBlockchainSchemaRequest {
  bizid?: string(name='Bizid'),
  categoryConfigs?: string(name='CategoryConfigs'),
  description?: string(name='Description'),
  schemaId?: long(name='SchemaId'),
  schemaName?: string(name='SchemaName'),
}

model UpdateBlockchainSchemaResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    responses?: [ 
      {
        category?: string(name='Category'),
        categoryName?: string(name='CategoryName'),
        description?: string(name='Description'),
        properties?: {
          count?: int32(name='Count'),
          dataSource?: [ 
            {
              allowNull?: int32(name='AllowNull'),
              annotation?: string(name='Annotation'),
              field?: string(name='Field'),
              indexes?: int32(name='Indexes'),
              key?: int32(name='Key'),
              length?: int32(name='Length'),
              reg?: string(name='Reg'),
              type?: string(name='Type'),
            }
          ](name='DataSource'),
        }(name='Properties'),
      }
    ](name='Responses'),
    schema?: {
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      id?: long(name='Id'),
      isTemplate?: boolean(name='IsTemplate'),
      name?: string(name='Name'),
      updateTime?: long(name='UpdateTime'),
      version?: long(name='Version'),
    }(name='Schema'),
  }(name='Result'),
}

model UpdateBlockchainSchemaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateBlockchainSchemaResponseBody(name='body'),
}

/**
 * @param request UpdateBlockchainSchemaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateBlockchainSchemaResponse
 */
async function updateBlockchainSchemaWithOptions(request: UpdateBlockchainSchemaRequest, runtime: Util.RuntimeOptions): UpdateBlockchainSchemaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.categoryConfigs)) {
    body['CategoryConfigs'] = request.categoryConfigs;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.schemaId)) {
    body['SchemaId'] = request.schemaId;
  }
  if (!Util.isUnset(request.schemaName)) {
    body['SchemaName'] = request.schemaName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateBlockchainSchema',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateBlockchainSchemaRequest
 * @return UpdateBlockchainSchemaResponse
 */
async function updateBlockchainSchema(request: UpdateBlockchainSchemaRequest): UpdateBlockchainSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateBlockchainSchemaWithOptions(request, runtime);
}

model UpdateChannelConfigRequest {
  batchTimeout?: int32(name='BatchTimeout', description='This parameter is required.'),
  channelId?: string(name='ChannelId', description='This parameter is required.'),
  maxMessageCount?: int32(name='MaxMessageCount', description='This parameter is required.'),
  organizationId?: string(name='OrganizationId'),
  preferredMaxBytes?: int32(name='PreferredMaxBytes', description='This parameter is required.'),
}

model UpdateChannelConfigResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    batchTimeout?: int32(name='BatchTimeout'),
    blockCount?: int32(name='BlockCount'),
    chaincodeCount?: int32(name='ChaincodeCount'),
    channelId?: string(name='ChannelId'),
    consortiumId?: string(name='ConsortiumId'),
    consortiumName?: string(name='ConsortiumName'),
    createTime?: string(name='CreateTime'),
    maxMessageCount?: int32(name='MaxMessageCount'),
    memberCount?: int32(name='MemberCount'),
    name?: string(name='Name'),
    ownerBid?: string(name='OwnerBid'),
    ownerName?: string(name='OwnerName'),
    ownerUid?: int32(name='OwnerUid'),
    preferredMaxBytes?: int32(name='PreferredMaxBytes'),
    requestId?: string(name='RequestId'),
    state?: string(name='State'),
    supportConfig?: boolean(name='SupportConfig'),
    updateTime?: string(name='UpdateTime'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateChannelConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateChannelConfigResponseBody(name='body'),
}

/**
 * @param request UpdateChannelConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateChannelConfigResponse
 */
async function updateChannelConfigWithOptions(request: UpdateChannelConfigRequest, runtime: Util.RuntimeOptions): UpdateChannelConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.batchTimeout)) {
    body['BatchTimeout'] = request.batchTimeout;
  }
  if (!Util.isUnset(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.maxMessageCount)) {
    body['MaxMessageCount'] = request.maxMessageCount;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.preferredMaxBytes)) {
    body['PreferredMaxBytes'] = request.preferredMaxBytes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateChannelConfig',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateChannelConfigRequest
 * @return UpdateChannelConfigResponse
 */
async function updateChannelConfig(request: UpdateChannelConfigRequest): UpdateChannelConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateChannelConfigWithOptions(request, runtime);
}

model UpdateEthereumRequest {
  description?: string(name='Description'),
  ethereumId?: string(name='EthereumId', description='This parameter is required.'),
  name?: string(name='Name'),
}

model UpdateEthereumResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    consensus?: string(name='Consensus'),
    creator?: string(name='Creator'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    networkId?: string(name='NetworkId'),
    regionId?: string(name='RegionId'),
    state?: string(name='State'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateEthereumResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateEthereumResponseBody(name='body'),
}

/**
 * @param request UpdateEthereumRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateEthereumResponse
 */
async function updateEthereumWithOptions(request: UpdateEthereumRequest, runtime: Util.RuntimeOptions): UpdateEthereumResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.ethereumId)) {
    body['EthereumId'] = request.ethereumId;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEthereum',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateEthereumRequest
 * @return UpdateEthereumResponse
 */
async function updateEthereum(request: UpdateEthereumRequest): UpdateEthereumResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEthereumWithOptions(request, runtime);
}

model UpdateEthereumClientUserPasswordRequest {
  nodeId?: string(name='NodeId', description='This parameter is required.'),
  password?: string(name='Password', description='This parameter is required.'),
  username?: string(name='Username', description='This parameter is required.'),
}

model UpdateEthereumClientUserPasswordResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateEthereumClientUserPasswordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateEthereumClientUserPasswordResponseBody(name='body'),
}

/**
 * @param request UpdateEthereumClientUserPasswordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateEthereumClientUserPasswordResponse
 */
async function updateEthereumClientUserPasswordWithOptions(request: UpdateEthereumClientUserPasswordRequest, runtime: Util.RuntimeOptions): UpdateEthereumClientUserPasswordResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.username)) {
    body['Username'] = request.username;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEthereumClientUserPassword',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateEthereumClientUserPasswordRequest
 * @return UpdateEthereumClientUserPasswordResponse
 */
async function updateEthereumClientUserPassword(request: UpdateEthereumClientUserPasswordRequest): UpdateEthereumClientUserPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEthereumClientUserPasswordWithOptions(request, runtime);
}

model UpdateEthereumNodeRequest {
  description?: string(name='Description'),
  nodeId?: string(name='NodeId', description='This parameter is required.'),
  nodeName?: string(name='NodeName'),
}

model UpdateEthereumNodeResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    createTime?: long(name='CreateTime'),
    creator?: string(name='Creator'),
    description?: string(name='Description'),
    ethereumId?: string(name='EthereumId'),
    ethereumName?: string(name='EthereumName'),
    id?: string(name='Id'),
    networkId?: string(name='NetworkId'),
    nodeName?: string(name='NodeName'),
    publicIp?: string(name='PublicIp'),
    regionId?: string(name='RegionId'),
    rpcPort?: int32(name='RpcPort'),
    state?: string(name='State'),
    wsPort?: int32(name='WsPort'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateEthereumNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateEthereumNodeResponseBody(name='body'),
}

/**
 * @param request UpdateEthereumNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateEthereumNodeResponse
 */
async function updateEthereumNodeWithOptions(request: UpdateEthereumNodeRequest, runtime: Util.RuntimeOptions): UpdateEthereumNodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.nodeName)) {
    body['NodeName'] = request.nodeName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEthereumNode',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateEthereumNodeRequest
 * @return UpdateEthereumNodeResponse
 */
async function updateEthereumNode(request: UpdateEthereumNodeRequest): UpdateEthereumNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEthereumNodeWithOptions(request, runtime);
}

model UpdateEthereumNodeConfigurationRequest {
  IP?: string(name='IP', description='This parameter is required.'),
  nodeId?: string(name='NodeId', description='This parameter is required.'),
  nodePub?: string(name='NodePub', description='This parameter is required.'),
  p2pPort?: int32(name='P2pPort', description='This parameter is required.'),
  raftPort?: int32(name='RaftPort'),
  rpcPort?: int32(name='RpcPort'),
  TMPort?: int32(name='TMPort', description='This parameter is required.'),
  TMPub?: string(name='TMPub', description='This parameter is required.'),
  WSPort?: int32(name='WSPort'),
}

model UpdateEthereumNodeConfigurationResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateEthereumNodeConfigurationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateEthereumNodeConfigurationResponseBody(name='body'),
}

/**
 * @param request UpdateEthereumNodeConfigurationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateEthereumNodeConfigurationResponse
 */
async function updateEthereumNodeConfigurationWithOptions(request: UpdateEthereumNodeConfigurationRequest, runtime: Util.RuntimeOptions): UpdateEthereumNodeConfigurationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.IP)) {
    body['IP'] = request.IP;
  }
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.nodePub)) {
    body['NodePub'] = request.nodePub;
  }
  if (!Util.isUnset(request.p2pPort)) {
    body['P2pPort'] = request.p2pPort;
  }
  if (!Util.isUnset(request.raftPort)) {
    body['RaftPort'] = request.raftPort;
  }
  if (!Util.isUnset(request.rpcPort)) {
    body['RpcPort'] = request.rpcPort;
  }
  if (!Util.isUnset(request.TMPort)) {
    body['TMPort'] = request.TMPort;
  }
  if (!Util.isUnset(request.TMPub)) {
    body['TMPub'] = request.TMPub;
  }
  if (!Util.isUnset(request.WSPort)) {
    body['WSPort'] = request.WSPort;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEthereumNodeConfiguration',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateEthereumNodeConfigurationRequest
 * @return UpdateEthereumNodeConfigurationResponse
 */
async function updateEthereumNodeConfiguration(request: UpdateEthereumNodeConfigurationRequest): UpdateEthereumNodeConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEthereumNodeConfigurationWithOptions(request, runtime);
}

model UpdateGovernanceTaskRequest {
  channelId?: string(name='ChannelId', description='This parameter is required.'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
  taskAction?: string(name='TaskAction', description='This parameter is required.'),
  taskId?: string(name='TaskId', description='This parameter is required.'),
}

model UpdateGovernanceTaskResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  requestId?: string(name='RequestId'),
  result?: {
    channelName?: string(name='ChannelName'),
    content?: {
      addedOrganizations?: [ 
        {
          anchorPeers?: [ 
            {
              host?: string(name='Host'),
              port?: int32(name='Port'),
            }
          ](name='AnchorPeers'),
          crls?: string(name='Crls'),
          mspId?: string(name='MspId'),
          mspType?: string(name='MspType'),
          orderer?: boolean(name='Orderer'),
          ordererNodes?: [ 
            {
              address?: string(name='Address'),
              certificate?: string(name='Certificate'),
              key?: string(name='Key'),
              tlsroot?: string(name='Tlsroot'),
            }
          ](name='OrdererNodes'),
          rootCertificates?: string(name='RootCertificates'),
          tlsRootCertificates?: string(name='TlsRootCertificates'),
        }
      ](name='AddedOrganizations'),
      chaincodeSpecPkg?: {
        cs?: {
          input?: string(name='Input'),
          name?: string(name='Name'),
          path?: string(name='Path'),
          type?: int32(name='Type'),
          version?: string(name='Version'),
        }(name='Cs'),
        policy?: string(name='Policy'),
        sha256?: string(name='Sha256'),
      }(name='ChaincodeSpecPkg'),
      ordererConfig?: {
        batchTimeout?: string(name='BatchTimeout'),
        maxMessageCount?: int32(name='MaxMessageCount'),
        preferredMaxBytes?: int32(name='PreferredMaxBytes'),
      }(name='OrdererConfig'),
      raw?: string(name='Raw'),
      removedOrganizations?: [ 
        {
          anchorPeers?: [ 
            {
              host?: string(name='Host'),
              port?: int32(name='Port'),
            }
          ](name='AnchorPeers'),
          crls?: string(name='Crls'),
          mspId?: string(name='MspId'),
          mspType?: string(name='MspType'),
          orderer?: boolean(name='Orderer'),
          ordererNodes?: [ 
            {
              address?: string(name='Address'),
              certificate?: string(name='Certificate'),
              key?: string(name='Key'),
              tlsroot?: string(name='Tlsroot'),
            }
          ](name='OrdererNodes'),
          rootCertificates?: string(name='RootCertificates'),
          tlsRootCertificates?: string(name='TlsRootCertificates'),
        }
      ](name='RemovedOrganizations'),
      rwSets?: string(name='RwSets'),
    }(name='Content'),
    createTime?: long(name='CreateTime'),
    creator?: string(name='Creator'),
    description?: string(name='Description'),
    status?: string(name='Status'),
    taskId?: string(name='TaskId'),
    type?: string(name='Type'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateGovernanceTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateGovernanceTaskResponseBody(name='body'),
}

/**
 * @param request UpdateGovernanceTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateGovernanceTaskResponse
 */
async function updateGovernanceTaskWithOptions(request: UpdateGovernanceTaskRequest, runtime: Util.RuntimeOptions): UpdateGovernanceTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.taskAction)) {
    body['TaskAction'] = request.taskAction;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGovernanceTask',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateGovernanceTaskRequest
 * @return UpdateGovernanceTaskResponse
 */
async function updateGovernanceTask(request: UpdateGovernanceTaskRequest): UpdateGovernanceTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGovernanceTaskWithOptions(request, runtime);
}

model UpdateMemberRoleRequest {
  bid?: string(name='Bid'),
  bizid?: string(name='Bizid'),
  role?: int32(name='Role'),
  userId?: long(name='UserId'),
}

model UpdateMemberRoleResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model UpdateMemberRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateMemberRoleResponseBody(name='body'),
}

/**
 * @param request UpdateMemberRoleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateMemberRoleResponse
 */
async function updateMemberRoleWithOptions(request: UpdateMemberRoleRequest, runtime: Util.RuntimeOptions): UpdateMemberRoleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bid)) {
    body['Bid'] = request.bid;
  }
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.role)) {
    body['Role'] = request.role;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMemberRole',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateMemberRoleRequest
 * @return UpdateMemberRoleResponse
 */
async function updateMemberRole(request: UpdateMemberRoleRequest): UpdateMemberRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMemberRoleWithOptions(request, runtime);
}

model UpdateQRCodeAuthorityRequest {
  authorized?: boolean(name='Authorized'),
  bizid?: string(name='Bizid'),
}

model UpdateQRCodeAuthorityResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model UpdateQRCodeAuthorityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateQRCodeAuthorityResponseBody(name='body'),
}

/**
 * @param request UpdateQRCodeAuthorityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateQRCodeAuthorityResponse
 */
async function updateQRCodeAuthorityWithOptions(request: UpdateQRCodeAuthorityRequest, runtime: Util.RuntimeOptions): UpdateQRCodeAuthorityResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.authorized)) {
    body['Authorized'] = request.authorized;
  }
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateQRCodeAuthority',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateQRCodeAuthorityRequest
 * @return UpdateQRCodeAuthorityResponse
 */
async function updateQRCodeAuthority(request: UpdateQRCodeAuthorityRequest): UpdateQRCodeAuthorityResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateQRCodeAuthorityWithOptions(request, runtime);
}

model UpdateSchemaRequest {
  bizid?: string(name='Bizid'),
  categoryConfigs?: string(name='CategoryConfigs'),
  description?: string(name='Description'),
  schemaId?: long(name='SchemaId'),
  schemaName?: string(name='SchemaName'),
}

model UpdateSchemaResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    responses?: [ 
      {
        category?: string(name='Category'),
        categoryName?: string(name='CategoryName'),
        description?: string(name='Description'),
        properties?: {
          count?: int32(name='Count'),
          dataSource?: [ 
            {
              allowNull?: int32(name='AllowNull'),
              annotation?: string(name='Annotation'),
              field?: string(name='Field'),
              indexes?: int32(name='Indexes'),
              key?: int32(name='Key'),
              length?: int32(name='Length'),
              reg?: string(name='Reg'),
              type?: string(name='Type'),
            }
          ](name='DataSource'),
        }(name='Properties'),
      }
    ](name='Responses'),
    schema?: {
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      id?: long(name='Id'),
      isTemplate?: boolean(name='IsTemplate'),
      name?: string(name='Name'),
      updateTime?: long(name='UpdateTime'),
      version?: long(name='Version'),
    }(name='Schema'),
  }(name='Result'),
}

model UpdateSchemaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSchemaResponseBody(name='body'),
}

/**
 * @param request UpdateSchemaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSchemaResponse
 */
async function updateSchemaWithOptions(request: UpdateSchemaRequest, runtime: Util.RuntimeOptions): UpdateSchemaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizid)) {
    body['Bizid'] = request.bizid;
  }
  if (!Util.isUnset(request.categoryConfigs)) {
    body['CategoryConfigs'] = request.categoryConfigs;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.schemaId)) {
    body['SchemaId'] = request.schemaId;
  }
  if (!Util.isUnset(request.schemaName)) {
    body['SchemaName'] = request.schemaName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSchema',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateSchemaRequest
 * @return UpdateSchemaResponse
 */
async function updateSchema(request: UpdateSchemaRequest): UpdateSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSchemaWithOptions(request, runtime);
}

model UpgradeChaincodeRequest {
  chaincodeId?: string(name='ChaincodeId', description='This parameter is required.', example='code-sacc-fk9z4r97****'),
  collectionConfig?: string(name='CollectionConfig', example='string'),
  endorsePolicy?: string(name='EndorsePolicy', example='OR ("wholesalerMSP.peer")'),
  location?: string(name='Location', example='cn-hangzhou'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.', example='peers-wholesaler-15ix77tof****'),
}

model UpgradeChaincodeResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  requestId?: string(name='RequestId', example='A6CC6C63-2D71-4D0C-AEBE-E95F0127C514'),
  result?: {
    chaincodeId?: string(name='ChaincodeId', example='code-sacc-fk9z4r97****'),
    channelName?: string(name='ChannelName', example='cc'),
    consortiumId?: string(name='ConsortiumId', example='consortium-supplychain-1pxzsp5tb****'),
    createTime?: string(name='CreateTime', example='1545215617000'),
    deployTime?: string(name='DeployTime', example='1545215617000'),
    endorsePolicy?: string(name='EndorsePolicy', example='OR ("wholesalerMSP.peer")'),
    input?: string(name='Input', example='{}'),
    install?: boolean(name='Install', example='true'),
    message?: string(name='Message', example='OK'),
    name?: string(name='Name', example='sacc'),
    path?: string(name='Path', example='github.com/sacc'),
    providerId?: string(name='ProviderId', example='1928592'),
    providerName?: string(name='ProviderName', example='uid-1928592'),
    state?: string(name='State', example='Running'),
    type?: int32(name='Type', example='1'),
    version?: string(name='Version', example='1.0'),
  }(name='Result'),
  success?: boolean(name='Success', example='true'),
}

model UpgradeChaincodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpgradeChaincodeResponseBody(name='body'),
}

/**
 * @param request UpgradeChaincodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpgradeChaincodeResponse
 */
async function upgradeChaincodeWithOptions(request: UpgradeChaincodeRequest, runtime: Util.RuntimeOptions): UpgradeChaincodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.chaincodeId)) {
    body['ChaincodeId'] = request.chaincodeId;
  }
  if (!Util.isUnset(request.collectionConfig)) {
    body['CollectionConfig'] = request.collectionConfig;
  }
  if (!Util.isUnset(request.endorsePolicy)) {
    body['EndorsePolicy'] = request.endorsePolicy;
  }
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeChaincode',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpgradeChaincodeRequest
 * @return UpgradeChaincodeResponse
 */
async function upgradeChaincode(request: UpgradeChaincodeRequest): UpgradeChaincodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeChaincodeWithOptions(request, runtime);
}

model UpgradeFabricChaincodeDefinitionRequest {
  chaincodeId?: string(name='ChaincodeId', description='This parameter is required.'),
  chaincodePackageId?: string(name='ChaincodePackageId', description='This parameter is required.'),
  chaincodeVersion?: string(name='ChaincodeVersion', description='This parameter is required.'),
  channelId?: string(name='ChannelId'),
  collectionConfig?: string(name='CollectionConfig'),
  endorsePolicy?: string(name='EndorsePolicy'),
  initRequired?: boolean(name='InitRequired'),
  location?: string(name='Location'),
  organizationId?: string(name='OrganizationId', description='This parameter is required.'),
}

model UpgradeFabricChaincodeDefinitionResponseBody = {
  chaincodeDefinitionId?: string(name='ChaincodeDefinitionId'),
  chaincodePackageId?: string(name='ChaincodePackageId'),
  errorCode?: int32(name='ErrorCode'),
  initRequired?: boolean(name='InitRequired'),
  requestId?: string(name='RequestId'),
  result?: {
    chaincodeId?: string(name='ChaincodeId'),
    chaincodeVersion?: string(name='ChaincodeVersion'),
    channelName?: string(name='ChannelName'),
    consortiumId?: string(name='ConsortiumId'),
    createTime?: string(name='CreateTime'),
    deployTime?: string(name='DeployTime'),
    endorsePolicy?: string(name='EndorsePolicy'),
    input?: string(name='Input'),
    install?: boolean(name='Install'),
    message?: string(name='Message'),
    name?: string(name='Name'),
    path?: string(name='Path'),
    providerId?: string(name='ProviderId'),
    providerName?: string(name='ProviderName'),
    state?: string(name='State'),
    type?: int32(name='Type'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model UpgradeFabricChaincodeDefinitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpgradeFabricChaincodeDefinitionResponseBody(name='body'),
}

/**
 * @param request UpgradeFabricChaincodeDefinitionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpgradeFabricChaincodeDefinitionResponse
 */
async function upgradeFabricChaincodeDefinitionWithOptions(request: UpgradeFabricChaincodeDefinitionRequest, runtime: Util.RuntimeOptions): UpgradeFabricChaincodeDefinitionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.chaincodeId)) {
    body['ChaincodeId'] = request.chaincodeId;
  }
  if (!Util.isUnset(request.chaincodePackageId)) {
    body['ChaincodePackageId'] = request.chaincodePackageId;
  }
  if (!Util.isUnset(request.chaincodeVersion)) {
    body['ChaincodeVersion'] = request.chaincodeVersion;
  }
  if (!Util.isUnset(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.collectionConfig)) {
    body['CollectionConfig'] = request.collectionConfig;
  }
  if (!Util.isUnset(request.endorsePolicy)) {
    body['EndorsePolicy'] = request.endorsePolicy;
  }
  if (!Util.isUnset(request.initRequired)) {
    body['InitRequired'] = request.initRequired;
  }
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  if (!Util.isUnset(request.organizationId)) {
    body['OrganizationId'] = request.organizationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeFabricChaincodeDefinition',
    version = '2018-07-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpgradeFabricChaincodeDefinitionRequest
 * @return UpgradeFabricChaincodeDefinitionResponse
 */
async function upgradeFabricChaincodeDefinition(request: UpgradeFabricChaincodeDefinitionRequest): UpgradeFabricChaincodeDefinitionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeFabricChaincodeDefinitionWithOptions(request, runtime);
}

