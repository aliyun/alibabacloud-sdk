/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  

  checkConfig(config);
  @endpoint = getEndpoint('xtrace', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model GetTagKeyRequest {
  regionId?: string(name='RegionId'),
  serviceName?: string(name='ServiceName'),
  spanName?: string(name='SpanName'),
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
}

model GetTagKeyResponseBody = {
  requestId?: string(name='RequestId'),
  tagKeys?: {
    tagKey?: [ string ](name='TagKey')
  }(name='TagKeys'),
}

model GetTagKeyResponse = {
  headers: map[string]string(name='headers'),
  body: GetTagKeyResponseBody(name='body'),
}

async function getTagKeyWithOptions(request: GetTagKeyRequest, runtime: Util.RuntimeOptions): GetTagKeyResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ServiceName"] = request.serviceName;
  query["SpanName"] = request.spanName;
  query["StartTime"] = request.startTime;
  query["EndTime"] = request.endTime;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetTagKey',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTagKey(request: GetTagKeyRequest): GetTagKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTagKeyWithOptions(request, runtime);
}

model GetTagValRequest {
  regionId?: string(name='RegionId'),
  serviceName?: string(name='ServiceName'),
  spanName?: string(name='SpanName'),
  tagKey?: string(name='TagKey'),
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
}

model GetTagValResponseBody = {
  requestId?: string(name='RequestId'),
  tagValues?: {
    tagValue?: [ string ](name='TagValue')
  }(name='TagValues'),
}

model GetTagValResponse = {
  headers: map[string]string(name='headers'),
  body: GetTagValResponseBody(name='body'),
}

async function getTagValWithOptions(request: GetTagValRequest, runtime: Util.RuntimeOptions): GetTagValResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ServiceName"] = request.serviceName;
  query["SpanName"] = request.spanName;
  query["TagKey"] = request.tagKey;
  query["StartTime"] = request.startTime;
  query["EndTime"] = request.endTime;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetTagVal',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTagVal(request: GetTagValRequest): GetTagValResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTagValWithOptions(request, runtime);
}

model GetTokenRequest {
  regionId?: string(name='RegionId'),
  appType?: string(name='AppType'),
  proxyUserId?: string(name='ProxyUserId'),
  isForce?: boolean(name='IsForce'),
}

model GetTokenResponseBody = {
  requestId?: string(name='RequestId'),
  token?: {
    domain?: string(name='Domain'),
    licenseKey?: string(name='LicenseKey'),
    internalDomain?: string(name='InternalDomain'),
    pid?: string(name='Pid'),
  }(name='Token'),
}

model GetTokenResponse = {
  headers: map[string]string(name='headers'),
  body: GetTokenResponseBody(name='body'),
}

async function getTokenWithOptions(request: GetTokenRequest, runtime: Util.RuntimeOptions): GetTokenResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["AppType"] = request.appType;
  query["ProxyUserId"] = request.proxyUserId;
  query["IsForce"] = request.isForce;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetToken',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getToken(request: GetTokenRequest): GetTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTokenWithOptions(request, runtime);
}

model GetTraceRequest {
  traceID?: string(name='TraceID'),
  appType?: string(name='AppType'),
  regionId?: string(name='RegionId'),
}

model GetTraceResponseBody = {
  requestId?: string(name='RequestId'),
  spans?: {
    span?: [ 
    {
      spanId?: string(name='SpanId'),
      operationName?: string(name='OperationName'),
      resultCode?: string(name='ResultCode'),
      timestamp?: long(name='Timestamp'),
      tagEntryList?: {
        tagEntry?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='TagEntry')
      }(name='TagEntryList'),
      logEventList?: {
        logEvent?: [ 
        {
          tagEntryList?: {
            tagEntry?: [ 
            {
              key?: string(name='Key'),
              value?: string(name='Value'),
            }
          ](name='TagEntry')
          }(name='TagEntryList'),
          timestamp?: long(name='Timestamp'),
        }
      ](name='LogEvent')
      }(name='LogEventList'),
      haveStack?: boolean(name='HaveStack'),
      serviceIp?: string(name='ServiceIp'),
      parentSpanId?: string(name='ParentSpanId'),
      duration?: long(name='Duration'),
      rpcId?: string(name='RpcId'),
      serviceName?: string(name='ServiceName'),
      traceID?: string(name='TraceID'),
    }
  ](name='Span')
  }(name='Spans'),
}

model GetTraceResponse = {
  headers: map[string]string(name='headers'),
  body: GetTraceResponseBody(name='body'),
}

async function getTraceWithOptions(request: GetTraceRequest, runtime: Util.RuntimeOptions): GetTraceResponse {
  Util.validateModel(request);
  var query = {};
  query["TraceID"] = request.traceID;
  query["AppType"] = request.appType;
  query["RegionId"] = request.regionId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetTrace',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTrace(request: GetTraceRequest): GetTraceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTraceWithOptions(request, runtime);
}

model ListIpOrHostsRequest {
  regionId?: string(name='RegionId'),
  serviceName?: string(name='ServiceName'),
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
}

model ListIpOrHostsResponseBody = {
  requestId?: string(name='RequestId'),
  ipNames?: {
    ipName?: [ string ](name='IpName')
  }(name='IpNames'),
}

model ListIpOrHostsResponse = {
  headers: map[string]string(name='headers'),
  body: ListIpOrHostsResponseBody(name='body'),
}

async function listIpOrHostsWithOptions(request: ListIpOrHostsRequest, runtime: Util.RuntimeOptions): ListIpOrHostsResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ServiceName"] = request.serviceName;
  query["StartTime"] = request.startTime;
  query["EndTime"] = request.endTime;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListIpOrHosts',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listIpOrHosts(request: ListIpOrHostsRequest): ListIpOrHostsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listIpOrHostsWithOptions(request, runtime);
}

model ListServicesRequest {
  regionId?: string(name='RegionId'),
  appType?: string(name='AppType'),
}

model ListServicesResponseBody = {
  services?: {
    service?: [ 
    {
      pid?: string(name='Pid'),
      serviceName?: string(name='ServiceName'),
      regionId?: string(name='RegionId'),
    }
  ](name='Service')
  }(name='Services'),
  requestId?: string(name='RequestId'),
}

model ListServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListServicesResponseBody(name='body'),
}

async function listServicesWithOptions(request: ListServicesRequest, runtime: Util.RuntimeOptions): ListServicesResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["AppType"] = request.appType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListServices',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServices(request: ListServicesRequest): ListServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listServicesWithOptions(request, runtime);
}

model ListSpanNamesRequest {
  regionId?: string(name='RegionId'),
  serviceName?: string(name='ServiceName'),
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
}

model ListSpanNamesResponseBody = {
  spanNames?: {
    spanName?: [ string ](name='SpanName')
  }(name='SpanNames'),
  requestId?: string(name='RequestId'),
}

model ListSpanNamesResponse = {
  headers: map[string]string(name='headers'),
  body: ListSpanNamesResponseBody(name='body'),
}

async function listSpanNamesWithOptions(request: ListSpanNamesRequest, runtime: Util.RuntimeOptions): ListSpanNamesResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ServiceName"] = request.serviceName;
  query["StartTime"] = request.startTime;
  query["EndTime"] = request.endTime;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListSpanNames',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSpanNames(request: ListSpanNamesRequest): ListSpanNamesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSpanNamesWithOptions(request, runtime);
}

model QueryMetricRequest {
  intervalInSec?: int32(name='IntervalInSec'),
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
  orderBy?: string(name='OrderBy'),
  limit?: int32(name='Limit'),
  metric?: string(name='Metric'),
  order?: string(name='Order'),
  proxyUserId?: string(name='ProxyUserId'),
  filters?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filters'),
  dimensions?: [ string ](name='Dimensions'),
  measures?: [ string ](name='Measures'),
}

model QueryMetricResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model QueryMetricResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMetricResponseBody(name='body'),
}

async function queryMetricWithOptions(request: QueryMetricRequest, runtime: Util.RuntimeOptions): QueryMetricResponse {
  Util.validateModel(request);
  var query = {};
  query["IntervalInSec"] = request.intervalInSec;
  query["StartTime"] = request.startTime;
  query["EndTime"] = request.endTime;
  query["OrderBy"] = request.orderBy;
  query["Limit"] = request.limit;
  query["Metric"] = request.metric;
  query["Order"] = request.order;
  query["ProxyUserId"] = request.proxyUserId;
  query["Filters"] = request.filters;
  query["Dimensions"] = request.dimensions;
  query["Measures"] = request.measures;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryMetric',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMetric(request: QueryMetricRequest): QueryMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMetricWithOptions(request, runtime);
}

model SearchTracesRequest {
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
  regionId?: string(name='RegionId'),
  serviceName?: string(name='ServiceName'),
  operationName?: string(name='OperationName'),
  minDuration?: long(name='MinDuration'),
  appType?: string(name='AppType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  reverse?: boolean(name='Reverse'),
  serviceIp?: string(name='ServiceIp'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model SearchTracesResponseBody = {
  pageBean?: {
    traceInfos?: {
      traceInfo?: [ 
      {
        operationName?: string(name='OperationName'),
        serviceIp?: string(name='ServiceIp'),
        duration?: long(name='Duration'),
        timestamp?: long(name='Timestamp'),
        serviceName?: string(name='ServiceName'),
        traceID?: string(name='TraceID'),
      }
    ](name='TraceInfo')
    }(name='TraceInfos'),
    pageSize?: int32(name='PageSize'),
    pageNumber?: int32(name='PageNumber'),
    totalCount?: long(name='TotalCount'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchTracesResponse = {
  headers: map[string]string(name='headers'),
  body: SearchTracesResponseBody(name='body'),
}

async function searchTracesWithOptions(request: SearchTracesRequest, runtime: Util.RuntimeOptions): SearchTracesResponse {
  Util.validateModel(request);
  var query = {};
  query["StartTime"] = request.startTime;
  query["EndTime"] = request.endTime;
  query["RegionId"] = request.regionId;
  query["ServiceName"] = request.serviceName;
  query["OperationName"] = request.operationName;
  query["MinDuration"] = request.minDuration;
  query["AppType"] = request.appType;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["Reverse"] = request.reverse;
  query["ServiceIp"] = request.serviceIp;
  query["Tag"] = request.tag;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SearchTraces',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchTraces(request: SearchTracesRequest): SearchTracesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTracesWithOptions(request, runtime);
}

