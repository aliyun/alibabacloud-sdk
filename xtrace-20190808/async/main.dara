/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'xtrace';
  @version = '2019-08-08';
  @endpointRule = 'regional';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model GetTagKeyRequest {
  endTime?: long(name='EndTime', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  serviceName?: string(name='ServiceName', position='Query'),
  spanName?: string(name='SpanName', position='Query'),
  startTime?: long(name='StartTime', position='Query'),
}

model GetTagKeyResponseBody = {
  requestId?: string(name='RequestId'),
  tagKeys?: {
    tagKey?: [ string ](name='TagKey')
  }(name='TagKeys'),
}

model GetTagKeyResponse = {
  headers: map[string]string(name='headers'),
  body: GetTagKeyResponseBody(name='body'),
}

async function getTagKey(request: GetTagKeyRequest): GetTagKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTagKey', 'POST', '/', 'json', false, 'json', request);
}

model GetTagValRequest {
  endTime?: long(name='EndTime', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  serviceName?: string(name='ServiceName', position='Query'),
  spanName?: string(name='SpanName', position='Query'),
  startTime?: long(name='StartTime', position='Query'),
  tagKey: string(name='TagKey', position='Query'),
}

model GetTagValResponseBody = {
  requestId?: string(name='RequestId'),
  tagValues?: {
    tagValue?: [ string ](name='TagValue')
  }(name='TagValues'),
}

model GetTagValResponse = {
  headers: map[string]string(name='headers'),
  body: GetTagValResponseBody(name='body'),
}

async function getTagVal(request: GetTagValRequest): GetTagValResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTagVal', 'POST', '/', 'json', false, 'json', request);
}

model GetTraceRequest {
  appType?: string(name='AppType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  traceID: string(name='TraceID', position='Query'),
}

model GetTraceResponseBody = {
  requestId?: string(name='RequestId'),
  spans?: {
    span?: [ 
    {
      duration?: long(name='Duration'),
      haveStack?: boolean(name='HaveStack'),
      logEventList?: {
        logEvent?: [ 
        {
          tagEntryList?: {
            tagEntry?: [ 
            {
              key?: string(name='Key'),
              value?: string(name='Value'),
            }
          ](name='TagEntry')
          }(name='TagEntryList'),
          timestamp?: long(name='Timestamp'),
        }
      ](name='LogEvent')
      }(name='LogEventList'),
      operationName?: string(name='OperationName'),
      parentSpanId?: string(name='ParentSpanId'),
      resultCode?: string(name='ResultCode'),
      rpcId?: string(name='RpcId'),
      serviceIp?: string(name='ServiceIp'),
      serviceName?: string(name='ServiceName'),
      spanId?: string(name='SpanId'),
      tagEntryList?: {
        tagEntry?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='TagEntry')
      }(name='TagEntryList'),
      timestamp?: long(name='Timestamp'),
      traceID?: string(name='TraceID'),
    }
  ](name='Span')
  }(name='Spans'),
}

model GetTraceResponse = {
  headers: map[string]string(name='headers'),
  body: GetTraceResponseBody(name='body'),
}

async function getTrace(request: GetTraceRequest): GetTraceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTrace', 'POST', '/', 'json', false, 'json', request);
}

model ListIpOrHostsRequest {
  endTime?: long(name='EndTime', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  serviceName?: string(name='ServiceName', position='Query'),
  startTime?: long(name='StartTime', position='Query'),
}

model ListIpOrHostsResponseBody = {
  ipNames?: {
    ipName?: [ string ](name='IpName')
  }(name='IpNames'),
  requestId?: string(name='RequestId'),
}

model ListIpOrHostsResponse = {
  headers: map[string]string(name='headers'),
  body: ListIpOrHostsResponseBody(name='body'),
}

async function listIpOrHosts(request: ListIpOrHostsRequest): ListIpOrHostsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListIpOrHosts', 'POST', '/', 'json', false, 'json', request);
}

model ListServicesRequest {
  appType?: string(name='AppType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListServicesResponseBody = {
  requestId?: string(name='RequestId'),
  services?: {
    service?: [ 
    {
      pid?: string(name='Pid'),
      regionId?: string(name='RegionId'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='Service')
  }(name='Services'),
}

model ListServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListServicesResponseBody(name='body'),
}

async function listServices(request: ListServicesRequest): ListServicesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListServices', 'POST', '/', 'json', false, 'json', request);
}

model ListSpanNamesRequest {
  endTime?: long(name='EndTime', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  serviceName?: string(name='ServiceName', position='Query'),
  startTime?: long(name='StartTime', position='Query'),
}

model ListSpanNamesResponseBody = {
  requestId?: string(name='RequestId'),
  spanNames?: {
    spanName?: [ string ](name='SpanName')
  }(name='SpanNames'),
}

model ListSpanNamesResponse = {
  headers: map[string]string(name='headers'),
  body: ListSpanNamesResponseBody(name='body'),
}

async function listSpanNames(request: ListSpanNamesRequest): ListSpanNamesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSpanNames', 'POST', '/', 'json', false, 'json', request);
}

model QueryMetricRequest {
  dimensions?: [ string ](name='Dimensions', position='Query'),
  endTime: long(name='EndTime', position='Query'),
  filters?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filters', position='Query'),
  intervalInSec?: int32(name='IntervalInSec', position='Query'),
  limit?: int32(name='Limit', position='Query'),
  measures: [ string ](name='Measures', position='Query'),
  metric: string(name='Metric', position='Query'),
  order?: string(name='Order', position='Query'),
  orderBy?: string(name='OrderBy', position='Query'),
  proxyUserId?: string(name='ProxyUserId', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  startTime: long(name='StartTime', position='Query'),
}

model QueryMetricResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryMetricResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMetricResponseBody(name='body'),
}

async function queryMetric(request: QueryMetricRequest): QueryMetricResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMetric', 'POST', '/', 'json', false, 'json', request);
}

model SearchTracesRequest {
  appType?: string(name='AppType', position='Query'),
  endTime: long(name='EndTime', position='Query'),
  minDuration?: long(name='MinDuration', position='Query'),
  operationName?: string(name='OperationName', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  reverse?: boolean(name='Reverse', position='Query'),
  serviceIp?: string(name='ServiceIp', position='Query'),
  serviceName?: string(name='ServiceName', position='Query'),
  startTime: long(name='StartTime', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model SearchTracesResponseBody = {
  pageBean?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    traceInfos?: {
      traceInfo?: [ 
      {
        duration?: long(name='Duration'),
        operationName?: string(name='OperationName'),
        serviceIp?: string(name='ServiceIp'),
        serviceName?: string(name='ServiceName'),
        tagMap?: map[string]any(name='TagMap'),
        timestamp?: long(name='Timestamp'),
        traceID?: string(name='TraceID'),
      }
    ](name='TraceInfo')
    }(name='TraceInfos'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchTracesResponse = {
  headers: map[string]string(name='headers'),
  body: SearchTracesResponseBody(name='body'),
}

async function searchTraces(request: SearchTracesRequest): SearchTracesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchTraces', 'POST', '/', 'json', false, 'json', request);
}

