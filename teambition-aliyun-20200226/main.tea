/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  

  checkConfig(config);
  @endpoint = getEndpoint('teambition-aliyun', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model AddProjectMembersRequest {
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
  members?: string(name='Members'),
}

model AddProjectMembersResponseBody = {
  requestId?: string(name='RequestId'),
  errorMsg?: string(name='ErrorMsg'),
  object?: boolean(name='Object'),
  errorCode?: string(name='ErrorCode'),
  successful?: boolean(name='Successful'),
}

model AddProjectMembersResponse = {
  headers: map[string]string(name='headers'),
  body: AddProjectMembersResponseBody(name='body'),
}

async function addProjectMembersWithOptions(request: AddProjectMembersRequest, runtime: Util.RuntimeOptions): AddProjectMembersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddProjectMembers',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addProjectMembers(request: AddProjectMembersRequest): AddProjectMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return addProjectMembersWithOptions(request, runtime);
}

model ApplySmallMicroRequest {
  orgId?: string(name='OrgId'),
  type?: string(name='Type'),
  orgName?: string(name='OrgName'),
  applicantName?: string(name='ApplicantName'),
  applicantTel?: string(name='ApplicantTel'),
  applicantEmail?: string(name='ApplicantEmail'),
  applicantPosition?: string(name='ApplicantPosition'),
  developScale?: string(name='DevelopScale'),
  developLanguage?: string(name='DevelopLanguage'),
  businessModel?: string(name='BusinessModel'),
  solution?: string(name='Solution'),
  forHelp?: string(name='ForHelp'),
}

model ApplySmallMicroResponseBody = {
  result?: map[string]any(name='result'),
  code?: int32(name='code'),
  requestId?: string(name='RequestId'),
  raw?: boolean(name='raw'),
  message?: boolean(name='message'),
}

model ApplySmallMicroResponse = {
  headers: map[string]string(name='headers'),
  body: ApplySmallMicroResponseBody(name='body'),
}

async function applySmallMicroWithOptions(request: ApplySmallMicroRequest, runtime: Util.RuntimeOptions): ApplySmallMicroResponse {
  Util.validateModel(request);
  var query = {};
  query["DevelopScale"] = request.developScale;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ApplySmallMicro',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function applySmallMicro(request: ApplySmallMicroRequest): ApplySmallMicroResponse {
  var runtime = new Util.RuntimeOptions{};
  return applySmallMicroWithOptions(request, runtime);
}

model BactchInsertMembersRequest {
  orgId?: string(name='OrgId'),
  members?: string(name='Members'),
  realPk?: string(name='RealPk'),
}

model BactchInsertMembersResponseBody = {
  requestId?: string(name='RequestId'),
  object?: boolean(name='Object'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
}

model BactchInsertMembersResponse = {
  headers: map[string]string(name='headers'),
  body: BactchInsertMembersResponseBody(name='body'),
}

async function bactchInsertMembersWithOptions(request: BactchInsertMembersRequest, runtime: Util.RuntimeOptions): BactchInsertMembersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'BactchInsertMembers',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function bactchInsertMembers(request: BactchInsertMembersRequest): BactchInsertMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return bactchInsertMembersWithOptions(request, runtime);
}

model CheckAliyunUserExistsRequest {
  userPk?: string(name='UserPk'),
}

model CheckAliyunUserExistsResponseBody = {
  requestId?: string(name='RequestId'),
  errorMsg?: string(name='ErrorMsg'),
  object?: boolean(name='Object'),
  errorCode?: string(name='ErrorCode'),
  successful?: boolean(name='Successful'),
}

model CheckAliyunUserExistsResponse = {
  headers: map[string]string(name='headers'),
  body: CheckAliyunUserExistsResponseBody(name='body'),
}

async function checkAliyunUserExistsWithOptions(request: CheckAliyunUserExistsRequest, runtime: Util.RuntimeOptions): CheckAliyunUserExistsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CheckAliyunUserExists',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkAliyunUserExists(request: CheckAliyunUserExistsRequest): CheckAliyunUserExistsResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkAliyunUserExistsWithOptions(request, runtime);
}

model CreateDevopsOrgRequest {
  orgName?: string(name='OrgName'),
  source?: string(name='Source'),
  realPk?: string(name='RealPk'),
  desiredMemberCount?: int32(name='DesiredMemberCount'),
}

model CreateDevopsOrgResponseBody = {
  requestId?: string(name='RequestId'),
  object?: string(name='Object'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
}

model CreateDevopsOrgResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDevopsOrgResponseBody(name='body'),
}

async function createDevopsOrgWithOptions(request: CreateDevopsOrgRequest, runtime: Util.RuntimeOptions): CreateDevopsOrgResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateDevopsOrg',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDevopsOrg(request: CreateDevopsOrgRequest): CreateDevopsOrgResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDevopsOrgWithOptions(request, runtime);
}

model CreateProjectRequest {
  orgId?: string(name='OrgId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
}

model CreateProjectResponseBody = {
  requestId?: string(name='RequestId'),
  object?: string(name='Object'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
}

model CreateProjectResponse = {
  headers: map[string]string(name='headers'),
  body: CreateProjectResponseBody(name='body'),
}

async function createProjectWithOptions(request: CreateProjectRequest, runtime: Util.RuntimeOptions): CreateProjectResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateProject',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createProject(request: CreateProjectRequest): CreateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return createProjectWithOptions(request, runtime);
}

model CreateProjectSprintRequest {
  orgId?: string(name='OrgId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  projectId?: string(name='ProjectId'),
  executorId?: string(name='ExecutorId'),
  startDate?: string(name='StartDate'),
  dueDate?: string(name='DueDate'),
}

model CreateProjectSprintResponseBody = {
  requestId?: string(name='RequestId'),
  errorMsg?: string(name='ErrorMsg'),
  object?: {
    status?: string(name='Status'),
    projectId?: string(name='ProjectId'),
    startDate?: string(name='StartDate'),
    creatorId?: string(name='CreatorId'),
    executor?: string(name='Executor'),
    description?: string(name='Description'),
    accomplished?: string(name='Accomplished'),
    isDeleted?: boolean(name='IsDeleted'),
    updated?: string(name='Updated'),
    dueDate?: string(name='DueDate'),
    name?: string(name='Name'),
    created?: string(name='Created'),
    planToDo?: {
      tasks?: int32(name='Tasks'),
      workTimes?: int32(name='WorkTimes'),
      storyPoints?: int32(name='StoryPoints'),
    }(name='PlanToDo'),
    id?: string(name='Id'),
  }(name='Object'),
  errorCode?: string(name='ErrorCode'),
  successful?: boolean(name='Successful'),
}

model CreateProjectSprintResponse = {
  headers: map[string]string(name='headers'),
  body: CreateProjectSprintResponseBody(name='body'),
}

async function createProjectSprintWithOptions(request: CreateProjectSprintRequest, runtime: Util.RuntimeOptions): CreateProjectSprintResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateProjectSprint',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createProjectSprint(request: CreateProjectSprintRequest): CreateProjectSprintResponse {
  var runtime = new Util.RuntimeOptions{};
  return createProjectSprintWithOptions(request, runtime);
}

model CreateProjectTaskRequest {
  orgId?: string(name='OrgId'),
  content?: string(name='Content'),
  projectId?: string(name='ProjectId'),
  executorId?: string(name='ExecutorId'),
  startDate?: string(name='StartDate'),
  dueDate?: string(name='DueDate'),
  scenarioFieldConfigId?: string(name='ScenarioFieldConfigId'),
  taskFlowStatusId?: string(name='TaskFlowStatusId'),
  note?: string(name='Note'),
  priority?: int32(name='Priority'),
  visible?: string(name='Visible'),
  parentTaskId?: string(name='ParentTaskId'),
  sprintId?: string(name='SprintId'),
  taskListId?: string(name='TaskListId'),
}

model CreateProjectTaskResponseBody = {
  requestId?: string(name='RequestId'),
  errorMsg?: string(name='ErrorMsg'),
  object?: {
    executorId?: string(name='ExecutorId'),
    projectId?: string(name='ProjectId'),
    priority?: int32(name='Priority'),
    scenarioFieldConfigId?: string(name='ScenarioFieldConfigId'),
    ancestorIds?: string(name='AncestorIds'),
    taskType?: string(name='TaskType'),
    tasklistId?: string(name='TasklistId'),
    taskflowstatusId?: string(name='TaskflowstatusId'),
    note?: string(name='Note'),
    updated?: string(name='Updated'),
    uniqueId?: int32(name='UniqueId'),
    content?: string(name='Content'),
    rating?: int32(name='Rating'),
    pos?: int32(name='Pos'),
    startDate?: string(name='StartDate'),
    storyPoint?: string(name='StoryPoint'),
    creatorId?: string(name='CreatorId'),
    source?: string(name='Source'),
    organizationId?: string(name='OrganizationId'),
    visible?: string(name='Visible'),
    isDone?: boolean(name='IsDone'),
    sprintId?: string(name='SprintId'),
    dueDate?: string(name='DueDate'),
    created?: string(name='Created'),
    id?: string(name='Id'),
  }(name='Object'),
  errorCode?: string(name='ErrorCode'),
  successful?: boolean(name='Successful'),
}

model CreateProjectTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateProjectTaskResponseBody(name='body'),
}

async function createProjectTaskWithOptions(request: CreateProjectTaskRequest, runtime: Util.RuntimeOptions): CreateProjectTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateProjectTask',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createProjectTask(request: CreateProjectTaskRequest): CreateProjectTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createProjectTaskWithOptions(request, runtime);
}

model DeleteMembersForOrgRequest {
  orgId?: string(name='OrgId'),
  userId?: string(name='UserId'),
  realPk?: string(name='RealPk'),
}

model DeleteMembersForOrgResponseBody = {
  requestId?: string(name='RequestId'),
  object?: boolean(name='Object'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
}

model DeleteMembersForOrgResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMembersForOrgResponseBody(name='body'),
}

async function deleteMembersForOrgWithOptions(request: DeleteMembersForOrgRequest, runtime: Util.RuntimeOptions): DeleteMembersForOrgResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMembersForOrg',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMembersForOrg(request: DeleteMembersForOrgRequest): DeleteMembersForOrgResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMembersForOrgWithOptions(request, runtime);
}

model DeleteProjectRequest {
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
}

model DeleteProjectResponseBody = {
  requestId?: string(name='RequestId'),
  object?: string(name='Object'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
}

model DeleteProjectResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteProjectResponseBody(name='body'),
}

async function deleteProjectWithOptions(request: DeleteProjectRequest, runtime: Util.RuntimeOptions): DeleteProjectResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProject',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteProject(request: DeleteProjectRequest): DeleteProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProjectWithOptions(request, runtime);
}

model DeleteProjectMembersRequest {
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
  userIds?: string(name='UserIds'),
}

model DeleteProjectMembersResponseBody = {
  requestId?: string(name='RequestId'),
  errorMsg?: string(name='ErrorMsg'),
  object?: boolean(name='Object'),
  errorCode?: string(name='ErrorCode'),
  successful?: boolean(name='Successful'),
}

model DeleteProjectMembersResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteProjectMembersResponseBody(name='body'),
}

async function deleteProjectMembersWithOptions(request: DeleteProjectMembersRequest, runtime: Util.RuntimeOptions): DeleteProjectMembersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProjectMembers',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteProjectMembers(request: DeleteProjectMembersRequest): DeleteProjectMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProjectMembersWithOptions(request, runtime);
}

model DeleteProjectSprintRequest {
  orgId?: string(name='OrgId'),
  sprintId?: string(name='SprintId'),
}

model DeleteProjectSprintResponseBody = {
  requestId?: string(name='RequestId'),
  errorMsg?: string(name='ErrorMsg'),
  object?: boolean(name='Object'),
  errorCode?: string(name='ErrorCode'),
  successful?: boolean(name='Successful'),
}

model DeleteProjectSprintResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteProjectSprintResponseBody(name='body'),
}

async function deleteProjectSprintWithOptions(request: DeleteProjectSprintRequest, runtime: Util.RuntimeOptions): DeleteProjectSprintResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProjectSprint',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteProjectSprint(request: DeleteProjectSprintRequest): DeleteProjectSprintResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProjectSprintWithOptions(request, runtime);
}

model DeleteProjectTaskRequest {
  orgId?: string(name='OrgId'),
  taskId?: string(name='TaskId'),
}

model DeleteProjectTaskResponseBody = {
  requestId?: string(name='RequestId'),
  errorMsg?: string(name='ErrorMsg'),
  object?: boolean(name='Object'),
  errorCode?: string(name='ErrorCode'),
  successful?: boolean(name='Successful'),
}

model DeleteProjectTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteProjectTaskResponseBody(name='body'),
}

async function deleteProjectTaskWithOptions(request: DeleteProjectTaskRequest, runtime: Util.RuntimeOptions): DeleteProjectTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProjectTask',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteProjectTask(request: DeleteProjectTaskRequest): DeleteProjectTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProjectTaskWithOptions(request, runtime);
}

model GetOrganizationMembersRequest {
  orgId?: string(name='OrgId'),
}

model GetOrganizationMembersResponseBody = {
  requestId?: string(name='RequestId'),
  errorMsg?: string(name='ErrorMsg'),
  object?: [ 
    {
      email?: string(name='Email'),
      avatarUrl?: string(name='AvatarUrl'),
      userId?: string(name='UserId'),
      memberId?: string(name='MemberId'),
      role?: int32(name='Role'),
      name?: string(name='Name'),
      phone?: string(name='Phone'),
    }
  ](name='Object'),
  errorCode?: string(name='ErrorCode'),
  successful?: boolean(name='Successful'),
}

model GetOrganizationMembersResponse = {
  headers: map[string]string(name='headers'),
  body: GetOrganizationMembersResponseBody(name='body'),
}

async function getOrganizationMembersWithOptions(request: GetOrganizationMembersRequest, runtime: Util.RuntimeOptions): GetOrganizationMembersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetOrganizationMembers',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOrganizationMembers(request: GetOrganizationMembersRequest): GetOrganizationMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOrganizationMembersWithOptions(request, runtime);
}

model GetProjectInfoRequest {
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
}

model GetProjectInfoResponseBody = {
  requestId?: string(name='RequestId'),
  errorMsg?: string(name='ErrorMsg'),
  object?: {
    sortMethod?: string(name='SortMethod'),
    uniqueIdPrefix?: string(name='UniqueIdPrefix'),
    normalType?: string(name='NormalType'),
    modifierId?: string(name='ModifierId'),
    sourceType?: string(name='SourceType'),
    isTemplate?: boolean(name='IsTemplate'),
    description?: string(name='Description'),
    defaultRoleId?: string(name='DefaultRoleId'),
    rootCollectionId?: string(name='RootCollectionId'),
    isDeleted?: boolean(name='IsDeleted'),
    updated?: string(name='Updated'),
    isArchived?: boolean(name='IsArchived'),
    name?: string(name='Name'),
    endDate?: string(name='EndDate'),
    logo?: string(name='Logo'),
    startDate?: string(name='StartDate'),
    pinyin?: string(name='Pinyin'),
    creatorId?: string(name='CreatorId'),
    sourceId?: string(name='SourceId'),
    organizationId?: string(name='OrganizationId'),
    isSuspended?: boolean(name='IsSuspended'),
    defaultCollectionId?: string(name='DefaultCollectionId'),
    visibility?: string(name='Visibility'),
    py?: string(name='Py'),
    category?: string(name='Category'),
    nextTaskUniqueId?: int32(name='NextTaskUniqueId'),
    customfields?: string(name='Customfields'),
    created?: string(name='Created'),
    id?: string(name='Id'),
  }(name='Object'),
  errorCode?: string(name='ErrorCode'),
  successful?: boolean(name='Successful'),
}

model GetProjectInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetProjectInfoResponseBody(name='body'),
}

async function getProjectInfoWithOptions(request: GetProjectInfoRequest, runtime: Util.RuntimeOptions): GetProjectInfoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetProjectInfo',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getProjectInfo(request: GetProjectInfoRequest): GetProjectInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getProjectInfoWithOptions(request, runtime);
}

model GetProjectMembersRequest {
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
}

model GetProjectMembersResponseBody = {
  requestId?: string(name='RequestId'),
  errorMsg?: string(name='ErrorMsg'),
  object?: [ 
    {
      email?: string(name='Email'),
      avatarUrl?: string(name='AvatarUrl'),
      userId?: string(name='UserId'),
      memberId?: string(name='MemberId'),
      role?: int32(name='Role'),
      name?: string(name='Name'),
      phone?: string(name='Phone'),
    }
  ](name='Object'),
  errorCode?: string(name='ErrorCode'),
  successful?: boolean(name='Successful'),
}

model GetProjectMembersResponse = {
  headers: map[string]string(name='headers'),
  body: GetProjectMembersResponseBody(name='body'),
}

async function getProjectMembersWithOptions(request: GetProjectMembersRequest, runtime: Util.RuntimeOptions): GetProjectMembersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetProjectMembers',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getProjectMembers(request: GetProjectMembersRequest): GetProjectMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return getProjectMembersWithOptions(request, runtime);
}

model GetProjectSprintInfoRequest {
  orgId?: string(name='OrgId'),
  sprintId?: string(name='SprintId'),
}

model GetProjectSprintInfoResponseBody = {
  requestId?: string(name='RequestId'),
  errorMsg?: string(name='ErrorMsg'),
  object?: {
    status?: string(name='Status'),
    projectId?: string(name='ProjectId'),
    startDate?: string(name='StartDate'),
    creatorId?: string(name='CreatorId'),
    accomplished?: string(name='Accomplished'),
    isDeleted?: boolean(name='IsDeleted'),
    updated?: string(name='Updated'),
    dueDate?: string(name='DueDate'),
    name?: string(name='Name'),
    created?: string(name='Created'),
    planToDo?: {
      tasks?: int32(name='Tasks'),
      workTimes?: int32(name='WorkTimes'),
      storyPoints?: int32(name='StoryPoints'),
    }(name='PlanToDo'),
    id?: string(name='Id'),
  }(name='Object'),
  errorCode?: string(name='ErrorCode'),
  successful?: boolean(name='Successful'),
}

model GetProjectSprintInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetProjectSprintInfoResponseBody(name='body'),
}

async function getProjectSprintInfoWithOptions(request: GetProjectSprintInfoRequest, runtime: Util.RuntimeOptions): GetProjectSprintInfoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetProjectSprintInfo',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getProjectSprintInfo(request: GetProjectSprintInfoRequest): GetProjectSprintInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getProjectSprintInfoWithOptions(request, runtime);
}

model GetProjectTaskInfoRequest {
  orgId?: string(name='OrgId'),
  taskId?: string(name='TaskId'),
}

model GetProjectTaskInfoResponseBody = {
  requestId?: string(name='RequestId'),
  errorMsg?: string(name='ErrorMsg'),
  object?: {
    executorId?: string(name='ExecutorId'),
    projectId?: string(name='ProjectId'),
    storyPoint?: string(name='StoryPoint'),
    startDate?: string(name='StartDate'),
    isTopInProject?: boolean(name='IsTopInProject'),
    priority?: string(name='Priority'),
    creatorId?: string(name='CreatorId'),
    organizationId?: string(name='OrganizationId'),
    taskType?: string(name='TaskType'),
    tasklistId?: string(name='TasklistId'),
    visible?: string(name='Visible'),
    isDone?: boolean(name='IsDone'),
    isDeleted?: boolean(name='IsDeleted'),
    taskflowstatusId?: string(name='TaskflowstatusId'),
    note?: string(name='Note'),
    sprintId?: string(name='SprintId'),
    updated?: string(name='Updated'),
    involveMembers?: [ string ](name='InvolveMembers'),
    dueDate?: string(name='DueDate'),
    created?: string(name='Created'),
    content?: string(name='Content'),
    id?: string(name='Id'),
  }(name='Object'),
  errorCode?: string(name='ErrorCode'),
  successful?: boolean(name='Successful'),
}

model GetProjectTaskInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetProjectTaskInfoResponseBody(name='body'),
}

async function getProjectTaskInfoWithOptions(request: GetProjectTaskInfoRequest, runtime: Util.RuntimeOptions): GetProjectTaskInfoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetProjectTaskInfo',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getProjectTaskInfo(request: GetProjectTaskInfoRequest): GetProjectTaskInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getProjectTaskInfoWithOptions(request, runtime);
}

model GetUserByUidRequest {
  orgId?: string(name='OrgId'),
  userPk?: string(name='UserPk'),
}

model GetUserByUidResponseBody = {
  requestId?: string(name='RequestId'),
  errorMsg?: string(name='ErrorMsg'),
  object?: {
    aliyunPk?: string(name='AliyunPk'),
    email?: string(name='Email'),
    avatarUrl?: string(name='AvatarUrl'),
    name?: string(name='Name'),
    id?: string(name='Id'),
    phone?: string(name='Phone'),
  }(name='Object'),
  errorCode?: string(name='ErrorCode'),
  successful?: boolean(name='Successful'),
}

model GetUserByUidResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserByUidResponseBody(name='body'),
}

async function getUserByUidWithOptions(request: GetUserByUidRequest, runtime: Util.RuntimeOptions): GetUserByUidResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetUserByUid',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserByUid(request: GetUserByUidRequest): GetUserByUidResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserByUidWithOptions(request, runtime);
}

model InsertDevopsMemberRequest {
  userPk?: string(name='UserPk'),
  userName?: string(name='UserName'),
  phone?: string(name='Phone'),
  email?: string(name='Email'),
}

model InsertDevopsMemberResponseBody = {
  requestId?: string(name='RequestId'),
  object?: string(name='Object'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
}

model InsertDevopsMemberResponse = {
  headers: map[string]string(name='headers'),
  body: InsertDevopsMemberResponseBody(name='body'),
}

async function insertDevopsMemberWithOptions(request: InsertDevopsMemberRequest, runtime: Util.RuntimeOptions): InsertDevopsMemberResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'InsertDevopsMember',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function insertDevopsMember(request: InsertDevopsMemberRequest): InsertDevopsMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertDevopsMemberWithOptions(request, runtime);
}

model ListProjectSprintsRequest {
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
}

model ListProjectSprintsResponseBody = {
  requestId?: string(name='RequestId'),
  errorMsg?: string(name='ErrorMsg'),
  object?: [ 
    {
      status?: string(name='Status'),
      projectId?: string(name='ProjectId'),
      startDate?: string(name='StartDate'),
      creatorId?: string(name='CreatorId'),
      accomplished?: string(name='Accomplished'),
      isDeleted?: boolean(name='IsDeleted'),
      updated?: string(name='Updated'),
      dueDate?: string(name='DueDate'),
      name?: string(name='Name'),
      created?: string(name='Created'),
      planToDo?: {
        tasks?: int32(name='Tasks'),
        workTimes?: int32(name='WorkTimes'),
        storyPoints?: int32(name='StoryPoints'),
      }(name='PlanToDo'),
      id?: string(name='Id'),
    }
  ](name='Object'),
  errorCode?: string(name='ErrorCode'),
  successful?: boolean(name='Successful'),
}

model ListProjectSprintsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProjectSprintsResponseBody(name='body'),
}

async function listProjectSprintsWithOptions(request: ListProjectSprintsRequest, runtime: Util.RuntimeOptions): ListProjectSprintsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListProjectSprints',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProjectSprints(request: ListProjectSprintsRequest): ListProjectSprintsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectSprintsWithOptions(request, runtime);
}

model ListProjectTaskFlowRequest {
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
}

model ListProjectTaskFlowResponseBody = {
  requestId?: string(name='RequestId'),
  errorMsg?: string(name='ErrorMsg'),
  object?: [ 
    {
      type?: string(name='Type'),
      id?: string(name='Id'),
    }
  ](name='Object'),
  errorCode?: string(name='ErrorCode'),
  successful?: boolean(name='Successful'),
}

model ListProjectTaskFlowResponse = {
  headers: map[string]string(name='headers'),
  body: ListProjectTaskFlowResponseBody(name='body'),
}

async function listProjectTaskFlowWithOptions(request: ListProjectTaskFlowRequest, runtime: Util.RuntimeOptions): ListProjectTaskFlowResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListProjectTaskFlow',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProjectTaskFlow(request: ListProjectTaskFlowRequest): ListProjectTaskFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectTaskFlowWithOptions(request, runtime);
}

model ListProjectTaskFlowStatusRequest {
  orgId?: string(name='OrgId'),
  taskFlowId?: string(name='TaskFlowId'),
}

model ListProjectTaskFlowStatusResponseBody = {
  requestId?: string(name='RequestId'),
  errorMsg?: string(name='ErrorMsg'),
  object?: [ 
    {
      taskflowId?: string(name='TaskflowId'),
      kind?: string(name='Kind'),
      pos?: int32(name='Pos'),
      isDeleted?: boolean(name='IsDeleted'),
      updated?: string(name='Updated'),
      creatorId?: string(name='CreatorId'),
      name?: string(name='Name'),
      created?: string(name='Created'),
      rejectStatusIds?: string(name='RejectStatusIds'),
      id?: string(name='Id'),
    }
  ](name='Object'),
  errorCode?: string(name='ErrorCode'),
  successful?: boolean(name='Successful'),
}

model ListProjectTaskFlowStatusResponse = {
  headers: map[string]string(name='headers'),
  body: ListProjectTaskFlowStatusResponseBody(name='body'),
}

async function listProjectTaskFlowStatusWithOptions(request: ListProjectTaskFlowStatusRequest, runtime: Util.RuntimeOptions): ListProjectTaskFlowStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListProjectTaskFlowStatus',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProjectTaskFlowStatus(request: ListProjectTaskFlowStatusRequest): ListProjectTaskFlowStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectTaskFlowStatusWithOptions(request, runtime);
}

model ListProjectTasksRequest {
  orgId?: string(name='OrgId'),
  projectIds?: string(name='ProjectIds'),
}

model ListProjectTasksResponseBody = {
  requestId?: string(name='RequestId'),
  errorMsg?: string(name='ErrorMsg'),
  object?: [ 
    {
      taskgroupId?: string(name='TaskgroupId'),
      tasklistId?: string(name='TasklistId'),
      projectId?: string(name='ProjectId'),
      modifierId?: string(name='ModifierId'),
      updated?: string(name='Updated'),
      creatorId?: string(name='CreatorId'),
      created?: string(name='Created'),
      name?: string(name='Name'),
      id?: string(name='Id'),
    }
  ](name='Object'),
  errorCode?: string(name='ErrorCode'),
  successful?: boolean(name='Successful'),
}

model ListProjectTasksResponse = {
  headers: map[string]string(name='headers'),
  body: ListProjectTasksResponseBody(name='body'),
}

async function listProjectTasksWithOptions(request: ListProjectTasksRequest, runtime: Util.RuntimeOptions): ListProjectTasksResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListProjectTasks',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProjectTasks(request: ListProjectTasksRequest): ListProjectTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectTasksWithOptions(request, runtime);
}

model ListScenarioFieldConfigRequest {
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
}

model ListScenarioFieldConfigResponseBody = {
  requestId?: string(name='RequestId'),
  errorMsg?: string(name='ErrorMsg'),
  object?: [ 
    {
      type?: string(name='Type'),
      id?: string(name='Id'),
    }
  ](name='Object'),
  errorCode?: string(name='ErrorCode'),
  successful?: boolean(name='Successful'),
}

model ListScenarioFieldConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ListScenarioFieldConfigResponseBody(name='body'),
}

async function listScenarioFieldConfigWithOptions(request: ListScenarioFieldConfigRequest, runtime: Util.RuntimeOptions): ListScenarioFieldConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListScenarioFieldConfig',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listScenarioFieldConfig(request: ListScenarioFieldConfigRequest): ListScenarioFieldConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return listScenarioFieldConfigWithOptions(request, runtime);
}

model UpdateProjectRequest {
  orgId?: string(name='OrgId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  projectId?: string(name='ProjectId'),
}

model UpdateProjectResponseBody = {
  requestId?: string(name='RequestId'),
  object?: string(name='Object'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
}

model UpdateProjectResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateProjectResponseBody(name='body'),
}

async function updateProjectWithOptions(request: UpdateProjectRequest, runtime: Util.RuntimeOptions): UpdateProjectResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProject',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateProject(request: UpdateProjectRequest): UpdateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateProjectWithOptions(request, runtime);
}

model UpdateProjectSprintRequest {
  orgId?: string(name='OrgId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  projectId?: string(name='ProjectId'),
  executorId?: string(name='ExecutorId'),
  startDate?: string(name='StartDate'),
  dueDate?: string(name='DueDate'),
  sprintId?: string(name='SprintId'),
}

model UpdateProjectSprintResponseBody = {
  requestId?: string(name='RequestId'),
  errorMsg?: string(name='ErrorMsg'),
  object?: boolean(name='Object'),
  errorCode?: string(name='ErrorCode'),
  successful?: boolean(name='Successful'),
}

model UpdateProjectSprintResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateProjectSprintResponseBody(name='body'),
}

async function updateProjectSprintWithOptions(request: UpdateProjectSprintRequest, runtime: Util.RuntimeOptions): UpdateProjectSprintResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProjectSprint',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateProjectSprint(request: UpdateProjectSprintRequest): UpdateProjectSprintResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateProjectSprintWithOptions(request, runtime);
}

model UpdateProjectTaskRequest {
  orgId?: string(name='OrgId'),
  content?: string(name='Content'),
  projectId?: string(name='ProjectId'),
  executorId?: string(name='ExecutorId'),
  startDate?: string(name='StartDate'),
  dueDate?: string(name='DueDate'),
  scenarioFiieldConfigId?: string(name='ScenarioFiieldConfigId'),
  taskFlowStatusId?: string(name='TaskFlowStatusId'),
  note?: string(name='Note'),
  priority?: int32(name='Priority'),
  visible?: string(name='Visible'),
  parentTaskId?: string(name='ParentTaskId'),
  sprintId?: string(name='SprintId'),
  taskId?: string(name='TaskId'),
}

model UpdateProjectTaskResponseBody = {
  requestId?: string(name='RequestId'),
  errorMsg?: string(name='ErrorMsg'),
  object?: boolean(name='Object'),
  errorCode?: string(name='ErrorCode'),
  successful?: boolean(name='Successful'),
}

model UpdateProjectTaskResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateProjectTaskResponseBody(name='body'),
}

async function updateProjectTaskWithOptions(request: UpdateProjectTaskRequest, runtime: Util.RuntimeOptions): UpdateProjectTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProjectTask',
    version = '2020-02-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateProjectTask(request: UpdateProjectTaskRequest): UpdateProjectTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateProjectTaskWithOptions(request, runtime);
}

