/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('cr', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CancelRepoBuildResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function cancelRepoBuild(RepoNamespace: string, RepoName: string, BuildId: string): CancelRepoBuildResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelRepoBuildWithOptions(RepoNamespace, RepoName, BuildId, headers, runtime);
}

async function cancelRepoBuildWithOptions(RepoNamespace: string, RepoName: string, BuildId: string, headers: map[string]string, runtime: Util.RuntimeOptions): CancelRepoBuildResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CancelRepoBuild',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}/${OpenApiUtil.getEncodeParam(RepoName)}/build/${OpenApiUtil.getEncodeParam(BuildId)}/cancel`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model CreateNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createNamespace(): CreateNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createNamespaceWithOptions(headers, runtime);
}

async function createNamespaceWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): CreateNamespaceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CreateNamespace',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/namespace`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model CreateRepoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createRepo(): CreateRepoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRepoWithOptions(headers, runtime);
}

async function createRepoWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): CreateRepoResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CreateRepo',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model CreateRepoBuildRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createRepoBuildRule(RepoNamespace: string, RepoName: string): CreateRepoBuildRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRepoBuildRuleWithOptions(RepoNamespace, RepoName, headers, runtime);
}

async function createRepoBuildRuleWithOptions(RepoNamespace: string, RepoName: string, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRepoBuildRuleResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CreateRepoBuildRule',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}/${OpenApiUtil.getEncodeParam(RepoName)}/rules`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model CreateRepoWebhookResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createRepoWebhook(RepoNamespace: string, RepoName: string): CreateRepoWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRepoWebhookWithOptions(RepoNamespace, RepoName, headers, runtime);
}

async function createRepoWebhookWithOptions(RepoNamespace: string, RepoName: string, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRepoWebhookResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CreateRepoWebhook',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}/${OpenApiUtil.getEncodeParam(RepoName)}/webhooks`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model CreateUserInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createUserInfo(): CreateUserInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createUserInfoWithOptions(headers, runtime);
}

async function createUserInfoWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): CreateUserInfoResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CreateUserInfo',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/users`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteImage(RepoNamespace: string, RepoName: string, Tag: string): DeleteImageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteImageWithOptions(RepoNamespace, RepoName, Tag, headers, runtime);
}

async function deleteImageWithOptions(RepoNamespace: string, RepoName: string, Tag: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteImageResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteImage',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}/${OpenApiUtil.getEncodeParam(RepoName)}/tags/${OpenApiUtil.getEncodeParam(Tag)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteNamespace(Namespace: string): DeleteNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteNamespaceWithOptions(Namespace, headers, runtime);
}

async function deleteNamespaceWithOptions(Namespace: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteNamespaceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteNamespace',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/namespace/${OpenApiUtil.getEncodeParam(Namespace)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteRepoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteRepo(RepoNamespace: string, RepoName: string): DeleteRepoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRepoWithOptions(RepoNamespace, RepoName, headers, runtime);
}

async function deleteRepoWithOptions(RepoNamespace: string, RepoName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRepoResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteRepo',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}/${OpenApiUtil.getEncodeParam(RepoName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteRepoBuildRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteRepoBuildRule(RepoNamespace: string, RepoName: string, BuildRuleId: string): DeleteRepoBuildRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRepoBuildRuleWithOptions(RepoNamespace, RepoName, BuildRuleId, headers, runtime);
}

async function deleteRepoBuildRuleWithOptions(RepoNamespace: string, RepoName: string, BuildRuleId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRepoBuildRuleResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteRepoBuildRule',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}/${OpenApiUtil.getEncodeParam(RepoName)}/rules/${OpenApiUtil.getEncodeParam(BuildRuleId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteRepoWebhookResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteRepoWebhook(RepoNamespace: string, RepoName: string, WebhookId: string): DeleteRepoWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRepoWebhookWithOptions(RepoNamespace, RepoName, WebhookId, headers, runtime);
}

async function deleteRepoWebhookWithOptions(RepoNamespace: string, RepoName: string, WebhookId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRepoWebhookResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteRepoWebhook',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}/${OpenApiUtil.getEncodeParam(RepoName)}/webhooks/${OpenApiUtil.getEncodeParam(WebhookId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model GetAuthorizationTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function getAuthorizationToken(): GetAuthorizationTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAuthorizationTokenWithOptions(headers, runtime);
}

async function getAuthorizationTokenWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): GetAuthorizationTokenResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAuthorizationToken',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/tokens`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model GetImageLayerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function getImageLayer(RepoNamespace: string, RepoName: string, Tag: string): GetImageLayerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getImageLayerWithOptions(RepoNamespace, RepoName, Tag, headers, runtime);
}

async function getImageLayerWithOptions(RepoNamespace: string, RepoName: string, Tag: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetImageLayerResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetImageLayer',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}/${OpenApiUtil.getEncodeParam(RepoName)}/tags/${OpenApiUtil.getEncodeParam(Tag)}/layers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model GetImageManifestRequest {
  schemaVersion?: int32(name='SchemaVersion'),
}

model GetImageManifestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function getImageManifest(RepoNamespace: string, RepoName: string, Tag: string, request: GetImageManifestRequest): GetImageManifestResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getImageManifestWithOptions(RepoNamespace, RepoName, Tag, request, headers, runtime);
}

async function getImageManifestWithOptions(RepoNamespace: string, RepoName: string, Tag: string, request: GetImageManifestRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetImageManifestResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.schemaVersion)) {
    query['SchemaVersion'] = request.schemaVersion;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetImageManifest',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}/${OpenApiUtil.getEncodeParam(RepoName)}/tags/${OpenApiUtil.getEncodeParam(Tag)}/manifest`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model GetNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function getNamespace(Namespace: string): GetNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getNamespaceWithOptions(Namespace, headers, runtime);
}

async function getNamespaceWithOptions(Namespace: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetNamespaceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetNamespace',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/namespace/${OpenApiUtil.getEncodeParam(Namespace)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model GetNamespaceListRequest {
  authorize?: string(name='Authorize'),
  status?: string(name='Status'),
}

model GetNamespaceListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function getNamespaceList(request: GetNamespaceListRequest): GetNamespaceListResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getNamespaceListWithOptions(request, headers, runtime);
}

async function getNamespaceListWithOptions(request: GetNamespaceListRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetNamespaceListResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.authorize)) {
    query['Authorize'] = request.authorize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetNamespaceList',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/namespace`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model GetRegionListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function getRegionList(): GetRegionListResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRegionListWithOptions(headers, runtime);
}

async function getRegionListWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): GetRegionListResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetRegionList',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/regions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model GetRepoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function getRepo(RepoNamespace: string, RepoName: string): GetRepoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepoWithOptions(RepoNamespace, RepoName, headers, runtime);
}

async function getRepoWithOptions(RepoNamespace: string, RepoName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepoResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetRepo',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}/${OpenApiUtil.getEncodeParam(RepoName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model GetRepoBuildListRequest {
  page?: int32(name='Page'),
  pageSize?: int32(name='PageSize'),
}

model GetRepoBuildListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function getRepoBuildList(RepoNamespace: string, RepoName: string, request: GetRepoBuildListRequest): GetRepoBuildListResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepoBuildListWithOptions(RepoNamespace, RepoName, request, headers, runtime);
}

async function getRepoBuildListWithOptions(RepoNamespace: string, RepoName: string, request: GetRepoBuildListRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepoBuildListResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoBuildList',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}/${OpenApiUtil.getEncodeParam(RepoName)}/build`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model GetRepoBuildRuleListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function getRepoBuildRuleList(RepoNamespace: string, RepoName: string): GetRepoBuildRuleListResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepoBuildRuleListWithOptions(RepoNamespace, RepoName, headers, runtime);
}

async function getRepoBuildRuleListWithOptions(RepoNamespace: string, RepoName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepoBuildRuleListResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetRepoBuildRuleList',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}/${OpenApiUtil.getEncodeParam(RepoName)}/rules`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model GetRepoBuildStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function getRepoBuildStatus(RepoNamespace: string, RepoName: string, BuildId: string): GetRepoBuildStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepoBuildStatusWithOptions(RepoNamespace, RepoName, BuildId, headers, runtime);
}

async function getRepoBuildStatusWithOptions(RepoNamespace: string, RepoName: string, BuildId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepoBuildStatusResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetRepoBuildStatus',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}/${OpenApiUtil.getEncodeParam(RepoName)}/build/${OpenApiUtil.getEncodeParam(BuildId)}/status`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model GetRepoListRequest {
  page?: int32(name='Page'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
}

model GetRepoListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function getRepoList(request: GetRepoListRequest): GetRepoListResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepoListWithOptions(request, headers, runtime);
}

async function getRepoListWithOptions(request: GetRepoListRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepoListResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoList',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model GetRepoListByNamespaceRequest {
  page?: int32(name='Page'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
}

model GetRepoListByNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function getRepoListByNamespace(RepoNamespace: string, request: GetRepoListByNamespaceRequest): GetRepoListByNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepoListByNamespaceWithOptions(RepoNamespace, request, headers, runtime);
}

async function getRepoListByNamespaceWithOptions(RepoNamespace: string, request: GetRepoListByNamespaceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepoListByNamespaceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoListByNamespace',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model GetRepoTagResponseBody = {
  digest?: string(name='digest'),
  imageCreate?: long(name='imageCreate'),
  imageId?: string(name='imageId'),
  imageSize?: long(name='imageSize'),
  imageUpdate?: long(name='imageUpdate'),
  requestId?: string(name='requestId'),
  status?: string(name='status'),
  tag?: string(name='tag'),
}

model GetRepoTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepoTagResponseBody(name='body'),
}

async function getRepoTag(RepoNamespace: string, RepoName: string, Tag: string): GetRepoTagResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepoTagWithOptions(RepoNamespace, RepoName, Tag, headers, runtime);
}

async function getRepoTagWithOptions(RepoNamespace: string, RepoName: string, Tag: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepoTagResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetRepoTag',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}/${OpenApiUtil.getEncodeParam(RepoName)}/tags/${OpenApiUtil.getEncodeParam(Tag)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetRepoTagScanListRequest {
  page?: int32(name='Page'),
  pageSize?: int32(name='PageSize'),
  severity?: string(name='Severity'),
}

model GetRepoTagScanListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function getRepoTagScanList(RepoNamespace: string, RepoName: string, Tag: string, request: GetRepoTagScanListRequest): GetRepoTagScanListResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepoTagScanListWithOptions(RepoNamespace, RepoName, Tag, request, headers, runtime);
}

async function getRepoTagScanListWithOptions(RepoNamespace: string, RepoName: string, Tag: string, request: GetRepoTagScanListRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepoTagScanListResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.severity)) {
    query['Severity'] = request.severity;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoTagScanList',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}/${OpenApiUtil.getEncodeParam(RepoName)}/tags/${OpenApiUtil.getEncodeParam(Tag)}/scanResult`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model GetRepoTagScanStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function getRepoTagScanStatus(RepoNamespace: string, RepoName: string, Tag: string): GetRepoTagScanStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepoTagScanStatusWithOptions(RepoNamespace, RepoName, Tag, headers, runtime);
}

async function getRepoTagScanStatusWithOptions(RepoNamespace: string, RepoName: string, Tag: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepoTagScanStatusResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetRepoTagScanStatus',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}/${OpenApiUtil.getEncodeParam(RepoName)}/tags/${OpenApiUtil.getEncodeParam(Tag)}/scanStatus`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model GetRepoTagScanSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function getRepoTagScanSummary(RepoNamespace: string, RepoName: string, Tag: string): GetRepoTagScanSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepoTagScanSummaryWithOptions(RepoNamespace, RepoName, Tag, headers, runtime);
}

async function getRepoTagScanSummaryWithOptions(RepoNamespace: string, RepoName: string, Tag: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepoTagScanSummaryResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetRepoTagScanSummary',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}/${OpenApiUtil.getEncodeParam(RepoName)}/tags/${OpenApiUtil.getEncodeParam(Tag)}/scanCount`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model GetRepoTagsRequest {
  page?: int32(name='Page'),
  pageSize?: int32(name='PageSize'),
}

model GetRepoTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function getRepoTags(RepoNamespace: string, RepoName: string, request: GetRepoTagsRequest): GetRepoTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepoTagsWithOptions(RepoNamespace, RepoName, request, headers, runtime);
}

async function getRepoTagsWithOptions(RepoNamespace: string, RepoName: string, request: GetRepoTagsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepoTagsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoTags',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}/${OpenApiUtil.getEncodeParam(RepoName)}/tags`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model GetRepoWebhookResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function getRepoWebhook(RepoNamespace: string, RepoName: string): GetRepoWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepoWebhookWithOptions(RepoNamespace, RepoName, headers, runtime);
}

async function getRepoWebhookWithOptions(RepoNamespace: string, RepoName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepoWebhookResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetRepoWebhook',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}/${OpenApiUtil.getEncodeParam(RepoName)}/webhooks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model StartImageScanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function startImageScan(RepoNamespace: string, RepoName: string, Tag: string): StartImageScanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startImageScanWithOptions(RepoNamespace, RepoName, Tag, headers, runtime);
}

async function startImageScanWithOptions(RepoNamespace: string, RepoName: string, Tag: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartImageScanResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartImageScan',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}/${OpenApiUtil.getEncodeParam(RepoName)}/tags/${OpenApiUtil.getEncodeParam(Tag)}/scan`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model StartRepoBuildByRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function startRepoBuildByRule(RepoNamespace: string, RepoName: string, BuildRuleId: string): StartRepoBuildByRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startRepoBuildByRuleWithOptions(RepoNamespace, RepoName, BuildRuleId, headers, runtime);
}

async function startRepoBuildByRuleWithOptions(RepoNamespace: string, RepoName: string, BuildRuleId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartRepoBuildByRuleResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartRepoBuildByRule',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}/${OpenApiUtil.getEncodeParam(RepoName)}/rules/${OpenApiUtil.getEncodeParam(BuildRuleId)}/build`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model UpdateNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateNamespace(Namespace: string): UpdateNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateNamespaceWithOptions(Namespace, headers, runtime);
}

async function updateNamespaceWithOptions(Namespace: string, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateNamespaceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'UpdateNamespace',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/namespace/${OpenApiUtil.getEncodeParam(Namespace)}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model UpdateRepoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateRepo(RepoNamespace: string, RepoName: string): UpdateRepoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRepoWithOptions(RepoNamespace, RepoName, headers, runtime);
}

async function updateRepoWithOptions(RepoNamespace: string, RepoName: string, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRepoResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'UpdateRepo',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}/${OpenApiUtil.getEncodeParam(RepoName)}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model UpdateRepoBuildRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateRepoBuildRule(RepoNamespace: string, RepoName: string, BuildRuleId: string): UpdateRepoBuildRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRepoBuildRuleWithOptions(RepoNamespace, RepoName, BuildRuleId, headers, runtime);
}

async function updateRepoBuildRuleWithOptions(RepoNamespace: string, RepoName: string, BuildRuleId: string, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRepoBuildRuleResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'UpdateRepoBuildRule',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}/${OpenApiUtil.getEncodeParam(RepoName)}/rules/${OpenApiUtil.getEncodeParam(BuildRuleId)}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model UpdateRepoWebhookResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateRepoWebhook(RepoNamespace: string, RepoName: string, WebhookId: string): UpdateRepoWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRepoWebhookWithOptions(RepoNamespace, RepoName, WebhookId, headers, runtime);
}

async function updateRepoWebhookWithOptions(RepoNamespace: string, RepoName: string, WebhookId: string, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRepoWebhookResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'UpdateRepoWebhook',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/repos/${OpenApiUtil.getEncodeParam(RepoNamespace)}/${OpenApiUtil.getEncodeParam(RepoName)}/webhooks/${OpenApiUtil.getEncodeParam(WebhookId)}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model UpdateUserInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateUserInfo(): UpdateUserInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateUserInfoWithOptions(headers, runtime);
}

async function updateUserInfoWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): UpdateUserInfoResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'UpdateUserInfo',
    version = '2016-06-07',
    protocol = 'HTTPS',
    pathname = `/users`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

