/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('energyexpertalgorithm', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model QueryCostCurveContrastRequest {
  deviceSnList?: [ string ](name='deviceSnList'),
  dsTime?: string(name='dsTime'),
  dsType?: string(name='dsType'),
  timeZone?: string(name='timeZone'),
}

model QueryCostCurveContrastResponseBody = {
  code?: string(name='code'),
  data?: [ 
    {
      deviceSn?: string(name='deviceSn'),
      recordList?: [ 
        {
          dataTime?: string(name='dataTime'),
          ds?: string(name='ds'),
          elePrice?: double(name='elePrice'),
          realCost?: double(name='realCost'),
          realSoc?: double(name='realSoc'),
          selfUseBuy?: double(name='selfUseBuy'),
          selfUseCost?: double(name='selfUseCost'),
          selfUseSoc?: double(name='selfUseSoc'),
          strategyBuy?: double(name='strategyBuy'),
          strategyBuyCost?: double(name='strategyBuyCost'),
          strategySoc?: double(name='strategySoc'),
        }
      ](name='recordList'),
    }
  ](name='data'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model QueryCostCurveContrastResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryCostCurveContrastResponseBody(name='body'),
}

async function queryCostCurveContrastWithOptions(request: QueryCostCurveContrastRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryCostCurveContrastResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceSnList)) {
    body['deviceSnList'] = request.deviceSnList;
  }
  if (!Util.isUnset(request.dsTime)) {
    body['dsTime'] = request.dsTime;
  }
  if (!Util.isUnset(request.dsType)) {
    body['dsType'] = request.dsType;
  }
  if (!Util.isUnset(request.timeZone)) {
    body['timeZone'] = request.timeZone;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryCostCurveContrast',
    version = '2023-06-15',
    protocol = 'HTTPS',
    pathname = `/api/pves/v1/queryCostCurveContrast`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryCostCurveContrast(request: QueryCostCurveContrastRequest): QueryCostCurveContrastResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryCostCurveContrastWithOptions(request, headers, runtime);
}

model QueryEnergyStorageStrategyRequest {
  deviceSnList?: [ string ](name='deviceSnList'),
  dsTime?: string(name='dsTime'),
  dsType?: string(name='dsType'),
  timeZone?: string(name='timeZone'),
}

model QueryEnergyStorageStrategyResponseBody = {
  code?: string(name='code'),
  data?: [ 
    {
      deviceSn?: string(name='deviceSn'),
      recordList?: [ 
        {
          batteryDirection?: int32(name='batteryDirection'),
          batteryPower?: double(name='batteryPower'),
          dataTime?: string(name='dataTime'),
          ds?: string(name='ds'),
          workMode?: int32(name='workMode'),
        }
      ](name='recordList'),
    }
  ](name='data'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model QueryEnergyStorageStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryEnergyStorageStrategyResponseBody(name='body'),
}

async function queryEnergyStorageStrategyWithOptions(request: QueryEnergyStorageStrategyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryEnergyStorageStrategyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceSnList)) {
    body['deviceSnList'] = request.deviceSnList;
  }
  if (!Util.isUnset(request.dsTime)) {
    body['dsTime'] = request.dsTime;
  }
  if (!Util.isUnset(request.dsType)) {
    body['dsType'] = request.dsType;
  }
  if (!Util.isUnset(request.timeZone)) {
    body['timeZone'] = request.timeZone;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryEnergyStorageStrategy',
    version = '2023-06-15',
    protocol = 'HTTPS',
    pathname = `/api/pves/v1/queryEnergyStorageStrategy`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryEnergyStorageStrategy(request: QueryEnergyStorageStrategyRequest): QueryEnergyStorageStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryEnergyStorageStrategyWithOptions(request, headers, runtime);
}

model QueryLongTermLoadForecastDataRequest {
  deviceSnList?: [ string ](name='deviceSnList'),
  dsTime?: string(name='dsTime'),
  dsType?: string(name='dsType'),
  timeZone?: string(name='timeZone'),
}

model QueryLongTermLoadForecastDataResponseBody = {
  code?: string(name='code'),
  data?: [ 
    {
      deviceSn?: string(name='deviceSn'),
      recordList?: [ 
        {
          dataTime?: string(name='dataTime'),
          ds?: string(name='ds'),
          loadEnergy?: string(name='loadEnergy'),
        }
      ](name='recordList'),
    }
  ](name='data'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model QueryLongTermLoadForecastDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryLongTermLoadForecastDataResponseBody(name='body'),
}

async function queryLongTermLoadForecastDataWithOptions(request: QueryLongTermLoadForecastDataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryLongTermLoadForecastDataResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceSnList)) {
    body['deviceSnList'] = request.deviceSnList;
  }
  if (!Util.isUnset(request.dsTime)) {
    body['dsTime'] = request.dsTime;
  }
  if (!Util.isUnset(request.dsType)) {
    body['dsType'] = request.dsType;
  }
  if (!Util.isUnset(request.timeZone)) {
    body['timeZone'] = request.timeZone;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryLongTermLoadForecastData',
    version = '2023-06-15',
    protocol = 'HTTPS',
    pathname = `/api/pves/v1/queryLongTermLoadForecastData`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryLongTermLoadForecastData(request: QueryLongTermLoadForecastDataRequest): QueryLongTermLoadForecastDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryLongTermLoadForecastDataWithOptions(request, headers, runtime);
}

model QueryLongTermPvForecastDataRequest {
  deviceSnList?: [ string ](name='deviceSnList'),
  dsTime?: string(name='dsTime'),
  dsType?: string(name='dsType'),
  timeZone?: string(name='timeZone'),
}

model QueryLongTermPvForecastDataResponseBody = {
  code?: string(name='code'),
  data?: [ 
    {
      deviceSn?: string(name='deviceSn'),
      recordList?: [ 
        {
          dataTime?: string(name='dataTime'),
          ds?: string(name='ds'),
          pvEnergy?: double(name='pvEnergy'),
        }
      ](name='recordList'),
    }
  ](name='data'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model QueryLongTermPvForecastDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryLongTermPvForecastDataResponseBody(name='body'),
}

async function queryLongTermPvForecastDataWithOptions(request: QueryLongTermPvForecastDataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryLongTermPvForecastDataResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceSnList)) {
    body['deviceSnList'] = request.deviceSnList;
  }
  if (!Util.isUnset(request.dsTime)) {
    body['dsTime'] = request.dsTime;
  }
  if (!Util.isUnset(request.dsType)) {
    body['dsType'] = request.dsType;
  }
  if (!Util.isUnset(request.timeZone)) {
    body['timeZone'] = request.timeZone;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryLongTermPvForecastData',
    version = '2023-06-15',
    protocol = 'HTTPS',
    pathname = `/api/pves/v1/queryLongTermPvForecastData`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryLongTermPvForecastData(request: QueryLongTermPvForecastDataRequest): QueryLongTermPvForecastDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryLongTermPvForecastDataWithOptions(request, headers, runtime);
}

model QueryShortTermLoadForecastDataRequest {
  deviceSnList?: [ string ](name='deviceSnList'),
  dsTime?: string(name='dsTime'),
  dsType?: string(name='dsType'),
  timeZone?: string(name='timeZone'),
}

model QueryShortTermLoadForecastDataResponseBody = {
  code?: string(name='code'),
  data?: [ 
    {
      deviceSn?: string(name='deviceSn'),
      recordList?: [ 
        {
          dataTime?: string(name='dataTime'),
          ds?: string(name='ds'),
          loadPower?: double(name='loadPower'),
        }
      ](name='recordList'),
    }
  ](name='data'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model QueryShortTermLoadForecastDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryShortTermLoadForecastDataResponseBody(name='body'),
}

async function queryShortTermLoadForecastDataWithOptions(request: QueryShortTermLoadForecastDataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryShortTermLoadForecastDataResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceSnList)) {
    body['deviceSnList'] = request.deviceSnList;
  }
  if (!Util.isUnset(request.dsTime)) {
    body['dsTime'] = request.dsTime;
  }
  if (!Util.isUnset(request.dsType)) {
    body['dsType'] = request.dsType;
  }
  if (!Util.isUnset(request.timeZone)) {
    body['timeZone'] = request.timeZone;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryShortTermLoadForecastData',
    version = '2023-06-15',
    protocol = 'HTTPS',
    pathname = `/api/pves/v1/queryShortTermLoadForecastData`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryShortTermLoadForecastData(request: QueryShortTermLoadForecastDataRequest): QueryShortTermLoadForecastDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryShortTermLoadForecastDataWithOptions(request, headers, runtime);
}

model QueryShortTermPvForecastDataRequest {
  deviceSnList?: [ string ](name='deviceSnList'),
  dsTime?: string(name='dsTime'),
  dsType?: string(name='dsType'),
  timeZone?: string(name='timeZone'),
}

model QueryShortTermPvForecastDataResponseBody = {
  code?: string(name='code'),
  data?: [ 
    {
      deviceSn?: string(name='deviceSn'),
      recordList?: [ 
        {
          dataTime?: string(name='dataTime'),
          ds?: string(name='ds'),
          pvPower?: double(name='pvPower'),
        }
      ](name='recordList'),
    }
  ](name='data'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model QueryShortTermPvForecastDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryShortTermPvForecastDataResponseBody(name='body'),
}

async function queryShortTermPvForecastDataWithOptions(request: QueryShortTermPvForecastDataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryShortTermPvForecastDataResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceSnList)) {
    body['deviceSnList'] = request.deviceSnList;
  }
  if (!Util.isUnset(request.dsTime)) {
    body['dsTime'] = request.dsTime;
  }
  if (!Util.isUnset(request.dsType)) {
    body['dsType'] = request.dsType;
  }
  if (!Util.isUnset(request.timeZone)) {
    body['timeZone'] = request.timeZone;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryShortTermPvForecastData',
    version = '2023-06-15',
    protocol = 'HTTPS',
    pathname = `/api/pves/v1/queryShortTermPvForecastData`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryShortTermPvForecastData(request: QueryShortTermPvForecastDataRequest): QueryShortTermPvForecastDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryShortTermPvForecastDataWithOptions(request, headers, runtime);
}

model QueryUltraShortTermLoadForecastDataRequest {
  deviceSnList?: [ string ](name='deviceSnList'),
  dsTime?: string(name='dsTime'),
  dsType?: string(name='dsType'),
  timeZone?: string(name='timeZone'),
}

model QueryUltraShortTermLoadForecastDataResponseBody = {
  code?: string(name='code'),
  data?: [ 
    {
      deviceSn?: string(name='deviceSn'),
      recordList?: [ 
        {
          dataTime?: string(name='dataTime'),
          ds?: string(name='ds'),
          loadPower?: double(name='loadPower'),
        }
      ](name='recordList'),
    }
  ](name='data'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model QueryUltraShortTermLoadForecastDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryUltraShortTermLoadForecastDataResponseBody(name='body'),
}

async function queryUltraShortTermLoadForecastDataWithOptions(request: QueryUltraShortTermLoadForecastDataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryUltraShortTermLoadForecastDataResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceSnList)) {
    body['deviceSnList'] = request.deviceSnList;
  }
  if (!Util.isUnset(request.dsTime)) {
    body['dsTime'] = request.dsTime;
  }
  if (!Util.isUnset(request.dsType)) {
    body['dsType'] = request.dsType;
  }
  if (!Util.isUnset(request.timeZone)) {
    body['timeZone'] = request.timeZone;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryUltraShortTermLoadForecastData',
    version = '2023-06-15',
    protocol = 'HTTPS',
    pathname = `/api/pves/v1/queryUltraShortTermLoadForecastData`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryUltraShortTermLoadForecastData(request: QueryUltraShortTermLoadForecastDataRequest): QueryUltraShortTermLoadForecastDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryUltraShortTermLoadForecastDataWithOptions(request, headers, runtime);
}

model QueryUltraShortTermPvForecastDataRequest {
  deviceSnList?: [ string ](name='deviceSnList'),
  dsTime?: string(name='dsTime'),
  dsType?: string(name='dsType'),
  timeZone?: string(name='timeZone'),
}

model QueryUltraShortTermPvForecastDataResponseBody = {
  code?: string(name='code'),
  data?: [ 
    {
      deviceSn?: string(name='deviceSn'),
      recordList?: [ 
        {
          dataTime?: string(name='dataTime'),
          ds?: string(name='ds'),
          pvPower?: double(name='pvPower'),
        }
      ](name='recordList'),
    }
  ](name='data'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model QueryUltraShortTermPvForecastDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryUltraShortTermPvForecastDataResponseBody(name='body'),
}

async function queryUltraShortTermPvForecastDataWithOptions(request: QueryUltraShortTermPvForecastDataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryUltraShortTermPvForecastDataResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceSnList)) {
    body['deviceSnList'] = request.deviceSnList;
  }
  if (!Util.isUnset(request.dsTime)) {
    body['dsTime'] = request.dsTime;
  }
  if (!Util.isUnset(request.dsType)) {
    body['dsType'] = request.dsType;
  }
  if (!Util.isUnset(request.timeZone)) {
    body['timeZone'] = request.timeZone;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryUltraShortTermPvForecastData',
    version = '2023-06-15',
    protocol = 'HTTPS',
    pathname = `/api/pves/v1/queryUltraShortTermPvForecastData`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryUltraShortTermPvForecastData(request: QueryUltraShortTermPvForecastDataRequest): QueryUltraShortTermPvForecastDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryUltraShortTermPvForecastDataWithOptions(request, headers, runtime);
}

