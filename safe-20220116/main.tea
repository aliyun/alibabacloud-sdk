/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('safe', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CreateAlarmEventRequest {
  alarmId?: string(name='AlarmId'),
  alarmTimestamp?: long(name='AlarmTimestamp'),
  appKey?: string(name='AppKey'),
  appSecret?: string(name='AppSecret'),
  attach?: string(name='Attach'),
  dynamicAlarmId?: string(name='DynamicAlarmId'),
  impact?: string(name='Impact'),
  link?: string(name='Link'),
  message?: string(name='Message'),
  region?: string(name='Region'),
  sourceKey?: string(name='SourceKey'),
  sourceSystem?: string(name='SourceSystem'),
  strategy?: string(name='Strategy'),
  title?: string(name='Title'),
  uid?: string(name='Uid'),
}

model CreateAlarmEventResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateAlarmEventResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAlarmEventResponseBody(name='body'),
}

async function createAlarmEventWithOptions(request: CreateAlarmEventRequest, runtime: Util.RuntimeOptions): CreateAlarmEventResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.alarmId)) {
    body['AlarmId'] = request.alarmId;
  }
  if (!Util.isUnset(request.alarmTimestamp)) {
    body['AlarmTimestamp'] = request.alarmTimestamp;
  }
  if (!Util.isUnset(request.appKey)) {
    body['AppKey'] = request.appKey;
  }
  if (!Util.isUnset(request.appSecret)) {
    body['AppSecret'] = request.appSecret;
  }
  if (!Util.isUnset(request.attach)) {
    body['Attach'] = request.attach;
  }
  if (!Util.isUnset(request.dynamicAlarmId)) {
    body['DynamicAlarmId'] = request.dynamicAlarmId;
  }
  if (!Util.isUnset(request.impact)) {
    body['Impact'] = request.impact;
  }
  if (!Util.isUnset(request.link)) {
    body['Link'] = request.link;
  }
  if (!Util.isUnset(request.message)) {
    body['Message'] = request.message;
  }
  if (!Util.isUnset(request.region)) {
    body['Region'] = request.region;
  }
  if (!Util.isUnset(request.sourceKey)) {
    body['SourceKey'] = request.sourceKey;
  }
  if (!Util.isUnset(request.sourceSystem)) {
    body['SourceSystem'] = request.sourceSystem;
  }
  if (!Util.isUnset(request.strategy)) {
    body['Strategy'] = request.strategy;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  if (!Util.isUnset(request.uid)) {
    body['Uid'] = request.uid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAlarmEvent',
    version = '2022-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAlarmEvent(request: CreateAlarmEventRequest): CreateAlarmEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAlarmEventWithOptions(request, runtime);
}

model GetFaultDetailRequest {
  appKey?: string(name='AppKey'),
  appSecret?: string(name='AppSecret'),
  vid?: string(name='Vid'),
}

model GetFaultDetailResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetFaultDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFaultDetailResponseBody(name='body'),
}

async function getFaultDetailWithOptions(request: GetFaultDetailRequest, runtime: Util.RuntimeOptions): GetFaultDetailResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFaultDetail',
    version = '2022-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getFaultDetail(request: GetFaultDetailRequest): GetFaultDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFaultDetailWithOptions(request, runtime);
}

model ReportInfluenceRequest {
  appKey?: string(name='AppKey'),
  appSecret?: string(name='AppSecret'),
  area?: string(name='Area'),
  channelCode?: string(name='ChannelCode'),
  cluster?: string(name='Cluster'),
  createId?: string(name='CreateId'),
  customerImpactDesc?: string(name='CustomerImpactDesc'),
  faultVid?: string(name='FaultVid'),
  issueDesc?: string(name='IssueDesc'),
  productLineId?: long(name='ProductLineId'),
  regions?: string(name='Regions'),
  room?: string(name='Room'),
  time?: long(name='Time'),
  totalDesc?: string(name='TotalDesc'),
}

model ReportInfluenceResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ReportInfluenceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReportInfluenceResponseBody(name='body'),
}

async function reportInfluenceWithOptions(request: ReportInfluenceRequest, runtime: Util.RuntimeOptions): ReportInfluenceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appKey)) {
    body['AppKey'] = request.appKey;
  }
  if (!Util.isUnset(request.appSecret)) {
    body['AppSecret'] = request.appSecret;
  }
  if (!Util.isUnset(request.area)) {
    body['Area'] = request.area;
  }
  if (!Util.isUnset(request.channelCode)) {
    body['ChannelCode'] = request.channelCode;
  }
  if (!Util.isUnset(request.cluster)) {
    body['Cluster'] = request.cluster;
  }
  if (!Util.isUnset(request.createId)) {
    body['CreateId'] = request.createId;
  }
  if (!Util.isUnset(request.customerImpactDesc)) {
    body['CustomerImpactDesc'] = request.customerImpactDesc;
  }
  if (!Util.isUnset(request.faultVid)) {
    body['FaultVid'] = request.faultVid;
  }
  if (!Util.isUnset(request.issueDesc)) {
    body['IssueDesc'] = request.issueDesc;
  }
  if (!Util.isUnset(request.productLineId)) {
    body['ProductLineId'] = request.productLineId;
  }
  if (!Util.isUnset(request.regions)) {
    body['Regions'] = request.regions;
  }
  if (!Util.isUnset(request.room)) {
    body['Room'] = request.room;
  }
  if (!Util.isUnset(request.time)) {
    body['Time'] = request.time;
  }
  if (!Util.isUnset(request.totalDesc)) {
    body['TotalDesc'] = request.totalDesc;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReportInfluence',
    version = '2022-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reportInfluence(request: ReportInfluenceRequest): ReportInfluenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportInfluenceWithOptions(request, runtime);
}

model ReportReasonDetailRequest {
  appKey?: string(name='AppKey'),
  appSecret?: string(name='AppSecret'),
  channelCode?: string(name='ChannelCode'),
  createId?: string(name='CreateId'),
  detailUrl?: string(name='DetailUrl'),
  faultVid?: string(name='FaultVid'),
  reason?: string(name='Reason'),
}

model ReportReasonDetailResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ReportReasonDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReportReasonDetailResponseBody(name='body'),
}

async function reportReasonDetailWithOptions(request: ReportReasonDetailRequest, runtime: Util.RuntimeOptions): ReportReasonDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appKey)) {
    body['AppKey'] = request.appKey;
  }
  if (!Util.isUnset(request.appSecret)) {
    body['AppSecret'] = request.appSecret;
  }
  if (!Util.isUnset(request.channelCode)) {
    body['ChannelCode'] = request.channelCode;
  }
  if (!Util.isUnset(request.createId)) {
    body['CreateId'] = request.createId;
  }
  if (!Util.isUnset(request.detailUrl)) {
    body['DetailUrl'] = request.detailUrl;
  }
  if (!Util.isUnset(request.faultVid)) {
    body['FaultVid'] = request.faultVid;
  }
  if (!Util.isUnset(request.reason)) {
    body['Reason'] = request.reason;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReportReasonDetail',
    version = '2022-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reportReasonDetail(request: ReportReasonDetailRequest): ReportReasonDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportReasonDetailWithOptions(request, runtime);
}

model ReportRecoverActionRequest {
  actionType?: int32(name='ActionType'),
  appKey?: string(name='AppKey'),
  appSecret?: string(name='AppSecret'),
  channelCode?: string(name='ChannelCode'),
  createId?: string(name='CreateId'),
  currentDesc?: string(name='CurrentDesc'),
  currentProgress?: int32(name='CurrentProgress'),
  expectedRepairedTime?: long(name='ExpectedRepairedTime'),
  faultVid?: string(name='FaultVid'),
  isRecovery?: int32(name='IsRecovery'),
  productLineId?: long(name='ProductLineId'),
  recoveryDuration?: long(name='RecoveryDuration'),
  recoveryTime?: long(name='RecoveryTime'),
}

model ReportRecoverActionResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ReportRecoverActionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReportRecoverActionResponseBody(name='body'),
}

async function reportRecoverActionWithOptions(request: ReportRecoverActionRequest, runtime: Util.RuntimeOptions): ReportRecoverActionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.actionType)) {
    body['ActionType'] = request.actionType;
  }
  if (!Util.isUnset(request.appKey)) {
    body['AppKey'] = request.appKey;
  }
  if (!Util.isUnset(request.appSecret)) {
    body['AppSecret'] = request.appSecret;
  }
  if (!Util.isUnset(request.channelCode)) {
    body['ChannelCode'] = request.channelCode;
  }
  if (!Util.isUnset(request.createId)) {
    body['CreateId'] = request.createId;
  }
  if (!Util.isUnset(request.currentDesc)) {
    body['CurrentDesc'] = request.currentDesc;
  }
  if (!Util.isUnset(request.currentProgress)) {
    body['CurrentProgress'] = request.currentProgress;
  }
  if (!Util.isUnset(request.expectedRepairedTime)) {
    body['ExpectedRepairedTime'] = request.expectedRepairedTime;
  }
  if (!Util.isUnset(request.faultVid)) {
    body['FaultVid'] = request.faultVid;
  }
  if (!Util.isUnset(request.isRecovery)) {
    body['IsRecovery'] = request.isRecovery;
  }
  if (!Util.isUnset(request.productLineId)) {
    body['ProductLineId'] = request.productLineId;
  }
  if (!Util.isUnset(request.recoveryDuration)) {
    body['RecoveryDuration'] = request.recoveryDuration;
  }
  if (!Util.isUnset(request.recoveryTime)) {
    body['RecoveryTime'] = request.recoveryTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReportRecoverAction',
    version = '2022-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reportRecoverAction(request: ReportRecoverActionRequest): ReportRecoverActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportRecoverActionWithOptions(request, runtime);
}

