/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('devops', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddRepositoryMemberRequest {
  accessToken?: string(name='AccessToken'),
  accessLevel?: int32(name='accessLevel'),
  aliyunPks?: string(name='aliyunPks'),
  organizationId?: string(name='organizationId'),
}

model AddRepositoryMemberResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      accessLevel?: int32(name='AccessLevel'),
      avatarUrl?: string(name='AvatarUrl'),
      email?: string(name='Email'),
      externUserId?: string(name='ExternUserId'),
      id?: long(name='Id'),
      state?: string(name='State'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model AddRepositoryMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddRepositoryMemberResponseBody(name='body'),
}

async function addRepositoryMember(repositoryId: string, request: AddRepositoryMemberRequest): AddRepositoryMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addRepositoryMemberWithOptions(repositoryId, request, headers, runtime);
}

async function addRepositoryMemberWithOptions(repositoryId: string, request: AddRepositoryMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddRepositoryMemberResponse {
  Util.validateModel(request);
  repositoryId = OpenApiUtil.getEncodeParam(repositoryId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['organizationId'] = request.organizationId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.accessLevel)) {
    body['accessLevel'] = request.accessLevel;
  }
  if (!Util.isUnset(request.aliyunPks)) {
    body['aliyunPks'] = request.aliyunPks;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddRepositoryMember',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/repository/${repositoryId}/members`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AddWebhookRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  description?: string(name='description'),
  enableSslVerification?: boolean(name='enableSslVerification'),
  mergeRequestsEvents?: boolean(name='mergeRequestsEvents'),
  noteEvents?: boolean(name='noteEvents'),
  pushEvents?: boolean(name='pushEvents'),
  secretToken?: string(name='secretToken'),
  tagPushEvents?: boolean(name='tagPushEvents'),
  url?: string(name='url'),
}

model AddWebhookResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  result?: {
    createdAt?: string(name='createdAt'),
    description?: string(name='description'),
    enableSslVerification?: boolean(name='enableSslVerification'),
    id?: long(name='id'),
    lastTestResult?: string(name='lastTestResult'),
    mergeRequestsEvents?: boolean(name='mergeRequestsEvents'),
    noteEvents?: boolean(name='noteEvents'),
    pushEvents?: boolean(name='pushEvents'),
    repositoryId?: long(name='repositoryId'),
    secretToken?: string(name='secretToken'),
    tagPushEvents?: boolean(name='tagPushEvents'),
    url?: string(name='url'),
  }(name='result'),
  success?: boolean(name='success'),
}

model AddWebhookResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddWebhookResponseBody(name='body'),
}

async function addWebhook(repositoryId: string, request: AddWebhookRequest): AddWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addWebhookWithOptions(repositoryId, request, headers, runtime);
}

async function addWebhookWithOptions(repositoryId: string, request: AddWebhookRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddWebhookResponse {
  Util.validateModel(request);
  repositoryId = OpenApiUtil.getEncodeParam(repositoryId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.enableSslVerification)) {
    body['enableSslVerification'] = request.enableSslVerification;
  }
  if (!Util.isUnset(request.mergeRequestsEvents)) {
    body['mergeRequestsEvents'] = request.mergeRequestsEvents;
  }
  if (!Util.isUnset(request.noteEvents)) {
    body['noteEvents'] = request.noteEvents;
  }
  if (!Util.isUnset(request.pushEvents)) {
    body['pushEvents'] = request.pushEvents;
  }
  if (!Util.isUnset(request.secretToken)) {
    body['secretToken'] = request.secretToken;
  }
  if (!Util.isUnset(request.tagPushEvents)) {
    body['tagPushEvents'] = request.tagPushEvents;
  }
  if (!Util.isUnset(request.url)) {
    body['url'] = request.url;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddWebhook',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/repository/${repositoryId}/webhooks/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateFlowTagRequest {
  color?: string(name='color'),
  flowTagGroupId?: long(name='flowTagGroupId'),
  name?: string(name='name'),
}

model CreateFlowTagResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  id?: long(name='id'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model CreateFlowTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFlowTagResponseBody(name='body'),
}

async function createFlowTag(organizationId: string, request: CreateFlowTagRequest): CreateFlowTagResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFlowTagWithOptions(organizationId, request, headers, runtime);
}

async function createFlowTagWithOptions(organizationId: string, request: CreateFlowTagRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFlowTagResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.color)) {
    query['color'] = request.color;
  }
  if (!Util.isUnset(request.flowTagGroupId)) {
    query['flowTagGroupId'] = request.flowTagGroupId;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateFlowTag',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/flow/tags`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateFlowTagGroupRequest {
  name?: string(name='name'),
}

model CreateFlowTagGroupResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  id?: long(name='id'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model CreateFlowTagGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFlowTagGroupResponseBody(name='body'),
}

async function createFlowTagGroup(organizationId: string, request: CreateFlowTagGroupRequest): CreateFlowTagGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFlowTagGroupWithOptions(organizationId, request, headers, runtime);
}

async function createFlowTagGroupWithOptions(organizationId: string, request: CreateFlowTagGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFlowTagGroupResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateFlowTagGroup',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/flow/tagGroups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateHostGroupRequest {
  aliyunRegion?: string(name='aliyunRegion'),
  ecsLabelKey?: string(name='ecsLabelKey'),
  ecsLabelValue?: string(name='ecsLabelValue'),
  ecsType?: string(name='ecsType'),
  envId?: string(name='envId'),
  machineInfos?: string(name='machineInfos'),
  name?: string(name='name'),
  serviceConnectionId?: long(name='serviceConnectionId'),
  tagIds?: string(name='tagIds'),
  type?: string(name='type'),
}

model CreateHostGroupResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  hostGroupId?: long(name='hostGroupId'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model CreateHostGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateHostGroupResponseBody(name='body'),
}

async function createHostGroup(organizationId: string, request: CreateHostGroupRequest): CreateHostGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createHostGroupWithOptions(organizationId, request, headers, runtime);
}

async function createHostGroupWithOptions(organizationId: string, request: CreateHostGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateHostGroupResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.aliyunRegion)) {
    body['aliyunRegion'] = request.aliyunRegion;
  }
  if (!Util.isUnset(request.ecsLabelKey)) {
    body['ecsLabelKey'] = request.ecsLabelKey;
  }
  if (!Util.isUnset(request.ecsLabelValue)) {
    body['ecsLabelValue'] = request.ecsLabelValue;
  }
  if (!Util.isUnset(request.ecsType)) {
    body['ecsType'] = request.ecsType;
  }
  if (!Util.isUnset(request.envId)) {
    body['envId'] = request.envId;
  }
  if (!Util.isUnset(request.machineInfos)) {
    body['machineInfos'] = request.machineInfos;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.serviceConnectionId)) {
    body['serviceConnectionId'] = request.serviceConnectionId;
  }
  if (!Util.isUnset(request.tagIds)) {
    body['tagIds'] = request.tagIds;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateHostGroup',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/hostGroups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateOAuthTokenRequest {
  clientId?: string(name='clientId'),
  clientSecret?: string(name='clientSecret'),
  code?: string(name='code'),
  grantType?: string(name='grantType'),
  login?: string(name='login'),
  scope?: string(name='scope'),
}

model CreateOAuthTokenResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  result?: {
    accessToken?: string(name='accessToken'),
    id?: string(name='id'),
    scope?: string(name='scope'),
    tokenType?: string(name='tokenType'),
  }(name='result'),
  success?: string(name='success'),
}

model CreateOAuthTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOAuthTokenResponseBody(name='body'),
}

async function createOAuthToken(request: CreateOAuthTokenRequest): CreateOAuthTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createOAuthTokenWithOptions(request, headers, runtime);
}

async function createOAuthTokenWithOptions(request: CreateOAuthTokenRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateOAuthTokenResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientId)) {
    body['clientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clientSecret)) {
    body['clientSecret'] = request.clientSecret;
  }
  if (!Util.isUnset(request.code)) {
    body['code'] = request.code;
  }
  if (!Util.isUnset(request.grantType)) {
    body['grantType'] = request.grantType;
  }
  if (!Util.isUnset(request.login)) {
    body['login'] = request.login;
  }
  if (!Util.isUnset(request.scope)) {
    body['scope'] = request.scope;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOAuthToken',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/login/oauth/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateProjectRequest {
  customCode?: string(name='customCode'),
  name?: string(name='name'),
  scope?: string(name='scope'),
  templateIdentifier?: string(name='templateIdentifier'),
}

model CreateProjectResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMsg?: string(name='errorMsg'),
  project?: {
    categoryIdentifier?: string(name='categoryIdentifier'),
    creator?: string(name='creator'),
    customCode?: string(name='customCode'),
    description?: string(name='description'),
    gmtCreate?: long(name='gmtCreate'),
    gmtModified?: long(name='gmtModified'),
    icon?: string(name='icon'),
    identifier?: string(name='identifier'),
    logicalStatus?: string(name='logicalStatus'),
    modifier?: string(name='modifier'),
    name?: string(name='name'),
    organizationIdentifier?: string(name='organizationIdentifier'),
    scope?: string(name='scope'),
    statusIdentifier?: string(name='statusIdentifier'),
    statusStageIdentifier?: string(name='statusStageIdentifier'),
    typeIdentifier?: string(name='typeIdentifier'),
  }(name='project'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model CreateProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateProjectResponseBody(name='body'),
}

async function createProject(organizationId: string, request: CreateProjectRequest): CreateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createProjectWithOptions(organizationId, request, headers, runtime);
}

async function createProjectWithOptions(organizationId: string, request: CreateProjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateProjectResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.customCode)) {
    body['customCode'] = request.customCode;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.scope)) {
    body['scope'] = request.scope;
  }
  if (!Util.isUnset(request.templateIdentifier)) {
    body['templateIdentifier'] = request.templateIdentifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateProject',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/projects/createProject`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateRepositoryRequest {
  accessToken?: string(name='accessToken'),
  avatarUrl?: string(name='avatarUrl'),
  description?: string(name='description'),
  gitignoreType?: string(name='gitignoreType'),
  importAccount?: string(name='importAccount'),
  importDemoProject?: boolean(name='importDemoProject'),
  importRepoType?: string(name='importRepoType'),
  importToken?: string(name='importToken'),
  importTokenEncrypted?: string(name='importTokenEncrypted'),
  importUrl?: string(name='importUrl'),
  initStandardService?: boolean(name='initStandardService'),
  isCryptoEnabled?: boolean(name='isCryptoEnabled'),
  localImportUrl?: string(name='localImportUrl'),
  name?: string(name='name'),
  namespaceId?: long(name='namespaceId'),
  path?: string(name='path'),
  readmeType?: string(name='readmeType'),
  visibilityLevel?: int32(name='visibilityLevel'),
  createParentPath?: boolean(name='createParentPath'),
  organizationId?: string(name='organizationId'),
  sync?: boolean(name='sync'),
}

model CreateRepositoryResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  result?: {
    importFromSvn?: boolean(name='Import_from_svn'),
    archived?: boolean(name='archived'),
    avatarUrl?: string(name='avatar_url'),
    createdAt?: string(name='createdAt'),
    creatorId?: long(name='creatorId'),
    defaultBranch?: string(name='defaultBranch'),
    demoProject?: boolean(name='demoProject'),
    description?: string(name='description'),
    httpUrlToRepo?: string(name='httpUrlToRepo'),
    id?: long(name='id'),
    lastActivityAt?: string(name='lastActivityAt'),
    name?: string(name='name'),
    nameWithNamespace?: string(name='nameWithNamespace'),
    namespace?: {
      avatar?: string(name='avatar'),
      createdAt?: string(name='createdAt'),
      description?: string(name='description'),
      id?: long(name='id'),
      name?: string(name='name'),
      ownerId?: long(name='ownerId'),
      path?: string(name='path'),
      public?: boolean(name='public'),
      updatedAt?: string(name='updatedAt'),
      visibilityLevel?: string(name='visibilityLevel'),
    }(name='namespace'),
    path?: string(name='path'),
    pathWithNamespace?: string(name='pathWithNamespace'),
    sshUrlToRepo?: string(name='sshUrlToRepo'),
    visibilityLevel?: string(name='visibilityLevel'),
    webUrl?: string(name='webUrl'),
  }(name='result'),
  success?: boolean(name='success'),
}

model CreateRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepositoryResponseBody(name='body'),
}

async function createRepository(request: CreateRepositoryRequest): CreateRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRepositoryWithOptions(request, headers, runtime);
}

async function createRepositoryWithOptions(request: CreateRepositoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRepositoryResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['accessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.createParentPath)) {
    query['createParentPath'] = request.createParentPath;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['organizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.sync)) {
    query['sync'] = request.sync;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.avatarUrl)) {
    body['avatarUrl'] = request.avatarUrl;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.gitignoreType)) {
    body['gitignoreType'] = request.gitignoreType;
  }
  if (!Util.isUnset(request.importAccount)) {
    body['importAccount'] = request.importAccount;
  }
  if (!Util.isUnset(request.importDemoProject)) {
    body['importDemoProject'] = request.importDemoProject;
  }
  if (!Util.isUnset(request.importRepoType)) {
    body['importRepoType'] = request.importRepoType;
  }
  if (!Util.isUnset(request.importToken)) {
    body['importToken'] = request.importToken;
  }
  if (!Util.isUnset(request.importTokenEncrypted)) {
    body['importTokenEncrypted'] = request.importTokenEncrypted;
  }
  if (!Util.isUnset(request.importUrl)) {
    body['importUrl'] = request.importUrl;
  }
  if (!Util.isUnset(request.initStandardService)) {
    body['initStandardService'] = request.initStandardService;
  }
  if (!Util.isUnset(request.isCryptoEnabled)) {
    body['isCryptoEnabled'] = request.isCryptoEnabled;
  }
  if (!Util.isUnset(request.localImportUrl)) {
    body['localImportUrl'] = request.localImportUrl;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.namespaceId)) {
    body['namespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.path)) {
    body['path'] = request.path;
  }
  if (!Util.isUnset(request.readmeType)) {
    body['readmeType'] = request.readmeType;
  }
  if (!Util.isUnset(request.visibilityLevel)) {
    body['visibilityLevel'] = request.visibilityLevel;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepository',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/repository/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateResourceMemberRequest {
  accountId?: string(name='accountId'),
  roleName?: string(name='roleName'),
}

model CreateResourceMemberResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model CreateResourceMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateResourceMemberResponseBody(name='body'),
}

async function createResourceMember(organizationId: string, resourceType: string, resourceId: string, request: CreateResourceMemberRequest): CreateResourceMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createResourceMemberWithOptions(organizationId, resourceType, resourceId, request, headers, runtime);
}

async function createResourceMemberWithOptions(organizationId: string, resourceType: string, resourceId: string, request: CreateResourceMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateResourceMemberResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  resourceType = OpenApiUtil.getEncodeParam(resourceType);
  resourceId = OpenApiUtil.getEncodeParam(resourceId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accountId)) {
    body['accountId'] = request.accountId;
  }
  if (!Util.isUnset(request.roleName)) {
    body['roleName'] = request.roleName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateResourceMember',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/${resourceType}/${resourceId}/members`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateSprintRequest {
  endDate?: string(name='endDate'),
  name?: string(name='name'),
  spaceIdentifier?: string(name='spaceIdentifier'),
  staffIds?: [ string ](name='staffIds'),
  startDate?: string(name='startDate'),
}

model CreateSprintResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMsg?: string(name='errorMsg'),
  requestId?: string(name='requestId'),
  sprint?: {
    creator?: string(name='creator'),
    description?: string(name='description'),
    endDate?: long(name='endDate'),
    gmtCreate?: long(name='gmtCreate'),
    gmtModified?: long(name='gmtModified'),
    identifier?: string(name='identifier'),
    modifier?: string(name='modifier'),
    name?: string(name='name'),
    scope?: string(name='scope'),
    spaceIdentifier?: string(name='spaceIdentifier'),
    startDate?: long(name='startDate'),
    status?: string(name='status'),
  }(name='sprint'),
  success?: boolean(name='success'),
}

model CreateSprintResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSprintResponseBody(name='body'),
}

async function createSprint(organizationId: string, request: CreateSprintRequest): CreateSprintResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSprintWithOptions(organizationId, request, headers, runtime);
}

async function createSprintWithOptions(organizationId: string, request: CreateSprintRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSprintResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.endDate)) {
    body['endDate'] = request.endDate;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.spaceIdentifier)) {
    body['spaceIdentifier'] = request.spaceIdentifier;
  }
  if (!Util.isUnset(request.staffIds)) {
    body['staffIds'] = request.staffIds;
  }
  if (!Util.isUnset(request.startDate)) {
    body['startDate'] = request.startDate;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSprint',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/sprints/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateSshKeyResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  sshKey?: {
    id?: long(name='id'),
    publicKey?: string(name='publicKey'),
  }(name='sshKey'),
  success?: boolean(name='success'),
}

model CreateSshKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSshKeyResponseBody(name='body'),
}

async function createSshKey(organizationId: string): CreateSshKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSshKeyWithOptions(organizationId, headers, runtime);
}

async function createSshKeyWithOptions(organizationId: string, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSshKeyResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CreateSshKey',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/sshKey`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateVariableGroupRequest {
  description?: string(name='description'),
  name?: string(name='name'),
  variables?: string(name='variables'),
}

model CreateVariableGroupResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  variableGroupId?: long(name='variableGroupId'),
}

model CreateVariableGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVariableGroupResponseBody(name='body'),
}

async function createVariableGroup(organizationId: string, request: CreateVariableGroupRequest): CreateVariableGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createVariableGroupWithOptions(organizationId, request, headers, runtime);
}

async function createVariableGroupWithOptions(organizationId: string, request: CreateVariableGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateVariableGroupResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.variables)) {
    body['variables'] = request.variables;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateVariableGroup',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/variableGroups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateWorkitemRequest {
  assignedTo?: string(name='assignedTo'),
  category?: string(name='category'),
  description?: string(name='description'),
  descriptionFormat?: string(name='descriptionFormat'),
  fieldValueList?: [ 
    {
      fieldIdentifier?: string(name='fieldIdentifier'),
      value?: string(name='value'),
      workitemIdentifier?: string(name='workitemIdentifier'),
    }
  ](name='fieldValueList'),
  parent?: string(name='parent'),
  participant?: [ string ](name='participant'),
  space?: string(name='space'),
  spaceIdentifier?: string(name='spaceIdentifier'),
  spaceType?: string(name='spaceType'),
  sprint?: [ string ](name='sprint'),
  subject?: string(name='subject'),
  tracker?: [ string ](name='tracker'),
  verifier?: [ string ](name='verifier'),
  workitemType?: string(name='workitemType'),
}

model CreateWorkitemResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMsg?: string(name='errorMsg'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  workitem?: {
    assignedTo?: string(name='assignedTo'),
    categoryIdentifier?: string(name='categoryIdentifier'),
    creator?: string(name='creator'),
    document?: string(name='document'),
    gmtCreate?: long(name='gmtCreate'),
    gmtModified?: long(name='gmtModified'),
    identifier?: string(name='identifier'),
    logicalStatus?: string(name='logicalStatus'),
    modifier?: string(name='modifier'),
    parentIdentifier?: string(name='parentIdentifier'),
    serialNumber?: string(name='serialNumber'),
    spaceIdentifier?: string(name='spaceIdentifier'),
    spaceName?: string(name='spaceName'),
    spaceType?: string(name='spaceType'),
    sprintIdentifier?: string(name='sprintIdentifier'),
    status?: string(name='status'),
    statusIdentifier?: string(name='statusIdentifier'),
    statusStageIdentifier?: string(name='statusStageIdentifier'),
    subject?: string(name='subject'),
    updateStatusAt?: long(name='updateStatusAt'),
    workitemTypeIdentifier?: string(name='workitemTypeIdentifier'),
  }(name='workitem'),
}

model CreateWorkitemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateWorkitemResponseBody(name='body'),
}

async function createWorkitem(organizationId: string, request: CreateWorkitemRequest): CreateWorkitemResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createWorkitemWithOptions(organizationId, request, headers, runtime);
}

async function createWorkitemWithOptions(organizationId: string, request: CreateWorkitemRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateWorkitemResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.assignedTo)) {
    body['assignedTo'] = request.assignedTo;
  }
  if (!Util.isUnset(request.category)) {
    body['category'] = request.category;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.descriptionFormat)) {
    body['descriptionFormat'] = request.descriptionFormat;
  }
  if (!Util.isUnset(request.fieldValueList)) {
    body['fieldValueList'] = request.fieldValueList;
  }
  if (!Util.isUnset(request.parent)) {
    body['parent'] = request.parent;
  }
  if (!Util.isUnset(request.participant)) {
    body['participant'] = request.participant;
  }
  if (!Util.isUnset(request.space)) {
    body['space'] = request.space;
  }
  if (!Util.isUnset(request.spaceIdentifier)) {
    body['spaceIdentifier'] = request.spaceIdentifier;
  }
  if (!Util.isUnset(request.spaceType)) {
    body['spaceType'] = request.spaceType;
  }
  if (!Util.isUnset(request.sprint)) {
    body['sprint'] = request.sprint;
  }
  if (!Util.isUnset(request.subject)) {
    body['subject'] = request.subject;
  }
  if (!Util.isUnset(request.tracker)) {
    body['tracker'] = request.tracker;
  }
  if (!Util.isUnset(request.verifier)) {
    body['verifier'] = request.verifier;
  }
  if (!Util.isUnset(request.workitemType)) {
    body['workitemType'] = request.workitemType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateWorkitem',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/workitems/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateWorkspaceRequest {
  codeUrl?: string(name='codeUrl'),
  codeVersion?: string(name='codeVersion'),
  filePath?: string(name='filePath'),
  name?: string(name='name'),
  requestFrom?: string(name='requestFrom'),
  resourceIdentifier?: string(name='resourceIdentifier'),
  reuse?: boolean(name='reuse'),
  workspaceTemplate?: string(name='workspaceTemplate'),
}

model CreateWorkspaceResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  workspace?: {
    createTime?: string(name='createTime'),
    creator?: string(name='creator'),
    id?: string(name='id'),
    name?: string(name='name'),
    status?: string(name='status'),
    template?: string(name='template'),
  }(name='workspace'),
}

model CreateWorkspaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateWorkspaceResponseBody(name='body'),
}

async function createWorkspace(request: CreateWorkspaceRequest): CreateWorkspaceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createWorkspaceWithOptions(request, headers, runtime);
}

async function createWorkspaceWithOptions(request: CreateWorkspaceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateWorkspaceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.codeUrl)) {
    body['codeUrl'] = request.codeUrl;
  }
  if (!Util.isUnset(request.codeVersion)) {
    body['codeVersion'] = request.codeVersion;
  }
  if (!Util.isUnset(request.filePath)) {
    body['filePath'] = request.filePath;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.requestFrom)) {
    body['requestFrom'] = request.requestFrom;
  }
  if (!Util.isUnset(request.resourceIdentifier)) {
    body['resourceIdentifier'] = request.resourceIdentifier;
  }
  if (!Util.isUnset(request.reuse)) {
    body['reuse'] = request.reuse;
  }
  if (!Util.isUnset(request.workspaceTemplate)) {
    body['workspaceTemplate'] = request.workspaceTemplate;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateWorkspace',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/api/workspaces`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteFlowTagResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model DeleteFlowTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFlowTagResponseBody(name='body'),
}

async function deleteFlowTag(organizationId: string, id: string): DeleteFlowTagResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFlowTagWithOptions(organizationId, id, headers, runtime);
}

async function deleteFlowTagWithOptions(organizationId: string, id: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFlowTagResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  id = OpenApiUtil.getEncodeParam(id);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteFlowTag',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/flow/tags/${id}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteFlowTagGroupResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model DeleteFlowTagGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFlowTagGroupResponseBody(name='body'),
}

async function deleteFlowTagGroup(organizationId: string, id: string): DeleteFlowTagGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFlowTagGroupWithOptions(organizationId, id, headers, runtime);
}

async function deleteFlowTagGroupWithOptions(organizationId: string, id: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFlowTagGroupResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  id = OpenApiUtil.getEncodeParam(id);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteFlowTagGroup',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/flow/tagGroups/${id}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteHostGroupResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model DeleteHostGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteHostGroupResponseBody(name='body'),
}

async function deleteHostGroup(organizationId: string, id: string): DeleteHostGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteHostGroupWithOptions(organizationId, id, headers, runtime);
}

async function deleteHostGroupWithOptions(organizationId: string, id: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteHostGroupResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  id = OpenApiUtil.getEncodeParam(id);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteHostGroup',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/hostGroups/${id}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeletePipelineResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model DeletePipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePipelineResponseBody(name='body'),
}

async function deletePipeline(organizationId: string, pipelineId: string): DeletePipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePipelineWithOptions(organizationId, pipelineId, headers, runtime);
}

async function deletePipelineWithOptions(organizationId: string, pipelineId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePipelineResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  pipelineId = OpenApiUtil.getEncodeParam(pipelineId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeletePipeline',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/pipelines/${pipelineId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteProjectRequest {
  identifier?: string(name='identifier'),
}

model DeleteProjectResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMsg?: string(name='errorMsg'),
  requestId?: string(name='requestId'),
  result?: boolean(name='result'),
  success?: boolean(name='success'),
}

model DeleteProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteProjectResponseBody(name='body'),
}

async function deleteProject(organizationId: string, request: DeleteProjectRequest): DeleteProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProjectWithOptions(organizationId, request, headers, runtime);
}

async function deleteProjectWithOptions(organizationId: string, request: DeleteProjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProjectResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.identifier)) {
    query['identifier'] = request.identifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProject',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/projects/delete`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteResourceMemberResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model DeleteResourceMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteResourceMemberResponseBody(name='body'),
}

async function deleteResourceMember(organizationId: string, resourceType: string, resourceId: string, accountId: string): DeleteResourceMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteResourceMemberWithOptions(organizationId, resourceType, resourceId, accountId, headers, runtime);
}

async function deleteResourceMemberWithOptions(organizationId: string, resourceType: string, resourceId: string, accountId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteResourceMemberResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  resourceType = OpenApiUtil.getEncodeParam(resourceType);
  resourceId = OpenApiUtil.getEncodeParam(resourceId);
  accountId = OpenApiUtil.getEncodeParam(accountId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourceMember',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/${resourceType}/${resourceId}/members/${accountId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteVariableGroupResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model DeleteVariableGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVariableGroupResponseBody(name='body'),
}

async function deleteVariableGroup(organizationId: string, id: string): DeleteVariableGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteVariableGroupWithOptions(organizationId, id, headers, runtime);
}

async function deleteVariableGroupWithOptions(organizationId: string, id: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteVariableGroupResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  id = OpenApiUtil.getEncodeParam(id);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteVariableGroup',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/variableGroups/${id}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model FrozenWorkspaceResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model FrozenWorkspaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FrozenWorkspaceResponseBody(name='body'),
}

async function frozenWorkspace(workspaceId: string): FrozenWorkspaceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return frozenWorkspaceWithOptions(workspaceId, headers, runtime);
}

async function frozenWorkspaceWithOptions(workspaceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): FrozenWorkspaceResponse {
  workspaceId = OpenApiUtil.getEncodeParam(workspaceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'FrozenWorkspace',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/api/workspaces/${workspaceId}/frozen`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetCodeupOrganizationRequest {
  accessToken?: string(name='AccessToken'),
}

model GetCodeupOrganizationResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    createdAt?: string(name='CreatedAt'),
    id?: long(name='Id'),
    namespaceId?: long(name='NamespaceId'),
    organizationId?: string(name='OrganizationId'),
    path?: string(name='Path'),
    updatedAt?: string(name='UpdatedAt'),
    userRole?: string(name='UserRole'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model GetCodeupOrganizationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCodeupOrganizationResponseBody(name='body'),
}

async function getCodeupOrganization(identity: string, request: GetCodeupOrganizationRequest): GetCodeupOrganizationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCodeupOrganizationWithOptions(identity, request, headers, runtime);
}

async function getCodeupOrganizationWithOptions(identity: string, request: GetCodeupOrganizationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCodeupOrganizationResponse {
  Util.validateModel(request);
  identity = OpenApiUtil.getEncodeParam(identity);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCodeupOrganization',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/api/organization/${identity}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetCustomFieldOptionRequest {
  spaceIdentifier?: string(name='spaceIdentifier'),
  spaceType?: string(name='spaceType'),
  workitemTypeIdentifier?: string(name='workitemTypeIdentifier'),
}

model GetCustomFieldOptionResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMsg?: string(name='errorMsg'),
  fileds?: [ 
    {
      displayValue?: string(name='displayValue'),
      fieldIdentifier?: string(name='fieldIdentifier'),
      identifier?: string(name='identifier'),
      level?: long(name='level'),
      position?: long(name='position'),
      value?: string(name='value'),
      valueEn?: string(name='valueEn'),
    }
  ](name='fileds'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetCustomFieldOptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCustomFieldOptionResponseBody(name='body'),
}

async function getCustomFieldOption(organizationId: string, fieldId: string, request: GetCustomFieldOptionRequest): GetCustomFieldOptionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCustomFieldOptionWithOptions(organizationId, fieldId, request, headers, runtime);
}

async function getCustomFieldOptionWithOptions(organizationId: string, fieldId: string, request: GetCustomFieldOptionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCustomFieldOptionResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  fieldId = OpenApiUtil.getEncodeParam(fieldId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.spaceIdentifier)) {
    query['spaceIdentifier'] = request.spaceIdentifier;
  }
  if (!Util.isUnset(request.spaceType)) {
    query['spaceType'] = request.spaceType;
  }
  if (!Util.isUnset(request.workitemTypeIdentifier)) {
    query['workitemTypeIdentifier'] = request.workitemTypeIdentifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCustomFieldOption',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/fields/${fieldId}/getCustomOption`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetFileLastCommitRequest {
  accessToken?: string(name='accessToken'),
  filepath?: string(name='filepath'),
  organizationId?: string(name='organizationId'),
  sha?: string(name='sha'),
}

model GetFileLastCommitResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    authorDate?: string(name='AuthorDate'),
    authorEmail?: string(name='AuthorEmail'),
    authorName?: string(name='AuthorName'),
    committedDate?: string(name='CommittedDate'),
    committerEmail?: string(name='CommitterEmail'),
    committerName?: string(name='CommitterName'),
    createdAt?: string(name='CreatedAt'),
    id?: string(name='Id'),
    message?: string(name='Message'),
    parentIds?: [ string ](name='ParentIds'),
    shortId?: string(name='ShortId'),
    signature?: {
      gpgKeyId?: string(name='GpgKeyId'),
      verificationStatus?: string(name='VerificationStatus'),
    }(name='Signature'),
    title?: string(name='Title'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model GetFileLastCommitResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFileLastCommitResponseBody(name='body'),
}

async function getFileLastCommit(repositoryId: string, request: GetFileLastCommitRequest): GetFileLastCommitResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFileLastCommitWithOptions(repositoryId, request, headers, runtime);
}

async function getFileLastCommitWithOptions(repositoryId: string, request: GetFileLastCommitRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFileLastCommitResponse {
  Util.validateModel(request);
  repositoryId = OpenApiUtil.getEncodeParam(repositoryId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['accessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.filepath)) {
    query['filepath'] = request.filepath;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['organizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.sha)) {
    query['sha'] = request.sha;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFileLastCommit',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/repository/${repositoryId}/files/lastCommit`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetFlowTagGroupResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  flowTagGroup?: {
    creatorAccountId?: string(name='creatorAccountId'),
    flowTagList?: [ 
      {
        color?: string(name='color'),
        creatorAccountId?: string(name='creatorAccountId'),
        id?: long(name='id'),
        modiferAccountId?: string(name='modiferAccountId'),
        name?: string(name='name'),
      }
    ](name='flowTagList'),
    id?: long(name='id'),
    modiferAccountId?: string(name='modiferAccountId'),
    name?: string(name='name'),
  }(name='flowTagGroup'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetFlowTagGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFlowTagGroupResponseBody(name='body'),
}

async function getFlowTagGroup(organizationId: string, id: string): GetFlowTagGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFlowTagGroupWithOptions(organizationId, id, headers, runtime);
}

async function getFlowTagGroupWithOptions(organizationId: string, id: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetFlowTagGroupResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  id = OpenApiUtil.getEncodeParam(id);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetFlowTagGroup',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/flow/tagGroups/${id}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetHostGroupResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  hostGroup?: {
    aliyunRegion?: string(name='aliyunRegion'),
    createTime?: long(name='createTime'),
    creatorAccountId?: string(name='creatorAccountId'),
    description?: string(name='description'),
    ecsLabelKey?: string(name='ecsLabelKey'),
    ecsLabelValue?: string(name='ecsLabelValue'),
    ecsType?: string(name='ecsType'),
    hostInfos?: [ 
      {
        aliyunRegionId?: string(name='aliyunRegionId'),
        createTime?: long(name='createTime'),
        creatorAccountId?: string(name='creatorAccountId'),
        instanceName?: string(name='instanceName'),
        ip?: string(name='ip'),
        machineSn?: string(name='machineSn'),
        modifierAccountId?: string(name='modifierAccountId'),
        objectType?: string(name='objectType'),
        updateTime?: long(name='updateTime'),
      }
    ](name='hostInfos'),
    hostNum?: long(name='hostNum'),
    id?: long(name='id'),
    modifierAccountId?: string(name='modifierAccountId'),
    name?: string(name='name'),
    serviceConnectionId?: long(name='serviceConnectionId'),
    type?: string(name='type'),
    upateTIme?: long(name='upateTIme'),
  }(name='hostGroup'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetHostGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetHostGroupResponseBody(name='body'),
}

async function getHostGroup(organizationId: string, id: string): GetHostGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getHostGroupWithOptions(organizationId, id, headers, runtime);
}

async function getHostGroupWithOptions(organizationId: string, id: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetHostGroupResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  id = OpenApiUtil.getEncodeParam(id);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetHostGroup',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/hostGroups/${id}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetOrganizationMemberResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  member?: {
    accountId?: string(name='accountId'),
    birthday?: long(name='birthday'),
    deptLists?: [ string ](name='deptLists'),
    email?: string(name='email'),
    hiredDate?: long(name='hiredDate'),
    identities?: {
      externUid?: string(name='externUid'),
      provider?: string(name='provider'),
    }(name='identities'),
    joinTime?: long(name='joinTime'),
    lastVisitTime?: long(name='lastVisitTime'),
    mobile?: string(name='mobile'),
    organizationMemberName?: string(name='organizationMemberName'),
    organizationRoleId?: string(name='organizationRoleId'),
    organizationRoleName?: string(name='organizationRoleName'),
    state?: string(name='state'),
  }(name='member'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetOrganizationMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOrganizationMemberResponseBody(name='body'),
}

async function getOrganizationMember(organizationId: string, accountId: string): GetOrganizationMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getOrganizationMemberWithOptions(organizationId, accountId, headers, runtime);
}

async function getOrganizationMemberWithOptions(organizationId: string, accountId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetOrganizationMemberResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  accountId = OpenApiUtil.getEncodeParam(accountId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetOrganizationMember',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/members/${accountId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetPipelineResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  pipeline?: {
    createTime?: long(name='createTime'),
    creatorAccountId?: string(name='creatorAccountId'),
    envId?: int32(name='envId'),
    envName?: string(name='envName'),
    groupId?: long(name='groupId'),
    modifierAccountId?: string(name='modifierAccountId'),
    name?: string(name='name'),
    pipelineConfig?: {
      flow?: string(name='flow'),
      settings?: string(name='settings'),
      sources?: [ 
        {
          data?: {
            branch?: string(name='branch'),
            cloneDepth?: long(name='cloneDepth'),
            credentialId?: long(name='credentialId'),
            credentialLabel?: string(name='credentialLabel'),
            credentialType?: string(name='credentialType'),
            events?: [ string ](name='events'),
            isBranchMode?: boolean(name='isBranchMode'),
            isCloneDepth?: boolean(name='isCloneDepth'),
            isSubmodule?: boolean(name='isSubmodule'),
            isTrigger?: boolean(name='isTrigger'),
            label?: string(name='label'),
            namespace?: string(name='namespace'),
            repo?: string(name='repo'),
            serviceConnectionId?: long(name='serviceConnectionId'),
            triggerFilter?: string(name='triggerFilter'),
            webhook?: string(name='webhook'),
          }(name='data'),
          sign?: string(name='sign'),
          type?: string(name='type'),
        }
      ](name='sources'),
    }(name='pipelineConfig'),
    tagList?: [ 
      {
        id?: long(name='id'),
        name?: string(name='name'),
      }
    ](name='tagList'),
    updateTime?: long(name='updateTime'),
  }(name='pipeline'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetPipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPipelineResponseBody(name='body'),
}

async function getPipeline(organizationId: string, pipelineId: string): GetPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPipelineWithOptions(organizationId, pipelineId, headers, runtime);
}

async function getPipelineWithOptions(organizationId: string, pipelineId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPipelineResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  pipelineId = OpenApiUtil.getEncodeParam(pipelineId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPipeline',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/pipelines/${pipelineId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetPipelineArtifactUrlRequest {
  fileName?: string(name='fileName'),
  filePath?: string(name='filePath'),
}

model GetPipelineArtifactUrlResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  fileUrl?: string(name='fileUrl'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetPipelineArtifactUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPipelineArtifactUrlResponseBody(name='body'),
}

async function getPipelineArtifactUrl(organizationId: string, request: GetPipelineArtifactUrlRequest): GetPipelineArtifactUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPipelineArtifactUrlWithOptions(organizationId, request, headers, runtime);
}

async function getPipelineArtifactUrlWithOptions(organizationId: string, request: GetPipelineArtifactUrlRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetPipelineArtifactUrlResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.fileName)) {
    query['fileName'] = request.fileName;
  }
  if (!Util.isUnset(request.filePath)) {
    query['filePath'] = request.filePath;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPipelineArtifactUrl',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/pipeline/getArtifactDownloadUrl`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetPipelineEmasArtifactUrlRequest {
  serviceConnectionId?: long(name='serviceConnectionId'),
}

model GetPipelineEmasArtifactUrlResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  fileUrl?: string(name='fileUrl'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetPipelineEmasArtifactUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPipelineEmasArtifactUrlResponseBody(name='body'),
}

async function getPipelineEmasArtifactUrl(organizationId: string, emasJobInstanceId: string, md5: string, pipelineId: string, pipelineRunId: string, request: GetPipelineEmasArtifactUrlRequest): GetPipelineEmasArtifactUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPipelineEmasArtifactUrlWithOptions(organizationId, emasJobInstanceId, md5, pipelineId, pipelineRunId, request, headers, runtime);
}

async function getPipelineEmasArtifactUrlWithOptions(organizationId: string, emasJobInstanceId: string, md5: string, pipelineId: string, pipelineRunId: string, request: GetPipelineEmasArtifactUrlRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetPipelineEmasArtifactUrlResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  emasJobInstanceId = OpenApiUtil.getEncodeParam(emasJobInstanceId);
  md5 = OpenApiUtil.getEncodeParam(md5);
  pipelineId = OpenApiUtil.getEncodeParam(pipelineId);
  pipelineRunId = OpenApiUtil.getEncodeParam(pipelineRunId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.serviceConnectionId)) {
    query['serviceConnectionId'] = request.serviceConnectionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPipelineEmasArtifactUrl',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/pipeline/${pipelineId}/pipelineRun/${pipelineRunId}/emas/artifact/${emasJobInstanceId}/${md5}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetPipelineRunResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  pipelineRun?: {
    createTime?: long(name='createTime'),
    creatorAccountId?: string(name='creatorAccountId'),
    modifierAccountId?: string(name='modifierAccountId'),
    pipelineId?: long(name='pipelineId'),
    pipelineRunId?: long(name='pipelineRunId'),
    sources?: [ 
      {
        data?: {
          branch?: string(name='branch'),
          commint?: string(name='commint'),
          repo?: string(name='repo'),
        }(name='data'),
        sign?: string(name='sign'),
        type?: string(name='type'),
      }
    ](name='sources'),
    stageGroup?: [[ string ]    ](name='stageGroup'),
    stages?: [ 
      {
        name?: string(name='name'),
        stageInfo?: {
          endTime?: long(name='endTime'),
          jobs?: [ 
            {
              actions?: [ 
                {
                  disable?: boolean(name='disable'),
                  params?: any(name='params'),
                  type?: string(name='type'),
                }
              ](name='actions'),
              endTime?: long(name='endTime'),
              id?: long(name='id'),
              name?: string(name='name'),
              params?: string(name='params'),
              startTime?: long(name='startTime'),
              status?: string(name='status'),
            }
          ](name='jobs'),
          name?: string(name='name'),
          startTime?: long(name='startTime'),
          status?: string(name='status'),
        }(name='stageInfo'),
      }
    ](name='stages'),
    status?: string(name='status'),
    triggerMode?: int32(name='triggerMode'),
    updateTime?: long(name='updateTime'),
  }(name='pipelineRun'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetPipelineRunResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPipelineRunResponseBody(name='body'),
}

async function getPipelineRun(organizationId: string, pipelineId: string, pipelineRunId: string): GetPipelineRunResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPipelineRunWithOptions(organizationId, pipelineId, pipelineRunId, headers, runtime);
}

async function getPipelineRunWithOptions(organizationId: string, pipelineId: string, pipelineRunId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPipelineRunResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  pipelineId = OpenApiUtil.getEncodeParam(pipelineId);
  pipelineRunId = OpenApiUtil.getEncodeParam(pipelineRunId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPipelineRun',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/pipelines/${pipelineId}/pipelineRuns/${pipelineRunId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetPipelineScanReportUrlRequest {
  reportPath?: string(name='reportPath'),
}

model GetPipelineScanReportUrlResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  reportUrl?: string(name='reportUrl'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetPipelineScanReportUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPipelineScanReportUrlResponseBody(name='body'),
}

async function getPipelineScanReportUrl(organizationId: string, request: GetPipelineScanReportUrlRequest): GetPipelineScanReportUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPipelineScanReportUrlWithOptions(organizationId, request, headers, runtime);
}

async function getPipelineScanReportUrlWithOptions(organizationId: string, request: GetPipelineScanReportUrlRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetPipelineScanReportUrlResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.reportPath)) {
    body['reportPath'] = request.reportPath;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetPipelineScanReportUrl',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/pipeline/getPipelineScanReportUrl`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProjectInfoResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  project?: {
    category?: string(name='category'),
    categoryIdentifier?: string(name='categoryIdentifier'),
    creator?: string(name='creator'),
    customCode?: string(name='customCode'),
    description?: string(name='description'),
    gmtCreate?: long(name='gmtCreate'),
    gmtModified?: long(name='gmtModified'),
    icon?: string(name='icon'),
    iconBig?: string(name='iconBig'),
    iconGroup?: string(name='iconGroup'),
    iconSmall?: string(name='iconSmall'),
    id?: string(name='id'),
    identifier?: string(name='identifier'),
    identifierPath?: string(name='identifierPath'),
    logicalStatus?: string(name='logicalStatus'),
    modifier?: string(name='modifier'),
    name?: string(name='name'),
    organizationIdentifier?: string(name='organizationIdentifier'),
    parentIdentifier?: string(name='parentIdentifier'),
    scope?: string(name='scope'),
    statusIdentifier?: string(name='statusIdentifier'),
    statusStageIdentifier?: string(name='statusStageIdentifier'),
    subType?: string(name='subType'),
    typeIdentifier?: string(name='typeIdentifier'),
  }(name='project'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetProjectInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProjectInfoResponseBody(name='body'),
}

async function getProjectInfo(organizationId: string, projectId: string): GetProjectInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProjectInfoWithOptions(organizationId, projectId, headers, runtime);
}

async function getProjectInfoWithOptions(organizationId: string, projectId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetProjectInfoResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  projectId = OpenApiUtil.getEncodeParam(projectId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetProjectInfo',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/project/${projectId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProjectMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  repositoryId?: long(name='repositoryId'),
  userAliyunPk?: string(name='userAliyunPk'),
}

model GetProjectMemberResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  result?: {
    accessLevel?: int32(name='accessLevel'),
    avatarUrl?: string(name='avatarUrl'),
    externUserId?: string(name='externUserId'),
    id?: long(name='id'),
    name?: string(name='name'),
  }(name='result'),
  success?: boolean(name='success'),
}

model GetProjectMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProjectMemberResponseBody(name='body'),
}

async function getProjectMember(request: GetProjectMemberRequest): GetProjectMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProjectMemberWithOptions(request, headers, runtime);
}

async function getProjectMemberWithOptions(request: GetProjectMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProjectMemberResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.repositoryId)) {
    query['repositoryId'] = request.repositoryId;
  }
  if (!Util.isUnset(request.userAliyunPk)) {
    query['userAliyunPk'] = request.userAliyunPk;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProjectMember',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/repository/member/get`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetRepositoryRequest {
  accessToken?: string(name='accessToken'),
  identity?: string(name='identity'),
  organizationId?: string(name='organizationId'),
}

model GetRepositoryResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  repository?: {
    archive?: boolean(name='archive'),
    avatarUrl?: string(name='avatarUrl'),
    createdAt?: string(name='createdAt'),
    creatorId?: long(name='creatorId'),
    defaultBranch?: string(name='defaultBranch'),
    demoProjectStatus?: boolean(name='demoProjectStatus'),
    description?: string(name='description'),
    httpUrlToRepository?: string(name='httpUrlToRepository'),
    id?: long(name='id'),
    lastActivityAt?: string(name='lastActivityAt'),
    name?: string(name='name'),
    nameWithNamespace?: string(name='nameWithNamespace'),
    namespace?: {
      avatar?: string(name='avatar'),
      createdAt?: string(name='createdAt'),
      description?: string(name='description'),
      id?: long(name='id'),
      name?: string(name='name'),
      ownerId?: long(name='ownerId'),
      path?: string(name='path'),
      updatedAt?: string(name='updatedAt'),
      visibilityLevel?: int32(name='visibilityLevel'),
    }(name='namespace'),
    path?: string(name='path'),
    pathWithNamespace?: string(name='pathWithNamespace'),
    sshUrlToRepository?: string(name='sshUrlToRepository'),
    visibilityLevel?: int32(name='visibilityLevel'),
    webUrl?: string(name='webUrl'),
  }(name='repository'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepositoryResponseBody(name='body'),
}

async function getRepository(request: GetRepositoryRequest): GetRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepositoryWithOptions(request, headers, runtime);
}

async function getRepositoryWithOptions(request: GetRepositoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepositoryResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['accessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.identity)) {
    query['identity'] = request.identity;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['organizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepository',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/repository/get`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetSprintInfoResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  sprint?: {
    creator?: string(name='creator'),
    description?: string(name='description'),
    endDate?: long(name='endDate'),
    gmtCreate?: long(name='gmtCreate'),
    gmtModified?: long(name='gmtModified'),
    identifier?: string(name='identifier'),
    modifier?: string(name='modifier'),
    name?: string(name='name'),
    scope?: string(name='scope'),
    spaceIdentifier?: string(name='spaceIdentifier'),
    startDate?: long(name='startDate'),
    status?: string(name='status'),
  }(name='sprint'),
  success?: boolean(name='success'),
}

model GetSprintInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSprintInfoResponseBody(name='body'),
}

async function getSprintInfo(organizationId: string, sprintId: string): GetSprintInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSprintInfoWithOptions(organizationId, sprintId, headers, runtime);
}

async function getSprintInfoWithOptions(organizationId: string, sprintId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetSprintInfoResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  sprintId = OpenApiUtil.getEncodeParam(sprintId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetSprintInfo',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/sprints/${sprintId}/getSprintinfo`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetVMDeployOrderResponseBody = {
  deployOrder?: {
    actions?: [ 
      {
        disable?: boolean(name='disable'),
        params?: any(name='params'),
        type?: string(name='type'),
      }
    ](name='actions'),
    createTime?: long(name='createTime'),
    creator?: string(name='creator'),
    currentBatch?: int32(name='currentBatch'),
    deployMachineInfo?: {
      batchNum?: int32(name='batchNum'),
      deployMachines?: [ 
        {
          actions?: [ 
            {
              disable?: boolean(name='disable'),
              params?: any(name='params'),
              type?: string(name='type'),
            }
          ](name='actions'),
          batchNum?: int32(name='batchNum'),
          clientStatus?: string(name='clientStatus'),
          createTime?: long(name='createTime'),
          ip?: string(name='ip'),
          machineSn?: string(name='machineSn'),
          status?: string(name='status'),
          updateTime?: long(name='updateTime'),
        }
      ](name='deployMachines'),
      hostGroupId?: long(name='hostGroupId'),
    }(name='deployMachineInfo'),
    deployOrderId?: string(name='deployOrderId'),
    exceptionCode?: string(name='exceptionCode'),
    status?: string(name='status'),
    totalBatch?: int32(name='totalBatch'),
    updateTime?: long(name='updateTime'),
  }(name='deployOrder'),
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetVMDeployOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVMDeployOrderResponseBody(name='body'),
}

async function getVMDeployOrder(organizationId: string, pipelineId: string, deployOrderId: string): GetVMDeployOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getVMDeployOrderWithOptions(organizationId, pipelineId, deployOrderId, headers, runtime);
}

async function getVMDeployOrderWithOptions(organizationId: string, pipelineId: string, deployOrderId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetVMDeployOrderResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  pipelineId = OpenApiUtil.getEncodeParam(pipelineId);
  deployOrderId = OpenApiUtil.getEncodeParam(deployOrderId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetVMDeployOrder',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/pipelines/${pipelineId}/deploy/${deployOrderId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetVariableGroupResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  variableGroup?: {
    ccreatorAccountId?: string(name='ccreatorAccountId'),
    createTime?: long(name='createTime'),
    description?: string(name='description'),
    id?: long(name='id'),
    modifierAccountId?: string(name='modifierAccountId'),
    name?: string(name='name'),
    relatedPipelines?: [ 
      {
        id?: long(name='id'),
        name?: string(name='name'),
      }
    ](name='relatedPipelines'),
    updateTime?: long(name='updateTime'),
    variables?: [ 
      {
        isEncrypted?: boolean(name='isEncrypted'),
        name?: string(name='name'),
        value?: string(name='value'),
      }
    ](name='variables'),
  }(name='variableGroup'),
}

model GetVariableGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVariableGroupResponseBody(name='body'),
}

async function getVariableGroup(organizationId: string, id: string): GetVariableGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getVariableGroupWithOptions(organizationId, id, headers, runtime);
}

async function getVariableGroupWithOptions(organizationId: string, id: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetVariableGroupResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  id = OpenApiUtil.getEncodeParam(id);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetVariableGroup',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/variableGroups/${id}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetWorkItemActivityResponseBody = {
  activities?: [ 
    {
      actionType?: string(name='actionType'),
      eventId?: long(name='eventId'),
      eventTime?: long(name='eventTime'),
      eventType?: string(name='eventType'),
      operator?: string(name='operator'),
      parentEventId?: long(name='parentEventId'),
      property?: {
        displayName?: string(name='displayName'),
        propertyIdentifier?: string(name='propertyIdentifier'),
        propertyName?: string(name='propertyName'),
        propertyType?: string(name='propertyType'),
      }(name='property'),
      resourceIdentifier?: string(name='resourceIdentifier'),
    }
  ](name='activities'),
  errorCode?: string(name='errorCode'),
  errorMsg?: string(name='errorMsg'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetWorkItemActivityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetWorkItemActivityResponseBody(name='body'),
}

async function getWorkItemActivity(organizationId: string, workitemId: string): GetWorkItemActivityResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getWorkItemActivityWithOptions(organizationId, workitemId, headers, runtime);
}

async function getWorkItemActivityWithOptions(organizationId: string, workitemId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetWorkItemActivityResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  workitemId = OpenApiUtil.getEncodeParam(workitemId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetWorkItemActivity',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/workitems/${workitemId}/getActivity`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetWorkItemInfoResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  workitem?: {
    assignedTo?: string(name='assignedTo'),
    categoryIdentifier?: string(name='categoryIdentifier'),
    creator?: string(name='creator'),
    customFields?: [ 
      {
        fieldClassName?: string(name='fieldClassName'),
        fieldFormat?: string(name='fieldFormat'),
        fieldIdentifier?: string(name='fieldIdentifier'),
        level?: long(name='level'),
        objectValue?: string(name='objectValue'),
        position?: long(name='position'),
        value?: string(name='value'),
        valueList?: [ 
          {
            displayValue?: string(name='displayValue'),
            identifier?: string(name='identifier'),
            level?: long(name='level'),
            value?: string(name='value'),
            valueEn?: string(name='valueEn'),
          }
        ](name='valueList'),
        workitemIdentifier?: string(name='workitemIdentifier'),
      }
    ](name='customFields'),
    document?: string(name='document'),
    gmtCreate?: long(name='gmtCreate'),
    gmtModified?: long(name='gmtModified'),
    identifier?: string(name='identifier'),
    logicalStatus?: string(name='logicalStatus'),
    modifier?: string(name='modifier'),
    parentIdentifier?: string(name='parentIdentifier'),
    participant?: [ string ](name='participant'),
    serialNumber?: string(name='serialNumber'),
    spaceIdentifier?: string(name='spaceIdentifier'),
    spaceName?: string(name='spaceName'),
    spaceType?: string(name='spaceType'),
    sprint?: [ string ](name='sprint'),
    status?: string(name='status'),
    statusIdentifier?: string(name='statusIdentifier'),
    statusStageIdentifier?: string(name='statusStageIdentifier'),
    subject?: string(name='subject'),
    tag?: [ string ](name='tag'),
    tracker?: [ string ](name='tracker'),
    updateStatusAt?: long(name='updateStatusAt'),
    verifier?: [ string ](name='verifier'),
    workitemTypeIdentifier?: string(name='workitemTypeIdentifier'),
  }(name='workitem'),
}

model GetWorkItemInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetWorkItemInfoResponseBody(name='body'),
}

async function getWorkItemInfo(organizationId: string, workitemId: string): GetWorkItemInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getWorkItemInfoWithOptions(organizationId, workitemId, headers, runtime);
}

async function getWorkItemInfoWithOptions(organizationId: string, workitemId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetWorkItemInfoResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  workitemId = OpenApiUtil.getEncodeParam(workitemId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetWorkItemInfo',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/workitems/${workitemId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetWorkItemWorkFlowInfoRequest {
  configurationId?: string(name='configurationId'),
}

model GetWorkItemWorkFlowInfoResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  workflow?: {
    creator?: string(name='creator'),
    defaultStatusIdentifier?: string(name='defaultStatusIdentifier'),
    description?: string(name='description'),
    gmtCreate?: long(name='gmtCreate'),
    gmtModified?: long(name='gmtModified'),
    identifier?: string(name='identifier'),
    modifier?: string(name='modifier'),
    name?: string(name='name'),
    ownerSpaceIdentifier?: string(name='ownerSpaceIdentifier'),
    ownerSpaceType?: string(name='ownerSpaceType'),
    resourceType?: string(name='resourceType'),
    source?: string(name='source'),
    statusOrder?: string(name='statusOrder'),
    statuses?: [ 
      {
        creator?: string(name='creator'),
        description?: string(name='description'),
        gmtCreate?: long(name='gmtCreate'),
        gmtModified?: long(name='gmtModified'),
        identifier?: string(name='identifier'),
        modifier?: string(name='modifier'),
        name?: string(name='name'),
        resourceType?: string(name='resourceType'),
        source?: string(name='source'),
        workflowStageIdentifier?: string(name='workflowStageIdentifier'),
        workflowStageName?: string(name='workflowStageName'),
      }
    ](name='statuses'),
    workflowActions?: [ 
      {
        id?: long(name='id'),
        name?: string(name='name'),
        nextWorkflowStatusIdentifier?: string(name='nextWorkflowStatusIdentifier'),
        workflowIdentifier?: string(name='workflowIdentifier'),
        workflowStatusIdentifier?: string(name='workflowStatusIdentifier'),
      }
    ](name='workflowActions'),
  }(name='workflow'),
}

model GetWorkItemWorkFlowInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetWorkItemWorkFlowInfoResponseBody(name='body'),
}

async function getWorkItemWorkFlowInfo(organizationId: string, workitemId: string, request: GetWorkItemWorkFlowInfoRequest): GetWorkItemWorkFlowInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getWorkItemWorkFlowInfoWithOptions(organizationId, workitemId, request, headers, runtime);
}

async function getWorkItemWorkFlowInfoWithOptions(organizationId: string, workitemId: string, request: GetWorkItemWorkFlowInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetWorkItemWorkFlowInfoResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  workitemId = OpenApiUtil.getEncodeParam(workitemId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.configurationId)) {
    query['configurationId'] = request.configurationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetWorkItemWorkFlowInfo',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/workitems/${workitemId}/getWorkflowInfo`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetWorkspaceResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  workspace?: {
    codeUrl?: string(name='codeUrl'),
    codeVersion?: string(name='codeVersion'),
    createTime?: string(name='createTime'),
    id?: string(name='id'),
    name?: string(name='name'),
    spec?: string(name='spec'),
    status?: string(name='status'),
    template?: string(name='template'),
    userId?: string(name='userId'),
  }(name='workspace'),
}

model GetWorkspaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetWorkspaceResponseBody(name='body'),
}

async function getWorkspace(workspaceId: string): GetWorkspaceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getWorkspaceWithOptions(workspaceId, headers, runtime);
}

async function getWorkspaceWithOptions(workspaceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetWorkspaceResponse {
  workspaceId = OpenApiUtil.getEncodeParam(workspaceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetWorkspace',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/api/workspaces/${workspaceId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListFlowTagGroupsResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  flowTagGroups?: [ 
    {
      creatorAccountId?: string(name='creatorAccountId'),
      id?: long(name='id'),
      modiferAccountId?: string(name='modiferAccountId'),
      name?: string(name='name'),
    }
  ](name='flowTagGroups'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ListFlowTagGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFlowTagGroupsResponseBody(name='body'),
}

async function listFlowTagGroups(organizationId: string): ListFlowTagGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFlowTagGroupsWithOptions(organizationId, headers, runtime);
}

async function listFlowTagGroupsWithOptions(organizationId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListFlowTagGroupsResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListFlowTagGroups',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/flow/tagGroups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListHostGroupsRequest {
  createEndTime?: long(name='createEndTime'),
  createStartTime?: long(name='createStartTime'),
  creatorAccountIds?: string(name='creatorAccountIds'),
  ids?: string(name='ids'),
  maxResults?: long(name='maxResults'),
  name?: string(name='name'),
  nextToken?: string(name='nextToken'),
  pageOrder?: string(name='pageOrder'),
  pageSort?: string(name='pageSort'),
}

model ListHostGroupsResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  hostGroups?: [ 
    {
      aliyunRegion?: string(name='aliyunRegion'),
      createTime?: long(name='createTime'),
      creatorAccountId?: string(name='creatorAccountId'),
      description?: string(name='description'),
      ecsLabelKey?: string(name='ecsLabelKey'),
      ecsLabelValue?: string(name='ecsLabelValue'),
      ecsType?: string(name='ecsType'),
      hostNum?: long(name='hostNum'),
      id?: long(name='id'),
      modifierAccountId?: string(name='modifierAccountId'),
      name?: string(name='name'),
      serviceConnectionId?: long(name='serviceConnectionId'),
      type?: string(name='type'),
      updateTime?: long(name='updateTime'),
    }
  ](name='hostGroups'),
  nextToken?: string(name='nextToken'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  totalCount?: long(name='totalCount'),
}

model ListHostGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListHostGroupsResponseBody(name='body'),
}

async function listHostGroups(organizationId: string, request: ListHostGroupsRequest): ListHostGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listHostGroupsWithOptions(organizationId, request, headers, runtime);
}

async function listHostGroupsWithOptions(organizationId: string, request: ListHostGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListHostGroupsResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.createEndTime)) {
    query['createEndTime'] = request.createEndTime;
  }
  if (!Util.isUnset(request.createStartTime)) {
    query['createStartTime'] = request.createStartTime;
  }
  if (!Util.isUnset(request.creatorAccountIds)) {
    query['creatorAccountIds'] = request.creatorAccountIds;
  }
  if (!Util.isUnset(request.ids)) {
    query['ids'] = request.ids;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['maxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.pageOrder)) {
    query['pageOrder'] = request.pageOrder;
  }
  if (!Util.isUnset(request.pageSort)) {
    query['pageSort'] = request.pageSort;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHostGroups',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/hostGroups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListOrganizationMembersRequest {
  externUid?: string(name='externUid'),
  joinTimeFrom?: long(name='joinTimeFrom'),
  joinTimeTo?: long(name='joinTimeTo'),
  maxResults?: long(name='maxResults'),
  nextToken?: string(name='nextToken'),
  organizationMemberName?: string(name='organizationMemberName'),
  provider?: string(name='provider'),
  state?: string(name='state'),
}

model ListOrganizationMembersResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  members?: [ 
    {
      accountId?: string(name='accountId'),
      birthday?: long(name='birthday'),
      deptLists?: [ string ](name='deptLists'),
      email?: string(name='email'),
      hiredDate?: long(name='hiredDate'),
      identities?: {
        externUid?: string(name='externUid'),
        provider?: string(name='provider'),
      }(name='identities'),
      joinTime?: long(name='joinTime'),
      lastVisitTime?: long(name='lastVisitTime'),
      mobile?: string(name='mobile'),
      organizationMemberName?: string(name='organizationMemberName'),
      organizationRoleId?: string(name='organizationRoleId'),
      organizationRoleName?: string(name='organizationRoleName'),
      state?: string(name='state'),
    }
  ](name='members'),
  nextToken?: string(name='nextToken'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  totalCount?: long(name='totalCount'),
}

model ListOrganizationMembersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListOrganizationMembersResponseBody(name='body'),
}

async function listOrganizationMembers(organizationId: string, request: ListOrganizationMembersRequest): ListOrganizationMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listOrganizationMembersWithOptions(organizationId, request, headers, runtime);
}

async function listOrganizationMembersWithOptions(organizationId: string, request: ListOrganizationMembersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListOrganizationMembersResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.externUid)) {
    query['externUid'] = request.externUid;
  }
  if (!Util.isUnset(request.joinTimeFrom)) {
    query['joinTimeFrom'] = request.joinTimeFrom;
  }
  if (!Util.isUnset(request.joinTimeTo)) {
    query['joinTimeTo'] = request.joinTimeTo;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['maxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.organizationMemberName)) {
    query['organizationMemberName'] = request.organizationMemberName;
  }
  if (!Util.isUnset(request.provider)) {
    query['provider'] = request.provider;
  }
  if (!Util.isUnset(request.state)) {
    query['state'] = request.state;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOrganizationMembers',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/members`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPipelineJobHistorysRequest {
  category?: string(name='category'),
  identifier?: string(name='identifier'),
  maxResults?: long(name='maxResults'),
  nextToken?: string(name='nextToken'),
}

model ListPipelineJobHistorysResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  jobs?: [ 
    {
      executeNumber?: int32(name='executeNumber'),
      identifier?: string(name='identifier'),
      jobId?: long(name='jobId'),
      jobName?: string(name='jobName'),
      operatorAccountId?: string(name='operatorAccountId'),
      pipelineId?: long(name='pipelineId'),
      pipelineRunId?: long(name='pipelineRunId'),
      sources?: string(name='sources'),
      status?: string(name='status'),
    }
  ](name='jobs'),
  nextToken?: string(name='nextToken'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  totalCount?: int32(name='totalCount'),
}

model ListPipelineJobHistorysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPipelineJobHistorysResponseBody(name='body'),
}

async function listPipelineJobHistorys(organizationId: string, pipelineId: string, request: ListPipelineJobHistorysRequest): ListPipelineJobHistorysResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPipelineJobHistorysWithOptions(organizationId, pipelineId, request, headers, runtime);
}

async function listPipelineJobHistorysWithOptions(organizationId: string, pipelineId: string, request: ListPipelineJobHistorysRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPipelineJobHistorysResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  pipelineId = OpenApiUtil.getEncodeParam(pipelineId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.category)) {
    query['category'] = request.category;
  }
  if (!Util.isUnset(request.identifier)) {
    query['identifier'] = request.identifier;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['maxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPipelineJobHistorys',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/pipeline/${pipelineId}/job/historys`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPipelineJobsRequest {
  category?: string(name='category'),
}

model ListPipelineJobsResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  jobs?: [ 
    {
      identifier?: string(name='identifier'),
      jobName?: string(name='jobName'),
      lastJobId?: long(name='lastJobId'),
      lastJobParams?: string(name='lastJobParams'),
    }
  ](name='jobs'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ListPipelineJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPipelineJobsResponseBody(name='body'),
}

async function listPipelineJobs(organizationId: string, pipelineId: string, request: ListPipelineJobsRequest): ListPipelineJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPipelineJobsWithOptions(organizationId, pipelineId, request, headers, runtime);
}

async function listPipelineJobsWithOptions(organizationId: string, pipelineId: string, request: ListPipelineJobsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPipelineJobsResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  pipelineId = OpenApiUtil.getEncodeParam(pipelineId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.category)) {
    query['category'] = request.category;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPipelineJobs',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/pipeline/${pipelineId}/jobs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPipelineRunsRequest {
  endTime?: long(name='endTime'),
  maxResults?: long(name='maxResults'),
  nextToken?: string(name='nextToken'),
  startTime?: long(name='startTime'),
  status?: string(name='status'),
  triggerMode?: int32(name='triggerMode'),
}

model ListPipelineRunsResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  nextToken?: string(name='nextToken'),
  pipelineRuns?: [ 
    {
      creatorAccountId?: string(name='creatorAccountId'),
      endTime?: long(name='endTime'),
      pipelineId?: long(name='pipelineId'),
      pipelineRunId?: long(name='pipelineRunId'),
      startTime?: long(name='startTime'),
      status?: string(name='status'),
      triggerMode?: long(name='triggerMode'),
    }
  ](name='pipelineRuns'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  totalCount?: long(name='totalCount'),
}

model ListPipelineRunsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPipelineRunsResponseBody(name='body'),
}

async function listPipelineRuns(organizationId: string, pipelineId: string, request: ListPipelineRunsRequest): ListPipelineRunsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPipelineRunsWithOptions(organizationId, pipelineId, request, headers, runtime);
}

async function listPipelineRunsWithOptions(organizationId: string, pipelineId: string, request: ListPipelineRunsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPipelineRunsResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  pipelineId = OpenApiUtil.getEncodeParam(pipelineId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['maxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.startTime)) {
    query['startTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    query['status'] = request.status;
  }
  if (!Util.isUnset(request.triggerMode)) {
    query['triggerMode'] = request.triggerMode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPipelineRuns',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/pipelines/${pipelineId}/pipelineRuns`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPipelinesRequest {
  createEndTime?: long(name='createEndTime'),
  createStartTime?: long(name='createStartTime'),
  creatorAccountIds?: string(name='creatorAccountIds'),
  executeAccountIds?: string(name='executeAccountIds'),
  executeEndTime?: long(name='executeEndTime'),
  executeStartTime?: long(name='executeStartTime'),
  maxResults?: long(name='maxResults'),
  nextToken?: string(name='nextToken'),
  pipelineName?: string(name='pipelineName'),
  statusList?: string(name='statusList'),
}

model ListPipelinesResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  nextToken?: string(name='nextToken'),
  pipelines?: [ 
    {
      createTime?: long(name='createTime'),
      creatorAccountId?: string(name='creatorAccountId'),
      pipelineId?: long(name='pipelineId'),
      pipelineName?: string(name='pipelineName'),
    }
  ](name='pipelines'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  totalCount?: long(name='totalCount'),
}

model ListPipelinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPipelinesResponseBody(name='body'),
}

async function listPipelines(organizationId: string, request: ListPipelinesRequest): ListPipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPipelinesWithOptions(organizationId, request, headers, runtime);
}

async function listPipelinesWithOptions(organizationId: string, request: ListPipelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPipelinesResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.createEndTime)) {
    query['createEndTime'] = request.createEndTime;
  }
  if (!Util.isUnset(request.createStartTime)) {
    query['createStartTime'] = request.createStartTime;
  }
  if (!Util.isUnset(request.creatorAccountIds)) {
    query['creatorAccountIds'] = request.creatorAccountIds;
  }
  if (!Util.isUnset(request.executeAccountIds)) {
    query['executeAccountIds'] = request.executeAccountIds;
  }
  if (!Util.isUnset(request.executeEndTime)) {
    query['executeEndTime'] = request.executeEndTime;
  }
  if (!Util.isUnset(request.executeStartTime)) {
    query['executeStartTime'] = request.executeStartTime;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['maxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.pipelineName)) {
    query['pipelineName'] = request.pipelineName;
  }
  if (!Util.isUnset(request.statusList)) {
    query['statusList'] = request.statusList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPipelines',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/pipelines`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProjectMembersRequest {
  targetType?: string(name='targetType'),
}

model ListProjectMembersResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMsg?: string(name='errorMsg'),
  members?: [ 
    {
      account?: string(name='account'),
      avatar?: string(name='avatar'),
      dingTalkId?: string(name='dingTalkId'),
      displayName?: string(name='displayName'),
      displayNickName?: string(name='displayNickName'),
      displayRealName?: string(name='displayRealName'),
      division?: {
        identifier?: string(name='identifier'),
      }(name='division'),
      email?: string(name='email'),
      gender?: string(name='gender'),
      identifier?: string(name='identifier'),
      mobile?: string(name='mobile'),
      nameEn?: string(name='nameEn'),
      nickName?: string(name='nickName'),
      nickNamePinyin?: string(name='nickNamePinyin'),
      organizationUserInfo?: {
        organizationIdentifier?: string(name='organizationIdentifier'),
      }(name='organizationUserInfo'),
      realName?: string(name='realName'),
      realNamePinyin?: string(name='realNamePinyin'),
      stamp?: string(name='stamp'),
      tbRoleId?: string(name='tbRoleId'),
    }
  ](name='members'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ListProjectMembersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProjectMembersResponseBody(name='body'),
}

async function listProjectMembers(organizationId: string, projectId: string, request: ListProjectMembersRequest): ListProjectMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProjectMembersWithOptions(organizationId, projectId, request, headers, runtime);
}

async function listProjectMembersWithOptions(organizationId: string, projectId: string, request: ListProjectMembersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProjectMembersResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  projectId = OpenApiUtil.getEncodeParam(projectId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.targetType)) {
    query['targetType'] = request.targetType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProjectMembers',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/projects/${projectId}/listMembers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProjectTemplatesRequest {
  category?: string(name='category'),
}

model ListProjectTemplatesResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMsg?: string(name='errorMsg'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  templates?: [ 
    {
      copyFrom?: string(name='copyFrom'),
      creator?: string(name='creator'),
      description?: string(name='description'),
      gmtCreate?: long(name='gmtCreate'),
      gmtModified?: long(name='gmtModified'),
      icon?: string(name='icon'),
      identifier?: string(name='identifier'),
      modifier?: string(name='modifier'),
      name?: string(name='name'),
      nameEn?: string(name='nameEn'),
      resourceCategory?: string(name='resourceCategory'),
      resourceType?: string(name='resourceType'),
      spaceIdentifier?: string(name='spaceIdentifier'),
      spaceType?: string(name='spaceType'),
      type?: long(name='type'),
    }
  ](name='templates'),
}

model ListProjectTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProjectTemplatesResponseBody(name='body'),
}

async function listProjectTemplates(organizationId: string, request: ListProjectTemplatesRequest): ListProjectTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProjectTemplatesWithOptions(organizationId, request, headers, runtime);
}

async function listProjectTemplatesWithOptions(organizationId: string, request: ListProjectTemplatesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProjectTemplatesResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.category)) {
    query['category'] = request.category;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProjectTemplates',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/projects/listTemplates`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProjectWorkitemTypesRequest {
  category?: string(name='category'),
  spaceType?: string(name='spaceType'),
}

model ListProjectWorkitemTypesResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  workitemTypes?: [ 
    {
      addUser?: string(name='addUser'),
      categoryIdentifier?: string(name='categoryIdentifier'),
      creator?: string(name='creator'),
      defaultType?: boolean(name='defaultType'),
      description?: string(name='description'),
      enable?: boolean(name='enable'),
      gmtAdd?: long(name='gmtAdd'),
      gmtCreate?: long(name='gmtCreate'),
      identifier?: string(name='identifier'),
      name?: string(name='name'),
      nameEn?: string(name='nameEn'),
      systemDefault?: boolean(name='systemDefault'),
    }
  ](name='workitemTypes'),
}

model ListProjectWorkitemTypesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProjectWorkitemTypesResponseBody(name='body'),
}

async function listProjectWorkitemTypes(organizationId: string, projectId: string, request: ListProjectWorkitemTypesRequest): ListProjectWorkitemTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProjectWorkitemTypesWithOptions(organizationId, projectId, request, headers, runtime);
}

async function listProjectWorkitemTypesWithOptions(organizationId: string, projectId: string, request: ListProjectWorkitemTypesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProjectWorkitemTypesResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  projectId = OpenApiUtil.getEncodeParam(projectId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.category)) {
    query['category'] = request.category;
  }
  if (!Util.isUnset(request.spaceType)) {
    query['spaceType'] = request.spaceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProjectWorkitemTypes',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/projects/${projectId}/getWorkitemType`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProjectsRequest {
  category?: string(name='category'),
  conditions?: string(name='conditions'),
  extraConditions?: string(name='extraConditions'),
  maxResults?: long(name='maxResults'),
  nextToken?: string(name='nextToken'),
  scope?: string(name='scope'),
}

model ListProjectsResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMsg?: string(name='errorMsg'),
  maxResults?: long(name='maxResults'),
  nextToken?: string(name='nextToken'),
  projects?: [ 
    {
      categoryIdentifier?: string(name='categoryIdentifier'),
      creator?: string(name='creator'),
      customCode?: string(name='customCode'),
      deleteTime?: long(name='deleteTime'),
      description?: string(name='description'),
      gmtCreate?: long(name='gmtCreate'),
      icon?: string(name='icon'),
      identifier?: string(name='identifier'),
      logicalStatus?: string(name='logicalStatus'),
      name?: string(name='name'),
      scope?: string(name='scope'),
      statusStageIdentifier?: string(name='statusStageIdentifier'),
      typeIdentifier?: string(name='typeIdentifier'),
    }
  ](name='projects'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  totalCount?: long(name='totalCount'),
}

model ListProjectsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProjectsResponseBody(name='body'),
}

async function listProjects(organizationId: string, request: ListProjectsRequest): ListProjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProjectsWithOptions(organizationId, request, headers, runtime);
}

async function listProjectsWithOptions(organizationId: string, request: ListProjectsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProjectsResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.category)) {
    query['category'] = request.category;
  }
  if (!Util.isUnset(request.conditions)) {
    query['conditions'] = request.conditions;
  }
  if (!Util.isUnset(request.extraConditions)) {
    query['extraConditions'] = request.extraConditions;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['maxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.scope)) {
    query['scope'] = request.scope;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProjects',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/listProjects`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRepositoriesRequest {
  accessToken?: string(name='accessToken'),
  archived?: boolean(name='archived'),
  orderBy?: string(name='orderBy'),
  organizationId?: string(name='organizationId'),
  page?: long(name='page'),
  perPage?: long(name='perPage'),
  search?: string(name='search'),
  sort?: string(name='sort'),
}

model ListRepositoriesResponseBody = {
  errorCode?: int32(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  result?: [ 
    {
      id?: long(name='Id'),
      accessLevel?: int32(name='accessLevel'),
      archive?: boolean(name='archive'),
      avatarUrl?: string(name='avatarUrl'),
      createdAt?: string(name='createdAt'),
      description?: string(name='description'),
      importStatus?: string(name='importStatus'),
      lastActivityAt?: string(name='lastActivityAt'),
      name?: string(name='name'),
      nameWithNamespace?: string(name='nameWithNamespace'),
      namespaceId?: long(name='namespaceId'),
      path?: string(name='path'),
      pathWithNamespace?: string(name='pathWithNamespace'),
      star?: boolean(name='star'),
      starCount?: long(name='starCount'),
      updatedAt?: string(name='updatedAt'),
      visibilityLevel?: string(name='visibilityLevel'),
      webUrl?: string(name='webUrl'),
    }
  ](name='result'),
  success?: boolean(name='success'),
  total?: long(name='total'),
}

model ListRepositoriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepositoriesResponseBody(name='body'),
}

async function listRepositories(request: ListRepositoriesRequest): ListRepositoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoriesWithOptions(request, headers, runtime);
}

async function listRepositoriesWithOptions(request: ListRepositoriesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoriesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['accessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.archived)) {
    query['archived'] = request.archived;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['organizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.perPage)) {
    query['perPage'] = request.perPage;
  }
  if (!Util.isUnset(request.search)) {
    query['search'] = request.search;
  }
  if (!Util.isUnset(request.sort)) {
    query['sort'] = request.sort;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepositories',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/repository/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRepositoryMemberWithInheritedRequest {
  accessToken?: string(name='accessToken'),
  organizationId?: string(name='organizationId'),
}

model ListRepositoryMemberWithInheritedResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  result?: [ 
    {
      accessLevel?: int32(name='accessLevel'),
      avatarUrl?: string(name='avatarUrl'),
      email?: string(name='email'),
      externUserId?: string(name='externUserId'),
      id?: long(name='id'),
      inherited?: {
        id?: long(name='id'),
        name?: string(name='name'),
        nameWithNamespace?: string(name='nameWithNamespace'),
        path?: string(name='path'),
        pathWithNamespace?: string(name='pathWithNamespace'),
        type?: string(name='type'),
        visibilityLevel?: string(name='visibilityLevel'),
      }(name='inherited'),
      name?: string(name='name'),
      state?: string(name='state'),
      username?: string(name='username'),
    }
  ](name='result'),
  success?: boolean(name='success'),
}

model ListRepositoryMemberWithInheritedResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepositoryMemberWithInheritedResponseBody(name='body'),
}

async function listRepositoryMemberWithInherited(repositoryId: string, request: ListRepositoryMemberWithInheritedRequest): ListRepositoryMemberWithInheritedResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryMemberWithInheritedWithOptions(repositoryId, request, headers, runtime);
}

async function listRepositoryMemberWithInheritedWithOptions(repositoryId: string, request: ListRepositoryMemberWithInheritedRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryMemberWithInheritedResponse {
  Util.validateModel(request);
  repositoryId = OpenApiUtil.getEncodeParam(repositoryId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['accessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['organizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepositoryMemberWithInherited',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/repository/${repositoryId}/members/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRepositoryWebhookRequest {
  accessToken?: string(name='accessToken'),
  organizationId?: string(name='organizationId'),
  page?: long(name='page'),
  pageSize?: long(name='pageSize'),
}

model ListRepositoryWebhookResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  result?: [ 
    {
      createdAt?: string(name='createdAt'),
      description?: string(name='description'),
      enableSslVerification?: boolean(name='enableSslVerification'),
      id?: long(name='id'),
      lastTestResult?: string(name='lastTestResult'),
      mergeRequestsEvents?: boolean(name='mergeRequestsEvents'),
      noteEvents?: boolean(name='noteEvents'),
      projectId?: long(name='projectId'),
      pushEvents?: boolean(name='pushEvents'),
      secretToken?: string(name='secretToken'),
      tagPushEvents?: boolean(name='tagPushEvents'),
      url?: string(name='url'),
    }
  ](name='result'),
  success?: boolean(name='success'),
  total?: long(name='total'),
}

model ListRepositoryWebhookResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepositoryWebhookResponseBody(name='body'),
}

async function listRepositoryWebhook(repositoryId: string, request: ListRepositoryWebhookRequest): ListRepositoryWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryWebhookWithOptions(repositoryId, request, headers, runtime);
}

async function listRepositoryWebhookWithOptions(repositoryId: string, request: ListRepositoryWebhookRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryWebhookResponse {
  Util.validateModel(request);
  repositoryId = OpenApiUtil.getEncodeParam(repositoryId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['accessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['organizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepositoryWebhook',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/repository/${repositoryId}/webhooks/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListResourceMembersResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  resourceMembers?: [ 
    {
      accountId?: string(name='accountId'),
      roleName?: string(name='roleName'),
      username?: string(name='username'),
    }
  ](name='resourceMembers'),
  success?: boolean(name='success'),
}

model ListResourceMembersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceMembersResponseBody(name='body'),
}

async function listResourceMembers(organizationId: string, resourceType: string, resourceId: string): ListResourceMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourceMembersWithOptions(organizationId, resourceType, resourceId, headers, runtime);
}

async function listResourceMembersWithOptions(organizationId: string, resourceType: string, resourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListResourceMembersResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  resourceType = OpenApiUtil.getEncodeParam(resourceType);
  resourceId = OpenApiUtil.getEncodeParam(resourceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListResourceMembers',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/${resourceType}/${resourceId}/members`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListServiceConnectionsRequest {
  sericeConnectionType?: string(name='sericeConnectionType'),
}

model ListServiceConnectionsResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  serviceConnections?: [ 
    {
      createTime?: long(name='createTime'),
      id?: long(name='id'),
      name?: string(name='name'),
      ownerAccountId?: long(name='ownerAccountId'),
      type?: string(name='type'),
    }
  ](name='serviceConnections'),
  success?: boolean(name='success'),
}

model ListServiceConnectionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServiceConnectionsResponseBody(name='body'),
}

async function listServiceConnections(organizationId: string, request: ListServiceConnectionsRequest): ListServiceConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServiceConnectionsWithOptions(organizationId, request, headers, runtime);
}

async function listServiceConnectionsWithOptions(organizationId: string, request: ListServiceConnectionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListServiceConnectionsResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.sericeConnectionType)) {
    query['sericeConnectionType'] = request.sericeConnectionType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServiceConnections',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/serviceConnections`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListSprintsRequest {
  maxResults?: long(name='maxResults'),
  nextToken?: string(name='nextToken'),
  spaceIdentifier?: string(name='spaceIdentifier'),
  spaceType?: string(name='spaceType'),
}

model ListSprintsResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMsg?: string(name='errorMsg'),
  maxResults?: long(name='maxResults'),
  nextToken?: string(name='nextToken'),
  requestId?: string(name='requestId'),
  sprints?: [ 
    {
      creator?: string(name='creator'),
      description?: string(name='description'),
      endDate?: long(name='endDate'),
      gmtCreate?: long(name='gmtCreate'),
      gmtModified?: long(name='gmtModified'),
      identifier?: string(name='identifier'),
      modifier?: string(name='modifier'),
      name?: string(name='name'),
      scope?: string(name='scope'),
      spaceIdentifier?: string(name='spaceIdentifier'),
      startDate?: long(name='startDate'),
      status?: string(name='status'),
    }
  ](name='sprints'),
  success?: boolean(name='success'),
  totalCount?: long(name='totalCount'),
}

model ListSprintsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSprintsResponseBody(name='body'),
}

async function listSprints(organizationId: string, request: ListSprintsRequest): ListSprintsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSprintsWithOptions(organizationId, request, headers, runtime);
}

async function listSprintsWithOptions(organizationId: string, request: ListSprintsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSprintsResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.maxResults)) {
    query['maxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.spaceIdentifier)) {
    query['spaceIdentifier'] = request.spaceIdentifier;
  }
  if (!Util.isUnset(request.spaceType)) {
    query['spaceType'] = request.spaceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSprints',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/sprints/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListVariableGroupsRequest {
  maxResults?: int32(name='maxResults'),
  nextToken?: string(name='nextToken'),
  pageOrder?: string(name='pageOrder'),
  pageSort?: string(name='pageSort'),
}

model ListVariableGroupsResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  nextToken?: string(name='nextToken'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  totalCount?: long(name='totalCount'),
  variableGroups?: [ 
    {
      createTime?: long(name='createTime'),
      creatorAccountId?: string(name='creatorAccountId'),
      description?: string(name='description'),
      id?: long(name='id'),
      modifierAccountId?: string(name='modifierAccountId'),
      name?: string(name='name'),
      relatedPipelines?: [ 
        {
          id?: long(name='id'),
          name?: string(name='name'),
        }
      ](name='relatedPipelines'),
      updateTime?: long(name='updateTime'),
      variables?: [ 
        {
          isEncrypted?: boolean(name='isEncrypted'),
          name?: string(name='name'),
          value?: string(name='value'),
        }
      ](name='variables'),
    }
  ](name='variableGroups'),
}

model ListVariableGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVariableGroupsResponseBody(name='body'),
}

async function listVariableGroups(organizationId: string, request: ListVariableGroupsRequest): ListVariableGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listVariableGroupsWithOptions(organizationId, request, headers, runtime);
}

async function listVariableGroupsWithOptions(organizationId: string, request: ListVariableGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListVariableGroupsResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.maxResults)) {
    query['maxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.pageOrder)) {
    query['pageOrder'] = request.pageOrder;
  }
  if (!Util.isUnset(request.pageSort)) {
    query['pageSort'] = request.pageSort;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVariableGroups',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/variableGroups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListWorkItemAllFieldsRequest {
  spaceIdentifier?: string(name='spaceIdentifier'),
  spaceType?: string(name='spaceType'),
  workitemTypeIdentifier?: string(name='workitemTypeIdentifier'),
}

model ListWorkItemAllFieldsResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMsg?: string(name='errorMsg'),
  fields?: [ 
    {
      className?: string(name='className'),
      creator?: string(name='creator'),
      defaultValue?: string(name='defaultValue'),
      description?: string(name='description'),
      format?: string(name='format'),
      gmtCreate?: long(name='gmtCreate'),
      gmtModified?: long(name='gmtModified'),
      identifier?: string(name='identifier'),
      isRequired?: boolean(name='isRequired'),
      isShowWhenCreate?: boolean(name='isShowWhenCreate'),
      isSystemRequired?: boolean(name='isSystemRequired'),
      linkWithService?: string(name='linkWithService'),
      modifier?: string(name='modifier'),
      name?: string(name='name'),
      options?: [ 
        {
          displayValue?: string(name='displayValue'),
          fieldIdentifier?: string(name='fieldIdentifier'),
          identifier?: string(name='identifier'),
          level?: long(name='level'),
          position?: long(name='position'),
          value?: string(name='value'),
          valueEn?: string(name='valueEn'),
        }
      ](name='options'),
      resourceType?: string(name='resourceType'),
      type?: string(name='type'),
    }
  ](name='fields'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ListWorkItemAllFieldsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListWorkItemAllFieldsResponseBody(name='body'),
}

async function listWorkItemAllFields(organizationId: string, request: ListWorkItemAllFieldsRequest): ListWorkItemAllFieldsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listWorkItemAllFieldsWithOptions(organizationId, request, headers, runtime);
}

async function listWorkItemAllFieldsWithOptions(organizationId: string, request: ListWorkItemAllFieldsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListWorkItemAllFieldsResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.spaceIdentifier)) {
    query['spaceIdentifier'] = request.spaceIdentifier;
  }
  if (!Util.isUnset(request.spaceType)) {
    query['spaceType'] = request.spaceType;
  }
  if (!Util.isUnset(request.workitemTypeIdentifier)) {
    query['workitemTypeIdentifier'] = request.workitemTypeIdentifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListWorkItemAllFields',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/workitems/fields/listAll`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListWorkItemWorkFlowStatusRequest {
  spaceIdentifier?: string(name='spaceIdentifier'),
  spaceType?: string(name='spaceType'),
  workitemCategoryIdentifier?: string(name='workitemCategoryIdentifier'),
  workitemTypeIdentifier?: string(name='workitemTypeIdentifier'),
}

model ListWorkItemWorkFlowStatusResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  statuses?: [ 
    {
      creator?: string(name='creator'),
      description?: string(name='description'),
      gmtCreate?: long(name='gmtCreate'),
      gmtModified?: long(name='gmtModified'),
      identifier?: string(name='identifier'),
      modifier?: string(name='modifier'),
      name?: string(name='name'),
      resourceType?: string(name='resourceType'),
      source?: string(name='source'),
      workflowStageIdentifier?: string(name='workflowStageIdentifier'),
      workflowStageName?: string(name='workflowStageName'),
    }
  ](name='statuses'),
  success?: boolean(name='success'),
}

model ListWorkItemWorkFlowStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListWorkItemWorkFlowStatusResponseBody(name='body'),
}

async function listWorkItemWorkFlowStatus(organizationId: string, request: ListWorkItemWorkFlowStatusRequest): ListWorkItemWorkFlowStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listWorkItemWorkFlowStatusWithOptions(organizationId, request, headers, runtime);
}

async function listWorkItemWorkFlowStatusWithOptions(organizationId: string, request: ListWorkItemWorkFlowStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListWorkItemWorkFlowStatusResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.spaceIdentifier)) {
    query['spaceIdentifier'] = request.spaceIdentifier;
  }
  if (!Util.isUnset(request.spaceType)) {
    query['spaceType'] = request.spaceType;
  }
  if (!Util.isUnset(request.workitemCategoryIdentifier)) {
    query['workitemCategoryIdentifier'] = request.workitemCategoryIdentifier;
  }
  if (!Util.isUnset(request.workitemTypeIdentifier)) {
    query['workitemTypeIdentifier'] = request.workitemTypeIdentifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListWorkItemWorkFlowStatus',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/workitems/workflow/listWorkflowStatus`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListWorkitemTimeResponseBody = {
  code?: long(name='code'),
  errorCode?: string(name='errorCode'),
  errorMsg?: string(name='errorMsg'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  workitemTime?: [ 
    {
      actualTime?: long(name='actualTime'),
      description?: string(name='description'),
      gmtCreate?: long(name='gmtCreate'),
      gmtEnd?: long(name='gmtEnd'),
      gmtModified?: long(name='gmtModified'),
      gmtStart?: long(name='gmtStart'),
      identifier?: string(name='identifier'),
      recordUser?: string(name='recordUser'),
      type?: string(name='type'),
      workitemIdentifier?: string(name='workitemIdentifier'),
    }
  ](name='workitemTime'),
}

model ListWorkitemTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListWorkitemTimeResponseBody(name='body'),
}

async function listWorkitemTime(organizationId: string, workitemId: string): ListWorkitemTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listWorkitemTimeWithOptions(organizationId, workitemId, headers, runtime);
}

async function listWorkitemTimeWithOptions(organizationId: string, workitemId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListWorkitemTimeResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  workitemId = OpenApiUtil.getEncodeParam(workitemId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListWorkitemTime',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/workitems/${workitemId}/time/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListWorkitemsRequest {
  category?: string(name='category'),
  conditions?: string(name='conditions'),
  extraConditions?: string(name='extraConditions'),
  groupCondition?: string(name='groupCondition'),
  maxResults?: string(name='maxResults'),
  nextToken?: string(name='nextToken'),
  orderBy?: string(name='orderBy'),
  searchType?: string(name='searchType'),
  spaceIdentifier?: string(name='spaceIdentifier'),
  spaceType?: string(name='spaceType'),
}

model ListWorkitemsResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMsg?: string(name='errorMsg'),
  maxResults?: long(name='maxResults'),
  nextToken?: string(name='nextToken'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  totalCount?: long(name='totalCount'),
  workitems?: [ 
    {
      assignedTo?: string(name='assignedTo'),
      categoryIdentifier?: string(name='categoryIdentifier'),
      creator?: string(name='creator'),
      document?: string(name='document'),
      gmtCreate?: long(name='gmtCreate'),
      gmtModified?: long(name='gmtModified'),
      identifier?: string(name='identifier'),
      logicalStatus?: string(name='logicalStatus'),
      modifier?: string(name='modifier'),
      parentIdentifier?: string(name='parentIdentifier'),
      serialNumber?: string(name='serialNumber'),
      spaceIdentifier?: string(name='spaceIdentifier'),
      spaceName?: string(name='spaceName'),
      spaceType?: string(name='spaceType'),
      sprintIdentifier?: string(name='sprintIdentifier'),
      status?: string(name='status'),
      statusIdentifier?: string(name='statusIdentifier'),
      statusStageIdentifier?: string(name='statusStageIdentifier'),
      subject?: string(name='subject'),
      updateStatusAt?: long(name='updateStatusAt'),
      workitemTypeIdentifier?: string(name='workitemTypeIdentifier'),
    }
  ](name='workitems'),
}

model ListWorkitemsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListWorkitemsResponseBody(name='body'),
}

async function listWorkitems(organizationId: string, request: ListWorkitemsRequest): ListWorkitemsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listWorkitemsWithOptions(organizationId, request, headers, runtime);
}

async function listWorkitemsWithOptions(organizationId: string, request: ListWorkitemsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListWorkitemsResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.category)) {
    query['category'] = request.category;
  }
  if (!Util.isUnset(request.conditions)) {
    query['conditions'] = request.conditions;
  }
  if (!Util.isUnset(request.extraConditions)) {
    query['extraConditions'] = request.extraConditions;
  }
  if (!Util.isUnset(request.groupCondition)) {
    query['groupCondition'] = request.groupCondition;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['maxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.searchType)) {
    query['searchType'] = request.searchType;
  }
  if (!Util.isUnset(request.spaceIdentifier)) {
    query['spaceIdentifier'] = request.spaceIdentifier;
  }
  if (!Util.isUnset(request.spaceType)) {
    query['spaceType'] = request.spaceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListWorkitems',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/listWorkitems`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListWorkspacesRequest {
  maxResults?: int32(name='maxResults'),
  nextToken?: string(name='nextToken'),
  statusList?: [ string ](name='statusList'),
  workspaceTemplateList?: [ string ](name='workspaceTemplateList'),
}

model ListWorkspacesShrinkRequest {
  maxResults?: int32(name='maxResults'),
  nextToken?: string(name='nextToken'),
  statusListShrink?: string(name='statusList'),
  workspaceTemplateListShrink?: string(name='workspaceTemplateList'),
}

model ListWorkspacesResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  maxResults?: int32(name='maxResults'),
  nextToken?: string(name='nextToken'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  totalCount?: int32(name='totalCount'),
  workspaces?: [ 
    {
      codeUrl?: string(name='codeUrl'),
      codeVersion?: string(name='codeVersion'),
      createTime?: string(name='createTime'),
      id?: string(name='id'),
      name?: string(name='name'),
      spec?: string(name='spec'),
      status?: string(name='status'),
      template?: string(name='template'),
      userId?: string(name='userId'),
    }
  ](name='workspaces'),
}

model ListWorkspacesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListWorkspacesResponseBody(name='body'),
}

async function listWorkspaces(request: ListWorkspacesRequest): ListWorkspacesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listWorkspacesWithOptions(request, headers, runtime);
}

async function listWorkspacesWithOptions(tmpReq: ListWorkspacesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListWorkspacesResponse {
  Util.validateModel(tmpReq);
  var request = new ListWorkspacesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.statusList)) {
    request.statusListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.statusList, 'statusList', 'simple');
  }
  if (!Util.isUnset(tmpReq.workspaceTemplateList)) {
    request.workspaceTemplateListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.workspaceTemplateList, 'workspaceTemplateList', 'simple');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.maxResults)) {
    query['maxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.statusListShrink)) {
    query['statusList'] = request.statusListShrink;
  }
  if (!Util.isUnset(request.workspaceTemplateListShrink)) {
    query['workspaceTemplateList'] = request.workspaceTemplateListShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListWorkspaces',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/api/workspaces`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model LogPipelineJobRunResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  log?: {
    content?: string(name='content'),
    more?: boolean(name='more'),
  }(name='log'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model LogPipelineJobRunResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LogPipelineJobRunResponseBody(name='body'),
}

async function logPipelineJobRun(organizationId: string, pipelineId: string, jobId: string, pipelineRunId: string): LogPipelineJobRunResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return logPipelineJobRunWithOptions(organizationId, pipelineId, jobId, pipelineRunId, headers, runtime);
}

async function logPipelineJobRunWithOptions(organizationId: string, pipelineId: string, jobId: string, pipelineRunId: string, headers: map[string]string, runtime: Util.RuntimeOptions): LogPipelineJobRunResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  pipelineId = OpenApiUtil.getEncodeParam(pipelineId);
  jobId = OpenApiUtil.getEncodeParam(jobId);
  pipelineRunId = OpenApiUtil.getEncodeParam(pipelineRunId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'LogPipelineJobRun',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/pipeline/${pipelineId}/pipelineRun/${pipelineRunId}/job/${jobId}/logs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model LogVMDeployMachineResponseBody = {
  deployMachineLog?: {
    aliyunRegion?: string(name='aliyunRegion'),
    deployBeginTime?: long(name='deployBeginTime'),
    deployEndTime?: long(name='deployEndTime'),
    deployLog?: string(name='deployLog'),
    deployLogPath?: string(name='deployLogPath'),
  }(name='deployMachineLog'),
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model LogVMDeployMachineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LogVMDeployMachineResponseBody(name='body'),
}

async function logVMDeployMachine(organizationId: string, pipelineId: string, deployOrderId: string, machineSn: string): LogVMDeployMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return logVMDeployMachineWithOptions(organizationId, pipelineId, deployOrderId, machineSn, headers, runtime);
}

async function logVMDeployMachineWithOptions(organizationId: string, pipelineId: string, deployOrderId: string, machineSn: string, headers: map[string]string, runtime: Util.RuntimeOptions): LogVMDeployMachineResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  pipelineId = OpenApiUtil.getEncodeParam(pipelineId);
  deployOrderId = OpenApiUtil.getEncodeParam(deployOrderId);
  machineSn = OpenApiUtil.getEncodeParam(machineSn);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'LogVMDeployMachine',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/pipelines/${pipelineId}/deploy/${deployOrderId}/machine/${machineSn}/log`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PassPipelineValidateResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model PassPipelineValidateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PassPipelineValidateResponseBody(name='body'),
}

async function passPipelineValidate(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string): PassPipelineValidateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return passPipelineValidateWithOptions(organizationId, pipelineId, pipelineRunId, jobId, headers, runtime);
}

async function passPipelineValidateWithOptions(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string, headers: map[string]string, runtime: Util.RuntimeOptions): PassPipelineValidateResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  pipelineId = OpenApiUtil.getEncodeParam(pipelineId);
  pipelineRunId = OpenApiUtil.getEncodeParam(pipelineRunId);
  jobId = OpenApiUtil.getEncodeParam(jobId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'PassPipelineValidate',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/pipelines/${pipelineId}/pipelineRuns/${pipelineRunId}/jobs/${jobId}/pass`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RefusePipelineValidateResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model RefusePipelineValidateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefusePipelineValidateResponseBody(name='body'),
}

async function refusePipelineValidate(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string): RefusePipelineValidateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return refusePipelineValidateWithOptions(organizationId, pipelineId, pipelineRunId, jobId, headers, runtime);
}

async function refusePipelineValidateWithOptions(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string, headers: map[string]string, runtime: Util.RuntimeOptions): RefusePipelineValidateResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  pipelineId = OpenApiUtil.getEncodeParam(pipelineId);
  pipelineRunId = OpenApiUtil.getEncodeParam(pipelineRunId);
  jobId = OpenApiUtil.getEncodeParam(jobId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RefusePipelineValidate',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/pipelines/${pipelineId}/pipelineRuns/${pipelineRunId}/jobs/${jobId}/refuse`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ReleaseWorkspaceResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ReleaseWorkspaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReleaseWorkspaceResponseBody(name='body'),
}

async function releaseWorkspace(workspaceId: string): ReleaseWorkspaceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return releaseWorkspaceWithOptions(workspaceId, headers, runtime);
}

async function releaseWorkspaceWithOptions(workspaceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ReleaseWorkspaceResponse {
  workspaceId = OpenApiUtil.getEncodeParam(workspaceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ReleaseWorkspace',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/api/workspaces/${workspaceId}/release`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ResetSshKeyResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  sshKey?: {
    id?: long(name='id'),
    publicKey?: string(name='publicKey'),
  }(name='sshKey'),
  success?: boolean(name='success'),
}

model ResetSshKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResetSshKeyResponseBody(name='body'),
}

async function resetSshKey(organizationId: string): ResetSshKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return resetSshKeyWithOptions(organizationId, headers, runtime);
}

async function resetSshKeyWithOptions(organizationId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ResetSshKeyResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ResetSshKey',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/sshKey`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ResumeVMDeployOrderResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ResumeVMDeployOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResumeVMDeployOrderResponseBody(name='body'),
}

async function resumeVMDeployOrder(organizationId: string, pipelineId: string, deployOrderId: string): ResumeVMDeployOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return resumeVMDeployOrderWithOptions(organizationId, pipelineId, deployOrderId, headers, runtime);
}

async function resumeVMDeployOrderWithOptions(organizationId: string, pipelineId: string, deployOrderId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ResumeVMDeployOrderResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  pipelineId = OpenApiUtil.getEncodeParam(pipelineId);
  deployOrderId = OpenApiUtil.getEncodeParam(deployOrderId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ResumeVMDeployOrder',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/pipelines/${pipelineId}/deploy/${deployOrderId}/resume`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RetryPipelineJobRunResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model RetryPipelineJobRunResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RetryPipelineJobRunResponseBody(name='body'),
}

async function retryPipelineJobRun(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string): RetryPipelineJobRunResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return retryPipelineJobRunWithOptions(organizationId, pipelineId, pipelineRunId, jobId, headers, runtime);
}

async function retryPipelineJobRunWithOptions(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string, headers: map[string]string, runtime: Util.RuntimeOptions): RetryPipelineJobRunResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  pipelineId = OpenApiUtil.getEncodeParam(pipelineId);
  pipelineRunId = OpenApiUtil.getEncodeParam(pipelineRunId);
  jobId = OpenApiUtil.getEncodeParam(jobId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RetryPipelineJobRun',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/pipelines/${pipelineId}/pipelineRuns/${pipelineRunId}/jobs/${jobId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RetryVMDeployMachineResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model RetryVMDeployMachineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RetryVMDeployMachineResponseBody(name='body'),
}

async function retryVMDeployMachine(organizationId: string, pipelineId: string, deployOrderId: string, machineSn: string): RetryVMDeployMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return retryVMDeployMachineWithOptions(organizationId, pipelineId, deployOrderId, machineSn, headers, runtime);
}

async function retryVMDeployMachineWithOptions(organizationId: string, pipelineId: string, deployOrderId: string, machineSn: string, headers: map[string]string, runtime: Util.RuntimeOptions): RetryVMDeployMachineResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  pipelineId = OpenApiUtil.getEncodeParam(pipelineId);
  deployOrderId = OpenApiUtil.getEncodeParam(deployOrderId);
  machineSn = OpenApiUtil.getEncodeParam(machineSn);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RetryVMDeployMachine',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/pipelines/${pipelineId}/deploy/${deployOrderId}/machine/${machineSn}/retry`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model SkipPipelineJobRunResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model SkipPipelineJobRunResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SkipPipelineJobRunResponseBody(name='body'),
}

async function skipPipelineJobRun(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string): SkipPipelineJobRunResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return skipPipelineJobRunWithOptions(organizationId, pipelineId, pipelineRunId, jobId, headers, runtime);
}

async function skipPipelineJobRunWithOptions(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string, headers: map[string]string, runtime: Util.RuntimeOptions): SkipPipelineJobRunResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  pipelineId = OpenApiUtil.getEncodeParam(pipelineId);
  pipelineRunId = OpenApiUtil.getEncodeParam(pipelineRunId);
  jobId = OpenApiUtil.getEncodeParam(jobId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'SkipPipelineJobRun',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/pipelines/${pipelineId}/pipelineRuns/${pipelineRunId}/jobs/${jobId}/skip`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model SkipVMDeployMachineResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model SkipVMDeployMachineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SkipVMDeployMachineResponseBody(name='body'),
}

async function skipVMDeployMachine(organizationId: string, pipelineId: string, deployOrderId: string, machineSn: string): SkipVMDeployMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return skipVMDeployMachineWithOptions(organizationId, pipelineId, deployOrderId, machineSn, headers, runtime);
}

async function skipVMDeployMachineWithOptions(organizationId: string, pipelineId: string, deployOrderId: string, machineSn: string, headers: map[string]string, runtime: Util.RuntimeOptions): SkipVMDeployMachineResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  pipelineId = OpenApiUtil.getEncodeParam(pipelineId);
  deployOrderId = OpenApiUtil.getEncodeParam(deployOrderId);
  machineSn = OpenApiUtil.getEncodeParam(machineSn);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'SkipVMDeployMachine',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/pipelines/${pipelineId}/deploy/${deployOrderId}/machine/${machineSn}/skip`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StartPipelineRunRequest {
  params?: string(name='params'),
}

model StartPipelineRunResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  pipelineRunId?: long(name='pipelineRunId'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model StartPipelineRunResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartPipelineRunResponseBody(name='body'),
}

async function startPipelineRun(organizationId: string, pipelineId: string, request: StartPipelineRunRequest): StartPipelineRunResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startPipelineRunWithOptions(organizationId, pipelineId, request, headers, runtime);
}

async function startPipelineRunWithOptions(organizationId: string, pipelineId: string, request: StartPipelineRunRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StartPipelineRunResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  pipelineId = OpenApiUtil.getEncodeParam(pipelineId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.params)) {
    body['params'] = request.params;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartPipelineRun',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organizations/${organizationId}/pipelines/${pipelineId}/run`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopPipelineJobRunResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model StopPipelineJobRunResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopPipelineJobRunResponseBody(name='body'),
}

async function stopPipelineJobRun(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string): StopPipelineJobRunResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopPipelineJobRunWithOptions(organizationId, pipelineId, pipelineRunId, jobId, headers, runtime);
}

async function stopPipelineJobRunWithOptions(organizationId: string, pipelineId: string, pipelineRunId: string, jobId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopPipelineJobRunResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  pipelineId = OpenApiUtil.getEncodeParam(pipelineId);
  pipelineRunId = OpenApiUtil.getEncodeParam(pipelineRunId);
  jobId = OpenApiUtil.getEncodeParam(jobId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopPipelineJobRun',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/pipelines/${pipelineId}/pipelineRuns/${pipelineRunId}/jobs/${jobId}/stop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopPipelineRunResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model StopPipelineRunResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopPipelineRunResponseBody(name='body'),
}

async function stopPipelineRun(organizationId: string, pipelineId: string, pipelineRunId: string): StopPipelineRunResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopPipelineRunWithOptions(organizationId, pipelineId, pipelineRunId, headers, runtime);
}

async function stopPipelineRunWithOptions(organizationId: string, pipelineId: string, pipelineRunId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopPipelineRunResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  pipelineId = OpenApiUtil.getEncodeParam(pipelineId);
  pipelineRunId = OpenApiUtil.getEncodeParam(pipelineRunId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopPipelineRun',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/pipelines/${pipelineId}/pipelineRuns/${pipelineRunId}/stop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopVMDeployOrderResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model StopVMDeployOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopVMDeployOrderResponseBody(name='body'),
}

async function stopVMDeployOrder(organizationId: string, pipelineId: string, deployOrderId: string): StopVMDeployOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopVMDeployOrderWithOptions(organizationId, pipelineId, deployOrderId, headers, runtime);
}

async function stopVMDeployOrderWithOptions(organizationId: string, pipelineId: string, deployOrderId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopVMDeployOrderResponse {
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  pipelineId = OpenApiUtil.getEncodeParam(pipelineId);
  deployOrderId = OpenApiUtil.getEncodeParam(deployOrderId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopVMDeployOrder',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/pipelines/${pipelineId}/deploy/${deployOrderId}/stop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model TriggerRepositoryMirrorSyncRequest {
  accessToken?: string(name='accessToken'),
  account?: string(name='account'),
  organizationId?: string(name='organizationId'),
  token?: string(name='token'),
}

model TriggerRepositoryMirrorSyncResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  result?: {
    result?: boolean(name='result'),
  }(name='result'),
  success?: boolean(name='success'),
}

model TriggerRepositoryMirrorSyncResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TriggerRepositoryMirrorSyncResponseBody(name='body'),
}

async function triggerRepositoryMirrorSync(repositoryId: string, request: TriggerRepositoryMirrorSyncRequest): TriggerRepositoryMirrorSyncResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return triggerRepositoryMirrorSyncWithOptions(repositoryId, request, headers, runtime);
}

async function triggerRepositoryMirrorSyncWithOptions(repositoryId: string, request: TriggerRepositoryMirrorSyncRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TriggerRepositoryMirrorSyncResponse {
  Util.validateModel(request);
  repositoryId = OpenApiUtil.getEncodeParam(repositoryId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['accessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.account)) {
    query['account'] = request.account;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['organizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.token)) {
    query['token'] = request.token;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TriggerRepositoryMirrorSync',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/repository/${repositoryId}/mirror`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateFlowTagRequest {
  color?: string(name='color'),
  flowTagGroupId?: long(name='flowTagGroupId'),
  name?: string(name='name'),
}

model UpdateFlowTagResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model UpdateFlowTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateFlowTagResponseBody(name='body'),
}

async function updateFlowTag(organizationId: string, id: string, request: UpdateFlowTagRequest): UpdateFlowTagResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFlowTagWithOptions(organizationId, id, request, headers, runtime);
}

async function updateFlowTagWithOptions(organizationId: string, id: string, request: UpdateFlowTagRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFlowTagResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  id = OpenApiUtil.getEncodeParam(id);
  var query : map[string]any = {};
  if (!Util.isUnset(request.color)) {
    query['color'] = request.color;
  }
  if (!Util.isUnset(request.flowTagGroupId)) {
    query['flowTagGroupId'] = request.flowTagGroupId;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFlowTag',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/flow/tags/${id}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateFlowTagGroupRequest {
  name?: string(name='name'),
}

model UpdateFlowTagGroupResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model UpdateFlowTagGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateFlowTagGroupResponseBody(name='body'),
}

async function updateFlowTagGroup(organizationId: string, id: string, request: UpdateFlowTagGroupRequest): UpdateFlowTagGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFlowTagGroupWithOptions(organizationId, id, request, headers, runtime);
}

async function updateFlowTagGroupWithOptions(organizationId: string, id: string, request: UpdateFlowTagGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFlowTagGroupResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  id = OpenApiUtil.getEncodeParam(id);
  var query : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFlowTagGroup',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/flow/tagGroups/${id}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateHostGroupRequest {
  aliyunRegion?: string(name='aliyunRegion'),
  ecsLabelKey?: string(name='ecsLabelKey'),
  ecsLabelValue?: string(name='ecsLabelValue'),
  ecsType?: string(name='ecsType'),
  envId?: string(name='envId'),
  machineInfos?: string(name='machineInfos'),
  name?: string(name='name'),
  serviceConnectionId?: long(name='serviceConnectionId'),
  tagIds?: string(name='tagIds'),
  type?: string(name='type'),
}

model UpdateHostGroupResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model UpdateHostGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateHostGroupResponseBody(name='body'),
}

async function updateHostGroup(organizationId: string, id: string, request: UpdateHostGroupRequest): UpdateHostGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateHostGroupWithOptions(organizationId, id, request, headers, runtime);
}

async function updateHostGroupWithOptions(organizationId: string, id: string, request: UpdateHostGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateHostGroupResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  id = OpenApiUtil.getEncodeParam(id);
  var body : map[string]any = {};
  if (!Util.isUnset(request.aliyunRegion)) {
    body['aliyunRegion'] = request.aliyunRegion;
  }
  if (!Util.isUnset(request.ecsLabelKey)) {
    body['ecsLabelKey'] = request.ecsLabelKey;
  }
  if (!Util.isUnset(request.ecsLabelValue)) {
    body['ecsLabelValue'] = request.ecsLabelValue;
  }
  if (!Util.isUnset(request.ecsType)) {
    body['ecsType'] = request.ecsType;
  }
  if (!Util.isUnset(request.envId)) {
    body['envId'] = request.envId;
  }
  if (!Util.isUnset(request.machineInfos)) {
    body['machineInfos'] = request.machineInfos;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.serviceConnectionId)) {
    body['serviceConnectionId'] = request.serviceConnectionId;
  }
  if (!Util.isUnset(request.tagIds)) {
    body['tagIds'] = request.tagIds;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHostGroup',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/hostGroups/${id}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdatePipelineBaseInfoRequest {
  envId?: long(name='envId'),
  pipelineName?: string(name='pipelineName'),
  tagList?: string(name='tagList'),
}

model UpdatePipelineBaseInfoResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model UpdatePipelineBaseInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePipelineBaseInfoResponseBody(name='body'),
}

async function updatePipelineBaseInfo(organizationId: string, pipelineId: string, request: UpdatePipelineBaseInfoRequest): UpdatePipelineBaseInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePipelineBaseInfoWithOptions(organizationId, pipelineId, request, headers, runtime);
}

async function updatePipelineBaseInfoWithOptions(organizationId: string, pipelineId: string, request: UpdatePipelineBaseInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePipelineBaseInfoResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  pipelineId = OpenApiUtil.getEncodeParam(pipelineId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.envId)) {
    query['envId'] = request.envId;
  }
  if (!Util.isUnset(request.pipelineName)) {
    query['pipelineName'] = request.pipelineName;
  }
  if (!Util.isUnset(request.tagList)) {
    query['tagList'] = request.tagList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePipelineBaseInfo',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/pipelines/${pipelineId}/baseInfo`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateProjectMemberRequest {
  roleIdentifier?: string(name='roleIdentifier'),
  targetIdentifier?: string(name='targetIdentifier'),
  targetType?: string(name='targetType'),
  userIdentifier?: string(name='userIdentifier'),
  userType?: string(name='userType'),
}

model UpdateProjectMemberResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMsg?: string(name='errorMsg'),
  member?: {
    gmtCreate?: long(name='gmtCreate'),
    gmtModified?: long(name='gmtModified'),
    id?: string(name='id'),
    roleIdentifier?: string(name='roleIdentifier'),
    targetIdentifier?: string(name='targetIdentifier'),
    targetType?: string(name='targetType'),
    userIdentifier?: string(name='userIdentifier'),
    userType?: string(name='userType'),
  }(name='member'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model UpdateProjectMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateProjectMemberResponseBody(name='body'),
}

async function updateProjectMember(organizationId: string, projectId: string, request: UpdateProjectMemberRequest): UpdateProjectMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProjectMemberWithOptions(organizationId, projectId, request, headers, runtime);
}

async function updateProjectMemberWithOptions(organizationId: string, projectId: string, request: UpdateProjectMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProjectMemberResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  projectId = OpenApiUtil.getEncodeParam(projectId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.roleIdentifier)) {
    body['roleIdentifier'] = request.roleIdentifier;
  }
  if (!Util.isUnset(request.targetIdentifier)) {
    body['targetIdentifier'] = request.targetIdentifier;
  }
  if (!Util.isUnset(request.targetType)) {
    body['targetType'] = request.targetType;
  }
  if (!Util.isUnset(request.userIdentifier)) {
    body['userIdentifier'] = request.userIdentifier;
  }
  if (!Util.isUnset(request.userType)) {
    body['userType'] = request.userType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProjectMember',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/projects/${projectId}/updateMember`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateResourceMemberRequest {
  roleName?: string(name='roleName'),
}

model UpdateResourceMemberResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model UpdateResourceMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateResourceMemberResponseBody(name='body'),
}

async function updateResourceMember(organizationId: string, resourceType: string, resourceId: string, accountId: string, request: UpdateResourceMemberRequest): UpdateResourceMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateResourceMemberWithOptions(organizationId, resourceType, resourceId, accountId, request, headers, runtime);
}

async function updateResourceMemberWithOptions(organizationId: string, resourceType: string, resourceId: string, accountId: string, request: UpdateResourceMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateResourceMemberResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  resourceType = OpenApiUtil.getEncodeParam(resourceType);
  resourceId = OpenApiUtil.getEncodeParam(resourceId);
  accountId = OpenApiUtil.getEncodeParam(accountId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.roleName)) {
    body['roleName'] = request.roleName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateResourceMember',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/${resourceType}/${resourceId}/members/${accountId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateVariableGroupRequest {
  description?: string(name='description'),
  name?: string(name='name'),
  variables?: string(name='variables'),
}

model UpdateVariableGroupResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model UpdateVariableGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateVariableGroupResponseBody(name='body'),
}

async function updateVariableGroup(organizationId: string, id: string, request: UpdateVariableGroupRequest): UpdateVariableGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateVariableGroupWithOptions(organizationId, id, request, headers, runtime);
}

async function updateVariableGroupWithOptions(organizationId: string, id: string, request: UpdateVariableGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateVariableGroupResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  id = OpenApiUtil.getEncodeParam(id);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.variables)) {
    body['variables'] = request.variables;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateVariableGroup',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/variableGroups/${id}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateWorkItemRequest {
  fieldType?: string(name='fieldType'),
  identifier?: string(name='identifier'),
  propertyKey?: string(name='propertyKey'),
  propertyValue?: string(name='propertyValue'),
}

model UpdateWorkItemResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  workitem?: {
    assignedTo?: string(name='assignedTo'),
    categoryIdentifier?: string(name='categoryIdentifier'),
    creator?: string(name='creator'),
    document?: string(name='document'),
    gmtCreate?: long(name='gmtCreate'),
    gmtModified?: long(name='gmtModified'),
    identifier?: string(name='identifier'),
    logicalStatus?: string(name='logicalStatus'),
    modifier?: string(name='modifier'),
    parentIdentifier?: string(name='parentIdentifier'),
    serialNumber?: string(name='serialNumber'),
    spaceIdentifier?: string(name='spaceIdentifier'),
    spaceName?: string(name='spaceName'),
    spaceType?: string(name='spaceType'),
    sprintIdentifier?: string(name='sprintIdentifier'),
    status?: string(name='status'),
    statusIdentifier?: string(name='statusIdentifier'),
    statusStageIdentifier?: string(name='statusStageIdentifier'),
    subject?: string(name='subject'),
    updateStatusAt?: long(name='updateStatusAt'),
    workitemTypeIdentifier?: string(name='workitemTypeIdentifier'),
  }(name='workitem'),
}

model UpdateWorkItemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateWorkItemResponseBody(name='body'),
}

async function updateWorkItem(organizationId: string, request: UpdateWorkItemRequest): UpdateWorkItemResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateWorkItemWithOptions(organizationId, request, headers, runtime);
}

async function updateWorkItemWithOptions(organizationId: string, request: UpdateWorkItemRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateWorkItemResponse {
  Util.validateModel(request);
  organizationId = OpenApiUtil.getEncodeParam(organizationId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.fieldType)) {
    body['fieldType'] = request.fieldType;
  }
  if (!Util.isUnset(request.identifier)) {
    body['identifier'] = request.identifier;
  }
  if (!Util.isUnset(request.propertyKey)) {
    body['propertyKey'] = request.propertyKey;
  }
  if (!Util.isUnset(request.propertyValue)) {
    body['propertyValue'] = request.propertyValue;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWorkItem',
    version = '2021-06-25',
    protocol = 'HTTPS',
    pathname = `/organization/${organizationId}/workitems/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

