/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('paielasticdatasetaccelerator', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model EndpointStatus {
  code?: string(name='Code'),
  detail?: EndpointStatusDetail(name='Detail'),
  message?: string(name='Message'),
  phase?: string(name='Phase'),
}

model EndpointStatusDetail {
  ipPortMapping?: map[string]any(name='IpPortMapping'),
}

model InstanceLifeCycle {
  config?: string(name='Config'),
  type?: string(name='Type'),
}

model InstanceStatus {
  code?: string(name='Code'),
  message?: string(name='Message'),
  phase?: string(name='Phase'),
  slotNum?: int32(name='SlotNum'),
  usedCapacity?: string(name='UsedCapacity'),
}

model Metric {
  timestamp?: string(name='Timestamp'),
  value?: double(name='Value'),
}

model SlotLifeCycle {
  config?: string(name='Config'),
  type?: string(name='Type'),
}

model SlotStatus {
  code?: string(name='Code'),
  detail?: SlotStatusDetail(name='Detail'),
  message?: string(name='Message'),
  phase?: string(name='Phase'),
}

model SlotStatusDetail {
  loadedFileNum?: long(name='LoadedFileNum'),
  loadedFileSize?: string(name='LoadedFileSize'),
  loadingTimeCost?: long(name='LoadingTimeCost'),
}

model BindEndpointResponseBody = {
  requestId?: string(name='RequestId'),
}

model BindEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BindEndpointResponseBody(name='body'),
}

async function bindEndpoint(EndpointId: string, SlotId: string): BindEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return bindEndpointWithOptions(EndpointId, SlotId, headers, runtime);
}

async function bindEndpointWithOptions(EndpointId: string, SlotId: string, headers: map[string]string, runtime: Util.RuntimeOptions): BindEndpointResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'BindEndpoint',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/api/v1/endpoints/${OpenApiUtil.getEncodeParam(EndpointId)}/slots/${OpenApiUtil.getEncodeParam(SlotId)}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateEndpointRequest {
  name?: string(name='Name'),
  type?: string(name='Type'),
  vpcId?: string(name='VpcId'),
  vswitchId?: string(name='VswitchId'),
}

model CreateEndpointResponseBody = {
  endpointId?: string(name='EndpointId'),
  requestId?: string(name='RequestId'),
}

model CreateEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateEndpointResponseBody(name='body'),
}

async function createEndpoint(request: CreateEndpointRequest): CreateEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createEndpointWithOptions(request, headers, runtime);
}

async function createEndpointWithOptions(request: CreateEndpointRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateEndpointResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  if (!Util.isUnset(request.vpcId)) {
    body['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.vswitchId)) {
    body['VswitchId'] = request.vswitchId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateEndpoint',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/api/v1/endpoints`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateInstanceRequest {
  capacity?: string(name='Capacity'),
  description?: string(name='Description'),
  maxSlot?: string(name='MaxSlot'),
  name?: string(name='Name'),
  paymentType?: string(name='PaymentType'),
  tags?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags'),
  type?: string(name='Type'),
}

model CreateInstanceResponseBody = {
  instanceId?: string(name='InstanceId'),
  requestId?: string(name='RequestId'),
}

model CreateInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateInstanceResponseBody(name='body'),
}

async function createInstance(request: CreateInstanceRequest): CreateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createInstanceWithOptions(request, headers, runtime);
}

async function createInstanceWithOptions(request: CreateInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.capacity)) {
    body['Capacity'] = request.capacity;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.maxSlot)) {
    body['MaxSlot'] = request.maxSlot;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.paymentType)) {
    body['PaymentType'] = request.paymentType;
  }
  if (!Util.isUnset(request.tags)) {
    body['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateInstance',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/api/v1/instances`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateSlotRequest {
  capacity?: string(name='Capacity'),
  description?: string(name='Description'),
  endpointIds?: string(name='EndpointIds'),
  endpoints?: [ 
    {
      name?: string(name='Name'),
      type?: string(name='Type'),
      vpcId?: string(name='VpcId'),
      vswitchId?: string(name='VswitchId'),
    }
  ](name='Endpoints'),
  instanceId?: string(name='InstanceId'),
  lifeCycle?: SlotLifeCycle(name='LifeCycle'),
  name?: string(name='Name'),
  storageType?: string(name='StorageType'),
  storageUri?: string(name='StorageUri'),
  tags?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags'),
}

model CreateSlotResponseBody = {
  requestId?: string(name='RequestId'),
  slotId?: string(name='SlotId'),
}

model CreateSlotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSlotResponseBody(name='body'),
}

async function createSlot(request: CreateSlotRequest): CreateSlotResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSlotWithOptions(request, headers, runtime);
}

async function createSlotWithOptions(request: CreateSlotRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSlotResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.capacity)) {
    body['Capacity'] = request.capacity;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.endpointIds)) {
    body['EndpointIds'] = request.endpointIds;
  }
  if (!Util.isUnset(request.endpoints)) {
    body['Endpoints'] = request.endpoints;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lifeCycle)) {
    body['LifeCycle'] = request.lifeCycle;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.storageType)) {
    body['StorageType'] = request.storageType;
  }
  if (!Util.isUnset(request.storageUri)) {
    body['StorageUri'] = request.storageUri;
  }
  if (!Util.isUnset(request.tags)) {
    body['Tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSlot',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/api/v1/slots`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateTagRequest {
  key?: string(name='Key'),
  resourceId?: string(name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  value?: string(name='Value'),
}

model CreateTagResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTagResponseBody(name='body'),
}

async function createTag(request: CreateTagRequest): CreateTagResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTagWithOptions(request, headers, runtime);
}

async function createTagWithOptions(request: CreateTagRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTagResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.key)) {
    body['Key'] = request.key;
  }
  if (!Util.isUnset(request.resourceId)) {
    body['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.value)) {
    body['Value'] = request.value;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTag',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/api/v1/tags`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteInstanceResponseBody(name='body'),
}

async function deleteInstance(InstanceId: string): DeleteInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteInstanceWithOptions(InstanceId, headers, runtime);
}

async function deleteInstanceWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteInstanceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteInstance',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/api/v1/instances/${OpenApiUtil.getEncodeParam(InstanceId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteSlotResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSlotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSlotResponseBody(name='body'),
}

async function deleteSlot(SlotId: string): DeleteSlotResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSlotWithOptions(SlotId, headers, runtime);
}

async function deleteSlotWithOptions(SlotId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteSlotResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteSlot',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/api/v1/slots/${OpenApiUtil.getEncodeParam(SlotId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteTagRequest {
  key?: string(name='Key'),
  resourceId?: string(name='ResourceId'),
  resourceType?: string(name='ResourceType'),
}

model DeleteTagResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTagResponseBody(name='body'),
}

async function deleteTag(request: DeleteTagRequest): DeleteTagResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTagWithOptions(request, headers, runtime);
}

async function deleteTagWithOptions(request: DeleteTagRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTagResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTag',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/api/v1/tags`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeComponentRequest {
  renderTemplate?: boolean(name='RenderTemplate'),
  values?: map[string]any(name='Values'),
}

model DescribeComponentShrinkRequest {
  renderTemplate?: boolean(name='RenderTemplate'),
  valuesShrink?: string(name='Values'),
}

model DescribeComponentResponseBody = {
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  name?: string(name='Name'),
  ownerId?: string(name='OwnerId'),
  renderedContent?: string(name='RenderedContent'),
  requestId?: string(name='RequestId'),
  template?: {
    type?: string(name='Type'),
    uri?: string(name='Uri'),
  }(name='Template'),
  userId?: string(name='UserId'),
  uuid?: string(name='Uuid'),
  version?: string(name='Version'),
}

model DescribeComponentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeComponentResponseBody(name='body'),
}

async function describeComponent(ComponentId: string, request: DescribeComponentRequest): DescribeComponentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeComponentWithOptions(ComponentId, request, headers, runtime);
}

async function describeComponentWithOptions(ComponentId: string, tmpReq: DescribeComponentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeComponentResponse {
  Util.validateModel(tmpReq);
  var request = new DescribeComponentShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.values)) {
    request.valuesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.values, 'Values', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.renderTemplate)) {
    query['RenderTemplate'] = request.renderTemplate;
  }
  if (!Util.isUnset(request.valuesShrink)) {
    query['Values'] = request.valuesShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeComponent',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/api/v1/components/${OpenApiUtil.getEncodeParam(ComponentId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeEndpointResponseBody = {
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  name?: string(name='Name'),
  ownerId?: string(name='OwnerId'),
  requestId?: string(name='RequestId'),
  status?: EndpointStatus(name='Status'),
  type?: string(name='Type'),
  userId?: string(name='UserId'),
  uuid?: string(name='Uuid'),
  vpcId?: string(name='VpcId'),
  vswitchId?: string(name='VswitchId'),
}

model DescribeEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEndpointResponseBody(name='body'),
}

async function describeEndpoint(EndpointId: string): DescribeEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeEndpointWithOptions(EndpointId, headers, runtime);
}

async function describeEndpointWithOptions(EndpointId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeEndpointResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeEndpoint',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/api/v1/endpoints/${OpenApiUtil.getEncodeParam(EndpointId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeInstanceResponseBody = {
  capacity?: string(name='Capacity'),
  description?: string(name='Description'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  maxSlot?: int32(name='MaxSlot'),
  name?: string(name='Name'),
  ownerId?: string(name='OwnerId'),
  paymentType?: string(name='PaymentType'),
  requestId?: string(name='RequestId'),
  status?: InstanceStatus(name='Status'),
  tags?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags'),
  type?: string(name='Type'),
  userId?: string(name='UserId'),
  uuid?: string(name='Uuid'),
}

model DescribeInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceResponseBody(name='body'),
}

async function describeInstance(InstanceId: string): DescribeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeInstanceWithOptions(InstanceId, headers, runtime);
}

async function describeInstanceWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeInstanceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstance',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/api/v1/instances/${OpenApiUtil.getEncodeParam(InstanceId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeSlotResponseBody = {
  capacity?: string(name='Capacity'),
  description?: string(name='Description'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  instanceId?: string(name='InstanceId'),
  lifeCycle?: SlotLifeCycle(name='LifeCycle'),
  name?: string(name='Name'),
  ownerId?: string(name='OwnerId'),
  requestId?: string(name='RequestId'),
  status?: SlotStatus(name='Status'),
  storageType?: string(name='StorageType'),
  storageUri?: string(name='StorageUri'),
  tags?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags'),
  userId?: string(name='UserId'),
  uuid?: string(name='Uuid'),
}

model DescribeSlotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSlotResponseBody(name='body'),
}

async function describeSlot(SlotId: string): DescribeSlotResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeSlotWithOptions(SlotId, headers, runtime);
}

async function describeSlotWithOptions(SlotId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeSlotResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeSlot',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/api/v1/slots/${OpenApiUtil.getEncodeParam(SlotId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListComponentsRequest {
  componentIds?: string(name='ComponentIds'),
  name?: string(name='Name'),
  order?: string(name='Order'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  sortBy?: string(name='SortBy'),
  version?: string(name='Version'),
}

model ListComponentsResponseBody = {
  components?: [ 
    {
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      name?: string(name='Name'),
      ownerId?: string(name='OwnerId'),
      template?: {
        type?: string(name='Type'),
        uri?: string(name='Uri'),
      }(name='Template'),
      userId?: string(name='UserId'),
      uuid?: string(name='Uuid'),
      version?: string(name='Version'),
    }
  ](name='Components'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListComponentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListComponentsResponseBody(name='body'),
}

async function listComponents(request: ListComponentsRequest): ListComponentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listComponentsWithOptions(request, headers, runtime);
}

async function listComponentsWithOptions(request: ListComponentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListComponentsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.componentIds)) {
    query['ComponentIds'] = request.componentIds;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListComponents',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/api/v1/components`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListEndpointsRequest {
  endpointIds?: string(name='EndpointIds'),
  name?: string(name='Name'),
  order?: string(name='Order'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  slotIds?: string(name='SlotIds'),
  sortBy?: string(name='SortBy'),
  type?: string(name='Type'),
}

model ListEndpointsResponseBody = {
  endpoints?: [ 
    {
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      name?: string(name='Name'),
      ownerId?: string(name='OwnerId'),
      status?: EndpointStatus(name='Status'),
      type?: string(name='Type'),
      userId?: string(name='UserId'),
      uuid?: string(name='Uuid'),
      vpcId?: string(name='VpcId'),
      vswitchId?: string(name='VswitchId'),
    }
  ](name='Endpoints'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListEndpointsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEndpointsResponseBody(name='body'),
}

async function listEndpoints(request: ListEndpointsRequest): ListEndpointsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEndpointsWithOptions(request, headers, runtime);
}

async function listEndpointsWithOptions(request: ListEndpointsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListEndpointsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endpointIds)) {
    query['EndpointIds'] = request.endpointIds;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.slotIds)) {
    query['SlotIds'] = request.slotIds;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEndpoints',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/api/v1/endpoints`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListInstancesRequest {
  instanceIds?: string(name='InstanceIds'),
  name?: string(name='Name'),
  order?: string(name='Order'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  paymentType?: string(name='PaymentType'),
  phase?: string(name='Phase'),
  sortBy?: string(name='SortBy'),
  type?: string(name='Type'),
}

model ListInstancesResponseBody = {
  instances?: [ 
    {
      capacity?: string(name='Capacity'),
      description?: string(name='Description'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      maxSlot?: int32(name='MaxSlot'),
      name?: string(name='Name'),
      ownerId?: string(name='OwnerId'),
      paymentType?: string(name='PaymentType'),
      status?: InstanceStatus(name='Status'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      type?: string(name='Type'),
      userId?: string(name='UserId'),
      uuid?: string(name='Uuid'),
    }
  ](name='Instances'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstancesResponseBody(name='body'),
}

async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstancesWithOptions(request, headers, runtime);
}

async function listInstancesWithOptions(request: ListInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.paymentType)) {
    query['PaymentType'] = request.paymentType;
  }
  if (!Util.isUnset(request.phase)) {
    query['Phase'] = request.phase;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstances',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/api/v1/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListSlotsRequest {
  instanceIds?: string(name='InstanceIds'),
  name?: string(name='Name'),
  order?: string(name='Order'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  phase?: string(name='Phase'),
  slotIds?: string(name='SlotIds'),
  sortBy?: string(name='SortBy'),
  storageType?: string(name='StorageType'),
}

model ListSlotsResponseBody = {
  requestId?: string(name='RequestId'),
  slots?: [ 
    {
      capacity?: string(name='Capacity'),
      description?: string(name='Description'),
      endpoints?: [ 
        {
          gmtCreateTime?: string(name='GmtCreateTime'),
          gmtModifiedTime?: string(name='GmtModifiedTime'),
          name?: string(name='Name'),
          ownerId?: string(name='OwnerId'),
          status?: EndpointStatus(name='Status'),
          type?: string(name='Type'),
          userId?: string(name='UserId'),
          uuid?: string(name='Uuid'),
          vpcId?: string(name='VpcId'),
          vswitchId?: string(name='VswitchId'),
        }
      ](name='Endpoints'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      instanceId?: string(name='InstanceId'),
      lifeCycle?: SlotLifeCycle(name='LifeCycle'),
      name?: string(name='Name'),
      ownerId?: string(name='OwnerId'),
      status?: SlotStatus(name='Status'),
      storageType?: string(name='StorageType'),
      storageUri?: string(name='StorageUri'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      userId?: string(name='UserId'),
      uuid?: string(name='Uuid'),
    }
  ](name='Slots'),
  totalCount?: int32(name='TotalCount'),
}

model ListSlotsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSlotsResponseBody(name='body'),
}

async function listSlots(request: ListSlotsRequest): ListSlotsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSlotsWithOptions(request, headers, runtime);
}

async function listSlotsWithOptions(request: ListSlotsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSlotsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.phase)) {
    query['Phase'] = request.phase;
  }
  if (!Util.isUnset(request.slotIds)) {
    query['SlotIds'] = request.slotIds;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.storageType)) {
    query['StorageType'] = request.storageType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSlots',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/api/v1/slots`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTagsRequest {
  key?: string(name='Key'),
  order?: string(name='Order'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceId?: string(name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  sortBy?: string(name='SortBy'),
  value?: string(name='Value'),
}

model ListTagsResponseBody = {
  requestId?: string(name='RequestId'),
  tags?: [ 
    {
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      key?: string(name='Key'),
      ownerId?: string(name='OwnerId'),
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      userId?: string(name='UserId'),
      value?: string(name='Value'),
    }
  ](name='Tags'),
  totalCount?: int32(name='TotalCount'),
}

model ListTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagsResponseBody(name='body'),
}

async function listTags(request: ListTagsRequest): ListTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagsWithOptions(request, headers, runtime);
}

async function listTagsWithOptions(request: ListTagsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTags',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/api/v1/tags`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model QueryInstanceMetricsRequest {
  dimensions?: map[string]any(name='Dimensions'),
  endTime?: string(name='EndTime'),
  metricType?: string(name='MetricType'),
  startTime?: string(name='StartTime'),
  timeStep?: string(name='TimeStep'),
}

model QueryInstanceMetricsShrinkRequest {
  dimensionsShrink?: string(name='Dimensions'),
  endTime?: string(name='EndTime'),
  metricType?: string(name='MetricType'),
  startTime?: string(name='StartTime'),
  timeStep?: string(name='TimeStep'),
}

model QueryInstanceMetricsResponseBody = {
  metrics?: [
    Metric
  ](name='Metrics'),
  period?: string(name='Period'),
  requestId?: string(name='RequestId'),
}

model QueryInstanceMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryInstanceMetricsResponseBody(name='body'),
}

async function queryInstanceMetrics(InstanceId: string, request: QueryInstanceMetricsRequest): QueryInstanceMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryInstanceMetricsWithOptions(InstanceId, request, headers, runtime);
}

async function queryInstanceMetricsWithOptions(InstanceId: string, tmpReq: QueryInstanceMetricsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryInstanceMetricsResponse {
  Util.validateModel(tmpReq);
  var request = new QueryInstanceMetricsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.dimensions)) {
    request.dimensionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dimensions, 'Dimensions', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.dimensionsShrink)) {
    query['Dimensions'] = request.dimensionsShrink;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.timeStep)) {
    query['TimeStep'] = request.timeStep;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryInstanceMetrics',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/api/v1/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/metrics/action/query`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model QuerySlotMetricsRequest {
  dimensions?: map[string]any(name='Dimensions'),
  endTime?: string(name='EndTime'),
  metricType?: string(name='MetricType'),
  startTime?: string(name='StartTime'),
  timeStep?: string(name='TimeStep'),
}

model QuerySlotMetricsShrinkRequest {
  dimensionsShrink?: string(name='Dimensions'),
  endTime?: string(name='EndTime'),
  metricType?: string(name='MetricType'),
  startTime?: string(name='StartTime'),
  timeStep?: string(name='TimeStep'),
}

model QuerySlotMetricsResponseBody = {
  metrics?: [
    Metric
  ](name='Metrics'),
  period?: string(name='Period'),
  requestId?: string(name='RequestId'),
}

model QuerySlotMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QuerySlotMetricsResponseBody(name='body'),
}

async function querySlotMetrics(SlotId: string, request: QuerySlotMetricsRequest): QuerySlotMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return querySlotMetricsWithOptions(SlotId, request, headers, runtime);
}

async function querySlotMetricsWithOptions(SlotId: string, tmpReq: QuerySlotMetricsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QuerySlotMetricsResponse {
  Util.validateModel(tmpReq);
  var request = new QuerySlotMetricsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.dimensions)) {
    request.dimensionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dimensions, 'Dimensions', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.dimensionsShrink)) {
    query['Dimensions'] = request.dimensionsShrink;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.timeStep)) {
    query['TimeStep'] = request.timeStep;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySlotMetrics',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/api/v1/slots/${OpenApiUtil.getEncodeParam(SlotId)}/metrics/action/query`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model QueryStatisticRequest {
  endTime?: string(name='EndTime'),
  fields?: string(name='Fields'),
  startTime?: string(name='StartTime'),
}

model QueryStatisticResponseBody = {
  instanceCapacityEachType?: map[string]any(name='InstanceCapacityEachType'),
  instanceNumEachType?: map[string]any(name='InstanceNumEachType'),
  requestId?: string(name='RequestId'),
  slotNumEachType?: map[string]any(name='SlotNumEachType'),
}

model QueryStatisticResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryStatisticResponseBody(name='body'),
}

async function queryStatistic(request: QueryStatisticRequest): QueryStatisticResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryStatisticWithOptions(request, headers, runtime);
}

async function queryStatisticWithOptions(request: QueryStatisticRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryStatisticResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.fields)) {
    query['Fields'] = request.fields;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryStatistic',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/api/v1/statistics/action/query`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopSlotResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopSlotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopSlotResponseBody(name='body'),
}

async function stopSlot(SlotId: string): StopSlotResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopSlotWithOptions(SlotId, headers, runtime);
}

async function stopSlotWithOptions(SlotId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopSlotResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopSlot',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/api/v1/slots/${OpenApiUtil.getEncodeParam(SlotId)}/action/stop`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UnbindEndpointResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnbindEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnbindEndpointResponseBody(name='body'),
}

async function unbindEndpoint(EndpointId: string, SlotId: string): UnbindEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return unbindEndpointWithOptions(EndpointId, SlotId, headers, runtime);
}

async function unbindEndpointWithOptions(EndpointId: string, SlotId: string, headers: map[string]string, runtime: Util.RuntimeOptions): UnbindEndpointResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'UnbindEndpoint',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/api/v1/endpoints/${OpenApiUtil.getEncodeParam(EndpointId)}/slots/${OpenApiUtil.getEncodeParam(SlotId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateInstanceRequest {
  description?: string(name='Description'),
  maxSlot?: string(name='MaxSlot'),
  name?: string(name='Name'),
}

model UpdateInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateInstanceResponseBody(name='body'),
}

async function updateInstance(InstanceId: string, request: UpdateInstanceRequest): UpdateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateInstanceWithOptions(InstanceId, request, headers, runtime);
}

async function updateInstanceWithOptions(InstanceId: string, request: UpdateInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.maxSlot)) {
    body['MaxSlot'] = request.maxSlot;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstance',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/api/v1/instances/${OpenApiUtil.getEncodeParam(InstanceId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateSlotRequest {
  capacity?: string(name='Capacity'),
  description?: string(name='Description'),
  lifeCycle?: SlotLifeCycle(name='LifeCycle'),
  name?: string(name='Name'),
  storageType?: string(name='StorageType'),
  storageUri?: string(name='StorageUri'),
  tags?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags'),
}

model UpdateSlotResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateSlotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSlotResponseBody(name='body'),
}

async function updateSlot(SlotId: string, request: UpdateSlotRequest): UpdateSlotResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSlotWithOptions(SlotId, request, headers, runtime);
}

async function updateSlotWithOptions(SlotId: string, request: UpdateSlotRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSlotResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.capacity)) {
    body['Capacity'] = request.capacity;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.lifeCycle)) {
    body['LifeCycle'] = request.lifeCycle;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.storageType)) {
    body['StorageType'] = request.storageType;
  }
  if (!Util.isUnset(request.storageUri)) {
    body['StorageUri'] = request.storageUri;
  }
  if (!Util.isUnset(request.tags)) {
    body['Tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSlot',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/api/v1/slots/${OpenApiUtil.getEncodeParam(SlotId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

