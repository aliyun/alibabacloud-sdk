/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  

  checkConfig(config);
  @endpoint = getEndpoint('microgw', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model FindAllServiceRequest {
  pageNumber?: long(name='pageNumber', description='pageNumber'),
  pageSize?: string(name='pageSize', description='pageSize'),
  name?: string(name='name', description='name'),
  aliasName?: string(name='aliasName', description='aliasName'),
  sourceType?: long(name='sourceType', description='sourceType'),
  isHealth?: boolean(name='isHealth', description='isHealth'),
}

model FindAllServiceResponseBody = {
  code?: long(name='code', description='code'),
  data?: {
    list?: [ 
      {
        aliasName?: string(name='aliasName', description='aliasName'),
        creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
        description?: string(name='description', description='description'),
        id?: long(name='id', description='id'),
        isAutoRefresh?: boolean(name='isAutoRefresh', description='isAutoRefresh'),
        isHealth?: boolean(name='isHealth', description='isHealth'),
        name?: string(name='name', description='name'),
        registryId?: string(name='registryId', description='registryId'),
        serviceEnds?: [ 
          {
            creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
            id?: long(name='id', description='id'),
            ipAddress?: string(name='ipAddress', description='ipAddress'),
            port?: string(name='port', description='port'),
            serviceId?: long(name='serviceId', description='serviceId'),
            status?: long(name='status', description='status'),
            updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
          }
        ](name='serviceEnds', description='serviceEnds'),
        serviceNameInRegistry?: string(name='serviceNameInRegistry', description='serviceNameInRegistry'),
        sourceType?: long(name='sourceType', description='sourceType'),
        updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
      }
    ](name='list', description='list'),
    totalCount?: long(name='totalCount', description='totalCount'),
  }(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model FindAllServiceResponse = {
  headers: map[string]string(name='headers'),
  body: FindAllServiceResponseBody(name='body'),
}

/**
 * findAllService
 */
async function findAllService(gatewayId: string, request: FindAllServiceRequest): FindAllServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return findAllServiceWithOptions(gatewayId, request, headers, runtime);
}

async function findAllServiceWithOptions(gatewayId: string, request: FindAllServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FindAllServiceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.pageNumber)) {
    query.pageNumber = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.pageSize = request.pageSize;
  }
  if (!Util.isUnset(request.name)) {
    query.name = request.name;
  }
  if (!Util.isUnset(request.aliasName)) {
    query.aliasName = request.aliasName;
  }
  if (!Util.isUnset(request.sourceType)) {
    query.sourceType = request.sourceType;
  }
  if (!Util.isUnset(request.isHealth)) {
    query.isHealth = request.isHealth;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('FindAllService', '2020-08-10', 'HTTPS', 'GET', 'AK', `/v1/gateway/${gatewayId}/service`, 'json', req, runtime);
}

model CreateApiRequest {
  aliasName?: string(name='aliasName', description='aliasName'),
  attachedServices?: [ long ](name='attachedServices', description='attachedServices'),
  basePath?: string(name='basePath', description='basePath'),
  description?: string(name='description', description='description'),
  name?: string(name='name', description='name'),
  status?: long(name='status', description='status'),
}

model CreateApiResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model CreateApiResponse = {
  headers: map[string]string(name='headers'),
  body: CreateApiResponseBody(name='body'),
}

/**
 * createApi
 */
async function createApi(gatewayId: string, request: CreateApiRequest): CreateApiResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createApiWithOptions(gatewayId, request, headers, runtime);
}

async function createApiWithOptions(gatewayId: string, request: CreateApiRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateApiResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.aliasName)) {
    body.aliasName = request.aliasName;
  }
  if (!Util.isUnset(request.attachedServices)) {
    body.attachedServices = request.attachedServices;
  }
  if (!Util.isUnset(request.basePath)) {
    body.basePath = request.basePath;
  }
  if (!Util.isUnset(request.description)) {
    body.description = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body.name = request.name;
  }
  if (!Util.isUnset(request.status)) {
    body.status = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CreateApi', '2020-08-10', 'HTTPS', 'POST', 'AK', `/v1/gateway/${gatewayId}/api`, 'json', req, runtime);
}

model GetGatewayByIdResponseBody = {
  code?: long(name='code', description='code'),
  data?: [ 
    {
      armsInfo?: {
        appId?: string(name='appId', description='appId'),
        appName?: string(name='appName', description='appName'),
        description?: string(name='description', description='description'),
        licenseKey?: string(name='licenseKey', description='licenseKey'),
      }(name='armsInfo', description='armsInfo'),
      autoCreateSlb?: boolean(name='autoCreateSlb', description='autoCreateSlb'),
      basePath?: string(name='basePath', description='basePath'),
      creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
      edasNamespaceId?: string(name='edasNamespaceId', description='edasNamespaceId'),
      gatewayType?: string(name='gatewayType', description='gatewayType'),
      id?: long(name='id', description='id'),
      name?: string(name='name', description='name'),
      podCidr?: string(name='podCidr', description='podCidr'),
      region?: string(name='region', description='region'),
      regionName?: string(name='regionName', description='regionName'),
      replica?: long(name='replica', description='replica'),
      runtimeOn?: string(name='runtimeOn', description='runtimeOn'),
      securityGroup?: string(name='securityGroup', description='securityGroup'),
      slb?: string(name='slb', description='slb'),
      slbAccessAddr?: string(name='slbAccessAddr', description='slbAccessAddr'),
      status?: string(name='status', description='status'),
      vpc?: string(name='vpc', description='vpc'),
      vswitch?: string(name='vswitch', description='vswitch'),
    }
  ](name='data', description='data'),
  message?: string(name='message', description='message'),
}

model GetGatewayByIdResponse = {
  headers: map[string]string(name='headers'),
  body: GetGatewayByIdResponseBody(name='body'),
}

/**
 * getGatewayById
 */
async function getGatewayById(gatewayId: string): GetGatewayByIdResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getGatewayByIdWithOptions(gatewayId, headers, runtime);
}

async function getGatewayByIdWithOptions(gatewayId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetGatewayByIdResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetGatewayById', '2020-08-10', 'HTTPS', 'GET', 'AK', `/v1/gateway/${gatewayId}`, 'json', req, runtime);
}

model CreatePolicyRequest {
  aliasName?: string(name='aliasName', description='aliasName'),
  content?: string(name='content', description='content'),
  gatewayId?: long(name='gatewayId', description='gatewayId'),
  id?: long(name='id', description='id'),
  name?: string(name='name', description='name'),
  policyGroup?: string(name='policyGroup', description='policyGroup'),
  type?: long(name='type', description='type'),
}

model CreatePolicyResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model CreatePolicyResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePolicyResponseBody(name='body'),
}

/**
 * createPolicy
 */
async function createPolicy(request: CreatePolicyRequest): CreatePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPolicyWithOptions(request, headers, runtime);
}

async function createPolicyWithOptions(request: CreatePolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePolicyResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.aliasName)) {
    body.aliasName = request.aliasName;
  }
  if (!Util.isUnset(request.content)) {
    body.content = request.content;
  }
  if (!Util.isUnset(request.gatewayId)) {
    body.gatewayId = request.gatewayId;
  }
  if (!Util.isUnset(request.id)) {
    body.id = request.id;
  }
  if (!Util.isUnset(request.name)) {
    body.name = request.name;
  }
  if (!Util.isUnset(request.policyGroup)) {
    body.policyGroup = request.policyGroup;
  }
  if (!Util.isUnset(request.type)) {
    body.type = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CreatePolicy', '2020-08-10', 'HTTPS', 'POST', 'AK', `/v1/policy`, 'json', req, runtime);
}

model GetServiceInstanceForRegistryByServiceNameRequest {
  serviceName?: string(name='serviceName', description='serviceName'),
}

model GetServiceInstanceForRegistryByServiceNameResponseBody = {
  code?: long(name='code', description='code'),
  data?: [ 
    {
      id?: long(name='id', description='id'),
      metaInfo?: string(name='metaInfo', description='metaInfo'),
      serviceEnds?: [ string ](name='serviceEnds'),
      serviceName?: string(name='serviceName', description='serviceName'),
    }
  ](name='data', description='data'),
  message?: string(name='message', description='message'),
}

model GetServiceInstanceForRegistryByServiceNameResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceInstanceForRegistryByServiceNameResponseBody(name='body'),
}

/**
 * getServiceInstanceForRegistryByServiceName
 */
async function getServiceInstanceForRegistryByServiceName(gatewayId: string, registryId: string, request: GetServiceInstanceForRegistryByServiceNameRequest): GetServiceInstanceForRegistryByServiceNameResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceInstanceForRegistryByServiceNameWithOptions(gatewayId, registryId, request, headers, runtime);
}

async function getServiceInstanceForRegistryByServiceNameWithOptions(gatewayId: string, registryId: string, request: GetServiceInstanceForRegistryByServiceNameRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceInstanceForRegistryByServiceNameResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.serviceName)) {
    query.serviceName = request.serviceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetServiceInstanceForRegistryByServiceName', '2020-08-10', 'HTTPS', 'GET', 'AK', `/v1/gateway/${gatewayId}/registry/{registryId}/service`, 'json', req, runtime);
}

model DeleteServiceResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model DeleteServiceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteServiceResponseBody(name='body'),
}

/**
 * deleteService
 */
async function deleteService(serviceId: string): DeleteServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceWithOptions(serviceId, headers, runtime);
}

async function deleteServiceWithOptions(serviceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DeleteService', '2020-08-10', 'HTTPS', 'DELETE', 'AK', `/v1/service/${serviceId}`, 'json', req, runtime);
}

model UpdateRegistryRequest {
  address?: string(name='address', description='address'),
  description?: string(name='description', description='description'),
  gatewayId?: long(name='gatewayId', description='gatewayId'),
  id?: string(name='id', description='id'),
  name?: string(name='name', description='name'),
  type?: long(name='type', description='type'),
}

model UpdateRegistryResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model UpdateRegistryResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateRegistryResponseBody(name='body'),
}

/**
 * UpdateRegistry
 */
async function updateRegistry(registryId: string, request: UpdateRegistryRequest): UpdateRegistryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRegistryWithOptions(registryId, request, headers, runtime);
}

async function updateRegistryWithOptions(registryId: string, request: UpdateRegistryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRegistryResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.address)) {
    body.address = request.address;
  }
  if (!Util.isUnset(request.description)) {
    body.description = request.description;
  }
  if (!Util.isUnset(request.gatewayId)) {
    body.gatewayId = request.gatewayId;
  }
  if (!Util.isUnset(request.id)) {
    body.id = request.id;
  }
  if (!Util.isUnset(request.name)) {
    body.name = request.name;
  }
  if (!Util.isUnset(request.type)) {
    body.type = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('UpdateRegistry', '2020-08-10', 'HTTPS', 'PUT', 'AK', `/v1/registry/${registryId}`, 'json', req, runtime);
}

model CreateGatewayRequest {
  autoCreateSlb?: boolean(name='autoCreateSlb', description='autoCreateSlb'),
  basePath?: string(name='basePath', description='basePath'),
  edasNamespaceId?: string(name='edasNamespaceId', description='edasNamespaceId'),
  gatewayType?: string(name='gatewayType', description='gatewayType'),
  name?: string(name='name', description='name'),
  podCidr?: string(name='podCidr', description='podCidr'),
  region?: string(name='region', description='region'),
  regionName?: string(name='regionName', description='regionName'),
  replica?: long(name='replica', description='replica'),
  runtimeOn?: string(name='runtimeOn', description='runtimeOn'),
  securityGroup?: string(name='securityGroup', description='securityGroup'),
  slb?: string(name='slb', description='slb'),
  slbSpec?: string(name='slbSpec', description='slbSpec'),
  vpc?: string(name='vpc', description='vpc'),
  vswitch?: string(name='vswitch', description='vswitch'),
  zone?: string(name='zone', description='zone'),
}

model CreateGatewayResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model CreateGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGatewayResponseBody(name='body'),
}

/**
 * createGateway
 */
async function createGateway(request: CreateGatewayRequest): CreateGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createGatewayWithOptions(request, headers, runtime);
}

async function createGatewayWithOptions(request: CreateGatewayRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateGatewayResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.autoCreateSlb)) {
    body.autoCreateSlb = request.autoCreateSlb;
  }
  if (!Util.isUnset(request.basePath)) {
    body.basePath = request.basePath;
  }
  if (!Util.isUnset(request.edasNamespaceId)) {
    body.edasNamespaceId = request.edasNamespaceId;
  }
  if (!Util.isUnset(request.gatewayType)) {
    body.gatewayType = request.gatewayType;
  }
  if (!Util.isUnset(request.name)) {
    body.name = request.name;
  }
  if (!Util.isUnset(request.podCidr)) {
    body.podCidr = request.podCidr;
  }
  if (!Util.isUnset(request.region)) {
    body.region = request.region;
  }
  if (!Util.isUnset(request.regionName)) {
    body.regionName = request.regionName;
  }
  if (!Util.isUnset(request.replica)) {
    body.replica = request.replica;
  }
  if (!Util.isUnset(request.runtimeOn)) {
    body.runtimeOn = request.runtimeOn;
  }
  if (!Util.isUnset(request.securityGroup)) {
    body.securityGroup = request.securityGroup;
  }
  if (!Util.isUnset(request.slb)) {
    body.slb = request.slb;
  }
  if (!Util.isUnset(request.slbSpec)) {
    body.slbSpec = request.slbSpec;
  }
  if (!Util.isUnset(request.vpc)) {
    body.vpc = request.vpc;
  }
  if (!Util.isUnset(request.vswitch)) {
    body.vswitch = request.vswitch;
  }
  if (!Util.isUnset(request.zone)) {
    body.zone = request.zone;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CreateGateway', '2020-08-10', 'HTTPS', 'POST', 'AK', `/v1/gateway`, 'json', req, runtime);
}

model CheckServiceHealthRequest {
  id?: long(name='id', description='id'),
  operationIds?: [ long ](name='operationIds', description='operationIds'),
}

model CheckServiceHealthResponseBody = {
  code?: long(name='code', description='code'),
  data?: [ 
    {
      aliasName?: string(name='aliasName', description='aliasName'),
      creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
      description?: string(name='description', description='description'),
      id?: long(name='id', description='id'),
      isAutoRefresh?: boolean(name='isAutoRefresh', description='isAutoRefresh'),
      isHealth?: boolean(name='isHealth', description='isHealth'),
      name?: string(name='name', description='name'),
      registryId?: string(name='registryId', description='registryId'),
      serviceEnds?: [ 
        {
          creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
          id?: long(name='id', description='id'),
          ipAddress?: string(name='ipAddress', description='ipAddress'),
          port?: string(name='port', description='port'),
          serviceId?: long(name='serviceId', description='serviceId'),
          status?: long(name='status', description='status'),
          updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
        }
      ](name='serviceEnds', description='serviceEnds'),
      serviceNameInRegistry?: string(name='serviceNameInRegistry', description='serviceNameInRegistry'),
      sourceType?: long(name='sourceType', description='sourceType'),
      updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
    }
  ](name='data', description='data'),
  message?: string(name='message', description='message'),
}

model CheckServiceHealthResponse = {
  headers: map[string]string(name='headers'),
  body: CheckServiceHealthResponseBody(name='body'),
}

/**
 * checkServiceHealth
 */
async function checkServiceHealth(request: CheckServiceHealthRequest): CheckServiceHealthResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkServiceHealthWithOptions(request, headers, runtime);
}

async function checkServiceHealthWithOptions(request: CheckServiceHealthRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckServiceHealthResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.id)) {
    body.id = request.id;
  }
  if (!Util.isUnset(request.operationIds)) {
    body.operationIds = request.operationIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CheckServiceHealth', '2020-08-10', 'HTTPS', 'POST', 'AK', `/v1/service/check`, 'json', req, runtime);
}

model CreatePolicyToApiRequest {
  creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
  direction?: string(name='direction', description='direction'),
  policyAliasName?: string(name='policyAliasName', description='policyAliasName'),
  policyContent?: string(name='policyContent', description='policyContent'),
  policyGroup?: string(name='policyGroup', description='policyGroup'),
  policyId?: long(name='policyId', description='policyId'),
  policyName?: string(name='policyName', description='policyName'),
  priority?: long(name='priority', description='priority'),
  scope?: string(name='scope', description='scope'),
  status?: boolean(name='status', description='status'),
  type?: long(name='type', description='type'),
}

model CreatePolicyToApiResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model CreatePolicyToApiResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePolicyToApiResponseBody(name='body'),
}

/**
 * createPolicyToApi
 */
async function createPolicyToApi(apiId: string, request: CreatePolicyToApiRequest): CreatePolicyToApiResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPolicyToApiWithOptions(apiId, request, headers, runtime);
}

async function createPolicyToApiWithOptions(apiId: string, request: CreatePolicyToApiRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePolicyToApiResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.creationDateTime)) {
    body.creationDateTime = request.creationDateTime;
  }
  if (!Util.isUnset(request.direction)) {
    body.direction = request.direction;
  }
  if (!Util.isUnset(request.policyAliasName)) {
    body.policyAliasName = request.policyAliasName;
  }
  if (!Util.isUnset(request.policyContent)) {
    body.policyContent = request.policyContent;
  }
  if (!Util.isUnset(request.policyGroup)) {
    body.policyGroup = request.policyGroup;
  }
  if (!Util.isUnset(request.policyId)) {
    body.policyId = request.policyId;
  }
  if (!Util.isUnset(request.policyName)) {
    body.policyName = request.policyName;
  }
  if (!Util.isUnset(request.priority)) {
    body.priority = request.priority;
  }
  if (!Util.isUnset(request.scope)) {
    body.scope = request.scope;
  }
  if (!Util.isUnset(request.status)) {
    body.status = request.status;
  }
  if (!Util.isUnset(request.type)) {
    body.type = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CreatePolicyToApi', '2020-08-10', 'HTTPS', 'POST', 'AK', `/v1/api/${apiId}/policy`, 'json', req, runtime);
}

model DetachPolicyResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model DetachPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DetachPolicyResponseBody(name='body'),
}

/**
 * detachPolicy
 */
async function detachPolicy(apiId: string, policyId: string): DetachPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return detachPolicyWithOptions(apiId, policyId, headers, runtime);
}

async function detachPolicyWithOptions(apiId: string, policyId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DetachPolicyResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DetachPolicy', '2020-08-10', 'HTTPS', 'GET', 'AK', `/v1/api/${apiId}/detach/{policyId}`, 'json', req, runtime);
}

model FindTemplateResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model FindTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: FindTemplateResponseBody(name='body'),
}

/**
 * findTemplate
 */
async function findTemplate(apiId: string): FindTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return findTemplateWithOptions(apiId, headers, runtime);
}

async function findTemplateWithOptions(apiId: string, headers: map[string]string, runtime: Util.RuntimeOptions): FindTemplateResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('FindTemplate', '2020-08-10', 'HTTPS', 'GET', 'AK', `/v1/api/${apiId}/policy/template`, 'json', req, runtime);
}

model ValidateRegistryAddressRequest {
  address?: string(name='address', description='address'),
  type?: long(name='type', description='type'),
}

model ValidateRegistryAddressResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model ValidateRegistryAddressResponse = {
  headers: map[string]string(name='headers'),
  body: ValidateRegistryAddressResponseBody(name='body'),
}

/**
 * validateRegistryAddress
 */
async function validateRegistryAddress(gatewayId: string, request: ValidateRegistryAddressRequest): ValidateRegistryAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return validateRegistryAddressWithOptions(gatewayId, request, headers, runtime);
}

async function validateRegistryAddressWithOptions(gatewayId: string, request: ValidateRegistryAddressRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ValidateRegistryAddressResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.address)) {
    body.address = request.address;
  }
  if (!Util.isUnset(request.type)) {
    body.type = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('ValidateRegistryAddress', '2020-08-10', 'HTTPS', 'POST', 'AK', `/v1/gateway/${gatewayId}/registry/validate`, 'json', req, runtime);
}

model GetApiDetailResponseBody = {
  code?: long(name='code', description='code'),
  data?: [ 
    {
      aliasName?: string(name='aliasName', description='aliasName'),
      attachedServices?: [ 
        {
          aliasName?: string(name='aliasName', description='aliasName'),
          creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
          description?: string(name='description', description='description'),
          id?: long(name='id', description='id'),
          isAutoRefresh?: boolean(name='isAutoRefresh', description='isAutoRefresh'),
          isHealth?: boolean(name='isHealth', description='isHealth'),
          name?: string(name='name', description='name'),
          registryId?: string(name='registryId', description='registryId'),
          serviceEnds?: [ 
            {
              creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
              id?: long(name='id', description='id'),
              ipAddress?: string(name='ipAddress', description='ipAddress'),
              port?: string(name='port', description='port'),
              serviceId?: long(name='serviceId', description='serviceId'),
              status?: long(name='status', description='status'),
              updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
            }
          ](name='serviceEnds', description='serviceEnds'),
          serviceNameInRegistry?: string(name='serviceNameInRegistry', description='serviceNameInRegistry'),
          sourceType?: long(name='sourceType', description='sourceType'),
          updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
        }
      ](name='attachedServices', description='attachedServices'),
      basePath?: string(name='basePath', description='basePath'),
      creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
      description?: string(name='description', description='description'),
      id?: long(name='id', description='id'),
      name?: string(name='name', description='name'),
      owneredPolicies?: [ 
        {
          apiId?: long(name='apiId', description='apiId'),
          apiName?: string(name='apiName', description='apiName'),
          creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
          direction?: string(name='direction', description='direction'),
          id?: long(name='id', description='id'),
          policyAliasName?: string(name='policyAliasName', description='policyAliasName'),
          policyContent?: string(name='policyContent', description='policyContent'),
          policyGroup?: string(name='policyGroup', description='policyGroup'),
          policyId?: string(name='policyId', description='policyId'),
          policyName?: string(name='policyName', description='policyName'),
          priority?: long(name='priority', description='priority'),
          scope?: string(name='scope', description='scope'),
          status?: boolean(name='status', description='status'),
          type?: long(name='type', description='type'),
          updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
        }
      ](name='owneredPolicies', description='owneredPolicies'),
      publishedGateway?: {
        armsInfo?: string(name='armsInfo', description='armsInfo'),
        autoCreateSlb?: boolean(name='autoCreateSlb', description='autoCreateSlb'),
        basePath?: string(name='basePath', description='basePath'),
        creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
        edasNamespaceId?: string(name='edasNamespaceId', description='edasNamespaceId'),
        gatewayType?: string(name='gatewayType', description='gatewayType'),
        id?: long(name='id', description='id'),
        name?: string(name='name', description='name'),
        podCidr?: string(name='podCidr', description='podCidr'),
        region?: string(name='region', description='region'),
        regionName?: string(name='regionName', description='regionName'),
        replica?: long(name='replica', description='replica'),
        runtimeOn?: string(name='runtimeOn', description='runtimeOn'),
        securityGroup?: string(name='securityGroup', description='securityGroup'),
        slb?: string(name='slb', description='slb'),
        slbAccessAddr?: string(name='slbAccessAddr', description='slbAccessAddr'),
        status?: string(name='status', description='status'),
        vpc?: string(name='vpc', description='vpc'),
        vswitch?: string(name='vswitch', description='vswitch'),
      }(name='publishedGateway', description='A short description of struct'),
      status?: string(name='status', description='status'),
      updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
    }
  ](name='data', description='data'),
  message?: string(name='message', description='message'),
}

model GetApiDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetApiDetailResponseBody(name='body'),
}

/**
 * getApiDetail
 */
async function getApiDetail(apiId: string): GetApiDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getApiDetailWithOptions(apiId, headers, runtime);
}

async function getApiDetailWithOptions(apiId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetApiDetailResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetApiDetail', '2020-08-10', 'HTTPS', 'GET', 'AK', `/v1/api/${apiId}`, 'json', req, runtime);
}

model CreateSpecialRouteForRegistryResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model CreateSpecialRouteForRegistryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSpecialRouteForRegistryResponseBody(name='body'),
}

/**
 * createSpecialRouteForRegistry
 */
async function createSpecialRouteForRegistry(gatewayId: string): CreateSpecialRouteForRegistryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSpecialRouteForRegistryWithOptions(gatewayId, headers, runtime);
}

async function createSpecialRouteForRegistryWithOptions(gatewayId: string, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSpecialRouteForRegistryResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('CreateSpecialRouteForRegistry', '2020-08-10', 'HTTPS', 'POST', 'AK', `/v1/gateway/${gatewayId}/registry/special/route`, 'json', req, runtime);
}

model PublishApiResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model PublishApiResponse = {
  headers: map[string]string(name='headers'),
  body: PublishApiResponseBody(name='body'),
}

/**
 * publishApi
 */
async function publishApi(apiId: string): PublishApiResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return publishApiWithOptions(apiId, headers, runtime);
}

async function publishApiWithOptions(apiId: string, headers: map[string]string, runtime: Util.RuntimeOptions): PublishApiResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('PublishApi', '2020-08-10', 'HTTPS', 'POST', 'AK', `/v1/api/${apiId}/publish`, 'json', req, runtime);
}

model CreateGatewayLogEtlResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model CreateGatewayLogEtlResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGatewayLogEtlResponseBody(name='body'),
}

/**
 * CreateGatewayLogEtl
 */
async function createGatewayLogEtl(gatewayId: string, regionId: string): CreateGatewayLogEtlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createGatewayLogEtlWithOptions(gatewayId, regionId, headers, runtime);
}

async function createGatewayLogEtlWithOptions(gatewayId: string, regionId: string, headers: map[string]string, runtime: Util.RuntimeOptions): CreateGatewayLogEtlResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('CreateGatewayLogEtl', '2020-08-10', 'HTTPS', 'POST', 'AK', `/v1/sls/gateway/${gatewayId}/region/{regionId}`, 'json', req, runtime);
}

model FindPoliciesRequest {
  pageNumber?: long(name='pageNumber', description='pageNumber'),
  pageSize?: long(name='pageSize', description='pageSize'),
  name?: string(name='name', description='name'),
  aliasName?: string(name='aliasName', description='aliasName'),
  type?: long(name='type', description='type'),
  group?: string(name='group', description='group'),
}

model FindPoliciesResponseBody = {
  code?: long(name='code', description='code'),
  data?: {
    list?: [ 
      {
        aliasName?: string(name='aliasName', description='aliasName'),
        attachedApi?: [ 
          {
            apiId?: long(name='apiId', description='apiId'),
            apiName?: string(name='apiName', description='apiName'),
            creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
            direction?: string(name='direction', description='direction'),
            id?: long(name='id', description='id'),
            policyAliasName?: string(name='policyAliasName', description='policyAliasName'),
            policyContent?: string(name='policyContent', description='policyContent'),
            policyGroup?: string(name='policyGroup', description='policyGroup'),
            policyId?: string(name='policyId', description='policyId'),
            policyName?: string(name='policyName', description='policyName'),
            priority?: long(name='priority', description='priority'),
            scope?: string(name='scope', description='scope'),
            status?: boolean(name='status', description='status'),
            type?: long(name='type', description='type'),
            updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
          }
        ](name='attachedApi', description='attachedApi'),
        content?: string(name='content', description='content'),
        creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
        id?: long(name='id', description='id'),
        name?: string(name='name', description='name'),
        policyGroup?: string(name='policyGroup', description='policyGroup'),
        policyTypeName?: string(name='policyTypeName', description='policyTypeName'),
        type?: long(name='type', description='type'),
        updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
      }
    ](name='list', description='list'),
    totalCount?: long(name='totalCount', description='totalCount'),
  }(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model FindPoliciesResponse = {
  headers: map[string]string(name='headers'),
  body: FindPoliciesResponseBody(name='body'),
}

/**
 * FindPolicies
 */
async function findPolicies(gatewayId: string, request: FindPoliciesRequest): FindPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return findPoliciesWithOptions(gatewayId, request, headers, runtime);
}

async function findPoliciesWithOptions(gatewayId: string, request: FindPoliciesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FindPoliciesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.pageNumber)) {
    query.pageNumber = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.pageSize = request.pageSize;
  }
  if (!Util.isUnset(request.name)) {
    query.name = request.name;
  }
  if (!Util.isUnset(request.aliasName)) {
    query.aliasName = request.aliasName;
  }
  if (!Util.isUnset(request.type)) {
    query.type = request.type;
  }
  if (!Util.isUnset(request.group)) {
    query.group = request.group;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('FindPolicies', '2020-08-10', 'HTTPS', 'GET', 'AK', `/v1/gateway/${gatewayId}/policy`, 'json', req, runtime);
}

model AttachPolicyRequest {
  data?: [ 
    {
      creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
      direction?: string(name='direction', description='direction'),
      policyAliasName?: string(name='policyAliasName', description='policyAliasName'),
      policyContent?: string(name='policyContent', description='policyContent'),
      policyGroup?: string(name='policyGroup', description='policyGroup'),
      policyId?: long(name='policyId', description='policyId'),
      policyName?: string(name='policyName', description='policyName'),
      priority?: long(name='priority', description='priority'),
      scope?: string(name='scope', description='scope'),
      status?: boolean(name='status', description='status'),
      type?: long(name='type', description='type'),
    }
  ](name='data', description='data'),
}

model AttachPolicyResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model AttachPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: AttachPolicyResponseBody(name='body'),
}

/**
 * attachPolicy
 */
async function attachPolicy(apiId: string, request: AttachPolicyRequest): AttachPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return attachPolicyWithOptions(apiId, request, headers, runtime);
}

async function attachPolicyWithOptions(apiId: string, request: AttachPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AttachPolicyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = Util.toArray(request.data),
  };
  return doROARequest('AttachPolicy', '2020-08-10', 'HTTPS', 'POST', 'AK', `/v1/api/${apiId}/attach`, 'json', req, runtime);
}

model FindRegistryResponseBody = {
  code?: long(name='code', description='code'),
  data?: [ 
    {
      address?: string(name='address', description='address'),
      creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
      description?: string(name='description', description='description'),
      gatewayId?: string(name='gatewayId', description='gatewayId'),
      id?: long(name='id', description='id'),
      name?: string(name='name', description='name'),
      type?: long(name='type', description='type'),
      updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
    }
  ](name='data', description='data'),
  message?: string(name='message', description='message'),
}

model FindRegistryResponse = {
  headers: map[string]string(name='headers'),
  body: FindRegistryResponseBody(name='body'),
}

/**
 * findRegistry
 */
async function findRegistry(registryId: string): FindRegistryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return findRegistryWithOptions(registryId, headers, runtime);
}

async function findRegistryWithOptions(registryId: string, headers: map[string]string, runtime: Util.RuntimeOptions): FindRegistryResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('FindRegistry', '2020-08-10', 'HTTPS', 'GET', 'AK', `/v1/registry/${registryId}`, 'json', req, runtime);
}

model GetAuthTicketByIdHeaders {
  commonHeaders?: map[string]string,
  cookie?: map[string]any(name='cookie', description='cookie'),
}

model GetAuthTicketByIdShrinkHeaders {
  commonHeaders?: map[string]string,
  cookieShrink?: string(name='cookie', description='cookie'),
}

model GetAuthTicketByIdResponseBody = {
  code?: long(name='code', description='code'),
  data?: [ 
    {
      clientToken?: string(name='clientToken', description='clientToken'),
      comment?: string(name='comment', description='comment'),
      id?: long(name='id', description='id'),
      name?: string(name='name', description='name'),
      serverKey?: string(name='serverKey', description='serverKey'),
      ticketType?: string(name='ticketType', description='ticketType'),
      validEndTime?: string(name='validEndTime', description='validEndTime'),
      validStartTime?: string(name='validStartTime', description='validStartTime'),
    }
  ](name='data', description='data'),
  message?: string(name='message', description='message'),
}

model GetAuthTicketByIdResponse = {
  headers: map[string]string(name='headers'),
  body: GetAuthTicketByIdResponseBody(name='body'),
}

/**
 * getAuthTicketById
 */
async function getAuthTicketById(ticketId: string): GetAuthTicketByIdResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetAuthTicketByIdHeaders{};
  return getAuthTicketByIdWithOptions(ticketId, headers, runtime);
}

async function getAuthTicketByIdWithOptions(ticketId: string, tmpHeader: GetAuthTicketByIdHeaders, runtime: Util.RuntimeOptions): GetAuthTicketByIdResponse {
  var headers = new GetAuthTicketByIdShrinkHeaders{};
  OpenApiUtil.convert(tmpHeader, headers);
  if (!Util.isUnset(tmpHeader.cookie)) {
    headers.cookieShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.cookie, 'cookie', 'json');
  }
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.cookieShrink)) {
    realHeaders.cookie = headers.cookieShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  return doROARequest('GetAuthTicketById', '2020-08-10', 'HTTPS', 'GET', 'AK', `/v1/auth/${ticketId}`, 'json', req, runtime);
}

model CreateRegistryRequest {
  address?: string(name='address', description='address'),
  description?: string(name='description', description='description'),
  gatewayId?: long(name='gatewayId', description='gatewayId'),
  id?: string(name='id', description='id'),
  name?: string(name='name', description='name'),
  type?: long(name='type', description='type'),
}

model CreateRegistryResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model CreateRegistryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRegistryResponseBody(name='body'),
}

/**
 * CreateRegistry
 */
async function createRegistry(gatewayId: string, request: CreateRegistryRequest): CreateRegistryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRegistryWithOptions(gatewayId, request, headers, runtime);
}

async function createRegistryWithOptions(gatewayId: string, request: CreateRegistryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRegistryResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.address)) {
    body.address = request.address;
  }
  if (!Util.isUnset(request.description)) {
    body.description = request.description;
  }
  if (!Util.isUnset(request.gatewayId)) {
    body.gatewayId = request.gatewayId;
  }
  if (!Util.isUnset(request.id)) {
    body.id = request.id;
  }
  if (!Util.isUnset(request.name)) {
    body.name = request.name;
  }
  if (!Util.isUnset(request.type)) {
    body.type = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CreateRegistry', '2020-08-10', 'HTTPS', 'POST', 'AK', `/v1/registry`, 'json', req, runtime);
}

model RecycleApiResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model RecycleApiResponse = {
  headers: map[string]string(name='headers'),
  body: RecycleApiResponseBody(name='body'),
}

/**
 * recycleApi
 */
async function recycleApi(apiId: string): RecycleApiResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return recycleApiWithOptions(apiId, headers, runtime);
}

async function recycleApiWithOptions(apiId: string, headers: map[string]string, runtime: Util.RuntimeOptions): RecycleApiResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('RecycleApi', '2020-08-10', 'HTTPS', 'POST', 'AK', `/v1/api/${apiId}/recycle`, 'json', req, runtime);
}

model CreateAuthTicketRequest {
  comment?: string(name='comment', description='comment'),
  gatewayId?: long(name='gatewayId', description='gatewayId'),
  name?: string(name='name', description='name'),
  ticketType?: string(name='ticketType', description='ticketType'),
  validDuration?: long(name='validDuration'),
}

model CreateAuthTicketResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model CreateAuthTicketResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAuthTicketResponseBody(name='body'),
}

/**
 * createAuthTicket
 */
async function createAuthTicket(request: CreateAuthTicketRequest): CreateAuthTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAuthTicketWithOptions(request, headers, runtime);
}

async function createAuthTicketWithOptions(request: CreateAuthTicketRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAuthTicketResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.comment)) {
    body.comment = request.comment;
  }
  if (!Util.isUnset(request.gatewayId)) {
    body.gatewayId = request.gatewayId;
  }
  if (!Util.isUnset(request.name)) {
    body.name = request.name;
  }
  if (!Util.isUnset(request.ticketType)) {
    body.ticketType = request.ticketType;
  }
  if (!Util.isUnset(request.validDuration)) {
    body.validDuration = request.validDuration;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CreateAuthTicket', '2020-08-10', 'HTTPS', 'POST', 'AK', `/v1/auth`, 'json', req, runtime);
}

model DeleteGatewayResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model DeleteGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGatewayResponseBody(name='body'),
}

/**
 * deleteGateway
 */
async function deleteGateway(gatewayId: string): DeleteGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteGatewayWithOptions(gatewayId, headers, runtime);
}

async function deleteGatewayWithOptions(gatewayId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteGatewayResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DeleteGateway', '2020-08-10', 'HTTPS', 'DELETE', 'AK', `/v1/gateway/${gatewayId}`, 'json', req, runtime);
}

model FindServiceResponseBody = {
  code?: long(name='code', description='code'),
  data?: [ 
    {
      aliasName?: string(name='aliasName', description='aliasName'),
      creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
      description?: string(name='description', description='description'),
      id?: long(name='id', description='id'),
      isAutoRefresh?: boolean(name='isAutoRefresh', description='isAutoRefresh'),
      isHealth?: boolean(name='isHealth', description='isHealth'),
      name?: string(name='name', description='name'),
      registryId?: string(name='registryId', description='registryId'),
      serviceEnds?: [ 
        {
          creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
          id?: long(name='id', description='id'),
          ipAddress?: string(name='ipAddress', description='ipAddress'),
          port?: string(name='port', description='port'),
          serviceId?: long(name='serviceId', description='serviceId'),
          status?: long(name='status', description='status'),
          updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
        }
      ](name='serviceEnds', description='serviceEnds'),
      serviceNameInRegistry?: string(name='serviceNameInRegistry', description='serviceNameInRegistry'),
      sourceType?: long(name='sourceType', description='sourceType'),
      updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
    }
  ](name='data', description='data'),
  message?: string(name='message', description='message'),
}

model FindServiceResponse = {
  headers: map[string]string(name='headers'),
  body: FindServiceResponseBody(name='body'),
}

/**
 * findService
 */
async function findService(serviceId: string): FindServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return findServiceWithOptions(serviceId, headers, runtime);
}

async function findServiceWithOptions(serviceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): FindServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('FindService', '2020-08-10', 'HTTPS', 'GET', 'AK', `/v1/service/${serviceId}`, 'json', req, runtime);
}

model DeletePolicyByIdResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model DeletePolicyByIdResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePolicyByIdResponseBody(name='body'),
}

/**
 * DeletePolicyById
 */
async function deletePolicyById(policyId: string): DeletePolicyByIdResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePolicyByIdWithOptions(policyId, headers, runtime);
}

async function deletePolicyByIdWithOptions(policyId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePolicyByIdResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DeletePolicyById', '2020-08-10', 'HTTPS', 'DELETE', 'AK', `/v1/policy/${policyId}`, 'json', req, runtime);
}

model DeleteApiResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model DeleteApiResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteApiResponseBody(name='body'),
}

/**
 * deleteApi
 */
async function deleteApi(apiId: string): DeleteApiResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteApiWithOptions(apiId, headers, runtime);
}

async function deleteApiWithOptions(apiId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteApiResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DeleteApi', '2020-08-10', 'HTTPS', 'DELETE', 'AK', `/v1/api/${apiId}`, 'json', req, runtime);
}

model FindAuthTicketsRequest {
  gatewayId?: long(name='gatewayId', description='gatewayId'),
  name?: string(name='name', description='name'),
  pageNumber?: long(name='pageNumber', description='pageNumber'),
  pageSize?: long(name='pageSize', description='pageSize'),
}

model FindAuthTicketsResponseBody = {
  code?: long(name='code', description='code'),
  data?: {
    list?: [ 
      {
        clientToken?: string(name='clientToken', description='clientToken'),
        comment?: string(name='comment', description='comment'),
        id?: long(name='id', description='id'),
        name?: string(name='name', description='name'),
        serverKey?: string(name='serverKey', description='serverKey'),
        ticketType?: string(name='ticketType', description='ticketType'),
        validEndTime?: string(name='validEndTime', description='validEndTime'),
        validStartTime?: string(name='validStartTime', description='validStartTime'),
      }
    ](name='list', description='list'),
    totalCount?: long(name='totalCount', description='totalCount'),
  }(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model FindAuthTicketsResponse = {
  headers: map[string]string(name='headers'),
  body: FindAuthTicketsResponseBody(name='body'),
}

/**
 * findAuthTickets
 */
async function findAuthTickets(request: FindAuthTicketsRequest): FindAuthTicketsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return findAuthTicketsWithOptions(request, headers, runtime);
}

async function findAuthTicketsWithOptions(request: FindAuthTicketsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FindAuthTicketsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.gatewayId)) {
    query.gatewayId = request.gatewayId;
  }
  if (!Util.isUnset(request.name)) {
    query.name = request.name;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query.pageNumber = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.pageSize = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('FindAuthTickets', '2020-08-10', 'HTTPS', 'GET', 'AK', `/v1/auth`, 'json', req, runtime);
}

model UpdatePolicyRequest {
  aliasName?: string(name='aliasName', description='aliasName'),
  content?: string(name='content', description='content'),
  id?: long(name='id', description='id'),
  name?: string(name='name', description='name'),
  policyGroup?: string(name='policyGroup', description='policyGroup'),
  type?: long(name='type', description='type'),
}

model UpdatePolicyResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model UpdatePolicyResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePolicyResponseBody(name='body'),
}

/**
 * updatePolicy
 */
async function updatePolicy(request: UpdatePolicyRequest): UpdatePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePolicyWithOptions(request, headers, runtime);
}

async function updatePolicyWithOptions(request: UpdatePolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePolicyResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.aliasName)) {
    body.aliasName = request.aliasName;
  }
  if (!Util.isUnset(request.content)) {
    body.content = request.content;
  }
  if (!Util.isUnset(request.id)) {
    body.id = request.id;
  }
  if (!Util.isUnset(request.name)) {
    body.name = request.name;
  }
  if (!Util.isUnset(request.policyGroup)) {
    body.policyGroup = request.policyGroup;
  }
  if (!Util.isUnset(request.type)) {
    body.type = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('UpdatePolicy', '2020-08-10', 'HTTPS', 'PUT', 'AK', `/v1/policy`, 'json', req, runtime);
}

model UpdateAuthTicketRequest {
  comment?: string(name='comment', description='comment'),
  id?: long(name='id', description='id'),
}

model UpdateAuthTicketResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model UpdateAuthTicketResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAuthTicketResponseBody(name='body'),
}

/**
 * updateAuthTicket
 */
async function updateAuthTicket(request: UpdateAuthTicketRequest): UpdateAuthTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAuthTicketWithOptions(request, headers, runtime);
}

async function updateAuthTicketWithOptions(request: UpdateAuthTicketRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAuthTicketResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.comment)) {
    body.comment = request.comment;
  }
  if (!Util.isUnset(request.id)) {
    body.id = request.id;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('UpdateAuthTicket', '2020-08-10', 'HTTPS', 'PUT', 'AK', `/v1/auth`, 'json', req, runtime);
}

model InstallArmsAgentResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model InstallArmsAgentResponse = {
  headers: map[string]string(name='headers'),
  body: InstallArmsAgentResponseBody(name='body'),
}

/**
 * installArmsAgent
 */
async function installArmsAgent(gatewayId: string): InstallArmsAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installArmsAgentWithOptions(gatewayId, headers, runtime);
}

async function installArmsAgentWithOptions(gatewayId: string, headers: map[string]string, runtime: Util.RuntimeOptions): InstallArmsAgentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('InstallArmsAgent', '2020-08-10', 'HTTPS', 'GET', 'AK', `/v1/gateway/agent/${gatewayId}`, 'json', req, runtime);
}

model DeleteAuthTicketResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model DeleteAuthTicketResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAuthTicketResponseBody(name='body'),
}

/**
 * deleteAuthTicket
 */
async function deleteAuthTicket(ticketId: string): DeleteAuthTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAuthTicketWithOptions(ticketId, headers, runtime);
}

async function deleteAuthTicketWithOptions(ticketId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAuthTicketResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DeleteAuthTicket', '2020-08-10', 'HTTPS', 'DELETE', 'AK', `/v1/auth/${ticketId}`, 'json', req, runtime);
}

model GetPolicyByIdResponseBody = {
  code?: long(name='code', description='code'),
  data?: [ 
    {
      aliasName?: string(name='aliasName', description='aliasName'),
      attachedApi?: [ 
        {
          apiId?: long(name='apiId', description='apiId'),
          apiName?: string(name='apiName', description='apiName'),
          creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
          direction?: string(name='direction', description='direction'),
          id?: long(name='id', description='id'),
          policyAliasName?: string(name='policyAliasName', description='policyAliasName'),
          policyContent?: string(name='policyContent', description='policyContent'),
          policyGroup?: string(name='policyGroup', description='policyGroup'),
          policyId?: string(name='policyId', description='policyId'),
          policyName?: string(name='policyName', description='policyName'),
          priority?: long(name='priority', description='priority'),
          scope?: string(name='scope', description='scope'),
          status?: boolean(name='status', description='status'),
          type?: long(name='type', description='type'),
          updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
        }
      ](name='attachedApi', description='attachedApi'),
      content?: string(name='content', description='content'),
      creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
      id?: long(name='id', description='id'),
      name?: string(name='name', description='name'),
      policyGroup?: string(name='policyGroup', description='policyGroup'),
      policyTypeName?: string(name='policyTypeName', description='policyTypeName'),
      type?: long(name='type', description='type'),
      updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
    }
  ](name='data', description='data'),
  message?: string(name='message', description='message'),
}

model GetPolicyByIdResponse = {
  headers: map[string]string(name='headers'),
  body: GetPolicyByIdResponseBody(name='body'),
}

/**
 * GetPolicyById
 */
async function getPolicyById(policyId: string): GetPolicyByIdResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPolicyByIdWithOptions(policyId, headers, runtime);
}

async function getPolicyByIdWithOptions(policyId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPolicyByIdResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetPolicyById', '2020-08-10', 'HTTPS', 'GET', 'AK', `/v1/policy/${policyId}`, 'json', req, runtime);
}

model DeleteRegistryResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model DeleteRegistryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRegistryResponseBody(name='body'),
}

/**
 * deleteRegistry
 */
async function deleteRegistry(registryId: string): DeleteRegistryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRegistryWithOptions(registryId, headers, runtime);
}

async function deleteRegistryWithOptions(registryId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRegistryResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DeleteRegistry', '2020-08-10', 'HTTPS', 'DELETE', 'AK', `/v1/registry/${registryId}`, 'json', req, runtime);
}

model GetPolicyOwnedByApiResponseBody = {
  code?: long(name='code', description='code'),
  data?: [ 
    {
      scopes?: map[string][ DataScopesValue       ](name='scopes'),
    }
  ](name='data'),
  message?: string(name='message', description='message'),
}

model GetPolicyOwnedByApiResponse = {
  headers: map[string]string(name='headers'),
  body: GetPolicyOwnedByApiResponseBody(name='body'),
}

async function getPolicyOwnedByApi(apiId: string): GetPolicyOwnedByApiResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPolicyOwnedByApiWithOptions(apiId, headers, runtime);
}

async function getPolicyOwnedByApiWithOptions(apiId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPolicyOwnedByApiResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetPolicyOwnedByApi', '2020-08-10', 'HTTPS', 'GET', 'AK', `/v1/api/${apiId}/policy`, 'json', req, runtime);
}

model UpdateApiRequest {
  aliasName?: string(name='aliasName', description='aliasName'),
  attachedServices?: [ 
    {
      aliasName?: string(name='aliasName', description='aliasName'),
      creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
      description?: string(name='description', description='description'),
      id?: long(name='id', description='id'),
      isAutoRefresh?: boolean(name='isAutoRefresh', description='isAutoRefresh'),
      isHealth?: boolean(name='isHealth', description='isHealth'),
      name?: string(name='name', description='name'),
      registryId?: string(name='registryId', description='registryId'),
      serviceEnds?: [ 
        {
          creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
          id?: long(name='id', description='id'),
          ipAddress?: string(name='ipAddress', description='ipAddress'),
          port?: string(name='port', description='port'),
          serviceId?: long(name='serviceId', description='serviceId'),
          status?: long(name='status', description='status'),
          updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
        }
      ](name='serviceEnds', description='serviceEnds'),
      serviceNameInRegistry?: string(name='serviceNameInRegistry', description='serviceNameInRegistry'),
      sourceType?: long(name='sourceType', description='sourceType'),
      updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
    }
  ](name='attachedServices', description='attachedServices'),
  basePath?: string(name='basePath', description='basePath'),
  creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
  description?: string(name='description', description='description'),
  id?: long(name='id', description='id'),
  name?: string(name='name', description='name'),
  owneredPolicies?: [ 
    {
      apiId?: long(name='apiId', description='apiId'),
      apiName?: string(name='apiName', description='apiName'),
      creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
      direction?: string(name='direction', description='direction'),
      id?: long(name='id', description='id'),
      policyAliasName?: string(name='policyAliasName', description='policyAliasName'),
      policyContent?: string(name='policyContent', description='policyContent'),
      policyGroup?: string(name='policyGroup', description='policyGroup'),
      policyId?: string(name='policyId', description='policyId'),
      policyName?: string(name='policyName', description='policyName'),
      priority?: long(name='priority', description='priority'),
      scope?: string(name='scope', description='scope'),
      status?: boolean(name='status', description='status'),
      type?: long(name='type', description='type'),
      updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
    }
  ](name='owneredPolicies', description='owneredPolicies'),
  publishedGateway?: {
    armsInfo?: string(name='armsInfo', description='armsInfo'),
    autoCreateSlb?: boolean(name='autoCreateSlb', description='autoCreateSlb'),
    basePath?: string(name='basePath', description='basePath'),
    creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
    edasNamespaceId?: string(name='edasNamespaceId', description='edasNamespaceId'),
    gatewayType?: string(name='gatewayType', description='gatewayType'),
    id?: long(name='id', description='id'),
    name?: string(name='name', description='name'),
    podCidr?: string(name='podCidr', description='podCidr'),
    region?: string(name='region', description='region'),
    regionName?: string(name='regionName', description='regionName'),
    replica?: long(name='replica', description='replica'),
    runtimeOn?: string(name='runtimeOn', description='runtimeOn'),
    securityGroup?: string(name='securityGroup', description='securityGroup'),
    slb?: string(name='slb', description='slb'),
    slbAccessAddr?: string(name='slbAccessAddr', description='slbAccessAddr'),
    status?: string(name='status', description='status'),
    vpc?: string(name='vpc', description='vpc'),
    vswitch?: string(name='vswitch', description='vswitch'),
  }(name='publishedGateway', description='A short description of struct'),
  status?: string(name='status', description='status'),
  updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
}

model UpdateApiResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model UpdateApiResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateApiResponseBody(name='body'),
}

/**
 * updateApi
 */
async function updateApi(apiId: string, request: UpdateApiRequest): UpdateApiResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateApiWithOptions(apiId, request, headers, runtime);
}

async function updateApiWithOptions(apiId: string, request: UpdateApiRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateApiResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.aliasName)) {
    body.aliasName = request.aliasName;
  }
  if (!Util.isUnset(request.attachedServices)) {
    body.attachedServices = request.attachedServices;
  }
  if (!Util.isUnset(request.basePath)) {
    body.basePath = request.basePath;
  }
  if (!Util.isUnset(request.creationDateTime)) {
    body.creationDateTime = request.creationDateTime;
  }
  if (!Util.isUnset(request.description)) {
    body.description = request.description;
  }
  if (!Util.isUnset(request.id)) {
    body.id = request.id;
  }
  if (!Util.isUnset(request.name)) {
    body.name = request.name;
  }
  if (!Util.isUnset(request.owneredPolicies)) {
    body.owneredPolicies = request.owneredPolicies;
  }
  if (!Util.isUnset(request.publishedGateway)) {
    body.publishedGateway = request.publishedGateway;
  }
  if (!Util.isUnset(request.status)) {
    body.status = request.status;
  }
  if (!Util.isUnset(request.updateDateTime)) {
    body.updateDateTime = request.updateDateTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('UpdateApi', '2020-08-10', 'HTTPS', 'PUT', 'AK', `/v1/api/${apiId}`, 'json', req, runtime);
}

model CreateServiceRequest {
  aliasName?: string(name='aliasName', description='aliasName'),
  description?: string(name='description', description='description'),
  isAutoRefresh?: boolean(name='isAutoRefresh', description='isAutoRefresh'),
  metaInfo?: [ string ](name='metaInfo', description='metaInfo'),
  name?: string(name='name', description='name'),
  registryId?: long(name='registryId', description='registryId'),
  serviceEnds?: [ string ](name='serviceEnds', description='serviceEnds'),
  serviceNameInRegistry?: string(name='serviceNameInRegistry', description='serviceNameInRegistry'),
  sourceType?: long(name='sourceType', description='sourceType'),
}

model CreateServiceResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model CreateServiceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateServiceResponseBody(name='body'),
}

/**
 * /gateway/{gatewayId}/service
 */
async function createService(gatewayId: string, request: CreateServiceRequest): CreateServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceWithOptions(gatewayId, request, headers, runtime);
}

async function createServiceWithOptions(gatewayId: string, request: CreateServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.aliasName)) {
    body.aliasName = request.aliasName;
  }
  if (!Util.isUnset(request.description)) {
    body.description = request.description;
  }
  if (!Util.isUnset(request.isAutoRefresh)) {
    body.isAutoRefresh = request.isAutoRefresh;
  }
  if (!Util.isUnset(request.metaInfo)) {
    body.metaInfo = request.metaInfo;
  }
  if (!Util.isUnset(request.name)) {
    body.name = request.name;
  }
  if (!Util.isUnset(request.registryId)) {
    body.registryId = request.registryId;
  }
  if (!Util.isUnset(request.serviceEnds)) {
    body.serviceEnds = request.serviceEnds;
  }
  if (!Util.isUnset(request.serviceNameInRegistry)) {
    body.serviceNameInRegistry = request.serviceNameInRegistry;
  }
  if (!Util.isUnset(request.sourceType)) {
    body.sourceType = request.sourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CreateService', '2020-08-10', 'HTTPS', 'POST', 'AK', `/v1/gateway/${gatewayId}/service`, 'json', req, runtime);
}

model SaveAllPoliciesRequest {
  data?: [ 
    {
      apiId?: long(name='apiId', description='apiId'),
      apiName?: string(name='apiName', description='apiName'),
      creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
      direction?: string(name='direction', description='direction'),
      id?: long(name='id', description='id'),
      policyAliasName?: string(name='policyAliasName', description='policyAliasName'),
      policyContent?: string(name='policyContent', description='policyContent'),
      policyGroup?: string(name='policyGroup', description='policyGroup'),
      policyId?: string(name='policyId', description='policyId'),
      policyName?: string(name='policyName', description='policyName'),
      priority?: long(name='priority', description='priority'),
      scope?: string(name='scope', description='scope'),
      status?: boolean(name='status', description='status'),
      type?: long(name='type', description='type'),
      updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
    }
  ](name='data', description='data'),
}

model SaveAllPoliciesResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model SaveAllPoliciesResponse = {
  headers: map[string]string(name='headers'),
  body: SaveAllPoliciesResponseBody(name='body'),
}

/**
 * saveAllPolicies
 */
async function saveAllPolicies(apiId: string, request: SaveAllPoliciesRequest): SaveAllPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return saveAllPoliciesWithOptions(apiId, request, headers, runtime);
}

async function saveAllPoliciesWithOptions(apiId: string, request: SaveAllPoliciesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SaveAllPoliciesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = Util.toArray(request.data),
  };
  return doROARequest('SaveAllPolicies', '2020-08-10', 'HTTPS', 'POST', 'AK', `/v1/api/${apiId}/policies`, 'json', req, runtime);
}

model UpdateGatewayRequest {
  id?: long(name='id', description='id'),
  replica?: string(name='replica', description='replica'),
}

model UpdateGatewayResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model UpdateGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGatewayResponseBody(name='body'),
}

/**
 * updateGateway
 */
async function updateGateway(request: UpdateGatewayRequest): UpdateGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateGatewayWithOptions(request, headers, runtime);
}

async function updateGatewayWithOptions(request: UpdateGatewayRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateGatewayResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.id)) {
    body.id = request.id;
  }
  if (!Util.isUnset(request.replica)) {
    body.replica = request.replica;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('UpdateGateway', '2020-08-10', 'HTTPS', 'PUT', 'AK', `/v1/gateway`, 'json', req, runtime);
}

model UpdateServiceRequest {
  aliasName?: string(name='aliasName', description='aliasName'),
  creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
  description?: string(name='description', description='description'),
  id?: long(name='id', description='id'),
  isAutoRefresh?: boolean(name='isAutoRefresh', description='isAutoRefresh'),
  isHealth?: boolean(name='isHealth', description='isHealth'),
  name?: string(name='name', description='name'),
  registryId?: long(name='registryId', description='registryId'),
  serviceEnds?: [ string ](name='serviceEnds', description='serviceEnds'),
  serviceNameInRegistry?: string(name='serviceNameInRegistry', description='serviceNameInRegistry'),
  sourceType?: long(name='sourceType', description='sourceType'),
  updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
}

model UpdateServiceResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model UpdateServiceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateServiceResponseBody(name='body'),
}

/**
 * updateService
 */
async function updateService(serviceId: string, request: UpdateServiceRequest): UpdateServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceWithOptions(serviceId, request, headers, runtime);
}

async function updateServiceWithOptions(serviceId: string, request: UpdateServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.aliasName)) {
    body.aliasName = request.aliasName;
  }
  if (!Util.isUnset(request.creationDateTime)) {
    body.creationDateTime = request.creationDateTime;
  }
  if (!Util.isUnset(request.description)) {
    body.description = request.description;
  }
  if (!Util.isUnset(request.id)) {
    body.id = request.id;
  }
  if (!Util.isUnset(request.isAutoRefresh)) {
    body.isAutoRefresh = request.isAutoRefresh;
  }
  if (!Util.isUnset(request.isHealth)) {
    body.isHealth = request.isHealth;
  }
  if (!Util.isUnset(request.name)) {
    body.name = request.name;
  }
  if (!Util.isUnset(request.registryId)) {
    body.registryId = request.registryId;
  }
  if (!Util.isUnset(request.serviceEnds)) {
    body.serviceEnds = request.serviceEnds;
  }
  if (!Util.isUnset(request.serviceNameInRegistry)) {
    body.serviceNameInRegistry = request.serviceNameInRegistry;
  }
  if (!Util.isUnset(request.sourceType)) {
    body.sourceType = request.sourceType;
  }
  if (!Util.isUnset(request.updateDateTime)) {
    body.updateDateTime = request.updateDateTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('UpdateService', '2020-08-10', 'HTTPS', 'PUT', 'AK', `/v1/service/${serviceId}`, 'json', req, runtime);
}

model FindApisByPagingRequest {
  pageNumber?: long(name='pageNumber', description='pageNumber'),
  pageSize?: long(name='pageSize', description='pageSize'),
  status?: string(name='status', description='status'),
  name?: string(name='name', description='name'),
  aliasName?: string(name='aliasName', description='aliasName'),
}

model FindApisByPagingResponseBody = {
  code?: long(name='code', description='code'),
  data?: {
    list?: [ 
      {
        aliasName?: string(name='aliasName', description='aliasName'),
        attachedServices?: [ 
          {
            aliasName?: string(name='aliasName', description='aliasName'),
            creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
            description?: string(name='description', description='description'),
            id?: long(name='id', description='id'),
            isAutoRefresh?: boolean(name='isAutoRefresh', description='isAutoRefresh'),
            isHealth?: boolean(name='isHealth', description='isHealth'),
            name?: string(name='name', description='name'),
            registryId?: string(name='registryId', description='registryId'),
            serviceEnds?: [ 
              {
                creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
                id?: long(name='id', description='id'),
                ipAddress?: string(name='ipAddress', description='ipAddress'),
                port?: string(name='port', description='port'),
                serviceId?: long(name='serviceId', description='serviceId'),
                status?: long(name='status', description='status'),
                updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
              }
            ](name='serviceEnds', description='serviceEnds'),
            serviceNameInRegistry?: string(name='serviceNameInRegistry', description='serviceNameInRegistry'),
            sourceType?: long(name='sourceType', description='sourceType'),
            updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
          }
        ](name='attachedServices', description='attachedServices'),
        basePath?: string(name='basePath', description='basePath'),
        creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
        description?: string(name='description', description='description'),
        id?: long(name='id', description='id'),
        name?: string(name='name', description='name'),
        owneredPolicies?: [ 
          {
            apiId?: long(name='apiId', description='apiId'),
            apiName?: string(name='apiName', description='apiName'),
            creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
            direction?: string(name='direction', description='direction'),
            id?: long(name='id', description='id'),
            policyAliasName?: string(name='policyAliasName', description='policyAliasName'),
            policyContent?: string(name='policyContent', description='policyContent'),
            policyGroup?: string(name='policyGroup', description='policyGroup'),
            policyId?: string(name='policyId', description='policyId'),
            policyName?: string(name='policyName', description='policyName'),
            priority?: long(name='priority', description='priority'),
            scope?: string(name='scope', description='scope'),
            status?: boolean(name='status', description='status'),
            type?: long(name='type', description='type'),
            updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
          }
        ](name='owneredPolicies', description='owneredPolicies'),
        publishedGateway?: {
          armsInfo?: string(name='armsInfo', description='armsInfo'),
          autoCreateSlb?: boolean(name='autoCreateSlb', description='autoCreateSlb'),
          basePath?: string(name='basePath', description='basePath'),
          creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
          edasNamespaceId?: string(name='edasNamespaceId', description='edasNamespaceId'),
          gatewayType?: string(name='gatewayType', description='gatewayType'),
          id?: long(name='id', description='id'),
          name?: string(name='name', description='name'),
          podCidr?: string(name='podCidr', description='podCidr'),
          region?: string(name='region', description='region'),
          regionName?: string(name='regionName', description='regionName'),
          replica?: long(name='replica', description='replica'),
          runtimeOn?: string(name='runtimeOn', description='runtimeOn'),
          securityGroup?: string(name='securityGroup', description='securityGroup'),
          slb?: string(name='slb', description='slb'),
          slbAccessAddr?: string(name='slbAccessAddr', description='slbAccessAddr'),
          status?: string(name='status', description='status'),
          vpc?: string(name='vpc', description='vpc'),
          vswitch?: string(name='vswitch', description='vswitch'),
        }(name='publishedGateway', description='A short description of struct'),
        status?: string(name='status', description='status'),
        updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
      }
    ](name='list', description='list'),
    totalCount?: long(name='totalCount', description='totalCount'),
  }(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model FindApisByPagingResponse = {
  headers: map[string]string(name='headers'),
  body: FindApisByPagingResponseBody(name='body'),
}

/**
 * findApisByPaging
 */
async function findApisByPaging(gatewayId: string, request: FindApisByPagingRequest): FindApisByPagingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return findApisByPagingWithOptions(gatewayId, request, headers, runtime);
}

async function findApisByPagingWithOptions(gatewayId: string, request: FindApisByPagingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FindApisByPagingResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.pageNumber)) {
    query.pageNumber = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.pageSize = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query.status = request.status;
  }
  if (!Util.isUnset(request.name)) {
    query.name = request.name;
  }
  if (!Util.isUnset(request.aliasName)) {
    query.aliasName = request.aliasName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('FindApisByPaging', '2020-08-10', 'HTTPS', 'GET', 'AK', `/v1/gateway/${gatewayId}/api`, 'json', req, runtime);
}

model UpdateServiceEndsRequest {
  id?: long(name='id', description='id'),
  serviceNodes?: [ 
    {
      port?: string(name='port', description='port'),
      ipAddress?: string(name='ipAddress', description='ipAddress'),
      status?: long(name='status', description='status'),
    }
  ](name='serviceNodes', description='serviceNodes'),
}

model UpdateServiceEndsResponseBody = {
  code?: long(name='code', description='code'),
  data?: map[string]any(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model UpdateServiceEndsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateServiceEndsResponseBody(name='body'),
}

async function updateServiceEnds(serviceId: string, request: UpdateServiceEndsRequest): UpdateServiceEndsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceEndsWithOptions(serviceId, request, headers, runtime);
}

async function updateServiceEndsWithOptions(serviceId: string, request: UpdateServiceEndsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceEndsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.id)) {
    body.id = request.id;
  }
  if (!Util.isUnset(request.serviceNodes)) {
    body.serviceNodes = request.serviceNodes;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('UpdateServiceEnds', '2020-08-10', 'HTTPS', 'PUT', 'AK', `/v1/service/${serviceId}/serviceends`, 'json', req, runtime);
}

model FindGatewaysRequest {
  gatewayUniqueId?: string(name='gatewayUniqueId', description='gatewayUniqueId'),
  name?: string(name='name', description='name'),
  region?: string(name='region', description='region'),
  gatewayTypes?: string(name='gatewayTypes', description='gatewayTypes'),
  status?: string(name='status', description='status'),
  pageNumber?: string(name='pageNumber', description='pageNumber'),
  pageSize?: string(name='pageSize', description='pageSize'),
  namespace?: string(name='namespace', description='namespace'),
}

model FindGatewaysResponseBody = {
  code?: long(name='code', description='code'),
  data?: {
    list?: [ 
      {
        armsInfo?: {
          appId?: string(name='appId', description='appId'),
          appName?: string(name='appName', description='appName'),
          description?: string(name='description', description='description'),
          licenseKey?: string(name='licenseKey', description='licenseKey'),
        }(name='armsInfo', description='armsInfo'),
        autoCreateSlb?: boolean(name='autoCreateSlb', description='autoCreateSlb'),
        basePath?: string(name='basePath', description='basePath'),
        creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
        edasNamespaceId?: string(name='edasNamespaceId', description='edasNamespaceId'),
        gatewayType?: string(name='gatewayType', description='gatewayType'),
        id?: long(name='id', description='id'),
        name?: string(name='name', description='name'),
        podCidr?: string(name='podCidr', description='podCidr'),
        region?: string(name='region', description='region'),
        regionName?: string(name='regionName', description='regionName'),
        replica?: long(name='replica', description='replica'),
        runtimeOn?: string(name='runtimeOn', description='runtimeOn'),
        securityGroup?: string(name='securityGroup', description='securityGroup'),
        slb?: string(name='slb', description='slb'),
        slbAccessAddr?: string(name='slbAccessAddr', description='slbAccessAddr'),
        status?: string(name='status', description='status'),
        vpc?: string(name='vpc', description='vpc'),
        vswitch?: string(name='vswitch', description='vswitch'),
      }
    ](name='list', description='list'),
    totalCount?: long(name='totalCount', description='totalCount'),
  }(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model FindGatewaysResponse = {
  headers: map[string]string(name='headers'),
  body: FindGatewaysResponseBody(name='body'),
}

async function findGateways(request: FindGatewaysRequest): FindGatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return findGatewaysWithOptions(request, headers, runtime);
}

async function findGatewaysWithOptions(request: FindGatewaysRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FindGatewaysResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query.gatewayUniqueId = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.name)) {
    query.name = request.name;
  }
  if (!Util.isUnset(request.region)) {
    query.region = request.region;
  }
  if (!Util.isUnset(request.gatewayTypes)) {
    query.gatewayTypes = request.gatewayTypes;
  }
  if (!Util.isUnset(request.status)) {
    query.status = request.status;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query.pageNumber = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.pageSize = request.pageSize;
  }
  if (!Util.isUnset(request.namespace)) {
    query.namespace = request.namespace;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('FindGateways', '2020-08-10', 'HTTPS', 'GET', 'AK', `/v1/gateway`, 'json', req, runtime);
}

model GetAllRegistryRequest {
  pageNumber?: long(name='pageNumber', description='pageNumber'),
  pageSize?: long(name='pageSize', description='pageSize'),
  name?: string(name='name', description='name'),
  type?: long(name='type', description='type'),
  groupBy?: boolean(name='groupBy', description='groupBy'),
}

model GetAllRegistryResponseBody = {
  code?: long(name='code', description='code'),
  data?: {
    list?: [ 
      {
        address?: string(name='address', description='address'),
        creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
        description?: string(name='description', description='description'),
        gatewayId?: string(name='gatewayId', description='gatewayId'),
        id?: long(name='id', description='id'),
        name?: string(name='name', description='name'),
        type?: long(name='type', description='type'),
        updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
      }
    ](name='list', description='list'),
    totalCount?: long(name='totalCount', description='totalCount'),
  }(name='data', description='data'),
  message?: string(name='message', description='message'),
}

model GetAllRegistryResponse = {
  headers: map[string]string(name='headers'),
  body: GetAllRegistryResponseBody(name='body'),
}

/**
 * getAllRegistry
 */
async function getAllRegistry(gatewayId: string, request: GetAllRegistryRequest): GetAllRegistryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAllRegistryWithOptions(gatewayId, request, headers, runtime);
}

async function getAllRegistryWithOptions(gatewayId: string, request: GetAllRegistryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAllRegistryResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.pageNumber)) {
    query.pageNumber = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.pageSize = request.pageSize;
  }
  if (!Util.isUnset(request.name)) {
    query.name = request.name;
  }
  if (!Util.isUnset(request.type)) {
    query.type = request.type;
  }
  if (!Util.isUnset(request.groupBy)) {
    query.groupBy = request.groupBy;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetAllRegistry', '2020-08-10', 'HTTPS', 'GET', 'AK', `/v1/gateway/${gatewayId}/registry`, 'json', req, runtime);
}

model PullServiceInfoFromRegistryResponseBody = {
  code?: long(name='code', description='code'),
  data?: [ 
    {
      id?: long(name='id', description='id'),
      metaInfo?: string(name='metaInfo', description='metaInfo'),
      serviceEnds?: [ string ](name='serviceEnds'),
      serviceName?: string(name='serviceName', description='serviceName'),
    }
  ](name='data', description='data'),
  message?: string(name='message', description='message'),
}

model PullServiceInfoFromRegistryResponse = {
  headers: map[string]string(name='headers'),
  body: PullServiceInfoFromRegistryResponseBody(name='body'),
}

/**
 * pullServiceInfoFromRegistry
 */
async function pullServiceInfoFromRegistry(registryId: string): PullServiceInfoFromRegistryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return pullServiceInfoFromRegistryWithOptions(registryId, headers, runtime);
}

async function pullServiceInfoFromRegistryWithOptions(registryId: string, headers: map[string]string, runtime: Util.RuntimeOptions): PullServiceInfoFromRegistryResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('PullServiceInfoFromRegistry', '2020-08-10', 'HTTPS', 'GET', 'AK', `/v1/registry/${registryId}/pull`, 'json', req, runtime);
}

model DataScopesValue = {
  apiId?: long(name='apiId', description='apiId'),
  apiName?: string(name='apiName', description='apiName'),
  creationDateTime?: string(name='creationDateTime', description='creationDateTime'),
  direction?: string(name='direction', description='direction'),
  id?: long(name='id', description='id'),
  policyAliasName?: string(name='policyAliasName', description='policyAliasName'),
  policyContent?: string(name='policyContent', description='policyContent'),
  policyGroup?: string(name='policyGroup', description='policyGroup'),
  policyId?: string(name='policyId', description='policyId'),
  policyName?: string(name='policyName', description='policyName'),
  priority?: long(name='priority', description='priority'),
  scope?: string(name='scope', description='scope'),
  status?: boolean(name='status', description='status'),
  type?: long(name='type', description='type'),
  updateDateTime?: string(name='updateDateTime', description='updateDateTime'),
}

