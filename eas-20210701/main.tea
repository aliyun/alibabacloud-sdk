/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-beijing = 'pai-eas.cn-beijing.aliyuncs.com',
    cn-zhangjiakou = 'pai-eas.cn-zhangjiakou.aliyuncs.com',
    cn-hangzhou = 'pai-eas.cn-hangzhou.aliyuncs.com',
    cn-shanghai = 'pai-eas.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'pai-eas.cn-shenzhen.aliyuncs.com',
    cn-hongkong = 'pai-eas.cn-hongkong.aliyuncs.com',
    ap-southeast-1 = 'pai-eas.ap-southeast-1.aliyuncs.com',
    ap-southeast-5 = 'pai-eas.ap-southeast-5.aliyuncs.com',
    us-east-1 = 'pai-eas.us-east-1.aliyuncs.com',
    us-west-1 = 'pai-eas.us-west-1.aliyuncs.com',
    eu-central-1 = 'pai-eas.eu-central-1.aliyuncs.com',
    ap-south-1 = 'pai-eas.ap-south-1.aliyuncs.com',
    cn-shanghai-finance-1 = 'pai-eas.cn-shanghai-finance-1.aliyuncs.com',
    cn-north-2-gov-1 = 'pai-eas.cn-north-2-gov-1.aliyuncs.com',
    cn-chengdu = 'pai-eas.cn-chengdu.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('eas', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model Instance {
  hostIP?: string(name='HostIP'),
  hostName?: string(name='HostName'),
  innerIP?: string(name='InnerIP'),
  instanceName?: string(name='InstanceName'),
  instancePort?: int32(name='InstancePort'),
  lastState?: [  map[string]any ](name='LastState'),
  namespace?: string(name='Namespace'),
  readyProcesses?: int32(name='ReadyProcesses'),
  reason?: string(name='Reason'),
  restartCount?: int32(name='RestartCount'),
  startAt?: string(name='StartAt'),
  status?: string(name='Status'),
  totalProcesses?: int32(name='TotalProcesses'),
}

model Resource {
  clusterId?: string(name='ClusterId'),
  cpuCount?: int32(name='CpuCount'),
  createTime?: string(name='CreateTime'),
  extraData?: map[string]any(name='ExtraData'),
  gpuCount?: int32(name='GpuCount'),
  instanceCount?: int32(name='InstanceCount'),
  message?: string(name='Message'),
  postPaidInstanceCount?: int32(name='PostPaidInstanceCount'),
  prePaidInstanceCount?: int32(name='PrePaidInstanceCount'),
  resourceId?: string(name='ResourceId'),
  resourceName?: string(name='ResourceName'),
  status?: string(name='Status'),
  updateTime?: string(name='UpdateTime'),
}

model ResourceInstance {
  autoRenewal?: boolean(name='AutoRenewal'),
  chargeType?: string(name='ChargeType'),
  createTime?: string(name='CreateTime'),
  expiredTime?: string(name='ExpiredTime'),
  instanceCpuCount?: int32(name='InstanceCpuCount'),
  instanceGpuCount?: int32(name='InstanceGpuCount'),
  instanceId?: string(name='InstanceId'),
  instanceIp?: string(name='InstanceIp'),
  instanceMemory?: string(name='InstanceMemory'),
  instanceName?: string(name='InstanceName'),
  instanceStatus?: string(name='InstanceStatus'),
  instanceType?: string(name='InstanceType'),
  instanceUsedCpu?: float(name='InstanceUsedCpu'),
  instanceUsedGpu?: int32(name='InstanceUsedGpu'),
  instanceUsedMemory?: string(name='InstanceUsedMemory'),
}

model ResourceInstanceWorker {
  cpuLimit?: int32(name='CpuLimit'),
  cpuRequest?: int32(name='CpuRequest'),
  gpuLimit?: int32(name='GpuLimit'),
  gpuRequest?: int32(name='GpuRequest'),
  memoryLimit?: int32(name='MemoryLimit'),
  memoryRquest?: int32(name='MemoryRquest'),
  name?: string(name='Name'),
  ready?: boolean(name='Ready'),
  restartCount?: int32(name='RestartCount'),
  serviceName?: string(name='ServiceName'),
  startTime?: string(name='StartTime'),
  status?: string(name='Status'),
}

model Service {
  accessToken?: string(name='AccessToken'),
  callerUid?: string(name='CallerUid'),
  cpu?: int32(name='Cpu'),
  createTime?: string(name='CreateTime'),
  currentVersion?: int32(name='CurrentVersion'),
  extraData?: string(name='ExtraData'),
  gpu?: int32(name='Gpu'),
  image?: string(name='Image'),
  internetEndpoint?: string(name='InternetEndpoint'),
  intranetEndpoint?: string(name='IntranetEndpoint'),
  latestVersion?: int32(name='LatestVersion'),
  memory?: int32(name='Memory'),
  message?: string(name='Message'),
  namespace?: string(name='Namespace'),
  parentUid?: string(name='ParentUid'),
  pendingInstance?: int32(name='PendingInstance'),
  reason?: string(name='Reason'),
  region?: string(name='Region'),
  requestId?: string(name='RequestId'),
  resource?: string(name='Resource'),
  resourceAlias?: string(name='ResourceAlias'),
  runningInstance?: int32(name='RunningInstance'),
  serviceConfig?: string(name='ServiceConfig'),
  serviceGroup?: string(name='ServiceGroup'),
  serviceId?: string(name='ServiceId'),
  serviceName?: string(name='ServiceName'),
  serviceUid?: string(name='ServiceUid'),
  source?: string(name='Source'),
  status?: string(name='Status'),
  totalInstance?: int32(name='TotalInstance'),
  updateTime?: string(name='UpdateTime'),
  weight?: int32(name='Weight'),
}

model CreateBenchmarkTaskRequest {
  body?: string(name='body'),
}

model CreateBenchmarkTaskResponseBody = {
  message?: string(name='Message'),
  name?: string(name='Name'),
  region?: string(name='Region'),
  requestId?: string(name='RequestId'),
}

model CreateBenchmarkTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBenchmarkTaskResponseBody(name='body'),
}

async function createBenchmarkTask(request: CreateBenchmarkTaskRequest): CreateBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createBenchmarkTaskWithOptions(request, headers, runtime);
}

async function createBenchmarkTaskWithOptions(request: CreateBenchmarkTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateBenchmarkTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CreateBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateResourceRequest {
  autoRenewal?: boolean(name='AutoRenewal'),
  chargeType?: string(name='ChargeType'),
  ecsInstanceCount?: int32(name='EcsInstanceCount'),
  ecsInstanceType?: string(name='EcsInstanceType'),
}

model CreateResourceResponseBody = {
  clusterId?: string(name='ClusterId'),
  ownerUid?: string(name='OwnerUid'),
  requestId?: string(name='RequestId'),
  resourceId?: string(name='ResourceId'),
  resourceName?: string(name='ResourceName'),
}

model CreateResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateResourceResponseBody(name='body'),
}

async function createResource(request: CreateResourceRequest): CreateResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createResourceWithOptions(request, headers, runtime);
}

async function createResourceWithOptions(request: CreateResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoRenewal)) {
    body['AutoRenewal'] = request.autoRenewal;
  }
  if (!Util.isUnset(request.chargeType)) {
    body['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.ecsInstanceCount)) {
    body['EcsInstanceCount'] = request.ecsInstanceCount;
  }
  if (!Util.isUnset(request.ecsInstanceType)) {
    body['EcsInstanceType'] = request.ecsInstanceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateResource',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateResourceInstancesRequest {
  autoRenewal?: boolean(name='AutoRenewal'),
  chargeType?: string(name='ChargeType'),
  ecsInstanceCount?: int32(name='EcsInstanceCount'),
  ecsInstanceType?: string(name='EcsInstanceType'),
  userData?: string(name='UserData'),
}

model CreateResourceInstancesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateResourceInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateResourceInstancesResponseBody(name='body'),
}

async function createResourceInstances(ClusterId: string, ResourceId: string, request: CreateResourceInstancesRequest): CreateResourceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createResourceInstancesWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

async function createResourceInstancesWithOptions(ClusterId: string, ResourceId: string, request: CreateResourceInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateResourceInstancesResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoRenewal)) {
    body['AutoRenewal'] = request.autoRenewal;
  }
  if (!Util.isUnset(request.chargeType)) {
    body['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.ecsInstanceCount)) {
    body['EcsInstanceCount'] = request.ecsInstanceCount;
  }
  if (!Util.isUnset(request.ecsInstanceType)) {
    body['EcsInstanceType'] = request.ecsInstanceType;
  }
  if (!Util.isUnset(request.userData)) {
    body['UserData'] = request.userData;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateResourceInstances',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}/instances`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateResourceLogRequest {
  logStore?: string(name='LogStore'),
  projectName?: string(name='ProjectName'),
}

model CreateResourceLogResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateResourceLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateResourceLogResponseBody(name='body'),
}

async function createResourceLog(ClusterId: string, ResourceId: string, request: CreateResourceLogRequest): CreateResourceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createResourceLogWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

async function createResourceLogWithOptions(ClusterId: string, ResourceId: string, request: CreateResourceLogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateResourceLogResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.logStore)) {
    body['LogStore'] = request.logStore;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateResourceLog',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}/log`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateServiceRequest {
  body?: string(name='body'),
}

model CreateServiceResponseBody = {
  internetEndpoint?: string(name='InternetEndpoint'),
  intranetEndpoint?: string(name='IntranetEndpoint'),
  region?: string(name='Region'),
  requestId?: string(name='RequestId'),
  serviceId?: string(name='ServiceId'),
  serviceName?: string(name='ServiceName'),
  status?: string(name='Status'),
}

model CreateServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceResponseBody(name='body'),
}

async function createService(request: CreateServiceRequest): CreateServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceWithOptions(request, headers, runtime);
}

async function createServiceWithOptions(request: CreateServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CreateService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateServiceAutoScalerRequest {
  max?: int32(name='max'),
  min?: int32(name='min'),
  strategies?: {
    cpu?: float(name='cpu'),
    qps?: float(name='qps'),
  }(name='strategies'),
}

model CreateServiceAutoScalerResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateServiceAutoScalerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceAutoScalerResponseBody(name='body'),
}

async function createServiceAutoScaler(ClusterId: string, ServiceName: string, request: CreateServiceAutoScalerRequest): CreateServiceAutoScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceAutoScalerWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

async function createServiceAutoScalerWithOptions(ClusterId: string, ServiceName: string, request: CreateServiceAutoScalerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceAutoScalerResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var body : map[string]any = {};
  if (!Util.isUnset(request.max)) {
    body['max'] = request.max;
  }
  if (!Util.isUnset(request.min)) {
    body['min'] = request.min;
  }
  if (!Util.isUnset(request.strategies)) {
    body['strategies'] = request.strategies;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceAutoScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/autoscaler`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateServiceCronScalerRequest {
  excludeDates?: [ string ](name='ExcludeDates'),
  scaleJobs?: [ 
    {
      name?: string(name='Name'),
      schedule?: string(name='Schedule'),
      targetSize?: int32(name='TargetSize'),
    }
  ](name='ScaleJobs'),
}

model CreateServiceCronScalerResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateServiceCronScalerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceCronScalerResponseBody(name='body'),
}

async function createServiceCronScaler(ClusterId: string, ServiceName: string, request: CreateServiceCronScalerRequest): CreateServiceCronScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceCronScalerWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

async function createServiceCronScalerWithOptions(ClusterId: string, ServiceName: string, request: CreateServiceCronScalerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceCronScalerResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var body : map[string]any = {};
  if (!Util.isUnset(request.excludeDates)) {
    body['ExcludeDates'] = request.excludeDates;
  }
  if (!Util.isUnset(request.scaleJobs)) {
    body['ScaleJobs'] = request.scaleJobs;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceCronScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/cronscaler`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateServiceMirrorRequest {
  ratio?: int32(name='Ratio'),
  target?: [ string ](name='Target'),
}

model CreateServiceMirrorResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateServiceMirrorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceMirrorResponseBody(name='body'),
}

async function createServiceMirror(ClusterId: string, ServiceName: string, request: CreateServiceMirrorRequest): CreateServiceMirrorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceMirrorWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

async function createServiceMirrorWithOptions(ClusterId: string, ServiceName: string, request: CreateServiceMirrorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceMirrorResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ratio)) {
    body['Ratio'] = request.ratio;
  }
  if (!Util.isUnset(request.target)) {
    body['Target'] = request.target;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceMirror',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/mirror`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteBenchmarkTaskResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteBenchmarkTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBenchmarkTaskResponseBody(name='body'),
}

async function deleteBenchmarkTask(ClusterId: string, TaskName: string): DeleteBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteBenchmarkTaskWithOptions(ClusterId, TaskName, headers, runtime);
}

async function deleteBenchmarkTaskWithOptions(ClusterId: string, TaskName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteBenchmarkTaskResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  TaskName = OpenApiUtil.getEncodeParam(TaskName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks/${ClusterId}/${TaskName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteResourceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteResourceResponseBody(name='body'),
}

async function deleteResource(ClusterId: string, ResourceId: string): DeleteResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteResourceWithOptions(ClusterId, ResourceId, headers, runtime);
}

async function deleteResourceWithOptions(ClusterId: string, ResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteResourceResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteResource',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteResourceDLinkResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteResourceDLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteResourceDLinkResponseBody(name='body'),
}

async function deleteResourceDLink(ClusterId: string, ResourceId: string): DeleteResourceDLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteResourceDLinkWithOptions(ClusterId, ResourceId, headers, runtime);
}

async function deleteResourceDLinkWithOptions(ClusterId: string, ResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteResourceDLinkResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourceDLink',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}/dlink`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteResourceInstancesRequest {
  allFailed?: boolean(name='AllFailed'),
  instanceList?: string(name='InstanceList'),
}

model DeleteResourceInstancesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteResourceInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteResourceInstancesResponseBody(name='body'),
}

async function deleteResourceInstances(ClusterId: string, ResourceId: string, request: DeleteResourceInstancesRequest): DeleteResourceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteResourceInstancesWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

async function deleteResourceInstancesWithOptions(ClusterId: string, ResourceId: string, request: DeleteResourceInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteResourceInstancesResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.allFailed)) {
    query['AllFailed'] = request.allFailed;
  }
  if (!Util.isUnset(request.instanceList)) {
    query['InstanceList'] = request.instanceList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourceInstances',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}/instances`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteResourceLogResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteResourceLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteResourceLogResponseBody(name='body'),
}

async function deleteResourceLog(ClusterId: string, ResourceId: string): DeleteResourceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteResourceLogWithOptions(ClusterId, ResourceId, headers, runtime);
}

async function deleteResourceLogWithOptions(ClusterId: string, ResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteResourceLogResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourceLog',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}/log`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteServiceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceResponseBody(name='body'),
}

async function deleteService(ClusterId: string, ServiceName: string): DeleteServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceWithOptions(ClusterId, ServiceName, headers, runtime);
}

async function deleteServiceWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteServiceAutoScalerResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteServiceAutoScalerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceAutoScalerResponseBody(name='body'),
}

async function deleteServiceAutoScaler(ClusterId: string, ServiceName: string): DeleteServiceAutoScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceAutoScalerWithOptions(ClusterId, ServiceName, headers, runtime);
}

async function deleteServiceAutoScalerWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceAutoScalerResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceAutoScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/autoscaler`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteServiceCronScalerResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteServiceCronScalerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceCronScalerResponseBody(name='body'),
}

async function deleteServiceCronScaler(ClusterId: string, ServiceName: string): DeleteServiceCronScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceCronScalerWithOptions(ClusterId, ServiceName, headers, runtime);
}

async function deleteServiceCronScalerWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceCronScalerResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceCronScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/cronscaler`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteServiceInstancesRequest {
  instanceList?: string(name='InstanceList'),
}

model DeleteServiceInstancesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteServiceInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceInstancesResponseBody(name='body'),
}

async function deleteServiceInstances(ClusterId: string, ServiceName: string, request: DeleteServiceInstancesRequest): DeleteServiceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceInstancesWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

async function deleteServiceInstancesWithOptions(ClusterId: string, ServiceName: string, request: DeleteServiceInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceInstancesResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceList)) {
    query['InstanceList'] = request.instanceList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceInstances',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/instances`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteServiceMirrorResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteServiceMirrorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceMirrorResponseBody(name='body'),
}

async function deleteServiceMirror(ClusterId: string, ServiceName: string): DeleteServiceMirrorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceMirrorWithOptions(ClusterId, ServiceName, headers, runtime);
}

async function deleteServiceMirrorWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceMirrorResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceMirror',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/mirror`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeBenchmarkTaskResponseBody = {
  availableAgent?: long(name='AvailableAgent'),
  callerUid?: string(name='CallerUid'),
  desiredAgent?: long(name='DesiredAgent'),
  message?: string(name='Message'),
  parentUid?: string(name='ParentUid'),
  reason?: string(name='Reason'),
  requestId?: string(name='RequestId'),
  serviceName?: string(name='ServiceName'),
  status?: string(name='Status'),
  taskId?: string(name='TaskId'),
  taskName?: string(name='TaskName'),
  token?: string(name='Token'),
}

model DescribeBenchmarkTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBenchmarkTaskResponseBody(name='body'),
}

async function describeBenchmarkTask(ClusterId: string, TaskName: string): DescribeBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeBenchmarkTaskWithOptions(ClusterId, TaskName, headers, runtime);
}

async function describeBenchmarkTaskWithOptions(ClusterId: string, TaskName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeBenchmarkTaskResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  TaskName = OpenApiUtil.getEncodeParam(TaskName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks/${ClusterId}/${TaskName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeBenchmarkTaskReportResponseBody = {
  reportUrl?: string(name='ReportUrl'),
  requestId?: string(name='RequestId'),
}

model DescribeBenchmarkTaskReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBenchmarkTaskReportResponseBody(name='body'),
}

async function describeBenchmarkTaskReport(ClusterId: string, TaskName: string): DescribeBenchmarkTaskReportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeBenchmarkTaskReportWithOptions(ClusterId, TaskName, headers, runtime);
}

async function describeBenchmarkTaskReportWithOptions(ClusterId: string, TaskName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeBenchmarkTaskReportResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  TaskName = OpenApiUtil.getEncodeParam(TaskName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeBenchmarkTaskReport',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks/${ClusterId}/${TaskName}/report`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeResourceResponseBody = {
  clusterId?: string(name='ClusterId'),
  cpuCount?: int32(name='CpuCount'),
  createTime?: string(name='CreateTime'),
  extraData?: string(name='ExtraData'),
  gpuCount?: int32(name='GpuCount'),
  instanceCount?: int32(name='InstanceCount'),
  message?: string(name='Message'),
  ownerUid?: string(name='OwnerUid'),
  postPaidInstanceCount?: int32(name='PostPaidInstanceCount'),
  prePaidInstanceCount?: int32(name='PrePaidInstanceCount'),
  requestId?: string(name='RequestId'),
  resourceId?: string(name='ResourceId'),
  resourceName?: string(name='ResourceName'),
  status?: string(name='Status'),
  updateTime?: string(name='UpdateTime'),
}

model DescribeResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeResourceResponseBody(name='body'),
}

async function describeResource(ClusterId: string, ResourceId: string): DescribeResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeResourceWithOptions(ClusterId, ResourceId, headers, runtime);
}

async function describeResourceWithOptions(ClusterId: string, ResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeResourceResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeResource',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeResourceDLinkResponseBody = {
  auxVSwitchList?: [ string ](name='AuxVSwitchList'),
  destinationCIDRs?: string(name='DestinationCIDRs'),
  requestId?: string(name='RequestId'),
  securityGroupId?: string(name='SecurityGroupId'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
}

model DescribeResourceDLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeResourceDLinkResponseBody(name='body'),
}

async function describeResourceDLink(ClusterId: string, ResourceId: string): DescribeResourceDLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeResourceDLinkWithOptions(ClusterId, ResourceId, headers, runtime);
}

async function describeResourceDLinkWithOptions(ClusterId: string, ResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeResourceDLinkResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeResourceDLink',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}/dlink`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeResourceLogResponseBody = {
  logStore?: string(name='LogStore'),
  message?: string(name='Message'),
  projectName?: string(name='ProjectName'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model DescribeResourceLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeResourceLogResponseBody(name='body'),
}

async function describeResourceLog(ClusterId: string, ResourceId: string): DescribeResourceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeResourceLogWithOptions(ClusterId, ResourceId, headers, runtime);
}

async function describeResourceLogWithOptions(ClusterId: string, ResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeResourceLogResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeResourceLog',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}/log`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Service  
}

async function describeService(ClusterId: string, ServiceName: string): DescribeServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceWithOptions(ClusterId, ServiceName, headers, runtime);
}

async function describeServiceWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeServiceAutoScalerResponseBody = {
  behavior?: map[string]any(name='Behavior'),
  currentValues?: map[string]any(name='CurrentValues'),
  maxReplica?: int32(name='MaxReplica'),
  minReplica?: int32(name='MinReplica'),
  requestId?: string(name='RequestId'),
  serviceName?: string(name='ServiceName'),
  strategies?: map[string]any(name='Strategies'),
}

model DescribeServiceAutoScalerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceAutoScalerResponseBody(name='body'),
}

async function describeServiceAutoScaler(ClusterId: string, ServiceName: string): DescribeServiceAutoScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceAutoScalerWithOptions(ClusterId, ServiceName, headers, runtime);
}

async function describeServiceAutoScalerWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceAutoScalerResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceAutoScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/autoscaler`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeServiceCronScalerResponseBody = {
  excludeDates?: [ string ](name='ExcludeDates'),
  requestId?: string(name='RequestId'),
  scaleJobs?: [ 
    {
      createTime?: string(name='CreateTime'),
      lastProbeTime?: string(name='LastProbeTime'),
      message?: string(name='Message'),
      name?: string(name='Name'),
      schedule?: string(name='Schedule'),
      state?: string(name='State'),
      targetSize?: int32(name='TargetSize'),
    }
  ](name='ScaleJobs'),
  serviceName?: string(name='ServiceName'),
}

model DescribeServiceCronScalerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceCronScalerResponseBody(name='body'),
}

async function describeServiceCronScaler(ClusterId: string, ServiceName: string): DescribeServiceCronScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceCronScalerWithOptions(ClusterId, ServiceName, headers, runtime);
}

async function describeServiceCronScalerWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceCronScalerResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceCronScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/cronscaler`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeServiceLogRequest {
  endTime?: string(name='EndTime'),
  ip?: string(name='Ip'),
  keyword?: string(name='Keyword'),
  pageNum?: long(name='PageNum'),
  pageSize?: long(name='PageSize'),
  startTime?: string(name='StartTime'),
}

model DescribeServiceLogResponseBody = {
  logs?: [ string ](name='Logs'),
  pageNum?: long(name='PageNum'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
  totalPageNum?: long(name='TotalPageNum'),
}

model DescribeServiceLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceLogResponseBody(name='body'),
}

async function describeServiceLog(ClusterId: string, ServiceName: string, request: DescribeServiceLogRequest): DescribeServiceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceLogWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

async function describeServiceLogWithOptions(ClusterId: string, ServiceName: string, request: DescribeServiceLogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceLogResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceLog',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/logs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeServiceMirrorResponseBody = {
  ratio?: string(name='Ratio'),
  requestId?: string(name='RequestId'),
  serviceName?: string(name='ServiceName'),
  target?: string(name='Target'),
}

model DescribeServiceMirrorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMirrorResponseBody(name='body'),
}

async function describeServiceMirror(ClusterId: string, ServiceName: string): DescribeServiceMirrorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceMirrorWithOptions(ClusterId, ServiceName, headers, runtime);
}

async function describeServiceMirrorWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceMirrorResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceMirror',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/mirror`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListBenchmarkTaskResponseBody = {
  requestId?: string(name='RequestId'),
  tasks?: [ 
    {
      availableAgent?: long(name='AvailableAgent'),
      createTime?: string(name='CreateTime'),
      message?: string(name='Message'),
      region?: string(name='Region'),
      serviceName?: string(name='ServiceName'),
      status?: string(name='Status'),
      taskId?: string(name='TaskId'),
      taskName?: string(name='TaskName'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='Tasks'),
}

model ListBenchmarkTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListBenchmarkTaskResponseBody(name='body'),
}

async function listBenchmarkTask(): ListBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listBenchmarkTaskWithOptions(headers, runtime);
}

async function listBenchmarkTaskWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListBenchmarkTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListResourceInstanceWorkerRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListResourceInstanceWorkerResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  pods?: [
    ResourceInstanceWorker
  ](name='Pods'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListResourceInstanceWorkerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceInstanceWorkerResponseBody(name='body'),
}

async function listResourceInstanceWorker(ClusterId: string, ResourceId: string, InstanceName: string, request: ListResourceInstanceWorkerRequest): ListResourceInstanceWorkerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourceInstanceWorkerWithOptions(ClusterId, ResourceId, InstanceName, request, headers, runtime);
}

async function listResourceInstanceWorkerWithOptions(ClusterId: string, ResourceId: string, InstanceName: string, request: ListResourceInstanceWorkerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListResourceInstanceWorkerResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  InstanceName = OpenApiUtil.getEncodeParam(InstanceName);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceInstanceWorker',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}/instance/${InstanceName}/workers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListResourceInstancesRequest {
  chargeType?: string(name='ChargeType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListResourceInstancesResponseBody = {
  instances?: [
    ResourceInstance
  ](name='Instances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListResourceInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceInstancesResponseBody(name='body'),
}

async function listResourceInstances(ClusterId: string, ResourceId: string, request: ListResourceInstancesRequest): ListResourceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourceInstancesWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

async function listResourceInstancesWithOptions(ClusterId: string, ResourceId: string, request: ListResourceInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListResourceInstancesResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceInstances',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListResourceServicesRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListResourceServicesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  services?: [
    Service
  ](name='Services'),
  totalCount?: int32(name='TotalCount'),
}

model ListResourceServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceServicesResponseBody(name='body'),
}

async function listResourceServices(ClusterId: string, ResourceId: string, request: ListResourceServicesRequest): ListResourceServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourceServicesWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

async function listResourceServicesWithOptions(ClusterId: string, ResourceId: string, request: ListResourceServicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListResourceServicesResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceServices',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}/services`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListResourcesRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListResourcesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  resources?: [
    Resource
  ](name='Resources'),
  totalCount?: int32(name='TotalCount'),
}

model ListResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourcesResponseBody(name='body'),
}

async function listResources(request: ListResourcesRequest): ListResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourcesWithOptions(request, headers, runtime);
}

async function listResourcesWithOptions(request: ListResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResources',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListServiceInstancesRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListServiceInstancesResponseBody = {
  instances?: [
    Instance
  ](name='Instances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListServiceInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServiceInstancesResponseBody(name='body'),
}

async function listServiceInstances(ClusterId: string, ServiceName: string, request: ListServiceInstancesRequest): ListServiceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServiceInstancesWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

async function listServiceInstancesWithOptions(ClusterId: string, ServiceName: string, request: ListServiceInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListServiceInstancesResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServiceInstances',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListServicesRequest {
  filter?: string(name='Filter'),
  order?: string(name='Order'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  sort?: string(name='Sort'),
}

model ListServicesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  services?: [
    Service
  ](name='Services'),
  totalCount?: int32(name='TotalCount'),
}

model ListServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServicesResponseBody(name='body'),
}

async function listServices(request: ListServicesRequest): ListServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServicesWithOptions(request, headers, runtime);
}

async function listServicesWithOptions(request: ListServicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListServicesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sort)) {
    query['Sort'] = request.sort;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServices',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ReleaseServiceRequest {
  trafficState?: string(name='TrafficState'),
  weight?: int32(name='Weight'),
}

model ReleaseServiceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ReleaseServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReleaseServiceResponseBody(name='body'),
}

async function releaseService(ClusterId: string, ServiceName: string, request: ReleaseServiceRequest): ReleaseServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return releaseServiceWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

async function releaseServiceWithOptions(ClusterId: string, ServiceName: string, request: ReleaseServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ReleaseServiceResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var body : map[string]any = {};
  if (!Util.isUnset(request.trafficState)) {
    body['TrafficState'] = request.trafficState;
  }
  if (!Util.isUnset(request.weight)) {
    body['Weight'] = request.weight;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/release`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StartBenchmarkTaskResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model StartBenchmarkTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartBenchmarkTaskResponseBody(name='body'),
}

async function startBenchmarkTask(ClusterId: string, TaskName: string): StartBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startBenchmarkTaskWithOptions(ClusterId, TaskName, headers, runtime);
}

async function startBenchmarkTaskWithOptions(ClusterId: string, TaskName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartBenchmarkTaskResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  TaskName = OpenApiUtil.getEncodeParam(TaskName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks/${ClusterId}/${TaskName}/start`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StartServiceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model StartServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartServiceResponseBody(name='body'),
}

async function startService(ClusterId: string, ServiceName: string): StartServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startServiceWithOptions(ClusterId, ServiceName, headers, runtime);
}

async function startServiceWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartServiceResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/start`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopBenchmarkTaskResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model StopBenchmarkTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopBenchmarkTaskResponseBody(name='body'),
}

async function stopBenchmarkTask(ClusterId: string, TaskName: string): StopBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopBenchmarkTaskWithOptions(ClusterId, TaskName, headers, runtime);
}

async function stopBenchmarkTaskWithOptions(ClusterId: string, TaskName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopBenchmarkTaskResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  TaskName = OpenApiUtil.getEncodeParam(TaskName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks/${ClusterId}/${TaskName}/stop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopServiceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model StopServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopServiceResponseBody(name='body'),
}

async function stopService(ClusterId: string, ServiceName: string): StopServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopServiceWithOptions(ClusterId, ServiceName, headers, runtime);
}

async function stopServiceWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopServiceResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/stop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateBenchmarkTaskRequest {
  body?: string(name='body'),
}

model UpdateBenchmarkTaskResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateBenchmarkTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateBenchmarkTaskResponseBody(name='body'),
}

async function updateBenchmarkTask(ClusterId: string, TaskName: string, request: UpdateBenchmarkTaskRequest): UpdateBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateBenchmarkTaskWithOptions(ClusterId, TaskName, request, headers, runtime);
}

async function updateBenchmarkTaskWithOptions(ClusterId: string, TaskName: string, request: UpdateBenchmarkTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateBenchmarkTaskResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  TaskName = OpenApiUtil.getEncodeParam(TaskName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks/${ClusterId}/${TaskName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateResourceRequest {
  resourceName?: string(name='ResourceName'),
}

model UpdateResourceResponseBody = {
  requestId?: string(name='RequestId'),
  resourceId?: string(name='ResourceId'),
  resourceName?: string(name='ResourceName'),
}

model UpdateResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateResourceResponseBody(name='body'),
}

async function updateResource(ClusterId: string, ResourceId: string, request: UpdateResourceRequest): UpdateResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateResourceWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

async function updateResourceWithOptions(ClusterId: string, ResourceId: string, request: UpdateResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateResourceResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.resourceName)) {
    body['ResourceName'] = request.resourceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateResource',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateResourceDLinkRequest {
  destinationCIDRs?: string(name='DestinationCIDRs'),
  securityGroupId?: string(name='SecurityGroupId'),
  vSwitchId?: string(name='VSwitchId'),
  vSwitchIdList?: [ string ](name='VSwitchIdList'),
}

model UpdateResourceDLinkResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateResourceDLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateResourceDLinkResponseBody(name='body'),
}

async function updateResourceDLink(ClusterId: string, ResourceId: string, request: UpdateResourceDLinkRequest): UpdateResourceDLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateResourceDLinkWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

async function updateResourceDLinkWithOptions(ClusterId: string, ResourceId: string, request: UpdateResourceDLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateResourceDLinkResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.destinationCIDRs)) {
    body['DestinationCIDRs'] = request.destinationCIDRs;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    body['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    body['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vSwitchIdList)) {
    body['VSwitchIdList'] = request.vSwitchIdList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateResourceDLink',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}/dlink`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateServiceRequest {
  body?: string(name='body'),
}

model UpdateServiceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceResponseBody(name='body'),
}

async function updateService(ClusterId: string, ServiceName: string, request: UpdateServiceRequest): UpdateServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

async function updateServiceWithOptions(ClusterId: string, ServiceName: string, request: UpdateServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateServiceAutoScalerRequest {
  max?: int32(name='max'),
  min?: int32(name='min'),
  strategies?: {
    cpu?: float(name='cpu'),
    qps?: float(name='qps'),
  }(name='strategies'),
}

model UpdateServiceAutoScalerResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateServiceAutoScalerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceAutoScalerResponseBody(name='body'),
}

async function updateServiceAutoScaler(ClusterId: string, ServiceName: string, request: UpdateServiceAutoScalerRequest): UpdateServiceAutoScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceAutoScalerWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

async function updateServiceAutoScalerWithOptions(ClusterId: string, ServiceName: string, request: UpdateServiceAutoScalerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceAutoScalerResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var body : map[string]any = {};
  if (!Util.isUnset(request.max)) {
    body['max'] = request.max;
  }
  if (!Util.isUnset(request.min)) {
    body['min'] = request.min;
  }
  if (!Util.isUnset(request.strategies)) {
    body['strategies'] = request.strategies;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceAutoScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/autoscaler`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateServiceCronScalerRequest {
  excludeDates?: [ string ](name='ExcludeDates'),
  scaleJobs?: [ 
    {
      name?: string(name='Name'),
      schedule?: string(name='Schedule'),
      targetSize?: int32(name='TargetSize'),
    }
  ](name='ScaleJobs'),
}

model UpdateServiceCronScalerResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateServiceCronScalerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceCronScalerResponseBody(name='body'),
}

async function updateServiceCronScaler(ClusterId: string, ServiceName: string, request: UpdateServiceCronScalerRequest): UpdateServiceCronScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceCronScalerWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

async function updateServiceCronScalerWithOptions(ClusterId: string, ServiceName: string, request: UpdateServiceCronScalerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceCronScalerResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var body : map[string]any = {};
  if (!Util.isUnset(request.excludeDates)) {
    body['ExcludeDates'] = request.excludeDates;
  }
  if (!Util.isUnset(request.scaleJobs)) {
    body['ScaleJobs'] = request.scaleJobs;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceCronScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/cronscaler`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateServiceMirrorRequest {
  ratio?: int32(name='Ratio'),
  target?: [ string ](name='Target'),
}

model UpdateServiceMirrorResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateServiceMirrorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceMirrorResponseBody(name='body'),
}

async function updateServiceMirror(ClusterId: string, ServiceName: string, request: UpdateServiceMirrorRequest): UpdateServiceMirrorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceMirrorWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

async function updateServiceMirrorWithOptions(ClusterId: string, ServiceName: string, request: UpdateServiceMirrorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceMirrorResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ratio)) {
    body['Ratio'] = request.ratio;
  }
  if (!Util.isUnset(request.target)) {
    body['Target'] = request.target;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceMirror',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/mirror`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateServiceVersionRequest {
  version?: int32(name='Version'),
}

model UpdateServiceVersionResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateServiceVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceVersionResponseBody(name='body'),
}

async function updateServiceVersion(ClusterId: string, ServiceName: string, request: UpdateServiceVersionRequest): UpdateServiceVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceVersionWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

async function updateServiceVersionWithOptions(ClusterId: string, ServiceName: string, request: UpdateServiceVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceVersionResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var body : map[string]any = {};
  if (!Util.isUnset(request.version)) {
    body['Version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceVersion',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/version`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

