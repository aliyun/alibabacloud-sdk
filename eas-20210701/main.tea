/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    'cn-beijing' = 'pai-eas.cn-beijing.aliyuncs.com',
    'cn-zhangjiakou' = 'pai-eas.cn-zhangjiakou.aliyuncs.com',
    'cn-hangzhou' = 'pai-eas.cn-hangzhou.aliyuncs.com',
    'cn-shanghai' = 'pai-eas.cn-shanghai.aliyuncs.com',
    'cn-shenzhen' = 'pai-eas.cn-shenzhen.aliyuncs.com',
    'cn-hongkong' = 'pai-eas.cn-hongkong.aliyuncs.com',
    'ap-southeast-1' = 'pai-eas.ap-southeast-1.aliyuncs.com',
    'ap-southeast-5' = 'pai-eas.ap-southeast-5.aliyuncs.com',
    'us-east-1' = 'pai-eas.us-east-1.aliyuncs.com',
    'us-west-1' = 'pai-eas.us-west-1.aliyuncs.com',
    'eu-central-1' = 'pai-eas.eu-central-1.aliyuncs.com',
    'ap-south-1' = 'pai-eas.ap-south-1.aliyuncs.com',
    'cn-shanghai-finance-1' = 'pai-eas.cn-shanghai-finance-1.aliyuncs.com',
    'cn-north-2-gov-1' = 'pai-eas.cn-north-2-gov-1.aliyuncs.com',
    'cn-chengdu' = 'pai-eas.cn-chengdu.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('eas', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ContainerInfo {
  currentReaon?: string(name='CurrentReaon'),
  currentStatus?: string(name='CurrentStatus'),
  currentTimestamp?: string(name='CurrentTimestamp'),
  image?: string(name='Image'),
  lastReason?: string(name='LastReason'),
  lastStatus?: string(name='LastStatus'),
  lastTimestamp?: string(name='LastTimestamp'),
  name?: string(name='Name'),
  port?: int32(name='Port'),
  ready?: boolean(name='Ready'),
  restartCount?: int32(name='RestartCount'),
}

model Group {
  accessToken?: string(name='AccessToken'),
  clusterId?: string(name='ClusterId'),
  createTime?: string(name='CreateTime'),
  internetEndpoint?: string(name='InternetEndpoint'),
  intranetEndpoint?: string(name='IntranetEndpoint'),
  name?: string(name='Name'),
  queueService?: string(name='QueueService'),
  trafficMode?: string(name='TrafficMode'),
  updateTime?: string(name='UpdateTime'),
}

model Instance {
  currentAmount?: float(name='CurrentAmount', example='0.444'),
  externalIP?: string(name='ExternalIP', example='192.168.1.100'),
  externalInstancePort?: int32(name='ExternalInstancePort', example='8080'),
  hostIP?: string(name='HostIP'),
  hostName?: string(name='HostName'),
  innerIP?: string(name='InnerIP'),
  instanceName?: string(name='InstanceName'),
  instancePort?: int32(name='InstancePort'),
  instanceType?: string(name='InstanceType', example='ecs.c7.large'),
  isSpot?: boolean(name='IsSpot', example='false'),
  isolated?: boolean(name='Isolated', example='false'),
  lastState?: [  map[string]any ](name='LastState'),
  namespace?: string(name='Namespace'),
  originalAmount?: float(name='OriginalAmount', example='2.2'),
  readyProcesses?: int32(name='ReadyProcesses'),
  reason?: string(name='Reason'),
  resourceType?: string(name='ResourceType', example='PublicResource'),
  restartCount?: int32(name='RestartCount'),
  role?: string(name='Role', example='Standard'),
  startAt?: string(name='StartAt', deprecated=true),
  startTime?: string(name='StartTime'),
  status?: string(name='Status'),
  tenantHostIP?: string(name='TenantHostIP', example='192.168.0.39'),
  tenantInstanceIP?: string(name='TenantInstanceIP', example='192.168.0.39'),
  totalProcesses?: int32(name='TotalProcesses'),
  zone?: string(name='Zone', example='cn-shanghai-a'),
}

model Resource {
  clusterId?: string(name='ClusterId'),
  cpuCount?: int32(name='CpuCount'),
  cpuUsed?: int32(name='CpuUsed'),
  createTime?: string(name='CreateTime'),
  extraData?: map[string]any(name='ExtraData'),
  features?: [ string ](name='Features'),
  gpuCount?: int32(name='GpuCount'),
  gpuUsed?: float(name='GpuUsed'),
  instanceCount?: int32(name='InstanceCount'),
  instanceMaxAllocatableCPU?: int32(name='InstanceMaxAllocatableCPU'),
  instanceMaxAllocatableGPU?: float(name='InstanceMaxAllocatableGPU'),
  instanceMaxAllocatableMemory?: int32(name='InstanceMaxAllocatableMemory'),
  memory?: int32(name='Memory'),
  memoryUsed?: int32(name='MemoryUsed'),
  message?: string(name='Message'),
  postPaidInstanceCount?: int32(name='PostPaidInstanceCount'),
  prePaidInstanceCount?: int32(name='PrePaidInstanceCount'),
  resourceId?: string(name='ResourceId'),
  resourceName?: string(name='ResourceName'),
  resourceType?: string(name='ResourceType'),
  status?: string(name='Status'),
  updateTime?: string(name='UpdateTime'),
  vendor?: string(name='Vendor'),
}

model ResourceInstance {
  arch?: string(name='Arch'),
  autoRenewal?: boolean(name='AutoRenewal'),
  chargeType?: string(name='ChargeType'),
  createTime?: string(name='CreateTime'),
  expiredTime?: string(name='ExpiredTime'),
  instanceCpuCount?: int32(name='InstanceCpuCount'),
  instanceGpuCount?: int32(name='InstanceGpuCount'),
  instanceGpuMemory?: string(name='InstanceGpuMemory'),
  instanceId?: string(name='InstanceId'),
  instanceIp?: string(name='InstanceIp'),
  instanceMemory?: string(name='InstanceMemory'),
  instanceName?: string(name='InstanceName'),
  instanceStatus?: string(name='InstanceStatus'),
  instanceSystemDiskSize?: int32(name='InstanceSystemDiskSize'),
  instanceTenantIp?: string(name='InstanceTenantIp'),
  instanceType?: string(name='InstanceType'),
  instanceUsedCpu?: float(name='InstanceUsedCpu'),
  instanceUsedGpu?: float(name='InstanceUsedGpu'),
  instanceUsedGpuMemory?: string(name='InstanceUsedGpuMemory'),
  instanceUsedMemory?: string(name='InstanceUsedMemory'),
  labels?: [ 
    {
      labelKey?: string(name='LabelKey'),
      labelValue?: string(name='LabelValue'),
    }
  ](name='Labels'),
  region?: string(name='Region'),
  resourceId?: string(name='ResourceId'),
  zone?: string(name='Zone'),
}

model ResourceInstanceWorker {
  cpuLimit?: int32(name='CpuLimit'),
  cpuRequest?: int32(name='CpuRequest'),
  gpuLimit?: int32(name='GpuLimit'),
  gpuRequest?: int32(name='GpuRequest'),
  memoryLimit?: int32(name='MemoryLimit'),
  memoryRquest?: int32(name='MemoryRquest'),
  name?: string(name='Name'),
  ready?: boolean(name='Ready'),
  restartCount?: int32(name='RestartCount'),
  serviceName?: string(name='ServiceName'),
  startTime?: string(name='StartTime'),
  status?: string(name='Status'),
}

model Service {
  accessToken?: string(name='AccessToken'),
  appConfig?: string(name='AppConfig'),
  appSpecName?: string(name='AppSpecName'),
  appType?: string(name='AppType'),
  appVersion?: string(name='AppVersion'),
  autoscalerEnabled?: boolean(name='AutoscalerEnabled'),
  callerUid?: string(name='CallerUid'),
  cpu?: int32(name='Cpu'),
  createTime?: string(name='CreateTime'),
  cronscalerEnabled?: boolean(name='CronscalerEnabled'),
  currentVersion?: int32(name='CurrentVersion'),
  extraData?: string(name='ExtraData'),
  GPUCorePercentage?: int32(name='GPUCorePercentage'),
  GPUMemory?: int32(name='GPUMemory'),
  gateway?: string(name='Gateway'),
  gpu?: int32(name='Gpu'),
  image?: string(name='Image'),
  instanceCountInResource?: {
    dedicated?: int32(name='Dedicated'),
    public?: int32(name='Public'),
    quota?: int32(name='Quota'),
  }(name='InstanceCountInResource'),
  internetEndpoint?: string(name='InternetEndpoint'),
  intranetEndpoint?: string(name='IntranetEndpoint'),
  labels?: [ 
    {
      labelKey?: string(name='LabelKey'),
      labelValue?: string(name='LabelValue'),
    }
  ](name='Labels'),
  latestVersion?: int32(name='LatestVersion'),
  memory?: int32(name='Memory'),
  message?: string(name='Message'),
  namespace?: string(name='Namespace'),
  parentUid?: string(name='ParentUid'),
  pendingInstance?: int32(name='PendingInstance'),
  quotaId?: string(name='QuotaId'),
  reason?: string(name='Reason'),
  region?: string(name='Region'),
  requestId?: string(name='RequestId'),
  resource?: string(name='Resource'),
  resourceAlias?: string(name='ResourceAlias'),
  resourceBurstable?: boolean(name='ResourceBurstable'),
  role?: string(name='Role'),
  roleAttrs?: string(name='RoleAttrs'),
  runningInstance?: int32(name='RunningInstance'),
  safetyLock?: string(name='SafetyLock'),
  secondaryInternetEndpoint?: string(name='SecondaryInternetEndpoint'),
  secondaryIntranetEndpoint?: string(name='SecondaryIntranetEndpoint'),
  serviceConfig?: string(name='ServiceConfig'),
  serviceGroup?: string(name='ServiceGroup'),
  serviceId?: string(name='ServiceId'),
  serviceName?: string(name='ServiceName'),
  serviceUid?: string(name='ServiceUid'),
  source?: string(name='Source'),
  status?: string(name='Status'),
  totalInstance?: int32(name='TotalInstance'),
  trafficState?: string(name='TrafficState'),
  updateTime?: string(name='UpdateTime'),
  weight?: int32(name='Weight'),
  workspaceId?: string(name='WorkspaceId'),
}

model AttachGatewayDomainRequest {
  customDomain?: {
    certificateId?: string(name='CertificateId', description='The ID of the SSL certificate bound to the domain name. Obtain the certificate ID after you upload or purchase a certificate in the [Certificate Management Service](https://yundunnext.console.aliyun.com/?spm=5176.2020520163.console-base_help.2.4b3baJixaJixOc\\\\&p=cas) console.', example='1473**25'),
    domain?: string(name='Domain', description='The custom domain name.

This parameter is required.', example='test.com'),
    type?: string(name='Type', description='The domain name type.

Valid value:

*   intranet: internal network.
*   internet: public network.

This parameter is required.', example='intranet'),
  }(name='CustomDomain', description='The custom domain name information.

This parameter is required.'),
}

model AttachGatewayDomainShrinkRequest {
  customDomainShrink?: string(name='CustomDomain', description='The custom domain name information.

This parameter is required.'),
}

model AttachGatewayDomainResponseBody = {
  gatewayId?: string(name='GatewayId', description='The ID of the private gateway. To obtain the private gateway ID, see the GatewayId parameter in the response parameters of the [ListGateway](https://apiworkbench.aliyun-inc.com/document/eas/2021-07-01/ListGateway?spm=openapi-amp.newDocPublishment.0.0.765e281fL2IcjJ\\\\&ampEnv=online) operation.', example='gw-1uhcqmsc7x22******'),
  message?: string(name='Message', description='The error message.', example='Successfully update custom endpoint for gateway gw-1uhcqmsc7x22******'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='40325405-579C-4D82****'),
}

model AttachGatewayDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AttachGatewayDomainResponseBody(name='body'),
}

/**
 * @summary Binds a custom domain name to a private gateway.
 *
 * @param tmpReq AttachGatewayDomainRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachGatewayDomainResponse
 */
async function attachGatewayDomainWithOptions(ClusterId: string, GatewayId: string, tmpReq: AttachGatewayDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AttachGatewayDomainResponse {
  Util.validateModel(tmpReq);
  var request = new AttachGatewayDomainShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.customDomain)) {
    request.customDomainShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.customDomain, 'CustomDomain', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.customDomainShrink)) {
    query['CustomDomain'] = request.customDomainShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachGatewayDomain',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GatewayId)}/domain/attach`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Binds a custom domain name to a private gateway.
 *
 * @param request AttachGatewayDomainRequest
 * @return AttachGatewayDomainResponse
 */
async function attachGatewayDomain(ClusterId: string, GatewayId: string, request: AttachGatewayDomainRequest): AttachGatewayDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return attachGatewayDomainWithOptions(ClusterId, GatewayId, request, headers, runtime);
}

model CloneServiceRequest {
  labels?: map[string]string(name='Labels', description='The label of the service to be cloned.'),
  body?: string(name='body', description='The request body. For more information, see [CreateService](https://help.aliyun.com/document_detail/412086.html).', example='{   "name": "foo",   "model_path": "http://path/to/model.tar.gz",   "processor": "tensorflow_cpu",   "metadata": {     "instance": 2,     "memory": 7000,     "cpu": 4   } }'),
}

model CloneServiceShrinkRequest {
  labelsShrink?: string(name='Labels', description='The label of the service to be cloned.'),
  body?: string(name='body', description='The request body. For more information, see [CreateService](https://help.aliyun.com/document_detail/412086.html).', example='{   "name": "foo",   "model_path": "http://path/to/model.tar.gz",   "processor": "tensorflow_cpu",   "metadata": {     "instance": 2,     "memory": 7000,     "cpu": 4   } }'),
}

model CloneServiceResponseBody = {
  internetEndpoint?: string(name='InternetEndpoint', description='The public endpoint of the service.', example='http://10123*****.cn-shanghai.aliyuncs.com/api/predict/echo'),
  intranetEndpoint?: string(name='IntranetEndpoint', description='The private endpoint of the service.', example='http://10123*****.vpc.cn-shanghai.aliyuncs.com/api/predict/echo'),
  requestId?: string(name='RequestId', description='Id of the request', example='40325405-579C-4D82****'),
  serviceId?: string(name='ServiceId', description='The service ID.', example='eas-m-r9knx7n9guf2p*****'),
  serviceName?: string(name='ServiceName', description='The service name.', example='foo'),
  status?: string(name='Status', description='The service status.', example='Creating'),
}

model CloneServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CloneServiceResponseBody(name='body'),
}

/**
 * @summary Clones a service.
 *
 * @param tmpReq CloneServiceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CloneServiceResponse
 */
async function cloneServiceWithOptions(ClusterId: string, ServiceName: string, tmpReq: CloneServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CloneServiceResponse {
  Util.validateModel(tmpReq);
  var request = new CloneServiceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.labels)) {
    request.labelsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.labels, 'Labels', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.labelsShrink)) {
    query['Labels'] = request.labelsShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CloneService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/clone`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Clones a service.
 *
 * @param request CloneServiceRequest
 * @return CloneServiceResponse
 */
async function cloneService(ClusterId: string, ServiceName: string, request: CloneServiceRequest): CloneServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cloneServiceWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model CommitServiceResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Success'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model CommitServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CommitServiceResponseBody(name='body'),
}

/**
 * @summary Commits the Worker0 container in the custom container service and deploys the container as a new image.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CommitServiceResponse
 */
async function commitServiceWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): CommitServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CommitService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/commit`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Commits the Worker0 container in the custom container service and deploys the container as a new image.
 *
 * @return CommitServiceResponse
 */
async function commitService(ClusterId: string, ServiceName: string): CommitServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return commitServiceWithOptions(ClusterId, ServiceName, headers, runtime);
}

model CreateAclPolicyRequest {
  aclPolicyList?: [ 
    {
      comment?: string(name='Comment', description='The comment on the IP CIDR block in the VPC that can access the private gateway.', example='default'),
      entry?: string(name='Entry', description='The IP CIDR block in the VPC that can access the private gateway.

This parameter is required.', example='10.23.XX.XX/32'),
    }
  ](name='AclPolicyList', description='The whitelisted IP CIDR blocks in the VPC that can access the private gateway.

This parameter is required.'),
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC). For more information about how to obtain the VPC ID, see DescribeVpcs.', example='vpc-uf66uio7md****'),
}

model CreateAclPolicyShrinkRequest {
  aclPolicyListShrink?: string(name='AclPolicyList', description='The whitelisted IP CIDR blocks in the VPC that can access the private gateway.

This parameter is required.'),
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC). For more information about how to obtain the VPC ID, see DescribeVpcs.', example='vpc-uf66uio7md****'),
}

model CreateAclPolicyResponseBody = {
  gatewayId?: string(name='GatewayId', description='The private gateway ID.', example='gw-1uhcqmsc7x22******'),
  message?: string(name='Message', description='The returned message.', example='Successfully add acl policy for gateway'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model CreateAclPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAclPolicyResponseBody(name='body'),
}

/**
 * @summary Creates an access control list (ACL) for a private gateway. The IP CIDR blocks added to the ACL can access the private gateway.
 *
 * @param tmpReq CreateAclPolicyRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAclPolicyResponse
 */
async function createAclPolicyWithOptions(ClusterId: string, GatewayId: string, tmpReq: CreateAclPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAclPolicyResponse {
  Util.validateModel(tmpReq);
  var request = new CreateAclPolicyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.aclPolicyList)) {
    request.aclPolicyListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.aclPolicyList, 'AclPolicyList', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.aclPolicyListShrink)) {
    query['AclPolicyList'] = request.aclPolicyListShrink;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAclPolicy',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GatewayId)}/acl_policy`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an access control list (ACL) for a private gateway. The IP CIDR blocks added to the ACL can access the private gateway.
 *
 * @param request CreateAclPolicyRequest
 * @return CreateAclPolicyResponse
 */
async function createAclPolicy(ClusterId: string, GatewayId: string, request: CreateAclPolicyRequest): CreateAclPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAclPolicyWithOptions(ClusterId, GatewayId, request, headers, runtime);
}

model CreateAppServiceRequest {
  quotaId?: string(name='QuotaId', description='The quota ID.', example='abcdef'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='123456'),
  appType?: string(name='AppType', description='The application service type.

Valid values:

*   LLM

    <!-- -->

    <!-- -->

    <!-- -->

This parameter is required.', example='LLM'),
  appVersion?: string(name='AppVersion', description='The application version.', example='v1'),
  config?: map[string]any(name='Config', description='The additional configurations that are required for service deployment.'),
  replicas?: int32(name='Replicas', description='The number of instances.

This parameter is required.', example='1'),
  serviceName?: string(name='ServiceName', description='The service name.

This parameter is required.', example='foo'),
  serviceSpec?: string(name='ServiceSpec', description='The service specifications. Valid values:

*   llama_7b_fp16
*   llama_7b_int8
*   llama_13b_fp16
*   llama_7b_int8
*   chatglm_6b_fp16
*   chatglm_6b_int8
*   chatglm2_6b_fp16
*   baichuan_7b_int8
*   baichuan_13b_fp16
*   baichuan_7b_fp16

This parameter is required.', example='llama_7b_fp16'),
}

model CreateAppServiceResponseBody = {
  internetEndpoint?: string(name='InternetEndpoint', description='The public endpoint of the service.', example='http://pai-eas.cn-shanghai.****'),
  intranetEndpoint?: string(name='IntranetEndpoint', description='The internal endpoint of the service.', example='http://pai-eas-vpc.cn-shanghai.****'),
  region?: string(name='Region', description='The region ID of the service.', example='cn-shanghai'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  serviceId?: string(name='ServiceId', description='The service ID.', example='eas-m-aaxxxddf'),
  serviceName?: string(name='ServiceName', description='The service name.', example='foo'),
  status?: string(name='Status', description='The service state.', example='Creating'),
}

model CreateAppServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAppServiceResponseBody(name='body'),
}

/**
 * @summary Creates an application service to obtain the inference capabilities of large models.
 *
 * @param request CreateAppServiceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAppServiceResponse
 */
async function createAppServiceWithOptions(request: CreateAppServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAppServiceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.quotaId)) {
    query['QuotaId'] = request.quotaId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.appType)) {
    body['AppType'] = request.appType;
  }
  if (!Util.isUnset(request.appVersion)) {
    body['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.config)) {
    body['Config'] = request.config;
  }
  if (!Util.isUnset(request.replicas)) {
    body['Replicas'] = request.replicas;
  }
  if (!Util.isUnset(request.serviceName)) {
    body['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.serviceSpec)) {
    body['ServiceSpec'] = request.serviceSpec;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAppService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/app_services`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an application service to obtain the inference capabilities of large models.
 *
 * @param request CreateAppServiceRequest
 * @return CreateAppServiceResponse
 */
async function createAppService(request: CreateAppServiceRequest): CreateAppServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAppServiceWithOptions(request, headers, runtime);
}

model CreateBenchmarkTaskRequest {
  body?: string(name='body', description='The request body. The body includes the parameters that are set to create a stress testing task.', example='{
    "base": {
        "duration": 600
    },
    "service": {
        "serviceName": "test_service",
        "requestToken": "test_token"
    },
    "data": {
        "path": "https://larec-benchmark-cd.oss-cn-chengdu.aliyuncs.com/youbei/sv_dbmtl/data/youbei.warmup.tf.bin",
        "dataType": "binary"
    },
    "optional": {
       "maxRt": 100
    }
}'),
}

model CreateBenchmarkTaskResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Benchmark  task [foo] is Creating'),
  region?: string(name='Region', description='The ID of the region where the stress testing task is performed.', example='cn-shanghai'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82********'),
  taskName?: string(name='TaskName', description='The name of the stress testing task.', example='benchmark-larec-test-1076'),
}

model CreateBenchmarkTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateBenchmarkTaskResponseBody(name='body'),
}

/**
 * @summary Creates a stress testing task.
 *
 * @param request CreateBenchmarkTaskRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBenchmarkTaskResponse
 */
async function createBenchmarkTaskWithOptions(request: CreateBenchmarkTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateBenchmarkTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CreateBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a stress testing task.
 *
 * @param request CreateBenchmarkTaskRequest
 * @return CreateBenchmarkTaskResponse
 */
async function createBenchmarkTask(request: CreateBenchmarkTaskRequest): CreateBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createBenchmarkTaskWithOptions(request, headers, runtime);
}

model CreateGatewayRequest {
  resourceName?: string(name='ResourceName', description='The resource group ID. To obtain a resource group ID, see the ResourceId field in the response of the [ListResources](https://help.aliyun.com/document_detail/412133.html) operation.', example='eas-r-4gt8twzwllfo******'),
  autoRenewal?: boolean(name='AutoRenewal', description='Specifies whether to enable auto-renewal. Valid values:

*   false (default)
*   true'),
  chargeType?: string(name='ChargeType', description='The billing method. Valid values:

*   PrePaid: subscription.
*   PostPaid: pay-as-you-go.', example='PostPaid'),
  enableInternet?: boolean(name='EnableInternet', description='Specifies whether to enable Internet access. Default value: false.

Valid values:

*   true
*   false', example='false'),
  enableIntranet?: boolean(name='EnableIntranet', description='Specifies whether to enable private access. Default value: true.

Valid values:

*   true
*   false', example='true'),
  instanceType?: string(name='InstanceType', description='The instance type used by the private gateway. Valid values:

*   2c4g
*   4c8g
*   8c16g
*   16c32g

This parameter is required.', example='ecs.c6.4xlarge'),
  name?: string(name='Name', description='The alias of the private gateway.', example='mygateway1'),
  replicas?: int32(name='Replicas', description='The number of nodes in the private gateway.', example='2'),
}

model CreateGatewayResponseBody = {
  clusterId?: string(name='ClusterId', description='The region ID of the private gateway.', example='cn-hangzhou'),
  gatewayId?: string(name='GatewayId', description='The private gateway ID.', example='gw-1uhcqmsc7x22******'),
  message?: string(name='Message', description='The returned message.', example='Successfully create gateway.'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model CreateGatewayResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateGatewayResponseBody(name='body'),
}

/**
 * @summary Creates a gateway.
 *
 * @param request CreateGatewayRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateGatewayResponse
 */
async function createGatewayWithOptions(request: CreateGatewayRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateGatewayResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.autoRenewal)) {
    body['AutoRenewal'] = request.autoRenewal;
  }
  if (!Util.isUnset(request.chargeType)) {
    body['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.enableInternet)) {
    body['EnableInternet'] = request.enableInternet;
  }
  if (!Util.isUnset(request.enableIntranet)) {
    body['EnableIntranet'] = request.enableIntranet;
  }
  if (!Util.isUnset(request.instanceType)) {
    body['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.replicas)) {
    body['Replicas'] = request.replicas;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateGateway',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a gateway.
 *
 * @param request CreateGatewayRequest
 * @return CreateGatewayResponse
 */
async function createGateway(request: CreateGatewayRequest): CreateGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createGatewayWithOptions(request, headers, runtime);
}

model CreateGatewayIntranetLinkedVpcRequest {
  accountId?: string(name='AccountId'),
  enableAuthoritativeDns?: boolean(name='EnableAuthoritativeDns'),
  vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.', example='vsw-8vbqn2at0kljjxxxx****'),
  vpcId?: string(name='VpcId', description='The virtual private cloud (VPC) ID.', example='vpc-uf66uio7md****'),
}

model CreateGatewayIntranetLinkedVpcResponseBody = {
  gatewayId?: string(name='GatewayId', description='The private gateway ID.', example='gw-1uhcqmsc7x22******'),
  message?: string(name='Message', description='The returned message.', example='Successfully add intranet linked vpc for gateway'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model CreateGatewayIntranetLinkedVpcResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateGatewayIntranetLinkedVpcResponseBody(name='body'),
}

/**
 * @summary Creates an internal endpoint of a private gateway.
 *
 * @param request CreateGatewayIntranetLinkedVpcRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateGatewayIntranetLinkedVpcResponse
 */
async function createGatewayIntranetLinkedVpcWithOptions(ClusterId: string, GatewayId: string, request: CreateGatewayIntranetLinkedVpcRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateGatewayIntranetLinkedVpcResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accountId)) {
    query['AccountId'] = request.accountId;
  }
  if (!Util.isUnset(request.enableAuthoritativeDns)) {
    query['EnableAuthoritativeDns'] = request.enableAuthoritativeDns;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGatewayIntranetLinkedVpc',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GatewayId)}/intranet_endpoint_linked_vpc`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an internal endpoint of a private gateway.
 *
 * @param request CreateGatewayIntranetLinkedVpcRequest
 * @return CreateGatewayIntranetLinkedVpcResponse
 */
async function createGatewayIntranetLinkedVpc(ClusterId: string, GatewayId: string, request: CreateGatewayIntranetLinkedVpcRequest): CreateGatewayIntranetLinkedVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createGatewayIntranetLinkedVpcWithOptions(ClusterId, GatewayId, request, headers, runtime);
}

model CreateGatewayIntranetLinkedVpcPeerRequest {
  peerVpcs?: [ 
    {
      region?: string(name='Region', description='The region where the VPC peer resides.', example='cn-shanghai'),
      vpcId?: string(name='VpcId', description='The ID of the VPC peer. To obtain the VPC ID, see [DescribeVpcs](https://help.aliyun.com/document_detail/35739.html).', example='vpc-uf66uio7md****'),
    }
  ](name='PeerVpcs', description='The list of VPC peers.'),
  vpcId?: string(name='VpcId', description='The VPC ID. To obtain the VPC ID, see [ListGatewayIntranetLinkedVpc](https://help.aliyun.com/document_detail/2621223.html).', example='vpc-2zetuli9ws0qgjd******'),
}

model CreateGatewayIntranetLinkedVpcPeerShrinkRequest {
  peerVpcsShrink?: string(name='PeerVpcs', description='The list of VPC peers.'),
  vpcId?: string(name='VpcId', description='The VPC ID. To obtain the VPC ID, see [ListGatewayIntranetLinkedVpc](https://help.aliyun.com/document_detail/2621223.html).', example='vpc-2zetuli9ws0qgjd******'),
}

model CreateGatewayIntranetLinkedVpcPeerResponseBody = {
  gatewayId?: string(name='GatewayId', description='The ID of the private gateway.', example='gw-1uhcqmsc7x22******'),
  message?: string(name='Message', description='The message that is returned.', example='Successfully add intranet linked vpc Peer for gateway'),
  requestId?: string(name='requestId', description='The ID of the request.', example='40325405-579C-4D82****'),
}

model CreateGatewayIntranetLinkedVpcPeerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateGatewayIntranetLinkedVpcPeerResponseBody(name='body'),
}

/**
 * @summary Creates a VPC peering connection on an internal endpoint of a gateway.
 *
 * @param tmpReq CreateGatewayIntranetLinkedVpcPeerRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateGatewayIntranetLinkedVpcPeerResponse
 */
async function createGatewayIntranetLinkedVpcPeerWithOptions(ClusterId: string, GatewayId: string, tmpReq: CreateGatewayIntranetLinkedVpcPeerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateGatewayIntranetLinkedVpcPeerResponse {
  Util.validateModel(tmpReq);
  var request = new CreateGatewayIntranetLinkedVpcPeerShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.peerVpcs)) {
    request.peerVpcsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.peerVpcs, 'PeerVpcs', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.peerVpcsShrink)) {
    query['PeerVpcs'] = request.peerVpcsShrink;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGatewayIntranetLinkedVpcPeer',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GatewayId)}/intranet_endpoint_linked_vpc_peer`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a VPC peering connection on an internal endpoint of a gateway.
 *
 * @param request CreateGatewayIntranetLinkedVpcPeerRequest
 * @return CreateGatewayIntranetLinkedVpcPeerResponse
 */
async function createGatewayIntranetLinkedVpcPeer(ClusterId: string, GatewayId: string, request: CreateGatewayIntranetLinkedVpcPeerRequest): CreateGatewayIntranetLinkedVpcPeerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createGatewayIntranetLinkedVpcPeerWithOptions(ClusterId, GatewayId, request, headers, runtime);
}

model CreateResourceRequest {
  autoRenewal?: boolean(name='AutoRenewal', description='Specifies whether to enable auto-renewal. Valid values:

*   false (default)
*   true', example='false'),
  chargeType?: string(name='ChargeType', description='The billing method. Valid values:

*   PrePaid: the subscription billing method.
*   PostPaid: the pay-as-you-go billing method.

>  This parameter is required when the ResourceType parameter is set to Dedicated.', example='PostPaid'),
  ecsInstanceCount?: int32(name='EcsInstanceCount', description='The number of ECS instances.

>  This parameter is required when the ResourceType parameter is set to Dedicated.', example='5'),
  ecsInstanceType?: string(name='EcsInstanceType', description='The type of the Elastic Compute Service (ECS) instance.

>  This parameter is required when the ResourceType parameter is set to Dedicated.', example='ecs.c6.8xlarge'),
  labels?: map[string]string(name='Labels', description='The labels.'),
  resourceName?: string(name='ResourceName', example='MyResource'),
  resourceType?: string(name='ResourceType', description='The type of the resource group. Valid values:

*   Dedicated: the dedicated resource group.
*   SelfManaged: the self-managed resource group.

>  If you use a self-managed resource group, you must configure a whitelist.', example='Dedicated'),
  selfManagedResourceOptions?: {
    externalClusterId?: string(name='ExternalClusterId', description='The ID of the self-managed cluster.', example='cf0386f250f2545689ca7fdd1cd******'),
    nodeMatchLabels?: map[string]string(name='NodeMatchLabels', description='The tag key-value pairs of the node.'),
    nodeTolerations?: [ 
      {
        effect?: string(name='effect', description='The effect.

Valid values:

*   PreferNoSchedule
*   NoSchedule
*   NoExecute', example='NoSchedule'),
        key?: string(name='key', description='The key name.', example='key1'),
        operator?: string(name='operator', description='The relationship between key names and key values.

Valid values:

*   Equal
*   Exists', example='Equal'),
        value?: string(name='value', description='The key value.', example='value1'),
      }
    ](name='NodeTolerations', description='The tolerations for the node taint.'),
    roleName?: string(name='RoleName', description='The name of the RAM user to which the permissions on Elastic Algorithm Service (EAS) of Platform for AI (PAI) are granted.', example='clusterrole'),
  }(name='SelfManagedResourceOptions', description='The configurations of the self-managed resource group.'),
  systemDiskSize?: int32(name='SystemDiskSize', description='The size of the system disk. Unit: GiB. Valid values: 200 to 2000. Default value: 200.', example='200'),
  zone?: string(name='Zone', description='The ID of the zone in which the instance resides.', example='cn-shanghai-f'),
}

model CreateResourceResponseBody = {
  clusterId?: string(name='ClusterId', description='The ID of the cluster to which the resource group belongs.', example='cn-shanghai'),
  instanceIds?: [ string ](name='InstanceIds', description='The instance IDs.'),
  ownerUid?: string(name='OwnerUid', description='The user ID (UID) of the resource group owner.', example='14401087478****'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  resourceId?: string(name='ResourceId', description='The ID of the resource group.', example='eas-r-h7lcw24dyqztwxxxxxx'),
  resourceName?: string(name='ResourceName', description='The name of the resource group.', example='MyResource'),
}

model CreateResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateResourceResponseBody(name='body'),
}

/**
 * @summary Creates a resource group.
 *
 * @description **Before you call this operation, make sure that you are familiar with the [billing](https://help.aliyun.com/document_detail/144261.html) of Elastic Algorithm Service (EAS).
 *
 * @param request CreateResourceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateResourceResponse
 */
async function createResourceWithOptions(request: CreateResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoRenewal)) {
    body['AutoRenewal'] = request.autoRenewal;
  }
  if (!Util.isUnset(request.chargeType)) {
    body['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.ecsInstanceCount)) {
    body['EcsInstanceCount'] = request.ecsInstanceCount;
  }
  if (!Util.isUnset(request.ecsInstanceType)) {
    body['EcsInstanceType'] = request.ecsInstanceType;
  }
  if (!Util.isUnset(request.labels)) {
    body['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.resourceName)) {
    body['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.selfManagedResourceOptions)) {
    body['SelfManagedResourceOptions'] = request.selfManagedResourceOptions;
  }
  if (!Util.isUnset(request.systemDiskSize)) {
    body['SystemDiskSize'] = request.systemDiskSize;
  }
  if (!Util.isUnset(request.zone)) {
    body['Zone'] = request.zone;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateResource',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a resource group.
 *
 * @description **Before you call this operation, make sure that you are familiar with the [billing](https://help.aliyun.com/document_detail/144261.html) of Elastic Algorithm Service (EAS).
 *
 * @param request CreateResourceRequest
 * @return CreateResourceResponse
 */
async function createResource(request: CreateResourceRequest): CreateResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createResourceWithOptions(request, headers, runtime);
}

model CreateResourceInstancesRequest {
  autoRenewal?: boolean(name='AutoRenewal', description='Specifies whether to enable auto-renewal. Valid values:

*   false (default)
*   true', example='false'),
  chargeType?: string(name='ChargeType', description='The billing method of the instance. Valid values:

*   PrePaid: subscription.
*   PostPaid: pay-as-you-go.

This parameter is required.', example='PrePaid'),
  ecsInstanceCount?: int32(name='EcsInstanceCount', description='The number of instances that you want to create. Valid values: 1 to 100.

This parameter is required.', example='5'),
  ecsInstanceType?: string(name='EcsInstanceType', description='The type of the Elastic Compute Service (ECS) instance.

This parameter is required.', example='ecs.s6-c1m2.xlarge'),
  labels?: map[string]string(name='Labels', description='The custom service tag.'),
  systemDiskSize?: int32(name='SystemDiskSize', description='The size of the system disk. Unit: GiB. Valid values: 200 to 2000. Default value: 200.', example='200'),
  userData?: string(name='UserData', description='The user-defined information. This parameter is not in use.', example='x112223333', deprecated=true),
  zone?: string(name='Zone', description='The zone to which the instance belongs.', example='cn-shanghai-f'),
}

model CreateResourceInstancesResponseBody = {
  instanceIds?: [ string ](name='InstanceIds', description='The instance IDs.'),
  message?: string(name='Message', description='The returned message.', example='Create 5 new ecs instance(s) in resource [eas-r-asdasdasd] successfully'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model CreateResourceInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateResourceInstancesResponseBody(name='body'),
}

/**
 * @summary Creates instances in a dedicated resource group.
 *
 * @param request CreateResourceInstancesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateResourceInstancesResponse
 */
async function createResourceInstancesWithOptions(ClusterId: string, ResourceId: string, request: CreateResourceInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateResourceInstancesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoRenewal)) {
    body['AutoRenewal'] = request.autoRenewal;
  }
  if (!Util.isUnset(request.chargeType)) {
    body['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.ecsInstanceCount)) {
    body['EcsInstanceCount'] = request.ecsInstanceCount;
  }
  if (!Util.isUnset(request.ecsInstanceType)) {
    body['EcsInstanceType'] = request.ecsInstanceType;
  }
  if (!Util.isUnset(request.labels)) {
    body['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.systemDiskSize)) {
    body['SystemDiskSize'] = request.systemDiskSize;
  }
  if (!Util.isUnset(request.userData)) {
    body['UserData'] = request.userData;
  }
  if (!Util.isUnset(request.zone)) {
    body['Zone'] = request.zone;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateResourceInstances',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/instances`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates instances in a dedicated resource group.
 *
 * @param request CreateResourceInstancesRequest
 * @return CreateResourceInstancesResponse
 */
async function createResourceInstances(ClusterId: string, ResourceId: string, request: CreateResourceInstancesRequest): CreateResourceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createResourceInstancesWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

model CreateResourceLogRequest {
  logStore?: string(name='LogStore', description='The Logstore of Log Service. For more information about how to query a Logstore, see [ListLogStores](https://help.aliyun.com/document_detail/426970.html).

This parameter is required.', example='access_log'),
  projectName?: string(name='ProjectName', description='The Log Service project that is associated with the resource group. For more information about how to query the project, see [ListProject](https://help.aliyun.com/document_detail/74955.html).

This parameter is required.', example='eas-r-asdasdasd-sls'),
}

model CreateResourceLogResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Resource [eas-r-asdasdasd] is deleted.'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model CreateResourceLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateResourceLogResponseBody(name='body'),
}

/**
 * @summary Enables the LogShipper feature of Log Service for a resource group.
 *
 * @param request CreateResourceLogRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateResourceLogResponse
 */
async function createResourceLogWithOptions(ClusterId: string, ResourceId: string, request: CreateResourceLogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateResourceLogResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.logStore)) {
    body['LogStore'] = request.logStore;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateResourceLog',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/log`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Enables the LogShipper feature of Log Service for a resource group.
 *
 * @param request CreateResourceLogRequest
 * @return CreateResourceLogResponse
 */
async function createResourceLog(ClusterId: string, ResourceId: string, request: CreateResourceLogRequest): CreateResourceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createResourceLogWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

model CreateServiceRequest {
  develop?: string(name='Develop', description='Specifies whether to enter development mode.

Valid values:

*   true

    <!-- -->

    <!-- -->

    <!-- -->

*   false

    <!-- -->

    <!-- -->

    <!-- -->', example='true'),
  labels?: map[string]string(name='Labels', description='The custom label.'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='123456'),
  body?: string(name='body', description='The request body. For more information about the key request parameters, see **Table 1. Request body parameters** and **Table 2. Metadata parameters**. For more information about all related parameters, see [Parameters of model services](https://help.aliyun.com/document_detail/450525.html).', example='Service deployment by using an image:
{
  "name": "foo",
  "metadata": {
    "instance": 2,
    "memory": 7000,
    "cpu": 4
    },
  "containers": [
    {
      "image": "****",
      "script": "**** --listen=0.0.0.0 --server_port=8000 --headless",
      "port": 8000
    }
  ],
  "storage": [
    {
      "oss": {
        "path": "oss://examplebuket/data111/",
        "readOnly": false
      },
      "properties": {
        "resource_type": "model"
      },
      "mount_path": "/data"
    }
  ]
}
AI-Web application deployment by using an image:
{
  "name": "foo",
  "metadata": {
    "instance": 1,
    "memory": 7000,
    "cpu": 4,
    "enable_webservice": true
  },
  "containers": [
    {
      "image": "****",
      "script": "**** --listen=0.0.0.0 --server_port=8000 --headless",
      "port": 8000
    }
  ],
  "storage": [
    {
      "oss": {
        "path": "oss://examplebucket/data111/",
        "readOnly": false
      },
      "properties": {
      "resource_type": "model"
      },
      "mount_path": "/data"
    }
  ]
}
Service deployment by using models and processors:
{
  "metadata": {
    "instance": 1,
    "memory": 7000,
    "cpu": 4
  },
  "name": "foo",
  "model_config": {},
  "processor_type": "python",
  "processor_path": "oss://****",
  "processor_entry": "a.py",
  "model_path": "oss://****"
}'),
}

model CreateServiceShrinkRequest {
  develop?: string(name='Develop', description='Specifies whether to enter development mode.

Valid values:

*   true

    <!-- -->

    <!-- -->

    <!-- -->

*   false

    <!-- -->

    <!-- -->

    <!-- -->', example='true'),
  labelsShrink?: string(name='Labels', description='The custom label.'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='123456'),
  body?: string(name='body', description='The request body. For more information about the key request parameters, see **Table 1. Request body parameters** and **Table 2. Metadata parameters**. For more information about all related parameters, see [Parameters of model services](https://help.aliyun.com/document_detail/450525.html).', example='Service deployment by using an image:
{
  "name": "foo",
  "metadata": {
    "instance": 2,
    "memory": 7000,
    "cpu": 4
    },
  "containers": [
    {
      "image": "****",
      "script": "**** --listen=0.0.0.0 --server_port=8000 --headless",
      "port": 8000
    }
  ],
  "storage": [
    {
      "oss": {
        "path": "oss://examplebuket/data111/",
        "readOnly": false
      },
      "properties": {
        "resource_type": "model"
      },
      "mount_path": "/data"
    }
  ]
}
AI-Web application deployment by using an image:
{
  "name": "foo",
  "metadata": {
    "instance": 1,
    "memory": 7000,
    "cpu": 4,
    "enable_webservice": true
  },
  "containers": [
    {
      "image": "****",
      "script": "**** --listen=0.0.0.0 --server_port=8000 --headless",
      "port": 8000
    }
  ],
  "storage": [
    {
      "oss": {
        "path": "oss://examplebucket/data111/",
        "readOnly": false
      },
      "properties": {
      "resource_type": "model"
      },
      "mount_path": "/data"
    }
  ]
}
Service deployment by using models and processors:
{
  "metadata": {
    "instance": 1,
    "memory": 7000,
    "cpu": 4
  },
  "name": "foo",
  "model_config": {},
  "processor_type": "python",
  "processor_path": "oss://****",
  "processor_entry": "a.py",
  "model_path": "oss://****"
}'),
}

model CreateServiceResponseBody = {
  internetEndpoint?: string(name='InternetEndpoint', description='The public endpoint of the created service.', example='http://pai-eas.vpc.cn-shanghai.****'),
  intranetEndpoint?: string(name='IntranetEndpoint', description='The internal endpoint of the created service.', example='http://pai-eas.cn-shanghai.****'),
  region?: string(name='Region', description='The region ID of the created service.', example='cn-shanghai'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  serviceId?: string(name='ServiceId', description='The ID of the created service.', example='eas-m-aaxxxddf'),
  serviceName?: string(name='ServiceName', description='The name of the created service.', example='yourname'),
  status?: string(name='Status', description='The service state.', example='Creating'),
}

model CreateServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateServiceResponseBody(name='body'),
}

/**
 * @summary Creates a model service in Elastic Algorithm Service (EAS).
 *
 * @description **Before you call this operation, make sure that you are familiar with the [billing](https://help.aliyun.com/document_detail/144261.html) of Elastic Algorithm Service (EAS).
 *
 * @param tmpReq CreateServiceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateServiceResponse
 */
async function createServiceWithOptions(tmpReq: CreateServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceResponse {
  Util.validateModel(tmpReq);
  var request = new CreateServiceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.labels)) {
    request.labelsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.labels, 'Labels', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.develop)) {
    query['Develop'] = request.develop;
  }
  if (!Util.isUnset(request.labelsShrink)) {
    query['Labels'] = request.labelsShrink;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CreateService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a model service in Elastic Algorithm Service (EAS).
 *
 * @description **Before you call this operation, make sure that you are familiar with the [billing](https://help.aliyun.com/document_detail/144261.html) of Elastic Algorithm Service (EAS).
 *
 * @param request CreateServiceRequest
 * @return CreateServiceResponse
 */
async function createService(request: CreateServiceRequest): CreateServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceWithOptions(request, headers, runtime);
}

model CreateServiceAutoScalerRequest {
  behavior?: {
    onZero?: {
      scaleDownGracePeriodSeconds?: int32(name='scaleDownGracePeriodSeconds', description='The time window that is required before the number of instances is reduced to 0. The number of instances can be reduced to 0 only if no request is available or no traffic exists in the specified time window. Default value: 600.', example='600'),
      scaleUpActivationReplicas?: int32(name='scaleUpActivationReplicas', description='The number of instances that you want to create at a time if the number of instances is 0. Default value: 1.', example='1'),
    }(name='onZero', description='The operation that reduces the number of instances to 0.'),
    scaleDown?: {
      stabilizationWindowSeconds?: int32(name='stabilizationWindowSeconds', description='The time window that is required before the scale-in operation is performed. The scale-in operation can be performed only if the specified metric drops below the specified threshold in the specified time window. Default value: 300.', example='300'),
    }(name='scaleDown', description='The scale-in operation.'),
    scaleUp?: {
      stabilizationWindowSeconds?: int32(name='stabilizationWindowSeconds', description='The time window that is required before the scale-out operation is performed. The scale-out operation can be performed only if the specified metric exceeds the specified threshold in the specified time window. Default value: 0.', example='0'),
    }(name='scaleUp', description='The scale-out operation.'),
  }(name='behavior', description='The Autoscaler operation.'),
  max?: int32(name='max', description='The maximum number of instances in the service. The value of max must be greater than the value of min.

This parameter is required.', example='8'),
  min?: int32(name='min', description='The minimum number of instances in the service.

This parameter is required.', example='2'),
  scaleStrategies?: [ 
    {
      metricName?: string(name='metricName', description='The name of the metric for triggering auto scaling. Valid values:

*   qps: the queries per second (qps) for an individual instance.
*   cpu: the cpu utilization.
* gpu[util]: gpu utilization.

This parameter is required.', example='qps'),
      service?: string(name='service', description='The service for which the metric is specified. If you do not set this parameter, the current service is specified by default.', example='demo_svc'),
      threshold?: float(name='threshold', description='The threshold of the metric that triggers auto scaling.

*   If you set metricName to qps, scale-out is triggered when the average qps for a single instance is greater than this threshold.
*   If you set metricName to cpu, scale-out is triggered when the average cpu utilization for a single instance is greater than this threshold.
*   If you set metricName to gpu, scale-out is triggered when the average gpu utilization for a single instance is greater than this threshold.

This parameter is required.', example='10'),
    }
  ](name='scaleStrategies', description='The service for which the metric is specified. If you do not set this parameter, the current service is specified by default.

This parameter is required.'),
}

model CreateServiceAutoScalerResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Succeed to auto scale service [foo]'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model CreateServiceAutoScalerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateServiceAutoScalerResponseBody(name='body'),
}

/**
 * @summary Enables the Autoscaler feature and creates an Autoscaler controller for a service.
 *
 * @param request CreateServiceAutoScalerRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateServiceAutoScalerResponse
 */
async function createServiceAutoScalerWithOptions(ClusterId: string, ServiceName: string, request: CreateServiceAutoScalerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceAutoScalerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.behavior)) {
    body['behavior'] = request.behavior;
  }
  if (!Util.isUnset(request.max)) {
    body['max'] = request.max;
  }
  if (!Util.isUnset(request.min)) {
    body['min'] = request.min;
  }
  if (!Util.isUnset(request.scaleStrategies)) {
    body['scaleStrategies'] = request.scaleStrategies;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceAutoScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/autoscaler`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Enables the Autoscaler feature and creates an Autoscaler controller for a service.
 *
 * @param request CreateServiceAutoScalerRequest
 * @return CreateServiceAutoScalerResponse
 */
async function createServiceAutoScaler(ClusterId: string, ServiceName: string, request: CreateServiceAutoScalerRequest): CreateServiceAutoScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceAutoScalerWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model CreateServiceCronScalerRequest {
  excludeDates?: [ string ](name='ExcludeDates', description='The points in time that are excluded when you schedule a CronHPA job. The points in time must be specified by using a cron expression.'),
  scaleJobs?: [ 
    {
      name?: string(name='Name', description='The name of the CronHPA job.', example='scale-job-1'),
      schedule?: string(name='Schedule', description='The cron expression that is used to configure the execution time of the CronHPA job. For more information about how to configure cron expressions, see **Description of special characters** in this topic.

This parameter is required.', example='0 18 * * * *'),
      targetSize?: int32(name='TargetSize', description='The number of instances that you want to configure for the CronHPA job.

This parameter is required.', example='1'),
      timeZone?: string(name='TimeZone'),
    }
  ](name='ScaleJobs', description='The description of the CronHPA job.

This parameter is required.'),
}

model CreateServiceCronScalerResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Create cron scaler for service [foo] successfully'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model CreateServiceCronScalerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateServiceCronScalerResponseBody(name='body'),
}

/**
 * @summary Enables the Cron Horizontal Pod Autoscaler (CronHPA) feature for a service.
 *
 * @param request CreateServiceCronScalerRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateServiceCronScalerResponse
 */
async function createServiceCronScalerWithOptions(ClusterId: string, ServiceName: string, request: CreateServiceCronScalerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceCronScalerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.excludeDates)) {
    body['ExcludeDates'] = request.excludeDates;
  }
  if (!Util.isUnset(request.scaleJobs)) {
    body['ScaleJobs'] = request.scaleJobs;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceCronScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/cronscaler`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Enables the Cron Horizontal Pod Autoscaler (CronHPA) feature for a service.
 *
 * @param request CreateServiceCronScalerRequest
 * @return CreateServiceCronScalerResponse
 */
async function createServiceCronScaler(ClusterId: string, ServiceName: string, request: CreateServiceCronScalerRequest): CreateServiceCronScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceCronScalerWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model CreateServiceMirrorRequest {
  ratio?: int32(name='Ratio', description='The percentage of the traffic that is mirrored to the destination service. Valid values: 0 to 100.', example='30'),
  target?: [ string ](name='Target', description='The instances.'),
}

model CreateServiceMirrorResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Traffic mirroring is ON for service [foo] in region [cn-shanghia], ratio [70%]'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82***'),
}

model CreateServiceMirrorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateServiceMirrorResponseBody(name='body'),
}

/**
 * @summary Enables the traffic mirroring feature for a service. After the feature is enabled, requests received by the service can be mirrored to another service.
 *
 * @param request CreateServiceMirrorRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateServiceMirrorResponse
 */
async function createServiceMirrorWithOptions(ClusterId: string, ServiceName: string, request: CreateServiceMirrorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceMirrorResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ratio)) {
    body['Ratio'] = request.ratio;
  }
  if (!Util.isUnset(request.target)) {
    body['Target'] = request.target;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceMirror',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/mirror`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Enables the traffic mirroring feature for a service. After the feature is enabled, requests received by the service can be mirrored to another service.
 *
 * @param request CreateServiceMirrorRequest
 * @return CreateServiceMirrorResponse
 */
async function createServiceMirror(ClusterId: string, ServiceName: string, request: CreateServiceMirrorRequest): CreateServiceMirrorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceMirrorWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model CreateVirtualResourceRequest {
  disableSpotProtectionPeriod?: boolean(name='DisableSpotProtectionPeriod', description='Specifies whether to disable the retention period of preemptible instances.', example='true'),
  resources?: [ 
    {
      instanceType?: string(name='InstanceType', description='The instance type of the public resource group.

>  You must specify one and only one of the InstanceType, ResourceId, and QuotaId parameters.', example='ecs.s6-c1m2.xlarge'),
      priority?: int32(name='Priority', description='The priority of resource scheduling. A greater number indicates a higher priority.', example='6'),
      quotaId?: string(name='QuotaId', description='The ID of the Lingjun resource quota.

>  You must specify one and only one of the InstanceType, ResourceId, and QuotaId parameters.', example='quota185lqxxxxxx'),
      region?: string(name='Region', description='The region in which the resource resides.', example='cn-hangzhou'),
      resourceId?: string(name='ResourceId', description='The ID of the dedicated resource group. For information about how to obtain the ID of a dedicated resource group, see [ListResources](https://help.aliyun.com/document_detail/412133.html).

>  You must specify one and only one of the InstanceType, ResourceId, and QuotaId parameters.', example='eas-r-g55ieatgg3buxxxxxx'),
      spotPriceLimit?: float(name='SpotPriceLimit', description='The maximum price of preemptible instances in a public resource group.

>  If you leave this parameter empty, preemptible instances are not used.', example='10.05'),
    }
  ](name='Resources', description='The resources in the virtual resource group.'),
  virtualResourceName?: string(name='VirtualResourceName', description='The name of the virtual resource group. Default value: the ID of the virtual resource group.', example='MyVirtualResource'),
}

model CreateVirtualResourceResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Successfully created virtual resource eas-vr-npovr28onap1xxxxxx'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='40325405-579C-4D82***'),
  virtualResourceId?: string(name='VirtualResourceId', description='The ID of the virtual resource group.', example='eas-vr-npovr28onap1xxxxxx'),
}

model CreateVirtualResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateVirtualResourceResponseBody(name='body'),
}

/**
 * @summary Creates a virtual resource group.
 *
 * @param request CreateVirtualResourceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVirtualResourceResponse
 */
async function createVirtualResourceWithOptions(request: CreateVirtualResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateVirtualResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.disableSpotProtectionPeriod)) {
    body['DisableSpotProtectionPeriod'] = request.disableSpotProtectionPeriod;
  }
  if (!Util.isUnset(request.resources)) {
    body['Resources'] = request.resources;
  }
  if (!Util.isUnset(request.virtualResourceName)) {
    body['VirtualResourceName'] = request.virtualResourceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateVirtualResource',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/virtualresources`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a virtual resource group.
 *
 * @param request CreateVirtualResourceRequest
 * @return CreateVirtualResourceResponse
 */
async function createVirtualResource(request: CreateVirtualResourceRequest): CreateVirtualResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createVirtualResourceWithOptions(request, headers, runtime);
}

model DeleteAclPolicyRequest {
  aclPolicyList?: [ 
    {
      comment?: string(name='Comment', description='The comment on the IP CIDR block in the VPC that can access the private gateway.', example='default'),
      entry?: string(name='Entry', description='The IP CIDR block in the VPC that can access the private gateway.', example='10.23.XX.XX/32'),
    }
  ](name='AclPolicyList', description='The whitelisted IP CIDR blocks in the VPC that can access the private gateway.'),
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC). For more information about how to obtain the VPC ID, see DescribeVpcs.', example='vpc-uf66uio7md****'),
}

model DeleteAclPolicyShrinkRequest {
  aclPolicyListShrink?: string(name='AclPolicyList', description='The whitelisted IP CIDR blocks in the VPC that can access the private gateway.'),
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC). For more information about how to obtain the VPC ID, see DescribeVpcs.', example='vpc-uf66uio7md****'),
}

model DeleteAclPolicyResponseBody = {
  gatewayId?: string(name='GatewayId', description='The private gateway ID.', example='gw-1uhcqmsc7x22******'),
  message?: string(name='Message', description='The returned message.', example='Successfully delete acl policy for gateway'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model DeleteAclPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAclPolicyResponseBody(name='body'),
}

/**
 * @summary Deletes an access control list (ACL) for a private gateway. The IP CIDR block that is deleted from the ACL cannot access the private gateway.
 *
 * @param tmpReq DeleteAclPolicyRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAclPolicyResponse
 */
async function deleteAclPolicyWithOptions(ClusterId: string, GatewayId: string, tmpReq: DeleteAclPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAclPolicyResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteAclPolicyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.aclPolicyList)) {
    request.aclPolicyListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.aclPolicyList, 'AclPolicyList', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.aclPolicyListShrink)) {
    query['AclPolicyList'] = request.aclPolicyListShrink;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAclPolicy',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GatewayId)}/acl_policy`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an access control list (ACL) for a private gateway. The IP CIDR block that is deleted from the ACL cannot access the private gateway.
 *
 * @param request DeleteAclPolicyRequest
 * @return DeleteAclPolicyResponse
 */
async function deleteAclPolicy(ClusterId: string, GatewayId: string, request: DeleteAclPolicyRequest): DeleteAclPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAclPolicyWithOptions(ClusterId, GatewayId, request, headers, runtime);
}

model DeleteBenchmarkTaskResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Benchmark task [benchmark-test-service-234c] is Deleting'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model DeleteBenchmarkTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteBenchmarkTaskResponseBody(name='body'),
}

/**
 * @summary Deletes a stress testing task.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBenchmarkTaskResponse
 */
async function deleteBenchmarkTaskWithOptions(ClusterId: string, TaskName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteBenchmarkTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(TaskName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a stress testing task.
 *
 * @return DeleteBenchmarkTaskResponse
 */
async function deleteBenchmarkTask(ClusterId: string, TaskName: string): DeleteBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteBenchmarkTaskWithOptions(ClusterId, TaskName, headers, runtime);
}

model DeleteGatewayResponseBody = {
  gatewayId?: string(name='GatewayId', description='The private gateway ID.', example='gw-1uhcqmsc7x22******'),
  message?: string(name='Message', description='The returned message.', example='Gateway is deleted.'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model DeleteGatewayResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteGatewayResponseBody(name='body'),
}

/**
 * @summary Deletes a private gateway.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteGatewayResponse
 */
async function deleteGatewayWithOptions(ClusterId: string, GatewayId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteGatewayResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteGateway',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GatewayId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a private gateway.
 *
 * @return DeleteGatewayResponse
 */
async function deleteGateway(ClusterId: string, GatewayId: string): DeleteGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteGatewayWithOptions(ClusterId, GatewayId, headers, runtime);
}

model DeleteGatewayIntranetLinkedVpcRequest {
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.', example='vsw-8vbqn2at0kljjxxxx****'),
  vpcId?: string(name='VpcId', description='The virtual private cloud (VPC) ID.', example='vpc-uf66uio7md****'),
}

model DeleteGatewayIntranetLinkedVpcResponseBody = {
  gatewayId?: string(name='GatewayId', description='The private gateway ID.', example='gw-1uhcqmsc7x22******'),
  message?: string(name='Message', description='The returned message.', example='Successfully delete intranet linked vpc for gateway'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model DeleteGatewayIntranetLinkedVpcResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteGatewayIntranetLinkedVpcResponseBody(name='body'),
}

/**
 * @summary 删除网关内网访问端点
 *
 * @param request DeleteGatewayIntranetLinkedVpcRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteGatewayIntranetLinkedVpcResponse
 */
async function deleteGatewayIntranetLinkedVpcWithOptions(ClusterId: string, GatewayId: string, request: DeleteGatewayIntranetLinkedVpcRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteGatewayIntranetLinkedVpcResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGatewayIntranetLinkedVpc',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GatewayId)}/intranet_endpoint_linked_vpc`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除网关内网访问端点
 *
 * @param request DeleteGatewayIntranetLinkedVpcRequest
 * @return DeleteGatewayIntranetLinkedVpcResponse
 */
async function deleteGatewayIntranetLinkedVpc(ClusterId: string, GatewayId: string, request: DeleteGatewayIntranetLinkedVpcRequest): DeleteGatewayIntranetLinkedVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteGatewayIntranetLinkedVpcWithOptions(ClusterId, GatewayId, request, headers, runtime);
}

model DeleteGatewayIntranetLinkedVpcPeerRequest {
  peerVpcs?: [ 
    {
      region?: string(name='Region', description='The region where the VPC peer resides.', example='cn-shanghai'),
      vpcId?: string(name='VpcId', description='The ID of the VPC peer.', example='vpc-uf66uio7md****'),
    }
  ](name='PeerVpcs', description='The VPC peer.'),
  vpcId?: string(name='VpcId', description='The ID of the associated VPC. To obtain the VPC ID, see [ListGatewayIntranetLinkedVpc](https://help.aliyun.com/document_detail/2621223.html).', example='vpc-2zetuli9ws0qgjd******'),
}

model DeleteGatewayIntranetLinkedVpcPeerShrinkRequest {
  peerVpcsShrink?: string(name='PeerVpcs', description='The VPC peer.'),
  vpcId?: string(name='VpcId', description='The ID of the associated VPC. To obtain the VPC ID, see [ListGatewayIntranetLinkedVpc](https://help.aliyun.com/document_detail/2621223.html).', example='vpc-2zetuli9ws0qgjd******'),
}

model DeleteGatewayIntranetLinkedVpcPeerResponseBody = {
  gatewayId?: string(name='GatewayId', description='The ID of the private gateway.', example='gw-1uhcqmsc7x22******'),
  message?: string(name='Message', description='The message that is returned.', example='Successfully delete intranet linked vpc Peer for gateway'),
  requestId?: string(name='requestId', description='The ID of the request.', example='40325405-579C-4D82****'),
}

model DeleteGatewayIntranetLinkedVpcPeerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteGatewayIntranetLinkedVpcPeerResponseBody(name='body'),
}

/**
 * @summary Deletes a VPC peering connection from an internal endpoint of a gateway.
 *
 * @param tmpReq DeleteGatewayIntranetLinkedVpcPeerRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteGatewayIntranetLinkedVpcPeerResponse
 */
async function deleteGatewayIntranetLinkedVpcPeerWithOptions(ClusterId: string, GatewayId: string, tmpReq: DeleteGatewayIntranetLinkedVpcPeerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteGatewayIntranetLinkedVpcPeerResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteGatewayIntranetLinkedVpcPeerShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.peerVpcs)) {
    request.peerVpcsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.peerVpcs, 'PeerVpcs', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.peerVpcsShrink)) {
    query['PeerVpcs'] = request.peerVpcsShrink;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGatewayIntranetLinkedVpcPeer',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GatewayId)}/intranet_endpoint_linked_vpc_peer`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a VPC peering connection from an internal endpoint of a gateway.
 *
 * @param request DeleteGatewayIntranetLinkedVpcPeerRequest
 * @return DeleteGatewayIntranetLinkedVpcPeerResponse
 */
async function deleteGatewayIntranetLinkedVpcPeer(ClusterId: string, GatewayId: string, request: DeleteGatewayIntranetLinkedVpcPeerRequest): DeleteGatewayIntranetLinkedVpcPeerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteGatewayIntranetLinkedVpcPeerWithOptions(ClusterId, GatewayId, request, headers, runtime);
}

model DeleteResourceResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Resource [eas-r-asdasdasd] is deleted.'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82-9624-EC2B1779848E'),
}

model DeleteResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteResourceResponseBody(name='body'),
}

/**
 * @summary Deletes a resource group that contains no resources or instances.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteResourceResponse
 */
async function deleteResourceWithOptions(ClusterId: string, ResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteResourceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteResource',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a resource group that contains no resources or instances.
 *
 * @return DeleteResourceResponse
 */
async function deleteResource(ClusterId: string, ResourceId: string): DeleteResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteResourceWithOptions(ClusterId, ResourceId, headers, runtime);
}

model DeleteResourceDLinkResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Network interfaces are deleting'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model DeleteResourceDLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteResourceDLinkResponseBody(name='body'),
}

/**
 * @summary Disables the virtual private cloud (VPC) direct connection feature for a dedicated resource group.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteResourceDLinkResponse
 */
async function deleteResourceDLinkWithOptions(ClusterId: string, ResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteResourceDLinkResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourceDLink',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/dlink`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Disables the virtual private cloud (VPC) direct connection feature for a dedicated resource group.
 *
 * @return DeleteResourceDLinkResponse
 */
async function deleteResourceDLink(ClusterId: string, ResourceId: string): DeleteResourceDLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteResourceDLinkWithOptions(ClusterId, ResourceId, headers, runtime);
}

model DeleteResourceInstanceLabelRequest {
  allInstances?: boolean(name='AllInstances', description='Specifies whether the delete operation takes effect on all instances in the resource group. If you set this parameter to true, the InstanceIds parameter does not take effect.'),
  instanceIds?: [ string ](name='InstanceIds', description='The instance IDs.'),
  keys?: [ string ](name='Keys', description='The keys of the tags that you want to delete.'),
}

model DeleteResourceInstanceLabelShrinkRequest {
  allInstances?: boolean(name='AllInstances', description='Specifies whether the delete operation takes effect on all instances in the resource group. If you set this parameter to true, the InstanceIds parameter does not take effect.'),
  instanceIdsShrink?: string(name='InstanceIds', description='The instance IDs.'),
  keysShrink?: string(name='Keys', description='The keys of the tags that you want to delete.'),
}

model DeleteResourceInstanceLabelResponseBody = {
  message?: string(name='Message', description='The message.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82********'),
}

model DeleteResourceInstanceLabelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteResourceInstanceLabelResponseBody(name='body'),
}

/**
 * @summary Deletes the tags of an instance in a resource group.
 *
 * @param tmpReq DeleteResourceInstanceLabelRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteResourceInstanceLabelResponse
 */
async function deleteResourceInstanceLabelWithOptions(ClusterId: string, ResourceId: string, tmpReq: DeleteResourceInstanceLabelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteResourceInstanceLabelResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteResourceInstanceLabelShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.instanceIds)) {
    request.instanceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.instanceIds, 'InstanceIds', 'simple');
  }
  if (!Util.isUnset(tmpReq.keys)) {
    request.keysShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.keys, 'Keys', 'simple');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.allInstances)) {
    query['AllInstances'] = request.allInstances;
  }
  if (!Util.isUnset(request.instanceIdsShrink)) {
    query['InstanceIds'] = request.instanceIdsShrink;
  }
  if (!Util.isUnset(request.keysShrink)) {
    query['Keys'] = request.keysShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourceInstanceLabel',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/label`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes the tags of an instance in a resource group.
 *
 * @param request DeleteResourceInstanceLabelRequest
 * @return DeleteResourceInstanceLabelResponse
 */
async function deleteResourceInstanceLabel(ClusterId: string, ResourceId: string, request: DeleteResourceInstanceLabelRequest): DeleteResourceInstanceLabelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteResourceInstanceLabelWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

model DeleteResourceInstancesRequest {
  allFailed?: boolean(name='AllFailed', description='Specifies whether to delete all the instances that fail to be created. Valid values:

*   true
*   false', example='true'),
  instanceList?: string(name='InstanceList', description='The instances. Separate multiple instances with commas (,), such as `instanceId1,instanceId2`. For more information about how to query the instances, see [ListResourceInstances](https://help.aliyun.com/document_detail/412129.html).', example='eas-i-xxxxxxx,eas-i-xxxxxxx'),
}

model DeleteResourceInstancesResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Instances eas-i-011227132046,eas-i-011227132046 are deleting'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model DeleteResourceInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteResourceInstancesResponseBody(name='body'),
}

/**
 * @summary Deletes instances in a dedicated resource group. You can delete only pay-as-you-go instances as a regular user.
 *
 * @param request DeleteResourceInstancesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteResourceInstancesResponse
 */
async function deleteResourceInstancesWithOptions(ClusterId: string, ResourceId: string, request: DeleteResourceInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteResourceInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.allFailed)) {
    query['AllFailed'] = request.allFailed;
  }
  if (!Util.isUnset(request.instanceList)) {
    query['InstanceList'] = request.instanceList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourceInstances',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/instances`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes instances in a dedicated resource group. You can delete only pay-as-you-go instances as a regular user.
 *
 * @param request DeleteResourceInstancesRequest
 * @return DeleteResourceInstancesResponse
 */
async function deleteResourceInstances(ClusterId: string, ResourceId: string, request: DeleteResourceInstancesRequest): DeleteResourceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteResourceInstancesWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

model DeleteResourceLogResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Log service for resource [eas-r-asdasdasd] is deleting'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model DeleteResourceLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteResourceLogResponseBody(name='body'),
}

/**
 * @summary Disables the LogShipper feature of Log Service for a dedicated resource group.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteResourceLogResponse
 */
async function deleteResourceLogWithOptions(ClusterId: string, ResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteResourceLogResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourceLog',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/log`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Disables the LogShipper feature of Log Service for a dedicated resource group.
 *
 * @return DeleteResourceLogResponse
 */
async function deleteResourceLog(ClusterId: string, ResourceId: string): DeleteResourceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteResourceLogWithOptions(ClusterId, ResourceId, headers, runtime);
}

model DeleteServiceResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Service [foo] in region [cn-shanghai] is terminating'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model DeleteServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteServiceResponseBody(name='body'),
}

/**
 * @summary Deletes a service.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteServiceResponse
 */
async function deleteServiceWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a service.
 *
 * @return DeleteServiceResponse
 */
async function deleteService(ClusterId: string, ServiceName: string): DeleteServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceWithOptions(ClusterId, ServiceName, headers, runtime);
}

model DeleteServiceAutoScalerResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Autoscaler for service [foo] deleted successfully'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model DeleteServiceAutoScalerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteServiceAutoScalerResponseBody(name='body'),
}

/**
 * @summary Deletes the existing Autoscaler controller and disables the Autoscaler feature for a service.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteServiceAutoScalerResponse
 */
async function deleteServiceAutoScalerWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceAutoScalerResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceAutoScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/autoscaler`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes the existing Autoscaler controller and disables the Autoscaler feature for a service.
 *
 * @return DeleteServiceAutoScalerResponse
 */
async function deleteServiceAutoScaler(ClusterId: string, ServiceName: string): DeleteServiceAutoScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceAutoScalerWithOptions(ClusterId, ServiceName, headers, runtime);
}

model DeleteServiceCronScalerResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Cronscaler for service [foo] deleted successfully'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model DeleteServiceCronScalerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteServiceCronScalerResponseBody(name='body'),
}

/**
 * @summary Disables the Cronscaler feature for a service.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteServiceCronScalerResponse
 */
async function deleteServiceCronScalerWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceCronScalerResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceCronScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/cronscaler`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Disables the Cronscaler feature for a service.
 *
 * @return DeleteServiceCronScalerResponse
 */
async function deleteServiceCronScaler(ClusterId: string, ServiceName: string): DeleteServiceCronScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceCronScalerWithOptions(ClusterId, ServiceName, headers, runtime);
}

model DeleteServiceInstancesRequest {
  container?: string(name='Container', description='The name of the container whose process needs to be restarted. This parameter takes effect only if the SoftRestart parameter is set to true.', example='worker0'),
  instanceList?: string(name='InstanceList', description='The instances that you want to restart. Separate multiple instance names with commas (,). For more information about how to query the instance name, see [ListServiceInstances](https://help.aliyun.com/document_detail/412108.html).

This parameter is required.', example='foo-rdsbxxxx,foo-rdsaxxxx'),
  softRestart?: boolean(name='SoftRestart', description='Specifies whether to restart only the container process without recreating the instance. Default value: false. Valid values: true and false.', example='true'),
}

model DeleteServiceInstancesResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Instance(s) [foo-rdsb,foo-rdsa]  for service [foo] in region [cn-shanghai] was deleted successfully'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model DeleteServiceInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteServiceInstancesResponseBody(name='body'),
}

/**
 * @summary Restarts the instances of a service.
 *
 * @param request DeleteServiceInstancesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteServiceInstancesResponse
 */
async function deleteServiceInstancesWithOptions(ClusterId: string, ServiceName: string, request: DeleteServiceInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.container)) {
    query['Container'] = request.container;
  }
  if (!Util.isUnset(request.instanceList)) {
    query['InstanceList'] = request.instanceList;
  }
  if (!Util.isUnset(request.softRestart)) {
    query['SoftRestart'] = request.softRestart;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceInstances',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/instances`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Restarts the instances of a service.
 *
 * @param request DeleteServiceInstancesRequest
 * @return DeleteServiceInstancesResponse
 */
async function deleteServiceInstances(ClusterId: string, ServiceName: string, request: DeleteServiceInstancesRequest): DeleteServiceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceInstancesWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model DeleteServiceLabelRequest {
  keys?: [ string ](name='Keys', description='The service tags that you want to delete.

This parameter is required.'),
}

model DeleteServiceLabelShrinkRequest {
  keysShrink?: string(name='Keys', description='The service tags that you want to delete.

This parameter is required.'),
}

model DeleteServiceLabelResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Succeed to delete service [service_from_zxxx] labels.'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model DeleteServiceLabelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteServiceLabelResponseBody(name='body'),
}

/**
 * @summary Deletes existing service tags.
 *
 * @param tmpReq DeleteServiceLabelRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteServiceLabelResponse
 */
async function deleteServiceLabelWithOptions(ClusterId: string, ServiceName: string, tmpReq: DeleteServiceLabelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceLabelResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteServiceLabelShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.keys)) {
    request.keysShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.keys, 'Keys', 'simple');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.keysShrink)) {
    query['Keys'] = request.keysShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceLabel',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/label`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes existing service tags.
 *
 * @param request DeleteServiceLabelRequest
 * @return DeleteServiceLabelResponse
 */
async function deleteServiceLabel(ClusterId: string, ServiceName: string, request: DeleteServiceLabelRequest): DeleteServiceLabelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceLabelWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model DeleteServiceMirrorResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Traffic mirroring is OFF for service [foo] in region [cn-shanghia], ratio [70%]'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82***'),
}

model DeleteServiceMirrorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteServiceMirrorResponseBody(name='body'),
}

/**
 * @summary Disables the traffic mirroring feature for a service.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteServiceMirrorResponse
 */
async function deleteServiceMirrorWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceMirrorResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceMirror',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/mirror`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Disables the traffic mirroring feature for a service.
 *
 * @return DeleteServiceMirrorResponse
 */
async function deleteServiceMirror(ClusterId: string, ServiceName: string): DeleteServiceMirrorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceMirrorWithOptions(ClusterId, ServiceName, headers, runtime);
}

model DeleteVirtualResourceResponseBody = {
  message?: string(name='Message', description='The information about the operation result.', example='Successfully deleted virtual resource eas-vr-npovr28onap1xxxxxx'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='40325405-579C-4D82***'),
}

model DeleteVirtualResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteVirtualResourceResponseBody(name='body'),
}

/**
 * @summary Deletes a virtual resource group that contains no resources or instances.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVirtualResourceResponse
 */
async function deleteVirtualResourceWithOptions(ClusterId: string, VirtualResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteVirtualResourceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteVirtualResource',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/virtualresources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(VirtualResourceId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a virtual resource group that contains no resources or instances.
 *
 * @return DeleteVirtualResourceResponse
 */
async function deleteVirtualResource(ClusterId: string, VirtualResourceId: string): DeleteVirtualResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteVirtualResourceWithOptions(ClusterId, VirtualResourceId, headers, runtime);
}

model DescribeBenchmarkTaskResponseBody = {
  availableAgent?: long(name='AvailableAgent', description='The number of instances that you can test.', example='4'),
  callerUid?: string(name='CallerUid', description='The ID of the operation caller.', example='1640133467****'),
  desiredAgent?: long(name='DesiredAgent', description='The number of instances that you want to test.', example='4'),
  endpoint?: string(name='Endpoint', description='The endpoint of the service gateway.', example='192342311234.pai-eas.cn-chengdu.aliyuncs.com'),
  message?: string(name='Message', description='The returned message.', example='Benchmar task is Running'),
  parentUid?: string(name='ParentUid', description='The ID of the Alibaba Cloud account that is used to call the operation.', example='1029728669****'),
  reason?: string(name='Reason', description='The event or reason that causes the current state of the stress testing task.', example='RUNNING'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  serviceName?: string(name='ServiceName', description='The name of the service that you want to test.', example='foo'),
  status?: string(name='Status', description='The state of the stress testing task.

Valid values:

*   Creating

    <!-- -->

    <!-- -->

    <!-- -->

*   Starting

    <!-- -->

    <!-- -->

    <!-- -->

*   DeleteFailed

    <!-- -->

    <!-- -->

    <!-- -->

*   Running

    <!-- -->

    <!-- -->

    <!-- -->

*   Stopping

    <!-- -->

    <!-- -->

    <!-- -->

*   Error

    <!-- -->

    <!-- -->

    <!-- -->

*   Updating

    <!-- -->

    <!-- -->

    <!-- -->

*   Deleting

    <!-- -->

    <!-- -->

    <!-- -->

*   CreateFailed

    <!-- -->

    <!-- -->

    <!-- -->', example='Running'),
  taskId?: string(name='TaskId', description='The ID of the stress testing task.', example='eas-b-gv4y86u****'),
  taskName?: string(name='TaskName', description='The name of the stress testing task.', example='benchmark-larec-test-ae70'),
  token?: string(name='Token', description='The token for authentication when a stress testing task is created.', example='6062787a-9301****'),
}

model DescribeBenchmarkTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBenchmarkTaskResponseBody(name='body'),
}

/**
 * @summary Queries details about the configurations of a stress testing task.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBenchmarkTaskResponse
 */
async function describeBenchmarkTaskWithOptions(ClusterId: string, TaskName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeBenchmarkTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(TaskName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries details about the configurations of a stress testing task.
 *
 * @return DescribeBenchmarkTaskResponse
 */
async function describeBenchmarkTask(ClusterId: string, TaskName: string): DescribeBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeBenchmarkTaskWithOptions(ClusterId, TaskName, headers, runtime);
}

model DescribeBenchmarkTaskReportRequest {
  reportType?: string(name='ReportType', description='The report type of the stress testing task. Valid values: RAW and Report.', example='report'),
}

model DescribeBenchmarkTaskReportResponseBody = {
  data?: any(name='Data', description='If the value of ReportType is set to RAW, the details about the stress testing report are returned.', example='{
    "TimestampList": ["int64"],
    "QPSList": ["float32"],
    "RTList": [
      {
        "AVG": "float32",
        "TP100": "float32",
        "TP99": "float32",
        "TP90": "float32",
        "TP50": "float32",
        "TP10": "float32"
      }
    ],
    "TrafficList": [
      {
        "Send": "float64",
        "Receive": "float64"
      }
    ],
    "StatusCode": {
      "200": "uint64",
      "450": "uint64",
      "500": "uint64"
    },
    "Count": "uint64",
    "Total": "float64",
    "MinRT": "float32",
    "AvgRT": "float32",
    "MaxRT": "float32",
    "QPS": "float32",
    "TotalSend": "float64",
    "TotalReceive": "float64",
    "RTDistribution": [
      {
        "Latency": "float32",
        "Percentage": "int"
      }
    ],
    "RTHistogram": [
      {
        "Count": "int",
        "Mark": "float32",
        "Frequency": "float32"
      }
    ]
  }'),
  reportUrl?: string(name='ReportUrl', description='If the value of ReportType is set to Report, the URL of the stress testing report is returned.', example='http://eas-benchmark.oss-cn-chengdu.aliyuncs.com/summary/benchmark-larec-test-015d-10007.html'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82********'),
}

model DescribeBenchmarkTaskReportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBenchmarkTaskReportResponseBody(name='body'),
}

/**
 * @summary Queries the report of a stress testing task.
 *
 * @param request DescribeBenchmarkTaskReportRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBenchmarkTaskReportResponse
 */
async function describeBenchmarkTaskReportWithOptions(ClusterId: string, TaskName: string, request: DescribeBenchmarkTaskReportRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeBenchmarkTaskReportResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.reportType)) {
    query['ReportType'] = request.reportType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBenchmarkTaskReport',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(TaskName)}/report`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the report of a stress testing task.
 *
 * @param request DescribeBenchmarkTaskReportRequest
 * @return DescribeBenchmarkTaskReportResponse
 */
async function describeBenchmarkTaskReport(ClusterId: string, TaskName: string, request: DescribeBenchmarkTaskReportRequest): DescribeBenchmarkTaskReportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeBenchmarkTaskReportWithOptions(ClusterId, TaskName, request, headers, runtime);
}

model DescribeGatewayResponseBody = {
  chargeType?: string(name='ChargeType'),
  createTime?: string(name='CreateTime', description='The time when the private gateway was created. The time is displayed in UTC.', example='2020-05-19T14:19:42Z'),
  externalClusterId?: string(name='ExternalClusterId', description='The ID of the self-managed cluster.', example='c935eadf284c14c2da57a2a13ad6******'),
  gatewayId?: string(name='GatewayId', description='The ID of the private gateway.', example='gw-1uhcqmsc7x22******'),
  gatewayName?: string(name='GatewayName', description='The alias of the private gateway.', example='mygateway1'),
  instanceType?: string(name='InstanceType', description='The instance type used by the private gateway.

Valid values:

*   8c16g
*   4c8g
*   2c4g
*   16c32g', example='ecs.c6.4xlarge'),
  internetDomain?: string(name='InternetDomain', description='The public endpoint.', example='gw-1uhcqmsc7x22******-1801786532******.cn-hangzhou.pai-eas.aliyuncs.com'),
  internetEnabled?: boolean(name='InternetEnabled', description='Indicates whether Internet access is enabled.', example='true'),
  internetStatus?: string(name='InternetStatus', description='Indicates whether Internet access is enabled.

Valid values:

*   Creating: Internet access is being enabled.
*   Failed: Internet access failed to be enabled or deleted.
*   Running: Internet access is running.
*   Deleted: Internet access is deleted.
*   Deleting: Internet access is being deleted.', example='Running'),
  intranetDomain?: string(name='IntranetDomain', description='The internal endpoint.', example='gw-1uhcqmsc7x22******-1801786532******-vpc.cn-hangzhou.pai-eas.aliyuncs.com'),
  isDefault?: boolean(name='IsDefault', description='Indicates whether it is the default private gateway.', example='true'),
  replicas?: int32(name='Replicas', description='The number of nodes in the private gateway.', example='2'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  SSLRedirectionEnabled?: boolean(name='SSLRedirectionEnabled', description='Indicates whether the HTTP to HTTPS redirection is enabled.', example='true'),
  status?: string(name='Status', description='The status of the private gateway.

Valid values:

*   Creating
*   Stopped
*   Failed
*   Running
*   Deleted
*   Deleting
*   Waiting', example='PrivateGatewayRunning'),
  updateTime?: string(name='UpdateTime', description='The time when the private gateway was updated. The time is displayed in UTC.', example='2021-02-24T11:52:17Z'),
}

model DescribeGatewayResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGatewayResponseBody(name='body'),
}

/**
 * @summary Queries the details of a private gateway.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGatewayResponse
 */
async function describeGatewayWithOptions(ClusterId: string, GatewayId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeGatewayResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeGateway',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GatewayId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of a private gateway.
 *
 * @return DescribeGatewayResponse
 */
async function describeGateway(ClusterId: string, GatewayId: string): DescribeGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeGatewayWithOptions(ClusterId, GatewayId, headers, runtime);
}

model DescribeGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Group  
}

/**
 * @summary Queries the information about a service group.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGroupResponse
 */
async function describeGroupWithOptions(ClusterId: string, GroupName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeGroup',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/groups/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GroupName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about a service group.
 *
 * @return DescribeGroupResponse
 */
async function describeGroup(ClusterId: string, GroupName: string): DescribeGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeGroupWithOptions(ClusterId, GroupName, headers, runtime);
}

model DescribeGroupEndpointsResponseBody = {
  accessToken?: string(name='AccessToken', description='The service token.', example='Nzc5N2FhNTM4OTQ0YzBmYTIy****ZTUxN2NkYjg4MTJmMWQxZmY1****'),
  endpoints?: [ 
    {
      backendId?: string(name='BackendId'),
      endpointType?: string(name='EndpointType'),
      internetEndpoints?: [ string ](name='InternetEndpoints'),
      intranetEndpoints?: [ string ](name='IntranetEndpoints'),
      pathType?: string(name='PathType'),
      port?: int32(name='Port'),
    }
  ](name='Endpoints', description='The endpoints of the service group.'),
  message?: string(name='Message', description='The response message.', example='Execution successful.'),
  requestId?: string(name='RequestId', description='The request ID.', example='890772EF-3AD6-129A-8E15-8F349C944783'),
}

model DescribeGroupEndpointsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGroupEndpointsResponseBody(name='body'),
}

/**
 * @summary Obtains a list of endpoints of service groups.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGroupEndpointsResponse
 */
async function describeGroupEndpointsWithOptions(ClusterId: string, GroupName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeGroupEndpointsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeGroupEndpoints',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/groups/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GroupName)}/endpoints`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains a list of endpoints of service groups.
 *
 * @return DescribeGroupEndpointsResponse
 */
async function describeGroupEndpoints(ClusterId: string, GroupName: string): DescribeGroupEndpointsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeGroupEndpointsWithOptions(ClusterId, GroupName, headers, runtime);
}

model DescribeMachineSpecRequest {
  instanceTypes?: [ string ](name='InstanceTypes', description='This parameter is deprecated.', deprecated=true),
}

model DescribeMachineSpecShrinkRequest {
  instanceTypesShrink?: string(name='InstanceTypes', description='This parameter is deprecated.', deprecated=true),
}

model DescribeMachineSpecResponseBody = {
  instanceMetas?: [ 
    {
      CPU?: int32(name='CPU', description='The number of CPU cores in the instance type.', example='32'),
      GPU?: string(name='GPU', description='The GPU type in the instance type. If the instance type is not a GPU-based instance type, this parameter does not exist.', example='GU30'),
      GPUAmount?: int32(name='GPUAmount', description='The number of GPUs in the instance type.', example='1'),
      GPUMemory?: float(name='GPUMemory', description='The GPU memory in the instance type. Unit: GB.', example='24'),
      instanceType?: string(name='InstanceType', description='The name of the instance type.', example='ml.gu7i.c32m188.1-gu30'),
      isAvailable?: boolean(name='IsAvailable', description='Indicates whether the instance type is available.', example='true'),
      memory?: float(name='Memory', description='The memory size in the instance type. Unit: GB.', example='188'),
      nonProtectSpotDiscount?: float(name='NonProtectSpotDiscount', description='The minimum discount that can be accepted when the preemptible instance type does not include a usage duration. 0.1 indicates one fold. If this parameter is not returned, the bidding feature is not supported.', example='0.1'),
      spotDiscount?: float(name='SpotDiscount', description='The minimum discount that can be accepted when the preemptible instance type has the 1-hour protection duration. 0.1 indicates one fold. If this parameter is not returned, the bidding feature is not supported.', example='0.12'),
      stockStatus?: string(name='StockStatus', description='The inventory status of the instance type.

Valid values:

*   WithStock
*   ClosedWithStock
*   NoStock', example='WithStock'),
      vendor?: string(name='Vendor', description='The source of the instance type.

Valid values:

*   ECS
*   BareMetal
*   Lingjun', example='ECS'),
    }
  ](name='InstanceMetas', description='The instance types when the resources are specified.'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82***'),
  types?: [ 
    {
      CPU?: int32(name='CPU', description='Valid values:', example='1'),
      memory?: [ int32 ](name='Memory', description='The optional values for memory when CPU is set to a specific value as above.'),
    }
  ](name='Types', description='The values that can be supported when the number of CPUs and memory size are specified for deployment.'),
}

model DescribeMachineSpecResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeMachineSpecResponseBody(name='body'),
}

/**
 * @summary Queries a list of instance types for an available instance in a shared resource group.
 *
 * @param tmpReq DescribeMachineSpecRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeMachineSpecResponse
 */
async function describeMachineSpecWithOptions(tmpReq: DescribeMachineSpecRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeMachineSpecResponse {
  Util.validateModel(tmpReq);
  var request = new DescribeMachineSpecShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.instanceTypes)) {
    request.instanceTypesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.instanceTypes, 'InstanceTypes', 'simple');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceTypesShrink)) {
    query['InstanceTypes'] = request.instanceTypesShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMachineSpec',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/public/instance_types`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of instance types for an available instance in a shared resource group.
 *
 * @param request DescribeMachineSpecRequest
 * @return DescribeMachineSpecResponse
 */
async function describeMachineSpec(request: DescribeMachineSpecRequest): DescribeMachineSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeMachineSpecWithOptions(request, headers, runtime);
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      regionId?: string(name='RegionId', description='The region ID.', example='cn-shanghai'),
      regionName?: string(name='RegionName', description='The region name.'),
    }
  ](name='Regions', description='The available regions.'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

/**
 * @summary Queries available regions.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRegionsResponse
 */
async function describeRegionsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/regions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries available regions.
 *
 * @return DescribeRegionsResponse
 */
async function describeRegions(): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeRegionsWithOptions(headers, runtime);
}

model DescribeResourceResponseBody = {
  clusterId?: string(name='ClusterId', description='The ID of the cluster to which the resource group belongs.', example='cn-beijing'),
  cpuCount?: int32(name='CpuCount', description='The total number of CPU cores.', example='16'),
  cpuUsed?: int32(name='CpuUsed', description='The number of vCPUs that is used.', example='8'),
  createTime?: string(name='CreateTime', description='The time when the resource group was created.', example='2020-05-19T14:19:42Z'),
  extraData?: string(name='ExtraData', description='The additional information, such as the connection status of a virtual private cloud (VPC) and the log status of Log Service.', example='{"vswitch_id":"vsw-bp17uo6xebcusy****","gpu_share":true,"aux_vswitch_id_list":["vsw-bp13b3pvjap3vxn****","vsw-bp1nls8o5hk8mt8*****"],"security_group_id":"sg-bp1j1z7297hcink*****","vpc_id":"vpc-bp1kjr3rfyhx01*****","destination_cidr":"172.16.0.12/28","role_arn":"acs:ram::1157703270*****:role/AliyunServiceRoleForPaiEas","sls_project":"","sls_logstore":"","sls_status":"ResourceReady","sls_message":"","update_time":""}'),
  features?: [ string ](name='Features'),
  gpuCount?: int32(name='GpuCount', description='The total number of GPUs.', example='1'),
  gpuUsed?: float(name='GpuUsed', description='The number of GPUs that is used.', example='2'),
  instanceCount?: int32(name='InstanceCount', description='The total number of instances in the resource group.', example='4'),
  instanceMaxAllocatableCPU?: int32(name='InstanceMaxAllocatableCPU'),
  instanceMaxAllocatableGPU?: float(name='InstanceMaxAllocatableGPU'),
  instanceMaxAllocatableMemory?: int32(name='InstanceMaxAllocatableMemory'),
  memory?: int32(name='Memory', description='The total memory size. Unit: MB.', example='8192'),
  memoryUsed?: int32(name='MemoryUsed', description='The size of memory that is used. Unit: MB.', example='2048'),
  message?: string(name='Message', description='The returned message.', example='Resource is ready'),
  ownerUid?: string(name='OwnerUid', description='The ID of the resource group owner.', example='14401087478****'),
  postPaidInstanceCount?: int32(name='PostPaidInstanceCount', description='The total number of pay-as-you-go instances in the resource group.', example='3'),
  prePaidInstanceCount?: int32(name='PrePaidInstanceCount', description='The total number of subscription instances in the resource group.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='902976F2-6FAF-5404-8A4D-6CC223***'),
  resourceId?: string(name='ResourceId', description='The ID of the Elastic Algorithm Service (EAS) resource.', example='eas-r-glkfpsxuw57x1h*****'),
  resourceName?: string(name='ResourceName', description='The name of the EAS resource.', example='my-resouce****'),
  resourceType?: string(name='ResourceType', description='The type of the resource group. Valid values:

*   Dedicated: the dedicated resource group.
*   SelfManaged: the self-managed resource group.', example='Dedicated'),
  status?: string(name='Status', description='The state of the resource group.', example='ResourceReady'),
  updateTime?: string(name='UpdateTime', description='The time when the resource group was last updated.', example='2021-02-24T11:52:17Z'),
}

model DescribeResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeResourceResponseBody(name='body'),
}

/**
 * @summary Queries the information about a resource group.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeResourceResponse
 */
async function describeResourceWithOptions(ClusterId: string, ResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeResourceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeResource',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about a resource group.
 *
 * @return DescribeResourceResponse
 */
async function describeResource(ClusterId: string, ResourceId: string): DescribeResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeResourceWithOptions(ClusterId, ResourceId, headers, runtime);
}

model DescribeResourceDLinkResponseBody = {
  auxVSwitchList?: [ string ](name='AuxVSwitchList', description='The IDs of the secondary vSwitches that are directly connected.'),
  destinationCIDRs?: string(name='DestinationCIDRs', description='The CIDR blocks of the clients that you want to connect to. After this parameter is specified, the CIDR blocks are added to the back-to-origin route of the server. Either this parameter or the VSwitchIdList parameter can be used to determine CIDR blocks.', example='72.16.0.0/16'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group that is directly connected.', example='sg-bp1j1z7297hcink9d****'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the primary vSwitch that is directly connected.', example='vsw-8vbqn2at0kljjxxxx****'),
  vpcId?: string(name='VpcId', description='The ID of the VPC that is directly connected.', example='vpc-uf66uio7md****'),
}

model DescribeResourceDLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeResourceDLinkResponseBody(name='body'),
}

/**
 * @summary Queries detailed configurations about a virtual private cloud (VPC) direct connection of a dedicated resource group.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeResourceDLinkResponse
 */
async function describeResourceDLinkWithOptions(ClusterId: string, ResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeResourceDLinkResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeResourceDLink',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/dlink`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries detailed configurations about a virtual private cloud (VPC) direct connection of a dedicated resource group.
 *
 * @return DescribeResourceDLinkResponse
 */
async function describeResourceDLink(ClusterId: string, ResourceId: string): DescribeResourceDLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeResourceDLinkWithOptions(ClusterId, ResourceId, headers, runtime);
}

model DescribeResourceLogResponseBody = {
  logStore?: string(name='LogStore', description='The Logstore of Log Service.', example='access_log'),
  message?: string(name='Message', description='The returned message.', example='Network interfaces are updating'),
  projectName?: string(name='ProjectName', description='The Log Service project that is associated with the resource group.', example='eas-r-asdasdasd-sls'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  status?: string(name='Status', description='The state of the resource group.', example='ResourceReady'),
}

model DescribeResourceLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeResourceLogResponseBody(name='body'),
}

/**
 * @summary Queries the details about the LogShipper configurations of Log Service for a dedicated resource group.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeResourceLogResponse
 */
async function describeResourceLogWithOptions(ClusterId: string, ResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeResourceLogResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeResourceLog',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/log`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details about the LogShipper configurations of Log Service for a dedicated resource group.
 *
 * @return DescribeResourceLogResponse
 */
async function describeResourceLog(ClusterId: string, ResourceId: string): DescribeResourceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeResourceLogWithOptions(ClusterId, ResourceId, headers, runtime);
}

model DescribeServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Service  
}

/**
 * @summary Queries the details about a service.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeServiceResponse
 */
async function describeServiceWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details about a service.
 *
 * @return DescribeServiceResponse
 */
async function describeService(ClusterId: string, ServiceName: string): DescribeServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceWithOptions(ClusterId, ServiceName, headers, runtime);
}

model DescribeServiceAutoScalerResponseBody = {
  behavior?: map[string]any(name='Behavior', description='The additional information about the Autoscaler policy, such as the interval of triggering Autoscaler.', example='{
  "behavior": {
    "scaleDown": {
      "stabilizationWindowSeconds": 150
    }
  }
}'),
  currentMetrics?: [ 
    {
      metricName?: string(name='metricName', description='The metric name. Valid values:

*   QPS
*   CPU', example='qps'),
      service?: string(name='service', description='The service for which the metric is specified.', example='demo_svc'),
      value?: float(name='value', description='The metric value.', example='10'),
    }
  ](name='CurrentMetrics', description='The metrics.'),
  maxReplica?: int32(name='MaxReplica', description='The maximum number of instances in the service.', example='8'),
  minReplica?: int32(name='MinReplica', description='The minimum number of instances in the service.', example='3'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  scaleStrategies?: [ 
    {
      metricName?: string(name='metricName', description='The metric name. Valid values:

*   QPS: the queries per second (QPS) for an individual instance.
*   CPU: the CPU utilization.', example='QPS'),
      service?: string(name='service', description='The service for which the metric is specified. If you do not set this parameter, the current service is specified by default.', example='demo_svc'),
      threshold?: float(name='threshold', description='The threshold of the metric that triggers auto scaling.

*   If you set metricName to QPS, scale-out is triggered when the average QPS for a single instance is greater than this threshold.
*   If you set metricName to CPU, scale-out is triggered when the average CPU utilization for a single instance is greater than this threshold.', example='10'),
    }
  ](name='ScaleStrategies', description='The auto scaling policies.'),
  serviceName?: string(name='ServiceName', description='The service name.', example='foo'),
}

model DescribeServiceAutoScalerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeServiceAutoScalerResponseBody(name='body'),
}

/**
 * @summary Queries information about the Autoscaler configurations of a service.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeServiceAutoScalerResponse
 */
async function describeServiceAutoScalerWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceAutoScalerResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceAutoScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/autoscaler`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries information about the Autoscaler configurations of a service.
 *
 * @return DescribeServiceAutoScalerResponse
 */
async function describeServiceAutoScaler(ClusterId: string, ServiceName: string): DescribeServiceAutoScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceAutoScalerWithOptions(ClusterId, ServiceName, headers, runtime);
}

model DescribeServiceCronScalerResponseBody = {
  excludeDates?: [ string ](name='ExcludeDates', description='The points in time that are excluded when you schedule a CronHPA job. The points in time must be specified by using a cron expression.'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  scaleJobs?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the most recent CronHPA job was created. The time is displayed in UTC.', example='2020-06-24T02:11:30Z'),
      lastProbeTime?: string(name='LastProbeTime', description='The time when the most recent CronHPA job ran. The time is displayed in UTC.', example='2022-02-24T06:31:00Z'),
      message?: string(name='Message', description='The returned message.', example='"cron hpa job scale-jobs-0 executed successfully. current replicas:3, desired replicas:2."'),
      name?: string(name='Name', description='The name of the CronHPA job.', example='scale-job-1'),
      schedule?: string(name='Schedule', description='The cron expression that is used to configure the execution time of the CronHPA job.', example='0 18 * * * *'),
      state?: string(name='State', description='The status of the most recent CronHPA job.', example='Succeed'),
      targetSize?: int32(name='TargetSize', description='The number of instances that you expect to configure for the CronHPA job.', example='1'),
    }
  ](name='ScaleJobs', description='The CronHPA jobs.'),
  serviceName?: string(name='ServiceName', description='The service name.', example='foo'),
}

model DescribeServiceCronScalerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeServiceCronScalerResponseBody(name='body'),
}

/**
 * @summary Queries the Cron Horizontal Pod Autoscaler (CronHPA) configurations of a service.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeServiceCronScalerResponse
 */
async function describeServiceCronScalerWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceCronScalerResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceCronScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/cronscaler`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the Cron Horizontal Pod Autoscaler (CronHPA) configurations of a service.
 *
 * @return DescribeServiceCronScalerResponse
 */
async function describeServiceCronScaler(ClusterId: string, ServiceName: string): DescribeServiceCronScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceCronScalerWithOptions(ClusterId, ServiceName, headers, runtime);
}

model DescribeServiceDiagnosisResponseBody = {
  diagnosisList?: [ 
    {
      advices?: [ string ](name='Advices', description='The suggestions about how to handle the errors.'),
      causes?: [ string ](name='Causes', description='The causes of the errors.'),
      error?: string(name='Error', description='The error message.', example='Container worker0 failed to pull image.'),
    }
  ](name='DiagnosisList', description='The diagnostics list.'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model DescribeServiceDiagnosisResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeServiceDiagnosisResponseBody(name='body'),
}

/**
 * @summary Queries the diagnostics details of a service.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeServiceDiagnosisResponse
 */
async function describeServiceDiagnosisWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceDiagnosisResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceDiagnosis',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/diagnosis`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the diagnostics details of a service.
 *
 * @return DescribeServiceDiagnosisResponse
 */
async function describeServiceDiagnosis(ClusterId: string, ServiceName: string): DescribeServiceDiagnosisResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceDiagnosisWithOptions(ClusterId, ServiceName, headers, runtime);
}

model DescribeServiceEndpointsResponseBody = {
  accessToken?: string(name='AccessToken', description='The service token.', example='Nzc5N2FhN****TQ0YzBmYTIyN2MxZTUxN2NkYjg4MTJmMWQxZmY1****'),
  endpoints?: [ 
    {
      backendId?: string(name='BackendId'),
      endpointType?: string(name='EndpointType'),
      internetEndpoints?: [ string ](name='InternetEndpoints'),
      intranetEndpoints?: [ string ](name='IntranetEndpoints'),
      pathType?: string(name='PathType'),
      port?: int32(name='Port'),
    }
  ](name='Endpoints', description='The service endpoints.'),
  message?: string(name='Message', description='The returned message.', example='Execution successful.'),
  requestId?: string(name='RequestId', description='The request ID.', example='739998B5-FB39-12A3-8323-0FA340317298'),
}

model DescribeServiceEndpointsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeServiceEndpointsResponseBody(name='body'),
}

/**
 * @summary Obtains a list of service endpoints.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeServiceEndpointsResponse
 */
async function describeServiceEndpointsWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceEndpointsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceEndpoints',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/endpoints`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains a list of service endpoints.
 *
 * @return DescribeServiceEndpointsResponse
 */
async function describeServiceEndpoints(ClusterId: string, ServiceName: string): DescribeServiceEndpointsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceEndpointsWithOptions(ClusterId, ServiceName, headers, runtime);
}

model DescribeServiceEventRequest {
  endTime?: string(name='EndTime', description='The end of the time range to query. By default, the current point in time is the end of the time range to query.', example='2006-01-02 15:04:05'),
  eventType?: string(name='EventType', description='The event type. Valid values:

*   Normal
*   Warning', example='Normal'),
  instanceName?: string(name='InstanceName', description='The instance name. For more information about how to obtain the instance name, see [ListServiceInstances](https://help.aliyun.com/document_detail/412108.html).', example='echo-test-784xxxx85d-hhnd8'),
  pageNum?: string(name='PageNum', description='The page number. Default value: 1.', example='1'),
  pageSize?: string(name='PageSize', description='The number of entries per page. Default value: 100.', example='20'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. The time must be in UTC. The default value is seven days ago.', example='2006-01-02 15:04:05'),
}

model DescribeServiceEventResponseBody = {
  events?: [ 
    {
      message?: string(name='Message', description='The returned message. The message is formatted and returned in the JSON format.', example='{\\\\"versionId\\\\":1,\\\\"message\\\\":\\\\"Stage scale complete\\\\",\\\\"availableInstance\\\\":1,\\\\"unavailableInstance\\\\":0}'),
      reason?: string(name='Reason', description='The cause of the event. The information about the change in the service status is returned.', example='Updating'),
      time?: string(name='Time', description='The time when the event occurred. The time must be in UTC.', example='2022-04-09 06:30:00'),
      type?: string(name='Type', description='The event type. Valid values:

*   Normal
*   Warning', example='Normal'),
    }
  ](name='Events', description='The events.'),
  pageNum?: long(name='PageNum', description='The page number.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='3D491C94-6239-5318-B4B4-799D859***'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='29'),
  totalPageNum?: long(name='TotalPageNum', description='The total number of pages returned.', example='12'),
}

model DescribeServiceEventResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeServiceEventResponseBody(name='body'),
}

/**
 * @summary Queries information about recent service deployment events.
 *
 * @param request DescribeServiceEventRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeServiceEventResponse
 */
async function describeServiceEventWithOptions(ClusterId: string, ServiceName: string, request: DescribeServiceEventRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceEventResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceEvent',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/events`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries information about recent service deployment events.
 *
 * @param request DescribeServiceEventRequest
 * @return DescribeServiceEventResponse
 */
async function describeServiceEvent(ClusterId: string, ServiceName: string, request: DescribeServiceEventRequest): DescribeServiceEventResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceEventWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model DescribeServiceInstanceDiagnosisResponseBody = {
  diagnosis?: {
    advices?: [ string ](name='Advices', description='The solutions to the errors.'),
    causes?: [ string ](name='Causes', description='The causes of the errors.'),
    error?: string(name='Error', description='The error message.', example='Container worker0 failed to pull image.'),
  }(name='Diagnosis', description='The diagnostics information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82***'),
}

model DescribeServiceInstanceDiagnosisResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeServiceInstanceDiagnosisResponseBody(name='body'),
}

/**
 * @summary Queries the diagnostics details of an instance that runs Elastic Algorithm Service (EAS).
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeServiceInstanceDiagnosisResponse
 */
async function describeServiceInstanceDiagnosisWithOptions(ClusterId: string, ServiceName: string, InstanceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceInstanceDiagnosisResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceInstanceDiagnosis',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/instances/${OpenApiUtil.getEncodeParam(InstanceName)}/diagnosis`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the diagnostics details of an instance that runs Elastic Algorithm Service (EAS).
 *
 * @return DescribeServiceInstanceDiagnosisResponse
 */
async function describeServiceInstanceDiagnosis(ClusterId: string, ServiceName: string, InstanceName: string): DescribeServiceInstanceDiagnosisResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceInstanceDiagnosisWithOptions(ClusterId, ServiceName, InstanceName, headers, runtime);
}

model DescribeServiceLogRequest {
  containerName?: string(name='ContainerName', description='The name of the container that runs the service.', example='worker0'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The time must be in UTC.', example='2006-01-02 15:04:05'),
  instanceName?: string(name='InstanceName', description='The name of the instance that runs the service. For more information about how to query the instance name, see [ListServiceInstances](https://help.aliyun.com/document_detail/412108.html).', example='echo-da290ac8-7fckm'),
  ip?: string(name='Ip', description='The IP address of the instance whose logs you want to query. For more information about how to query the IP address of an instance, see [ListServiceInstances](https://help.aliyun.com/document_detail/412108.html).', example='10.0.0.1'),
  keyword?: string(name='Keyword', description='The keyword that you use to query the logs of the service.', example='key'),
  pageNum?: long(name='PageNum', description='The page number. Default value: 1.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Default value: 500.', example='500'),
  previous?: boolean(name='Previous', description='Specifies whether to query the logs that are generated before the instance last restarts. This parameter is available only if the instance restarts.

Valid values:

*   true

    <!-- -->

    <!-- -->

    <!-- -->

*   false

    <!-- -->

    <!-- -->

    <!-- -->', example='true'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. The time must be in Coordinated Universal Time (UTC).', example='2006-01-02 15:04:05'),
}

model DescribeServiceLogResponseBody = {
  logs?: [ string ](name='Logs', description='The returned logs.'),
  pageNum?: long(name='PageNum', description='The page number.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82********'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='1'),
  totalPageNum?: long(name='TotalPageNum', description='The total number of pages returned.', example='500'),
}

model DescribeServiceLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeServiceLogResponseBody(name='body'),
}

/**
 * @summary Queries the information about the logs of a service.
 *
 * @param request DescribeServiceLogRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeServiceLogResponse
 */
async function describeServiceLogWithOptions(ClusterId: string, ServiceName: string, request: DescribeServiceLogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceLogResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.containerName)) {
    query['ContainerName'] = request.containerName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.previous)) {
    query['Previous'] = request.previous;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceLog',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/logs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about the logs of a service.
 *
 * @param request DescribeServiceLogRequest
 * @return DescribeServiceLogResponse
 */
async function describeServiceLog(ClusterId: string, ServiceName: string, request: DescribeServiceLogRequest): DescribeServiceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceLogWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model DescribeServiceMirrorResponseBody = {
  ratio?: string(name='Ratio', description='The percentage of traffic that you want to mirror. Valid values: 0 to 100.', example='50'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  serviceName?: string(name='ServiceName', description='The service name.', example='foo'),
  target?: string(name='Target', description='The destination services to which you want to mirror traffic.', example='foo2,foo3'),
}

model DescribeServiceMirrorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeServiceMirrorResponseBody(name='body'),
}

/**
 * @summary Queries details about the traffic mirroring settings of a service.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeServiceMirrorResponse
 */
async function describeServiceMirrorWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceMirrorResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceMirror',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/mirror`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries details about the traffic mirroring settings of a service.
 *
 * @return DescribeServiceMirrorResponse
 */
async function describeServiceMirror(ClusterId: string, ServiceName: string): DescribeServiceMirrorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceMirrorWithOptions(ClusterId, ServiceName, headers, runtime);
}

model DescribeServiceSignedUrlRequest {
  expire?: long(name='Expire', description='The period of time for which the URL expires.', example='43200'),
  internal?: boolean(name='Internal', description='Specifies whether to use the VPC connection.', example='false'),
  type?: string(name='Type', description='The page type.

Valid values:

*   webview
*   monitor', example='webview'),
}

model DescribeServiceSignedUrlResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='40325405-579C-4D82****'),
  signedUrl?: string(name='SignedUrl', description='The service URL.', example='https://foo-115**.console.cn-hangzhou.eas.pai-ml.com?expire=1735202661&signature=ey*******'),
}

model DescribeServiceSignedUrlResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeServiceSignedUrlResponseBody(name='body'),
}

/**
 * @summary Obtains the logon-free URL of the service.
 *
 * @param request DescribeServiceSignedUrlRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeServiceSignedUrlResponse
 */
async function describeServiceSignedUrlWithOptions(ClusterId: string, ServiceName: string, request: DescribeServiceSignedUrlRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceSignedUrlResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.expire)) {
    query['Expire'] = request.expire;
  }
  if (!Util.isUnset(request.internal)) {
    query['Internal'] = request.internal;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceSignedUrl',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/signed_url`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the logon-free URL of the service.
 *
 * @param request DescribeServiceSignedUrlRequest
 * @return DescribeServiceSignedUrlResponse
 */
async function describeServiceSignedUrl(ClusterId: string, ServiceName: string, request: DescribeServiceSignedUrlRequest): DescribeServiceSignedUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceSignedUrlWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model DescribeSpotDiscountHistoryRequest {
  instanceType?: string(name='InstanceType', description='The type of the Elastic Algorithm Service (EAS) instance.

This parameter is required.', example='ecs.c6.4xlarge'),
  isProtect?: boolean(name='IsProtect', description='Specifies whether the preemptible instance has a protection period. During the 1-hour protection period of the preemptible instance, the preemptible instance will not be released.', example='false'),
}

model DescribeSpotDiscountHistoryResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82***'),
  spotDiscounts?: [ 
    {
      instanceType?: string(name='InstanceType', description='The type of the ECS instance.', example='ecs.c7.large'),
      spotDiscount?: string(name='SpotDiscount', description='The discount for the preemptible instance. For example, 0.1 represents a 90% discount.', example='0.1'),
      timestamp?: string(name='Timestamp', description='The time when the discount is available. The time must be in UTC.', example='2024-04-10T10:00:00Z'),
      zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-i'),
    }
  ](name='SpotDiscounts', description='The discount for the preemptible instance.'),
}

model DescribeSpotDiscountHistoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSpotDiscountHistoryResponseBody(name='body'),
}

/**
 * @summary Queries the historical prices of preemptible instances. For more information about preemptible instances, see Create and use preemptible instances.
 *
 * @param request DescribeSpotDiscountHistoryRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSpotDiscountHistoryResponse
 */
async function describeSpotDiscountHistoryWithOptions(request: DescribeSpotDiscountHistoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeSpotDiscountHistoryResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.isProtect)) {
    query['IsProtect'] = request.isProtect;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSpotDiscountHistory',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/public/spot_discount`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the historical prices of preemptible instances. For more information about preemptible instances, see Create and use preemptible instances.
 *
 * @param request DescribeSpotDiscountHistoryRequest
 * @return DescribeSpotDiscountHistoryResponse
 */
async function describeSpotDiscountHistory(request: DescribeSpotDiscountHistoryRequest): DescribeSpotDiscountHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeSpotDiscountHistoryWithOptions(request, headers, runtime);
}

model DescribeVirtualResourceResponseBody = {
  createTime?: string(name='CreateTime', description='The time when the virtual resource group was created.', example='2024-10-16T17:52:49Z'),
  disableSpotProtectionPeriod?: boolean(name='DisableSpotProtectionPeriod', description='Indicates whether the retention period of preemptible instances was disabled.', example='true'),
  features?: [ string ](name='Features'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='40325405-579C-4D82****'),
  resources?: [ 
    {
      instanceType?: string(name='InstanceType', description='The instance type of the public resource group.', example='ecs.s6-c1m2.xlarge'),
      priority?: int32(name='Priority', description='The priority of resource scheduling. A greater number specifies a higher priority.', example='3'),
      quotaId?: string(name='QuotaId', description='The instance type of the public resource group.', example='quota185lqxxxxxx'),
      region?: string(name='Region', description='The region where the resource resides.', example='cn-hangzhou'),
      resourceId?: string(name='ResourceId', description='The ID of the dedicated resource group.', example='eas-r-g55ieatgg3buxxxxxx'),
      spotPriceLimit?: float(name='SpotPriceLimit', description='The maximum price of preemptible instances in a public resource group.', example='10.05'),
    }
  ](name='Resources', description='The list of resources in the virtual resource group.'),
  serviceCount?: int32(name='ServiceCount', description='The number of deployed services.', example='1'),
  updateTime?: string(name='UpdateTime', description='The time when the virtual resource group was last updated.', example='2024-10-16T19:52:49Z'),
  virtualResourceId?: string(name='VirtualResourceId', description='The ID of the virtual resource group.', example='eas-vr-npovr28onap1xxxxxx'),
  virtualResourceName?: string(name='VirtualResourceName', description='The name of the virtual resource group.', example='MyVirtualResource'),
}

model DescribeVirtualResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVirtualResourceResponseBody(name='body'),
}

/**
 * @summary Views the details of a virtual resource group.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVirtualResourceResponse
 */
async function describeVirtualResourceWithOptions(ClusterId: string, VirtualResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeVirtualResourceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeVirtualResource',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/virtualresources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(VirtualResourceId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Views the details of a virtual resource group.
 *
 * @return DescribeVirtualResourceResponse
 */
async function describeVirtualResource(ClusterId: string, VirtualResourceId: string): DescribeVirtualResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeVirtualResourceWithOptions(ClusterId, VirtualResourceId, headers, runtime);
}

model DetachGatewayDomainRequest {
  customDomain?: {
    domain?: string(name='Domain', description='The custom domain name.

This parameter is required.', example='test.com'),
    type?: string(name='Type', description='The domain name type.

Valid value:

*   intranet: internal network.
*   internet: public network.

This parameter is required.', example='intranet'),
  }(name='CustomDomain', description='The custom domain name information.

This parameter is required.'),
}

model DetachGatewayDomainShrinkRequest {
  customDomainShrink?: string(name='CustomDomain', description='The custom domain name information.

This parameter is required.'),
}

model DetachGatewayDomainResponseBody = {
  gatewayId?: string(name='GatewayId', description='The ID of the private gateway. To obtain the private gateway ID, see the GatewayId parameter in the response parameters of the [ListGateway](https://apiworkbench.aliyun-inc.com/document/eas/2021-07-01/ListGateway?spm=openapi-amp.newDocPublishment.0.0.765e281fL2IcjJ\\\\&ampEnv=online) operation.', example='gw-1uhcqmsc7x22******'),
  message?: string(name='Message', description='The message that is returned.', example='Successfully delete custom endpoint for gateway gw-1uhcqmsc7x22******'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='40325405-579C-4D82****'),
}

model DetachGatewayDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DetachGatewayDomainResponseBody(name='body'),
}

/**
 * @summary Unbinds a custom domain name from a private gateway.
 *
 * @param tmpReq DetachGatewayDomainRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DetachGatewayDomainResponse
 */
async function detachGatewayDomainWithOptions(ClusterId: string, GatewayId: string, tmpReq: DetachGatewayDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DetachGatewayDomainResponse {
  Util.validateModel(tmpReq);
  var request = new DetachGatewayDomainShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.customDomain)) {
    request.customDomainShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.customDomain, 'CustomDomain', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.customDomainShrink)) {
    query['CustomDomain'] = request.customDomainShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachGatewayDomain',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GatewayId)}/domain/detach`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Unbinds a custom domain name from a private gateway.
 *
 * @param request DetachGatewayDomainRequest
 * @return DetachGatewayDomainResponse
 */
async function detachGatewayDomain(ClusterId: string, GatewayId: string, request: DetachGatewayDomainRequest): DetachGatewayDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return detachGatewayDomainWithOptions(ClusterId, GatewayId, request, headers, runtime);
}

model DevelopServiceRequest {
  exit?: string(name='Exit', description='Specifies whether to exit development mode. Valid values:

*   true: exits development mode.
*   false (default): enters development mode.', example='true'),
}

model DevelopServiceResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Success'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model DevelopServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DevelopServiceResponseBody(name='body'),
}

/**
 * @summary Switches a container service to development mode or exits development mode.
 *
 * @param request DevelopServiceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DevelopServiceResponse
 */
async function developServiceWithOptions(ClusterId: string, ServiceName: string, request: DevelopServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DevelopServiceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.exit)) {
    query['Exit'] = request.exit;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DevelopService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/develop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Switches a container service to development mode or exits development mode.
 *
 * @param request DevelopServiceRequest
 * @return DevelopServiceResponse
 */
async function developService(ClusterId: string, ServiceName: string, request: DevelopServiceRequest): DevelopServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return developServiceWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model ListAclPolicyRequest {
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC). For more information about how to obtain the VPC ID, see DescribeVpcs.', example='vpc-uf66uio7md****'),
}

model ListAclPolicyResponseBody = {
  gatewayId?: string(name='GatewayId', description='The private gateway ID.', example='gw-1uhcqmsc7x22******'),
  internetAclPolicyList?: [ 
    {
      aclPolicyList?: [ 
        {
          comment?: string(name='Comment', description='The comment on the IP CIDR block in the VPC that can access the private gateway over the Internet.', example='default'),
          entry?: string(name='Entry', description='The IP CIDR block in the VPC that can access the private gateway over the Internet.', example='10.23.XX.XX/32'),
        }
      ](name='AclPolicyList', description='The whitelisted IP CIDR blocks in the VPC that can access the private gateway over the Internet.'),
    }
  ](name='InternetAclPolicyList', description='The access control policies of the private gateway over the Internet.'),
  intranetVpcAclPolicyList?: [ 
    {
      aclPolicyList?: [ 
        {
          comment?: string(name='Comment', description='The comment on the IP CIDR block in the VPC that can access the private gateway over the internal network.', example='Test Entry'),
          entry?: string(name='Entry', description='The IP CIDR block in the VPC that can access the private gateway over the internal network.', example='192.168.XX.XX/24'),
        }
      ](name='AclPolicyList', description='The whitelisted IP CIDR blocks in the VPC that can access the private gateway over the internal network.'),
      vpcId?: string(name='VpcId', description='The VPC ID. For more information about how to obtain the VPC ID, see DescribeVpcs.', example='vpc-uf66uio7md****'),
    }
  ](name='IntranetVpcAclPolicyList', description='The access control policies of the private gateway over the internal network.'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model ListAclPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAclPolicyResponseBody(name='body'),
}

/**
 * @summary Queries access control lists (ACLs) created for a private gateway.
 *
 * @param request ListAclPolicyRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAclPolicyResponse
 */
async function listAclPolicyWithOptions(ClusterId: string, GatewayId: string, request: ListAclPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAclPolicyResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAclPolicy',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GatewayId)}/acl_policy`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries access control lists (ACLs) created for a private gateway.
 *
 * @param request ListAclPolicyRequest
 * @return ListAclPolicyResponse
 */
async function listAclPolicy(ClusterId: string, GatewayId: string, request: ListAclPolicyRequest): ListAclPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAclPolicyWithOptions(ClusterId, GatewayId, request, headers, runtime);
}

model ListBenchmarkTaskRequest {
  filter?: string(name='Filter', description='The keyword used to query required stress testing tasks. If this parameter is specified, the system returns stress testing tasks based on the names of the stress testing tasks in the matched Elastic Algorithm Service (EAS).', example='test_bench'),
  pageNumber?: string(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: string(name='PageSize', description='The number of entries per page. Default value: 100.', example='10'),
  serviceName?: string(name='ServiceName', description='The name of the EAS service that corresponds to the stress testing task. For more information about how to query the service name, see [ListServices](https://help.aliyun.com/document_detail/412109.html).', example='test_bench_srv'),
}

model ListBenchmarkTaskResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  tasks?: [ 
    {
      availableAgent?: long(name='AvailableAgent', description='The number of instances that are available for stress testing.', example='2'),
      createTime?: string(name='CreateTime', description='The time when the stress testing task was created.', example='2020-12-04T02:43:15Z'),
      message?: string(name='Message', description='The returned message.', example='Benchmark task [benchmark-larec-test-1076] is Running'),
      region?: string(name='Region', description='The region ID of the stress testing task.', example='cn-shanghai'),
      serviceName?: string(name='ServiceName', description='The name of the service on which you want to perform a stress testing.', example='test_quota'),
      status?: string(name='Status', description='The state of the stress testing task.

Valid values:

*   Creating

    <!-- -->

    <!-- -->

    <!-- -->

*   Starting

    <!-- -->

    <!-- -->

    <!-- -->

*   DeleteFailed

    <!-- -->

    <!-- -->

    <!-- -->

*   Running

    <!-- -->

    <!-- -->

    <!-- -->

*   Stopping

    <!-- -->

    <!-- -->

    <!-- -->

*   Error

    <!-- -->

    <!-- -->

    <!-- -->

*   Updating

    <!-- -->

    <!-- -->

    <!-- -->

*   Deleting

    <!-- -->

    <!-- -->

    <!-- -->

*   CreateFailed

    <!-- -->

    <!-- -->

    <!-- -->', example='Running'),
      taskId?: string(name='TaskId', description='The ID of the stress testing task.', example='eas-b-gv4y86uvgt****i'),
      taskName?: string(name='TaskName', description='The name of the stress testing task.', example='benchmark-larec-test-1076'),
      updateTime?: string(name='UpdateTime', description='The time when the stress testing task was updated.', example='2020-06-24T03:11:30Z'),
    }
  ](name='Tasks', description='The stress testing tasks.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model ListBenchmarkTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListBenchmarkTaskResponseBody(name='body'),
}

/**
 * @summary Queries a list of stress testing tasks that are created by the current user.
 *
 * @param request ListBenchmarkTaskRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListBenchmarkTaskResponse
 */
async function listBenchmarkTaskWithOptions(request: ListBenchmarkTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListBenchmarkTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of stress testing tasks that are created by the current user.
 *
 * @param request ListBenchmarkTaskRequest
 * @return ListBenchmarkTaskResponse
 */
async function listBenchmarkTask(request: ListBenchmarkTaskRequest): ListBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listBenchmarkTaskWithOptions(request, headers, runtime);
}

model ListGatewayRequest {
  gatewayId?: string(name='GatewayId', description='The private gateway ID. To obtain the private gateway ID, see the private_gateway_id parameter in the response parameters of the ListResources operation.', example='gw-1uhcqmsc7x22******'),
  gatewayName?: string(name='GatewayName', description='The private gateway alias.', example='mygateway1'),
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 100.', example='100'),
  resourceName?: string(name='ResourceName', description='The ID of the resource group. To obtain a resource group ID, see the ResourceId field in the response of the [ListResources](https://help.aliyun.com/document_detail/412133.html) operation.', example='eas-r-4gt8twzwllfo******'),
}

model ListGatewayResponseBody = {
  gateways?: [ 
    {
      chargeType?: string(name='ChargeType', description='The billing method. Valid values:

*   PrePaid: subscription.
*   PostPaid: pay-as-you-go.', example='PostPaid'),
      createTime?: string(name='CreateTime', description='The time when the private gateway was created. The time is displayed in UTC.', example='2020-05-19T14:19:42Z'),
      gatewayId?: string(name='GatewayId', description='The private gateway ID.', example='gw-1uhcqmsc7x22******'),
      gatewayName?: string(name='GatewayName', description='The private gateway alias.', example='mygateway1'),
      instanceType?: string(name='InstanceType', description='The type of instances used for the private gateway.', example='2c4g'),
      internetDomain?: string(name='InternetDomain', description='The public endpoint.', example='gw-1uhcqmsc7x22******-1801786532******.cn-wulanchabu.pai-eas.aliyuncs.com'),
      internetEnabled?: boolean(name='InternetEnabled', description='Indicates whether Internet access is enabled.', example='true'),
      intranetDomain?: string(name='IntranetDomain', description='The internal endpoint.', example='gw-1uhcqmsc7x22******-1801786532******-vpc.cn-wulanchabu.pai-eas.aliyuncs.com'),
      isDefault?: boolean(name='IsDefault', description='Indicates whether it is the default private gateway.', example='true'),
      replicas?: int32(name='Replicas', description='The number of nodes in the private gateway.', example='2'),
      SSLRedirectionEnabled?: boolean(name='SSLRedirectionEnabled', description='Specifies whether to enable HTTP to HTTPS redirection.', example='true'),
      status?: string(name='Status', description='The state of the private gateway.

Valid values:

*   Creating
*   Stopped
*   Failed
*   Running
*   Deleted
*   Deleting
*   Waiting', example='Running'),
      updateTime?: string(name='UpdateTime', description='The time when the private gateway was updated. The time is displayed in UTC.', example='2021-02-24T11:52:17Z'),
    }
  ](name='Gateways', description='The private gateways.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='100'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  totalCount?: long(name='TotalCount', description='The total number of private gateways returned.', example='5'),
}

model ListGatewayResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListGatewayResponseBody(name='body'),
}

/**
 * @summary Queries a list of private gateways.
 *
 * @param request ListGatewayRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListGatewayResponse
 */
async function listGatewayWithOptions(request: ListGatewayRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListGatewayResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.gatewayId)) {
    query['GatewayId'] = request.gatewayId;
  }
  if (!Util.isUnset(request.gatewayName)) {
    query['GatewayName'] = request.gatewayName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGateway',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of private gateways.
 *
 * @param request ListGatewayRequest
 * @return ListGatewayResponse
 */
async function listGateway(request: ListGatewayRequest): ListGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGatewayWithOptions(request, headers, runtime);
}

model ListGatewayDomainsResponseBody = {
  customDomains?: [ 
    {
      certificateEndDate?: string(name='CertificateEndDate'),
      certificateId?: string(name='CertificateId', description='The ID of the SSL certificate bound to the domain name. Obtain the certificate ID after you upload or purchase a certificate in the [Certificate Management Service](https://yundunnext.console.aliyun.com/?spm=5176.2020520163.console-base_help.2.4b3baJixaJixOc\\\\&p=cas) console.', example='1473**25'),
      certificateName?: string(name='CertificateName'),
      certificateStartDate?: string(name='CertificateStartDate'),
      certificateStatus?: string(name='CertificateStatus'),
      createTime?: string(name='CreateTime'),
      domain?: string(name='Domain', description='The custom domain name.', example='test.com'),
      type?: string(name='Type', description='The domain name type.

Valid value:

*   intranet: internal network.
*   internet: public network.', example='intranet'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='CustomDomains', description='The custom domain names.'),
  message?: string(name='Message', description='The message that is returned.', example='Successfully get custom domains'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='40325405-579C-4D82****'),
}

model ListGatewayDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListGatewayDomainsResponseBody(name='body'),
}

/**
 * @summary Queries a list of custom domain names of a private gateway.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListGatewayDomainsResponse
 */
async function listGatewayDomainsWithOptions(ClusterId: string, GatewayId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListGatewayDomainsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListGatewayDomains',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GatewayId)}/domains`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of custom domain names of a private gateway.
 *
 * @return ListGatewayDomainsResponse
 */
async function listGatewayDomains(ClusterId: string, GatewayId: string): ListGatewayDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGatewayDomainsWithOptions(ClusterId, GatewayId, headers, runtime);
}

model ListGatewayIntranetLinkedVpcResponseBody = {
  gatewayId?: string(name='GatewayId', description='The private gateway ID.', example='gw-1uhcqmsc7x22******'),
  intranetLinkedVpcList?: [ 
    {
      accountId?: string(name='AccountId'),
      authoritativeDnsEnabled?: boolean(name='AuthoritativeDnsEnabled'),
      ip?: string(name='Ip', description='The IP address.', example='192.168.10.11'),
      securityGroupId?: string(name='SecurityGroupId', description='The security group ID.', example='sg-2ze4pgstgszvgq******'),
      status?: string(name='Status', description='The state of the private gateway.

Valid values:

*   Creating

    <!-- -->

    :

    <!-- -->

    The private gateway is being created.

    <!-- -->

*   Running

    <!-- -->

    :

    <!-- -->

    The private gateway is running.

    <!-- -->', example='Running'),
      vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.', example='vsw-8vb2qjoiio6m9pg******'),
      vpcId?: string(name='VpcId', description='The virtual private cloud (VPC) ID.', example='vpc-2zetuli9ws0qgjd******'),
    }
  ](name='IntranetLinkedVpcList', description='The internal endpoints.'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model ListGatewayIntranetLinkedVpcResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListGatewayIntranetLinkedVpcResponseBody(name='body'),
}

/**
 * @summary Queries a list of the internal endpoints of a private gateway.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListGatewayIntranetLinkedVpcResponse
 */
async function listGatewayIntranetLinkedVpcWithOptions(ClusterId: string, GatewayId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListGatewayIntranetLinkedVpcResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListGatewayIntranetLinkedVpc',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GatewayId)}/intranet_endpoint_linked_vpc`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of the internal endpoints of a private gateway.
 *
 * @return ListGatewayIntranetLinkedVpcResponse
 */
async function listGatewayIntranetLinkedVpc(ClusterId: string, GatewayId: string): ListGatewayIntranetLinkedVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGatewayIntranetLinkedVpcWithOptions(ClusterId, GatewayId, headers, runtime);
}

model ListGatewayIntranetLinkedVpcPeerRequest {
  vpcId?: string(name='VpcId', description='The ID of the associated VPC. To obtain the VPC ID, see [ListGatewayIntranetLinkedVpc](https://help.aliyun.com/document_detail/2621223.html).

*   If you specify a VPC ID, only VPC peers corresponding to the ID are queried.
*   Otherwise, all VPC peers are queried.', example='vpc-2zetuli9ws0qgjd******'),
}

model ListGatewayIntranetLinkedVpcPeerResponseBody = {
  gatewayId?: string(name='GatewayId', description='The ID of the private gateway.', example='gw-1uhcqmsc7x22******'),
  peerVpcList?: [ 
    {
      peerVpcs?: [ 
        {
          region?: string(name='Region', description='The region where the VPC peer resides.', example='cn-shanghai'),
          status?: string(name='Status'),
          vpcId?: string(name='VpcId', description='The ID of the VPC peer.', example='vpc-uf66uio7md****'),
        }
      ](name='PeerVpcs', description='The IDs of the VPC peers.'),
      vpcId?: string(name='VpcId', description='The VPC ID.', example='vpc-2zetuli9ws0qgjd******'),
    }
  ](name='PeerVpcList', description='The VPC peers.'),
  requestId?: string(name='requestId', description='The ID of the request.', example='40325405-579C-4D82****'),
}

model ListGatewayIntranetLinkedVpcPeerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListGatewayIntranetLinkedVpcPeerResponseBody(name='body'),
}

/**
 * @summary Obtains a list of all VPC peering connections on internal endpoint of a gateway.
 *
 * @param request ListGatewayIntranetLinkedVpcPeerRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListGatewayIntranetLinkedVpcPeerResponse
 */
async function listGatewayIntranetLinkedVpcPeerWithOptions(ClusterId: string, GatewayId: string, request: ListGatewayIntranetLinkedVpcPeerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListGatewayIntranetLinkedVpcPeerResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGatewayIntranetLinkedVpcPeer',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GatewayId)}/intranet_endpoint_linked_vpc_peer`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains a list of all VPC peering connections on internal endpoint of a gateway.
 *
 * @param request ListGatewayIntranetLinkedVpcPeerRequest
 * @return ListGatewayIntranetLinkedVpcPeerResponse
 */
async function listGatewayIntranetLinkedVpcPeer(ClusterId: string, GatewayId: string, request: ListGatewayIntranetLinkedVpcPeerRequest): ListGatewayIntranetLinkedVpcPeerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGatewayIntranetLinkedVpcPeerWithOptions(ClusterId, GatewayId, request, headers, runtime);
}

model ListGatewayIntranetSupportedZoneResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  zones?: [ string ](name='Zones', description='The zones that are supported by the region.'),
}

model ListGatewayIntranetSupportedZoneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListGatewayIntranetSupportedZoneResponseBody(name='body'),
}

/**
 * @summary Obtains the zones supported by a gateway within an intranet.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListGatewayIntranetSupportedZoneResponse
 */
async function listGatewayIntranetSupportedZoneWithOptions(GatewayId: string, ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListGatewayIntranetSupportedZoneResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListGatewayIntranetSupportedZone',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GatewayId)}/intranet_supported_zone`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the zones supported by a gateway within an intranet.
 *
 * @return ListGatewayIntranetSupportedZoneResponse
 */
async function listGatewayIntranetSupportedZone(GatewayId: string, ClusterId: string): ListGatewayIntranetSupportedZoneResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGatewayIntranetSupportedZoneWithOptions(GatewayId, ClusterId, headers, runtime);
}

model ListGroupsRequest {
  filter?: string(name='Filter', description='The name of the filter that is used to filter out unwanted service groups. Fuzzy match is supported.', example='foo'),
  pageNumber?: string(name='PageNumber', description='The page number. Default value: 1.', example='1'),
  pageSize?: string(name='PageSize', description='The number of entries per page. Default value: 100.', example='20'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='123***'),
}

model ListGroupsResponseBody = {
  groups?: [
    Group
  ](name='Groups', description='The service groups.'),
  pageNumber?: long(name='PageNumber', description='The page number.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='5'),
}

model ListGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListGroupsResponseBody(name='body'),
}

/**
 * @summary Queries created service groups.
 *
 * @param request ListGroupsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListGroupsResponse
 */
async function listGroupsWithOptions(request: ListGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListGroupsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGroups',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/groups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries created service groups.
 *
 * @param request ListGroupsRequest
 * @return ListGroupsResponse
 */
async function listGroups(request: ListGroupsRequest): ListGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGroupsWithOptions(request, headers, runtime);
}

model ListResourceInstanceWorkerRequest {
  order?: string(name='Order'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 100.', example='20'),
  ready?: boolean(name='Ready'),
  serviceName?: string(name='ServiceName'),
  sort?: string(name='Sort'),
  status?: string(name='Status'),
  workerName?: string(name='WorkerName', description='The worker name.', example='test-fd95xxxxx-xxxxxx'),
}

model ListResourceInstanceWorkerResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  pods?: [
    ResourceInstanceWorker
  ](name='Pods', description='The workers.'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model ListResourceInstanceWorkerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListResourceInstanceWorkerResponseBody(name='body'),
}

/**
 * @summary Queries a list of workers in a resource group.
 *
 * @param request ListResourceInstanceWorkerRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListResourceInstanceWorkerResponse
 */
async function listResourceInstanceWorkerWithOptions(ClusterId: string, ResourceId: string, InstanceName: string, request: ListResourceInstanceWorkerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListResourceInstanceWorkerResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.ready)) {
    query['Ready'] = request.ready;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.sort)) {
    query['Sort'] = request.sort;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.workerName)) {
    query['WorkerName'] = request.workerName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceInstanceWorker',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/instance/${OpenApiUtil.getEncodeParam(InstanceName)}/workers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of workers in a resource group.
 *
 * @param request ListResourceInstanceWorkerRequest
 * @return ListResourceInstanceWorkerResponse
 */
async function listResourceInstanceWorker(ClusterId: string, ResourceId: string, InstanceName: string, request: ListResourceInstanceWorkerRequest): ListResourceInstanceWorkerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourceInstanceWorkerWithOptions(ClusterId, ResourceId, InstanceName, request, headers, runtime);
}

model ListResourceInstancesRequest {
  chargeType?: string(name='ChargeType', description='The billing method of the instance. Valid values:

*   PrePaid: subscription.
*   PostPaid: pay-as-you-go.', example='PrePaid'),
  filter?: string(name='Filter', description='The keyword used to query instances. Instances can be queried by instance ID or instance IP address.', example='10.224.xx.xx'),
  instanceIP?: string(name='InstanceIP', description='The IP address of the instance.', example='10.224.xx.xx'),
  instanceId?: string(name='InstanceId', description='The instance ID. For more information about how to query the instance ID, see [ListResourceInstances](https://help.aliyun.com/document_detail/412129.html).', example='i-bp1jd6x3uotsv****'),
  instanceName?: string(name='InstanceName', description='The instance name.', example='e-xxxx***'),
  instanceStatus?: string(name='InstanceStatus', description='The instance state.

Valid values:

*   Ready-SchedulingDisabled

    <!-- -->

    :

    <!-- -->

    The instance is available but unschedulable

    <!-- -->

    .

*   Ready

    <!-- -->

    : The instance

    <!-- -->

    is running

    <!-- -->

    .

*   NotReady

    <!-- -->

    : The instance is unready.

    <!-- -->

    <!-- -->

*   Stopped

    <!-- -->

    : The instance has stopped.

    <!-- -->

    <!-- -->

*   NotReady-SchedulingDisabled

    <!-- -->

    :

    <!-- -->

    The instance is unavailable and unschedulable

    <!-- -->

    .

*   Attaching

    <!-- -->

    : The instance

    <!-- -->

    is starting

    <!-- -->

    .

*   Deleting

    <!-- -->

    : The instance is being deleted.

    <!-- -->

    <!-- -->

*   CreateFailed: The instance failed to be created.

    <!-- -->

    <!-- -->

    <!-- -->', example='Ready'),
  label?: map[string]string(name='Label', description='The tag.'),
  order?: string(name='Order', description='The sorting order.

Valid values:

*   asc: The instances are sorted in ascending order.

    <!-- -->

    <!-- -->

    <!-- -->

*   desc

    <!-- -->

    : The instances are sorted in descending order.

    <!-- -->

    <!-- -->', example='desc'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 100.', example='20'),
  sort?: string(name='Sort', description='The field that you use to sort the query results.

Valid values:

*   CreateTime

    <!-- -->

    : The instances are sorted based on the time when the instances were created.

    <!-- -->

    <!-- -->

*   MemoryUsed

    <!-- -->

    :

    <!-- -->

    The instances are sorted based on the memory usage of the instances

    <!-- -->

    .

*   GpuUsed

    <!-- -->

    : The instances are sorted based on the

    <!-- -->

    GPU usage of the instances.

    <!-- -->

*   ExpireTime: The instances are sorted based on the time when the instances expired.

    <!-- -->

    <!-- -->

    <!-- -->

*   CpuUsed

    <!-- -->

    :

    <!-- -->

    The instances are sorted based on the CPU utilization of the instances.

    <!-- -->', example='CreateTime'),
}

model ListResourceInstancesShrinkRequest {
  chargeType?: string(name='ChargeType', description='The billing method of the instance. Valid values:

*   PrePaid: subscription.
*   PostPaid: pay-as-you-go.', example='PrePaid'),
  filter?: string(name='Filter', description='The keyword used to query instances. Instances can be queried by instance ID or instance IP address.', example='10.224.xx.xx'),
  instanceIP?: string(name='InstanceIP', description='The IP address of the instance.', example='10.224.xx.xx'),
  instanceId?: string(name='InstanceId', description='The instance ID. For more information about how to query the instance ID, see [ListResourceInstances](https://help.aliyun.com/document_detail/412129.html).', example='i-bp1jd6x3uotsv****'),
  instanceName?: string(name='InstanceName', description='The instance name.', example='e-xxxx***'),
  instanceStatus?: string(name='InstanceStatus', description='The instance state.

Valid values:

*   Ready-SchedulingDisabled

    <!-- -->

    :

    <!-- -->

    The instance is available but unschedulable

    <!-- -->

    .

*   Ready

    <!-- -->

    : The instance

    <!-- -->

    is running

    <!-- -->

    .

*   NotReady

    <!-- -->

    : The instance is unready.

    <!-- -->

    <!-- -->

*   Stopped

    <!-- -->

    : The instance has stopped.

    <!-- -->

    <!-- -->

*   NotReady-SchedulingDisabled

    <!-- -->

    :

    <!-- -->

    The instance is unavailable and unschedulable

    <!-- -->

    .

*   Attaching

    <!-- -->

    : The instance

    <!-- -->

    is starting

    <!-- -->

    .

*   Deleting

    <!-- -->

    : The instance is being deleted.

    <!-- -->

    <!-- -->

*   CreateFailed: The instance failed to be created.

    <!-- -->

    <!-- -->

    <!-- -->', example='Ready'),
  labelShrink?: string(name='Label', description='The tag.'),
  order?: string(name='Order', description='The sorting order.

Valid values:

*   asc: The instances are sorted in ascending order.

    <!-- -->

    <!-- -->

    <!-- -->

*   desc

    <!-- -->

    : The instances are sorted in descending order.

    <!-- -->

    <!-- -->', example='desc'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 100.', example='20'),
  sort?: string(name='Sort', description='The field that you use to sort the query results.

Valid values:

*   CreateTime

    <!-- -->

    : The instances are sorted based on the time when the instances were created.

    <!-- -->

    <!-- -->

*   MemoryUsed

    <!-- -->

    :

    <!-- -->

    The instances are sorted based on the memory usage of the instances

    <!-- -->

    .

*   GpuUsed

    <!-- -->

    : The instances are sorted based on the

    <!-- -->

    GPU usage of the instances.

    <!-- -->

*   ExpireTime: The instances are sorted based on the time when the instances expired.

    <!-- -->

    <!-- -->

    <!-- -->

*   CpuUsed

    <!-- -->

    :

    <!-- -->

    The instances are sorted based on the CPU utilization of the instances.

    <!-- -->', example='CreateTime'),
}

model ListResourceInstancesResponseBody = {
  instances?: [
    ResourceInstance
  ](name='Instances', description='The instances.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model ListResourceInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListResourceInstancesResponseBody(name='body'),
}

/**
 * @summary Queries a list of instances in a dedicated resource group.
 *
 * @param tmpReq ListResourceInstancesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListResourceInstancesResponse
 */
async function listResourceInstancesWithOptions(ClusterId: string, ResourceId: string, tmpReq: ListResourceInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListResourceInstancesResponse {
  Util.validateModel(tmpReq);
  var request = new ListResourceInstancesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.label)) {
    request.labelShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.label, 'Label', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.instanceIP)) {
    query['InstanceIP'] = request.instanceIP;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.instanceStatus)) {
    query['InstanceStatus'] = request.instanceStatus;
  }
  if (!Util.isUnset(request.labelShrink)) {
    query['Label'] = request.labelShrink;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sort)) {
    query['Sort'] = request.sort;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceInstances',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of instances in a dedicated resource group.
 *
 * @param request ListResourceInstancesRequest
 * @return ListResourceInstancesResponse
 */
async function listResourceInstances(ClusterId: string, ResourceId: string, request: ListResourceInstancesRequest): ListResourceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourceInstancesWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

model ListResourceServicesRequest {
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 100.', example='20'),
}

model ListResourceServicesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  services?: [
    Service
  ](name='Services', description='The services.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model ListResourceServicesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListResourceServicesResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI ListResourceServices is deprecated
 *
 * @summary Queries a list of services that are deployed in the dedicated resource group.
 *
 * @param request ListResourceServicesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListResourceServicesResponse
 */
// Deprecated
async function listResourceServicesWithOptions(ClusterId: string, ResourceId: string, request: ListResourceServicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListResourceServicesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceServices',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/services`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @deprecated OpenAPI ListResourceServices is deprecated
 *
 * @summary Queries a list of services that are deployed in the dedicated resource group.
 *
 * @param request ListResourceServicesRequest
 * @return ListResourceServicesResponse
 */
// Deprecated
async function listResourceServices(ClusterId: string, ResourceId: string, request: ListResourceServicesRequest): ListResourceServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourceServicesWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

model ListResourcesRequest {
  order?: string(name='Order', description='The sorting order. Valid values:

*   Desc
*   Asc', example='Desc'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 100.', example='20'),
  resourceId?: string(name='ResourceId', description='The ID of the resource group. You can call the [CreateResource](https://help.aliyun.com/document_detail/412111.html) operation to query the ID of the resource group.', example='eas-r-h7lcw24dyqztwxxxxxx'),
  resourceName?: string(name='ResourceName', description='The name of the resource group. You can call the [CreateResource](https://help.aliyun.com/document_detail/412111.html) operation to query the name of the resource group.', example='MyResource'),
  resourceStatus?: string(name='ResourceStatus', description='The resource group status.', example='ResourceReady'),
  resourceType?: string(name='ResourceType', description='The type of the resource group. Valid values:

*   Dedicated: the dedicated resource group.
*   SelfManaged: the self-managed resource group.', example='Dedicated'),
  sort?: string(name='Sort', description='The condition by which the results are sorted. By default, the query results are sorted by the timestamp type in descending order.

Valid values:

*   PrePaidInstanceCount
*   CpuCount
*   Memory
*   CreateTime
*   PostPaidInstanceCount
*   MemoryUsed
*   GpuCount
*   GpuUsed
*   CpuUsed
*   ServiceCount', example='CreateTime'),
}

model ListResourcesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  resources?: [
    Resource
  ](name='Resources', description='The resource groups.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model ListResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListResourcesResponseBody(name='body'),
}

/**
 * @summary Queries a list of dedicated resource groups for the current user.
 *
 * @param request ListResourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListResourcesResponse
 */
async function listResourcesWithOptions(request: ListResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.resourceStatus)) {
    query['ResourceStatus'] = request.resourceStatus;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.sort)) {
    query['Sort'] = request.sort;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResources',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of dedicated resource groups for the current user.
 *
 * @param request ListResourcesRequest
 * @return ListResourcesResponse
 */
async function listResources(request: ListResourcesRequest): ListResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourcesWithOptions(request, headers, runtime);
}

model ListServiceContainersResponseBody = {
  containers?: [
    ContainerInfo
  ](name='Containers', description='The containers of the service.'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  serviceName?: string(name='ServiceName', description='The service name.', example='foo'),
}

model ListServiceContainersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListServiceContainersResponseBody(name='body'),
}

/**
 * @summary Queries the containers of a service.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListServiceContainersResponse
 */
async function listServiceContainersWithOptions(ClusterId: string, ServiceName: string, InstanceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListServiceContainersResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListServiceContainers',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/instances/${OpenApiUtil.getEncodeParam(InstanceName)}/containers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the containers of a service.
 *
 * @return ListServiceContainersResponse
 */
async function listServiceContainers(ClusterId: string, ServiceName: string, InstanceName: string): ListServiceContainersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServiceContainersWithOptions(ClusterId, ServiceName, InstanceName, headers, runtime);
}

model ListServiceInstancesRequest {
  filter?: string(name='Filter', description='The keyword used to query instances. Instances can be queried based on instance name, instance IP address, IP address of the server where the instance resides, and instance type.', example='10.118.xx.xx'),
  hostIP?: string(name='HostIP', description='The IP address of the server where the instance resides.', example='10.224.xx.xx'),
  instanceIP?: string(name='InstanceIP', description='The IP address of the instance.', example='10.224.xx.xx'),
  instanceName?: string(name='InstanceName', description='The instance name.', example='foo-bdc5xxxx-8l7rk'),
  instanceStatus?: string(name='InstanceStatus', description='The instance state.', example='Running'),
  instanceType?: string(name='InstanceType', description='The instance type.', example='ecs.c7.large'),
  isSpot?: boolean(name='IsSpot', description='Specifies whether the instance is a preemptible instance.', example='false'),
  memberType?: string(name='MemberType'),
  order?: string(name='Order', description='The sorting order.

Valid values:

*   asc

    <!-- -->

    :

    <!-- -->

    <!-- -->

    The instances are sorted in ascending order.

*   desc

    <!-- -->

    :

    <!-- -->

    <!-- -->

    The instances are sorted in descending order.', example='desc'),
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 100.', example='20'),
  resourceType?: string(name='ResourceType', description='The type of the resource group to which the instance belongs.

Valid values:

*   PublicResource

    <!-- -->

    <!-- -->

    <!-- -->

*   DedicatedResource

    <!-- -->

    <!-- -->

    <!-- -->', example='PublicResource'),
  role?: string(name='Role', description='The service role.

Valid values:

*   DataSet

    <!-- -->

    :

    <!-- -->

    dataset service

    <!-- -->

    .

*   SDProxy

    <!-- -->

    :

    <!-- -->

    Stable-Diffusion proxy service

    <!-- -->

    .

*   Standard

    <!-- -->

    :

    <!-- -->

    standard service

    <!-- -->

    .

*   Queue

    <!-- -->

    :

    <!-- -->

    queue service

    <!-- -->

    .', example='Queue'),
  sort?: string(name='Sort', description='The field that you use to sort the query results.

*   Set the value to StartTime.

    <!-- -->

    <!-- -->

    The value specifies that the query results are sorted based on the time when the instances were created

    <!-- -->

    .', example='StartTime'),
}

model ListServiceInstancesResponseBody = {
  instances?: [
    Instance
  ](name='Instances', description='The instances.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model ListServiceInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListServiceInstancesResponseBody(name='body'),
}

/**
 * @summary Queries instances of a service.
 *
 * @param request ListServiceInstancesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListServiceInstancesResponse
 */
async function listServiceInstancesWithOptions(ClusterId: string, ServiceName: string, request: ListServiceInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListServiceInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.hostIP)) {
    query['HostIP'] = request.hostIP;
  }
  if (!Util.isUnset(request.instanceIP)) {
    query['InstanceIP'] = request.instanceIP;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.instanceStatus)) {
    query['InstanceStatus'] = request.instanceStatus;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.isSpot)) {
    query['IsSpot'] = request.isSpot;
  }
  if (!Util.isUnset(request.memberType)) {
    query['MemberType'] = request.memberType;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.role)) {
    query['Role'] = request.role;
  }
  if (!Util.isUnset(request.sort)) {
    query['Sort'] = request.sort;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServiceInstances',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries instances of a service.
 *
 * @param request ListServiceInstancesRequest
 * @return ListServiceInstancesResponse
 */
async function listServiceInstances(ClusterId: string, ServiceName: string, request: ListServiceInstancesRequest): ListServiceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServiceInstancesWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model ListServiceVersionsRequest {
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 100.', example='10'),
}

model ListServiceVersionsResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='E089D584-B6F4-50C4-9902-DA2295B7****'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='166'),
  versions?: [ 
    {
      buildTime?: string(name='BuildTime', description='The time when the service version was created. The time is displayed in UTC.', example='2022-08-29T22:02:14Z'),
      imageAvailable?: string(name='ImageAvailable', description='Indicates whether the image is available. Valid values:

*   true: The image is available.
*   false: The image is unavailable.
*   unknown: The availability of the image is unknown.', example='true'),
      imageId?: int32(name='ImageId', description='The image ID.', example='4'),
      message?: string(name='Message', description='The returned message.', example='Service is Running'),
      serviceConfig?: string(name='ServiceConfig', description='The service deployment configurations. This parameter is returned only if the service is deployed by using a custom image.', example='{
    "metadata": {
        "cpu": 1,
        "instance": 1,
        "memory": 1024
    },
    "name": "echo"
}'),
      serviceRunnable?: string(name='ServiceRunnable', description='Indicates whether Elastic Algorithm service (EAS) is activated. Valid values:

*   true: EAS is activated.
*   false: EAS is not activated.
*   unknown: The activation of EAS is unknown.', example='true'),
    }
  ](name='Versions', description='The historical versions of the service.'),
}

model ListServiceVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListServiceVersionsResponseBody(name='body'),
}

/**
 * @summary Queries the information about the historical versions of a service.
 *
 * @param request ListServiceVersionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListServiceVersionsResponse
 */
async function listServiceVersionsWithOptions(ClusterId: string, ServiceName: string, request: ListServiceVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListServiceVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServiceVersions',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about the historical versions of a service.
 *
 * @param request ListServiceVersionsRequest
 * @return ListServiceVersionsResponse
 */
async function listServiceVersions(ClusterId: string, ServiceName: string, request: ListServiceVersionsRequest): ListServiceVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServiceVersionsWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model ListServicesRequest {
  autoscalerEnabled?: boolean(name='AutoscalerEnabled'),
  cronscalerEnabled?: boolean(name='CronscalerEnabled'),
  filter?: string(name='Filter', description='The field that is used for fuzzy matches. The system performs fuzzy matches only by service name.', example='foo'),
  gateway?: string(name='Gateway', description='The private gateway ID.', example='gw-1uhcqmsc7x22******'),
  groupName?: string(name='GroupName', description='The name of the service group. For more information about how to query the name of a service group, see [ListServices](https://help.aliyun.com/document_detail/412109.html).', example='foo'),
  includeNoWorkspace?: boolean(name='IncludeNoWorkspace'),
  label?: map[string]string(name='Label', description='The tag that is used to filter services.'),
  order?: string(name='Order', description='The sorting order. Valid values:

*   desc (default): The query results are sorted in descending order.
*   asc: The query results are sorted in ascending order.', example='asc'),
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 100.', example='100'),
  parentServiceUid?: string(name='ParentServiceUid', description='The ID of the primary service that corresponds to the Band member service.', example='eas-m-ijafy3c8cxxxx'),
  quotaId?: string(name='QuotaId', description='The quota ID.', example='quota12345'),
  resourceAliasName?: string(name='ResourceAliasName'),
  resourceBurstable?: boolean(name='ResourceBurstable'),
  resourceId?: string(name='ResourceId'),
  resourceName?: string(name='ResourceName', description='The name or ID of the resource group to which the service belongs.', example='eas-r-hd0qwy8cxxxx', deprecated=true),
  resourceType?: string(name='ResourceType'),
  role?: string(name='Role', description='The server role.

Valid values:

*   DataLoader
*   FrontEnd
*   DataSet
*   SDProxy
*   LLMSscheduler
*   ScalableJob
*   LLMGateway
*   Job
*   Queue', example='LLMGateway'),
  serviceName?: string(name='ServiceName', description='The service name.', example='echo_test'),
  serviceStatus?: string(name='ServiceStatus', description='The service state.

Valid values:

*   Creating

    <!-- -->

    <!-- -->

    <!-- -->

*   Stopped

    <!-- -->

    <!-- -->

    <!-- -->

*   Failed

    <!-- -->

    <!-- -->

    <!-- -->

*   Complete

    <!-- -->

    <!-- -->

    <!-- -->

*   Cloning

    <!-- -->

    <!-- -->

    <!-- -->

*   Stopping

    <!-- -->

    <!-- -->

    <!-- -->

*   Updating

    <!-- -->

    <!-- -->

    <!-- -->

*   Waiting

    <!-- -->

    <!-- -->

    <!-- -->

*   HotUpdate

    <!-- -->

    <!-- -->

    <!-- -->

*   Committing

    <!-- -->

    <!-- -->

    <!-- -->

*   Starting

    <!-- -->

    <!-- -->

    <!-- -->

*   DeleteFailed

    <!-- -->

    <!-- -->

    <!-- -->

*   Running

    <!-- -->

    <!-- -->

    <!-- -->

*   Developing

    <!-- -->

    <!-- -->

    <!-- -->

*   Scaling

    <!-- -->

    <!-- -->

    <!-- -->

*   Deleted

    <!-- -->

    <!-- -->

    <!-- -->

*   Pending

    <!-- -->

    <!-- -->

    <!-- -->

*   Deleting

    <!-- -->

    <!-- -->

    <!-- -->', example='Running'),
  serviceType?: string(name='ServiceType', description='The service type. Valid values:

*   Async
*   Standard
*   Offline Task
*   Proxima

Valid values:

*   Async

    <!-- -->

    <!-- -->

    <!-- -->

*   Standard

    <!-- -->

    <!-- -->

    <!-- -->

*   OfflineTask

    <!-- -->

    <!-- -->

    <!-- -->

*   Proxima

    <!-- -->

    <!-- -->

    <!-- -->', example='Standard'),
  serviceUid?: string(name='ServiceUid', description='The user ID (UID) of the service.', example='eas-m-c9iw3yitxxxx'),
  sort?: string(name='Sort', description='The sort field. By default, the query results are sorted by the timestamp type in descending order.', example='CreateTime'),
  trafficState?: string(name='TrafficState'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='123456'),
}

model ListServicesShrinkRequest {
  autoscalerEnabled?: boolean(name='AutoscalerEnabled'),
  cronscalerEnabled?: boolean(name='CronscalerEnabled'),
  filter?: string(name='Filter', description='The field that is used for fuzzy matches. The system performs fuzzy matches only by service name.', example='foo'),
  gateway?: string(name='Gateway', description='The private gateway ID.', example='gw-1uhcqmsc7x22******'),
  groupName?: string(name='GroupName', description='The name of the service group. For more information about how to query the name of a service group, see [ListServices](https://help.aliyun.com/document_detail/412109.html).', example='foo'),
  includeNoWorkspace?: boolean(name='IncludeNoWorkspace'),
  labelShrink?: string(name='Label', description='The tag that is used to filter services.'),
  order?: string(name='Order', description='The sorting order. Valid values:

*   desc (default): The query results are sorted in descending order.
*   asc: The query results are sorted in ascending order.', example='asc'),
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 100.', example='100'),
  parentServiceUid?: string(name='ParentServiceUid', description='The ID of the primary service that corresponds to the Band member service.', example='eas-m-ijafy3c8cxxxx'),
  quotaId?: string(name='QuotaId', description='The quota ID.', example='quota12345'),
  resourceAliasName?: string(name='ResourceAliasName'),
  resourceBurstable?: boolean(name='ResourceBurstable'),
  resourceId?: string(name='ResourceId'),
  resourceName?: string(name='ResourceName', description='The name or ID of the resource group to which the service belongs.', example='eas-r-hd0qwy8cxxxx', deprecated=true),
  resourceType?: string(name='ResourceType'),
  role?: string(name='Role', description='The server role.

Valid values:

*   DataLoader
*   FrontEnd
*   DataSet
*   SDProxy
*   LLMSscheduler
*   ScalableJob
*   LLMGateway
*   Job
*   Queue', example='LLMGateway'),
  serviceName?: string(name='ServiceName', description='The service name.', example='echo_test'),
  serviceStatus?: string(name='ServiceStatus', description='The service state.

Valid values:

*   Creating

    <!-- -->

    <!-- -->

    <!-- -->

*   Stopped

    <!-- -->

    <!-- -->

    <!-- -->

*   Failed

    <!-- -->

    <!-- -->

    <!-- -->

*   Complete

    <!-- -->

    <!-- -->

    <!-- -->

*   Cloning

    <!-- -->

    <!-- -->

    <!-- -->

*   Stopping

    <!-- -->

    <!-- -->

    <!-- -->

*   Updating

    <!-- -->

    <!-- -->

    <!-- -->

*   Waiting

    <!-- -->

    <!-- -->

    <!-- -->

*   HotUpdate

    <!-- -->

    <!-- -->

    <!-- -->

*   Committing

    <!-- -->

    <!-- -->

    <!-- -->

*   Starting

    <!-- -->

    <!-- -->

    <!-- -->

*   DeleteFailed

    <!-- -->

    <!-- -->

    <!-- -->

*   Running

    <!-- -->

    <!-- -->

    <!-- -->

*   Developing

    <!-- -->

    <!-- -->

    <!-- -->

*   Scaling

    <!-- -->

    <!-- -->

    <!-- -->

*   Deleted

    <!-- -->

    <!-- -->

    <!-- -->

*   Pending

    <!-- -->

    <!-- -->

    <!-- -->

*   Deleting

    <!-- -->

    <!-- -->

    <!-- -->', example='Running'),
  serviceType?: string(name='ServiceType', description='The service type. Valid values:

*   Async
*   Standard
*   Offline Task
*   Proxima

Valid values:

*   Async

    <!-- -->

    <!-- -->

    <!-- -->

*   Standard

    <!-- -->

    <!-- -->

    <!-- -->

*   OfflineTask

    <!-- -->

    <!-- -->

    <!-- -->

*   Proxima

    <!-- -->

    <!-- -->

    <!-- -->', example='Standard'),
  serviceUid?: string(name='ServiceUid', description='The user ID (UID) of the service.', example='eas-m-c9iw3yitxxxx'),
  sort?: string(name='Sort', description='The sort field. By default, the query results are sorted by the timestamp type in descending order.', example='CreateTime'),
  trafficState?: string(name='TrafficState'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='123456'),
}

model ListServicesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='100'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  services?: [
    Service
  ](name='Services', description='The services.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model ListServicesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListServicesResponseBody(name='body'),
}

/**
 * @summary Lists services.
 *
 * @param tmpReq ListServicesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListServicesResponse
 */
async function listServicesWithOptions(tmpReq: ListServicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListServicesResponse {
  Util.validateModel(tmpReq);
  var request = new ListServicesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.label)) {
    request.labelShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.label, 'Label', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.autoscalerEnabled)) {
    query['AutoscalerEnabled'] = request.autoscalerEnabled;
  }
  if (!Util.isUnset(request.cronscalerEnabled)) {
    query['CronscalerEnabled'] = request.cronscalerEnabled;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.gateway)) {
    query['Gateway'] = request.gateway;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.includeNoWorkspace)) {
    query['IncludeNoWorkspace'] = request.includeNoWorkspace;
  }
  if (!Util.isUnset(request.labelShrink)) {
    query['Label'] = request.labelShrink;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.parentServiceUid)) {
    query['ParentServiceUid'] = request.parentServiceUid;
  }
  if (!Util.isUnset(request.quotaId)) {
    query['QuotaId'] = request.quotaId;
  }
  if (!Util.isUnset(request.resourceAliasName)) {
    query['ResourceAliasName'] = request.resourceAliasName;
  }
  if (!Util.isUnset(request.resourceBurstable)) {
    query['ResourceBurstable'] = request.resourceBurstable;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.role)) {
    query['Role'] = request.role;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.serviceStatus)) {
    query['ServiceStatus'] = request.serviceStatus;
  }
  if (!Util.isUnset(request.serviceType)) {
    query['ServiceType'] = request.serviceType;
  }
  if (!Util.isUnset(request.serviceUid)) {
    query['ServiceUid'] = request.serviceUid;
  }
  if (!Util.isUnset(request.sort)) {
    query['Sort'] = request.sort;
  }
  if (!Util.isUnset(request.trafficState)) {
    query['TrafficState'] = request.trafficState;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServices',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Lists services.
 *
 * @param request ListServicesRequest
 * @return ListServicesResponse
 */
async function listServices(request: ListServicesRequest): ListServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServicesWithOptions(request, headers, runtime);
}

model ListTenantAddonsResponseBody = {
  addons?: [ 
    {
      attributes?: map[string]string(name='Attributes', description='The attributes of the plug-in.'),
      name?: string(name='Name', description='The name of the plug-in.', example='prometheus_discovery'),
    }
  ](name='Addons', description='The information about the plug-in.'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model ListTenantAddonsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTenantAddonsResponseBody(name='body'),
}

/**
 * @summary Queries a list of tenant plug-ins.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTenantAddonsResponse
 */
async function listTenantAddonsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListTenantAddonsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListTenantAddons',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/tenantaddons`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of tenant plug-ins.
 *
 * @return ListTenantAddonsResponse
 */
async function listTenantAddons(): ListTenantAddonsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTenantAddonsWithOptions(headers, runtime);
}

model ListVirtualResourceRequest {
  order?: string(name='Order'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 100.', example='20'),
  sort?: string(name='Sort'),
  virtualResourceId?: string(name='VirtualResourceId', description='The ID of the virtual resource group.', example='eas-vr-npovr28onap1xxxxxx'),
  virtualResourceName?: string(name='VirtualResourceName', description='The name of the virtual resource group.', example='MyVirtualResource'),
}

model ListVirtualResourceResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='40325405-579C-4D82****'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
  virtualResources?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the virtual resource group was created.', example='2024-10-16T17:52:49Z'),
      serviceCount?: int32(name='ServiceCount', description='The number of deployed services.', example='1'),
      updateTime?: string(name='UpdateTime', description='The time when the virtual resource group was last updated.', example='2024-10-16T19:52:49Z'),
      virtualResourceId?: string(name='VirtualResourceId', description='The ID of the virtual resource group.', example='eas-vr-npovr28onap1xxxxxx'),
      virtualResourceName?: string(name='VirtualResourceName', description='The name of the virtual resource group.', example='MyVirtualResource'),
    }
  ](name='VirtualResources', description='The virtual resource groups.'),
}

model ListVirtualResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListVirtualResourceResponseBody(name='body'),
}

/**
 * @summary Queries a list of virtual resource groups for the current user.
 *
 * @param request ListVirtualResourceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListVirtualResourceResponse
 */
async function listVirtualResourceWithOptions(request: ListVirtualResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListVirtualResourceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sort)) {
    query['Sort'] = request.sort;
  }
  if (!Util.isUnset(request.virtualResourceId)) {
    query['VirtualResourceId'] = request.virtualResourceId;
  }
  if (!Util.isUnset(request.virtualResourceName)) {
    query['VirtualResourceName'] = request.virtualResourceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVirtualResource',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/virtualresources`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of virtual resource groups for the current user.
 *
 * @param request ListVirtualResourceRequest
 * @return ListVirtualResourceResponse
 */
async function listVirtualResource(request: ListVirtualResourceRequest): ListVirtualResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listVirtualResourceWithOptions(request, headers, runtime);
}

model ReinstallTenantAddonResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Addon prometheus_discovery is successfully reinstalled'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model ReinstallTenantAddonResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReinstallTenantAddonResponseBody(name='body'),
}

/**
 * @summary Resets tenant configurations.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReinstallTenantAddonResponse
 */
async function reinstallTenantAddonWithOptions(ClusterId: string, TenantAddonName: string, headers: map[string]string, runtime: Util.RuntimeOptions): ReinstallTenantAddonResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ReinstallTenantAddon',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/tenantaddons/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(TenantAddonName)}/reinstall`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Resets tenant configurations.
 *
 * @return ReinstallTenantAddonResponse
 */
async function reinstallTenantAddon(ClusterId: string, TenantAddonName: string): ReinstallTenantAddonResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return reinstallTenantAddonWithOptions(ClusterId, TenantAddonName, headers, runtime);
}

model ReleaseServiceRequest {
  trafficState?: string(name='TrafficState', description='The traffic state. Valid values:

*   standalone: independent traffic.
*   grouping: grouped traffic.', example='grouping'),
  weight?: int32(name='Weight', description='The weight of the service. Valid values: [-1, 1000].', example='100'),
}

model ReleaseServiceResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Releasing service [foo] in region [cn-shanghai] with weight [40], service status: [Running]'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model ReleaseServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReleaseServiceResponseBody(name='body'),
}

/**
 * @summary Switch the traffic state or weight of the service.
 *
 * @param request ReleaseServiceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReleaseServiceResponse
 */
async function releaseServiceWithOptions(ClusterId: string, ServiceName: string, request: ReleaseServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ReleaseServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.trafficState)) {
    body['TrafficState'] = request.trafficState;
  }
  if (!Util.isUnset(request.weight)) {
    body['Weight'] = request.weight;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/release`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Switch the traffic state or weight of the service.
 *
 * @param request ReleaseServiceRequest
 * @return ReleaseServiceResponse
 */
async function releaseService(ClusterId: string, ServiceName: string, request: ReleaseServiceRequest): ReleaseServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return releaseServiceWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model RestartServiceResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Service is restarting'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model RestartServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RestartServiceResponseBody(name='body'),
}

/**
 * @summary Restarts a service.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RestartServiceResponse
 */
async function restartServiceWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): RestartServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RestartService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/restart`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Restarts a service.
 *
 * @return RestartServiceResponse
 */
async function restartService(ClusterId: string, ServiceName: string): RestartServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restartServiceWithOptions(ClusterId, ServiceName, headers, runtime);
}

model StartBenchmarkTaskResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Benchmark task [benchmark-larec-test-1076] is Starting'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model StartBenchmarkTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartBenchmarkTaskResponseBody(name='body'),
}

/**
 * @summary Starts a stress testing task.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartBenchmarkTaskResponse
 */
async function startBenchmarkTaskWithOptions(ClusterId: string, TaskName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartBenchmarkTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(TaskName)}/start`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Starts a stress testing task.
 *
 * @return StartBenchmarkTaskResponse
 */
async function startBenchmarkTask(ClusterId: string, TaskName: string): StartBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startBenchmarkTaskWithOptions(ClusterId, TaskName, headers, runtime);
}

model StartServiceResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Service [foo] in region [cn-shanghai] is starting'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model StartServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartServiceResponseBody(name='body'),
}

/**
 * @summary Starts a service.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartServiceResponse
 */
async function startServiceWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/start`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Starts a service.
 *
 * @return StartServiceResponse
 */
async function startService(ClusterId: string, ServiceName: string): StartServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startServiceWithOptions(ClusterId, ServiceName, headers, runtime);
}

model StopBenchmarkTaskResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Benchmark task [benchmark-larec-test-1076] is Stopping'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model StopBenchmarkTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopBenchmarkTaskResponseBody(name='body'),
}

/**
 * @summary Stops a stress testing task.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopBenchmarkTaskResponse
 */
async function stopBenchmarkTaskWithOptions(ClusterId: string, TaskName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopBenchmarkTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(TaskName)}/stop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Stops a stress testing task.
 *
 * @return StopBenchmarkTaskResponse
 */
async function stopBenchmarkTask(ClusterId: string, TaskName: string): StopBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopBenchmarkTaskWithOptions(ClusterId, TaskName, headers, runtime);
}

model StopServiceResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Succeed to auto scale service [foo]'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model StopServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopServiceResponseBody(name='body'),
}

/**
 * @summary Stops a running service.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopServiceResponse
 */
async function stopServiceWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/stop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Stops a running service.
 *
 * @return StopServiceResponse
 */
async function stopService(ClusterId: string, ServiceName: string): StopServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopServiceWithOptions(ClusterId, ServiceName, headers, runtime);
}

model UpdateAppServiceRequest {
  quotaId?: string(name='QuotaId', description='The quota ID.', example='abcdef'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='123456'),
  appType?: string(name='AppType', description='The application type.

Valid values:

*   LLM: the large language model (LLM) application

    <!-- -->

    <!-- -->

    <!-- -->', example='LLM'),
  appVersion?: string(name='AppVersion', description='The application version.', example='v1'),
  config?: map[string]any(name='Config', description='The additional configurations that are required for service deployment.'),
  replicas?: int32(name='Replicas', description='The number of instances. This value must be greater than 0.', example='1'),
  serviceSpec?: string(name='ServiceSpec', description='The service specifications. Valid values:

*   llama_7b_fp16
*   llama_7b_int8
*   llama_13b_fp16
*   llama_7b_int8
*   chatglm_6b_fp16
*   chatglm_6b_int8
*   chatglm2_6b_fp16
*   baichuan_7b_int8
*   baichuan_13b_fp16
*   baichuan_7b_fp16', example='llama_7b_fp16'),
}

model UpdateAppServiceResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Success'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model UpdateAppServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAppServiceResponseBody(name='body'),
}

/**
 * @summary Updates an application service.
 *
 * @param request UpdateAppServiceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAppServiceResponse
 */
async function updateAppServiceWithOptions(ClusterId: string, ServiceName: string, request: UpdateAppServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAppServiceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.quotaId)) {
    query['QuotaId'] = request.quotaId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.appType)) {
    body['AppType'] = request.appType;
  }
  if (!Util.isUnset(request.appVersion)) {
    body['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.config)) {
    body['Config'] = request.config;
  }
  if (!Util.isUnset(request.replicas)) {
    body['Replicas'] = request.replicas;
  }
  if (!Util.isUnset(request.serviceSpec)) {
    body['ServiceSpec'] = request.serviceSpec;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAppService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/app_services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates an application service.
 *
 * @param request UpdateAppServiceRequest
 * @return UpdateAppServiceResponse
 */
async function updateAppService(ClusterId: string, ServiceName: string, request: UpdateAppServiceRequest): UpdateAppServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAppServiceWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model UpdateBenchmarkTaskRequest {
  body?: string(name='body', description='The request body. The body includes the parameters that are set to create a stress testing task. For more information, see **Table 1. Fields in the base parameter**.', example='{
    "base":  {
         "qps": 200
    }
}'),
}

model UpdateBenchmarkTaskResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Benchmark task [benchmark-larec-test-1076] is Updating'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82***'),
}

model UpdateBenchmarkTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateBenchmarkTaskResponseBody(name='body'),
}

/**
 * @summary Updates a stress testing task.
 *
 * @param request UpdateBenchmarkTaskRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateBenchmarkTaskResponse
 */
async function updateBenchmarkTaskWithOptions(ClusterId: string, TaskName: string, request: UpdateBenchmarkTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateBenchmarkTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(TaskName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates a stress testing task.
 *
 * @param request UpdateBenchmarkTaskRequest
 * @return UpdateBenchmarkTaskResponse
 */
async function updateBenchmarkTask(ClusterId: string, TaskName: string, request: UpdateBenchmarkTaskRequest): UpdateBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateBenchmarkTaskWithOptions(ClusterId, TaskName, request, headers, runtime);
}

model UpdateGatewayRequest {
  enableInternet?: boolean(name='EnableInternet', description='Specifies whether to enable Internet access. Default value: false.

Valid values:

*   true
*   false', example='false'),
  enableIntranet?: boolean(name='EnableIntranet', description='Specifies whether to enable private access. Default value: true.

Valid values:

*   true
*   false', example='true'),
  enableSSLRedirection?: boolean(name='EnableSSLRedirection', description='Specifies whether to enable HTTP to HTTPS redirection. Default value: false.', example='false'),
  instanceType?: string(name='InstanceType', description='The instance type used by the private gateway. Valid values:

*   2c4g
*   4c8g
*   8c16g
*   16c32g', example='ecs.c6.4xlarge'),
  isDefault?: boolean(name='IsDefault', description='Specifies whether it is the default private gateway.', example='true'),
  name?: string(name='Name', description='The alias of the private gateway.', example='mygateway1'),
  replicas?: int32(name='Replicas', description='The number of nodes in the private gateway.', example='2'),
}

model UpdateGatewayResponseBody = {
  gatewayId?: string(name='GatewayId', description='The ID of the gateway.', example='gw-1uhcqmsc7x22******'),
  message?: string(name='Message', description='The returned message.', example='Gateway is updated'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='40325405-579C-4D82***'),
}

model UpdateGatewayResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateGatewayResponseBody(name='body'),
}

/**
 * @summary Update a private gateway.
 *
 * @param request UpdateGatewayRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateGatewayResponse
 */
async function updateGatewayWithOptions(GatewayId: string, ClusterId: string, request: UpdateGatewayRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateGatewayResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.enableInternet)) {
    body['EnableInternet'] = request.enableInternet;
  }
  if (!Util.isUnset(request.enableIntranet)) {
    body['EnableIntranet'] = request.enableIntranet;
  }
  if (!Util.isUnset(request.enableSSLRedirection)) {
    body['EnableSSLRedirection'] = request.enableSSLRedirection;
  }
  if (!Util.isUnset(request.instanceType)) {
    body['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.isDefault)) {
    body['IsDefault'] = request.isDefault;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.replicas)) {
    body['Replicas'] = request.replicas;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGateway',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GatewayId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Update a private gateway.
 *
 * @param request UpdateGatewayRequest
 * @return UpdateGatewayResponse
 */
async function updateGateway(GatewayId: string, ClusterId: string, request: UpdateGatewayRequest): UpdateGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateGatewayWithOptions(GatewayId, ClusterId, request, headers, runtime);
}

model UpdateGroupRequest {
  trafficMode?: string(name='TrafficMode', description='The traffic mode. Valid values: auto and customized. auto: The traffic is automatically allocated based on the proportion of the number of instances to the total number of instances. customized: The traffic is allocated based on a custom weight.', example='auto'),
}

model UpdateGroupResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='40325405-579C-4D82****'),
}

model UpdateGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateGroupResponseBody(name='body'),
}

/**
 * @summary Updates the specific fields of a service group.
 *
 * @param request UpdateGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateGroupResponse
 */
async function updateGroupWithOptions(ClusterId: string, GroupName: string, request: UpdateGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.trafficMode)) {
    body['TrafficMode'] = request.trafficMode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGroup',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/groups/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GroupName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the specific fields of a service group.
 *
 * @param request UpdateGroupRequest
 * @return UpdateGroupResponse
 */
async function updateGroup(ClusterId: string, GroupName: string, request: UpdateGroupRequest): UpdateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateGroupWithOptions(ClusterId, GroupName, request, headers, runtime);
}

model UpdateResourceRequest {
  resourceName?: string(name='ResourceName', description='The new name of the resource group after the update. The name can be up to 27 characters in length.', example='iot'),
  selfManagedResourceOptions?: {
    nodeMatchLabels?: map[string]string(name='NodeMatchLabels', description='Tag tag key-value pairs for nodes.'),
    nodeTolerations?: [ 
      {
        effect?: string(name='effect', description='The effect.
Valid values:
- PreferNoSchedule
- NoSchedule
- NoExecute', example='NoSchedule'),
        key?: string(name='key', description='The key name.', example='key1'),
        operator?: string(name='operator', description='Relationship between key names and key values.
Valid values:
- Equal
- Exists', example='Equal'),
        value?: string(name='value', description='The key value.', example='value1'),
      }
    ](name='NodeTolerations', description='Tolerations for nodes.'),
  }(name='SelfManagedResourceOptions', description='The configuration items of the self-managed resource group.'),
}

model UpdateResourceResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  resourceId?: string(name='ResourceId', description='The ID of the resource group.', example='eas-r-asdasdasd'),
  resourceName?: string(name='ResourceName', description='The name of the resource group.', example='iot'),
}

model UpdateResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateResourceResponseBody(name='body'),
}

/**
 * @summary Updates the information about a dedicated resource group. Only the name of a dedicated resource group can be updated.
 *
 * @param request UpdateResourceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateResourceResponse
 */
async function updateResourceWithOptions(ClusterId: string, ResourceId: string, request: UpdateResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.resourceName)) {
    body['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.selfManagedResourceOptions)) {
    body['SelfManagedResourceOptions'] = request.selfManagedResourceOptions;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateResource',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the information about a dedicated resource group. Only the name of a dedicated resource group can be updated.
 *
 * @param request UpdateResourceRequest
 * @return UpdateResourceResponse
 */
async function updateResource(ClusterId: string, ResourceId: string, request: UpdateResourceRequest): UpdateResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateResourceWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

model UpdateResourceDLinkRequest {
  destinationCIDRs?: string(name='DestinationCIDRs', description='The CIDR blocks of the clients that you want to connect to. After this parameter is specified, the CIDR blocks are added to the back-to-origin route of the server. Either this parameter or the VSwitchIdList parameter can be used to determine CIDR blocks.', example='72.16.0.0/16'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the Elastic Compute Service (ECS) instance belongs.

This parameter is required.', example='sg-bp149cedsfx2rfspd2d'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the peer primary vSwitch. After this parameter is specified, an elastic network interface (ENI) is created in the VSwitch.

This parameter is required.', example='vpc-uf66uio7md****'),
  vSwitchIdList?: [ string ](name='VSwitchIdList', description='The vSwitches of the clients that you want to connect to. After this parameter is specified, the CIDR blocks of these vSwitches are added to the back-to-origin route of the server.'),
}

model UpdateResourceDLinkResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Network interfaces are updating'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model UpdateResourceDLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateResourceDLinkResponseBody(name='body'),
}

/**
 * @summary Updates the configurations of a virtual private cloud (VPC) direct connection for a dedicated resource group.
 *
 * @param request UpdateResourceDLinkRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateResourceDLinkResponse
 */
async function updateResourceDLinkWithOptions(ClusterId: string, ResourceId: string, request: UpdateResourceDLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateResourceDLinkResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.destinationCIDRs)) {
    body['DestinationCIDRs'] = request.destinationCIDRs;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    body['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    body['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vSwitchIdList)) {
    body['VSwitchIdList'] = request.vSwitchIdList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateResourceDLink',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/dlink`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the configurations of a virtual private cloud (VPC) direct connection for a dedicated resource group.
 *
 * @param request UpdateResourceDLinkRequest
 * @return UpdateResourceDLinkResponse
 */
async function updateResourceDLink(ClusterId: string, ResourceId: string, request: UpdateResourceDLinkRequest): UpdateResourceDLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateResourceDLinkWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

model UpdateResourceInstanceRequest {
  action?: string(name='Action', description='The operation that updates the scheduling state of the instance in a dedicated resource group. Valid values:

*   Uncordon: allows scheduling the service to this instance.
*   Cordon: prohibits scheduling the service to this instance.
*   Drain: evicts the service that has been scheduled to this instance.

This parameter is required.', example='Cordon'),
}

model UpdateResourceInstanceResponseBody = {
  instanceId?: string(name='InstanceId', description='The instance ID.', example='eas-i-asdasdasd'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  resourceId?: string(name='ResourceId', description='The ID of the resource group.', example='eas-r-asdasdasd'),
}

model UpdateResourceInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateResourceInstanceResponseBody(name='body'),
}

/**
 * @summary Updates the service scheduling status of an instance in a dedicated resource group.
 *
 * @param request UpdateResourceInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateResourceInstanceResponse
 */
async function updateResourceInstanceWithOptions(ClusterId: string, ResourceId: string, InstanceId: string, request: UpdateResourceInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateResourceInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.action)) {
    body['Action'] = request.action;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateResourceInstance',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/instances/${OpenApiUtil.getEncodeParam(InstanceId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the service scheduling status of an instance in a dedicated resource group.
 *
 * @param request UpdateResourceInstanceRequest
 * @return UpdateResourceInstanceResponse
 */
async function updateResourceInstance(ClusterId: string, ResourceId: string, InstanceId: string, request: UpdateResourceInstanceRequest): UpdateResourceInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateResourceInstanceWithOptions(ClusterId, ResourceId, InstanceId, request, headers, runtime);
}

model UpdateResourceInstanceLabelRequest {
  allInstances?: boolean(name='AllInstances', description='Specifies whether the modification takes effect on all instances in the resource group. If you set this parameter to true, the InstanceIds parameter does not take effect.', example='false'),
  instanceIds?: [ string ](name='InstanceIds', description='The instance IDs.'),
  labels?: map[string]string(name='Labels', description='The custom tag.'),
}

model UpdateResourceInstanceLabelShrinkRequest {
  allInstances?: boolean(name='AllInstances', description='Specifies whether the modification takes effect on all instances in the resource group. If you set this parameter to true, the InstanceIds parameter does not take effect.', example='false'),
  instanceIdsShrink?: string(name='InstanceIds', description='The instance IDs.'),
  labels?: map[string]string(name='Labels', description='The custom tag.'),
}

model UpdateResourceInstanceLabelResponseBody = {
  message?: string(name='Message', description='The message.', example='Success'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model UpdateResourceInstanceLabelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateResourceInstanceLabelResponseBody(name='body'),
}

/**
 * @summary Updates the tag of an instance in a resource group.
 *
 * @param tmpReq UpdateResourceInstanceLabelRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateResourceInstanceLabelResponse
 */
async function updateResourceInstanceLabelWithOptions(ClusterId: string, ResourceId: string, tmpReq: UpdateResourceInstanceLabelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateResourceInstanceLabelResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateResourceInstanceLabelShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.instanceIds)) {
    request.instanceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.instanceIds, 'InstanceIds', 'simple');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.allInstances)) {
    query['AllInstances'] = request.allInstances;
  }
  if (!Util.isUnset(request.instanceIdsShrink)) {
    query['InstanceIds'] = request.instanceIdsShrink;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.labels)) {
    body['Labels'] = request.labels;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateResourceInstanceLabel',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/label`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the tag of an instance in a resource group.
 *
 * @param request UpdateResourceInstanceLabelRequest
 * @return UpdateResourceInstanceLabelResponse
 */
async function updateResourceInstanceLabel(ClusterId: string, ResourceId: string, request: UpdateResourceInstanceLabelRequest): UpdateResourceInstanceLabelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateResourceInstanceLabelWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

model UpdateServiceRequest {
  memberToUpdate?: string(name='MemberToUpdate'),
  updateType?: string(name='UpdateType', description='The type of the service update. Valid values: merge and replace. By default, merge is used if you do not specify this parameter.

*   merge: If the JSON string configured for the existing service is `{"a":"b"}` and the JSON string specified in the body parameter is `{"c":"d"}`, the JSON string is `{"a":"b","c":"d"}` after the service update.
*   replace: If the JSON string configured for the existing service is `{"a":"b"}` and the JSON string specified in the body parameter is `{"c":"d"}`, the JSON string is `{"c":"d"}` after the service update.', example='merge'),
  body?: string(name='body', description='The request body. The body includes the request parameters that you want to update. For more information about the request parameters, see [CreateService](https://help.aliyun.com/document_detail/412086.html).', example='{   "name": "foo",   "model_path": "http://path/to/model.tar.gz",   "processor": "tensorflow_cpu",   "metadata": {     "instance": 2,     "memory": 7000,     "cpu": 4   } }'),
}

model UpdateServiceResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Succeed to update service [foo] in region [cn-shanghai]'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model UpdateServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateServiceResponseBody(name='body'),
}

/**
 * @summary Updates a model or processor of a service. If only the metadata.instance field is updated, manual scaling can be performed.
 *
 * @param request UpdateServiceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateServiceResponse
 */
async function updateServiceWithOptions(ClusterId: string, ServiceName: string, request: UpdateServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.memberToUpdate)) {
    query['MemberToUpdate'] = request.memberToUpdate;
  }
  if (!Util.isUnset(request.updateType)) {
    query['UpdateType'] = request.updateType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates a model or processor of a service. If only the metadata.instance field is updated, manual scaling can be performed.
 *
 * @param request UpdateServiceRequest
 * @return UpdateServiceResponse
 */
async function updateService(ClusterId: string, ServiceName: string, request: UpdateServiceRequest): UpdateServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model UpdateServiceAutoScalerRequest {
  behavior?: {
    onZero?: {
      scaleDownGracePeriodSeconds?: int32(name='scaleDownGracePeriodSeconds', description='The time window that is required before the number of instances is reduced to 0. Default value: 600. The number of instances can be reduced to 0 only if no request is available or no traffic exists in the specified time window.', example='600'),
      scaleUpActivationReplicas?: int32(name='scaleUpActivationReplicas', description='The number of instances that you want to create at a time if the number of instances is scaled out from 0. Default value: 1.', example='1'),
    }(name='onZero', description='The operation that reduces the number of instances to 0.'),
    scaleDown?: {
      stabilizationWindowSeconds?: int32(name='stabilizationWindowSeconds', description='The time window that is required before the scale-in operation is performed. Default value: 300. The scale-in operation can be performed only if the specified metric drops below the threshold in the specified time window.', example='300'),
    }(name='scaleDown', description='The scale-in operation.'),
    scaleUp?: {
      stabilizationWindowSeconds?: int32(name='stabilizationWindowSeconds', description='The time window that is required before the scale-out operation is performed. Default value: 0. The scale-out operation can be performed only if the specified metric exceeds the specified threshold in the specified time window.', example='0'),
    }(name='scaleUp', description='The scale-out operation.'),
  }(name='behavior', description='The Autoscaler operation.'),
  max?: int32(name='max', description='The maximum number of instances. The value must be greater than that of the min parameter.

This parameter is required.', example='8'),
  min?: int32(name='min', description='The minimum number of instances. The value must be greater than 0.

This parameter is required.', example='2'),
  scaleStrategies?: [ 
    {
      metricName?: string(name='metricName', description='The name of the metric for triggering auto scaling. Valid values:

*   qps: the queries per second (QPS) for an individual instance.
*   cpu: the CPU utilization.

This parameter is required.', example='qps'),
      service?: string(name='service', description='The service for which the metric is specified. If you do not set this parameter, the current service is specified by default.', example='demo_svc'),
      threshold?: float(name='threshold', description='The threshold of the metric that triggers auto scaling.

*   If you set metricName to QPS, scale-out is triggered when the average QPS for a single instance is greater than this threshold.
*   If you set metricName to CPU, scale-out is triggered when the average CPU utilization for a single instance is greater than this threshold.

This parameter is required.', example='100'),
    }
  ](name='scaleStrategies', description='The auto scaling policies.

This parameter is required.'),
}

model UpdateServiceAutoScalerResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Update auto scale for service [foo] successfully'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model UpdateServiceAutoScalerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateServiceAutoScalerResponseBody(name='body'),
}

/**
 * @summary Updates the Autoscaler configurations of a service.
 *
 * @param request UpdateServiceAutoScalerRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateServiceAutoScalerResponse
 */
async function updateServiceAutoScalerWithOptions(ClusterId: string, ServiceName: string, request: UpdateServiceAutoScalerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceAutoScalerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.behavior)) {
    body['behavior'] = request.behavior;
  }
  if (!Util.isUnset(request.max)) {
    body['max'] = request.max;
  }
  if (!Util.isUnset(request.min)) {
    body['min'] = request.min;
  }
  if (!Util.isUnset(request.scaleStrategies)) {
    body['scaleStrategies'] = request.scaleStrategies;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceAutoScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/autoscaler`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the Autoscaler configurations of a service.
 *
 * @param request UpdateServiceAutoScalerRequest
 * @return UpdateServiceAutoScalerResponse
 */
async function updateServiceAutoScaler(ClusterId: string, ServiceName: string, request: UpdateServiceAutoScalerRequest): UpdateServiceAutoScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceAutoScalerWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model UpdateServiceCronScalerRequest {
  excludeDates?: [ string ](name='ExcludeDates', description='The points in time that are excluded when you schedule a CronHPA job. The points in time must be specified by using a cron expression.'),
  scaleJobs?: [ 
    {
      name?: string(name='Name', description='The name of the CronHPA job.', example='scale-job-1'),
      schedule?: string(name='Schedule', description='The cron expression that is used to configure the execution time of the CronHPA job. For more information about how to configure cron expressions, see **Description of special characters** in this topic.

This parameter is required.', example='0 18 * * * *'),
      targetSize?: int32(name='TargetSize', description='The number of instances that you want to configure for the CronHPA job.

This parameter is required.', example='2'),
      timeZone?: string(name='TimeZone'),
    }
  ](name='ScaleJobs', description='The description of the CronHPA job.

This parameter is required.'),
}

model UpdateServiceCronScalerResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Update cron scaler for service [foo] successfully'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model UpdateServiceCronScalerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateServiceCronScalerResponseBody(name='body'),
}

/**
 * @summary Updates the Cron Horizontal Pod Autoscaler (CronHPA) settings of a service.
 *
 * @param request UpdateServiceCronScalerRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateServiceCronScalerResponse
 */
async function updateServiceCronScalerWithOptions(ClusterId: string, ServiceName: string, request: UpdateServiceCronScalerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceCronScalerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.excludeDates)) {
    body['ExcludeDates'] = request.excludeDates;
  }
  if (!Util.isUnset(request.scaleJobs)) {
    body['ScaleJobs'] = request.scaleJobs;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceCronScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/cronscaler`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the Cron Horizontal Pod Autoscaler (CronHPA) settings of a service.
 *
 * @param request UpdateServiceCronScalerRequest
 * @return UpdateServiceCronScalerResponse
 */
async function updateServiceCronScaler(ClusterId: string, ServiceName: string, request: UpdateServiceCronScalerRequest): UpdateServiceCronScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceCronScalerWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model UpdateServiceInstanceRequest {
  isolate?: boolean(name='Isolate', description='Specifies whether to isolate the service instance. Valid values:

*   true
*   false', example='true'),
}

model UpdateServiceInstanceResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Success'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model UpdateServiceInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateServiceInstanceResponseBody(name='body'),
}

/**
 * @summary Updates attributes of service instances. Only isolation can be performed for service instances.
 *
 * @param request UpdateServiceInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateServiceInstanceResponse
 */
async function updateServiceInstanceWithOptions(ClusterId: string, ServiceName: string, InstanceName: string, request: UpdateServiceInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.isolate)) {
    body['Isolate'] = request.isolate;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceInstance',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/instances/${OpenApiUtil.getEncodeParam(InstanceName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates attributes of service instances. Only isolation can be performed for service instances.
 *
 * @param request UpdateServiceInstanceRequest
 * @return UpdateServiceInstanceResponse
 */
async function updateServiceInstance(ClusterId: string, ServiceName: string, InstanceName: string, request: UpdateServiceInstanceRequest): UpdateServiceInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceInstanceWithOptions(ClusterId, ServiceName, InstanceName, request, headers, runtime);
}

model UpdateServiceLabelRequest {
  labels?: map[string]string(name='Labels', description='The custom service tags.

This parameter is required.'),
}

model UpdateServiceLabelResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Succeed to update service [service_from_XXXX] labels.'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model UpdateServiceLabelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateServiceLabelResponseBody(name='body'),
}

/**
 * @summary Adds service tags or updates existing service tags.
 *
 * @param request UpdateServiceLabelRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateServiceLabelResponse
 */
async function updateServiceLabelWithOptions(ClusterId: string, ServiceName: string, request: UpdateServiceLabelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceLabelResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.labels)) {
    body['Labels'] = request.labels;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceLabel',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/label`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Adds service tags or updates existing service tags.
 *
 * @param request UpdateServiceLabelRequest
 * @return UpdateServiceLabelResponse
 */
async function updateServiceLabel(ClusterId: string, ServiceName: string, request: UpdateServiceLabelRequest): UpdateServiceLabelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceLabelWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model UpdateServiceMirrorRequest {
  ratio?: int32(name='Ratio', description='The percentage of traffic that you want to mirror. Valid values: 0 to 100.', example='30'),
  target?: [ string ](name='Target', description='The service instances.'),
}

model UpdateServiceMirrorResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Traffic mirroring is updating for service [foo] in region [cn-shanghia], ratio [70%]'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82***'),
}

model UpdateServiceMirrorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateServiceMirrorResponseBody(name='body'),
}

/**
 * @summary Updates the traffic mirroring configurations of a service.
 *
 * @param request UpdateServiceMirrorRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateServiceMirrorResponse
 */
async function updateServiceMirrorWithOptions(ClusterId: string, ServiceName: string, request: UpdateServiceMirrorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceMirrorResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ratio)) {
    body['Ratio'] = request.ratio;
  }
  if (!Util.isUnset(request.target)) {
    body['Target'] = request.target;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceMirror',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/mirror`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the traffic mirroring configurations of a service.
 *
 * @param request UpdateServiceMirrorRequest
 * @return UpdateServiceMirrorResponse
 */
async function updateServiceMirror(ClusterId: string, ServiceName: string, request: UpdateServiceMirrorRequest): UpdateServiceMirrorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceMirrorWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model UpdateServiceSafetyLockRequest {
  lock?: string(name='Lock', description='The lock scope. Valid values:

*   all: locks all operations.
*   dangerous: locks dangerous operations such as delete and stop operations.
*   none: locks no operations.

This parameter is required.', example='dangerous'),
}

model UpdateServiceSafetyLockResponseBody = {
  message?: string(name='Message', description='The returned message.', example='service safety lock updated to dangerous'),
  requestId?: string(name='RequestId', description='The request ID.', example='E089D584-B6F4-50C4-9902-DA2295B7****'),
}

model UpdateServiceSafetyLockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateServiceSafetyLockResponseBody(name='body'),
}

/**
 * @summary Updates the safety lock of a service to minimize misoperations on the service.
 *
 * @param request UpdateServiceSafetyLockRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateServiceSafetyLockResponse
 */
async function updateServiceSafetyLockWithOptions(ClusterId: string, ServiceName: string, request: UpdateServiceSafetyLockRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceSafetyLockResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.lock)) {
    body['Lock'] = request.lock;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceSafetyLock',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/lock`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the safety lock of a service to minimize misoperations on the service.
 *
 * @param request UpdateServiceSafetyLockRequest
 * @return UpdateServiceSafetyLockResponse
 */
async function updateServiceSafetyLock(ClusterId: string, ServiceName: string, request: UpdateServiceSafetyLockRequest): UpdateServiceSafetyLockResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceSafetyLockWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model UpdateServiceVersionRequest {
  version?: int32(name='Version', description='The destination version of the service. The value must be of the INT type. The value must be greater than 0 and smaller than the current version of the service.

This parameter is required.', example='1'),
}

model UpdateServiceVersionResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Service [foo] in region [cn-shanghai] is starting'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model UpdateServiceVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateServiceVersionResponseBody(name='body'),
}

/**
 * @summary Updates the version of a service or rolls back the service to a specific version.
 *
 * @param request UpdateServiceVersionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateServiceVersionResponse
 */
async function updateServiceVersionWithOptions(ClusterId: string, ServiceName: string, request: UpdateServiceVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceVersionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.version)) {
    body['Version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceVersion',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/version`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the version of a service or rolls back the service to a specific version.
 *
 * @param request UpdateServiceVersionRequest
 * @return UpdateServiceVersionResponse
 */
async function updateServiceVersion(ClusterId: string, ServiceName: string, request: UpdateServiceVersionRequest): UpdateServiceVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceVersionWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model UpdateVirtualResourceRequest {
  disableSpotProtectionPeriod?: boolean(name='DisableSpotProtectionPeriod', description='Specifies whether to disable the retention period of preemptible instances.', example='true'),
  resources?: [ 
    {
      instanceType?: string(name='InstanceType', description='The instance type of the public resource group.

>  You must specify one and only one of the InstanceType, ResourceId, and QuotaId parameters.', example='ecs.s6-c1m2.xlarge'),
      priority?: int32(name='Priority', description='The priority of resource scheduling. A greater number indicates a higher priority.', example='6'),
      quotaId?: string(name='QuotaId', description='The ID of the Lingjun resource quota.

>  You must specify one and only one of the InstanceType, ResourceId, and QuotaId parameters.', example='quota185lqf994k6'),
      region?: string(name='Region', description='The region in which the resource resides.', example='cn-hangzhou'),
      resourceId?: string(name='ResourceId', description='The ID of the dedicated resource group. For information about how to obtain the ID of a dedicated resource group, see [ListResources](https://help.aliyun.com/document_detail/412133.html).

>  You must specify one and only one of the InstanceType, ResourceId, and QuotaId parameters.', example='eas-r-g55ieatgg3butwrn7a'),
      spotPriceLimit?: float(name='SpotPriceLimit', description='The maximum price of preemptible instances in a public resource group.

>  If you leave this parameter empty, preemptible instances are not used.', example='10.05'),
    }
  ](name='Resources', description='The resources in the virtual resource group.

>  If you specify this parameter, previous data is overwritten.'),
  virtualResourceName?: string(name='VirtualResourceName', description='The new name of the virtual resource group.', example='NewMyVirtualResource'),
}

model UpdateVirtualResourceResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Successfully updated virtual resource eas-vr-npovr28onap1xxxxxx'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='40325405-579C-4D82****'),
}

model UpdateVirtualResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateVirtualResourceResponseBody(name='body'),
}

/**
 * @summary Updates the information about a virtual resource group.
 *
 * @param request UpdateVirtualResourceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateVirtualResourceResponse
 */
async function updateVirtualResourceWithOptions(ClusterId: string, VirtualResourceId: string, request: UpdateVirtualResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateVirtualResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.disableSpotProtectionPeriod)) {
    body['DisableSpotProtectionPeriod'] = request.disableSpotProtectionPeriod;
  }
  if (!Util.isUnset(request.resources)) {
    body['Resources'] = request.resources;
  }
  if (!Util.isUnset(request.virtualResourceName)) {
    body['VirtualResourceName'] = request.virtualResourceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateVirtualResource',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/virtualresources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(VirtualResourceId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the information about a virtual resource group.
 *
 * @param request UpdateVirtualResourceRequest
 * @return UpdateVirtualResourceResponse
 */
async function updateVirtualResource(ClusterId: string, VirtualResourceId: string, request: UpdateVirtualResourceRequest): UpdateVirtualResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateVirtualResourceWithOptions(ClusterId, VirtualResourceId, request, headers, runtime);
}

