/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-beijing = 'pai-eas.cn-beijing.aliyuncs.com',
    cn-zhangjiakou = 'pai-eas.cn-zhangjiakou.aliyuncs.com',
    cn-hangzhou = 'pai-eas.cn-hangzhou.aliyuncs.com',
    cn-shanghai = 'pai-eas.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'pai-eas.cn-shenzhen.aliyuncs.com',
    cn-hongkong = 'pai-eas.cn-hongkong.aliyuncs.com',
    ap-southeast-1 = 'pai-eas.ap-southeast-1.aliyuncs.com',
    ap-southeast-5 = 'pai-eas.ap-southeast-5.aliyuncs.com',
    us-east-1 = 'pai-eas.us-east-1.aliyuncs.com',
    us-west-1 = 'pai-eas.us-west-1.aliyuncs.com',
    eu-central-1 = 'pai-eas.eu-central-1.aliyuncs.com',
    ap-south-1 = 'pai-eas.ap-south-1.aliyuncs.com',
    cn-shanghai-finance-1 = 'pai-eas.cn-shanghai-finance-1.aliyuncs.com',
    cn-north-2-gov-1 = 'pai-eas.cn-north-2-gov-1.aliyuncs.com',
    cn-chengdu = 'pai-eas.cn-chengdu.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('eas', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model Instance {
  hostIP?: string(name='HostIP', description='实例所在的宿主机IP'),
  hostName?: string(name='HostName', description='实例所在的宿主机名字'),
  innerIP?: string(name='InnerIP', description='实例的内网IP'),
  instanceName?: string(name='InstanceName', description='实例的名字'),
  instancePort?: int32(name='InstancePort', description='实例的网络端口'),
  lastState?: [  map[string]any ](name='LastState', description='实例上一次退出的状态'),
  namespace?: string(name='Namespace', description='实例的命名空间'),
  readyProcesses?: int32(name='ReadyProcesses', description='实例已经启动完成的进程数'),
  reason?: string(name='Reason', description='实例当前状态的标识'),
  restartCount?: int32(name='RestartCount', description='实例重启次数'),
  startAt?: string(name='StartAt', description='实例的启动时间'),
  status?: string(name='Status', description='实例状态'),
  totalProcesses?: int32(name='TotalProcesses', description='实例总的进程数'),
}

model Resource {
  clusterId?: string(name='ClusterId', description='资源组所在的集群'),
  cpuCount?: int32(name='CpuCount', description='资源组CPU数量'),
  createTime?: string(name='CreateTime', description='资源组创建时间'),
  extraData?: map[string]any(name='ExtraData', description='资源组自定义数据'),
  gpuCount?: int32(name='GpuCount', description='资源组GPU个数'),
  instanceCount?: int32(name='InstanceCount', description='资源组实例个数'),
  message?: string(name='Message', description='资源组摘要信息'),
  postPaidInstanceCount?: int32(name='PostPaidInstanceCount', description='资源组按量付费实例个数'),
  prePaidInstanceCount?: int32(name='PrePaidInstanceCount', description='资源组预付费实例个数'),
  resourceId?: string(name='ResourceId', description='资源组ID'),
  resourceName?: string(name='ResourceName', description='资源组名字'),
  status?: string(name='Status', description='资源组的状态'),
  updateTime?: string(name='UpdateTime', description='资源组更新时间'),
}

model ResourceInstance {
  autoRenewal?: boolean(name='AutoRenewal', description='实例是否自动续费'),
  chargeType?: string(name='ChargeType', description='实例的计费类型'),
  createTime?: string(name='CreateTime', description='实例的创建时间'),
  expiredTime?: string(name='ExpiredTime', description='实例过期时间'),
  instanceCpuCount?: int32(name='InstanceCpuCount', description='实例的Cpu个数'),
  instanceGpuCount?: int32(name='InstanceGpuCount', description='实例的Gpu个数'),
  instanceId?: string(name='InstanceId', description='实例ID'),
  instanceIp?: string(name='InstanceIp', description='实例IP'),
  instanceMemory?: string(name='InstanceMemory', description='实例的内存大小'),
  instanceName?: string(name='InstanceName', description='实例名称'),
  instanceStatus?: string(name='InstanceStatus', description='实例状态'),
  instanceType?: string(name='InstanceType', description='实例的机型'),
  instanceUsedCpu?: float(name='InstanceUsedCpu', description='实例被使用的CPU数量'),
  instanceUsedGpu?: int32(name='InstanceUsedGpu', description='实例被使用的GPU数量'),
  instanceUsedMemory?: string(name='InstanceUsedMemory', description='实例被使用的内存大小'),
}

model ResourceInstanceWorker {
  cpuLimit?: int32(name='CpuLimit', description='CpuLimit'),
  cpuRequest?: int32(name='CpuRequest', description='CpuRequest'),
  gpuLimit?: int32(name='GpuLimit', description='GpuLimit'),
  gpuRequest?: int32(name='GpuRequest', description='GpuRequest'),
  memoryLimit?: int32(name='MemoryLimit', description='MemoryLimit'),
  memoryRquest?: int32(name='MemoryRquest', description='MemoryRquest'),
  name?: string(name='Name', description='pod名'),
  ready?: boolean(name='Ready', description='是否ready'),
  restartCount?: int32(name='RestartCount', description='RestartCount'),
  serviceName?: string(name='ServiceName', description='服务名'),
  startTime?: string(name='StartTime', description='StartTime'),
  status?: string(name='Status', description='pod状态'),
}

model Service {
  accessToken?: string(name='AccessToken', description='服务的请求Token'),
  callerUid?: string(name='CallerUid', description='服务创建账号的UID'),
  cpu?: int32(name='Cpu', description='每个实例申请的cpu'),
  createTime?: string(name='CreateTime', description='服务的创建时间'),
  currentVersion?: int32(name='CurrentVersion', description='当前运行的模型版本'),
  gpu?: int32(name='Gpu', description='每个实例申请的gpu'),
  image?: string(name='Image', description='服务的数据镜像'),
  internetEndpoint?: string(name='InternetEndpoint', description='服务的公网endpoint'),
  intranetEndpoint?: string(name='IntranetEndpoint', description='服务内网endpoint'),
  latestVersion?: int32(name='LatestVersion', description='服务最新版本号'),
  memory?: int32(name='Memory', description='每个worker需要的内存大小，单位为M'),
  message?: string(name='Message', description='服务的摘要信息'),
  namespace?: string(name='Namespace', description='服务所在的命名空间'),
  parentUid?: string(name='ParentUid', description='服务创建账号的主账号UID'),
  pendingInstance?: int32(name='PendingInstance', description='被挂起的服务的实例个数'),
  reason?: string(name='Reason', description='服务的状态信息'),
  region?: string(name='Region', description='服务所在的区域'),
  requestId?: string(name='RequestId', description='请求ID'),
  resource?: string(name='Resource', description='服务所在的资源组'),
  runningInstance?: int32(name='RunningInstance', description='正在运行的服务的实例个数'),
  serviceConfig?: string(name='ServiceConfig', description='服务的配置信息'),
  serviceId?: string(name='ServiceId', description='服务ID'),
  serviceName?: string(name='ServiceName', description='服务的名字'),
  source?: string(name='Source', description='服务的部署来源'),
  status?: string(name='Status', description='服务的状态'),
  totalInstance?: int32(name='TotalInstance', description='服务的所有实例总个数'),
  updatetime?: string(name='Updatetime', description='服务的更新时间'),
  weight?: int32(name='Weight', description='服务灰度发布的权重值'),
}

model CreateBenchmarkTaskRequest {
  body?: string(name='body'),
}

model CreateBenchmarkTaskResponseBody = {
  message?: string(name='Message'),
  name?: string(name='Name'),
  region?: string(name='Region'),
  requestId?: string(name='RequestId'),
}

model CreateBenchmarkTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBenchmarkTaskResponseBody(name='body'),
}

async function createBenchmarkTask(request: CreateBenchmarkTaskRequest): CreateBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createBenchmarkTaskWithOptions(request, headers, runtime);
}

async function createBenchmarkTaskWithOptions(request: CreateBenchmarkTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateBenchmarkTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CreateBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateResourceRequest {
  autoRenewal?: boolean(name='AutoRenewal', description='是否自动续费'),
  chargeType?: string(name='ChargeType', description='付费类型，预付费PrePaid，后付费PostPaid'),
  ecsInstanceCount?: int32(name='EcsInstanceCount', description='实例数量'),
  ecsInstanceType?: string(name='EcsInstanceType', description='实例机型，对应ecs机型'),
}

model CreateResourceResponseBody = {
  clusterId?: string(name='ClusterId', description='资源组所在集群ID'),
  ownerUid?: string(name='OwnerUid', description='资源组的Owner UID'),
  requestId?: string(name='RequestId', description='Id of the request'),
  resourceId?: string(name='ResourceId', description='资源组ID'),
  resourceName?: string(name='ResourceName', description='资源组名称'),
}

model CreateResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateResourceResponseBody(name='body'),
}

async function createResource(request: CreateResourceRequest): CreateResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createResourceWithOptions(request, headers, runtime);
}

async function createResourceWithOptions(request: CreateResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateResourceResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.autoRenewal)) {
    body['AutoRenewal'] = request.autoRenewal;
  }
  if (!Util.isUnset(request.chargeType)) {
    body['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.ecsInstanceCount)) {
    body['EcsInstanceCount'] = request.ecsInstanceCount;
  }
  if (!Util.isUnset(request.ecsInstanceType)) {
    body['EcsInstanceType'] = request.ecsInstanceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateResource',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateResourceInstancesRequest {
  autoRenewal?: boolean(name='AutoRenewal', description='是否自动续费'),
  chargeType?: string(name='ChargeType', description='付费类型，预付费PrePaid，后付费PostPaid'),
  ecsInstanceCount?: int32(name='EcsInstanceCount', description='新创建的实例个数，(0, 100]'),
  ecsInstanceType?: string(name='EcsInstanceType', description='实例机型，对应ecs机型'),
  userData?: string(name='UserData', description='用户自这义数据，小于 16KB'),
}

model CreateResourceInstancesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateResourceInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateResourceInstancesResponseBody(name='body'),
}

async function createResourceInstances(ClusterId: string, ResourceId: string, request: CreateResourceInstancesRequest): CreateResourceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createResourceInstancesWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

async function createResourceInstancesWithOptions(ClusterId: string, ResourceId: string, request: CreateResourceInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateResourceInstancesResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.autoRenewal)) {
    body['AutoRenewal'] = request.autoRenewal;
  }
  if (!Util.isUnset(request.chargeType)) {
    body['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.ecsInstanceCount)) {
    body['EcsInstanceCount'] = request.ecsInstanceCount;
  }
  if (!Util.isUnset(request.ecsInstanceType)) {
    body['EcsInstanceType'] = request.ecsInstanceType;
  }
  if (!Util.isUnset(request.userData)) {
    body['UserData'] = request.userData;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateResourceInstances',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}/instances`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateResourceLogRequest {
  logStore?: string(name='LogStore', description='sls日志库'),
  projectName?: string(name='ProjectName', description='资源组对应的sls日志管理项目'),
}

model CreateResourceLogResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateResourceLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateResourceLogResponseBody(name='body'),
}

async function createResourceLog(ClusterId: string, ResourceId: string, request: CreateResourceLogRequest): CreateResourceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createResourceLogWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

async function createResourceLogWithOptions(ClusterId: string, ResourceId: string, request: CreateResourceLogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateResourceLogResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.logStore)) {
    body['LogStore'] = request.logStore;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateResourceLog',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}/log`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateServiceRequest {
  body?: string(name='body'),
}

model CreateServiceResponseBody = {
  internetEndpoint?: string(name='InternetEndpoint'),
  intranetEndpoint?: string(name='IntranetEndpoint'),
  region?: string(name='Region'),
  requestId?: string(name='RequestId', description='Id of the request'),
  serviceId?: string(name='ServiceId'),
  serviceName?: string(name='ServiceName'),
  status?: string(name='Status'),
}

model CreateServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceResponseBody(name='body'),
}

async function createService(request: CreateServiceRequest): CreateServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceWithOptions(request, headers, runtime);
}

async function createServiceWithOptions(request: CreateServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CreateService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateServiceAutoScalerRequest {
  max?: int32(name='Max', description='最大 replica 数，需要大于MinReplica'),
  min?: int32(name='Min', description='最小 replica 数，需要大于0'),
  strategies?: {
    cpu?: float(name='Cpu', description='最大 replica 数，需要大于MinReplica'),
    qps?: float(name='Qps', description='每个实例支持的最大qps数，超出即扩容'),
  }(name='Strategies', description='map 类型的策略定义'),
}

model CreateServiceAutoScalerResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateServiceAutoScalerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceAutoScalerResponseBody(name='body'),
}

async function createServiceAutoScaler(ClusterId: string, ServiceName: string, request: CreateServiceAutoScalerRequest): CreateServiceAutoScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceAutoScalerWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

async function createServiceAutoScalerWithOptions(ClusterId: string, ServiceName: string, request: CreateServiceAutoScalerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceAutoScalerResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var body : map[string]any= {};
  if (!Util.isUnset(request.max)) {
    body['Max'] = request.max;
  }
  if (!Util.isUnset(request.min)) {
    body['Min'] = request.min;
  }
  if (!Util.isUnset(request.strategies)) {
    body['Strategies'] = request.strategies;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceAutoScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/autoscaler`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateServiceCronScalerRequest {
  excludeDates?: [ string ](name='ExcludeDates', description='需要排除的时间点的cron表达式'),
  scaleJobs?: [ 
    {
      name?: string(name='Name'),
      schedule?: string(name='Schedule', description='要执行伸缩任务的cron表达式'),
      targetSize?: int32(name='TargetSize', description='执行伸缩任务的目标replica'),
    }
  ](name='ScaleJobs', description='定时伸缩任务描述'),
}

model CreateServiceCronScalerResponseBody = {
  message?: string(name='Message', description='操作成功消息'),
  requestId?: string(name='RequestId', description='请求ID'),
}

model CreateServiceCronScalerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceCronScalerResponseBody(name='body'),
}

async function createServiceCronScaler(ClusterId: string, ServiceName: string, request: CreateServiceCronScalerRequest): CreateServiceCronScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceCronScalerWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

async function createServiceCronScalerWithOptions(ClusterId: string, ServiceName: string, request: CreateServiceCronScalerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceCronScalerResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var body : map[string]any= {};
  if (!Util.isUnset(request.excludeDates)) {
    body['ExcludeDates'] = request.excludeDates;
  }
  if (!Util.isUnset(request.scaleJobs)) {
    body['ScaleJobs'] = request.scaleJobs;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceCronScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/cronscaler`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateServiceMirrorRequest {
  ratio?: int32(name='Ratio', description='比例 [0, 100]'),
  target?: [ string ](name='Target', description='服务实例列表'),
}

model CreateServiceMirrorResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateServiceMirrorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceMirrorResponseBody(name='body'),
}

async function createServiceMirror(ClusterId: string, ServiceName: string, request: CreateServiceMirrorRequest): CreateServiceMirrorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceMirrorWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

async function createServiceMirrorWithOptions(ClusterId: string, ServiceName: string, request: CreateServiceMirrorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceMirrorResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var body : map[string]any= {};
  if (!Util.isUnset(request.ratio)) {
    body['Ratio'] = request.ratio;
  }
  if (!Util.isUnset(request.target)) {
    body['Target'] = request.target;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceMirror',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/mirror`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateStressRequest {
  body?: string(name='body'),
}

model CreateStressResponseBody = {
  message?: string(name='Message'),
  name?: string(name='Name'),
  region?: string(name='Region'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateStressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateStressResponseBody(name='body'),
}

async function createStress(request: CreateStressRequest): CreateStressResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createStressWithOptions(request, headers, runtime);
}

async function createStressWithOptions(request: CreateStressRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateStressResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CreateStress',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/stress`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteBenchmarkTaskResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteBenchmarkTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBenchmarkTaskResponseBody(name='body'),
}

async function deleteBenchmarkTask(ClusterId: string, TaskName: string): DeleteBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteBenchmarkTaskWithOptions(ClusterId, TaskName, headers, runtime);
}

async function deleteBenchmarkTaskWithOptions(ClusterId: string, TaskName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteBenchmarkTaskResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  TaskName = OpenApiUtil.getEncodeParam(TaskName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks/${ClusterId}/${TaskName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteResourceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteResourceResponseBody(name='body'),
}

async function deleteResource(ClusterId: string, ResourceId: string): DeleteResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteResourceWithOptions(ClusterId, ResourceId, headers, runtime);
}

async function deleteResourceWithOptions(ClusterId: string, ResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteResourceResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteResource',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteResourceDLinkResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteResourceDLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteResourceDLinkResponseBody(name='body'),
}

async function deleteResourceDLink(ClusterId: string, ResourceId: string): DeleteResourceDLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteResourceDLinkWithOptions(ClusterId, ResourceId, headers, runtime);
}

async function deleteResourceDLinkWithOptions(ClusterId: string, ResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteResourceDLinkResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourceDLink',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}/dlink`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteResourceInstancesRequest {
  allFailed?: boolean(name='AllFailed'),
  instanceList?: string(name='InstanceList'),
}

model DeleteResourceInstancesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteResourceInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteResourceInstancesResponseBody(name='body'),
}

async function deleteResourceInstances(ClusterId: string, ResourceId: string, request: DeleteResourceInstancesRequest): DeleteResourceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteResourceInstancesWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

async function deleteResourceInstancesWithOptions(ClusterId: string, ResourceId: string, request: DeleteResourceInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteResourceInstancesResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.allFailed)) {
    query['AllFailed'] = request.allFailed;
  }
  if (!Util.isUnset(request.instanceList)) {
    query['InstanceList'] = request.instanceList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourceInstances',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}/instances`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteResourceLogResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteResourceLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteResourceLogResponseBody(name='body'),
}

async function deleteResourceLog(ClusterId: string, ResourceId: string): DeleteResourceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteResourceLogWithOptions(ClusterId, ResourceId, headers, runtime);
}

async function deleteResourceLogWithOptions(ClusterId: string, ResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteResourceLogResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourceLog',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}/log`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteServiceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceResponseBody(name='body'),
}

async function deleteService(ClusterId: string, ServiceName: string): DeleteServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceWithOptions(ClusterId, ServiceName, headers, runtime);
}

async function deleteServiceWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteServiceAutoScalerResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteServiceAutoScalerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceAutoScalerResponseBody(name='body'),
}

async function deleteServiceAutoScaler(ClusterId: string, ServiceName: string): DeleteServiceAutoScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceAutoScalerWithOptions(ClusterId, ServiceName, headers, runtime);
}

async function deleteServiceAutoScalerWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceAutoScalerResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceAutoScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/autoscaler`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteServiceCronScalerResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteServiceCronScalerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceCronScalerResponseBody(name='body'),
}

async function deleteServiceCronScaler(ClusterId: string, ServiceName: string): DeleteServiceCronScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceCronScalerWithOptions(ClusterId, ServiceName, headers, runtime);
}

async function deleteServiceCronScalerWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceCronScalerResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceCronScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/cronscaler`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteServiceInstancesRequest {
  instanceList?: string(name='InstanceList', description='删除的实例列表，多个实例名字之间逗号隔开'),
}

model DeleteServiceInstancesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteServiceInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceInstancesResponseBody(name='body'),
}

async function deleteServiceInstances(ClusterId: string, ServiceName: string, request: DeleteServiceInstancesRequest): DeleteServiceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceInstancesWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

async function deleteServiceInstancesWithOptions(ClusterId: string, ServiceName: string, request: DeleteServiceInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceInstancesResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceList)) {
    query['InstanceList'] = request.instanceList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceInstances',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/instances`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteServiceMirrorResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteServiceMirrorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceMirrorResponseBody(name='body'),
}

async function deleteServiceMirror(ClusterId: string, ServiceName: string): DeleteServiceMirrorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceMirrorWithOptions(ClusterId, ServiceName, headers, runtime);
}

async function deleteServiceMirrorWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceMirrorResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceMirror',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/mirror`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteStressResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteStressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteStressResponseBody(name='body'),
}

async function deleteStress(ClusterId: string, StressName: string): DeleteStressResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteStressWithOptions(ClusterId, StressName, headers, runtime);
}

async function deleteStressWithOptions(ClusterId: string, StressName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteStressResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  StressName = OpenApiUtil.getEncodeParam(StressName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteStress',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/stress/${ClusterId}/${StressName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeBenchmarkTaskResponseBody = {
  availableAgent?: long(name='AvailableAgent'),
  callerUid?: string(name='CallerUid'),
  desiredAgent?: long(name='DesiredAgent'),
  message?: string(name='Message'),
  parentUid?: string(name='ParentUid'),
  reason?: string(name='Reason'),
  requestId?: string(name='RequestId'),
  serviceName?: string(name='ServiceName'),
  status?: string(name='Status'),
  taskId?: string(name='TaskId'),
  taskName?: string(name='TaskName'),
  token?: string(name='Token'),
}

model DescribeBenchmarkTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBenchmarkTaskResponseBody(name='body'),
}

async function describeBenchmarkTask(ClusterId: string, TaskName: string): DescribeBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeBenchmarkTaskWithOptions(ClusterId, TaskName, headers, runtime);
}

async function describeBenchmarkTaskWithOptions(ClusterId: string, TaskName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeBenchmarkTaskResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  TaskName = OpenApiUtil.getEncodeParam(TaskName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks/${ClusterId}/${TaskName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeBenchmarkTaskReportResponseBody = {
  reportUrl?: string(name='ReportUrl'),
  requestId?: string(name='RequestId'),
}

model DescribeBenchmarkTaskReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBenchmarkTaskReportResponseBody(name='body'),
}

async function describeBenchmarkTaskReport(ClusterId: string, TaskName: string): DescribeBenchmarkTaskReportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeBenchmarkTaskReportWithOptions(ClusterId, TaskName, headers, runtime);
}

async function describeBenchmarkTaskReportWithOptions(ClusterId: string, TaskName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeBenchmarkTaskReportResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  TaskName = OpenApiUtil.getEncodeParam(TaskName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeBenchmarkTaskReport',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks/${ClusterId}/${TaskName}/report`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeResourceResponseBody = {
  clusterId?: string(name='ClusterId'),
  cpuCount?: int32(name='CpuCount'),
  createTime?: string(name='CreateTime'),
  extraData?: string(name='ExtraData'),
  gpuCount?: int32(name='GpuCount'),
  instanceCount?: int32(name='InstanceCount'),
  message?: string(name='Message'),
  ownerUid?: string(name='OwnerUid'),
  postPaidInstanceCount?: int32(name='PostPaidInstanceCount'),
  prePaidInstanceCount?: int32(name='PrePaidInstanceCount'),
  requestId?: string(name='RequestId'),
  resourceId?: string(name='ResourceId'),
  resourceName?: string(name='ResourceName'),
  status?: string(name='Status'),
  updateTime?: string(name='UpdateTime'),
}

model DescribeResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeResourceResponseBody(name='body'),
}

async function describeResource(ClusterId: string, ResourceId: string): DescribeResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeResourceWithOptions(ClusterId, ResourceId, headers, runtime);
}

async function describeResourceWithOptions(ClusterId: string, ResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeResourceResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeResource',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeResourceDLinkResponseBody = {
  auxVSwitchList?: [ string ](name='AuxVSwitchList', description='已打通直连的副VSwitch ID'),
  destinationCIDRs?: string(name='DestinationCIDRs', description='要打通的客户端的网段信息，会将该网段加入到服务端的回包路由中，与VSwitchIdList可二选一'),
  requestId?: string(name='RequestId', description='Id of the request'),
  securityGroupId?: string(name='SecurityGroupId', description='已打通直连的安全组'),
  vSwitchId?: string(name='VSwitchId', description='已打通直连的主VSwitch ID'),
  vpcId?: string(name='VpcId', description='已打通直接的Vpc ID'),
}

model DescribeResourceDLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeResourceDLinkResponseBody(name='body'),
}

async function describeResourceDLink(ClusterId: string, ResourceId: string): DescribeResourceDLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeResourceDLinkWithOptions(ClusterId, ResourceId, headers, runtime);
}

async function describeResourceDLinkWithOptions(ClusterId: string, ResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeResourceDLinkResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeResourceDLink',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}/dlink`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeResourceLogResponseBody = {
  logStore?: string(name='LogStore', description='sls日志库'),
  message?: string(name='Message', description='sls日志信息'),
  projectName?: string(name='ProjectName', description='资源组对应的sls日志管理项目'),
  requestId?: string(name='RequestId', description='Id of the request'),
  status?: string(name='Status', description='资源组状态'),
}

model DescribeResourceLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeResourceLogResponseBody(name='body'),
}

async function describeResourceLog(ClusterId: string, ResourceId: string): DescribeResourceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeResourceLogWithOptions(ClusterId, ResourceId, headers, runtime);
}

async function describeResourceLogWithOptions(ClusterId: string, ResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeResourceLogResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeResourceLog',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}/log`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Service  
}

async function describeService(ClusterId: string, ServiceName: string): DescribeServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceWithOptions(ClusterId, ServiceName, headers, runtime);
}

async function describeServiceWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeServiceAutoScalerResponseBody = {
  currentValues?: map[string]any(name='CurrentValues'),
  maxReplica?: int32(name='MaxReplica', description='服务最大实例数'),
  minReplica?: int32(name='MinReplica', description='服务最小实例数'),
  requestId?: string(name='RequestId', description='Id of the request'),
  serviceName?: string(name='ServiceName', description='服务名字'),
  strategies?: map[string]any(name='Strategies', description='扩缩控制器控制策略'),
}

model DescribeServiceAutoScalerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceAutoScalerResponseBody(name='body'),
}

async function describeServiceAutoScaler(ClusterId: string, ServiceName: string): DescribeServiceAutoScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceAutoScalerWithOptions(ClusterId, ServiceName, headers, runtime);
}

async function describeServiceAutoScalerWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceAutoScalerResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceAutoScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/autoscaler`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeServiceCronScalerResponseBody = {
  excludeDates?: [ string ](name='ExcludeDates'),
  requestId?: string(name='RequestId'),
  scaleJobs?: [ 
    {
      createTime?: string(name='CreateTime'),
      lastProbeTime?: string(name='LastProbeTime'),
      message?: string(name='Message'),
      name?: string(name='Name'),
      schedule?: string(name='Schedule'),
      state?: string(name='State'),
      targetSize?: int32(name='TargetSize'),
    }
  ](name='ScaleJobs'),
  serviceName?: string(name='ServiceName'),
}

model DescribeServiceCronScalerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceCronScalerResponseBody(name='body'),
}

async function describeServiceCronScaler(ClusterId: string, ServiceName: string): DescribeServiceCronScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceCronScalerWithOptions(ClusterId, ServiceName, headers, runtime);
}

async function describeServiceCronScalerWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceCronScalerResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceCronScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/cronscaler`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeServiceLogRequest {
  endTime?: string(name='EndTime', description='查询的结束时间'),
  ip?: string(name='Ip', description='要查询的机器ip'),
  keyword?: string(name='Keyword', description='查询的关键字'),
  pageNum?: long(name='PageNum', description='请求的页码（默认为1）'),
  pageSize?: long(name='PageSize', description='每页的大小（默认为500）'),
  startTime?: string(name='StartTime', description='查询的开始时间'),
}

model DescribeServiceLogResponseBody = {
  logs?: [ string ](name='Logs', description='返回的日志信息'),
  pageNum?: long(name='PageNum', description='当前页码'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: long(name='TotalCount', description='总计数量'),
  totalPageNum?: long(name='TotalPageNum', description='总计页码'),
}

model DescribeServiceLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceLogResponseBody(name='body'),
}

async function describeServiceLog(ClusterId: string, ServiceName: string, request: DescribeServiceLogRequest): DescribeServiceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceLogWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

async function describeServiceLogWithOptions(ClusterId: string, ServiceName: string, request: DescribeServiceLogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceLogResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceLog',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/logs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeServiceMirrorResponseBody = {
  ratio?: string(name='Ratio', description='比例[0,100]'),
  requestId?: string(name='RequestId', description='Id of the request'),
  serviceName?: string(name='ServiceName', description='服务名字'),
  target?: string(name='Target', description='设置流量镜像对服务列表'),
}

model DescribeServiceMirrorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMirrorResponseBody(name='body'),
}

async function describeServiceMirror(ClusterId: string, ServiceName: string): DescribeServiceMirrorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceMirrorWithOptions(ClusterId, ServiceName, headers, runtime);
}

async function describeServiceMirrorWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceMirrorResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceMirror',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/mirror`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeStressResponseBody = {
  availableAgent?: long(name='AvailableAgent'),
  callerUid?: string(name='CallerUid'),
  desiredAgent?: long(name='DesiredAgent'),
  message?: string(name='Message'),
  parentUid?: string(name='ParentUid'),
  reason?: string(name='Reason'),
  requestId?: string(name='RequestId', description='Id of the request'),
  serviceName?: string(name='ServiceName'),
  status?: string(name='Status'),
  stressName?: string(name='StressName'),
  token?: string(name='Token'),
}

model DescribeStressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeStressResponseBody(name='body'),
}

async function describeStress(ClusterId: string, StressName: string): DescribeStressResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeStressWithOptions(ClusterId, StressName, headers, runtime);
}

async function describeStressWithOptions(ClusterId: string, StressName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeStressResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  StressName = OpenApiUtil.getEncodeParam(StressName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeStress',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/stress/${ClusterId}/${StressName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListBenchmarkTaskResponseBody = {
  requestId?: string(name='RequestId'),
  tasks?: [ 
    {
      availableAgent?: long(name='AvailableAgent'),
      createTime?: string(name='CreateTime'),
      message?: string(name='Message'),
      region?: string(name='Region'),
      serviceName?: string(name='ServiceName'),
      status?: string(name='Status'),
      taskId?: string(name='TaskId'),
      taskName?: string(name='TaskName'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='Tasks'),
}

model ListBenchmarkTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListBenchmarkTaskResponseBody(name='body'),
}

async function listBenchmarkTask(): ListBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listBenchmarkTaskWithOptions(headers, runtime);
}

async function listBenchmarkTaskWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListBenchmarkTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListResourceInstanceWorkerRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListResourceInstanceWorkerResponseBody = {
  pageNumber?: int32(name='PageNumber', description='当前页码'),
  pageSize?: int32(name='PageSize', description='每页大小'),
  pods?: [
    ResourceInstanceWorker
  ](name='Pods', description='pod列表'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: int32(name='TotalCount', description='pod总数'),
}

model ListResourceInstanceWorkerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceInstanceWorkerResponseBody(name='body'),
}

async function listResourceInstanceWorker(ClusterId: string, ResourceId: string, InstanceName: string, request: ListResourceInstanceWorkerRequest): ListResourceInstanceWorkerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourceInstanceWorkerWithOptions(ClusterId, ResourceId, InstanceName, request, headers, runtime);
}

async function listResourceInstanceWorkerWithOptions(ClusterId: string, ResourceId: string, InstanceName: string, request: ListResourceInstanceWorkerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListResourceInstanceWorkerResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  InstanceName = OpenApiUtil.getEncodeParam(InstanceName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceInstanceWorker',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}/instance/${InstanceName}/workers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListResourceInstancesRequest {
  chargeType?: string(name='ChargeType', description='付费类型
PrePaid预付费
PostPaid后付费'),
  pageNumber?: int32(name='PageNumber', description='请求的页码（默认为1）'),
  pageSize?: int32(name='PageSize', description='每页的大小（默认为100）'),
}

model ListResourceInstancesResponseBody = {
  instances?: [
    ResourceInstance
  ](name='Instances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: int32(name='TotalCount'),
}

model ListResourceInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceInstancesResponseBody(name='body'),
}

async function listResourceInstances(ClusterId: string, ResourceId: string, request: ListResourceInstancesRequest): ListResourceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourceInstancesWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

async function listResourceInstancesWithOptions(ClusterId: string, ResourceId: string, request: ListResourceInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListResourceInstancesResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceInstances',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListResourceServicesRequest {
  pageNumber?: int32(name='PageNumber', description='请求的页码（默认为1）'),
  pageSize?: int32(name='PageSize', description='每页的大小（默认为100）'),
}

model ListResourceServicesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  services?: [
    Service
  ](name='Services'),
  totalCount?: int32(name='TotalCount'),
}

model ListResourceServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceServicesResponseBody(name='body'),
}

async function listResourceServices(ClusterId: string, ResourceId: string, request: ListResourceServicesRequest): ListResourceServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourceServicesWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

async function listResourceServicesWithOptions(ClusterId: string, ResourceId: string, request: ListResourceServicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListResourceServicesResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceServices',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}/services`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListResourcesRequest {
  pageNumber?: int32(name='PageNumber', description='请求的页码（默认为1）'),
  pageSize?: int32(name='PageSize', description='每页的大小（默认为100）'),
}

model ListResourcesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  resources?: [
    Resource
  ](name='Resources'),
  totalCount?: int32(name='TotalCount'),
}

model ListResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourcesResponseBody(name='body'),
}

async function listResources(request: ListResourcesRequest): ListResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourcesWithOptions(request, headers, runtime);
}

async function listResourcesWithOptions(request: ListResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResources',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListServiceInstancesRequest {
  pageNumber?: int32(name='PageNumber', description='请求的页码（默认为1）'),
  pageSize?: int32(name='PageSize', description='每页的大小（默认为100）'),
}

model ListServiceInstancesResponseBody = {
  instances?: [
    Instance
  ](name='Instances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: int32(name='TotalCount'),
}

model ListServiceInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServiceInstancesResponseBody(name='body'),
}

async function listServiceInstances(ClusterId: string, ServiceName: string, request: ListServiceInstancesRequest): ListServiceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServiceInstancesWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

async function listServiceInstancesWithOptions(ClusterId: string, ServiceName: string, request: ListServiceInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListServiceInstancesResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServiceInstances',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListServicesRequest {
  filter?: string(name='Filter', description='模糊匹配字段（只支持按服务名字模糊匹配）'),
  order?: string(name='Order', description='排序方式（默认降序）'),
  pageNumber?: int32(name='PageNumber', description='请求的页码（默认为1）'),
  pageSize?: int32(name='PageSize', description='每页的大小（默认为100）'),
  sort?: string(name='Sort', description='排序字段 （时间戳类型默认倒序排序）'),
}

model ListServicesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  services?: [
    Service
  ](name='Services'),
  totalCount?: int32(name='TotalCount'),
}

model ListServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServicesResponseBody(name='body'),
}

async function listServices(request: ListServicesRequest): ListServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServicesWithOptions(request, headers, runtime);
}

async function listServicesWithOptions(request: ListServicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListServicesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sort)) {
    query['Sort'] = request.sort;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServices',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListStressesResponseBody = {
  requestId?: string(name='RequestId'),
  stresses?: [ 
    {
      availableAgent?: long(name='AvailableAgent'),
      createTime?: string(name='CreateTime'),
      message?: string(name='Message'),
      region?: string(name='Region'),
      serviceName?: string(name='ServiceName'),
      status?: string(name='Status'),
      stressName?: string(name='StressName'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='Stresses'),
}

model ListStressesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListStressesResponseBody(name='body'),
}

async function listStresses(): ListStressesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listStressesWithOptions(headers, runtime);
}

async function listStressesWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListStressesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListStresses',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/stress`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ReleaseServiceRequest {
  weight?: int32(name='Weight', description='灰度权重，范围 [0, 100]'),
}

model ReleaseServiceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ReleaseServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReleaseServiceResponseBody(name='body'),
}

async function releaseService(ClusterId: string, ServiceName: string, request: ReleaseServiceRequest): ReleaseServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return releaseServiceWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

async function releaseServiceWithOptions(ClusterId: string, ServiceName: string, request: ReleaseServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ReleaseServiceResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var body : map[string]any= {};
  if (!Util.isUnset(request.weight)) {
    body['Weight'] = request.weight;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/release`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ReportStressResponseBody = {
  reportUrl?: string(name='ReportUrl'),
  requestId?: string(name='RequestId'),
}

model ReportStressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReportStressResponseBody(name='body'),
}

async function reportStress(ClusterId: string, StressName: string): ReportStressResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return reportStressWithOptions(ClusterId, StressName, headers, runtime);
}

async function reportStressWithOptions(ClusterId: string, StressName: string, headers: map[string]string, runtime: Util.RuntimeOptions): ReportStressResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  StressName = OpenApiUtil.getEncodeParam(StressName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ReportStress',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/stress/${ClusterId}/${StressName}/report`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StartBenchmarkTaskResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model StartBenchmarkTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartBenchmarkTaskResponseBody(name='body'),
}

async function startBenchmarkTask(ClusterId: string, TaskName: string): StartBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startBenchmarkTaskWithOptions(ClusterId, TaskName, headers, runtime);
}

async function startBenchmarkTaskWithOptions(ClusterId: string, TaskName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartBenchmarkTaskResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  TaskName = OpenApiUtil.getEncodeParam(TaskName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks/${ClusterId}/${TaskName}/start`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StartServiceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model StartServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartServiceResponseBody(name='body'),
}

async function startService(ClusterId: string, ServiceName: string): StartServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startServiceWithOptions(ClusterId, ServiceName, headers, runtime);
}

async function startServiceWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartServiceResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/start`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StartStressResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model StartStressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartStressResponseBody(name='body'),
}

async function startStress(ClusterId: string, StressName: string): StartStressResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startStressWithOptions(ClusterId, StressName, headers, runtime);
}

async function startStressWithOptions(ClusterId: string, StressName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartStressResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  StressName = OpenApiUtil.getEncodeParam(StressName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartStress',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/stress/${ClusterId}/${StressName}/start`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopBenchmarkTaskResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model StopBenchmarkTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopBenchmarkTaskResponseBody(name='body'),
}

async function stopBenchmarkTask(ClusterId: string, TaskName: string): StopBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopBenchmarkTaskWithOptions(ClusterId, TaskName, headers, runtime);
}

async function stopBenchmarkTaskWithOptions(ClusterId: string, TaskName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopBenchmarkTaskResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  TaskName = OpenApiUtil.getEncodeParam(TaskName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks/${ClusterId}/${TaskName}/stop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopServiceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model StopServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopServiceResponseBody(name='body'),
}

async function stopService(ClusterId: string, ServiceName: string): StopServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopServiceWithOptions(ClusterId, ServiceName, headers, runtime);
}

async function stopServiceWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopServiceResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/stop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopStressResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model StopStressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopStressResponseBody(name='body'),
}

async function stopStress(ClusterId: string, StressName: string): StopStressResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopStressWithOptions(ClusterId, StressName, headers, runtime);
}

async function stopStressWithOptions(ClusterId: string, StressName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopStressResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  StressName = OpenApiUtil.getEncodeParam(StressName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopStress',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/stress/${ClusterId}/${StressName}/stop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateBenchmarkTaskRequest {
  body?: string(name='body'),
}

model UpdateBenchmarkTaskResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateBenchmarkTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateBenchmarkTaskResponseBody(name='body'),
}

async function updateBenchmarkTask(ClusterId: string, TaskName: string, request: UpdateBenchmarkTaskRequest): UpdateBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateBenchmarkTaskWithOptions(ClusterId, TaskName, request, headers, runtime);
}

async function updateBenchmarkTaskWithOptions(ClusterId: string, TaskName: string, request: UpdateBenchmarkTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateBenchmarkTaskResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  TaskName = OpenApiUtil.getEncodeParam(TaskName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks/${ClusterId}/${TaskName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateResourceRequest {
  resourceName?: string(name='ResourceName', description='新的资源组名称'),
}

model UpdateResourceResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  resourceId?: string(name='ResourceId'),
  resourceName?: string(name='ResourceName'),
}

model UpdateResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateResourceResponseBody(name='body'),
}

async function updateResource(ClusterId: string, ResourceId: string, request: UpdateResourceRequest): UpdateResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateResourceWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

async function updateResourceWithOptions(ClusterId: string, ResourceId: string, request: UpdateResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateResourceResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.resourceName)) {
    body['ResourceName'] = request.resourceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateResource',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateResourceDLinkRequest {
  destinationCIDRs?: string(name='DestinationCIDRs', description='要打通的客户端的网段信息，会将该网段加入到服务端的回包路由中，与VSwitchIdList可二选一'),
  securityGroupId?: string(name='SecurityGroupId', description='客户端ECS归属的安全组'),
  vSwitchId?: string(name='VSwitchId', description='对端的主VSwitchID，会在该vswitch中创建ENI'),
  vSwitchIdList?: [ string ](name='VSwitchIdList', description='要打通的客户端的vswitch列表，会将这些vswitch对应的网段加入到服务端的回包路由中'),
}

model UpdateResourceDLinkResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateResourceDLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateResourceDLinkResponseBody(name='body'),
}

async function updateResourceDLink(ClusterId: string, ResourceId: string, request: UpdateResourceDLinkRequest): UpdateResourceDLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateResourceDLinkWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

async function updateResourceDLinkWithOptions(ClusterId: string, ResourceId: string, request: UpdateResourceDLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateResourceDLinkResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ResourceId = OpenApiUtil.getEncodeParam(ResourceId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.destinationCIDRs)) {
    body['DestinationCIDRs'] = request.destinationCIDRs;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    body['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    body['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vSwitchIdList)) {
    body['VSwitchIdList'] = request.vSwitchIdList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateResourceDLink',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${ClusterId}/${ResourceId}/dlink`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateServiceRequest {
  body?: string(name='body'),
}

model UpdateServiceResponseBody = {
  message?: string(name='Message', description='请求返回消息。'),
  requestId?: string(name='RequestId', description='请求ID。'),
}

model UpdateServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceResponseBody(name='body'),
}

async function updateService(ClusterId: string, ServiceName: string, request: UpdateServiceRequest): UpdateServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

async function updateServiceWithOptions(ClusterId: string, ServiceName: string, request: UpdateServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateServiceAutoScalerRequest {
  max?: int32(name='Max', description='最大 replica 数，需要大于MinReplica'),
  min?: int32(name='Min', description='最小 replica 数，需要大于0'),
  strategies?: {
    cpu?: float(name='Cpu', description='最大 replica 数，需要大于MinReplica'),
    qps?: float(name='Qps', description='每个实例支持的最大qps数，超出即扩容'),
  }(name='Strategies', description='map 类型的策略定义'),
}

model UpdateServiceAutoScalerResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateServiceAutoScalerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceAutoScalerResponseBody(name='body'),
}

async function updateServiceAutoScaler(ClusterId: string, ServiceName: string, request: UpdateServiceAutoScalerRequest): UpdateServiceAutoScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceAutoScalerWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

async function updateServiceAutoScalerWithOptions(ClusterId: string, ServiceName: string, request: UpdateServiceAutoScalerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceAutoScalerResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var body : map[string]any= {};
  if (!Util.isUnset(request.max)) {
    body['Max'] = request.max;
  }
  if (!Util.isUnset(request.min)) {
    body['Min'] = request.min;
  }
  if (!Util.isUnset(request.strategies)) {
    body['Strategies'] = request.strategies;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceAutoScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/autoscaler`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateServiceCronScalerRequest {
  excludeDates?: [ string ](name='ExcludeDates', description='需要排除的时间点的cron表达式'),
  scaleJobs?: [ 
    {
      name?: string(name='Name'),
      schedule?: string(name='Schedule', description='要执行伸缩任务的cron表达式'),
      targetSize?: int32(name='TargetSize', description='执行伸缩任务的目标replica'),
    }
  ](name='ScaleJobs', description='定时伸缩任务描述'),
}

model UpdateServiceCronScalerResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateServiceCronScalerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceCronScalerResponseBody(name='body'),
}

async function updateServiceCronScaler(ClusterId: string, ServiceName: string, request: UpdateServiceCronScalerRequest): UpdateServiceCronScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceCronScalerWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

async function updateServiceCronScalerWithOptions(ClusterId: string, ServiceName: string, request: UpdateServiceCronScalerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceCronScalerResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var body : map[string]any= {};
  if (!Util.isUnset(request.excludeDates)) {
    body['ExcludeDates'] = request.excludeDates;
  }
  if (!Util.isUnset(request.scaleJobs)) {
    body['ScaleJobs'] = request.scaleJobs;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceCronScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/cronscaler`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateServiceMirrorRequest {
  ratio?: int32(name='Ratio', description='比例 [0, 100]'),
  target?: [ string ](name='Target', description='服务实例列表'),
}

model UpdateServiceMirrorResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateServiceMirrorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceMirrorResponseBody(name='body'),
}

async function updateServiceMirror(ClusterId: string, ServiceName: string, request: UpdateServiceMirrorRequest): UpdateServiceMirrorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceMirrorWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

async function updateServiceMirrorWithOptions(ClusterId: string, ServiceName: string, request: UpdateServiceMirrorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceMirrorResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var body : map[string]any= {};
  if (!Util.isUnset(request.ratio)) {
    body['Ratio'] = request.ratio;
  }
  if (!Util.isUnset(request.target)) {
    body['Target'] = request.target;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceMirror',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/mirror`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateServiceVersionRequest {
  version?: int32(name='Version'),
}

model UpdateServiceVersionResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateServiceVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceVersionResponseBody(name='body'),
}

async function updateServiceVersion(ClusterId: string, ServiceName: string, request: UpdateServiceVersionRequest): UpdateServiceVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceVersionWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

async function updateServiceVersionWithOptions(ClusterId: string, ServiceName: string, request: UpdateServiceVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceVersionResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ServiceName = OpenApiUtil.getEncodeParam(ServiceName);
  var body : map[string]any= {};
  if (!Util.isUnset(request.version)) {
    body['Version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceVersion',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${ClusterId}/${ServiceName}/version`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateStressRequest {
  body?: string(name='body'),
}

model UpdateStressResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateStressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateStressResponseBody(name='body'),
}

async function updateStress(ClusterId: string, StressName: string, request: UpdateStressRequest): UpdateStressResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateStressWithOptions(ClusterId, StressName, request, headers, runtime);
}

async function updateStressWithOptions(ClusterId: string, StressName: string, request: UpdateStressRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateStressResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  StressName = OpenApiUtil.getEncodeParam(StressName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateStress',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/stress/${ClusterId}/${StressName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

