/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-beijing = 'pai-eas.cn-beijing.aliyuncs.com',
    cn-zhangjiakou = 'pai-eas.cn-zhangjiakou.aliyuncs.com',
    cn-hangzhou = 'pai-eas.cn-hangzhou.aliyuncs.com',
    cn-shanghai = 'pai-eas.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'pai-eas.cn-shenzhen.aliyuncs.com',
    cn-hongkong = 'pai-eas.cn-hongkong.aliyuncs.com',
    ap-southeast-1 = 'pai-eas.ap-southeast-1.aliyuncs.com',
    ap-southeast-5 = 'pai-eas.ap-southeast-5.aliyuncs.com',
    us-east-1 = 'pai-eas.us-east-1.aliyuncs.com',
    us-west-1 = 'pai-eas.us-west-1.aliyuncs.com',
    eu-central-1 = 'pai-eas.eu-central-1.aliyuncs.com',
    ap-south-1 = 'pai-eas.ap-south-1.aliyuncs.com',
    cn-shanghai-finance-1 = 'pai-eas.cn-shanghai-finance-1.aliyuncs.com',
    cn-north-2-gov-1 = 'pai-eas.cn-north-2-gov-1.aliyuncs.com',
    cn-chengdu = 'pai-eas.cn-chengdu.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('eas', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ContainerInfo {
  currentReaon?: string(name='CurrentReaon'),
  currentStatus?: string(name='CurrentStatus'),
  currentTimestamp?: string(name='CurrentTimestamp'),
  image?: string(name='Image'),
  lastReason?: string(name='LastReason'),
  lastStatus?: string(name='LastStatus'),
  lastTimestamp?: string(name='LastTimestamp'),
  name?: string(name='Name'),
  port?: int32(name='Port'),
  ready?: boolean(name='Ready'),
  restartCount?: int32(name='RestartCount'),
}

model Group {
  accessToken?: string(name='AccessToken'),
  clusterId?: string(name='ClusterId'),
  createTime?: string(name='CreateTime'),
  internetEndpoint?: string(name='InternetEndpoint'),
  intranetEndpoint?: string(name='IntranetEndpoint'),
  name?: string(name='Name'),
  queueService?: string(name='QueueService'),
  updateTime?: string(name='UpdateTime'),
}

model Instance {
  currentAmount?: float(name='CurrentAmount', example='0.444'),
  hostIP?: string(name='HostIP'),
  hostName?: string(name='HostName'),
  innerIP?: string(name='InnerIP'),
  instanceName?: string(name='InstanceName'),
  instancePort?: int32(name='InstancePort'),
  isSpot?: boolean(name='IsSpot', example='false'),
  isolated?: boolean(name='Isolated', example='false'),
  lastState?: [  map[string]any ](name='LastState'),
  namespace?: string(name='Namespace'),
  originalAmount?: float(name='OriginalAmount', example='2.2'),
  readyProcesses?: int32(name='ReadyProcesses'),
  reason?: string(name='Reason'),
  resourceType?: string(name='ResourceType', example='PublicResource'),
  restartCount?: int32(name='RestartCount'),
  role?: string(name='Role', example='Standard'),
  startAt?: string(name='StartAt'),
  status?: string(name='Status'),
  tenantHostIP?: string(name='TenantHostIP', example='192.168.0.39'),
  tenantInstanceIP?: string(name='TenantInstanceIP', example='192.168.0.39'),
  totalProcesses?: int32(name='TotalProcesses'),
}

model Resource {
  clusterId?: string(name='ClusterId'),
  cpuCount?: int32(name='CpuCount'),
  createTime?: string(name='CreateTime'),
  extraData?: map[string]any(name='ExtraData'),
  gpuCount?: int32(name='GpuCount'),
  instanceCount?: int32(name='InstanceCount'),
  message?: string(name='Message'),
  postPaidInstanceCount?: int32(name='PostPaidInstanceCount'),
  prePaidInstanceCount?: int32(name='PrePaidInstanceCount'),
  resourceId?: string(name='ResourceId'),
  resourceName?: string(name='ResourceName'),
  resourceType?: string(name='ResourceType'),
  status?: string(name='Status'),
  updateTime?: string(name='UpdateTime'),
}

model ResourceInstance {
  arch?: string(name='Arch'),
  autoRenewal?: boolean(name='AutoRenewal'),
  chargeType?: string(name='ChargeType'),
  createTime?: string(name='CreateTime'),
  expiredTime?: string(name='ExpiredTime'),
  instanceCpuCount?: int32(name='InstanceCpuCount'),
  instanceGpuCount?: int32(name='InstanceGpuCount'),
  instanceGpuMemory?: string(name='InstanceGpuMemory'),
  instanceId?: string(name='InstanceId'),
  instanceIp?: string(name='InstanceIp'),
  instanceMemory?: string(name='InstanceMemory'),
  instanceName?: string(name='InstanceName'),
  instanceStatus?: string(name='InstanceStatus'),
  instanceSystemDiskSize?: int32(name='InstanceSystemDiskSize'),
  instanceTenantIp?: string(name='InstanceTenantIp'),
  instanceType?: string(name='InstanceType'),
  instanceUsedCpu?: float(name='InstanceUsedCpu'),
  instanceUsedGpu?: float(name='InstanceUsedGpu'),
  instanceUsedGpuMemory?: string(name='InstanceUsedGpuMemory'),
  instanceUsedMemory?: string(name='InstanceUsedMemory'),
  region?: string(name='Region'),
  resourceId?: string(name='ResourceId'),
  zone?: string(name='Zone'),
}

model ResourceInstanceWorker {
  cpuLimit?: int32(name='CpuLimit'),
  cpuRequest?: int32(name='CpuRequest'),
  gpuLimit?: int32(name='GpuLimit'),
  gpuRequest?: int32(name='GpuRequest'),
  memoryLimit?: int32(name='MemoryLimit'),
  memoryRquest?: int32(name='MemoryRquest'),
  name?: string(name='Name'),
  ready?: boolean(name='Ready'),
  restartCount?: int32(name='RestartCount'),
  serviceName?: string(name='ServiceName'),
  startTime?: string(name='StartTime'),
  status?: string(name='Status'),
}

model Service {
  accessToken?: string(name='AccessToken'),
  appConfig?: string(name='AppConfig'),
  appSpecName?: string(name='AppSpecName'),
  appType?: string(name='AppType'),
  appVersion?: string(name='AppVersion'),
  callerUid?: string(name='CallerUid'),
  cpu?: int32(name='Cpu'),
  createTime?: string(name='CreateTime'),
  currentVersion?: int32(name='CurrentVersion'),
  extraData?: string(name='ExtraData'),
  gpu?: int32(name='Gpu'),
  image?: string(name='Image'),
  internetEndpoint?: string(name='InternetEndpoint'),
  intranetEndpoint?: string(name='IntranetEndpoint'),
  labels?: [ 
    {
      labelKey?: string(name='LabelKey'),
      labelValue?: string(name='LabelValue'),
    }
  ](name='Labels'),
  latestVersion?: int32(name='LatestVersion'),
  memory?: int32(name='Memory'),
  message?: string(name='Message'),
  namespace?: string(name='Namespace'),
  parentUid?: string(name='ParentUid'),
  pendingInstance?: int32(name='PendingInstance'),
  reason?: string(name='Reason'),
  region?: string(name='Region'),
  requestId?: string(name='RequestId'),
  resource?: string(name='Resource'),
  resourceAlias?: string(name='ResourceAlias'),
  role?: string(name='Role'),
  roleAttrs?: string(name='RoleAttrs'),
  runningInstance?: int32(name='RunningInstance'),
  safetyLock?: string(name='SafetyLock'),
  secondaryInternetEndpoint?: string(name='SecondaryInternetEndpoint'),
  secondaryIntranetEndpoint?: string(name='SecondaryIntranetEndpoint'),
  serviceConfig?: string(name='ServiceConfig'),
  serviceGroup?: string(name='ServiceGroup'),
  serviceId?: string(name='ServiceId'),
  serviceName?: string(name='ServiceName'),
  serviceUid?: string(name='ServiceUid'),
  source?: string(name='Source'),
  status?: string(name='Status'),
  totalInstance?: int32(name='TotalInstance'),
  updateTime?: string(name='UpdateTime'),
  weight?: int32(name='Weight'),
  workspaceId?: string(name='WorkspaceId'),
}

model CommitServiceResponseBody = {
  message?: string(name='Message', example='Success'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
}

model CommitServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CommitServiceResponseBody(name='body'),
}

async function commitServiceWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): CommitServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CommitService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/commit`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function commitService(ClusterId: string, ServiceName: string): CommitServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return commitServiceWithOptions(ClusterId, ServiceName, headers, runtime);
}

model CreateAppServiceRequest {
  quotaId?: string(name='QuotaId', description='The quota ID.', example='abcdef'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='123456'),
  appType?: string(name='AppType', description='The application service type.

Valid values:

*   LLM

    <!-- -->

    <!-- -->

    <!-- -->', example='LLM'),
  appVersion?: string(name='AppVersion', description='The application version.', example='v1'),
  config?: map[string]any(name='Config', description='Additional configurations that are required for the service deployment.'),
  replicas?: int32(name='Replicas', description='The number of instances.', example='1'),
  serviceName?: string(name='ServiceName', description='The service name.', example='foo'),
  serviceSpec?: string(name='ServiceSpec', description='The service specifications.', example='llama_7b_fp16'),
}

model CreateAppServiceResponseBody = {
  internetEndpoint?: string(name='InternetEndpoint', description='The public endpoint of the service.', example='http://pai-eas.cn-shanghai.****'),
  intranetEndpoint?: string(name='IntranetEndpoint', description='The internal endpoint of the service.', example='http://pai-eas-vpc.cn-shanghai.****'),
  region?: string(name='Region', description='The region ID of the service.', example='cn-shanghai'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  serviceId?: string(name='ServiceId', description='The service ID.', example='eas-m-aaxxxddf'),
  serviceName?: string(name='ServiceName', description='The service name.', example='foo'),
  status?: string(name='Status', description='The service state.', example='Creating'),
}

model CreateAppServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAppServiceResponseBody(name='body'),
}

async function createAppServiceWithOptions(request: CreateAppServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAppServiceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.quotaId)) {
    query['QuotaId'] = request.quotaId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.appType)) {
    body['AppType'] = request.appType;
  }
  if (!Util.isUnset(request.appVersion)) {
    body['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.config)) {
    body['Config'] = request.config;
  }
  if (!Util.isUnset(request.replicas)) {
    body['Replicas'] = request.replicas;
  }
  if (!Util.isUnset(request.serviceName)) {
    body['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.serviceSpec)) {
    body['ServiceSpec'] = request.serviceSpec;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAppService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/app_services`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAppService(request: CreateAppServiceRequest): CreateAppServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAppServiceWithOptions(request, headers, runtime);
}

model CreateBenchmarkTaskRequest {
  body?: string(name='body', description='The request body. The body includes the parameters that are set to create a stress testing task.', example='{
    "base": {
        "duration": 600
    },
    "service": {
        "serviceName": "test_service",
        "requestToken": "test_token"
    },
    "data": {
        "path": "https://larec-benchmark-cd.oss-cn-chengdu.aliyuncs.com/youbei/sv_dbmtl/data/youbei.warmup.tf.bin",
        "dataType": "binary"
    },
    "optional": {
       "maxRt": 100
    }
}'),
}

model CreateBenchmarkTaskResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Benchmark  task [foo] is Creating'),
  region?: string(name='Region', description='The ID of the region where the stress testing task is performed.', example='cn-shanghai'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82********'),
  taskName?: string(name='TaskName', description='The name of the stress testing task.', example='benchmark-larec-test-1076'),
}

model CreateBenchmarkTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBenchmarkTaskResponseBody(name='body'),
}

async function createBenchmarkTaskWithOptions(request: CreateBenchmarkTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateBenchmarkTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CreateBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBenchmarkTask(request: CreateBenchmarkTaskRequest): CreateBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createBenchmarkTaskWithOptions(request, headers, runtime);
}

model CreateGatewayRequest {
  resourceName?: string(name='ResourceName', description='The name of the resource group.', example='eas-r-4gt8twzwllfo******'),
  enableInternet?: boolean(name='EnableInternet', description='Specifies whether to enable Internet access. Default value: false.

Valid values:

*   true

    <!-- -->

    <!-- -->

    <!-- -->

*   false

    <!-- -->

    <!-- -->

    <!-- -->', example='false'),
  enableIntranet?: boolean(name='EnableIntranet', description='Specifies whether to enable internal network access. Default value: true.', example='true'),
  instanceType?: string(name='InstanceType', description='The instance type used for the private gateway.', example='ecs.c6.4xlarge'),
  name?: string(name='Name', description='The private gateway alias.', example='mygateway1'),
}

model CreateGatewayResponseBody = {
  clusterId?: string(name='ClusterId', description='The region ID of the private gateway.', example='cn-hangzhou'),
  gatewayId?: string(name='GatewayId', description='The private gateway ID.', example='gw-1uhcqmsc7x22******'),
  message?: string(name='Message', description='The returned message.', example='Successfully create gateway.'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model CreateGatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGatewayResponseBody(name='body'),
}

async function createGatewayWithOptions(request: CreateGatewayRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateGatewayResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.enableInternet)) {
    body['EnableInternet'] = request.enableInternet;
  }
  if (!Util.isUnset(request.enableIntranet)) {
    body['EnableIntranet'] = request.enableIntranet;
  }
  if (!Util.isUnset(request.instanceType)) {
    body['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateGateway',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGateway(request: CreateGatewayRequest): CreateGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createGatewayWithOptions(request, headers, runtime);
}

model CreateGatewayIntranetLinkedVpcRequest {
  vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.', example='vsw-8vbqn2at0kljjxxxx****'),
  vpcId?: string(name='VpcId', description='The virtual private cloud (VPC) ID.', example='vpc-uf66uio7md****'),
}

model CreateGatewayIntranetLinkedVpcResponseBody = {
  gatewayId?: string(name='GatewayId', description='The private gateway ID.', example='gw-1uhcqmsc7x22******'),
  message?: string(name='Message', description='The returned message.', example='Successfully add intranet linked vpc for gateway'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model CreateGatewayIntranetLinkedVpcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGatewayIntranetLinkedVpcResponseBody(name='body'),
}

async function createGatewayIntranetLinkedVpcWithOptions(ClusterId: string, GatewayId: string, request: CreateGatewayIntranetLinkedVpcRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateGatewayIntranetLinkedVpcResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGatewayIntranetLinkedVpc',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GatewayId)}/intranet_endpoint_linked_vpc`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGatewayIntranetLinkedVpc(ClusterId: string, GatewayId: string, request: CreateGatewayIntranetLinkedVpcRequest): CreateGatewayIntranetLinkedVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createGatewayIntranetLinkedVpcWithOptions(ClusterId, GatewayId, request, headers, runtime);
}

model CreateResourceRequest {
  autoRenewal?: boolean(name='AutoRenewal', description='Specifies whether to enable auto-renewal. Valid values: false (default)

*   true', example='false'),
  chargeType?: string(name='ChargeType', description='The billing method of the instance. Valid values:

*   PrePaid: the subscription billing method.
*   PostPaid: the pay-as-you-go billing method.', example='PostPaid'),
  ecsInstanceCount?: int32(name='EcsInstanceCount', description='The number of ECS instances.', example='5'),
  ecsInstanceType?: string(name='EcsInstanceType', description='The type of the Elastic Compute Service (ECS) instance.', example='ecs.c6.8xlarge'),
  resourceType?: string(name='ResourceType', example='Dedicated'),
  selfManagedResourceOptions?: {
    externalClusterId?: string(name='ExternalClusterId', description='自运维集群Id', example='cf0386f250f2545689ca7fdd1cd******'),
    nodeMatchLabels?: map[string]string(name='NodeMatchLabels', description='节点的标签键值对集合'),
    nodeTolerations?: [ 
      {
        effect?: string(name='effect', description='效果', example='NoSchedule'),
        key?: string(name='key', description='键名', example='key1'),
        operator?: string(name='operator', description='键名和键值的关系', example='Equal'),
        value?: string(name='value', description='键值', example='value1'),
      }
    ](name='NodeTolerations', description='节点污点的容忍度列表'),
    roleName?: string(name='RoleName', description='授予云服务PAI-EAS相关权限的RAM角色名称', example='clusterrole'),
  }(name='SelfManagedResourceOptions', description='自运维资源组配置选项'),
  systemDiskSize?: int32(name='SystemDiskSize', description='The size of the system disk. Unit: GiB. Valid values: 200 to 2000. Default value: 200.', example='200'),
  zone?: string(name='Zone', description='The zone to which the instance belongs.', example='cn-shanghai-f'),
}

model CreateResourceResponseBody = {
  clusterId?: string(name='ClusterId', example='cn-shanghai'),
  instanceIds?: [ string ](name='InstanceIds'),
  ownerUid?: string(name='OwnerUid', example='14401087478****'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
  resourceId?: string(name='ResourceId', example='eas-r-h7lcw24dyqztwxxxxxx'),
  resourceName?: string(name='ResourceName', example='MyResource'),
}

model CreateResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateResourceResponseBody(name='body'),
}

async function createResourceWithOptions(request: CreateResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoRenewal)) {
    body['AutoRenewal'] = request.autoRenewal;
  }
  if (!Util.isUnset(request.chargeType)) {
    body['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.ecsInstanceCount)) {
    body['EcsInstanceCount'] = request.ecsInstanceCount;
  }
  if (!Util.isUnset(request.ecsInstanceType)) {
    body['EcsInstanceType'] = request.ecsInstanceType;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.selfManagedResourceOptions)) {
    body['SelfManagedResourceOptions'] = request.selfManagedResourceOptions;
  }
  if (!Util.isUnset(request.systemDiskSize)) {
    body['SystemDiskSize'] = request.systemDiskSize;
  }
  if (!Util.isUnset(request.zone)) {
    body['Zone'] = request.zone;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateResource',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createResource(request: CreateResourceRequest): CreateResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createResourceWithOptions(request, headers, runtime);
}

model CreateResourceInstancesRequest {
  autoRenewal?: boolean(name='AutoRenewal', example='false'),
  chargeType?: string(name='ChargeType', example='PrePaid'),
  ecsInstanceCount?: int32(name='EcsInstanceCount', example='5'),
  ecsInstanceType?: string(name='EcsInstanceType', example='ecs.s6-c1m2.xlarge'),
  systemDiskSize?: int32(name='SystemDiskSize', example='200'),
  userData?: string(name='UserData', example='x112223333'),
  zone?: string(name='Zone', example='cn-shanghai-f'),
}

model CreateResourceInstancesResponseBody = {
  instanceIds?: [ string ](name='InstanceIds'),
  message?: string(name='Message', example='Create 5 new ecs instance(s) in resource [eas-r-asdasdasd] successfully'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
}

model CreateResourceInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateResourceInstancesResponseBody(name='body'),
}

async function createResourceInstancesWithOptions(ClusterId: string, ResourceId: string, request: CreateResourceInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateResourceInstancesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoRenewal)) {
    body['AutoRenewal'] = request.autoRenewal;
  }
  if (!Util.isUnset(request.chargeType)) {
    body['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.ecsInstanceCount)) {
    body['EcsInstanceCount'] = request.ecsInstanceCount;
  }
  if (!Util.isUnset(request.ecsInstanceType)) {
    body['EcsInstanceType'] = request.ecsInstanceType;
  }
  if (!Util.isUnset(request.systemDiskSize)) {
    body['SystemDiskSize'] = request.systemDiskSize;
  }
  if (!Util.isUnset(request.userData)) {
    body['UserData'] = request.userData;
  }
  if (!Util.isUnset(request.zone)) {
    body['Zone'] = request.zone;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateResourceInstances',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/instances`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createResourceInstances(ClusterId: string, ResourceId: string, request: CreateResourceInstancesRequest): CreateResourceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createResourceInstancesWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

model CreateResourceLogRequest {
  logStore?: string(name='LogStore', example='access_log'),
  projectName?: string(name='ProjectName', example='eas-r-asdasdasd-sls'),
}

model CreateResourceLogResponseBody = {
  message?: string(name='Message', example='Resource [eas-r-asdasdasd] is deleted.'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
}

model CreateResourceLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateResourceLogResponseBody(name='body'),
}

async function createResourceLogWithOptions(ClusterId: string, ResourceId: string, request: CreateResourceLogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateResourceLogResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.logStore)) {
    body['LogStore'] = request.logStore;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateResourceLog',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/log`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createResourceLog(ClusterId: string, ResourceId: string, request: CreateResourceLogRequest): CreateResourceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createResourceLogWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

model CreateServiceRequest {
  develop?: string(name='Develop', description='Specifies whether to enter development mode.

Valid values:

*   true

    <!-- -->

    <!-- -->

    <!-- -->

*   false

    <!-- -->

    <!-- -->

    <!-- -->', example='true'),
  labels?: map[string]string(name='Labels'),
  workspaceId?: string(name='WorkspaceId', example='123456'),
  body?: string(name='body', example='{
      "name": "foo",
      "model_path": "http://path/to/model.tar.gz",
      "processor": "tensorflow_cpu",
      "metadata": {
            "instance": 2,
            "memory": 7000,
            "cpu": 4
      }
}'),
}

model CreateServiceShrinkRequest {
  develop?: string(name='Develop', description='Specifies whether to enter development mode.

Valid values:

*   true

    <!-- -->

    <!-- -->

    <!-- -->

*   false

    <!-- -->

    <!-- -->

    <!-- -->', example='true'),
  labelsShrink?: string(name='Labels'),
  workspaceId?: string(name='WorkspaceId', example='123456'),
  body?: string(name='body', example='{
      "name": "foo",
      "model_path": "http://path/to/model.tar.gz",
      "processor": "tensorflow_cpu",
      "metadata": {
            "instance": 2,
            "memory": 7000,
            "cpu": 4
      }
}'),
}

model CreateServiceResponseBody = {
  internetEndpoint?: string(name='InternetEndpoint', example='http://pai-eas.vpc.cn-shanghai.****'),
  intranetEndpoint?: string(name='IntranetEndpoint', example='http://pai-eas.cn-shanghai.****'),
  region?: string(name='Region', example='cn-shanghai'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
  serviceId?: string(name='ServiceId', example='eas-m-aaxxxddf'),
  serviceName?: string(name='ServiceName', example='yourname'),
  status?: string(name='Status', example='Creating'),
}

model CreateServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceResponseBody(name='body'),
}

async function createServiceWithOptions(tmpReq: CreateServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceResponse {
  Util.validateModel(tmpReq);
  var request = new CreateServiceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.labels)) {
    request.labelsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.labels, 'Labels', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.develop)) {
    query['Develop'] = request.develop;
  }
  if (!Util.isUnset(request.labelsShrink)) {
    query['Labels'] = request.labelsShrink;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CreateService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createService(request: CreateServiceRequest): CreateServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceWithOptions(request, headers, runtime);
}

model CreateServiceAutoScalerRequest {
  behavior?: {
    onZero?: {
      scaleDownGracePeriodSeconds?: int32(name='scaleDownGracePeriodSeconds', description='The time window that is required before the number of instances is reduced to 0. The number of instances can be reduced to 0 only if no request is available or no traffic exists in the specified time window. Default value: 600.', example='600'),
      scaleUpActivationReplicas?: int32(name='scaleUpActivationReplicas', description='The number of instances that you want to create at a time if the number of instances is scaled out from 0. Default value: 1.', example='1'),
    }(name='onZero', description='The operation that reduces the number of instances to 0.'),
    scaleDown?: {
      stabilizationWindowSeconds?: int32(name='stabilizationWindowSeconds', description='The time window that is required before the scale-in operation is performed. The scale-in operation can be performed only if the specified metric drops below the specified threshold in the specified time window. Default value: 300.', example='300'),
    }(name='scaleDown', description='The scale-in operation.'),
    scaleUp?: {
      stabilizationWindowSeconds?: int32(name='stabilizationWindowSeconds', description='The time window that is required before the scale-out operation is performed. The scale-out operation can be performed only if the specified metric exceeds the specified threshold in the specified time window. Default value: 0.', example='0'),
    }(name='scaleUp', description='The scale-out operation.'),
  }(name='behavior', description='The Autoscaler operation.'),
  max?: int32(name='max', description='The maximum number of instances. The value must be greater than that of the min parameter.', example='8'),
  min?: int32(name='min', description='The minimum number of instances. The value must be greater than 0.', example='2'),
  scaleStrategies?: [ 
    {
      metricName?: string(name='metricName', description='The name of the metric for triggering auto scaling. Valid values:

*   QPS: the queries per second (QPS) for an individual instance.
*   CPU: the CPU utilization.', example='QPS'),
      service?: string(name='service', description='The service for which the metric is specified. If you do not set this parameter, the current service is specified by default.', example='demo_svc'),
      threshold?: float(name='threshold', description='The threshold of the metric that triggers auto scaling.

*   If you set metricName to QPS, scale-out is triggered when the average QPS for a single instance is greater than this threshold.
*   If you set metricName to CPU, scale-out is triggered when the average CPU utilization for a single instance is greater than this threshold.', example='10'),
    }
  ](name='scaleStrategies', description='The Autoscaler strategies.'),
}

model CreateServiceAutoScalerResponseBody = {
  message?: string(name='Message', example='Succeed to auto scale service [foo]'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
}

model CreateServiceAutoScalerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceAutoScalerResponseBody(name='body'),
}

async function createServiceAutoScalerWithOptions(ClusterId: string, ServiceName: string, request: CreateServiceAutoScalerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceAutoScalerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.behavior)) {
    body['behavior'] = request.behavior;
  }
  if (!Util.isUnset(request.max)) {
    body['max'] = request.max;
  }
  if (!Util.isUnset(request.min)) {
    body['min'] = request.min;
  }
  if (!Util.isUnset(request.scaleStrategies)) {
    body['scaleStrategies'] = request.scaleStrategies;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceAutoScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/autoscaler`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createServiceAutoScaler(ClusterId: string, ServiceName: string, request: CreateServiceAutoScalerRequest): CreateServiceAutoScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceAutoScalerWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model CreateServiceCronScalerRequest {
  excludeDates?: [ string ](name='ExcludeDates'),
  scaleJobs?: [ 
    {
      name?: string(name='Name', example='scale-job-1'),
      schedule?: string(name='Schedule', example='0 18 * * * *'),
      targetSize?: int32(name='TargetSize', example='1'),
    }
  ](name='ScaleJobs'),
}

model CreateServiceCronScalerResponseBody = {
  message?: string(name='Message', example='Create cron scaler for service [foo] successfully'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
}

model CreateServiceCronScalerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceCronScalerResponseBody(name='body'),
}

async function createServiceCronScalerWithOptions(ClusterId: string, ServiceName: string, request: CreateServiceCronScalerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceCronScalerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.excludeDates)) {
    body['ExcludeDates'] = request.excludeDates;
  }
  if (!Util.isUnset(request.scaleJobs)) {
    body['ScaleJobs'] = request.scaleJobs;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceCronScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/cronscaler`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createServiceCronScaler(ClusterId: string, ServiceName: string, request: CreateServiceCronScalerRequest): CreateServiceCronScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceCronScalerWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model CreateServiceMirrorRequest {
  ratio?: int32(name='Ratio', example='30'),
  target?: [ string ](name='Target'),
}

model CreateServiceMirrorResponseBody = {
  message?: string(name='Message', example='Traffic mirroring is ON for service [foo] in region [cn-shanghia], ratio [70%]'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82***'),
}

model CreateServiceMirrorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceMirrorResponseBody(name='body'),
}

async function createServiceMirrorWithOptions(ClusterId: string, ServiceName: string, request: CreateServiceMirrorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceMirrorResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ratio)) {
    body['Ratio'] = request.ratio;
  }
  if (!Util.isUnset(request.target)) {
    body['Target'] = request.target;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceMirror',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/mirror`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createServiceMirror(ClusterId: string, ServiceName: string, request: CreateServiceMirrorRequest): CreateServiceMirrorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceMirrorWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model DeleteBenchmarkTaskResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Benchmark task [benchmark-test-service-234c] is Deleting'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model DeleteBenchmarkTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBenchmarkTaskResponseBody(name='body'),
}

async function deleteBenchmarkTaskWithOptions(ClusterId: string, TaskName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteBenchmarkTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(TaskName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBenchmarkTask(ClusterId: string, TaskName: string): DeleteBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteBenchmarkTaskWithOptions(ClusterId, TaskName, headers, runtime);
}

model DeleteGatewayResponseBody = {
  gatewayId?: string(name='GatewayId', description='The private gateway ID.', example='gw-1uhcqmsc7x22******'),
  message?: string(name='Message', description='The returned message.', example='Gateway is deleted.'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model DeleteGatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGatewayResponseBody(name='body'),
}

async function deleteGatewayWithOptions(ClusterId: string, GatewayId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteGatewayResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteGateway',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GatewayId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGateway(ClusterId: string, GatewayId: string): DeleteGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteGatewayWithOptions(ClusterId, GatewayId, headers, runtime);
}

model DeleteGatewayIntranetLinkedVpcRequest {
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.', example='vsw-8vbqn2at0kljjxxxx****'),
  vpcId?: string(name='VpcId', description='The virtual private cloud (VPC) ID.', example='vpc-uf66uio7md****'),
}

model DeleteGatewayIntranetLinkedVpcResponseBody = {
  gatewayId?: string(name='GatewayId', description='The private gateway ID.', example='gw-1uhcqmsc7x22******'),
  message?: string(name='Message', description='The returned message.', example='Successfully delete intranet linked vpc for gateway'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model DeleteGatewayIntranetLinkedVpcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGatewayIntranetLinkedVpcResponseBody(name='body'),
}

async function deleteGatewayIntranetLinkedVpcWithOptions(ClusterId: string, GatewayId: string, request: DeleteGatewayIntranetLinkedVpcRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteGatewayIntranetLinkedVpcResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGatewayIntranetLinkedVpc',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GatewayId)}/intranet_endpoint_linked_vpc`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGatewayIntranetLinkedVpc(ClusterId: string, GatewayId: string, request: DeleteGatewayIntranetLinkedVpcRequest): DeleteGatewayIntranetLinkedVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteGatewayIntranetLinkedVpcWithOptions(ClusterId, GatewayId, request, headers, runtime);
}

model DeleteResourceResponseBody = {
  message?: string(name='Message', example='Resource [eas-r-asdasdasd] is deleted.'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82-9624-EC2B1779848E'),
}

model DeleteResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteResourceResponseBody(name='body'),
}

async function deleteResourceWithOptions(ClusterId: string, ResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteResourceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteResource',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteResource(ClusterId: string, ResourceId: string): DeleteResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteResourceWithOptions(ClusterId, ResourceId, headers, runtime);
}

model DeleteResourceDLinkResponseBody = {
  message?: string(name='Message', example='Network interfaces are deleting'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
}

model DeleteResourceDLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteResourceDLinkResponseBody(name='body'),
}

async function deleteResourceDLinkWithOptions(ClusterId: string, ResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteResourceDLinkResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourceDLink',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/dlink`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteResourceDLink(ClusterId: string, ResourceId: string): DeleteResourceDLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteResourceDLinkWithOptions(ClusterId, ResourceId, headers, runtime);
}

model DeleteResourceInstancesRequest {
  allFailed?: boolean(name='AllFailed', example='true'),
  instanceList?: string(name='InstanceList', example='eas-i-xxxxxxx,eas-i-xxxxxxx'),
}

model DeleteResourceInstancesResponseBody = {
  message?: string(name='Message', example='Instances eas-i-011227132046,eas-i-011227132046 are deleting'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
}

model DeleteResourceInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteResourceInstancesResponseBody(name='body'),
}

async function deleteResourceInstancesWithOptions(ClusterId: string, ResourceId: string, request: DeleteResourceInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteResourceInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.allFailed)) {
    query['AllFailed'] = request.allFailed;
  }
  if (!Util.isUnset(request.instanceList)) {
    query['InstanceList'] = request.instanceList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourceInstances',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/instances`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteResourceInstances(ClusterId: string, ResourceId: string, request: DeleteResourceInstancesRequest): DeleteResourceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteResourceInstancesWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

model DeleteResourceLogResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Log service for resource [eas-r-asdasdasd] is deleting'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model DeleteResourceLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteResourceLogResponseBody(name='body'),
}

async function deleteResourceLogWithOptions(ClusterId: string, ResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteResourceLogResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourceLog',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/log`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteResourceLog(ClusterId: string, ResourceId: string): DeleteResourceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteResourceLogWithOptions(ClusterId, ResourceId, headers, runtime);
}

model DeleteServiceResponseBody = {
  message?: string(name='Message', example='Service [foo] in region [cn-shanghai] is terminating'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
}

model DeleteServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceResponseBody(name='body'),
}

async function deleteServiceWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteService(ClusterId: string, ServiceName: string): DeleteServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceWithOptions(ClusterId, ServiceName, headers, runtime);
}

model DeleteServiceAutoScalerResponseBody = {
  message?: string(name='Message', example='Autoscaler for service [foo] deleted successfully'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
}

model DeleteServiceAutoScalerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceAutoScalerResponseBody(name='body'),
}

async function deleteServiceAutoScalerWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceAutoScalerResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceAutoScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/autoscaler`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteServiceAutoScaler(ClusterId: string, ServiceName: string): DeleteServiceAutoScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceAutoScalerWithOptions(ClusterId, ServiceName, headers, runtime);
}

model DeleteServiceCronScalerResponseBody = {
  message?: string(name='Message', example='Cronscaler for service [foo] deleted successfully'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
}

model DeleteServiceCronScalerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceCronScalerResponseBody(name='body'),
}

async function deleteServiceCronScalerWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceCronScalerResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceCronScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/cronscaler`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteServiceCronScaler(ClusterId: string, ServiceName: string): DeleteServiceCronScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceCronScalerWithOptions(ClusterId, ServiceName, headers, runtime);
}

model DeleteServiceInstancesRequest {
  container?: string(name='Container', description='The name of the container whose process needs to be restarted. This parameter takes effect only if the SoftRestart parameter is set to true.', example='worker0'),
  instanceList?: string(name='InstanceList', example='foo-rdsbxxxx,foo-rdsaxxxx'),
  softRestart?: boolean(name='SoftRestart', description='Specifies whether to restart only the container process without recreating the instance. Default value: false. Valid values: true and false.', example='true'),
}

model DeleteServiceInstancesResponseBody = {
  message?: string(name='Message', example='Instance(s) [foo-rdsb,foo-rdsa]  for service [foo] in region [cn-shanghai] was deleted successfully'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
}

model DeleteServiceInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceInstancesResponseBody(name='body'),
}

async function deleteServiceInstancesWithOptions(ClusterId: string, ServiceName: string, request: DeleteServiceInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.container)) {
    query['Container'] = request.container;
  }
  if (!Util.isUnset(request.instanceList)) {
    query['InstanceList'] = request.instanceList;
  }
  if (!Util.isUnset(request.softRestart)) {
    query['SoftRestart'] = request.softRestart;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceInstances',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/instances`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteServiceInstances(ClusterId: string, ServiceName: string, request: DeleteServiceInstancesRequest): DeleteServiceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceInstancesWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model DeleteServiceLabelRequest {
  keys?: [ string ](name='Keys', description='The service tags that you want to delete.'),
}

model DeleteServiceLabelShrinkRequest {
  keysShrink?: string(name='Keys', description='The service tags that you want to delete.'),
}

model DeleteServiceLabelResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Succeed to delete service [service_from_zxxx] labels.'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model DeleteServiceLabelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceLabelResponseBody(name='body'),
}

async function deleteServiceLabelWithOptions(ClusterId: string, ServiceName: string, tmpReq: DeleteServiceLabelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceLabelResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteServiceLabelShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.keys)) {
    request.keysShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.keys, 'Keys', 'simple');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.keysShrink)) {
    query['Keys'] = request.keysShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceLabel',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/label`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteServiceLabel(ClusterId: string, ServiceName: string, request: DeleteServiceLabelRequest): DeleteServiceLabelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceLabelWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model DeleteServiceMirrorResponseBody = {
  message?: string(name='Message', example='Traffic mirroring is OFF for service [foo] in region [cn-shanghia], ratio [70%]'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82***'),
}

model DeleteServiceMirrorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceMirrorResponseBody(name='body'),
}

async function deleteServiceMirrorWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceMirrorResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceMirror',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/mirror`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteServiceMirror(ClusterId: string, ServiceName: string): DeleteServiceMirrorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceMirrorWithOptions(ClusterId, ServiceName, headers, runtime);
}

model DescribeBenchmarkTaskResponseBody = {
  availableAgent?: long(name='AvailableAgent', description='The number of instances that you can test.', example='4'),
  callerUid?: string(name='CallerUid', description='The ID of the operation caller.', example='1640133467****'),
  desiredAgent?: long(name='DesiredAgent', description='The number of instances that you want to test.', example='4'),
  endpoint?: string(name='Endpoint', description='The endpoint of the service gateway.', example='192342311234.pai-eas.cn-chengdu.aliyuncs.com'),
  message?: string(name='Message', description='The returned message.', example='Benchmar task is Running'),
  parentUid?: string(name='ParentUid', description='The ID of the Alibaba Cloud account that is used to call the operation.', example='1029728669****'),
  reason?: string(name='Reason', description='The event or reason that causes the current state of the stress testing task.', example='RUNNING'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  serviceName?: string(name='ServiceName', description='The name of the service that you want to test.', example='foo'),
  status?: string(name='Status', description='The state of the stress testing task.

Valid values:

*   Creating

    <!-- -->

    <!-- -->

    <!-- -->

*   Starting

    <!-- -->

    <!-- -->

    <!-- -->

*   DeleteFailed

    <!-- -->

    <!-- -->

    <!-- -->

*   Running

    <!-- -->

    <!-- -->

    <!-- -->

*   Stopping

    <!-- -->

    <!-- -->

    <!-- -->

*   Error

    <!-- -->

    <!-- -->

    <!-- -->

*   Updating

    <!-- -->

    <!-- -->

    <!-- -->

*   Deleting

    <!-- -->

    <!-- -->

    <!-- -->

*   CreateFailed

    <!-- -->

    <!-- -->

    <!-- -->', example='Running'),
  taskId?: string(name='TaskId', description='The ID of the stress testing task.', example='eas-b-gv4y86u****'),
  taskName?: string(name='TaskName', description='The name of the stress testing task.', example='benchmark-larec-test-ae70'),
  token?: string(name='Token', description='The token for authentication when a stress testing task is created.', example='6062787a-9301****'),
}

model DescribeBenchmarkTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBenchmarkTaskResponseBody(name='body'),
}

async function describeBenchmarkTaskWithOptions(ClusterId: string, TaskName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeBenchmarkTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(TaskName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBenchmarkTask(ClusterId: string, TaskName: string): DescribeBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeBenchmarkTaskWithOptions(ClusterId, TaskName, headers, runtime);
}

model DescribeBenchmarkTaskReportRequest {
  reportType?: string(name='ReportType', example='report'),
}

model DescribeBenchmarkTaskReportResponseBody = {
  data?: any(name='Data', example='{
    "TimestampList": ["int64"],
    "QPSList": ["float32"],
    "RTList": [
      {
        "AVG": "float32",
        "TP100": "float32",
        "TP99": "float32",
        "TP90": "float32",
        "TP50": "float32",
        "TP10": "float32"
      }
    ],
    "TrafficList": [
      {
        "Send": "float64",
        "Receive": "float64"
      }
    ],
    "StatusCode": {
      "200": "uint64",
      "450": "uint64",
      "500": "uint64"
    },
    "Count": "uint64",
    "Total": "float64",
    "MinRT": "float32",
    "AvgRT": "float32",
    "MaxRT": "float32",
    "QPS": "float32",
    "TotalSend": "float64",
    "TotalReceive": "float64",
    "RTDistribution": [
      {
        "Latency": "float32",
        "Percentage": "int"
      }
    ],
    "RTHistogram": [
      {
        "Count": "int",
        "Mark": "float32",
        "Frequency": "float32"
      }
    ]
  }'),
  reportUrl?: string(name='ReportUrl', example='http://eas-benchmark.oss-cn-chengdu.aliyuncs.com/summary/benchmark-larec-test-015d-10007.html'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82********'),
}

model DescribeBenchmarkTaskReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBenchmarkTaskReportResponseBody(name='body'),
}

async function describeBenchmarkTaskReportWithOptions(ClusterId: string, TaskName: string, request: DescribeBenchmarkTaskReportRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeBenchmarkTaskReportResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.reportType)) {
    query['ReportType'] = request.reportType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBenchmarkTaskReport',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(TaskName)}/report`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBenchmarkTaskReport(ClusterId: string, TaskName: string, request: DescribeBenchmarkTaskReportRequest): DescribeBenchmarkTaskReportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeBenchmarkTaskReportWithOptions(ClusterId, TaskName, request, headers, runtime);
}

model DescribeGatewayResponseBody = {
  callerUid?: string(name='CallerUid', example='20123*******'),
  createTime?: string(name='CreateTime', description='网关创建时间', example='2020-05-19T14:19:42Z'),
  externalClusterId?: string(name='ExternalClusterId', example='c935eadf284c14c2da57a2a13ad6******'),
  gatewayId?: string(name='GatewayId', description='网关ID', example='gw-1uhcqmsc7x22******'),
  gatewayName?: string(name='GatewayName', example='mygateway1'),
  instanceType?: string(name='InstanceType', description='网关创建的实例种类', example='ecs.c6.4xlarge'),
  internetAclPolicyList?: [ 
    {
      comment?: string(name='Comment', description='The description.', example='test'),
      entry?: string(name='Entry', description='The accessible CIDR block.', example='192.168.1.1/32'),
      status?: string(name='Status', description='The state of the private gateway.

Valid values:

*   Creating

    <!-- -->

    <!-- -->

    <!-- -->

*   Running

    <!-- -->

    <!-- -->

    <!-- -->', example='Running'),
    }
  ](name='InternetAclPolicyList', description='The Internet access control policies.'),
  internetDomain?: string(name='InternetDomain', description='网关内部域名', example='gw-1uhcqmsc7x22******-1801786532******.cn-hangzhou.pai-eas.aliyuncs.com'),
  internetEnabled?: boolean(name='InternetEnabled', example='true'),
  intranetDomain?: string(name='IntranetDomain', description='网关外部域名', example='gw-1uhcqmsc7x22******-1801786532******-vpc.cn-hangzhou.pai-eas.aliyuncs.com'),
  intranetEnabled?: boolean(name='IntranetEnabled', example='true'),
  intranetLinkedVpcList?: [ 
    {
      ip?: string(name='Ip', description='The IP address.', example='192.168.10.11'),
      securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group.', example='sg-2ze4pgstgszvgq******'),
      status?: string(name='Status', description='The state of the private gateway.

Valid values:

*   Creating

    <!-- -->

    <!-- -->

    <!-- -->

*   Running

    <!-- -->

    <!-- -->

    <!-- -->', example='Running'),
      vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.', example='vsw-bp1txzxsdck43pp******'),
      vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-bp1g11zvka6zr3i******'),
    }
  ](name='IntranetLinkedVpcList'),
  parentUid?: string(name='ParentUid', description='创建网关的用户ID', example='11234*******'),
  region?: string(name='Region', description='网关所在地域', example='cn-hangzhou'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
  status?: string(name='Status', description='网关现在的状态', example='PrivateGatewayRunning'),
  updateTime?: string(name='UpdateTime', description='网关最后一次的更新时间', example='2021-02-24T11:52:17Z'),
}

model DescribeGatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGatewayResponseBody(name='body'),
}

async function describeGatewayWithOptions(ClusterId: string, GatewayId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeGatewayResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeGateway',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GatewayId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGateway(ClusterId: string, GatewayId: string): DescribeGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeGatewayWithOptions(ClusterId, GatewayId, headers, runtime);
}

model DescribeGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Group  
}

async function describeGroupWithOptions(ClusterId: string, GroupName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeGroup',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/groups/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GroupName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGroup(ClusterId: string, GroupName: string): DescribeGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeGroupWithOptions(ClusterId, GroupName, headers, runtime);
}

model DescribeResourceResponseBody = {
  clusterId?: string(name='ClusterId', description='The ID of the cluster to which the resource group belongs.', example='cn-beijing'),
  cpuCount?: int32(name='CpuCount', description='The total number of CPU cores.', example='16'),
  createTime?: string(name='CreateTime', description='The time when the resource group was created.', example='2020-05-19T14:19:42Z'),
  extraData?: string(name='ExtraData', description='The additional information, such as the connection status of a virtual private cloud (VPC) and the log status of Log Service.', example='{"vswitch_id":"vsw-bp17uo6xebcusy****","gpu_share":true,"aux_vswitch_id_list":["vsw-bp13b3pvjap3vxn****","vsw-bp1nls8o5hk8mt8*****"],"security_group_id":"sg-bp1j1z7297hcink*****","vpc_id":"vpc-bp1kjr3rfyhx01*****","destination_cidr":"172.16.0.12/28","role_arn":"acs:ram::1157703270*****:role/AliyunServiceRoleForPaiEas","sls_project":"","sls_logstore":"","sls_status":"ResourceReady","sls_message":"","update_time":""}'),
  gpuCount?: int32(name='GpuCount', description='The total number of GPUs.', example='1'),
  instanceCount?: int32(name='InstanceCount', description='The total number of instances in the resource group.', example='4'),
  message?: string(name='Message', description='The returned message.', example='Resource is ready'),
  ownerUid?: string(name='OwnerUid', description='The ID of the resource group owner.', example='14401087478****'),
  postPaidInstanceCount?: int32(name='PostPaidInstanceCount', description='The total number of pay-as-you-go instances in the resource group.', example='3'),
  prePaidInstanceCount?: int32(name='PrePaidInstanceCount', description='The total number of subscription instances in the resource group.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='902976F2-6FAF-5404-8A4D-6CC223***'),
  resourceId?: string(name='ResourceId', description='The ID of the Elastic Algorithm Service (EAS) resource.', example='eas-r-glkfpsxuw57x1h*****'),
  resourceName?: string(name='ResourceName', description='The name of the EAS resource.', example='my-resouce****'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Valid values:

- Dedicated
- SelfManaged', example='Dedicated'),
  status?: string(name='Status', description='The state of the resource group.', example='ResourceReady'),
  updateTime?: string(name='UpdateTime', description='The time when the resource group was last updated.', example='2021-02-24T11:52:17Z'),
}

model DescribeResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeResourceResponseBody(name='body'),
}

async function describeResourceWithOptions(ClusterId: string, ResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeResourceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeResource',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeResource(ClusterId: string, ResourceId: string): DescribeResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeResourceWithOptions(ClusterId, ResourceId, headers, runtime);
}

model DescribeResourceDLinkResponseBody = {
  auxVSwitchList?: [ string ](name='AuxVSwitchList'),
  destinationCIDRs?: string(name='DestinationCIDRs', description='The CIDR blocks of the clients that you want to connect to. The CIDR blocks are added to the back-to-origin route of the server.', example='72.16.0.0/16'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
  securityGroupId?: string(name='SecurityGroupId', example='sg-bp1j1z7297hcink9d****'),
  vSwitchId?: string(name='VSwitchId', example='vsw-8vbqn2at0kljjxxxx****'),
  vpcId?: string(name='VpcId', example='vpc-uf66uio7md****'),
}

model DescribeResourceDLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeResourceDLinkResponseBody(name='body'),
}

async function describeResourceDLinkWithOptions(ClusterId: string, ResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeResourceDLinkResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeResourceDLink',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/dlink`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeResourceDLink(ClusterId: string, ResourceId: string): DescribeResourceDLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeResourceDLinkWithOptions(ClusterId, ResourceId, headers, runtime);
}

model DescribeResourceLogResponseBody = {
  logStore?: string(name='LogStore', example='access_log'),
  message?: string(name='Message', example='Network interfaces are updating'),
  projectName?: string(name='ProjectName', example='eas-r-asdasdasd-sls'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
  status?: string(name='Status', example='ResourceReady'),
}

model DescribeResourceLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeResourceLogResponseBody(name='body'),
}

async function describeResourceLogWithOptions(ClusterId: string, ResourceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeResourceLogResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeResourceLog',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/log`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeResourceLog(ClusterId: string, ResourceId: string): DescribeResourceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeResourceLogWithOptions(ClusterId, ResourceId, headers, runtime);
}

model DescribeServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Service  
}

async function describeServiceWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeService(ClusterId: string, ServiceName: string): DescribeServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceWithOptions(ClusterId, ServiceName, headers, runtime);
}

model DescribeServiceAutoScalerResponseBody = {
  behavior?: map[string]any(name='Behavior', example='{
  "behavior": {
    "scaleDown": {
      "stabilizationWindowSeconds": 150
    }
  }
}'),
  currentMetrics?: [ 
    {
      metricName?: string(name='metricName', example='qps'),
      service?: string(name='service', example='demo_svc'),
      value?: float(name='value', example='10'),
    }
  ](name='CurrentMetrics'),
  maxReplica?: int32(name='MaxReplica', example='8'),
  minReplica?: int32(name='MinReplica', example='3'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
  scaleStrategies?: [ 
    {
      metricName?: string(name='metricName', example='QPS'),
      service?: string(name='service', example='demo_svc'),
      threshold?: float(name='threshold', example='10'),
    }
  ](name='ScaleStrategies'),
  serviceName?: string(name='ServiceName', example='foo'),
}

model DescribeServiceAutoScalerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceAutoScalerResponseBody(name='body'),
}

async function describeServiceAutoScalerWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceAutoScalerResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceAutoScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/autoscaler`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceAutoScaler(ClusterId: string, ServiceName: string): DescribeServiceAutoScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceAutoScalerWithOptions(ClusterId, ServiceName, headers, runtime);
}

model DescribeServiceCronScalerResponseBody = {
  excludeDates?: [ string ](name='ExcludeDates'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
  scaleJobs?: [ 
    {
      createTime?: string(name='CreateTime', example='2020-06-24T02:11:30Z'),
      lastProbeTime?: string(name='LastProbeTime', example='2022-02-24T06:31:00Z'),
      message?: string(name='Message', example='"cron hpa job scale-jobs-0 executed successfully. current replicas:3, desired replicas:2."'),
      name?: string(name='Name', example='scale-job-1'),
      schedule?: string(name='Schedule', example='0 18 * * * *'),
      state?: string(name='State', example='Succeed'),
      targetSize?: int32(name='TargetSize', example='1'),
    }
  ](name='ScaleJobs'),
  serviceName?: string(name='ServiceName', example='foo'),
}

model DescribeServiceCronScalerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceCronScalerResponseBody(name='body'),
}

async function describeServiceCronScalerWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceCronScalerResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceCronScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/cronscaler`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceCronScaler(ClusterId: string, ServiceName: string): DescribeServiceCronScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceCronScalerWithOptions(ClusterId, ServiceName, headers, runtime);
}

model DescribeServiceDiagnosisResponseBody = {
  diagnosisList?: [ 
    {
      advices?: [ string ](name='Advices'),
      causes?: [ string ](name='Causes'),
      error?: string(name='Error', example='Container worker0 failed to pull image.'),
    }
  ](name='DiagnosisList'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
}

model DescribeServiceDiagnosisResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceDiagnosisResponseBody(name='body'),
}

async function describeServiceDiagnosisWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceDiagnosisResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceDiagnosis',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/diagnosis`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceDiagnosis(ClusterId: string, ServiceName: string): DescribeServiceDiagnosisResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceDiagnosisWithOptions(ClusterId, ServiceName, headers, runtime);
}

model DescribeServiceEventRequest {
  endTime?: string(name='EndTime', example='2006-01-02 15:04:05'),
  eventType?: string(name='EventType', example='Normal'),
  instanceName?: string(name='InstanceName', example='echo-test-784xxxx85d-hhnd8'),
  pageNum?: string(name='PageNum', example='1'),
  pageSize?: string(name='PageSize', example='20'),
  startTime?: string(name='StartTime', example='2006-01-02 15:04:05'),
}

model DescribeServiceEventResponseBody = {
  events?: [ 
    {
      message?: string(name='Message', example='{\\"versionId\\":1,\\"message\\":\\"Stage scale complete\\",\\"availableInstance\\":1,\\"unavailableInstance\\":0}'),
      reason?: string(name='Reason', example='Updating'),
      time?: string(name='Time', example='2022-04-09 06:30:00'),
      type?: string(name='Type', example='Normal'),
    }
  ](name='Events'),
  pageNum?: long(name='PageNum', example='1'),
  requestId?: string(name='RequestId', example='3D491C94-6239-5318-B4B4-799D859***'),
  totalCount?: long(name='TotalCount', example='29'),
  totalPageNum?: long(name='TotalPageNum', example='12'),
}

model DescribeServiceEventResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceEventResponseBody(name='body'),
}

async function describeServiceEventWithOptions(ClusterId: string, ServiceName: string, request: DescribeServiceEventRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceEventResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceEvent',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/events`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceEvent(ClusterId: string, ServiceName: string, request: DescribeServiceEventRequest): DescribeServiceEventResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceEventWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model DescribeServiceInstanceDiagnosisResponseBody = {
  diagnosis?: {
    advices?: [ string ](name='Advices'),
    causes?: [ string ](name='Causes'),
    error?: string(name='Error', example='Container worker0 failed to pull image.'),
  }(name='Diagnosis'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82***'),
}

model DescribeServiceInstanceDiagnosisResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceInstanceDiagnosisResponseBody(name='body'),
}

async function describeServiceInstanceDiagnosisWithOptions(ClusterId: string, ServiceName: string, InstanceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceInstanceDiagnosisResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceInstanceDiagnosis',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/instances/${OpenApiUtil.getEncodeParam(InstanceName)}/diagnosis`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceInstanceDiagnosis(ClusterId: string, ServiceName: string, InstanceName: string): DescribeServiceInstanceDiagnosisResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceInstanceDiagnosisWithOptions(ClusterId, ServiceName, InstanceName, headers, runtime);
}

model DescribeServiceLogRequest {
  containerName?: string(name='ContainerName', example='worker0'),
  endTime?: string(name='EndTime', example='2006-01-02 15:04:05'),
  instanceName?: string(name='InstanceName', example='echo-da290ac8-7fckm'),
  ip?: string(name='Ip', example='10.0.0.1'),
  keyword?: string(name='Keyword', example='key'),
  pageNum?: long(name='PageNum', example='1'),
  pageSize?: long(name='PageSize', example='500'),
  previous?: boolean(name='Previous', example='true'),
  startTime?: string(name='StartTime', example='2006-01-02 15:04:05'),
}

model DescribeServiceLogResponseBody = {
  logs?: [ string ](name='Logs'),
  pageNum?: long(name='PageNum', example='1'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82********'),
  totalCount?: long(name='TotalCount', example='1'),
  totalPageNum?: long(name='TotalPageNum', example='500'),
}

model DescribeServiceLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceLogResponseBody(name='body'),
}

async function describeServiceLogWithOptions(ClusterId: string, ServiceName: string, request: DescribeServiceLogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceLogResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.containerName)) {
    query['ContainerName'] = request.containerName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.previous)) {
    query['Previous'] = request.previous;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceLog',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/logs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceLog(ClusterId: string, ServiceName: string, request: DescribeServiceLogRequest): DescribeServiceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceLogWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model DescribeServiceMirrorResponseBody = {
  ratio?: string(name='Ratio', example='50'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
  serviceName?: string(name='ServiceName', example='foo'),
  target?: string(name='Target', example='foo2,foo3'),
}

model DescribeServiceMirrorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMirrorResponseBody(name='body'),
}

async function describeServiceMirrorWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeServiceMirrorResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceMirror',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/mirror`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceMirror(ClusterId: string, ServiceName: string): DescribeServiceMirrorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeServiceMirrorWithOptions(ClusterId, ServiceName, headers, runtime);
}

model DevelopServiceRequest {
  exit?: string(name='Exit', description='Specifies whether to exit development mode. Valid values:

*   true
*   false (default)', example='true'),
}

model DevelopServiceResponseBody = {
  message?: string(name='Message', example='Success'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
}

model DevelopServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DevelopServiceResponseBody(name='body'),
}

async function developServiceWithOptions(ClusterId: string, ServiceName: string, request: DevelopServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DevelopServiceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.exit)) {
    query['Exit'] = request.exit;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DevelopService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/develop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function developService(ClusterId: string, ServiceName: string, request: DevelopServiceRequest): DevelopServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return developServiceWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model ListBenchmarkTaskRequest {
  filter?: string(name='Filter', description='The keyword used to query required stress testing tasks. If this parameter is specified, the system returns stress testing tasks based on the names of the stress testing tasks in the matched Elastic Algorithm service (EAS).', example='test_bench'),
  pageNumber?: string(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: string(name='PageSize', description='The number of entries per page. Default value: 100.', example='10'),
  serviceName?: string(name='ServiceName', description='The name of the EAS service that corresponds to the stress testing task. For more information about how to query the service name, see [ListServices](~~412109~~).', example='test_bench_srv'),
}

model ListBenchmarkTaskResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  tasks?: [ 
    {
      availableAgent?: long(name='AvailableAgent', example='2'),
      createTime?: string(name='CreateTime', example='2020-12-04T02:43:15Z'),
      message?: string(name='Message', example='Benchmark task [benchmark-larec-test-1076] is Running'),
      region?: string(name='Region', example='cn-shanghai'),
      serviceName?: string(name='ServiceName', example='test_quota'),
      status?: string(name='Status', example='Running'),
      taskId?: string(name='TaskId', example='eas-b-gv4y86uvgt****i'),
      taskName?: string(name='TaskName', example='benchmark-larec-test-1076'),
      updateTime?: string(name='UpdateTime', example='2020-06-24T03:11:30Z'),
    }
  ](name='Tasks', description='The time when the stress testing task was updated.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model ListBenchmarkTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListBenchmarkTaskResponseBody(name='body'),
}

async function listBenchmarkTaskWithOptions(request: ListBenchmarkTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListBenchmarkTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listBenchmarkTask(request: ListBenchmarkTaskRequest): ListBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listBenchmarkTaskWithOptions(request, headers, runtime);
}

model ListGatewayIntranetLinkedVpcResponseBody = {
  gatewayId?: string(name='GatewayId', description='The private gateway ID.', example='gw-1uhcqmsc7x22******'),
  intranetLinkedVpcList?: [ 
    {
      ip?: string(name='Ip', description='The IP address.', example='192.168.10.11'),
      securityGroupId?: string(name='SecurityGroupId', description='The security group ID.', example='sg-2ze4pgstgszvgq******'),
      status?: string(name='Status', description='The state of the private gateway.

Valid values:

*   Creating

    <!-- -->

    :

    <!-- -->

    The private gateway is being created.

    <!-- -->

*   Running

    <!-- -->

    :

    <!-- -->

    The private gateway is running.

    <!-- -->', example='Running'),
      vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.', example='vsw-8vb2qjoiio6m9pg******'),
      vpcId?: string(name='VpcId', description='The virtual private cloud (VPC) ID.', example='vpc-2zetuli9ws0qgjd******'),
    }
  ](name='IntranetLinkedVpcList', description='The internal endpoints.'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model ListGatewayIntranetLinkedVpcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGatewayIntranetLinkedVpcResponseBody(name='body'),
}

async function listGatewayIntranetLinkedVpcWithOptions(ClusterId: string, GatewayId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListGatewayIntranetLinkedVpcResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListGatewayIntranetLinkedVpc',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GatewayId)}/intranet_endpoint_linked_vpc`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGatewayIntranetLinkedVpc(ClusterId: string, GatewayId: string): ListGatewayIntranetLinkedVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGatewayIntranetLinkedVpcWithOptions(ClusterId, GatewayId, headers, runtime);
}

model ListGroupsRequest {
  filter?: string(name='Filter', example='foo'),
  pageNumber?: string(name='PageNumber', example='1'),
  pageSize?: string(name='PageSize', example='20'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListGroupsResponseBody = {
  groups?: [
    Group
  ](name='Groups'),
  pageNumber?: long(name='PageNumber', example='1'),
  pageSize?: long(name='PageSize', example='20'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
  totalCount?: long(name='TotalCount', example='5'),
}

model ListGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGroupsResponseBody(name='body'),
}

async function listGroupsWithOptions(request: ListGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListGroupsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGroups',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/groups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGroups(request: ListGroupsRequest): ListGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGroupsWithOptions(request, headers, runtime);
}

model ListResourceInstanceWorkerRequest {
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 100.', example='20'),
}

model ListResourceInstanceWorkerResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  pods?: [
    ResourceInstanceWorker
  ](name='Pods', description='The workers.'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model ListResourceInstanceWorkerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceInstanceWorkerResponseBody(name='body'),
}

async function listResourceInstanceWorkerWithOptions(ClusterId: string, ResourceId: string, InstanceName: string, request: ListResourceInstanceWorkerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListResourceInstanceWorkerResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceInstanceWorker',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/instance/${OpenApiUtil.getEncodeParam(InstanceName)}/workers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listResourceInstanceWorker(ClusterId: string, ResourceId: string, InstanceName: string, request: ListResourceInstanceWorkerRequest): ListResourceInstanceWorkerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourceInstanceWorkerWithOptions(ClusterId, ResourceId, InstanceName, request, headers, runtime);
}

model ListResourceInstancesRequest {
  chargeType?: string(name='ChargeType', example='PrePaid'),
  filter?: string(name='Filter', example='10.224.xx.xx'),
  instanceIP?: string(name='InstanceIP', example='10.224.xx.xx'),
  instanceId?: string(name='InstanceId', example='i-bp1jd6x3uotsv****'),
  instanceName?: string(name='InstanceName', example='e-xxxx***'),
  instanceStatus?: string(name='InstanceStatus', example='Ready'),
  order?: string(name='Order', example='desc'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='20'),
  sort?: string(name='Sort', example='CreateTime'),
}

model ListResourceInstancesResponseBody = {
  instances?: [
    ResourceInstance
  ](name='Instances'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='20'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
  totalCount?: int32(name='TotalCount', example='2'),
}

model ListResourceInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceInstancesResponseBody(name='body'),
}

async function listResourceInstancesWithOptions(ClusterId: string, ResourceId: string, request: ListResourceInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListResourceInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.instanceIP)) {
    query['InstanceIP'] = request.instanceIP;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.instanceStatus)) {
    query['InstanceStatus'] = request.instanceStatus;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sort)) {
    query['Sort'] = request.sort;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceInstances',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listResourceInstances(ClusterId: string, ResourceId: string, request: ListResourceInstancesRequest): ListResourceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourceInstancesWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

model ListResourceServicesRequest {
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 100.', example='20'),
}

model ListResourceServicesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  services?: [
    Service
  ](name='Services', description='The services.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model ListResourceServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceServicesResponseBody(name='body'),
}

async function listResourceServicesWithOptions(ClusterId: string, ResourceId: string, request: ListResourceServicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListResourceServicesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceServices',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/services`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listResourceServices(ClusterId: string, ResourceId: string, request: ListResourceServicesRequest): ListResourceServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourceServicesWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

model ListResourcesRequest {
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 100.', example='20'),
  resourceId?: string(name='ResourceId', description='The ID of the resource group. You can call the [CreateResource](~~412111~~) operation to query the ID of the resource group.', example='eas-r-h7lcw24dyqztwxxxxxx'),
  resourceName?: string(name='ResourceName', description='The name of the resource group. You can call the [CreateResource](~~412111~~) operation to query the name of the resource group.', example='MyResource'),
  resourceType?: string(name='ResourceType', example='Dedicated'),
}

model ListResourcesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  resources?: [
    Resource
  ](name='Resources', description='The resource groups.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model ListResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourcesResponseBody(name='body'),
}

async function listResourcesWithOptions(request: ListResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResources',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listResources(request: ListResourcesRequest): ListResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourcesWithOptions(request, headers, runtime);
}

model ListServiceContainersResponseBody = {
  containers?: [
    ContainerInfo
  ](name='Containers', description='The containers of the service.'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
  serviceName?: string(name='ServiceName', example='foo'),
}

model ListServiceContainersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServiceContainersResponseBody(name='body'),
}

async function listServiceContainersWithOptions(ClusterId: string, ServiceName: string, InstanceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListServiceContainersResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListServiceContainers',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/instances/${OpenApiUtil.getEncodeParam(InstanceName)}/containers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServiceContainers(ClusterId: string, ServiceName: string, InstanceName: string): ListServiceContainersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServiceContainersWithOptions(ClusterId, ServiceName, InstanceName, headers, runtime);
}

model ListServiceInstancesRequest {
  filter?: string(name='Filter', example='10.118.xx.xx'),
  hostIP?: string(name='HostIP', example='10.224.xx.xx'),
  instanceIP?: string(name='InstanceIP', example='10.224.xx.xx'),
  instanceName?: string(name='InstanceName', example='foo-bdc5xxxx-8l7rk'),
  instanceStatus?: string(name='InstanceStatus', example='Running'),
  instanceType?: string(name='InstanceType', example='ecs.c7.large'),
  isSpot?: boolean(name='IsSpot', example='false'),
  order?: string(name='Order', description='The sorting order.

Valid values:

*   asc: The instances are sorted in ascending order.

    <!-- -->

    <!-- -->

    <!-- -->

*   desc

    <!-- -->

    : The instances are sorted in descending order.

    <!-- -->

    <!-- -->', example='desc'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='20'),
  resourceType?: string(name='ResourceType', example='PublicResource'),
  role?: string(name='Role', example='Queue'),
  sort?: string(name='Sort', example='StartTime'),
}

model ListServiceInstancesResponseBody = {
  instances?: [
    Instance
  ](name='Instances'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='20'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
  totalCount?: int32(name='TotalCount', example='1'),
}

model ListServiceInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServiceInstancesResponseBody(name='body'),
}

async function listServiceInstancesWithOptions(ClusterId: string, ServiceName: string, request: ListServiceInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListServiceInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.hostIP)) {
    query['HostIP'] = request.hostIP;
  }
  if (!Util.isUnset(request.instanceIP)) {
    query['InstanceIP'] = request.instanceIP;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.instanceStatus)) {
    query['InstanceStatus'] = request.instanceStatus;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.isSpot)) {
    query['IsSpot'] = request.isSpot;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.role)) {
    query['Role'] = request.role;
  }
  if (!Util.isUnset(request.sort)) {
    query['Sort'] = request.sort;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServiceInstances',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServiceInstances(ClusterId: string, ServiceName: string, request: ListServiceInstancesRequest): ListServiceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServiceInstancesWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model ListServiceVersionsRequest {
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='10'),
}

model ListServiceVersionsResponseBody = {
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='10'),
  requestId?: string(name='RequestId', example='E089D584-B6F4-50C4-9902-DA2295B7****'),
  totalCount?: long(name='TotalCount', example='166'),
  versions?: [ 
    {
      buildTime?: string(name='BuildTime', example='2022-08-29T22:02:14Z'),
      imageAvailable?: string(name='ImageAvailable', example='true'),
      imageId?: int32(name='ImageId', example='4'),
      message?: string(name='Message', example='Service is Running'),
      serviceRunnable?: string(name='ServiceRunnable', example='true'),
    }
  ](name='Versions'),
}

model ListServiceVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServiceVersionsResponseBody(name='body'),
}

async function listServiceVersionsWithOptions(ClusterId: string, ServiceName: string, request: ListServiceVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListServiceVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServiceVersions',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServiceVersions(ClusterId: string, ServiceName: string, request: ListServiceVersionsRequest): ListServiceVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServiceVersionsWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model ListServicesRequest {
  filter?: string(name='Filter', description='{
  "RequestId": "40325405-579C-4D82-9624-EC2B1779848E",
  "Services": [
    {
      "ServiceId": "200516454695942578",
      "ServiceName": "vipserver",
      "ParentUid": "1628454689805075",
      "CallerUid": "eas",
      "CurrentVersion": 1,
      "Cpu": 1,
      "Gpu": 0,
      "Memory": 900,
      "Image": "registry.cn-zhangjiakou.aliyuncs.com/eas/ndisearch_v1_inner_zhangbei:v0.0.3-20200302145109",
      "Resource": "seccontent_inner_2080ti_5",
      "Namespace": "vipserver",
      "CreateTime": "2019-10-25T10:37:53Z",
      "UpdateTime": "2019-10-30T16:50:59Z",
      "TotalInstance": 1,
      "RunningInstance": 1,
      "PendingInstance": 0,
      "LatestVersion": 1,
      "Status": "Running",
      "Reason": "RUNNING",
      "Message": "Service is now scaling",
      "AccessToken": "",
      "Weight": 0
    },
    {
      "ServiceId": 97097,
      "ServiceName": "a1",
      "CallerUid": "eas",
      "CurrentVersion": 1,
      "Cpu": 1,
      "Gpu": 0,
      "Memory": 900,
      "Image": "registry.cn-hangzhou.aliyuncs.com/eas/pi_imemb_tb:v0.0.1-20191023130701",
      "Resource": "seccontent_inner_b",
      "Namespace": "a1",
      "CreateTime": "2020-05-26T18:03:11Z",
      "UpdateTime": "2020-05-26T18:03:11Z",
      "TotalInstance": 1,
      "RunningInstance": 0,
      "PendingInstance": 1,
      "LatestVersion": 1,
      "Status": "Failed",
      "Reason": "FAILED",
      "Message": "the server could not find the requested resource (post services.meta.k8s.io)",
      "AccessToken": "regression_test_token",
      "Weight": 0
    }
  ],
  "PageNumber": 1,
  "PageSize": 2,
  "TotalCount": 2
}', example='foo'),
  groupName?: string(name='GroupName', example='foo'),
  label?: map[string]string(name='Label'),
  order?: string(name='Order', description='所属的group。', example='asc'),
  pageNumber?: int32(name='PageNumber', description='376577', example='1'),
  pageSize?: int32(name='PageSize', example='100'),
  parentServiceUid?: string(name='ParentServiceUid'),
  resourceName?: string(name='ResourceName', description='服务所属的资源组名称或ID。', example='eas-r-hd0qwy8cxxxx'),
  serviceName?: string(name='ServiceName', description='服务名。', example='echo_test'),
  serviceStatus?: string(name='ServiceStatus', description='服务运行的状态。', example='Running'),
  serviceType?: string(name='ServiceType'),
  serviceUid?: string(name='ServiceUid', example='eas-m-c9iw3yitxxxx'),
  sort?: string(name='Sort', description='服务的类型定义。', example='CreateTime'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListServicesShrinkRequest {
  filter?: string(name='Filter', description='{
  "RequestId": "40325405-579C-4D82-9624-EC2B1779848E",
  "Services": [
    {
      "ServiceId": "200516454695942578",
      "ServiceName": "vipserver",
      "ParentUid": "1628454689805075",
      "CallerUid": "eas",
      "CurrentVersion": 1,
      "Cpu": 1,
      "Gpu": 0,
      "Memory": 900,
      "Image": "registry.cn-zhangjiakou.aliyuncs.com/eas/ndisearch_v1_inner_zhangbei:v0.0.3-20200302145109",
      "Resource": "seccontent_inner_2080ti_5",
      "Namespace": "vipserver",
      "CreateTime": "2019-10-25T10:37:53Z",
      "UpdateTime": "2019-10-30T16:50:59Z",
      "TotalInstance": 1,
      "RunningInstance": 1,
      "PendingInstance": 0,
      "LatestVersion": 1,
      "Status": "Running",
      "Reason": "RUNNING",
      "Message": "Service is now scaling",
      "AccessToken": "",
      "Weight": 0
    },
    {
      "ServiceId": 97097,
      "ServiceName": "a1",
      "CallerUid": "eas",
      "CurrentVersion": 1,
      "Cpu": 1,
      "Gpu": 0,
      "Memory": 900,
      "Image": "registry.cn-hangzhou.aliyuncs.com/eas/pi_imemb_tb:v0.0.1-20191023130701",
      "Resource": "seccontent_inner_b",
      "Namespace": "a1",
      "CreateTime": "2020-05-26T18:03:11Z",
      "UpdateTime": "2020-05-26T18:03:11Z",
      "TotalInstance": 1,
      "RunningInstance": 0,
      "PendingInstance": 1,
      "LatestVersion": 1,
      "Status": "Failed",
      "Reason": "FAILED",
      "Message": "the server could not find the requested resource (post services.meta.k8s.io)",
      "AccessToken": "regression_test_token",
      "Weight": 0
    }
  ],
  "PageNumber": 1,
  "PageSize": 2,
  "TotalCount": 2
}', example='foo'),
  groupName?: string(name='GroupName', example='foo'),
  labelShrink?: string(name='Label'),
  order?: string(name='Order', description='所属的group。', example='asc'),
  pageNumber?: int32(name='PageNumber', description='376577', example='1'),
  pageSize?: int32(name='PageSize', example='100'),
  parentServiceUid?: string(name='ParentServiceUid'),
  resourceName?: string(name='ResourceName', description='服务所属的资源组名称或ID。', example='eas-r-hd0qwy8cxxxx'),
  serviceName?: string(name='ServiceName', description='服务名。', example='echo_test'),
  serviceStatus?: string(name='ServiceStatus', description='服务运行的状态。', example='Running'),
  serviceType?: string(name='ServiceType'),
  serviceUid?: string(name='ServiceUid', example='eas-m-c9iw3yitxxxx'),
  sort?: string(name='Sort', description='服务的类型定义。', example='CreateTime'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListServicesResponseBody = {
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='100'),
  requestId?: string(name='RequestId', description='请求ID。', example='40325405-579C-4D82****'),
  services?: [
    Service
  ](name='Services', description='服务列表。'),
  totalCount?: int32(name='TotalCount', description='服务总数。', example='2'),
}

model ListServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServicesResponseBody(name='body'),
}

async function listServicesWithOptions(tmpReq: ListServicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListServicesResponse {
  Util.validateModel(tmpReq);
  var request = new ListServicesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.label)) {
    request.labelShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.label, 'Label', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.labelShrink)) {
    query['Label'] = request.labelShrink;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.parentServiceUid)) {
    query['ParentServiceUid'] = request.parentServiceUid;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.serviceStatus)) {
    query['ServiceStatus'] = request.serviceStatus;
  }
  if (!Util.isUnset(request.serviceType)) {
    query['ServiceType'] = request.serviceType;
  }
  if (!Util.isUnset(request.serviceUid)) {
    query['ServiceUid'] = request.serviceUid;
  }
  if (!Util.isUnset(request.sort)) {
    query['Sort'] = request.sort;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServices',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServices(request: ListServicesRequest): ListServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServicesWithOptions(request, headers, runtime);
}

model ReleaseServiceRequest {
  trafficState?: string(name='TrafficState', example='grouping'),
  weight?: int32(name='Weight', example='100'),
}

model ReleaseServiceResponseBody = {
  message?: string(name='Message', example='Releasing service [foo] in region [cn-shanghai] with weight [40], service status: [Running]'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
}

model ReleaseServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReleaseServiceResponseBody(name='body'),
}

async function releaseServiceWithOptions(ClusterId: string, ServiceName: string, request: ReleaseServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ReleaseServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.trafficState)) {
    body['TrafficState'] = request.trafficState;
  }
  if (!Util.isUnset(request.weight)) {
    body['Weight'] = request.weight;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/release`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function releaseService(ClusterId: string, ServiceName: string, request: ReleaseServiceRequest): ReleaseServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return releaseServiceWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model RestartServiceResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Service is restarting'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model RestartServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestartServiceResponseBody(name='body'),
}

async function restartServiceWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): RestartServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RestartService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/restart`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function restartService(ClusterId: string, ServiceName: string): RestartServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restartServiceWithOptions(ClusterId, ServiceName, headers, runtime);
}

model StartBenchmarkTaskResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Benchmark task [benchmark-larec-test-1076] is Starting'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model StartBenchmarkTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartBenchmarkTaskResponseBody(name='body'),
}

async function startBenchmarkTaskWithOptions(ClusterId: string, TaskName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartBenchmarkTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(TaskName)}/start`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startBenchmarkTask(ClusterId: string, TaskName: string): StartBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startBenchmarkTaskWithOptions(ClusterId, TaskName, headers, runtime);
}

model StartServiceResponseBody = {
  message?: string(name='Message', example='Service [foo] in region [cn-shanghai] is starting'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
}

model StartServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartServiceResponseBody(name='body'),
}

async function startServiceWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/start`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startService(ClusterId: string, ServiceName: string): StartServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startServiceWithOptions(ClusterId, ServiceName, headers, runtime);
}

model StopBenchmarkTaskResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Benchmark task [benchmark-larec-test-1076] is Stopping'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model StopBenchmarkTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopBenchmarkTaskResponseBody(name='body'),
}

async function stopBenchmarkTaskWithOptions(ClusterId: string, TaskName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopBenchmarkTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(TaskName)}/stop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopBenchmarkTask(ClusterId: string, TaskName: string): StopBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopBenchmarkTaskWithOptions(ClusterId, TaskName, headers, runtime);
}

model StopServiceResponseBody = {
  message?: string(name='Message', example='Succeed to auto scale service [foo]'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
}

model StopServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopServiceResponseBody(name='body'),
}

async function stopServiceWithOptions(ClusterId: string, ServiceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/stop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopService(ClusterId: string, ServiceName: string): StopServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopServiceWithOptions(ClusterId, ServiceName, headers, runtime);
}

model UpdateAppServiceRequest {
  quotaId?: string(name='QuotaId', description='The quota ID.', example='abcdef'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='123456'),
  appType?: string(name='AppType', description='The application type.

Valid values:

*   LLM

    <!-- -->

    :

    <!-- -->

    the large language model (LLM) application

    <!-- -->', example='LLM'),
  appVersion?: string(name='AppVersion', description='The application version.', example='v1'),
  config?: map[string]any(name='Config', description='Additional configurations that are required for the service deployment.'),
  replicas?: string(name='Replicas', description='The number of instances.', example='1'),
  serviceSpec?: string(name='ServiceSpec', description='The service specifications.', example='llama_7b_fp16'),
}

model UpdateAppServiceResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Succee'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
}

model UpdateAppServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAppServiceResponseBody(name='body'),
}

async function updateAppServiceWithOptions(ClusterId: string, ServiceName: string, request: UpdateAppServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAppServiceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.quotaId)) {
    query['QuotaId'] = request.quotaId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.appType)) {
    body['AppType'] = request.appType;
  }
  if (!Util.isUnset(request.appVersion)) {
    body['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.config)) {
    body['Config'] = request.config;
  }
  if (!Util.isUnset(request.replicas)) {
    body['Replicas'] = request.replicas;
  }
  if (!Util.isUnset(request.serviceSpec)) {
    body['ServiceSpec'] = request.serviceSpec;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAppService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/app_services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAppService(ClusterId: string, ServiceName: string, request: UpdateAppServiceRequest): UpdateAppServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAppServiceWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model UpdateBenchmarkTaskRequest {
  body?: string(name='body', description='The request body. The body includes the parameters that are set to create a stress testing task.', example='{
    "base":  {
         "qps": 200
    }
}'),
}

model UpdateBenchmarkTaskResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Benchmark task [benchmark-larec-test-1076] is Updating'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82***'),
}

model UpdateBenchmarkTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateBenchmarkTaskResponseBody(name='body'),
}

async function updateBenchmarkTaskWithOptions(ClusterId: string, TaskName: string, request: UpdateBenchmarkTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateBenchmarkTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateBenchmarkTask',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/benchmark-tasks/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(TaskName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateBenchmarkTask(ClusterId: string, TaskName: string, request: UpdateBenchmarkTaskRequest): UpdateBenchmarkTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateBenchmarkTaskWithOptions(ClusterId, TaskName, request, headers, runtime);
}

model UpdateGatewayRequest {
  enableInternet?: boolean(name='EnableInternet', description='Specifies whether to enable Internet access. Default value: false.

Valid values:

*   true

    <!-- -->

    <!-- -->

    <!-- -->

*   false

    <!-- -->

    <!-- -->

    <!-- -->', example='false'),
  enableIntranet?: boolean(name='EnableIntranet', description='Specifies whether to enable internal network access. Default value: true.', example='true'),
  instanceType?: string(name='InstanceType', description='The instance type used for the private gateway.', example='ecs.c6.4xlarge'),
  name?: string(name='Name', description='The private gateway alias.', example='mygateway1'),
}

model UpdateGatewayResponseBody = {
  gatewayId?: string(name='GatewayId', description='The ID of the gateway.', example='gw-1uhcqmsc7x22******'),
  message?: string(name='Message', description='The returned message.', example='Gateway is updated'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='40325405-579C-4D82***'),
}

model UpdateGatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGatewayResponseBody(name='body'),
}

async function updateGatewayWithOptions(GatewayId: string, ClusterId: string, request: UpdateGatewayRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateGatewayResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.enableInternet)) {
    body['EnableInternet'] = request.enableInternet;
  }
  if (!Util.isUnset(request.enableIntranet)) {
    body['EnableIntranet'] = request.enableIntranet;
  }
  if (!Util.isUnset(request.instanceType)) {
    body['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGateway',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/gateways/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(GatewayId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGateway(GatewayId: string, ClusterId: string, request: UpdateGatewayRequest): UpdateGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateGatewayWithOptions(GatewayId, ClusterId, request, headers, runtime);
}

model UpdateResourceRequest {
  resourceName?: string(name='ResourceName', description='The new name of the resource group after the update. The name can be up to 27 characters in length.', example='iot'),
  selfManagedResourceOptions?: {
    nodeMatchLabels?: map[string]string(name='NodeMatchLabels', description='The key-value pairs for matched nodes.'),
    nodeTolerations?: [ 
      {
        effect?: string(name='effect', description='The effect.

Valid values:
- PreferNoSchedule
- NoSchedule
- NoExecute', example='NoSchedule'),
        key?: string(name='key', description='The name of the key.', example='key1'),
        operator?: string(name='operator', description='Relationship between key names and key values.
Valid values:
- Equal
- Exists', example='Equal'),
        value?: string(name='value', description='The name of the value.', example='value1'),
      }
    ](name='NodeTolerations', description='Tolerations for nodes.'),
  }(name='SelfManagedResourceOptions', description='The configurable options for self managed resource group.'),
}

model UpdateResourceResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
  resourceId?: string(name='ResourceId', description='The ID of the resource group.', example='eas-r-asdasdasd'),
  resourceName?: string(name='ResourceName', description='The name of the resource group.', example='iot'),
}

model UpdateResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateResourceResponseBody(name='body'),
}

async function updateResourceWithOptions(ClusterId: string, ResourceId: string, request: UpdateResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.resourceName)) {
    body['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.selfManagedResourceOptions)) {
    body['SelfManagedResourceOptions'] = request.selfManagedResourceOptions;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateResource',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateResource(ClusterId: string, ResourceId: string, request: UpdateResourceRequest): UpdateResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateResourceWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

model UpdateResourceDLinkRequest {
  destinationCIDRs?: string(name='DestinationCIDRs', description='The CIDR blocks of the clients that you want to connect to. After this parameter is specified, the CIDR blocks are added to the back-to-origin route of the server. Either this parameter or the VSwitchIdList parameter can be used to determine CIDR blocks.', example='72.16.0.0/16'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the Elastic Compute Service (ECS) instance belongs.', example='sg-bp149cedsfx2rfspd2d'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the peer primary vSwitch. After this parameter is specified, an elastic network interface (ENI) is created in the VSwitch.', example='vpc-uf66uio7md****'),
  vSwitchIdList?: [ string ](name='VSwitchIdList', description='The vSwitches of the clients that you want to connect to. After this parameter is specified, the CIDR blocks of these vSwitches are added to the back-to-origin route of the server.'),
}

model UpdateResourceDLinkResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Network interfaces are updating'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model UpdateResourceDLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateResourceDLinkResponseBody(name='body'),
}

async function updateResourceDLinkWithOptions(ClusterId: string, ResourceId: string, request: UpdateResourceDLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateResourceDLinkResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.destinationCIDRs)) {
    body['DestinationCIDRs'] = request.destinationCIDRs;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    body['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    body['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vSwitchIdList)) {
    body['VSwitchIdList'] = request.vSwitchIdList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateResourceDLink',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/dlink`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateResourceDLink(ClusterId: string, ResourceId: string, request: UpdateResourceDLinkRequest): UpdateResourceDLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateResourceDLinkWithOptions(ClusterId, ResourceId, request, headers, runtime);
}

model UpdateResourceInstanceRequest {
  action?: string(name='Action', example='Cordon'),
}

model UpdateResourceInstanceResponseBody = {
  instanceId?: string(name='InstanceId', example='eas-i-asdasdasd'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
  resourceId?: string(name='ResourceId', example='eas-r-asdasdasd'),
}

model UpdateResourceInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateResourceInstanceResponseBody(name='body'),
}

async function updateResourceInstanceWithOptions(ClusterId: string, ResourceId: string, InstanceId: string, request: UpdateResourceInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateResourceInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.action)) {
    body['Action'] = request.action;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateResourceInstance',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/resources/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ResourceId)}/instances/${OpenApiUtil.getEncodeParam(InstanceId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateResourceInstance(ClusterId: string, ResourceId: string, InstanceId: string, request: UpdateResourceInstanceRequest): UpdateResourceInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateResourceInstanceWithOptions(ClusterId, ResourceId, InstanceId, request, headers, runtime);
}

model UpdateServiceRequest {
  updateType?: string(name='UpdateType'),
  body?: string(name='body', example='{   "name": "foo",   "model_path": "http://path/to/model.tar.gz",   "processor": "tensorflow_cpu",   "metadata": {     "instance": 2,     "memory": 7000,     "cpu": 4   } }'),
}

model UpdateServiceResponseBody = {
  message?: string(name='Message', example='Succeed to update service [foo] in region [cn-shanghai]'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
}

model UpdateServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceResponseBody(name='body'),
}

async function updateServiceWithOptions(ClusterId: string, ServiceName: string, request: UpdateServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.updateType)) {
    query['UpdateType'] = request.updateType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateService',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateService(ClusterId: string, ServiceName: string, request: UpdateServiceRequest): UpdateServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model UpdateServiceAutoScalerRequest {
  behavior?: {
    onZero?: {
      scaleDownGracePeriodSeconds?: int32(name='scaleDownGracePeriodSeconds', example='600'),
      scaleUpActivationReplicas?: int32(name='scaleUpActivationReplicas', example='1'),
    }(name='onZero'),
    scaleDown?: {
      stabilizationWindowSeconds?: int32(name='stabilizationWindowSeconds', example='300'),
    }(name='scaleDown'),
    scaleUp?: {
      stabilizationWindowSeconds?: int32(name='stabilizationWindowSeconds', example='0'),
    }(name='scaleUp'),
  }(name='behavior'),
  max?: int32(name='max', example='8'),
  min?: int32(name='min', example='2'),
  scaleStrategies?: [ 
    {
      metricName?: string(name='metricName', example='qps'),
      service?: string(name='service', example='demo_svc'),
      threshold?: float(name='threshold', example='100'),
    }
  ](name='scaleStrategies'),
}

model UpdateServiceAutoScalerResponseBody = {
  message?: string(name='Message', example='Update auto scale for service [foo] successfully'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
}

model UpdateServiceAutoScalerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceAutoScalerResponseBody(name='body'),
}

async function updateServiceAutoScalerWithOptions(ClusterId: string, ServiceName: string, request: UpdateServiceAutoScalerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceAutoScalerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.behavior)) {
    body['behavior'] = request.behavior;
  }
  if (!Util.isUnset(request.max)) {
    body['max'] = request.max;
  }
  if (!Util.isUnset(request.min)) {
    body['min'] = request.min;
  }
  if (!Util.isUnset(request.scaleStrategies)) {
    body['scaleStrategies'] = request.scaleStrategies;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceAutoScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/autoscaler`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateServiceAutoScaler(ClusterId: string, ServiceName: string, request: UpdateServiceAutoScalerRequest): UpdateServiceAutoScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceAutoScalerWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model UpdateServiceCronScalerRequest {
  excludeDates?: [ string ](name='ExcludeDates'),
  scaleJobs?: [ 
    {
      name?: string(name='Name', example='scale-job-1'),
      schedule?: string(name='Schedule', example='0 18 * * * *'),
      targetSize?: int32(name='TargetSize', example='2'),
    }
  ](name='ScaleJobs'),
}

model UpdateServiceCronScalerResponseBody = {
  message?: string(name='Message', example='Update cron scaler for service [foo] successfully'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
}

model UpdateServiceCronScalerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceCronScalerResponseBody(name='body'),
}

async function updateServiceCronScalerWithOptions(ClusterId: string, ServiceName: string, request: UpdateServiceCronScalerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceCronScalerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.excludeDates)) {
    body['ExcludeDates'] = request.excludeDates;
  }
  if (!Util.isUnset(request.scaleJobs)) {
    body['ScaleJobs'] = request.scaleJobs;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceCronScaler',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/cronscaler`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateServiceCronScaler(ClusterId: string, ServiceName: string, request: UpdateServiceCronScalerRequest): UpdateServiceCronScalerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceCronScalerWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model UpdateServiceInstanceRequest {
  isolate?: boolean(name='Isolate', description='Specifies whether to isolate the service instance.', example='true'),
}

model UpdateServiceInstanceResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Success'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model UpdateServiceInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceInstanceResponseBody(name='body'),
}

async function updateServiceInstanceWithOptions(ClusterId: string, ServiceName: string, InstanceName: string, request: UpdateServiceInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.isolate)) {
    body['Isolate'] = request.isolate;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceInstance',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/instances/${OpenApiUtil.getEncodeParam(InstanceName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateServiceInstance(ClusterId: string, ServiceName: string, InstanceName: string, request: UpdateServiceInstanceRequest): UpdateServiceInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceInstanceWithOptions(ClusterId, ServiceName, InstanceName, request, headers, runtime);
}

model UpdateServiceLabelRequest {
  labels?: map[string]string(name='Labels', description='The custom service tags.'),
}

model UpdateServiceLabelResponseBody = {
  message?: string(name='Message', description='The returned message.', example='Succeed to update service [service_from_XXXX] labels.'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model UpdateServiceLabelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceLabelResponseBody(name='body'),
}

async function updateServiceLabelWithOptions(ClusterId: string, ServiceName: string, request: UpdateServiceLabelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceLabelResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.labels)) {
    body['Labels'] = request.labels;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceLabel',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/label`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateServiceLabel(ClusterId: string, ServiceName: string, request: UpdateServiceLabelRequest): UpdateServiceLabelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceLabelWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model UpdateServiceMirrorRequest {
  ratio?: int32(name='Ratio', example='30'),
  target?: [ string ](name='Target'),
}

model UpdateServiceMirrorResponseBody = {
  message?: string(name='Message', example='Traffic mirroring is updating for service [foo] in region [cn-shanghia], ratio [70%]'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82***'),
}

model UpdateServiceMirrorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceMirrorResponseBody(name='body'),
}

async function updateServiceMirrorWithOptions(ClusterId: string, ServiceName: string, request: UpdateServiceMirrorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceMirrorResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ratio)) {
    body['Ratio'] = request.ratio;
  }
  if (!Util.isUnset(request.target)) {
    body['Target'] = request.target;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceMirror',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/mirror`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateServiceMirror(ClusterId: string, ServiceName: string, request: UpdateServiceMirrorRequest): UpdateServiceMirrorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceMirrorWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model UpdateServiceSafetyLockRequest {
  lock?: string(name='Lock', description='The lock scope. Valid values:

*   all: locks all operations.
*   dangerous: locks high-risk operations such as delete and stop operations.
*   none: locks no operations.', example='dangerous'),
}

model UpdateServiceSafetyLockResponseBody = {
  message?: string(name='Message', example='service safety lock updated to dangerous'),
  requestId?: string(name='RequestId', example='E089D584-B6F4-50C4-9902-DA2295B7****'),
}

model UpdateServiceSafetyLockResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceSafetyLockResponseBody(name='body'),
}

async function updateServiceSafetyLockWithOptions(ClusterId: string, ServiceName: string, request: UpdateServiceSafetyLockRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceSafetyLockResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.lock)) {
    body['Lock'] = request.lock;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceSafetyLock',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/lock`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateServiceSafetyLock(ClusterId: string, ServiceName: string, request: UpdateServiceSafetyLockRequest): UpdateServiceSafetyLockResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceSafetyLockWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

model UpdateServiceVersionRequest {
  version?: int32(name='Version', example='1'),
}

model UpdateServiceVersionResponseBody = {
  message?: string(name='Message', example='Service [foo] in region [cn-shanghai] is starting'),
  requestId?: string(name='RequestId', example='40325405-579C-4D82****'),
}

model UpdateServiceVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceVersionResponseBody(name='body'),
}

async function updateServiceVersionWithOptions(ClusterId: string, ServiceName: string, request: UpdateServiceVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceVersionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.version)) {
    body['Version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceVersion',
    version = '2021-07-01',
    protocol = 'HTTPS',
    pathname = `/api/v2/services/${OpenApiUtil.getEncodeParam(ClusterId)}/${OpenApiUtil.getEncodeParam(ServiceName)}/version`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateServiceVersion(ClusterId: string, ServiceName: string, request: UpdateServiceVersionRequest): UpdateServiceVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceVersionWithOptions(ClusterId, ServiceName, request, headers, runtime);
}

