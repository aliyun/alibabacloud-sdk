/**
  *
  */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Alidns';
  @version = '2015-01-09';
  @endpointRule = 'central';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AddCustomLineRequest {
  domainName: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.

This parameter is required.', example='example.com', position='Query'),
  ipSegment: [ 
    {
      endIp?: string(name='EndIp', description='The end IP address of the CIDR block.', example='192.0.2.254'),
      startIp?: string(name='StartIp', description='The start IP address of the CIDR block.', example='192.0.2.0'),
    }
  ](name='IpSegment', description='The CIDR blocks.

This parameter is required.', position='Query'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en', position='Query'),
  lineName: string(name='LineName', description='The name of the custom line.

This parameter is required.', position='Query'),
}

model AddCustomLineResponseBody = {
  lineCode?: string(name='LineCode', description='The code of the custom line.', example='hra0yc-597'),
  lineId?: long(name='LineId', description='The unique ID of the custom line.', example='597'),
  requestId?: string(name='RequestId', description='The request ID.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
}

model AddCustomLineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddCustomLineResponseBody(name='body'),
}

/**
  * @description In each CIDR block, the end IP address must be greater than or equal to the start IP address.\\
  * The CIDR blocks that are specified for all custom lines of a domain name cannot be overlapped.
  * @param request  the request parameters of AddCustomLine  AddCustomLineRequest
  * @return AddCustomLineResponse
 */
async function addCustomLine(request: AddCustomLineRequest): AddCustomLineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddCustomLine', 'POST', '/', 'json', false, 'json', request);
}

model AddDnsCacheDomainRequest {
  cacheTtlMax: int32(name='CacheTtlMax', description='The maximum TTL period of the cached data retrieved from the origin DNS server. Unit: seconds. Valid values: 30 to 86400.

This parameter is required.', example='86400', minimum=30, maximum=86400, position='Query'),
  cacheTtlMin: int32(name='CacheTtlMin', description='The minimum time-to-live (TTL) period of the cached data retrieved from the origin Domain Name System (DNS) server. Unit: seconds. Valid values: 30 to 86400.

This parameter is required.', example='30', minimum=30, maximum=86400, position='Query'),
  domainName: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.

This parameter is required.', example='dns.example.com', position='Query'),
  instanceId: string(name='InstanceId', description='The instance ID of the cache-accelerated domain name. You can call the [ListCloudGtmInstances](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-listcloudgtminstances?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the instance ID.

This parameter is required.', example='dns-cn-j6666', position='Query'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English Default: **zh**', example='en', position='Query'),
  remark?: string(name='Remark', description='The remarks.', example='test', position='Query'),
  sourceDnsServer: [ 
    {
      host: string(name='Host', description='The domain name or IP address of the origin DNS server.

This parameter is required.', example='192.0.0.0'),
      port: string(name='Port', description='The port of the origin DNS server.

This parameter is required.', example='53'),
    }
  ](name='SourceDnsServer', description='The origin DNS servers. A maximum of 10 origin DNS servers are supported.

This parameter is required.', position='Query'),
  sourceEdns: string(name='SourceEdns', description='Specifies whether the origin DNS server supports Extension Mechanisms for DNS (EDNS). Valid values: NOT_SUPPORT and SUPPORT.

This parameter is required.', example='SUPPORT', position='Query'),
  sourceProtocol: string(name='SourceProtocol', description='The origin protocol policy. Valid values: TCP and UDP. Default value: UDP.

This parameter is required.', example='UDP', position='Query'),
}

model AddDnsCacheDomainResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='B57C121B-A45F-44D8-A9B2-XXXXXXX'),
}

model AddDnsCacheDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddDnsCacheDomainResponseBody(name='body'),
}

/**
  * @param request  the request parameters of AddDnsCacheDomain  AddDnsCacheDomainRequest
  * @return AddDnsCacheDomainResponse
 */
async function addDnsCacheDomain(request: AddDnsCacheDomainRequest): AddDnsCacheDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddDnsCacheDomain', 'POST', '/', 'json', false, 'json', request);
}

model AddDnsGtmAccessStrategyRequest {
  defaultAddrPool: [ 
    {
      id?: string(name='Id', description='The ID of the address pool in the primary address pool set.', example='pool1'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool in the primary address pool set.', example='1'),
    }
  ](name='DefaultAddrPool', description='The address pools in the primary address pool set.

This parameter is required.', position='Query'),
  defaultAddrPoolType: string(name='DefaultAddrPoolType', description='The type of the primary address pool. Valid values:

*   IPV4
*   IPV6
*   DOMAIN

This parameter is required.', example='ipv4', position='Query'),
  defaultLatencyOptimization?: string(name='DefaultLatencyOptimization', description='Specifies whether to enable DNS resolution with optimal latency for the primary address pool set. Valid values:

*   OPEN
*   CLOSE', example='open', position='Query'),
  defaultLbaStrategy?: string(name='DefaultLbaStrategy', description='The load balancing policy of the primary address pool set. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr', position='Query'),
  defaultMaxReturnAddrNum?: int32(name='DefaultMaxReturnAddrNum', description='The maximum number of addresses returned from the primary address pool set.', example='3', minimum=1, maximum=8, position='Query'),
  defaultMinAvailableAddrNum: int32(name='DefaultMinAvailableAddrNum', description='The minimum number of available addresses in the primary address pool set.

This parameter is required.', example='1', minimum=1, maximum=400, position='Query'),
  failoverAddrPool?: [ 
    {
      id?: string(name='Id', description='The ID of the address pool in the secondary address pool set.', example='pool1'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool in the secondary address pool set.', example='1'),
    }
  ](name='FailoverAddrPool', description='The address pools in the secondary address pool set. If no address pool exists in the secondary address pool set, set this parameter to EMPTY.', position='Query'),
  failoverAddrPoolType?: string(name='FailoverAddrPoolType', description='The type of the secondary address pool. Valid values:

*   IPV4
*   IPV6
*   DOMAIN', example='ipv4', position='Query'),
  failoverLatencyOptimization?: string(name='FailoverLatencyOptimization', description='Specifies whether to enable DNS resolution with optimal latency for the secondary address pool set. Valid values:

*   OPEN
*   CLOSE', example='open', position='Query'),
  failoverLbaStrategy?: string(name='FailoverLbaStrategy', description='The load balancing policy of the secondary address pool set. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr', position='Query'),
  failoverMaxReturnAddrNum?: int32(name='FailoverMaxReturnAddrNum', description='The maximum number of addresses returned from the secondary address pool set.', example='1', minimum=1, maximum=8, position='Query'),
  failoverMinAvailableAddrNum?: int32(name='FailoverMinAvailableAddrNum', description='The minimum number of available addresses in the secondary address pool set.', example='1', minimum=1, maximum=400, position='Query'),
  instanceId: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='instance1', position='Query'),
  lang?: string(name='Lang', description='The language of the values for specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
  lines?: string(name='Lines', description='The Domain Name System (DNS) request source. For example: `["default", "drpeng"]` indicates Global and Dr. Peng Group.', example='["default", "drpeng"]', position='Query'),
  strategyMode: string(name='StrategyMode', description='The type of the access policy. Valid values:

*   GEO: geographical location-based access policy
*   LATENCY: latency-based access policy

This parameter is required.', example='geo', position='Query'),
  strategyName: string(name='StrategyName', description='The name of the access policy.

This parameter is required.', example='testStrategyName', position='Query'),
}

model AddDnsGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy.', example='testStrategyId1'),
}

model AddDnsGtmAccessStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddDnsGtmAccessStrategyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of AddDnsGtmAccessStrategy  AddDnsGtmAccessStrategyRequest
  * @return AddDnsGtmAccessStrategyResponse
 */
async function addDnsGtmAccessStrategy(request: AddDnsGtmAccessStrategyRequest): AddDnsGtmAccessStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddDnsGtmAccessStrategy', 'POST', '/', 'json', false, 'json', request);
}

model AddDnsGtmAddressPoolRequest {
  addr: [ 
    {
      addr: string(name='Addr', description='The address in the address pool.

This parameter is required.', example='1.1.1.1'),
      attributeInfo: string(name='AttributeInfo', description='The information about the source region of the address. The value of this parameter is a JSON string. Valid values:

*   lineCode: the line code of the source region for the address

*   lineCodeRectifyType: the rectification type of the line code. Default value: AUTO. Valid values:

    *   NO_NEED: no need for rectification
    *   RECTIFIED: rectified
    *   AUTO: automatic rectification

This parameter is required.', example='default'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address.', example='1'),
      mode: string(name='Mode', description='The return mode of the addresses: Valid values:

*   SMART: smart return
*   ONLINE: always online
*   OFFLINE: always offline

This parameter is required.', example='online'),
      remark?: string(name='Remark', description='The description of the address pool.', example='test'),
    }
  ](name='Addr', description='The address pools.

This parameter is required.', position='Query'),
  evaluationCount?: int32(name='EvaluationCount', description='The number of consecutive failures.', example='1', minimum=1, maximum=9999999, position='Query'),
  instanceId: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='instance1', position='Query'),
  interval?: int32(name='Interval', description='The health check interval. Unit: seconds.', example='1', minimum=1, maximum=9999999, position='Query'),
  ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The city code.

Specify the parameter according to the value of CityCode returned by the DescribeGtmMonitorAvailableConfig operation.', example='503'),
      ispCode?: string(name='IspCode', description='*   The Internet service provider (ISP) node. Specify the parameter according to the value of IspCode returned by the DescribeGtmMonitorAvailableConfig operation.
*   If the returned value of GroupType for the DescribeGtmMonitorAvailableConfig operation is BGP or Overseas, IspCode is not required and is set to 465 by default.
*   If the returned value of GroupType for the DescribeGtmMonitorAvailableConfig operation is not BGP or Overseas, IspCode is required. When IspCode is specified, CityCode is required.', example='465'),
    }
  ](name='IspCityNode', description='The nodes for monitoring.', position='Query'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
  lbaStrategy: string(name='LbaStrategy', description='The load balancing policy of the address pool. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.

This parameter is required.', example='all_rr', position='Query'),
  monitorExtendInfo?: string(name='MonitorExtendInfo', description='The extended information. The required parameters vary based on the health check protocol.

*   HTTP or HTTPS:

    *   port: the port that you want to check

    *   host: the host settings

    *   path: the URL

    *   code: the return code. The health check result is deemed abnormal if the returned value is greater than the specified value. Valid values: 400 and 500.

    *   failureRate: the failure rate

    *   sni: specifies whether to enable Server Name Indication (SNI). This parameter is available only when ProtocolType is set to HTTPS. Valid values:

        *   true: enables SNI.
        *   other: disables SNI.

    *   nodeType: the type of the node for monitoring when Type is set to DOMAIN. Valid values:

        *   IPV4
        *   IPV6

*   ping:

    *   failureRate: the failure rate

    *   packetNum: the number of ping packets

    *   packetLossRate: the loss rate of ping packets

    *   nodeType: the type of the node for monitoring when Type is set to DOMAIN. Valid values:

        *   IPV4
        *   IPV6

*   TCP:

    *   port: the port that you want to check

    *   failureRate: the failure rate

    *   nodeType: the type of the node for monitoring when Type is set to DOMAIN. Valid values:

        *   IPV4
        *   IPV6', example='{\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}', position='Query'),
  monitorStatus?: string(name='MonitorStatus', description='Specifies whether to enable the health check feature. If you set this parameter to OPEN, the system verifies the health check configurations. If you set this parameter to CLOSE, the system discards the health check configurations. Default value: CLOSE. Valid values:

*   OPEN: enables the health check feature.
*   CLOSE: disables the health check feature.', example='open', position='Query'),
  name: string(name='Name', description='The name of the address pool.

This parameter is required.', example='test', position='Query'),
  protocolType?: string(name='ProtocolType', description='The health check protocol. Valid values:

*   HTTP
*   HTTPS
*   PING
*   TCP', example='http', position='Query'),
  timeout?: int32(name='Timeout', description='The timeout period. Unit: milliseconds.', example='1', minimum=1, maximum=9999999, position='Query'),
  type: string(name='Type', description='The type of the address pool. Valid values:

*   IPV4: IPv4 address
*   IPV6: IPv6 address
*   DOMAIN: domain name

This parameter is required.', example='ipv4', position='Query'),
}

model AddDnsGtmAddressPoolResponseBody = {
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.', example='testpool1'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.', example='test1'),
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model AddDnsGtmAddressPoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddDnsGtmAddressPoolResponseBody(name='body'),
}

/**
  * @param request  the request parameters of AddDnsGtmAddressPool  AddDnsGtmAddressPoolRequest
  * @return AddDnsGtmAddressPoolResponse
 */
async function addDnsGtmAddressPool(request: AddDnsGtmAddressPoolRequest): AddDnsGtmAddressPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddDnsGtmAddressPool', 'POST', '/', 'json', false, 'json', request);
}

model AddDnsGtmMonitorRequest {
  addrPoolId: string(name='AddrPoolId', description='The ID of the address pool.

This parameter is required.', example='pool1', position='Query'),
  evaluationCount: int32(name='EvaluationCount', description='The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.

This parameter is required.', example='1', minimum=1, maximum=3, position='Query'),
  interval: int32(name='Interval', description='The health check interval. Unit: seconds.

This parameter is required.', example='60', minimum=15, maximum=60, position='Query'),
  ispCityNode: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the city where the monitored node is deployed.', example='123'),
      ispCode?: string(name='IspCode', description='The code of the Internet service provider (ISP) to which the monitored node belongs.', example='123'),
    }
  ](name='IspCityNode', description='The monitored nodes.

This parameter is required.', position='Query'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
  monitorExtendInfo: string(name='MonitorExtendInfo', description='The extended information. The required parameters vary based on the value of ProtocolType.

*   HTTP or HTTPS

    *   port: the port that you want to check

    *   host: the host settings

    *   path: the URL path

    *   code: the response code. The health check result is deemed abnormal if the returned value is greater than the specified value.

    *   failureRate: the failure rate

    *   sni: specifies whether to enable server name indication (SNI). This parameter is available only when ProtocolType is set to HTTPS. Valid values:

        *   true: enables SNI.
        *   false: disables SNI.

    *   nodeType: the type of the node for monitoring when Type is set to DOMAIN. Valid values:

        *   IPV4
        *   IPV6

*   PING

    *   failureRate: the failure rate

    *   packetNum: the number of ping packets

    *   packetLossRate: the loss rate of ping packets

    *   nodeType: the type of the node for monitoring when Type is set to DOMAIN. Valid values:

        *   IPV4
        *   IPV6

*   TCP

    *   port: the port that you want to check

    *   failureRate: the failure rate

    *   nodeType: the type of the node for monitoring when Type is set to DOMAIN. Valid values:

        *   IPV4
        *   IPV6

This parameter is required.', example='{\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}', position='Query'),
  protocolType: string(name='ProtocolType', description='The health check protocol. Valid values:

*   HTTP
*   HTTPS
*   PING
*   TCP

This parameter is required.', example='http', position='Query'),
  timeout: int32(name='Timeout', description='The timeout period. Unit: milliseconds.

This parameter is required.', example='30000', minimum=1000, maximum=10000, position='Query'),
}

model AddDnsGtmMonitorResponseBody = {
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.', example='MonitorConfigId1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model AddDnsGtmMonitorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddDnsGtmMonitorResponseBody(name='body'),
}

/**
  * @description ***
  * @param request  the request parameters of AddDnsGtmMonitor  AddDnsGtmMonitorRequest
  * @return AddDnsGtmMonitorResponse
 */
async function addDnsGtmMonitor(request: AddDnsGtmMonitorRequest): AddDnsGtmMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddDnsGtmMonitor', 'POST', '/', 'json', false, 'json', request);
}

model AddDomainRequest {
  domainName: string(name='DomainName', description='The domain name.

This parameter is required.', example='dns-example.top', position='Query'),
  groupId?: string(name='GroupId', description='The ID of the group to which the domain name will belong. The default value is the ID of the default group.', example='2223', position='Query'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en.', example='en', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-resourcegroupid', position='Query'),
}

model AddDomainResponseBody = {
  dnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='DnsServers', description='The Domain Name System (DNS) servers configured for the domain name.'),
  domainId?: string(name='DomainId', description='The ID of the domain name.', example='00efd71a-770e-4255-b54e-6fe5659baffe'),
  domainName?: string(name='DomainName', description='The domain name.', example='dns-example.top'),
  groupId?: string(name='GroupId', description='The ID of the domain name group.', example='2223'),
  groupName?: string(name='GroupName', description='The name of the domain name group.', example='MyGroup'),
  punyCode?: string(name='PunyCode', description='The Punycode for the domain name. This parameter is returned only for Chinese domain names.', example='xn--fsq270a.com'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model AddDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddDomainResponseBody(name='body'),
}

/**
  * @description For more information about how to check whether a domain name is valid, see
  * [Domain name validity](https://www.alibabacloud.com/help/zh/doc-detail/67788.htm).
  * @param request  the request parameters of AddDomain  AddDomainRequest
  * @return AddDomainResponse
 */
async function addDomain(request: AddDomainRequest): AddDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddDomain', 'POST', '/', 'json', false, 'json', request);
}

model AddDomainBackupRequest {
  domainName: string(name='DomainName', description='The domain name.

This parameter is required.', example='test.aliyun.com', position='Query'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en.', example='en', position='Query'),
  periodType: string(name='PeriodType', description='The backup cycle. Valid values:

*   DAY: backs up data on a daily basis.
*   HOUR: backs up data on an hourly basis.

This parameter is required.', example='HOUR', position='Query'),
}

model AddDomainBackupResponseBody = {
  domainName?: string(name='DomainName', description='The domain name.', example='test.aliyun.com'),
  periodType?: string(name='PeriodType', description='The backup cycle.', example='DAY'),
  requestId?: string(name='RequestId', description='The request ID.', example='FD552816-FCC8-4832-B4A2-2DA0C2BA1688'),
}

model AddDomainBackupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddDomainBackupResponseBody(name='body'),
}

/**
  * @param request  the request parameters of AddDomainBackup  AddDomainBackupRequest
  * @return AddDomainBackupResponse
 */
async function addDomainBackup(request: AddDomainBackupRequest): AddDomainBackupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddDomainBackup', 'POST', '/', 'json', false, 'json', request);
}

model AddDomainGroupRequest {
  groupName: string(name='GroupName', description='The name of the domain name group.

This parameter is required.', example='MyGroup', position='Query'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en.', example='en', position='Query'),
}

model AddDomainGroupResponseBody = {
  groupId?: string(name='GroupId', description='The ID of the domain name group.', example='2223'),
  groupName?: string(name='GroupName', description='The name of the domain name group.', example='NewName'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model AddDomainGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddDomainGroupResponseBody(name='body'),
}

/**
  * @param request  the request parameters of AddDomainGroup  AddDomainGroupRequest
  * @return AddDomainGroupResponse
 */
async function addDomainGroup(request: AddDomainGroupRequest): AddDomainGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddDomainGroup', 'POST', '/', 'json', false, 'json', request);
}

model AddDomainRecordRequest {
  domainName: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.

This parameter is required.', example='example.com', position='Query'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English Default: **zh**', example='en', position='Query'),
  line?: string(name='Line', description='The resolution line. Default value: **default**. For more information, see

[DNS resolution lines](https://www.alibabacloud.com/help/zh/doc-detail/29807.htm).', example='default', position='Query'),
  priority?: long(name='Priority', description='The priority of the mail exchanger (MX) record. Valid values: `1 to 50`.

This parameter is required if the type of the DNS record is MX. A smaller value indicates a higher priority.', example='1', minimum=0, maximum=65535, position='Query'),
  rr: string(name='RR', description='The hostname.

For example, to resolve @.example.com, you must set this parameter to an at sign (@). You cannot leave this parameter empty.

This parameter is required.', example='www', position='Query'),
  TTL?: long(name='TTL', description='The time to live (TTL) period of the Alibaba Cloud DNS (DNS) record. Default value: 600. Unit: seconds. For more information, see

[TTL definition](https://www.alibabacloud.com/help/zh/doc-detail/29806.htm).', example='600', minimum=1, maximum=86400, position='Query'),
  type: string(name='Type', description='The type of the DNS record. For more information, see

[DNS record types](https://www.alibabacloud.com/help/zh/doc-detail/29805.htm).

This parameter is required.', example='A', position='Query'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0', position='Query'),
  value: string(name='Value', description='The value of the DNS record.

This parameter is required.', example='192.0.2.254', position='Query'),
}

model AddDomainRecordResponseBody = {
  recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model AddDomainRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddDomainRecordResponseBody(name='body'),
}

/**
  * @param request  the request parameters of AddDomainRecord  AddDomainRecordRequest
  * @return AddDomainRecordResponse
 */
async function addDomainRecord(request: AddDomainRecordRequest): AddDomainRecordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddDomainRecord', 'POST', '/', 'json', false, 'json', request);
}

model AddGtmAccessStrategyRequest {
  accessLines: string(name='AccessLines', description='The line codes of access regions.

This parameter is required.', example='["default", "drpeng"]', position='Query'),
  defaultAddrPoolId: string(name='DefaultAddrPoolId', description='The ID of the default address pool.

This parameter is required.', example='hrsix', position='Query'),
  failoverAddrPoolId: string(name='FailoverAddrPoolId', description='The ID of the failover address pool.

If the failover address pool is not set, pass the **Empty** value.

This parameter is required.', example='hrsyw', position='Query'),
  instanceId: string(name='InstanceId', description='The ID of the GTM instance for which you want to create an access policy.

This parameter is required.', example='instance1', position='Query'),
  lang?: string(name='Lang', description='The language used by the user.', example='en', position='Query'),
  strategyName: string(name='StrategyName', description='The name of the access policy.

This parameter is required.', position='Query'),
}

model AddGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy created.', example='strategyid'),
}

model AddGtmAccessStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddGtmAccessStrategyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of AddGtmAccessStrategy  AddGtmAccessStrategyRequest
  * @return AddGtmAccessStrategyResponse
 */
async function addGtmAccessStrategy(request: AddGtmAccessStrategyRequest): AddGtmAccessStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddGtmAccessStrategy', 'POST', '/', 'json', false, 'json', request);
}

model AddGtmAddressPoolRequest {
  addr: [ 
    {
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool.', example='1'),
      mode?: string(name='Mode', description='The mode of the address pool. Valid values:

*   **SMART**: smart return
*   **ONLINE**: always online
*   **OFFLINE**: always offline', example='SMART'),
      value?: string(name='Value', description='The address in the address pool.', example='1.1.1.1'),
    }
  ](name='Addr', description='The address pools.

This parameter is required.', position='Query'),
  evaluationCount?: int32(name='EvaluationCount', description='The number of consecutive failures.', example='2', position='Query'),
  instanceId: string(name='InstanceId', description='The ID of the GTM instance for which you want to create an address pool.

This parameter is required.', example='gtm-cn-xxxxxxx', position='Query'),
  interval?: int32(name='Interval', description='The health check interval. Unit: seconds. Set the value to 60.', example='60', position='Query'),
  ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the city where the monitored node is deployed. For more information about specific values, see the response parameters of DescribeGtmMonitorAvailableConfig.', example='546'),
      ispCode?: string(name='IspCode', description='*   The code of the Internet service provider (ISP) to which the monitored node belongs. For more information about specific values, see the response parameters of DescribeGtmMonitorAvailableConfig.
*   If the value of the GroupType parameter is BGP or OVERSEAS, IspCode is optional. The default value is 465.
*   If the value of the GroupType parameter is not BGP or OVERSEAS, IspCode is required and is used together with CityCode.', example='465'),
    }
  ](name='IspCityNode', description='The monitored nodes.', position='Query'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters.', example='en', position='Query'),
  minAvailableAddrNum: int32(name='MinAvailableAddrNum', description='The minimum number of available addresses in the address pool.

This parameter is required.', example='2', position='Query'),
  monitorExtendInfo?: string(name='MonitorExtendInfo', description='The extended information. The required parameters vary based on the value of ProtocolType.

When ProtocolType is set to HTTP or HTTPS:

*   port: the port that you want to check
*   failureRate: the failure rate
*   code: the return code. The health check result is deemed abnormal if the returned value is greater than the specified value. Valid values: 400 and 500.
*   host: the host settings
*   path: the URL path

When ProtocolType is set to PING:

*   packetNum: the number of ping packets
*   packetLossRate: the packet loss rate
*   failureRate: the failure rate

When ProtocolType is set to TCP:

*   port: the port that you want to check
*   failureRate: the failure rate', example='{"host":"aliyun.com","port":80}', position='Query'),
  monitorStatus?: string(name='MonitorStatus', description='Specifies whether to enable the health check. Valid values:

*   **OPEN**: enables the health check.
*   **CLOSE**: disables the health check. This is the default value.', example='OPEN', position='Query'),
  name: string(name='Name', description='The name of the address pool.

This parameter is required.', example='Alibaba Cloud cluster', position='Query'),
  protocolType?: string(name='ProtocolType', description='The health check protocol. Valid values:

*   HTTP
*   HTTPS
*   Ping
*   TCP', example='HTTPS', position='Query'),
  timeout?: int32(name='Timeout', description='The timeout period. Unit: milliseconds. Valid values: 2000, 3000, 5000, and 10000.', example='60', position='Query'),
  type: string(name='Type', description='The type of the address pool. Valid values:

*   **IP**: IPv4 address
*   **DOMAIN**: domain name

This parameter is required.', example='IP', position='Query'),
}

model AddGtmAddressPoolResponseBody = {
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool created.', example='hraf3x'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.', example='hraf14'),
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model AddGtmAddressPoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddGtmAddressPoolResponseBody(name='body'),
}

/**
  * @param request  the request parameters of AddGtmAddressPool  AddGtmAddressPoolRequest
  * @return AddGtmAddressPoolResponse
 */
async function addGtmAddressPool(request: AddGtmAddressPoolRequest): AddGtmAddressPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddGtmAddressPool', 'POST', '/', 'json', false, 'json', request);
}

model AddGtmMonitorRequest {
  addrPoolId: string(name='AddrPoolId', description='The ID of the address pool.

This parameter is required.', example='xxxx', position='Query'),
  evaluationCount: int32(name='EvaluationCount', description='The number of consecutive failures.

This parameter is required.', example='3', position='Query'),
  interval: int32(name='Interval', description='The health check interval. Unit: seconds. Set the value to 60.

This parameter is required.', example='60', position='Query'),
  ispCityNode: [ 
    {
      cityCode?: string(name='CityCode', description='The city code.

Specify the parameter according to the value of CityCode returned by the DescribeGtmMonitorAvailableConfig operation.', example='503'),
      ispCode?: string(name='IspCode', description='The Internet service provider (ISP) node. Specify the parameter according to the value of IspCode returned by the DescribeGtmMonitorAvailableConfig operation.

*   If the return value of GroupType for the DescribeGtmMonitorAvailableConfig operation is BGP or Overseas, IspCode is not required and is set to 465 by default.
*   If the return value of GroupType for the DescribeGtmMonitorAvailableConfig operation is not BGP or Overseas, IspCode is required. When IspCode is specified, CityCode is required.', example='465'),
    }
  ](name='IspCityNode', description='The nodes for monitoring.

This parameter is required.', position='Query'),
  lang?: string(name='Lang', description='The language.', example='en', position='Query'),
  monitorExtendInfo: string(name='MonitorExtendInfo', description='The extended information. The required parameters vary based on the health check protocol.

HTTP or HTTPS

*   port: the port that you want to check
*   failureRate: the failure rate
*   code: the return code. The health check result is deemed abnormal if the returned value is greater than the specified value. Valid values: 400 and 500.
*   host: the host settings
*   path: the URL path

PING

*   packetNum: the number of ping packets
*   packetLossRate: the packet loss rate
*   failureRate: the failure rate

TCP

*   port: the port that you want to check
*   failureRate: the failure rate

This parameter is required.', example='{\\"code\\":200,\\"path\\":\\"/index.htm\\",\\"host\\":\\"aliyun.com\\"}', position='Query'),
  protocolType: string(name='ProtocolType', description='The protocol used for the health check. Valid values:

*   HTTP
*   HTTPS
*   PING
*   TCP

This parameter is required.', example='HTTP', position='Query'),
  timeout: int32(name='Timeout', description='The health check timeout period. Unit: milliseconds. Valid values: 2000, 3000, 5000, and 10000.

This parameter is required.', example='3000', position='Query'),
}

model AddGtmMonitorResponseBody = {
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.', example='1234abc'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model AddGtmMonitorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddGtmMonitorResponseBody(name='body'),
}

/**
  * @param request  the request parameters of AddGtmMonitor  AddGtmMonitorRequest
  * @return AddGtmMonitorResponse
 */
async function addGtmMonitor(request: AddGtmMonitorRequest): AddGtmMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddGtmMonitor', 'POST', '/', 'json', false, 'json', request);
}

model AddGtmRecoveryPlanRequest {
  faultAddrPool: string(name='FaultAddrPool', description='The IDs of faulty address pools.

This parameter is required.', example='["hra0or"]', position='Query'),
  lang?: string(name='Lang', description='The language.', example='en', position='Query'),
  name: string(name='Name', description='The name of the disaster recovery plan.

This parameter is required.', example='name-example', position='Query'),
  remark?: string(name='Remark', description='The description of the disaster recovery plan.', example='remark', position='Query'),
}

model AddGtmRecoveryPlanResponseBody = {
  recoveryPlanId?: string(name='RecoveryPlanId', description='The ID of the disaster recovery plan.', example='100'),
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model AddGtmRecoveryPlanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddGtmRecoveryPlanResponseBody(name='body'),
}

/**
  * @param request  the request parameters of AddGtmRecoveryPlan  AddGtmRecoveryPlanRequest
  * @return AddGtmRecoveryPlanResponse
 */
async function addGtmRecoveryPlan(request: AddGtmRecoveryPlanRequest): AddGtmRecoveryPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddGtmRecoveryPlan', 'POST', '/', 'json', false, 'json', request);
}

model BindInstanceDomainsRequest {
  domainNames: string(name='DomainNames', description='The domain names.

>  Separate multiple domain names with commas (,). Up to 100 domain names can be entered.

This parameter is required.', example='example.com,example.net', position='Query'),
  instanceId: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='sdfasdf', position='Query'),
  lang?: string(name='Lang', description='The language.', example='en', position='Query'),
}

model BindInstanceDomainsResponseBody = {
  failedCount?: int32(name='FailedCount', description='The number of domain names that failed to be bound to the instance.', example='0'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  successCount?: int32(name='SuccessCount', description='The number of domain names that are bound to the instance.', example='2'),
}

model BindInstanceDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BindInstanceDomainsResponseBody(name='body'),
}

/**
  * @description A paid Alibaba Cloud DNS instance whose ID starts with dns is an instance of the new version. You can call this API operation to bind multiple domain names to the instance. If the upper limit is exceeded, an error message is returned.\\
  * A paid Alibaba Cloud DNS instance whose ID does not start with dns is an instance of the old version. You can call this API operation to bind only one domain name to the instance. However, if the instance is already bound to a domain name, you must unbind the original domain name from the instance and bind the desired domain name to the instance.
  * @param request  the request parameters of BindInstanceDomains  BindInstanceDomainsRequest
  * @return BindInstanceDomainsResponse
 */
async function bindInstanceDomains(request: BindInstanceDomainsRequest): BindInstanceDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BindInstanceDomains', 'POST', '/', 'json', false, 'json', request);
}

model ChangeDomainGroupRequest {
  domainName: string(name='DomainName', description='The domain name. You can call the [DescribeDomains ](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0)operation to obtain the domain name.

This parameter is required.', example='example.com', position='Query'),
  groupId?: string(name='GroupId', description='The ID of the target domain name group.

*   If you do not specify GroupId, the domain name belongs to the default group.
*   If you specify an empty string "" for GroupId, the domain name belongs to the default group.
*   If you set GroupId to defaultGroup, the domain name belongs to the default group.
*   If you specify GroupId to another value and the value is verified existent, the value of GroupId for the target domain name is updated. If the value is verified inexistent, the value of GroupId for the target domain name is not updated.', example='2223', position='Query'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en', example='en', position='Query'),
}

model ChangeDomainGroupResponseBody = {
  groupId?: string(name='GroupId', description='The ID of the target domain name group.', example='2223'),
  groupName?: string(name='GroupName', description='The name of the destination domain name group.', example='MyGroup'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model ChangeDomainGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeDomainGroupResponseBody(name='body'),
}

/**
  * @description You can specify GroupId to move a domain name to a specific domain name group. You can move the domain name to the group that contains all domain names or the default group.
  * @param request  the request parameters of ChangeDomainGroup  ChangeDomainGroupRequest
  * @return ChangeDomainGroupResponse
 */
async function changeDomainGroup(request: ChangeDomainGroupRequest): ChangeDomainGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ChangeDomainGroup', 'POST', '/', 'json', false, 'json', request);
}

model ChangeDomainOfDnsProductRequest {
  force?: boolean(name='Force', description='Specifies whether to forcibly bind a domain name to the instance. Valid values:

*   **false****: no**
*   **true**: **yes**

Default value: **false**.', example='false', position='Query'),
  instanceId: string(name='InstanceId', description='The ID of the Alibaba Cloud Domain Name System (DNS) instance.

You can call the [ListCloudGtmInstances ](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-listcloudgtminstances?spm=a2c63.p38356.help-menu-search-29697.d_0)operation to obtain the ID.

This parameter is required.', example='i-7sb', position='Query'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English

Default value: **zh**.', example='en', position='Query'),
  newDomain?: string(name='NewDomain', description='The domain name that you want to bind to the instance. If you leave this parameter empty, the domain name that is bound to the instance is unbound from the instance.', example='newdomain.com', position='Query'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='1.1.1.1', position='Query'),
}

model ChangeDomainOfDnsProductResponseBody = {
  originalDomain?: string(name='OriginalDomain', description='The domain name that is originally bound to the instance. If no value is returned for this parameter, the instance is bound to a domain name for the first time.', example='originaldomain.com'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model ChangeDomainOfDnsProductResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeDomainOfDnsProductResponseBody(name='body'),
}

/**
  * @description *   **You can call this operation regardless of whether the Alibaba Cloud DNS instance is bound to a domain name. You can also call this operation to unbind the domain name from the Alibaba Cloud DNS instance by leaving the NewDomain parameter empty.**
  * *   **This operation applies to instances of the custom edition. To change the domain name that is bound to an Alibaba Cloud DNS instance of Personal Edition, Enterprise Standard Edition, or Enterprise Ultimate Edition, call the BindInstanceDomains operation.
  * @param request  the request parameters of ChangeDomainOfDnsProduct  ChangeDomainOfDnsProductRequest
  * @return ChangeDomainOfDnsProductResponse
 */
async function changeDomainOfDnsProduct(request: ChangeDomainOfDnsProductRequest): ChangeDomainOfDnsProductResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ChangeDomainOfDnsProduct', 'POST', '/', 'json', false, 'json', request);
}

model CopyGtmConfigRequest {
  copyType: string(name='CopyType', description='The type of the object that is copied. Only the INSTANCE type is supported.

This parameter is required.', example='INSTANCE', position='Query'),
  lang?: string(name='Lang', description='The language.', example='en', position='Query'),
  sourceId: string(name='SourceId', description='The ID of the source object. Only instance IDs are supported.

This parameter is required.', example='gtm-cn-0pp1j84v60d', position='Query'),
  targetId: string(name='TargetId', description='The ID of the target object. Only instance IDs are supported.

This parameter is required.', example='gtm-cn-v0h1gaujg06', position='Query'),
}

model CopyGtmConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='389DFFA3-77A5-4A9E-BF3D-147C6F98A5BA'),
}

model CopyGtmConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CopyGtmConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CopyGtmConfig  CopyGtmConfigRequest
  * @return CopyGtmConfigResponse
 */
async function copyGtmConfig(request: CopyGtmConfigRequest): CopyGtmConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CopyGtmConfig', 'POST', '/', 'json', false, 'json', request);
}

model CreateCloudGtmAddressRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='zh-CN', position='Query'),
  address: string(name='Address', description='IP address or domain name.

This parameter is required.', example='223.5.XX.XX', position='Query'),
  attributeInfo?: string(name='AttributeInfo', description='Address ownership information.', example='当前版本不支持传入此参数，请不要传入参数。', position='Query'),
  availableMode: string(name='AvailableMode', description='The failover mode that is used when address exceptions are identified. Valid values:

*   auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
*   manual: the manual mode. If an address is in the unavailable state, the address is not returned for DNS requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.

This parameter is required.', example='auto', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  enableStatus: string(name='EnableStatus', description='Indicates the current enabled status of the address:
- enable: Enabled status 
- disable: Disabled status

This parameter is required.', example='enable', position='Query'),
  healthJudgement: string(name='HealthJudgement', description='The condition for determining the health status of the address. This parameter is required when HealthTasks is specified. Valid values:

*   any_ok: The health check results of at least one health check template are normal.
*   p30_ok: The health check results of at least 30% of health check templates are normal.
*   p50_ok: The health check results of at least 50% of health check templates are normal.
*   p70_ok: The health check results of at least 70% of health check templates are normal.
*   all_ok: The health check results of all health check templates are normal.

This parameter is required.', example='p50_ok', position='Query'),
  healthTasks?: [ 
    {
      port?: int32(name='Port', description='The service port of the address on which health check tasks are performed. If the ping protocol is used for health checks, the configuration of the service port is not supported.', example='80'),
      templateId?: string(name='TemplateId', description='The ID of the health check template associated with the address.', example='mtp-89518052425100**80'),
    }
  ](name='HealthTasks', description='The health check tasks associated with the address.', shrink='json', position='Query'),
  manualAvailableStatus?: string(name='ManualAvailableStatus', description='The availability state of the address. This parameter is required when AvailableMode is set to **manual**. Valid values:

*   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
*   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.', example='available', position='Query'),
  name: string(name='Name', description='Address name.

This parameter is required.', example='Address-1', position='Query'),
  remark?: string(name='Remark', description='Remarks.', example='test', position='Query'),
  type: string(name='Type', description='Address type:
- IPv4
- IPv6
- domain

This parameter is required.', example='IPv4', position='Query'),
}

model CreateCloudGtmAddressResponseBody = {
  addressId?: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.', example='addr-8951821811436**192'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='46973D4C-E3E4-4ABA-9190-9A9DE406C7E'),
  success?: boolean(name='Success', description='Indicates whether the address creation operation is successful:
- true: Operation was successful
- false: Operation was failed', example='true'),
}

model CreateCloudGtmAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCloudGtmAddressResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateCloudGtmAddress  CreateCloudGtmAddressRequest
  * @return CreateCloudGtmAddressResponse
 */
async function createCloudGtmAddress(request: CreateCloudGtmAddressRequest): CreateCloudGtmAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCloudGtmAddress', 'POST', '/', 'json', false, 'json', request);
}

model CreateCloudGtmAddressPoolRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  addressPoolName?: string(name='AddressPoolName', description='Address pool name, helping users distinguish the purpose of address pools.', example='Address pool-1', position='Query'),
  addressPoolType?: string(name='AddressPoolType', description='The type of the address pool. Valid values:

*   IPv4: IPv4 addresses are returned for Domain Name System (DNS) resolution.
*   IPv6: IPv6 addresses are returned for DNS resolution.
*   domain: Domain names are returned for DNS resolution.', example='IPv4', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  enableStatus?: string(name='EnableStatus', description='The enabling state of the address pool. Valid values:

*   enable: The address pool is enabled, and the addresses in the address pool are returned for DNS resolution when the health check results are normal.
*   disable: The address pool is disabled, and the addresses in the address pool are not returned for DNS resolution regardless of whether the health check results are normal or not.', example='enable', position='Query'),
  healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address pool. Valid values:

*   any_ok: At least one address in the address pool is available.
*   p30_ok: At least 30% of the addresses in the address pool are available.
*   p50_ok: At least 50% of the addresses in the address pool are available.
*   p70_ok: At least 70% of the addresses in the address pool are available.
*   all_ok: All addresses in the address pool are available.', example='any_ok', position='Query'),
  remark?: string(name='Remark', description='Remarks for the address pool, helping users distinguish the usage scenarios of different address pools.', example='app', position='Query'),
}

model CreateCloudGtmAddressPoolResponseBody = {
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='46973D4C-E3E4-4ABA-9190-9A9DE406C7E'),
  success?: boolean(name='Success', description='Indicates whether the address pool creation operation was successful:
- true: Operation was successful
- false: Operation was failed', example='true'),
}

model CreateCloudGtmAddressPoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCloudGtmAddressPoolResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateCloudGtmAddressPool  CreateCloudGtmAddressPoolRequest
  * @return CreateCloudGtmAddressPoolResponse
 */
async function createCloudGtmAddressPool(request: CreateCloudGtmAddressPoolRequest): CreateCloudGtmAddressPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCloudGtmAddressPool', 'POST', '/', 'json', false, 'json', request);
}

model CreateCloudGtmInstanceConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US: English', example='en-US', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  enableStatus?: string(name='EnableStatus', description='The enabling state of the access domain name. Valid values:

*   enable: The access domain name is enabled and the intelligent scheduling policy of the corresponding GTM instance takes effect.
*   disable: The access domain name is disabled and the intelligent scheduling policy of the corresponding GTM instance is unavailable.', example='enable', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the Global Traffic Manager (GTM) 3.0 instance. This ID uniquely identifies a GTM 3.0 instance.', example='gtm-cn-jmp3qnw**03', position='Query'),
  remark?: string(name='Remark', description='The description of the access domain name.', example='test', position='Query'),
  scheduleHostname?: string(name='ScheduleHostname', description='The hostname of the access domain name.', example='www', position='Query'),
  scheduleRrType?: string(name='ScheduleRrType', description='The type of the Domain Name System (DNS) record configured for the access domain name. Valid values:

*   A: IPv4 address
*   AAAA: IPv6 address
*   CNAME: domain name', example='A', position='Query'),
  scheduleZoneMode?: string(name='ScheduleZoneMode', description='The configuration mode of the access domain name. Valid values:

*   sys_assign: system allocation. This mode is not supported.
*   custom: custom allocation. You must select a zone within the account to which the instance belongs and enter a hostname to generate an access domain name.', example='custom', position='Query'),
  scheduleZoneName?: string(name='ScheduleZoneName', description='The name of the parent zone for the access domain name configured in GTM. In most cases, the value of this parameter is the name of a zone hosted by Alibaba Cloud DNS. This zone belongs to the account to which the GTM instance belongs. You can specify the name of a zone or subzone.', example='example.com', position='Query'),
  ttl?: int32(name='Ttl', description='The global time to live (TTL) period. Unit: seconds. The global TTL period affects how long the DNS records that map the access domain name to the addresses in the address pools are cached in the local DNS servers of Internet service providers (ISPs). You can specify a custom value.', example='30', position='Query'),
}

model CreateCloudGtmInstanceConfigResponseBody = {
  configId?: boolean(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.', example='config-000**1'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model CreateCloudGtmInstanceConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCloudGtmInstanceConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateCloudGtmInstanceConfig  CreateCloudGtmInstanceConfigRequest
  * @return CreateCloudGtmInstanceConfigResponse
 */
async function createCloudGtmInstanceConfig(request: CreateCloudGtmInstanceConfigRequest): CreateCloudGtmInstanceConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCloudGtmInstanceConfig', 'POST', '/', 'json', false, 'json', request);
}

model CreateCloudGtmMonitorTemplateRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  evaluationCount: int32(name='EvaluationCount', description='This parameter is required.', example='2', position='Query'),
  extendInfo?: string(name='ExtendInfo', description='The extended information. The value of this parameter is a JSON string. The required parameters vary based on the health check protocol.

*   HTTP or HTTPS:

    **host**: the Host field of an HTTP or HTTPS request header during an HTTP or HTTPS health check. The parameter value indicates the HTTP website that you want to visit. By default, the value is the primary domain name. You can change the value based on your business requirements.

    **path**: the URL for HTTP or HTTPS health checks. Default value: /.

    **code**: the alert threshold. During an HTTP or HTTPS health check, the system checks whether a web server functions as expected based on the status code that is returned from the web server. If the returned status code is greater than the specified threshold, the corresponding application service address is deemed abnormal. Valid values:

    *   400: specifies an invalid request. If an HTTP or HTTPS request contains invalid request parameters, a web server returns a status code that is greater than 400. You must set path to an exact URL if you set code to 400.
    *   500: specifies a server error. If some exceptions occur on a web server, the web server returns a status code that is greater than 500. This value is used by default.

    **sni**: specifies whether to enable Server Name Indication (SNI). This parameter is used only when the health check protocol is HTTPS. SNI is an extension to the Transport Layer Security (TLS) protocol, which allows a client to specify the host to be connected when the client sends a TLS handshake request. TLS handshakes occur before any data of HTTP requests is sent. Therefore, SNI enables servers to identify the services that clients are attempting to access before certificates are sent. This allows the servers to present correct certificates to the clients. Valid values:

    *   true: enables SNI.
    *   false: disables SNI.

    **followRedirect**: specifies whether to follow 3XX redirects. Valid values:

    *   true: follows 3XX redirects. You are redirected to the destination address if a 3XX status code such as 301, 302, 303, 307, or 308 is returned.
    *   false: does not follow 3XX redirects.

*   ping:

    **packetNum**: the total number of Internet Control Message Protocol (ICMP) packets that are sent to the address for each ping-based health check. Valid values: 20, 50, and 100.

    **packetLossRate**: the ICMP packet loss rate for each ping-based health check. The packet loss rate in a health check can be calculated by using the following formula: Packet loss rate in a health check = (Number of lost packets/Total number of sent ICMP packets) × 100%. If the packet loss rate reaches the threshold, an alert is triggered. Valid values: 10, 30, 40, 80, 90, and 100.', example='{\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}', position='Query'),
  failureRate: int32(name='FailureRate', description='This parameter is required.', example='50', position='Query'),
  interval: int32(name='Interval', description='This parameter is required.', example='60', position='Query'),
  ipVersion: string(name='IpVersion', description='The IP address type of health check nodes. Valid values:

*   IPv4: You can set IpVersion to IPv4 to perform health checks on IPv4 addresses.
*   IPv6: You can set IpVersion to IPv6 to perform health checks on IPv6 addresses.

This parameter is required.', example='IPv4', position='Query'),
  ispCityNodes: [ 
    {
      cityCode?: string(name='CityCode', description='The city code of the health check node.', example='503'),
      ispCode?: string(name='IspCode', description='The Internet service provider (ISP) code of the health check node.', example='465'),
    }
  ](name='IspCityNodes', description='The health check nodes. You can call the [ListCloudGtmMonitorNodes](~~ListCloudGtmMonitorNodes~~) operation to obtain the health check nodes.

This parameter is required.', shrink='json', position='Query'),
  name: string(name='Name', description='The name of the health check template. We recommend that you use a name that distinguishes the type of health check protocol used.

This parameter is required.', example='Ping-IPv4', position='Query'),
  protocol: string(name='Protocol', description='This parameter is required.', example='ping', position='Query'),
  timeout: int32(name='Timeout', description='This parameter is required.', example='5000', position='Query'),
}

model CreateCloudGtmMonitorTemplateResponseBody = {
  requestId?: string(name='RequestId', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
  success?: boolean(name='Success', example='true'),
  templateId?: string(name='TemplateId', description='The ID of the health check template. This ID uniquely identifies the health check template.', example='mtp-89518052425100**80'),
}

model CreateCloudGtmMonitorTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCloudGtmMonitorTemplateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateCloudGtmMonitorTemplate  CreateCloudGtmMonitorTemplateRequest
  * @return CreateCloudGtmMonitorTemplateResponse
 */
async function createCloudGtmMonitorTemplate(request: CreateCloudGtmMonitorTemplateRequest): CreateCloudGtmMonitorTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCloudGtmMonitorTemplate', 'POST', '/', 'json', false, 'json', request);
}

model CreatePdnsAppKeyRequest {
  lang?: string(name='Lang', position='Query'),
  remark?: string(name='Remark', position='Query'),
}

model CreatePdnsAppKeyResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreatePdnsAppKeyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePdnsAppKeyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreatePdnsAppKey  CreatePdnsAppKeyRequest
  * @return CreatePdnsAppKeyResponse
 */
async function createPdnsAppKey(request: CreatePdnsAppKeyRequest): CreatePdnsAppKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreatePdnsAppKey', 'POST', '/', 'json', false, 'json', request);
}

model CreatePdnsUdpIpSegmentRequest {
  ip?: string(name='Ip', position='Query'),
  ipToken?: string(name='IpToken', position='Query'),
  lang?: string(name='Lang', position='Query'),
  name?: string(name='Name', position='Query'),
}

model CreatePdnsUdpIpSegmentResponseBody = {
  requestId?: string(name='RequestId'),
  validMessage?: string(name='ValidMessage'),
}

model CreatePdnsUdpIpSegmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePdnsUdpIpSegmentResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreatePdnsUdpIpSegment  CreatePdnsUdpIpSegmentRequest
  * @return CreatePdnsUdpIpSegmentResponse
 */
async function createPdnsUdpIpSegment(request: CreatePdnsUdpIpSegmentRequest): CreatePdnsUdpIpSegmentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreatePdnsUdpIpSegment', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCloudGtmAddressRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  addressId: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.

This parameter is required.', example='addr-895182181143688192', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
}

model DeleteCloudGtmAddressResponseBody = {
  requestId?: string(name='RequestId', description='Unique request identification code.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  success?: boolean(name='Success', description='Indicates whether the address deletion operation was successful:
- true: Operation successful
- false: Operation failed', example='true'),
}

model DeleteCloudGtmAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCloudGtmAddressResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteCloudGtmAddress  DeleteCloudGtmAddressRequest
  * @return DeleteCloudGtmAddressResponse
 */
async function deleteCloudGtmAddress(request: DeleteCloudGtmAddressRequest): DeleteCloudGtmAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCloudGtmAddress', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCloudGtmAddressPoolRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
}

model DeleteCloudGtmAddressPoolResponseBody = {
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
  requestId?: string(name='RequestId', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  success?: boolean(name='Success', example='true'),
}

model DeleteCloudGtmAddressPoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCloudGtmAddressPoolResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteCloudGtmAddressPool  DeleteCloudGtmAddressPoolRequest
  * @return DeleteCloudGtmAddressPoolResponse
 */
async function deleteCloudGtmAddressPool(request: DeleteCloudGtmAddressPoolRequest): DeleteCloudGtmAddressPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCloudGtmAddressPool', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCloudGtmInstanceConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration. You can call the [ListCloudGtmInstanceConfigs](~~ListCloudGtmInstanceConfigs~~) operation to query the configuration ID of the access domain name.', example='config-000**1', position='Query'),
  instanceId?: string(name='InstanceId', description='The access domain name that is configured for the desired GTM 3.0 instance. You can delete only one access domain name.', example='gtm-cn-jmp3qnw**03', position='Query'),
}

model DeleteCloudGtmInstanceConfigResponseBody = {
  requestId?: string(name='RequestId', description='Unique request identification code.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  success?: boolean(name='Success', description='Indicates whether the operation to delete domain instance configurations was successful:
- true: Operation successful - false: Operation failed', example='true'),
}

model DeleteCloudGtmInstanceConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCloudGtmInstanceConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteCloudGtmInstanceConfig  DeleteCloudGtmInstanceConfigRequest
  * @return DeleteCloudGtmInstanceConfigResponse
 */
async function deleteCloudGtmInstanceConfig(request: DeleteCloudGtmInstanceConfigRequest): DeleteCloudGtmInstanceConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCloudGtmInstanceConfig', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCloudGtmMonitorTemplateRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language in which the returned results are displayed. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  templateId: string(name='TemplateId', description='The ID of the health check template. This ID uniquely identifies a health check template.

This parameter is required.', example='mtp-89518052425100**80', position='Query'),
}

model DeleteCloudGtmMonitorTemplateResponseBody = {
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  success?: boolean(name='Success', description='Indicates whether the operation to delete the health check template was successful:
- true: Operation successful
- false: Operation failed', example='true'),
}

model DeleteCloudGtmMonitorTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCloudGtmMonitorTemplateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteCloudGtmMonitorTemplate  DeleteCloudGtmMonitorTemplateRequest
  * @return DeleteCloudGtmMonitorTemplateResponse
 */
async function deleteCloudGtmMonitorTemplate(request: DeleteCloudGtmMonitorTemplateRequest): DeleteCloudGtmMonitorTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCloudGtmMonitorTemplate', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCustomLinesRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en', position='Query'),
  lineIds: string(name='LineIds', description='The unique IDs of the custom lines that you want to delete. Separate the unique IDs with commas (,). You can call the [DescribeCustomLines](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describecustomlines?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.

This parameter is required.', example='1234,1235', position='Query'),
}

model DeleteCustomLinesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
}

model DeleteCustomLinesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCustomLinesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteCustomLines  DeleteCustomLinesRequest
  * @return DeleteCustomLinesResponse
 */
async function deleteCustomLines(request: DeleteCustomLinesRequest): DeleteCustomLinesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCustomLines', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDnsCacheDomainRequest {
  domainName: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the name.

This parameter is required.', example='dns-example.top', position='Query'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English Default: **zh**', example='en', position='Query'),
}

model DeleteDnsCacheDomainResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model DeleteDnsCacheDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDnsCacheDomainResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteDnsCacheDomain  DeleteDnsCacheDomainRequest
  * @return DeleteDnsCacheDomainResponse
 */
async function deleteDnsCacheDomain(request: DeleteDnsCacheDomainRequest): DeleteDnsCacheDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDnsCacheDomain', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDnsGtmAccessStrategyRequest {
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
  strategyId: string(name='StrategyId', description='The ID of the access policy.

This parameter is required.', example='testStrategyId1', position='Query'),
}

model DeleteDnsGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
}

model DeleteDnsGtmAccessStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDnsGtmAccessStrategyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteDnsGtmAccessStrategy  DeleteDnsGtmAccessStrategyRequest
  * @return DeleteDnsGtmAccessStrategyResponse
 */
async function deleteDnsGtmAccessStrategy(request: DeleteDnsGtmAccessStrategyRequest): DeleteDnsGtmAccessStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDnsGtmAccessStrategy', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDnsGtmAddressPoolRequest {
  addrPoolId: string(name='AddrPoolId', description='The ID of the address pool.

This parameter is required.', example='testpool1', position='Query'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
}

model DeleteDnsGtmAddressPoolResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model DeleteDnsGtmAddressPoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDnsGtmAddressPoolResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteDnsGtmAddressPool  DeleteDnsGtmAddressPoolRequest
  * @return DeleteDnsGtmAddressPoolResponse
 */
async function deleteDnsGtmAddressPool(request: DeleteDnsGtmAddressPoolRequest): DeleteDnsGtmAddressPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDnsGtmAddressPool', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDomainRequest {
  domainName: string(name='DomainName', description='The domain name that already exists in Alibaba Cloud DNS. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.

This parameter is required.', example='example.com', position='Query'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en.', example='en', position='Query'),
}

model DeleteDomainResponseBody = {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model DeleteDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDomainResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteDomain  DeleteDomainRequest
  * @return DeleteDomainResponse
 */
async function deleteDomain(request: DeleteDomainRequest): DeleteDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDomain', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDomainGroupRequest {
  groupId: string(name='GroupId', description='The ID of the domain name group. You can call the [DescribeDomainGroups](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomaingroups?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.

This parameter is required.', example='2223', position='Query'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en.', example='en', position='Query'),
}

model DeleteDomainGroupResponseBody = {
  groupName?: string(name='GroupName', description='The name of the domain name group.', example='MyGroup'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model DeleteDomainGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDomainGroupResponseBody(name='body'),
}

/**
  * @description >  The default group cannot be deleted.
  * @param request  the request parameters of DeleteDomainGroup  DeleteDomainGroupRequest
  * @return DeleteDomainGroupResponse
 */
async function deleteDomainGroup(request: DeleteDomainGroupRequest): DeleteDomainGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDomainGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDomainRecordRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en', position='Query'),
  recordId: string(name='RecordId', description='The ID of the DNS record. You can call the [DescribeDomainRecords](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomainrecords?spm=a2c63.p38356.help-menu-search-29697.d_0) to obtain the ID.

This parameter is required.', example='9999985', position='Query'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0', position='Query'),
}

model DeleteDomainRecordResponseBody = {
  recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model DeleteDomainRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDomainRecordResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteDomainRecord  DeleteDomainRecordRequest
  * @return DeleteDomainRecordResponse
 */
async function deleteDomainRecord(request: DeleteDomainRecordRequest): DeleteDomainRecordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDomainRecord', 'POST', '/', 'json', false, 'json', request);
}

model DeleteGtmAccessStrategyRequest {
  lang?: string(name='Lang', description='The language used by the user.', example='en', position='Query'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy that you want to delete.', example='hrskc', position='Query'),
}

model DeleteGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
}

model DeleteGtmAccessStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteGtmAccessStrategyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteGtmAccessStrategy  DeleteGtmAccessStrategyRequest
  * @return DeleteGtmAccessStrategyResponse
 */
async function deleteGtmAccessStrategy(request: DeleteGtmAccessStrategyRequest): DeleteGtmAccessStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGtmAccessStrategy', 'POST', '/', 'json', false, 'json', request);
}

model DeleteGtmAddressPoolRequest {
  addrPoolId: string(name='AddrPoolId', description='The ID of the address pool that you want to delete.

This parameter is required.', example='1234', position='Query'),
  lang?: string(name='Lang', description='The language used by the user.', example='en', position='Query'),
}

model DeleteGtmAddressPoolResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model DeleteGtmAddressPoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteGtmAddressPoolResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteGtmAddressPool  DeleteGtmAddressPoolRequest
  * @return DeleteGtmAddressPoolResponse
 */
async function deleteGtmAddressPool(request: DeleteGtmAddressPoolRequest): DeleteGtmAddressPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGtmAddressPool', 'POST', '/', 'json', false, 'json', request);
}

model DeleteGtmRecoveryPlanRequest {
  lang?: string(name='Lang', description='The language used by the user.', example='en', position='Query'),
  recoveryPlanId: long(name='RecoveryPlanId', description='The ID of the disaster recovery plan that you want to delete.

This parameter is required.', example='100', position='Query'),
}

model DeleteGtmRecoveryPlanResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model DeleteGtmRecoveryPlanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteGtmRecoveryPlanResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteGtmRecoveryPlan  DeleteGtmRecoveryPlanRequest
  * @return DeleteGtmRecoveryPlanResponse
 */
async function deleteGtmRecoveryPlan(request: DeleteGtmRecoveryPlanRequest): DeleteGtmRecoveryPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGtmRecoveryPlan', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSubDomainRecordsRequest {
  domainName: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.

This parameter is required.', example='example.com', position='Query'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en', position='Query'),
  rr: string(name='RR', description='The hostname field in the DNS record.

For example, if you want to resolve @.example.com, you must set this parameter to an at sign (@) instead of leaving it empty.

This parameter is required.', example='www', position='Query'),
  type?: string(name='Type', description='The type of DNS records. If you do not specify this parameter, all types of DNS records corresponding to the subdomain are returned.

Valid values: **A, MX, CNAME, TXT, REDIRECT_URL, FORWORD_URL, NS, AAAA, and SRV**. The value is not case-sensitive.', example='A', position='Query'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0', position='Query'),
}

model DeleteSubDomainRecordsResponseBody = {
  rr?: string(name='RR', description='The hostname.', example='www'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: string(name='TotalCount', description='The total number of the DNS records to be deleted.', example='1'),
}

model DeleteSubDomainRecordsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSubDomainRecordsResponseBody(name='body'),
}

/**
  * @description If the DNS records to be deleted contain locked DNS records, the locked DNS records will not be deleted.
  * @param request  the request parameters of DeleteSubDomainRecords  DeleteSubDomainRecordsRequest
  * @return DeleteSubDomainRecordsResponse
 */
async function deleteSubDomainRecords(request: DeleteSubDomainRecordsRequest): DeleteSubDomainRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSubDomainRecords', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBatchResultCountRequest {
  batchType?: string(name='BatchType', description='The type of the batch operation. Valid values:

*   **DOMAIN_ADD**: adds domain names in batches.
*   **DOMAIN_DEL**: deletes domain names in batches.
*   **RR_ADD**: adds Domain Name System (DNS) records in batches.
*   **RR_DEL**: deletes DNS records in batches.

>  If you do not specify this parameter, filtering is not required.', example='DOMAIN_ADD', position='Query'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en', position='Query'),
  taskId?: long(name='TaskId', description='The task ID.

>  If you specify TaskId, the execution result of the specified task is returned. If you do not specify TaskId, the execution result of the last task is returned.', example='123456', position='Query'),
}

model DescribeBatchResultCountResponseBody = {
  batchType?: string(name='BatchType', description='The type of the batch operation.', example='DOMAIN_ADD'),
  failedCount?: int32(name='FailedCount', description='The total number of domain names or DNS records that failed to be processed.', example='2'),
  reason?: string(name='Reason', description='The cause of the execution failure.', example='failed_reason'),
  requestId?: string(name='RequestId', description='The request ID.', example='75446CC1-FC9A-4595-8D96-089D73D7A63D'),
  status?: int32(name='Status', description='The state of the task. Valid values:

*   **-1**: No task for importing domain names or DNS records is submitted.
*   **0**: The task is being processed.
*   **1**: The task is complete.
*   **2**: The task failed.', example='0'),
  successCount?: int32(name='SuccessCount', description='The total number of domain names or DNS records that were processed.', example='2'),
  taskId?: long(name='TaskId', description='The ID of the last task.', example='123456'),
  totalCount?: int32(name='TotalCount', description='The total number of DNS records that were processed in batches.', example='4'),
}

model DescribeBatchResultCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBatchResultCountResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeBatchResultCount  DescribeBatchResultCountRequest
  * @return DescribeBatchResultCountResponse
 */
async function describeBatchResultCount(request: DescribeBatchResultCountRequest): DescribeBatchResultCountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBatchResultCount', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBatchResultDetailRequest {
  batchType?: string(name='BatchType', description='The type of the batch operation. Valid values:

*   **DOMAIN_ADD**: adds domain names in batches.
*   **DOMAIN_DEL**: deletes domain names in batches.
*   **RR_ADD**: adds Domain Name System (DNS) records in batches.
*   **RR_DEL**: deletes DNS records in batches.

>  Do not perform filtering when this field is empty.', example='DOMAIN_ADD', position='Query'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20', position='Query'),
  status?: string(name='Status', description='The execution result. If you do not specify this parameter, all results are returned.', example='SUCCESS', position='Query'),
  taskId?: long(name='TaskId', description='The task ID.', example='83618818', position='Query'),
}

model DescribeBatchResultDetailResponseBody = {
  batchResultDetails?: {
    batchResultDetail?: [ 
    {
      batchType?: string(name='BatchType', description='The type of the batch operation.', example='DOMAIN_ADD'),
      domain?: string(name='Domain', description='The domain name.', example='example.com'),
      line?: string(name='Line', description='The line code.', example='default'),
      newRr?: string(name='NewRr', description='The new hostname.', example='demo-batch-7'),
      newValue?: string(name='NewValue', description='The new record value.', example='192.0.2.254'),
      operateDateStr?: string(name='OperateDateStr', description='The time when the operation was performed. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2019-08-22 18:02:58'),
      priority?: string(name='Priority', description='The priority of the mail exchanger (MX) record.', example='10'),
      reason?: string(name='Reason', description='The cause of the execution failure.', example='Task lock fail'),
      recordId?: string(name='RecordId', description='The ID of the DNS record.', example='123456789'),
      remark?: string(name='Remark', description='The description of the DNS record.', example='remark'),
      rr?: string(name='Rr', description='The hostname.', example='www'),
      rrStatus?: string(name='RrStatus', description='The status of the DNS record.', example='stop'),
      status?: boolean(name='Status', description='The execution result of the batch operation. Valid values: **true**: The operation succeeded. **false**: The operation failed.', example='true'),
      ttl?: string(name='Ttl', description='The time-to-live (TTL) of the DNS record.', example='600'),
      type?: string(name='Type', description='The type of the DNS record.', example='A'),
      value?: string(name='Value', description='The value of the DNS record.', example='192.0.2.0'),
    }
  ](name='BatchResultDetail')
  }(name='BatchResultDetails', description='The detailed results of the batch operation.'),
  pageNumber?: long(name='PageNumber', description='The page number.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='75446CC1-FC9A-4595-8D96-089D73D7A63D'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model DescribeBatchResultDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBatchResultDetailResponseBody(name='body'),
}

/**
  * @description Before you call this operation, make sure that the batch operation task is complete.
  * @param request  the request parameters of DescribeBatchResultDetail  DescribeBatchResultDetailRequest
  * @return DescribeBatchResultDetailResponse
 */
async function describeBatchResultDetail(request: DescribeBatchResultDetailRequest): DescribeBatchResultDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBatchResultDetail', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCloudGtmAddressRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  addressId: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.

This parameter is required.', example='addr-89518218114368**92', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
}

model DescribeCloudGtmAddressResponseBody = {
  address?: string(name='Address', description='IP address or domain name.', example='223.5.XX.XX'),
  addressId?: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.', example='addr-89518218114368**92'),
  attributeInfo?: string(name='AttributeInfo', description='Address ownership information.', example='The current version does not support passing this parameter, please do not input the parameter.'),
  availableMode?: string(name='AvailableMode', description='The failover method that is used if the address fails health checks. Valid values:

*   auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
*   manual: the manual mode. If an address is in the unavailable state, the address is not returned for Domain Name System (DNS) requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.', example='auto'),
  availableStatus?: string(name='AvailableStatus', description='Address availability status:
- available: Available
- unavailable: Unavailable', example='available'),
  createTime?: string(name='CreateTime', description='Address creation time.', example='2024-03-23T13:09Z'),
  createTimestamp?: long(name='CreateTimestamp', description='Creation time (timestamp).', example='1527690629357'),
  enableStatus?: string(name='EnableStatus', description='Indicates the current enabled status of the address:
enabled: enabled state
disabled: disabled state', example='enable'),
  healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address. Valid values:

*   any_ok: The health check results of at least one health check template are normal.
*   p30_ok: The health check results of at least 30% of health check templates are normal.
*   p50_ok: The health check results of at least 50% of health check templates are normal.
*   p70_ok: The health check results of at least 70% of health check templates are normal.
*   all_ok: The health check results of all health check templates are normal.', example='p50_ok'),
  healthStatus?: string(name='HealthStatus', description='The health check state of the address. Valid values:

*   ok: The address passes all health checks of the referenced health check templates.
*   ok_alert: The address fails some health checks of the referenced health check templates but the address is deemed normal.
*   ok_no_monitor: The address does not reference a health check template.
*   exceptional: The address fails some or all health checks of the referenced health check templates and the address is deemed abnormal.', example='ok'),
  healthTasks?: {
    healthTask?: [ 
    {
      monitorStatus?: string(name='MonitorStatus', description='The state of the health check task. Valid values:

*   ok: The task is normal.
*   alert: An alert is triggered.
*   no_data: No data is available. In most cases, the health check task is newly created and no data is collected.', example='ok'),
      port?: int32(name='Port', description='The target service port for health checks. When the Ping protocol is selected for health checks, configuration of the service port is not supported.', example='80'),
      templateId?: string(name='TemplateId', description='The ID of the health check template associated with the address.', example='mtp-89518052425100**80'),
      templateName?: string(name='TemplateName', description='The name of the health check template.', example='Ping-IPv4'),
    }
  ](name='HealthTask')
  }(name='HealthTasks', description='The health check tasks referenced by the address.'),
  manualAvailableStatus?: string(name='ManualAvailableStatus', description='The availability state of the address when AvailableMode is set to manual. Valid values:

*   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
*   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.', example='available'),
  name?: string(name='Name', description='Address name.', example='test'),
  remark?: string(name='Remark', description='Remarks.', example='test1'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
  type?: string(name='Type', description='Address type:
- IPv4
- IPv6
- domain', example='IPv4'),
  updateTime?: string(name='UpdateTime', description='The last modification time of the address configuration.', example='2024-03-29T13:20Z'),
  updateTimestamp?: long(name='UpdateTimestamp', description='Modified time (timestamp).', example='1527690629357'),
}

model DescribeCloudGtmAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudGtmAddressResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeCloudGtmAddress  DescribeCloudGtmAddressRequest
  * @return DescribeCloudGtmAddressResponse
 */
async function describeCloudGtmAddress(request: DescribeCloudGtmAddressRequest): DescribeCloudGtmAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCloudGtmAddress', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCloudGtmAddressPoolRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89564674533755**96', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
}

model DescribeCloudGtmAddressPoolResponseBody = {
  addressLbStrategy?: string(name='AddressLbStrategy', description='Load balancing policy among addresses in the address pool:
- round_robin: Round-robin, where for any source of DNS resolution requests, all addresses are returned, with a rotation of the order for every request.
- sequence: Sequential, where for any source of DNS resolution requests, the address with the lower sequence number (indicating a higher priority, the smaller the number, the higher the priority) is returned. If the address with the lower sequence number is unavailable, the next address with a lower sequence number is returned.
- weight: Weighted, supporting the setting of different weight values for each address to realize returning addresses according to the weight ratio of query resolutions.
- source_nearest: Source-nearest, also known as intelligent resolution, where GTM can return different addresses based on the source of different DNS resolution requests, achieving the effect of users accessing nearby servers.', example='round_robin'),
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89564674533755**96'),
  addressPoolName?: string(name='AddressPoolName', description='Address pool name.', example='AddressPool-1'),
  addressPoolType?: string(name='AddressPoolType', description='Address pool type:
- IPv4
- IPv6
- domain', example='IPv4'),
  addresses?: {
    address?: [ 
    {
      address?: string(name='Address', description='IP address or domain name.', example='223.5.XX.XX'),
      addressId?: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.', example='addr-89518218114368**92'),
      attributeInfo?: string(name='AttributeInfo', description='Address ownership information, not supported in the current version.', example='Not supported in the current version.'),
      availableMode?: string(name='AvailableMode', description='The failover method that is used if the address fails health checks. Valid values:

*   auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
*   manual: the manual mode. If an address is in the unavailable state, the address is not returned for DNS requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.', example='auto'),
      availableStatus?: string(name='AvailableStatus', description='Address availability status:
- available: Address available
- unavailable: Address unavailable', example='available'),
      createTime?: string(name='CreateTime', description='Address creation time.', example='2024-03-15T01:46Z'),
      createTimestamp?: long(name='CreateTimestamp', description='Address creation time (timestamp).', example='1527690629357'),
      enableStatus?: string(name='EnableStatus', description='Address enable status, indicating whether the address is currently available:
- enable: Enabled status
- disable: Disabled status', example='enable'),
      healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address. Valid values:

*   any_ok: The health check results of at least one health check template are normal.
*   p30_ok: The health check results of at least 30% of health check templates are normal.
*   p50_ok: The health check results of at least 50% of health check templates are normal.
*   p70_ok: The health check results of at least 70% of health check templates are normal.
*   all_ok: The health check results of all health check templates are normal.', example='any_ok'),
      healthStatus?: string(name='HealthStatus', description='The health check state of the address. Valid values:

*   ok: The address passes all health checks of the referenced health check templates.
*   ok_alert: The address fails some health checks of the referenced health check templates but the address is deemed normal.
*   ok_no_monitor: The address does not reference a health check template and is normal.
*   exceptional: The address fails some or all health checks of the referenced health check templates and the address is deemed abnormal.', example='ok'),
      healthTasks?: {
        healthTask?: [ 
        {
          port?: int32(name='Port', description='The target service port for health check probes. When the health check protocol is set to Ping, configuration of the service port is not supported.', example='80'),
          templateId?: string(name='TemplateId', description='ID of the health check template associated with the address.', example='mtp-89518052425100**80'),
          templateName?: string(name='TemplateName', description='Health check template name.', example='IPv4-Ping'),
        }
      ](name='HealthTask')
      }(name='HealthTasks', description='Health check task list.'),
      manualAvailableStatus?: string(name='ManualAvailableStatus', description='The availability state of the address when AvailableMode is set to manual. Valid values:

*   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
*   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.', example='available'),
      name?: string(name='Name', description='Address name.', example='Address-1'),
      remark?: string(name='Remark', description='Remarks for the address.', example='test'),
      requestSource?: {
        requestSource?: [ string ](name='RequestSource')
      }(name='RequestSource', description='The request source list.'),
      seqNonPreemptiveSchedule?: boolean(name='SeqNonPreemptiveSchedule', description='Indicates whether it is a sequential (non-preemptive) scheduling object for hybrid cloud management scenarios: - true: yes - false: no', example='false'),
      serialNumber?: int32(name='SerialNumber', description='Sequence number, indicating the priority of address return, where smaller numbers have higher priority.', example='1'),
      type?: string(name='Type', description='The address type. Valid values:

*   IPv4: IPv4 address
*   IPv6: IPv6 address
*   domain: domain name', example='IPv4'),
      updateTime?: string(name='UpdateTime', description='The last time the address was modified.', example='2024-03-15T01:46Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The last modification time of the address (timestamp).', example='1527690629357'),
      weightValue?: int32(name='WeightValue', description='Weight value (an integer between 1 and 100, inclusive), allowing different weight values to be set for each address, enabling resolution queries to return addresses according to the weighted ratio.', example='1'),
    }
  ](name='Address')
  }(name='Addresses', description='The addresses.'),
  availableStatus?: string(name='AvailableStatus', description='Address pool availability status:
- available: Available
- unavailable: Unavailable', example='available'),
  createTime?: string(name='CreateTime', description='Address pool creation time.', example='2024-03-15T01:46Z'),
  createTimestamp?: long(name='CreateTimestamp', description='Address pool creation time (timestamp).', example='1527690629357'),
  enableStatus?: string(name='EnableStatus', description='Address pool status:
- enable: Enabled status
- disable: Disabled status', example='enable'),
  healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address pool. Valid values:

*   any_ok: At least one address in the address pool is available.
*   p30_ok: At least 30% of the addresses in the address pool are available.
*   p50_ok: At least 50% of the addresses in the address pool are available.
*   p70_ok: At least 70% of the addresses in the address pool are available.
*   all_ok: All addresses in the address pool are available.', example='any_ok'),
  healthStatus?: string(name='HealthStatus', description='The health state of the address pool. Valid values:

*   ok: The health state of the address pool is normal and all addresses that are referenced by the address pool are available.
*   ok_alert: The health state of the address pool is warning and some of the addresses that are referenced by the address pool are unavailable. However, the address pool is deemed normal. In this case, only the available addresses are returned for Domain Name System (DNS) requests.
*   exceptional: The health state of the address pool is abnormal and some or all of the addresses that are referenced by the address pool are unavailable. In this case, the address pool is deemed abnormal.', example='ok'),
  remark?: string(name='Remark', description='Remarks for the address.', example='test'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address with the smallest sequence number is recovered. This parameter is returned only when the policy for load balancing between addresses is sequence. Valid values:

*   preemptive: The address with the smallest sequence number is preferentially used if this address is recovered.
*   non_preemptive: The current address is still used even if the address with the smallest sequence number is recovered.', example='preemptive'),
  updateTime?: string(name='UpdateTime', description='The last modification time of the address pool.', example='2024-03-15T01:46Z'),
  updateTimestamp?: long(name='UpdateTimestamp', description='Last modification time of the address pool (timestamp).', example='1527690629357'),
}

model DescribeCloudGtmAddressPoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudGtmAddressPoolResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeCloudGtmAddressPool  DescribeCloudGtmAddressPoolRequest
  * @return DescribeCloudGtmAddressPoolResponse
 */
async function describeCloudGtmAddressPool(request: DescribeCloudGtmAddressPoolRequest): DescribeCloudGtmAddressPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCloudGtmAddressPool', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCloudGtmAddressPoolReferenceRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
}

model DescribeCloudGtmAddressPoolReferenceResponseBody = {
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
  addressPoolName?: string(name='AddressPoolName', description='Address pool name.', example='app'),
  instanceConfigs?: {
    instanceConfig?: [ 
    {
      addressPoolLbStrategy?: string(name='AddressPoolLbStrategy', description='The policy for load balancing between address pools. Valid values:

*   round_robin: All address pools are returned for Domain Name System (DNS) requests from any source. All address pools are sorted in round-robin mode each time they are returned.
*   sequence: The address pool with the smallest sequence number is preferentially returned for DNS requests from any source. The sequence number indicates the priority for returning the address pool. A smaller sequence number indicates a higher priority. If the address pool with the smallest sequence number is unavailable, the address pool with the second smallest sequence number is returned.
*   weight: You can set a different weight value for each address pool. This way, address pools are returned based on the weight values.
*   source_nearest: Different address pools are returned based on the sources of DNS requests. This way, users can access nearby address pools.', example='round_robin'),
      availableStatus?: string(name='AvailableStatus', description='The availability state of the access domain name. Valid values:

*   available: If the access domain name is **enabled** and the health state is **normal**, the access domain name is deemed **available**.
*   unavailable: If the access domain name is **disabled** or the health state is **abnormal**, the access domain name is deemed **unavailable**.', example='available'),
      configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.', example='config-000**1'),
      enableStatus?: string(name='EnableStatus', description='The enabling state of the access domain name. Valid values:

*   enable: The access domain name is enabled and the intelligent scheduling policy of the corresponding GTM instance takes effect.
*   disable: The access domain name is disabled and the intelligent scheduling policy of the corresponding GTM instance does not take effect.', example='enable'),
      healthStatus?: string(name='HealthStatus', description='The health state of the access domain name. Valid values:

*   ok: The health state of the access domain name is normal and all address pools that are referenced by the access domain name are available.
*   ok_alert: The health state of the access domain name is warning and some of the address pools that are referenced by the access domain name are unavailable. In this case, only the available address pools are returned for DNS requests.
*   exceptional: The health state of the access domain name is abnormal and all address pools that are referenced by the access domain name are unavailable. In this case, addresses in the non-empty address pool with the smallest sequence number are preferentially used for fallback resolution. This returns DNS results for clients as much as possible.', example='ok'),
      instanceId?: string(name='InstanceId', description='The ID of the Global Traffic Manager (GTM) 3.0 instance.', example='gtm-cn-jmp3qnw**03'),
      instanceName?: string(name='InstanceName', description='Instance name.', example='test'),
      remark?: string(name='Remark', description='Remarks.', example='test'),
      scheduleDomainName?: string(name='ScheduleDomainName', description='The access domain name. The value of this parameter is composed of the value of ScheduleHostname and the value of ScheduleZoneName.', example='www.example.com'),
      scheduleHostname?: string(name='ScheduleHostname', description='Host record of the domain accessed by GTM.', example='www'),
      scheduleRrType?: string(name='ScheduleRrType', description='DNS record types for scheduling domains:
- A: IPv4 address
- AAAA: IPv6 address
- CNAME: Domain name', example='A'),
      scheduleZoneName?: string(name='ScheduleZoneName', description='The zone such as example.com or subzone such as a.example.com of the access domain name. In most cases, the zone or subzone is hosted by the Public Authoritative DNS module of Alibaba Cloud DNS. This zone belongs to the account to which the GTM instance belongs.', example='example.com'),
      sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address pool with the smallest sequence number is recovered. This parameter is returned when AddressPoolLbStrategy is set to sequence. Valid values:

*   preemptive: The address pool with the smallest sequence number is preferentially used if this address pool is recovered.
*   non_preemptive: The current address pool is still used even if the address pool with the smallest sequence number is recovered.', example='preemptive'),
      ttl?: int32(name='Ttl', description='Global TTL, the TTL value for resolving the accessed domain name to addresses in the address pool, which affects the caching time of DNS records in the operator\\"s LocalDNS. Supports custom TTL values.', example='30'),
      versionCode?: string(name='VersionCode', description='Global Traffic Management version 3.0 instance types:
- standard: Standard Edition
- ultimate: Ultimate Edition', example='ultimate'),
    }
  ](name='InstanceConfig')
  }(name='InstanceConfigs', description='The access domain names that reference the address pool.'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='853805EA-3D47-47D5-9A1A-A45C24313ABD'),
}

model DescribeCloudGtmAddressPoolReferenceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudGtmAddressPoolReferenceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeCloudGtmAddressPoolReference  DescribeCloudGtmAddressPoolReferenceRequest
  * @return DescribeCloudGtmAddressPoolReferenceResponse
 */
async function describeCloudGtmAddressPoolReference(request: DescribeCloudGtmAddressPoolReferenceRequest): DescribeCloudGtmAddressPoolReferenceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCloudGtmAddressPoolReference', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCloudGtmAddressReferenceRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  addressId?: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.', example='addr-89518218114368**92', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
}

model DescribeCloudGtmAddressReferenceResponseBody = {
  address?: string(name='Address', description='IP address or domain name.', example='223.5.XX.XX'),
  addressId?: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.', example='addr-89564584963974**40'),
  addressPools?: {
    addressPool?: [ 
    {
      addressLbStrategy?: string(name='AddressLbStrategy', description='Load balancing policy among addresses in the address pool:
- round_robin: Round-robin, for any source of DNS resolution requests, all addresses are returned, with a rotation sort applied to all addresses each time.
- sequence: Sequential, for any source of DNS resolution requests, returns the address with the smaller sequence number (the sequence number indicates the priority of address return, with smaller numbers having higher priority). If the address with the smaller sequence number is unavailable, the next address with a smaller sequence number is returned.
- weight: Weighted, supports setting different weight values for each address, realizing the return of addresses according to the ratio of weight for DNS query resolutions.
- source_nearest: Source-nearest, i.e., intelligent resolution function, where GTM can return different addresses based on the source of different DNS resolution requests, achieving the effect of users accessing nearby.', example='round_robin'),
      addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool.', example='pool-895280232254422016'),
      addressPoolName?: string(name='AddressPoolName', description='Address pool name.', example='AddressPool-1'),
      addressPoolType?: string(name='AddressPoolType', description='Address pool type:
- IPv4
- IPv6
- domain', example='IPv4'),
      availableStatus?: string(name='AvailableStatus', description='Address pool availability status:
- available
- unavailable', example='available'),
      enableStatus?: string(name='EnableStatus', description='Address pool status:
- enable: Enabled status
- disable: Disabled status', example='enable'),
      healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address pool. Valid values:

*   any_ok: At least one address in the address pool is available.
*   p30_ok: At least 30% of the addresses in the address pool are available.
*   p50_ok: At least 50% of the addresses in the address pool are available.
*   p70_ok: At least 70% of the addresses in the address pool are available.
*   all_ok: All addresses in the address pool are available.', example='any_ok'),
      healthStatus?: string(name='HealthStatus', description='The health state of the address pool. Valid values:

*   ok: The health state of the address pool is normal and all addresses that are referenced by the address pool are available.
*   ok_alert: The health state of the address pool is warning and some of the addresses that are referenced by the address pool are unavailable. However, the address pool is deemed normal. In this case, only the available addresses are returned for DNS requests.
*   exceptional: The health state of the address pool is abnormal and some or all of the addresses that are referenced by the address pool are unavailable. In this case, the address pool is deemed abnormal.', example='ok'),
      instanceConfigs?: {
        instanceConfig?: [ 
        {
          addressPoolLbStrategy?: string(name='AddressPoolLbStrategy', description='The policy for load balancing between address pools. Valid values:

*   round_robin: All address pools are returned for Domain Name System (DNS) requests from any source. All address pools are sorted in round-robin mode each time they are returned.
*   sequence: The address pool with the smallest sequence number is preferentially returned for DNS requests from any source. The sequence number indicates the priority for returning the address pool. A smaller sequence number indicates a higher priority. If the address pool with the smallest sequence number is unavailable, the address pool with the second smallest sequence number is returned.
*   weight: You can set a different weight value for each address pool. This way, address pools are returned based on the weight values.
*   source_nearest: Different address pools are returned based on the sources of DNS requests. This way, users can access nearby address pools.', example='round_robin'),
          availableStatus?: string(name='AvailableStatus', description='The availability state of the access domain name. Valid values:

*   available: If the access domain name is **enabled** and the health state is normal, the access domain name is deemed **available**.
*   unavailable: If the access domain name is **disabled** or the health state is **abnormal**, the access domain name is deemed **unavailable**.', example='available'),
          configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.', example='config-00**01'),
          enableStatus?: string(name='EnableStatus', description='The enabling state of the access domain name. Valid values:

*   enable: The access domain name is enabled and the intelligent scheduling policy of the corresponding GTM instance takes effect.
*   disable: The access domain name is disabled and the intelligent scheduling policy of the corresponding GTM instance does not take effect.', example='enable'),
          healthStatus?: string(name='HealthStatus', description='The health state of the access domain name. Valid values:

*   ok: The health state of the access domain name is normal and all address pools that are referenced by the access domain name are available.
*   ok_alert: The health state of the access domain name is warning and some of the address pools that are referenced by the access domain name are unavailable. In this case, only the available address pools are returned for DNS requests.
*   exceptional: The health state of the access domain name is abnormal and all address pools that are referenced by the access domain name are unavailable. In this case, addresses in the non-empty address pool with the smallest sequence number are preferentially used for fallback resolution. This returns DNS results for clients as much as possible.', example='ok'),
          instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance.', example='gtm-cn-zz11t58**0k'),
          instanceName?: string(name='InstanceName', description='Instance name.', example='test'),
          remark?: string(name='Remark', description='Remarks.', example='test'),
          scheduleDomainName?: string(name='ScheduleDomainName', description='The access domain name. The value of this parameter is composed of the value of ScheduleHostname and the value of ScheduleZoneName.', example='www.example.com'),
          scheduleHostname?: string(name='ScheduleHostname', description='Host record of the domain accessed by GTM.', example='www'),
          scheduleRrType?: string(name='ScheduleRrType', description='DNS record types for the scheduling domain:
- A: IPv4 address
- AAAA: IPv6 address
- CNAME: Domain name', example='A'),
          scheduleZoneName?: string(name='ScheduleZoneName', description='The zone such as example.com or subzone such as a.example.com of the access domain name. In most cases, the zone or subzone is hosted by the Public Authoritative DNS module of Alibaba Cloud DNS. This zone belongs to the account to which the GTM instance belongs.', example='example.com'),
          sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address pool with the smallest sequence number is recovered. This parameter is returned when AddressPoolLbStrategy is set to sequence. Valid values:

*   preemptive: The address pool with the smallest sequence number is preferentially used if this address pool is recovered.
*   non_preemptive: The current address pool is still used even if the address pool with the smallest sequence number is recovered.', example='preemptive'),
          ttl?: int32(name='Ttl', description='Global TTL (in seconds), the TTL value for domain name resolution to addresses in the address pool, which affects the caching time of DNS records in the ISP\\"s LocalDNS. Custom TTL values are supported.', example='30'),
          versionCode?: string(name='VersionCode', description='Global Traffic Management version 3.0 instance types:
- standard: Standard Edition
- ultimate: Ultimate Edition', example='ultimate'),
        }
      ](name='InstanceConfig')
      }(name='InstanceConfigs', description='The instances that reference the address pool.'),
      remark?: string(name='Remark', description='Remarks for the address pool.', example='pool-1'),
      sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='Load balancing policy between addresses in sequential mode during the recovery of preceding resources service mode:
- preemptive: Preemption mode, where upon recovery of preceding resources, priority is given to using addresses with smaller sequence numbers;
- non_preemptive: Non-preemption mode, where upon recovery of preceding resources, the current address continues to be used;', example='preemptive'),
    }
  ](name='AddressPool')
  }(name='AddressPools', description='The address pools.'),
  name?: string(name='Name', description='Address name.', example='Address-1'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model DescribeCloudGtmAddressReferenceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudGtmAddressReferenceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeCloudGtmAddressReference  DescribeCloudGtmAddressReferenceRequest
  * @return DescribeCloudGtmAddressReferenceResponse
 */
async function describeCloudGtmAddressReference(request: DescribeCloudGtmAddressReferenceRequest): DescribeCloudGtmAddressReferenceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCloudGtmAddressReference', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCloudGtmGlobalAlertRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US: English', example='en-US', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
}

model DescribeCloudGtmGlobalAlertResponseBody = {
  alertConfig?: {
    alertConfig?: [ 
    {
      dingtalkNotice?: boolean(name='DingtalkNotice', description='Indicates whether DingTalk notifications are configured. Valid values:

*   true: DingTalk notifications are configured. DingTalk notifications are sent when alerts are triggered.
*   false: DingTalk notifications are not configured.', example='false'),
      emailNotice?: boolean(name='EmailNotice', description='Indicates whether email notifications are configured. Valid values:

*   true: Email notifications are configured. Emails are sent when alerts are triggered.
*   false: Email notifications are not configured.', example='true'),
      noticeType?: string(name='NoticeType', description='The type of the alert event. Valid values:

*   addr_alert: The address is unavailable.
*   addr_resume: The address becomes available.
*   addr_pool_unavailable: The address pool is unavailable.
*   addr_pool_available: The address pool becomes available.', example='addr_alert'),
      smsNotice?: boolean(name='SmsNotice', description='Indicates whether text message notifications are configured. Valid values:

*   true: Text message notifications are configured. Text messages are sent when alerts are triggered.
*   false: Text message notifications are not configured.

Only the China site (aliyun.com) supports text message notifications.', example='true'),
    }
  ](name='AlertConfig')
  }(name='AlertConfig', description='The alert configurations.'),
  alertGroup?: {
    alertGroup?: [ string ](name='AlertGroup')
  }(name='AlertGroup', description='The alert contact groups.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
}

model DescribeCloudGtmGlobalAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudGtmGlobalAlertResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeCloudGtmGlobalAlert  DescribeCloudGtmGlobalAlertRequest
  * @return DescribeCloudGtmGlobalAlertResponse
 */
async function describeCloudGtmGlobalAlert(request: DescribeCloudGtmGlobalAlertRequest): DescribeCloudGtmGlobalAlertResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCloudGtmGlobalAlert', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCloudGtmInstanceConfigAlertRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   **zh-CN**: Chinese
*   **en-US**: English', example='en-US', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.', example='Config-000**11', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the Global Traffic Manager (GTM) 3.0 instance.', example='gtm-cn-wwo3a3hbz**', position='Query'),
}

model DescribeCloudGtmInstanceConfigAlertResponseBody = {
  alertConfig?: {
    alertConfig?: [ 
    {
      dingtalkNotice?: boolean(name='DingtalkNotice', description='Indicates whether DingTalk notifications are configured. Valid values:

*   true: DingTalk notifications are configured. DingTalk notifications are sent after alerts are triggered.
*   false: DingTalk notifications are not configured.', example='true'),
      emailNotice?: boolean(name='EmailNotice', description='Indicates whether email notifications are configured. Valid values:

*   true: Email notifications are configured. Emails are sent after alerts are triggered.
*   false: Email notifications are not configured.', example='true'),
      noticeType?: string(name='NoticeType', description='The type of the alert event. Valid values:

*   addr_alert: The address is unavailable.
*   addr_resume: The address becomes available.
*   addr_pool_unavailable: The address pool is unavailable.
*   addr_pool_available: The address pool becomes available.', example='addr_alert'),
      smsNotice?: boolean(name='SmsNotice', description='Indicates whether text message notifications are configured. Valid values:

*   true: Text message notifications are configured. Text messages are sent after alerts are triggered.
*   false: Text message notifications are not configured.

Only the China site (aliyun.com) supports text message notifications.', example='true'),
    }
  ](name='AlertConfig')
  }(name='AlertConfig', description='The alert configurations.'),
  alertGroup?: {
    alertGroup?: [ string ](name='AlertGroup')
  }(name='AlertGroup', description='The alert contact groups.'),
  alertMode?: string(name='AlertMode', description='The alert configuration mode of the instance. Valid values:

*   global: global alert configuration
*   instance_config: custom alert configuration', example='global'),
  configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.', example='Config-000**11'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance.', example='gtm-cn-wwo3a3hbz**'),
  requestId?: string(name='RequestId', description='The request ID.', example='0F32959D-417B-4D66-8463-68606605E3E2'),
}

model DescribeCloudGtmInstanceConfigAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudGtmInstanceConfigAlertResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeCloudGtmInstanceConfigAlert  DescribeCloudGtmInstanceConfigAlertRequest
  * @return DescribeCloudGtmInstanceConfigAlertResponse
 */
async function describeCloudGtmInstanceConfigAlert(request: DescribeCloudGtmInstanceConfigAlertRequest): DescribeCloudGtmInstanceConfigAlertResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCloudGtmInstanceConfigAlert', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCloudGtmInstanceConfigFullInfoRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.

You can call the [ListCloudGtmInstanceConfigs](~~ListCloudGtmInstanceConfigs~~) operation to query the value of ConfigId for the access domain name.', example='Config-000**11', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance.', example='gtm-cn-wwo3a3hbz**', position='Query'),
}

model DescribeCloudGtmInstanceConfigFullInfoResponseBody = {
  addressPoolLbStrategy?: string(name='AddressPoolLbStrategy', description='The policy for load balancing between address pools. Valid values:

*   round_robin: All address pools are returned for DNS requests from any source. All address pools are sorted in round-robin mode each time they are returned.
*   sequence: The address pool with the smallest sequence number is preferentially returned for DNS requests from any source. The sequence number indicates the priority for returning the address pool. A smaller sequence number indicates a higher priority. If the address pool with the smallest sequence number is unavailable, the address pool with the second smallest sequence number is returned.
*   weight: You can set a different weight value for each address pool. This way, address pools are returned based on the weight values.
*   source_nearest: GTM returns different addresses based on the sources of DNS requests. This way, users can access nearby addresses.', example='round_robin'),
  addressPools?: {
    addressPool?: [ 
    {
      addressLbStrategy?: string(name='AddressLbStrategy', description='Load balancing policy among addresses in the address pool:
- round_robin: Round-robin, for any source of DNS resolution requests, returns all addresses and rotates their order for each request.
- sequence: Sequential, for any source of DNS resolution requests, returns the address with the smaller sequence number (the sequence number indicates the priority of the address return, with smaller numbers having higher priority). If the address with the smaller sequence number is unavailable, the next address with a smaller sequence number is returned.
- weight: Weighted, supports setting different weight values for each address to realize returning addresses according to the weight ratio for resolution queries.
- source_nearest: Source-nearest, i.e., intelligent resolution function, where GTM can return different addresses based on the source of different DNS resolution requests, achieving the effect of users accessing nearby.', example='round_robin'),
      addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
      addressPoolName?: string(name='AddressPoolName', description='Address pool name.', example='AddressPool-1'),
      addressPoolType?: string(name='AddressPoolType', description='Address pool type:
- IPv4
- IPv6
- domain', example='IPv4'),
      addresses?: {
        address?: [ 
        {
          address?: string(name='Address', description='IP address or domain name.', example='223.5.XX.XX'),
          addressId?: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.', example='addr-89564712295703**96'),
          attributeInfo?: string(name='AttributeInfo', description='Address ownership information, not supported in the current version.', example='The current version does not support returning this parameter.'),
          availableMode?: string(name='AvailableMode', description='The failover mode that is used when address exceptions are identified. Valid values:

*   auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
*   manual: the manual mode. If an address is in the unavailable state, the address is not returned for DNS requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.', example='auto'),
          availableStatus?: string(name='AvailableStatus', description='The availability state of the address. Valid values:

*   available
*   unavailable', example='available'),
          createTime?: string(name='CreateTime', description='Address creation time.', example='2024-03-15T01:46Z'),
          createTimestamp?: long(name='CreateTimestamp', description='Address creation time (timestamp).', example='1527690629357'),
          enableStatus?: string(name='EnableStatus', description='The enabling state of the address. Valid values:

*   enable
*   disable', example='enable'),
          healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health state of the address. Valid values:

*   any_ok: The health check results of at least one health check template are normal.
*   p30_ok: The health check results of at least 30% of health check templates are normal.
*   p50_ok: The health check results of at least 50% of health check templates are normal.
*   p70_ok: The health check results of at least 70% of health check templates are normal.
*   all_ok: The health check results of all health check templates are normal.', example='any_ok'),
          healthStatus?: string(name='HealthStatus', description='The health check state of the address. Valid values:

*   ok: The address passes all health checks of the referenced health check templates.
*   ok_alert: The address fails some health checks of the referenced health check templates but the address is deemed normal.
*   ok_no_monitor: The address does not reference any health check template and is normal.
*   exceptional: The address fails some or all health checks of the referenced health check templates and the address is deemed abnormal.', example='ok'),
          manualAvailableStatus?: string(name='ManualAvailableStatus', description='The availability state of the address when AvailableMode is set to manual. Valid values:

*   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
*   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.', example='available'),
          name?: string(name='Name', description='Address name.', example='Address-1'),
          remark?: string(name='Remark', description='The remark of the address.', example='test'),
          requestSource?: {
            requestSource?: [ string ](name='RequestSource')
          }(name='RequestSource', description='Request source list.'),
          seqNonPreemptiveSchedule?: boolean(name='SeqNonPreemptiveSchedule', description='Indicates whether it is a sequential (non-preemptive) mode scheduling object, applicable to hybrid cloud management scenarios: 

- true: yes
- false: no', example='false'),
          serialNumber?: int32(name='SerialNumber', description='Sequence number, indicating the priority of address return, where smaller numbers have higher priority.', example='1'),
          type?: string(name='Type', description='The type of the address. Valid values:

*   IPV4: the IPv4 address
*   IPv6: the IPv6 address
*   domain: the domain name', example='IPv4'),
          updateTime?: string(name='UpdateTime', description='Last modified time of the address.', example='2024-03-15T01:46Z'),
          updateTimestamp?: long(name='UpdateTimestamp', description='The last modification time of the address (timestamp).', example='1527690629357'),
          weightValue?: int32(name='WeightValue', description='Weight value (an integer between 1 and 100, inclusive), allowing different weight values to be set for each address, enabling resolution queries to return addresses in proportion to their weights.', example='1'),
        }
      ](name='Address')
      }(name='Addresses', description='The addresses.'),
      availableStatus?: string(name='AvailableStatus', description='The availability state of the address pool. Valid values:

*   Available
*   unavailable', example='available'),
      createTime?: string(name='CreateTime', description='Address pool creation time.', example='2024-03-15T01:46Z'),
      createTimestamp?: long(name='CreateTimestamp', description='Address pool creation time (timestamp).', example='1527690629357'),
      enableStatus?: string(name='EnableStatus', description='The enabling state of the address pool. Valid values:

*   enable
*   disable', example='enable'),
      healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health state of the address pool. Valid values:

*   any_ok: At least one address in the address pool is available.
*   p30_ok: At least 30% of the addresses in the address pool are available.
*   p50_ok: At least 50% of the addresses in the address pool are available.
*   p70_ok: At least 70% of the addresses in the address pool are available.
*   all_ok: All addresses in the address pool are available.', example='any_ok'),
      healthStatus?: string(name='HealthStatus', description='Address pool health status:
- ok: Normal, all addresses referenced by the address pool are available.
- ok_alert: Warning, some addresses referenced by the address pool are unavailable, but the address pool status is deemed normal. In the warning state, available address pools are resolved normally, while unavailable ones stop resolving.
- exceptional: Abnormal, some or all of the addresses referenced by the address pool are unavailable, and the address pool status is determined to be abnormal.', example='ok'),
      requestSource?: {
        requestSource?: [ string ](name='RequestSource')
      }(name='RequestSource', description='Parse the list of request sources.'),
      seqNonPreemptiveSchedule?: boolean(name='SeqNonPreemptiveSchedule', description='Indicates whether it is a sequential (non-preemptive) scheduling object for hybrid cloud management scenarios: 
- true: yes 
- false: no', example='false'),
      sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address with the smallest sequence number is recovered. This parameter is required only when AddressLbStrategy is set to sequence. Valid values:

*   preemptive: The address with the smallest sequence number is preferentially used if this address is recovered.
*   non_preemptive: The current address is still used even if the address with the smallest sequence number is recovered.', example='preemptive'),
      serialNumber?: int32(name='SerialNumber', description='Sequence number. For any parsing request from any source, the address pool with the smaller sequence number is returned (the sequence number indicates the priority of the address pool returned, with smaller numbers having higher priority).', example='1'),
      updateTime?: string(name='UpdateTime', description='Last modification time of the address pool.', example='2024-03-15T01:46Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='Last modification time of the address pool (timestamp).', example='1527690629357'),
      weightValue?: int32(name='WeightValue', description='Weight value (an integer between 1 and 100, inclusive), allowing different weight values to be set for each address pool, enabling resolution queries to return address pools according to the weighted ratio.', example='1'),
    }
  ](name='AddressPool')
  }(name='AddressPools', description='The address pools.'),
  alertConfig?: string(name='AlertConfig', description='Alert notification configuration.', example='[{\\"NoticeType\\":\\"addr_alert\\",\\"SmsNotice\\":true,\\"EmailNotice\\":true,\\"DingtalkNotice\\":true},{\\"NoticeType\\":\\"addr_resume\\",\\"SmsNotice\\":true,\\"EmailNotice\\":true,\\"DingtalkNotice\\":true},{\\"NoticeType\\":\\"addr_pool_unavailable\\",\\"SmsNotice\\":true,\\"EmailNotice\\":true,\\"DingtalkNotice\\":true},{\\"NoticeType\\":\\"addr_pool_available\\",\\"SmsNotice\\":true,\\"EmailNotice\\":true,\\"DingtalkNotice\\":true}]"'),
  alertGroup?: string(name='AlertGroup', description='Alert notification group.', example='[\\"Default Contact Group\\"]'),
  availableStatus?: string(name='AvailableStatus', description='The availability state of the access domain name. Valid values:

*   available: If the access domain name is **enabled** and the health state of the access domain name is **Normal**, the access domain name is deemed **available**.
*   unavailable: If the access domain name is **disabled** or the health state of the access domain name is **Abnormal**, the access domain name is deemed **unavailable**.', example='available'),
  commodityCode?: string(name='CommodityCode', description='The commodity code. Valid values:

*   dns_gtm_public_cn: the commodity code on the China site (aliyun.com)
*   dns_gtm_public_intl: the commodity code on the international site (alibabacloud.com)', example='dns_gtm_public_cn'),
  configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.', example='Config-000**11'),
  createTime?: string(name='CreateTime', description='Instance creation time.', example='2024-03-15T01:46Z'),
  createTimestamp?: long(name='CreateTimestamp', description='Instance creation time (timestamp).', example='1527690629357'),
  enableStatus?: string(name='EnableStatus', description='The enabling state of the access domain name. Valid values:

*   enable: The access domain name is enabled and the intelligent scheduling policy of the corresponding GTM instance takes effect.
*   disable: The access domain name is disabled and the intelligent scheduling policy of the corresponding GTM instance does not take effect.', example='enable'),
  healthStatus?: string(name='HealthStatus', description='The health state of the access domain name. Valid values:

*   ok: The health state of the access domain name is Normal and all address pools that are referenced by the access domain name are available.
*   ok_alert: The health state of the access domain name is Warning and some of the address pools that are referenced by the access domain name are unavailable. In this case, the available address pools are normally used for DNS resolution, but the unavailable address pools cannot be used for DNS resolution.
*   exceptional: The health state of the access domain name is Abnormal and all address pools that are referenced by the access domain name are unavailable. In this case, addresses in the non-empty address pool with the smallest sequence number are preferentially used for fallback resolution. This returns DNS results for clients as much as possible.', example='ok'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance.', example='gtm-cn-wwo3a3hbz**'),
  instanceName?: string(name='InstanceName', description='Schedule instance name.', example='test'),
  remark?: string(name='Remark', description='Remarks of the configuration of domain instance.', example='test'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
  scheduleDomainName?: string(name='ScheduleDomainName', description='The GTM access domain name. The value of this parameter is composed of the value of ScheduleHostname and the value of ScheduleZoneName.', example='www.example.com'),
  scheduleHostname?: string(name='ScheduleHostname', description='Host name of the domain accessed by GTM.', example='www'),
  scheduleRrType?: string(name='ScheduleRrType', description='DNS record types for the ScheduleDomainName:
- A: IPv4 address
- AAAA: IPv6 address
- CNAME: Domain name', example='A'),
  scheduleZoneMode?: string(name='ScheduleZoneMode', description='The allocation mode of the access domain name. Valid values:

*   custom: custom allocation. You must specify a custom hostname and associate the hostname with a zone or subzone within the account to which the GTM instance belongs to generate an access domain name.
*   sys_assign: The system assigns an access domain name by default. This mode is no longer supported. Do not choose this mode.', example='custom'),
  scheduleZoneName?: string(name='ScheduleZoneName', description='The zone (such as example.com) or subzone (such as a.example.com) associated with the GTM access domain name. In most cases, the zone or subzone is hosted in Authoritative DNS Resolution of the Alibaba Cloud DNS console within the account to which the GTM instance belongs.', example='example.com'),
  sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address pool with the smallest sequence number is recovered. This parameter is required when AddressPoolLbStrategy is set to sequence. Valid values:

*   preemptive: The address pool with the smallest sequence number is preferentially used if this address pool is recovered.
*   non_preemptive: The current address pool is still used even if the address pool with the smallest sequence number is recovered.', example='preemptive'),
  ttl?: int32(name='Ttl', description='Global TTL (in seconds), the TTL value for resolving the access domain to addresses in the address pool, which affects the caching time of DNS records in the ISP\\"s LocalDNS. Custom TTL values are supported.', example='60'),
  updateTime?: string(name='UpdateTime', description='Last modified time.', example='2024-03-15T01:46Z'),
  updateTimestamp?: long(name='UpdateTimestamp', description='Last modified time (timestamp).', example='1527690629357'),
  versionCode?: string(name='VersionCode', description='Global Traffic Management version 3.0 instances:
- standard: Standard Edition
- ultimate: Ultimate Edition', example='ultimate'),
}

model DescribeCloudGtmInstanceConfigFullInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudGtmInstanceConfigFullInfoResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeCloudGtmInstanceConfigFullInfo  DescribeCloudGtmInstanceConfigFullInfoRequest
  * @return DescribeCloudGtmInstanceConfigFullInfoResponse
 */
async function describeCloudGtmInstanceConfigFullInfo(request: DescribeCloudGtmInstanceConfigFullInfoRequest): DescribeCloudGtmInstanceConfigFullInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCloudGtmInstanceConfigFullInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCloudGtmMonitorTemplateRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   **zh-CN**: Chinese
*   **en-US** (default): English', example='en-US', position='Query'),
  templateId: string(name='TemplateId', description='The ID of the health check template that you want to query. This ID uniquely identifies the health check template.

This parameter is required.', example='mtp-89518052425100**80', position='Query'),
}

model DescribeCloudGtmMonitorTemplateResponseBody = {
  createTime?: string(name='CreateTime', description='Health check template creation time.', example='2024-03-23T13:09Z'),
  createTimestamp?: long(name='CreateTimestamp', description='Health check template creation time (timestamp).', example='1527690629357'),
  evaluationCount?: int32(name='EvaluationCount', description='Retries count. The system will only judge the application service as abnormal after consecutive monitoring failures to prevent inaccurate monitoring results due to momentary network fluctuations or other reasons. Available retry counts are:
- 1
- 2
- 3', example='2'),
  extendInfo?: string(name='ExtendInfo', description='The extended information. The value of this parameter is a JSON string. The required parameters vary based on the health check protocol.

*   HTTP or HTTPS:

    **host**: the Host field of an HTTP or HTTPS request header during an HTTP or HTTPS health check. The parameter value indicates the HTTP website that you want to visit. By default, the value is the primary domain name. You can change the value based on your business requirements.

    **path**: the URL for HTTP or HTTPS health checks. Default value: /.

    **code**: the alert threshold. During an HTTP or HTTPS health check, the system checks whether a web server functions as expected based on the status code that is returned from the web server. If the returned status code is greater than the specified threshold, the corresponding application service address is deemed abnormal. Valid values:

    *   400: indicates an invalid request. If an HTTP or HTTPS request contains invalid request parameters, a web server returns a status code that is greater than 400. You must specify an exact URL for path if you set code to 400.
    *   500: indicates a server error. If some exceptions occur on a web server, the web server returns a status code that is greater than 500. This value is used by default.

    **sni**: indicates whether Server Name Indication (SNI) is enabled. This parameter is used only when the health check protocol is HTTPS. SNI is an extension to the Transport Layer Security (TLS) protocol, which allows a client to specify the host to be connected when the client sends a TLS handshake request. TLS handshakes occur before any data of HTTP requests is sent. Therefore, SNI enables servers to identify the services that clients are attempting to access before certificates are sent. This allows the servers to present correct certificates to the clients. Valid values:

    *   true: SNI is enabled.
    *   false: SNI is disabled.

    **followRedirect**: indicates whether 3XX redirects are followed. Valid values:

    *   true: 3XX redirects are followed. You are redirected to the destination address if a 3XX status code such as 301, 302, 303, 307, or 308 is returned.
    *   false: 3XX redirects are not followed.

*   ping:

    **packetNum**: the total number of Internet Control Message Protocol (ICMP) packets that are sent to the address for each ping-based health check. Valid values: 20, 50, and 100.

    **packetLossRate**: the ICMP packet loss rate for each ping-based health check. The packet loss rate in a health check can be calculated by using the following formula: Packet loss rate in a health check = (Number of lost packets/Total number of sent ICMP packets) × 100%. If the packet loss rate reaches the threshold, an alert is triggered. Valid values: 10, 30, 40, 80, 90, and 100.', example='{\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}'),
  failureRate?: int32(name='FailureRate', description='Percentage of selected node probe failures (%), that is, the percentage of abnormal detection points among the total detection points. When the failure ratio exceeds the set threshold, the service address is judged as abnormal. The available failure ratio thresholds are:
- 20
- 50
- 80
- 100', example='50'),
  interval?: int32(name='Interval', description='The time interval (in seconds) between each check, with a default interval of 1 minute. The minimum supported health check interval is 15 seconds, available for flagship edition instances.', example='60'),
  ipVersion?: string(name='IpVersion', description='Detect the type of the node IP address:
- IPv4: Applicable when the target address type is IPv4;
- IPv6: Applicable when the target address type is IPv6.', example='IPv4'),
  ispCityNodes?: {
    ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='City code', example='357'),
      cityName?: string(name='CityName', description='City name', example='Shanghai'),
      countryCode?: string(name='CountryCode', description='Country Code', example='629'),
      countryName?: string(name='CountryName', description='Country Name', example='China'),
      groupName?: string(name='GroupName', description='Probe node group type name', example='BGP Nodes'),
      groupType?: string(name='GroupType', description='Probe node group types:
- BGP: BGP nodes
- OVERSEAS: International nodes
- ISP: Carrier nodes', example='BGP'),
      ispCode?: string(name='IspCode', description='Operator Code', example='465'),
      ispName?: string(name='IspName', description='Operator Name', example='Alibaba'),
    }
  ](name='IspCityNode')
  }(name='IspCityNodes', description='Probe node list, detailed information can be obtained by calling ListCloudGtmMonitorNodes.'),
  name?: string(name='Name', description='The name of the health check probe template, which is recommended to be distinguishable for configuration personnel to differentiate and remember, ideally indicating the health check protocol.', example='Ping-IPv4'),
  protocol?: string(name='Protocol', description='Protocol types to initiate probes to the target IP address:
- ping
- tcp
- http
- https', example='ping'),
  remark?: string(name='Remark', description='Remarks for the health check template.', example='test'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='6AEC7A64-3CB1-4C49-8B35-0B901F1E26BF'),
  templateId?: string(name='TemplateId', description='The ID of the health check template. This ID uniquely identifies the health check template.', example='mtp-89518052425100**80'),
  timeout?: int32(name='Timeout', description='Probe timeout (in milliseconds), data packets not returned within the timeout period are deemed as health check timeouts:
- 2000
- 3000
- 5000
- 10000', example='5000'),
  updateTime?: string(name='UpdateTime', description='Health check template configuration modification time.', example='2024-03-29T13:20Z'),
  updateTimestamp?: long(name='UpdateTimestamp', description='Health check template configuration modification time (timestamp).', example='1527690629357'),
}

model DescribeCloudGtmMonitorTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudGtmMonitorTemplateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeCloudGtmMonitorTemplate  DescribeCloudGtmMonitorTemplateRequest
  * @return DescribeCloudGtmMonitorTemplateResponse
 */
async function describeCloudGtmMonitorTemplate(request: DescribeCloudGtmMonitorTemplateRequest): DescribeCloudGtmMonitorTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCloudGtmMonitorTemplate', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCloudGtmSummaryRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US: English', example='en-US', position='Query'),
}

model DescribeCloudGtmSummaryResponseBody = {
  instanceTotalCount?: int32(name='InstanceTotalCount', description='The total number of instances within the current account.', example='10'),
  monitorTaskTotalCount?: int32(name='MonitorTaskTotalCount', description='The total number of configured health check tasks.', example='20'),
  monitorTaskTotalQuota?: int32(name='MonitorTaskTotalQuota', description='The quota on the number of health check tasks.', example='101'),
  requestId?: string(name='RequestId', description='The request ID.', example='199C3699-9A7B-41A1-BB5A-F1E862D3CB38'),
}

model DescribeCloudGtmSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudGtmSummaryResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeCloudGtmSummary  DescribeCloudGtmSummaryRequest
  * @return DescribeCloudGtmSummaryResponse
 */
async function describeCloudGtmSummary(request: DescribeCloudGtmSummaryRequest): DescribeCloudGtmSummaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCloudGtmSummary', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCloudGtmSystemLinesRequest {
}

model DescribeCloudGtmSystemLinesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='389DFFA3-77A5-4A9E-BF3D-147C6F98A5BA'),
  systemLines?: {
    systemLine?: [ 
    {
      code?: string(name='Code', description='The line code.', example='aliyun_r_ap-south-1'),
      displayName?: string(name='DisplayName', description='The display name of the line.', example='Default'),
      isAvailable?: boolean(name='IsAvailable', description='Indicates whether the line can be selected as the source of a Domain Name System (DNS) request. Valid values:

*   true
*   false', example='true'),
      name?: string(name='Name', description='The name of the line.', example='Default'),
      parentCode?: string(name='ParentCode', description='The code of the parent line.', example='String	aliyun'),
    }
  ](name='SystemLine')
  }(name='SystemLines', description='The system lines.'),
  systemLinesTree?: string(name='SystemLinesTree', description='The system lines, which are in a tree structure. Only a system line is listed in this example.', example='[{\\"displayName\\":\\"Default\\",\\"id\\":\\"default\\",\\"isAvailable\\":true,\\"name\\":\\"Default\\",\\"parentId\\":\\"\\"}]'),
}

model DescribeCloudGtmSystemLinesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudGtmSystemLinesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeCloudGtmSystemLines  DescribeCloudGtmSystemLinesRequest
  * @return DescribeCloudGtmSystemLinesResponse
 */
async function describeCloudGtmSystemLines(request: DescribeCloudGtmSystemLinesRequest): DescribeCloudGtmSystemLinesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCloudGtmSystemLines', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCustomLineRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en', position='Query'),
  lineId?: long(name='LineId', description='The unique ID of the custom line. You can call [DescribeCustomLines](https://www.alibabacloud.com/help/en/dns/api-alidns-2015-01-09-describecustomlines?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID', example='597', position='Query'),
}

model DescribeCustomLineResponseBody = {
  code?: string(name='Code', description='The code of the custom line.', example='hra0yc-597'),
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  id?: long(name='Id', description='The ID/Name of the custom line.', example='597'),
  ipSegmentList?: [ 
    {
      endIp?: string(name='EndIp', description='The end IP address of the CIDR block.', example='11.1.1.3'),
      startIp?: string(name='StartIp', description='The start IP address of the CIDR block.', example='11.1.1.2'),
    }
  ](name='IpSegmentList', description='The CIDR blocks. Separate IP addresses with a hyphen (-). Enter a CIDR block in each row. You can enter 1 to 50 CIDR blocks at a time. If a CIDR block contains only one IP address, enter the IP address in the format of IP1-IP1. Different CIDR blocks cannot be overlapped.'),
  name?: string(name='Name', description='The name of the custom line.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
}

model DescribeCustomLineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCustomLineResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeCustomLine  DescribeCustomLineRequest
  * @return DescribeCustomLineResponse
 */
async function describeCustomLine(request: DescribeCustomLineRequest): DescribeCustomLineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCustomLine', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCustomLinesRequest {
  domainName: string(name='DomainName', description='The domain name that already exists in Alibaba Cloud Domain Name System (DNS). You can call the [DescribeDomains ](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0)operation to obtain the domain name.

This parameter is required.', example='example.com', position='Query'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en', example='en', position='Query'),
  pageNumber?: long(name='PageNumber', description='The page number.', example='1', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='10', position='Query'),
}

model DescribeCustomLinesResponseBody = {
  customLines?: [ 
    {
      code?: string(name='Code', description='The code of the custom line.', example='hra0yc-597'),
      id?: long(name='Id', description='The unique ID of the custom line.', example='597'),
      ipSegmentList?: [ 
        {
          endIp?: string(name='EndIp'),
          startIp?: string(name='StartIp'),
        }
      ](name='IpSegmentList'),
      name?: string(name='Name', description='The name of the custom line.', example='hra0yd-597'),
    }
  ](name='CustomLines', description='The custom lines.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
  totalItems?: int32(name='TotalItems', description='The total number of custom lines.', example='1'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeCustomLinesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCustomLinesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeCustomLines  DescribeCustomLinesRequest
  * @return DescribeCustomLinesResponse
 */
async function describeCustomLines(request: DescribeCustomLinesRequest): DescribeCustomLinesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCustomLines', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDNSSLBSubDomainsRequest {
  domainName: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.

This parameter is required.', example='example.com', position='Query'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   **zh** (default): Chinese
*   **en**: English', example='en', position='Query'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: **1 to 100**. Default value: **20**.', example='20', maximum=100, position='Query'),
  rr?: string(name='Rr', description='The hostname.', example='test', position='Query'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the user account.', example='1.1.1.1', position='Query'),
}

model DescribeDNSSLBSubDomainsResponseBody = {
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: **1 to 100**. Default value: **20**.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  slbSubDomains?: {
    slbSubDomain?: [ 
    {
      lineAlgorithms?: {
        lineAlgorithm?: [ 
        {
          line?: string(name='Line', description='The DNS resolution line. The line can be China Telecom, China Mobile, and China Unicom.', example='default'),
          open?: boolean(name='Open', description='Indicates whether weighted round-robin is enabled for the line. Valid values:

*   **true** (default): Weighted round-robin is enabled.
*   **false**: Weighted round-robin is disabled.', example='true'),
        }
      ](name='LineAlgorithm')
      }(name='LineAlgorithms', description='The lines for which weighted round-robin is enabled.'),
      open?: boolean(name='Open', description='Indicates whether weighted round-robin is enabled for the subdomain.', example='true'),
      recordCount?: long(name='RecordCount', description='The number of DNS records added for the subdomain.', example='3'),
      subDomain?: string(name='SubDomain', description='The name of the subdomain.', example='www.example.com'),
      type?: string(name='Type', description='The type of the Domain Name System (DNS) record that supports weighted round-robin. Valid values: A, AAAA, and CNAME.', example='A'),
    }
  ](name='SlbSubDomain')
  }(name='SlbSubDomains', description='The subdomains for which weighted round-robin is enabled.'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model DescribeDNSSLBSubDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDNSSLBSubDomainsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDNSSLBSubDomains  DescribeDNSSLBSubDomainsRequest
  * @return DescribeDNSSLBSubDomainsResponse
 */
async function describeDNSSLBSubDomains(request: DescribeDNSSLBSubDomainsRequest): DescribeDNSSLBSubDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDNSSLBSubDomains', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsCacheDomainsRequest {
  keyword?: string(name='Keyword', description='The keyword for searches in "%KeyWord%" mode. The value is not case-sensitive.', example='a\\"\\"', position='Query'),
  lang?: string(name='Lang', description='The language.', example='zh', position='Query'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Maximum value: **100**. Default value: **20**.', example='20', minimum=1, maximum=100, position='Query'),
}

model DescribeDnsCacheDomainsResponseBody = {
  domains?: [ 
    {
      cacheTtlMax?: int32(name='CacheTtlMax', description='The maximum time-to-live (TTL) period of the cached data retrieved from the origin DNS server. Unit: seconds. Valid values: 30 to 86400.', example='86400'),
      cacheTtlMin?: int32(name='CacheTtlMin', description='The minimum TTL period of the cached data retrieved from the origin DNS server. Unit: seconds. Valid values: 30 to 86400.', example='30'),
      createTime?: string(name='CreateTime', description='The time when the domain name was added. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2022-10-17T06:13Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The time when the domain name was added. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1660546144000'),
      domainId?: string(name='DomainId', description='The ID of the cache-accelerated domain name.', example='00efd71a-770e-4255-b54e-6fe5659baffe'),
      domainName?: string(name='DomainName', description='The cache-accelerated domain name.', example='dns-example.top'),
      expireTime?: string(name='ExpireTime', description='The time when the instance expires. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2022-12-02T16:00Z'),
      expireTimestamp?: long(name='ExpireTimestamp', description='The time when the instance expires. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1692374400000'),
      instanceId?: string(name='InstanceId', description='The instance ID of the cache-accelerated domain name.', example='i-7bg'),
      remark?: string(name='Remark', description='The description of the domain name.', example='remark'),
      sourceDnsServers?: [ 
        {
          host?: string(name='Host', description='The domain name or IP address of the origin DNS server.', example='ns8.alidns.com'),
          port?: string(name='Port', description='The port of the origin DNS server.', example='53'),
        }
      ](name='SourceDnsServers', description='The origin DNS servers.'),
      sourceEdns?: string(name='SourceEdns', description='Specifies whether the origin Domain Name System (DNS) server supports Extension Mechanisms for DNS (EDNS). Valid values: NOT_SUPPORT and SUPPORT.', example='SUPPORT'),
      sourceProtocol?: string(name='SourceProtocol', description='The origin protocol policy. Valid values: TCP and UDP. Default value: UDP.', example='UDP'),
      updateTime?: string(name='UpdateTime', description='The time when the configurations of the domain name were updated. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2023-05-22T03:40Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The time when the configurations of the domain name were updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1671690491000'),
      versionCode?: string(name='VersionCode', description='The edition code of Alibaba Cloud DNS.', example='ultimate'),
    }
  ](name='Domains', description='The domain names.'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: 1 to 100. Default value: 20.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='57121A9C-CDCF-541F-AD39-275D89099420'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='3'),
}

model DescribeDnsCacheDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsCacheDomainsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDnsCacheDomains  DescribeDnsCacheDomainsRequest
  * @return DescribeDnsCacheDomainsResponse
 */
async function describeDnsCacheDomains(request: DescribeDnsCacheDomainsRequest): DescribeDnsCacheDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsCacheDomains', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmAccessStrategiesRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='instance1', position='Query'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.', example='1', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='1', minimum=1, maximum=100, position='Query'),
  strategyMode: string(name='StrategyMode', description='The type of the access policy. Valid values:

*   GEO: geographical location-based
*   LATENCY: latency-based

This parameter is required.', example='geo', position='Query'),
}

model DescribeDnsGtmAccessStrategiesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0CCC9971-CEC9-4132-824B-4AE611C07623'),
  strategies?: {
    strategy?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the access policy was created.', example='2018-08-09T00:10Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates when the access policy was created.', example='1533773400000'),
      effectiveAddrPoolGroupType?: string(name='EffectiveAddrPoolGroupType', description='The type of the active address pool group. Valid values:

*   DEFAULT: the primary address pool group
*   FAILOVER: the secondary address pool group', example='default'),
      effectiveAddrPoolType?: string(name='EffectiveAddrPoolType', description='The type of the active address pools. Valid values:

*   IPV4
*   IPV6
*   DOMAIN', example='ipv4'),
      effectiveAddrPools?: {
        effectiveAddrPool?: [ 
        {
          addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='3'),
          id?: string(name='Id', description='The ID of the address pool.', example='pool1'),
          lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool.', example='1'),
          name?: string(name='Name', description='The name of the address pool.', example='test'),
        }
      ](name='EffectiveAddrPool')
      }(name='EffectiveAddrPools', description='The active address pool groups.'),
      effectiveLbaStrategy?: string(name='EffectiveLbaStrategy', description='The load balancing policy of the active address pool group. Data is returned when StrategyMode is set to GEO. Valid values: 

- ALL_RR: returns all addresses.
- RATIO: returns addresses by weight.', example='all_rr'),
      lines?: {
        line?: [ 
        {
          groupCode?: string(name='GroupCode', description='The code of the source region group.', example='default'),
          groupName?: string(name='GroupName', description='The name of the source region group.', example='global'),
          lineCode?: string(name='LineCode', description='The line code of the source region.', example='default'),
          lineName?: string(name='LineName', description='The line name of the source region.', example='global'),
        }
      ](name='Line')
      }(name='Lines', description='The source regions. Data is returned when StrategyMode is set to GEO. Valid values:'),
      strategyId?: string(name='StrategyId', description='The ID of the access policy.', example='strategyid1'),
      strategyName?: string(name='StrategyName', description='The name of the access policy.', example='strategname1'),
    }
  ](name='Strategy')
  }(name='Strategies', description='The access policies.'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned on all pages.', example='11'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='11'),
}

model DescribeDnsGtmAccessStrategiesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmAccessStrategiesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDnsGtmAccessStrategies  DescribeDnsGtmAccessStrategiesRequest
  * @return DescribeDnsGtmAccessStrategiesResponse
 */
async function describeDnsGtmAccessStrategies(request: DescribeDnsGtmAccessStrategiesRequest): DescribeDnsGtmAccessStrategiesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmAccessStrategies', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmAccessStrategyRequest {
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
  strategyId: string(name='StrategyId', description='The ID of the access policy.

This parameter is required.', example='strategyId1', position='Query'),
}

model DescribeDnsGtmAccessStrategyResponseBody = {
  accessMode?: string(name='AccessMode', description='The primary/secondary switchover policy for address pool groups. Valid values:

*   AUTO: performs automatic switchover between the primary and secondary address pool groups upon failures.
*   DEFAULT: uses the primary address pool group.
*   FAILOVER: uses the secondary address pool group.', example='auto'),
  createTime?: string(name='CreateTime', description='The time when the access policy was created.', example='2018-08-09T00:10Z'),
  createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates when the access policy was created.', example='1533773400000'),
  defaultAddrPoolGroupStatus?: string(name='DefaultAddrPoolGroupStatus', description='The status of the primary address pool group. Valid values:

*   AVAILABLE: available
*   NOT_AVAILABLE: unavailable', example='AVAILABLE'),
  defaultAddrPoolType?: string(name='DefaultAddrPoolType', description='The type of the primary address pool. Valid values:

*   IPV4
*   IPV6
*   DOMAIN', example='ipv4'),
  defaultAddrPools?: {
    defaultAddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='1'),
      id?: string(name='Id', description='The ID of the address pool.', example='pool1'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool.', example='1'),
      name?: string(name='Name', description='The name of the address pool.', example='test'),
    }
  ](name='DefaultAddrPool')
  }(name='DefaultAddrPools', description='The address pools in the primary address pool group.'),
  defaultAvailableAddrNum?: int32(name='DefaultAvailableAddrNum', description='The number of available addresses in the primary address pool.', example='1'),
  defaultLatencyOptimization?: string(name='DefaultLatencyOptimization', description='Indicates whether scheduling optimization for latency resolution was enabled for the primary address pool group. Valid values:

*   OPEN: enabled
*   CLOSE: disabled', example='open'),
  defaultLbaStrategy?: string(name='DefaultLbaStrategy', description='The load balancing policy of the primary address pool group. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr'),
  defaultMaxReturnAddrNum?: int32(name='DefaultMaxReturnAddrNum', description='The maximum number of addresses returned from the primary address pool group.', example='1'),
  defaultMinAvailableAddrNum?: int32(name='DefaultMinAvailableAddrNum', description='The minimum number of available addresses in the primary address pool group.', example='1'),
  effectiveAddrPoolGroupType?: string(name='EffectiveAddrPoolGroupType', description='The type of the active address pool group. Valid values:

*   DEFAULT: the primary address pool group
*   FAILOVER: the secondary address pool group', example='DEFAULT'),
  failoverAddrPoolGroupStatus?: string(name='FailoverAddrPoolGroupStatus', description='The status of the secondary address pool group. Valid values:

*   AVAILABLE: available
*   NOT_AVAILABLE: unavailable', example='AVAILABLE'),
  failoverAddrPoolType?: string(name='FailoverAddrPoolType', description='The type of the secondary address pool. Valid values:

*   IPV4
*   IPV6
*   DOMAIN', example='ipv4'),
  failoverAddrPools?: {
    failoverAddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='1'),
      id?: string(name='Id', description='The ID of the address pool.', example='pool1'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool.', example='1'),
      name?: string(name='Name', description='The name of the address pool.', example='test'),
    }
  ](name='FailoverAddrPool')
  }(name='FailoverAddrPools', description='The address pools in the secondary address pool group.'),
  failoverAvailableAddrNum?: int32(name='FailoverAvailableAddrNum', description='The number of available addresses in the secondary address pool.', example='1'),
  failoverLatencyOptimization?: string(name='FailoverLatencyOptimization', description='Indicates whether scheduling optimization for latency resolution was enabled for the secondary address pool group. Valid values:

*   OPEN: enabled
*   CLOSE: disabled', example='open'),
  failoverLbaStrategy?: string(name='FailoverLbaStrategy', description='The load balancing policy of the secondary address pool group. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr'),
  failoverMaxReturnAddrNum?: int32(name='FailoverMaxReturnAddrNum', description='The maximum number of addresses returned from the secondary address pool group.', example='1'),
  failoverMinAvailableAddrNum?: int32(name='FailoverMinAvailableAddrNum', description='The minimum number of available addresses in the secondary address pool group.', example='1'),
  instanceId?: string(name='InstanceId', description='The ID of the associated instance.', example='instance1'),
  lines?: {
    line?: [ 
    {
      groupCode?: string(name='GroupCode', description='The code of the source region group.', example='default'),
      groupName?: string(name='GroupName', description='The name of the source region group.', example='global'),
      lineCode?: string(name='LineCode', description='The line code of the source region.', example='default'),
      lineName?: string(name='LineName', description='The line name of the source region.', example='global'),
    }
  ](name='Line')
  }(name='Lines', description='The source regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BA1608CA-834C-4E63-8682-8AF0B11ED72D'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy.', example='strategyId1'),
  strategyMode?: string(name='StrategyMode', description='The type of the access policy. Valid values:

*   GEO: geographical location-based
*   LATENCY: latency-based', example='geo'),
  strategyName?: string(name='StrategyName', description='The name of the access policy.', example='strategyName1'),
}

model DescribeDnsGtmAccessStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmAccessStrategyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDnsGtmAccessStrategy  DescribeDnsGtmAccessStrategyRequest
  * @return DescribeDnsGtmAccessStrategyResponse
 */
async function describeDnsGtmAccessStrategy(request: DescribeDnsGtmAccessStrategyRequest): DescribeDnsGtmAccessStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmAccessStrategy', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmAccessStrategyAvailableConfigRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='instance1', position='Query'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
  strategyMode: string(name='StrategyMode', description='The type of the access policy. Valid values:

*   GEO: geographical location-based
*   LATENCY: latency-based

This parameter is required.', example='geo', position='Query'),
}

model DescribeDnsGtmAccessStrategyAvailableConfigResponseBody = {
  domainAddrPools?: {
    domainAddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='1'),
      id?: string(name='Id', description='The ID of the address pool.', example='pool1'),
      name?: string(name='Name', description='The name of the address pool.', example='testpool'),
    }
  ](name='DomainAddrPool')
  }(name='DomainAddrPools', description='The available address pools of the domain name type.'),
  ipv4AddrPools?: {
    ipv4AddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='1'),
      id?: string(name='Id', description='The ID of the address pool.', example='pool1'),
      name?: string(name='Name', description='The name of the address pool.', example='testpool'),
    }
  ](name='Ipv4AddrPool')
  }(name='Ipv4AddrPools', description='The available address pools of the IPv4 type.'),
  ipv6AddrPools?: {
    ipv6AddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='1'),
      id?: string(name='Id', description='The ID of the address pool.', example='pool1'),
      name?: string(name='Name', description='The name of the address pool.', example='testpool'),
    }
  ](name='Ipv6AddrPool')
  }(name='Ipv6AddrPools', description='The available address pools of the IPv6 type.'),
  lines?: {
    line?: [ 
    {
      fatherCode?: string(name='FatherCode', description='The parent line code of the source region. Leave it blank if no parent line exists.', example='telecom'),
      groupCode?: string(name='GroupCode', description='The line name of the source region.', example='default'),
      groupName?: string(name='GroupName', description='The name of the source region group.', example='global'),
      lineCode?: string(name='LineCode', description='The line code of the source region.', example='default'),
      lineName?: string(name='LineName', description='The code of the source region group.', example='global'),
    }
  ](name='Line')
  }(name='Lines', description='The source regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C2851BA9-CE56-49AF-8D12-4FC6A49EE688'),
  selectedDomainLines?: {
    selectedDomainLine?: [ string ](name='SelectedDomainLine')
  }(name='SelectedDomainLines'),
  selectedIpv4Lines?: {
    selectedIpv4Line?: [ string ](name='SelectedIpv4Line')
  }(name='SelectedIpv4Lines'),
  selectedIpv6Lines?: {
    selectedIpv6Line?: [ string ](name='SelectedIpv6Line')
  }(name='SelectedIpv6Lines'),
  suggestSetDefaultLine?: boolean(name='SuggestSetDefaultLine', description='Indicates whether we recommend that you set the source region to global.', example='true'),
}

model DescribeDnsGtmAccessStrategyAvailableConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDnsGtmAccessStrategyAvailableConfig  DescribeDnsGtmAccessStrategyAvailableConfigRequest
  * @return DescribeDnsGtmAccessStrategyAvailableConfigResponse
 */
async function describeDnsGtmAccessStrategyAvailableConfig(request: DescribeDnsGtmAccessStrategyAvailableConfigRequest): DescribeDnsGtmAccessStrategyAvailableConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmAccessStrategyAvailableConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmAddrAttributeInfoRequest {
  addrs: string(name='Addrs', description='The addresses.

This parameter is required.', example='["1.1.1.1"]', position='Query'),
  lang?: string(name='Lang', description='The language of the values for specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
  type: string(name='Type', description='The type of addresses. Valid values:

*   IPV4: IPv4 address
*   IPv6: IPv6 address
*   DOMAIN: domain name

This parameter is required.', example='ipv4', position='Query'),
}

model DescribeDnsGtmAddrAttributeInfoResponseBody = {
  addr?: {
    addr?: [ 
    {
      addr?: string(name='Addr', description='The address in the address pool.', example='1.1.1.1'),
      attributeInfo?: {
        fatherCode?: string(name='FatherCode', description='The parent line code of the source region.', example='telecom'),
        groupCode?: string(name='GroupCode', description='The code of the source region group.', example='DEFAULT'),
        groupName?: string(name='GroupName', description='The name of the source region group.', example='Global'),
        lineCode?: string(name='LineCode', description='The line code of the source region.', example='default'),
        lineName?: string(name='LineName', description='The line name of the source region.', example='Global'),
      }(name='AttributeInfo', description='The information about the source region of the address.'),
    }
  ](name='Addr')
  }(name='Addr', description='The address in the address pool.'),
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model DescribeDnsGtmAddrAttributeInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmAddrAttributeInfoResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDnsGtmAddrAttributeInfo  DescribeDnsGtmAddrAttributeInfoRequest
  * @return DescribeDnsGtmAddrAttributeInfoResponse
 */
async function describeDnsGtmAddrAttributeInfo(request: DescribeDnsGtmAddrAttributeInfoRequest): DescribeDnsGtmAddrAttributeInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmAddrAttributeInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmAddressPoolAvailableConfigRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='instance1', position='Query'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
}

model DescribeDnsGtmAddressPoolAvailableConfigResponseBody = {
  attributeInfos?: {
    attributeInfo?: [ 
    {
      fatherCode?: string(name='FatherCode', description='The parent line code of the source region.', example='telecom'),
      groupCode?: string(name='GroupCode', description='The code of the source region group.', example='default'),
      groupName?: string(name='GroupName', description='The name of the request source group.', example='global'),
      lineCode?: string(name='LineCode', description='The line code of the source region.', example='default'),
      lineName?: string(name='LineName', description='The line name of the source region.', example='global'),
    }
  ](name='AttributeInfo')
  }(name='AttributeInfos', description='The supported source regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='199C3699-9A7B-41A1-BB5A-F1E862D3CB38'),
}

model DescribeDnsGtmAddressPoolAvailableConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmAddressPoolAvailableConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDnsGtmAddressPoolAvailableConfig  DescribeDnsGtmAddressPoolAvailableConfigRequest
  * @return DescribeDnsGtmAddressPoolAvailableConfigResponse
 */
async function describeDnsGtmAddressPoolAvailableConfig(request: DescribeDnsGtmAddressPoolAvailableConfigRequest): DescribeDnsGtmAddressPoolAvailableConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmAddressPoolAvailableConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmAvailableAlertGroupRequest {
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
}

model DescribeDnsGtmAvailableAlertGroupResponseBody = {
  availableAlertGroup?: string(name='AvailableAlertGroup', description='The returned available alert groups.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model DescribeDnsGtmAvailableAlertGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmAvailableAlertGroupResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDnsGtmAvailableAlertGroup  DescribeDnsGtmAvailableAlertGroupRequest
  * @return DescribeDnsGtmAvailableAlertGroupResponse
 */
async function describeDnsGtmAvailableAlertGroup(request: DescribeDnsGtmAvailableAlertGroupRequest): DescribeDnsGtmAvailableAlertGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmAvailableAlertGroup', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmInstanceRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance about which you want to query the information.

This parameter is required.', example='instance1', position='Query'),
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
}

model DescribeDnsGtmInstanceResponseBody = {
  config?: {
    alertConfig?: {
      alertConfig?: [ 
      {
        dingtalkNotice?: boolean(name='DingtalkNotice'),
        emailNotice?: boolean(name='EmailNotice', description='Indicates whether email notification is configured. Valid values:

*   true: Email notification is configured.
*   false: Email notification is not configured. null: Email notification is not configured.', example='true'),
        noticeType?: string(name='NoticeType', description='The type of the alert event. Valid values:

*   ADDR_ALERT: The address is unavailable.
*   ADDR_RESUME: The address is restored and becomes available.
*   ADDR_POOL_GROUP_UNAVAILABLE: The address pool group is unavailable.
*   ADDR_POOL_GROUP_AVAILABLE: The address pool group is restored and becomes available.
*   ACCESS_STRATEGY_POOL_GROUP_SWITCH: Switchover is triggered between the primary and secondary address pools.
*   MONITOR_NODE_IP_CHANGE: The IP address of the monitoring node has changed.', example='ADDR_ALERT'),
        smsNotice?: boolean(name='SmsNotice', description='Indicates whether SMS notification is configured. Valid values:

*   true: SMS notification is configured.
*   false: SMS notification is not configured. null: SMS notification is not configured.', example='true'),
      }
    ](name='AlertConfig')
    }(name='AlertConfig', description='The alert notification method.'),
    alertGroup?: string(name='AlertGroup', description='The name of the alert group.', example='alertgroup1'),
    cnameType?: string(name='CnameType', description='The type of the CNAME domain name that is used to access the instance. Valid value:

*   PUBLIC: The CNAME domain name is used to access the instance over the Internet.', example='public'),
    instanceName?: string(name='InstanceName', description='The name of the instance.', example='instancetest1'),
    pubicZoneName?: string(name='PubicZoneName', description='The domain name that is used to access the instance over the Internet.', example='test.rr.gtm-003.com'),
    publicCnameMode?: string(name='PublicCnameMode', description='Indicates whether a custom CNAME domain name or a CNAME domain name assigned by the system is used to access the instance over the Internet. Valid values:

*   CUSTOM: A custom CNAME domain name is used.
*   SYSTEM_ASSIGN: A CNAME domain name assigned by the system is used.', example='custom'),
    publicRr?: string(name='PublicRr', description='The hostname corresponding to the CNAME domain name that is used to access the instance over the Internet.', example='test.rr'),
    publicUserDomainName?: string(name='PublicUserDomainName', description='The service domain name that is used over the Internet.', example='example.com'),
    strategyMode?: string(name='StrategyMode', description='The type of the access policy. Valid values:

*   LATENCY: Latency-based
*   GEO: Geographical location-based', example='GEO'),
    ttl?: int32(name='Ttl', description='The global time to live (TTL).', example='1'),
  }(name='Config', description='The configurations of the instance.'),
  createTime?: string(name='CreateTime', description='The time when the instance was created.', example='2020-10-14T06:58Z'),
  createTimestamp?: long(name='CreateTimestamp', description='The UNIX timestamp that indicates when the instance was created.', example='1602656937000'),
  expireTime?: string(name='ExpireTime', description='The time when the instance expires.', example='2020-10-14T06:58Z'),
  expireTimestamp?: long(name='ExpireTimestamp', description='The UNIX timestamp that indicates when the instance expires.', example='1602656937000'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='instanceid1'),
  paymentType?: string(name='PaymentType', description='The billing method. Valid value:

*   Subscription: You can pay in advance for the use of resources.', example='Subscription'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='84314904-D047-4176-A0EC-256D7F68C7F5'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs.', example='resourcegroupid1'),
  smsQuota?: int32(name='SmsQuota', description='The total number of SMS notifications.', example='100'),
  taskQuota?: int32(name='TaskQuota', description='The total number of detection tasks.', example='100'),
  usedQuota?: {
    dingtalkUsedCount?: int32(name='DingtalkUsedCount'),
    emailUsedCount?: int32(name='EmailUsedCount', description='The total number of emails that were sent.', example='123'),
    smsUsedCount?: int32(name='SmsUsedCount', description='The total number of short messages that were sent.', example='123'),
    taskUsedCount?: int32(name='TaskUsedCount', description='The number of detection tasks that were created.', example='123'),
  }(name='UsedQuota', description='The used quota.'),
  versionCode?: string(name='VersionCode', description='The version of the instance.', example='versioncode1'),
}

model DescribeDnsGtmInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmInstanceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDnsGtmInstance  DescribeDnsGtmInstanceRequest
  * @return DescribeDnsGtmInstanceResponse
 */
async function describeDnsGtmInstance(request: DescribeDnsGtmInstanceRequest): DescribeDnsGtmInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmInstance', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmInstanceAddressPoolRequest {
  addrPoolId: string(name='AddrPoolId', description='The ID of the address pool.

This parameter is required.', example='testpool1', position='Query'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
}

model DescribeDnsGtmInstanceAddressPoolResponseBody = {
  addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='1'),
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.', example='testpool1'),
  addrs?: {
    addr?: [ 
    {
      addr?: string(name='Addr', description='The address.', example='1.1.1.1'),
      alertStatus?: string(name='AlertStatus', description='The status of the last health check on the address. Valid values:

*   OK: No active alerts are triggered.
*   ALERT: Alerts are triggered based on the alert rules.', example='ok'),
      attributeInfo?: string(name='AttributeInfo', description='The source region of the address.

*   lineCode: the line code of the source region of the address. This parameter is deprecated, and lineCodes prevails.
*   lineName: the line name of the source region of the address. This parameter is deprecated.
*   lineCodes: the line codes of the source regions of the address.', example='"lineCode":"aliyun_r_cn-zhangjiakou", "lineName": "Alibaba Cloud_China (Zhangjiakou)", "lineCodes": ["aliyun_r_cn-zhangjiakou"]'),
      createTime?: string(name='CreateTime', description='The time when the address was added into the address pool.', example='2017-12-28T13:08Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates the time when the address was added into the address pool.', example='1527690629357'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address.', example='1'),
      mode?: string(name='Mode', description='The mode of the address. Valid values:

*   SMART: smart return
*   ONLINE: always online
*   OFFLINE: always offline', example='online'),
      remark?: string(name='Remark', description='The description of the address.', example='test'),
      updateTime?: string(name='UpdateTime', description='The time when the address was last updated.', example='2017-12-28T13:08Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The timestamp that indicates the time when the address was last updated.', example='1527690629357'),
    }
  ](name='Addr')
  }(name='Addrs', description='The addresses in the address pool.'),
  createTime?: string(name='CreateTime', description='The time when the address pool was created.', example='2017-12-28T13:08Z'),
  createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates the time when the address pool was created.', example='1527690629357'),
  lbaStrategy?: string(name='LbaStrategy', description='The load balancing policy for the address pool. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.', example='test1'),
  monitorStatus?: string(name='MonitorStatus', description='Indicates the status of the health check. Valid values:

*   OPEN: The health check is enabled.
*   CLOSE: The health check is disabled.
*   UNCONFIGURED: The health check is not configured.', example='open'),
  name?: string(name='Name', description='The name of the address pool.', example='test'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  type?: string(name='Type', description='The type of the address pool. Valid values:

*   IPV4: IPv4 address
*   IPV6: IPv6 address
*   DOMAIN: domain name', example='ipv4'),
  updateTime?: string(name='UpdateTime', description='The time when the address pool was last updated.', example='2017-12-28T13:08Z'),
  updateTimestamp?: long(name='UpdateTimestamp', description='The timestamp that indicates the time when the address pool was last updated.', example='1527690629357'),
}

model DescribeDnsGtmInstanceAddressPoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmInstanceAddressPoolResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDnsGtmInstanceAddressPool  DescribeDnsGtmInstanceAddressPoolRequest
  * @return DescribeDnsGtmInstanceAddressPoolResponse
 */
async function describeDnsGtmInstanceAddressPool(request: DescribeDnsGtmInstanceAddressPoolRequest): DescribeDnsGtmInstanceAddressPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmInstanceAddressPool', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmInstanceAddressPoolsRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='instance1', position='Query'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1', minimum=1, maximum=9999999, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 100. Default value: 20.', example='1', minimum=1, maximum=100, position='Query'),
}

model DescribeDnsGtmInstanceAddressPoolsResponseBody = {
  addrPools?: {
    addrPool?: [ 
    {
      addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='1'),
      addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.', example='pool-1'),
      createTime?: string(name='CreateTime', description='The time when the address pool was created.', example='2017-12-28T13:08Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates when the address pool was created.', example='1527690629357'),
      lbaStrategy?: string(name='LbaStrategy', description='The load balancing policy of the address pool. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr'),
      monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check task.', example='abc123'),
      monitorStatus?: string(name='MonitorStatus', description='Indicates whether health checks are configured. Valid values:

*   OPEN: enabled
*   CLOSE: disabled
*   UNCONFIGURED: not configured', example='open'),
      name?: string(name='Name', description='The name of the address pool.', example='testpool'),
      type?: string(name='Type', description='The type of the address pool. Valid values:

*   IPV4: IPv4 address
*   IPV6: IPv6 address
*   DOMAIN: domain name', example='ipv4'),
      updateTime?: string(name='UpdateTime', description='The time when the address pool was updated.', example='2017-12-28T13:08Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The timestamp that indicates when the address pool was updated.', example='1527690629357'),
    }
  ](name='AddrPool')
  }(name='AddrPools', description='The returned address pools.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned on all pages.', example='1'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeDnsGtmInstanceAddressPoolsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmInstanceAddressPoolsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDnsGtmInstanceAddressPools  DescribeDnsGtmInstanceAddressPoolsRequest
  * @return DescribeDnsGtmInstanceAddressPoolsResponse
 */
async function describeDnsGtmInstanceAddressPools(request: DescribeDnsGtmInstanceAddressPoolsRequest): DescribeDnsGtmInstanceAddressPoolsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmInstanceAddressPools', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmInstanceStatusRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='instance1', position='Query'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
}

model DescribeDnsGtmInstanceStatusResponseBody = {
  addrAvailableNum?: int32(name='AddrAvailableNum', description='The number of available addresses.', example='1'),
  addrNotAvailableNum?: int32(name='AddrNotAvailableNum', description='The number of unavailable addresses.', example='1'),
  addrPoolGroupNotAvailableNum?: int32(name='AddrPoolGroupNotAvailableNum', description='The number of unavailable address pool groups.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='389DFFA3-77A5-4A9E-BF3D-147C6F98A5BA'),
  strategyNotAvailableNum?: int32(name='StrategyNotAvailableNum', description='The number of access policies that are unavailable in the current active address pool group.', example='1'),
  switchToFailoverStrategyNum?: int32(name='SwitchToFailoverStrategyNum', description='The number of access policies switched to the secondary address pool group.', example='1'),
}

model DescribeDnsGtmInstanceStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmInstanceStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDnsGtmInstanceStatus  DescribeDnsGtmInstanceStatusRequest
  * @return DescribeDnsGtmInstanceStatusResponse
 */
async function describeDnsGtmInstanceStatus(request: DescribeDnsGtmInstanceStatusRequest): DescribeDnsGtmInstanceStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmInstanceStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmInstanceSystemCnameRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='instance1', position='Query'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
}

model DescribeDnsGtmInstanceSystemCnameResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  systemCname?: string(name='SystemCname', description='The CNAME domain name assigned by the system.', example='gtminstance.com'),
}

model DescribeDnsGtmInstanceSystemCnameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmInstanceSystemCnameResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDnsGtmInstanceSystemCname  DescribeDnsGtmInstanceSystemCnameRequest
  * @return DescribeDnsGtmInstanceSystemCnameResponse
 */
async function describeDnsGtmInstanceSystemCname(request: DescribeDnsGtmInstanceSystemCnameRequest): DescribeDnsGtmInstanceSystemCnameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmInstanceSystemCname', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmInstancesRequest {
  keyword?: string(name='Keyword', description='The keyword that you use for the query. Fuzzy search by instance ID or instance name is supported.', example='instance1', position='Query'),
  lang?: string(name='Lang', description='The language of the values for specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1', minimum=1, maximum=9999999, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Maximum value: **100**. Default value: **20**.', example='1', minimum=1, maximum=100, position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-testgroupid', position='Query'),
}

model DescribeDnsGtmInstancesResponseBody = {
  gtmInstances?: [ 
    {
      config?: {
        alertConfig?: [ 
          {
            dingtalkNotice?: string(name='DingtalkNotice', description='Indicates whether DingTalk alert notifications are configured. Valid values:

*   true
*   false | null', example='true'),
            emailNotice?: string(name='EmailNotice', description='Indicates whether email notifications are configured. Valid values:

*   true
*   false | null', example='true'),
            noticeType?: string(name='NoticeType', description='The type of the alert event. Valid values:

*   ADDR_ALERT: The address is unavailable.
*   ADDR_RESUME: The address becomes available.
*   ADDR_POOL_GROUP_UNAVAILABLE: The address pool set is unavailable.
*   ADDR_POOL_GROUP_AVAILABLE: The address pool set becomes available.
*   ACCESS_STRATEGY_POOL_GROUP_SWITCH: Switchover is triggered between the primary and secondary address pools.', example='ADDR_ALERT'),
            smsNotice?: string(name='SmsNotice', description='Indicates whether SMS notifications are configured. Valid values:

*   true
*   false | null', example='true'),
          }
        ](name='AlertConfig', description='The alert notification method.'),
        alertGroup?: string(name='AlertGroup', description='The alert contact groups. The value is in the JSON format.', example='testgroup'),
        cnameType?: string(name='CnameType', description='The type of the CNAME. Valid value:

*   PUBLIC', example='public'),
        instanceName?: string(name='InstanceName', description='The name of the instance.', example='instanceTest'),
        publicCnameMode?: string(name='PublicCnameMode', description='Specifies whether to use a custom CNAME or a system-assigned CNAME to access GTM over the Internet. Valid values:

*   CUSTOM: a custom CNAME
*   SYSTEM_ASSIGN: a system-assigned CNAME. You cannot set PublicCnameMode to this value.', example='custom'),
        publicRr?: string(name='PublicRr', description='The hostname of the domain name that is used to access GTM over the Internet.', example='test.rr'),
        publicUserDomainName?: string(name='PublicUserDomainName', description='The domain name that is used to access GTM over the Internet.', example='example.com'),
        publicZoneName?: string(name='PublicZoneName', description='The canonical name (CNAME) that is used to access GTM over the Internet.', example='test.rr.gtm-003.com'),
        strategyMode?: string(name='StrategyMode', description='The type of the access policy. Valid values:

*   LATENCY: latency-based access policy
*   GEO: geographical location-based access policy', example='geo'),
        ttl?: int32(name='Ttl', description='The global time to live (TTL).', example='1'),
      }(name='Config', description='The configurations of the instance.'),
      createTime?: string(name='CreateTime', description='The time when the instance was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2020-10-14T06:58Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The time when the instance was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1602658709000'),
      expireTime?: string(name='ExpireTime', description='The time when the instance expires. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2020-10-14T06:58Z'),
      expireTimestamp?: long(name='ExpireTimestamp', description='The time when the instance expires. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1602658709000'),
      instanceId?: string(name='InstanceId', description='The instance ID.', example='instance1'),
      paymentType?: string(name='PaymentType', description='The billing method of the GTM instance. Valid value:

*   Subscription.', example='Subscription'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='resourceGroupid123'),
      smsQuota?: int32(name='SmsQuota', description='The total number of Short Message Service (SMS) notifications.', example='1'),
      taskQuota?: int32(name='TaskQuota', description='The total number of detection tasks.', example='1'),
      usedQuota?: {
        dingtalkUsedCount?: int32(name='DingtalkUsedCount', description='The total number of sent DingTalk notifications.', example='100'),
        emailUsedCount?: int32(name='EmailUsedCount', description='The total number of sent email notifications.', example='100'),
        smsUsedCount?: int32(name='SmsUsedCount', description='The total number of sent SMS notifications.', example='100'),
        taskUsedCount?: int32(name='TaskUsedCount', description='The number of created detection tasks.', example='100'),
      }(name='UsedQuota', description='The used quota.'),
      versionCode?: string(name='VersionCode', description='The version of the instance.', example='testVersion1'),
    }
  ](name='GtmInstances', description='The Global Traffic Manager (GTM) instances.'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Maximum value: 100. Default value: 20.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='84314904-D047-4176-A0EC-256D7F68C7F5'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned.', example='100'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='123'),
}

model DescribeDnsGtmInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmInstancesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDnsGtmInstances  DescribeDnsGtmInstancesRequest
  * @return DescribeDnsGtmInstancesResponse
 */
async function describeDnsGtmInstances(request: DescribeDnsGtmInstancesRequest): DescribeDnsGtmInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmLogsRequest {
  endTimestamp?: long(name='EndTimestamp', description='The timestamp that specifies the end of the time range to query.', example='1516779348000', minimum=1, maximum=999999999999999, position='Query'),
  instanceId: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='instance1', position='Query'),
  keyword?: string(name='Keyword', description='The keyword for searches in "%KeyWord%" mode. The value is not case-sensitive.', example='demo', position='Query'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1', minimum=1, maximum=9999999, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 100. Default value: 20.', example='1', minimum=1, maximum=100, position='Query'),
  startTimestamp?: long(name='StartTimestamp', description='The timestamp that specifies the beginning of the time range to query.', example='1516779348000', minimum=1, maximum=999999999999999, position='Query'),
}

model DescribeDnsGtmLogsResponseBody = {
  logs?: {
    log?: [ 
    {
      content?: string(name='Content', description='The formatted message content.', example='addtest-pool-1'),
      entityId?: string(name='EntityId', description='The ID of the object on which the operation was performed.', example='121212'),
      entityName?: string(name='EntityName', description='The name of the object on which the operation was performed.', example='test-pool-1'),
      entityType?: string(name='EntityType', description='The type of the object on which the operation was performed.'),
      id?: long(name='Id', description='The ID of the record.', example='6726'),
      operAction?: string(name='OperAction', description='The operation performed.'),
      operTime?: string(name='OperTime', description='The time when the operation was performed.', example='2018-01-24T07:35Z'),
      operTimestamp?: long(name='OperTimestamp', description='The timestamp of the operation.', example='1516779348000'),
    }
  ](name='Log')
  }(name='Logs', description='The returned logs.'),
  pageNumber?: int32(name='PageNumber', description='The number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='50C60A29-2E93-425A-ABA8-068686E28873'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned on all pages.', example='1'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeDnsGtmLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmLogsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDnsGtmLogs  DescribeDnsGtmLogsRequest
  * @return DescribeDnsGtmLogsResponse
 */
async function describeDnsGtmLogs(request: DescribeDnsGtmLogsRequest): DescribeDnsGtmLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmLogs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmMonitorAvailableConfigRequest {
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
}

model DescribeDnsGtmMonitorAvailableConfigResponseBody = {
  domainIpv4IspCityNodes?: {
    domainIpv4IspCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The city code.', example='503'),
      cityName?: string(name='CityName', description='The display name of the city.', example='Zhangjiakou'),
      defaultSelected?: boolean(name='DefaultSelected', description='Indicates whether the health check node is selected by default.', example='true'),
      groupName?: string(name='GroupName', description='The name of the node group.', example='BGP Nodes'),
      groupType?: string(name='GroupType', description='The type of the node group. Valid values:

*   BGP: BGP node
*   OVERSEAS: node outside the Chinese mainland
*   ISP: ISP node', example='BGP'),
      ips?: {
        ip?: [ string ](name='Ip')
      }(name='Ips', description='The IP addresses of the health check nodes.'),
      ispCode?: string(name='IspCode', description='The ISP code.', example='465'),
      ispName?: string(name='IspName', description='The display name of the ISP.', example='Alibaba'),
    }
  ](name='DomainIpv4IspCityNode')
  }(name='DomainIpv4IspCityNodes', description='The nodes that perform health checks on domain names that use public IPv4 addresses.'),
  domainIpv6IspCityNodes?: {
    domainIpv6IspCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The city code.', example='503'),
      cityName?: string(name='CityName', description='The display name of the city.', example='Zhangjiakou'),
      defaultSelected?: boolean(name='DefaultSelected', description='Indicates whether the health check node is selected by default.', example='false'),
      groupName?: string(name='GroupName', description='The name of the node group.', example='BGP Nodes'),
      groupType?: string(name='GroupType', description='The type of the node group. Valid values:

*   BGP: BGP node
*   OVERSEAS: node outside the Chinese mainland
*   ISP: ISP node', example='BGP'),
      ips?: {
        ip?: [ string ](name='ip')
      }(name='Ips', description='This parameter is not returned.'),
      ispCode?: string(name='IspCode', description='The ISP code.', example='465'),
      ispName?: string(name='IspName', description='The display name of the ISP.', example='Alibaba'),
    }
  ](name='DomainIpv6IspCityNode')
  }(name='DomainIpv6IspCityNodes', description='The nodes that perform health checks on domain names that use public IPv6 addresses.'),
  ipv4IspCityNodes?: {
    ipv4IspCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The city code.', example='503'),
      cityName?: string(name='CityName', description='The display name of the city.', example='Zhangjiakou'),
      defaultSelected?: boolean(name='DefaultSelected', description='Indicates whether the health check node is selected by default.', example='true'),
      groupName?: string(name='GroupName', description='The name of the node group.', example='BGP Nodes'),
      groupType?: string(name='GroupType', description='The type of the node group. Valid values:

*   BGP: Border Gateway Protocol (BGP) node
*   OVERSEAS: node outside the Chinese mainland
*   ISP: ISP node', example='BGP'),
      ips?: {
        ip?: [ string ](name='Ip')
      }(name='Ips', description='The IP addresses of the health check nodes.'),
      ispCode?: string(name='IspCode', description='The Internet service provider (ISP) code.', example='465'),
      ispName?: string(name='IspName', description='The display name of the ISP.', example='Alibaba'),
    }
  ](name='Ipv4IspCityNode')
  }(name='Ipv4IspCityNodes', description='The nodes that perform health checks on public IPv4 addresses.'),
  ipv6IspCityNodes?: {
    ipv6IspCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The city code.', example='503'),
      cityName?: string(name='CityName', description='The display name of the city.', example='Zhangjiakou'),
      defaultSelected?: boolean(name='DefaultSelected', description='Indicates whether the health check node is selected by default.', example='true'),
      groupName?: string(name='GroupName', description='The name of the node group.', example='BGP Nodes'),
      groupType?: string(name='GroupType', description='The type of the node group. Valid values:

*   BGP: BGP node
*   OVERSEAS: node outside the Chinese mainland
*   ISP: ISP node', example='BGP'),
      ips?: {
        ip?: [ string ](name='Ip')
      }(name='Ips', description='This parameter is not returned.'),
      ispCode?: string(name='IspCode', description='The ISP code.', example='465'),
      ispName?: string(name='IspName', description='The display name of the ISP.', example='Alibaba'),
    }
  ](name='Ipv6IspCityNode')
  }(name='Ipv6IspCityNodes', description='The nodes that perform health checks on public IPv6 addresses.'),
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model DescribeDnsGtmMonitorAvailableConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmMonitorAvailableConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDnsGtmMonitorAvailableConfig  DescribeDnsGtmMonitorAvailableConfigRequest
  * @return DescribeDnsGtmMonitorAvailableConfigResponse
 */
async function describeDnsGtmMonitorAvailableConfig(request: DescribeDnsGtmMonitorAvailableConfigRequest): DescribeDnsGtmMonitorAvailableConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmMonitorAvailableConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmMonitorConfigRequest {
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
  monitorConfigId: string(name='MonitorConfigId', description='The ID of the health check task.

This parameter is required.', example='MonitorConfigId1', position='Query'),
}

model DescribeDnsGtmMonitorConfigResponseBody = {
  createTime?: string(name='CreateTime', description='The time when the health check configuration was created. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2017-12-28T13:08Z'),
  createTimestamp?: long(name='CreateTimestamp', description='The time when the health check configuration was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1527690629357'),
  evaluationCount?: int32(name='EvaluationCount', description='The number of consecutive failures.', example='1'),
  interval?: int32(name='Interval', description='The health check interval. Unit: seconds.', example='1'),
  ispCityNodes?: {
    ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The city code.', example='572'),
      cityName?: string(name='CityName', description='The display name of the city.', example='Qingdao'),
      countryCode?: string(name='CountryCode', description='The code of the country or region.', example='001'),
      countryName?: string(name='CountryName', description='The display name of the country or region.', example='China'),
      ispCode?: string(name='IspCode', description='The Internet service provider (ISP) code.', example='123'),
      ispName?: string(name='IspName', description='The display name of the ISP.', example='Alibaba'),
    }
  ](name='IspCityNode')
  }(name='IspCityNodes', description='The health check nodes.'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.', example='MonitorConfigId1'),
  monitorExtendInfo?: string(name='MonitorExtendInfo', description='The extended information. The required parameters vary based on the value of ProtocolType.

*   HTTP or HTTPS

    *   port: the port that you want to check

    *   host: the host settings

    *   path: the URL path

    *   code: the response code. The health check result is deemed abnormal if the returned value is greater than the specified value.

    *   failureRate: the failure rate

    *   sni: specifies whether to enable server name indication (SNI). This parameter is available only when ProtocolType is set to HTTPS. Valid values:

        *   true: enables SNI.
        *   false: disables SNI.

    *   nodeType: the type of the node for monitoring when the address pool type is domain name. Valid values:

        *   IPV4
        *   IPV6

*   PING:

    *   failureRate: the failure rate

    *   packetNum: the number of ping packets

    *   packetLossRate: the loss rate of ping packets

    *   nodeType: the type of the node for monitoring when the address pool type is domain name. Valid values:

        *   IPV4
        *   IPV6

*   TCP

    *   port: the port that you want to check

    *   failureRate: the failure rate

    *   nodeType: the type of the node for monitoring when the address pool type is domain name. Valid values:

        *   IPV4
        *   IPV6', example='{\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}'),
  protocolType?: string(name='ProtocolType', description='The health check protocol. Valid values:

*   HTTP
*   HTTPS
*   PING
*   TCP', example='http'),
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  timeout?: int32(name='Timeout', description='The timeout period. Unit: milliseconds.', example='3000'),
  updateTime?: string(name='UpdateTime', description='The time when the health check configuration was updated. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2018-01-03T08:57Z'),
  updateTimestamp?: long(name='UpdateTimestamp', description='The time when the health check configuration was updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1527690629357'),
}

model DescribeDnsGtmMonitorConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmMonitorConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDnsGtmMonitorConfig  DescribeDnsGtmMonitorConfigRequest
  * @return DescribeDnsGtmMonitorConfigResponse
 */
async function describeDnsGtmMonitorConfig(request: DescribeDnsGtmMonitorConfigRequest): DescribeDnsGtmMonitorConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmMonitorConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsProductInstanceRequest {
  instanceId: string(name='InstanceId', description='The ID of the DNS instance. . You can call the [DescribeDomainInfo](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomaininfo?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.

This parameter is required.', example='i-8fxxxx', position='Query'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en', example='en', position='Query'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0', position='Query'),
}

model DescribeDnsProductInstanceResponseBody = {
  autoRenewal?: boolean(name='AutoRenewal', description='Indicates whether auto-renewal was enabled. Valid values:

*   true: Auto-renewal was enabled.
*   false: Auto-renewal was not enabled.', example='true'),
  bindCount?: long(name='BindCount', description='The number of times that you can change the domain names that are bound to the paid Alibaba Cloud DNS instance. This parameter applies to Alibaba Cloud DNS instances of the custom edition.', example='3'),
  bindDomainCount?: long(name='BindDomainCount', description='The number of domain names that can be bound to the paid Alibaba Cloud DNS instance. This parameter applies to Alibaba Cloud DNS instances of Personal Edition, Enterprise Standard Edition, and Enterprise Ultimate Edition.', example='5'),
  bindDomainUsedCount?: long(name='BindDomainUsedCount', description='The number of domain names that are bound to the paid Alibaba Cloud DNS instance. This parameter applies to Alibaba Cloud DNS instances of Personal Edition, Enterprise Standard Edition, and Enterprise Ultimate Edition.', example='3'),
  bindUsedCount?: long(name='BindUsedCount', description='The number of times that you have changed the domain names that are bound to the paid Alibaba Cloud DNS instance. This parameter applies to Alibaba Cloud DNS instances of the custom edition.', example='1'),
  dDosDefendFlow?: long(name='DDosDefendFlow', description='The DDoS protection traffic. Unit: GB.', example='50'),
  dDosDefendQuery?: long(name='DDosDefendQuery', description='The DDoS protection frequency. Unit: 10,000 QPS. This parameter applies to Alibaba Cloud DNS instances of the custom edition.', example='50'),
  dnsSLBCount?: long(name='DnsSLBCount', description='The maximum number of IP addresses that are used for load balancing in a single line of a domain name.', example='15'),
  dnsSecurity?: string(name='DnsSecurity', description='The level of DNS protection. Valid values:

*   no: No DNS protection is provided.
*   basic: Basic DNS protection is provided.
*   advanced: Advanced DNS protection is provided.', example='advanced'),
  dnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='DnsServers', description='The DNS servers configured for the domain names.'),
  domain?: string(name='Domain', description='The domain name that is bound to the paid instance.

If no value is returned for this parameter, no domain name is bound to the paid instance.', example='example.com'),
  domainType?: string(name='DomainType', description='The type of the instance. Valid values:

*   PUBLIC: authoritative domain name
*   CACHE: cache-accelerated domain name', example='PUBLIC'),
  endTime?: string(name='EndTime', description='The time when the instance expired. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2015-12-12T09:23Z'),
  endTimestamp?: long(name='EndTimestamp', description='The time when the instance expired. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1474335170000'),
  gslb?: boolean(name='Gslb', description='Indicates whether global server load balancing (GSLB) is supported. Valid values:

*   true: GSLB is supported.
*   false: GSLB is not supported.', example='true'),
  ISPLines?: string(name='ISPLines', description='The ISP resolution lines. Valid values:

*   China Telecom
*   China Mobile
*   China Unicom
*   China Education and Research Network (CERNET)
*   China Broadcasting Network (CBN)
*   Dr Peng Telecom & Media Group'),
  ISPRegionLines?: string(name='ISPRegionLines', description='The regional ISP resolution lines. Valid values:

*   China Telecom (province)
*   China Mobile (province)
*   China Unicom (province)
*   CERNET (province)'),
  inBlackHole?: boolean(name='InBlackHole', description='Indicates whether the Domain Name System (DNS) servers stopped responding to all DNS requests. Valid values:

*   true: The DNS servers stopped responding to all DNS requests.
*   false: The DNS servers did not stop responding to all DNS requests.', example='false'),
  inClean?: boolean(name='InClean', description='Indicates whether the DNS servers stopped responding to abnormal requests sent to the domain names.

*   true: The DNS servers stopped responding to abnormal requests sent to the domain names.
*   false: The DNS servers did not stop responding to abnormal requests sent to the domain names.', example='false'),
  instanceId?: string(name='InstanceId', description='The ID of the Alibaba Cloud DNS instance.', example='i-8fxxx'),
  monitorFrequency?: long(name='MonitorFrequency', description='The interval at which the instance is monitored. Unit: minutes.', example='50'),
  monitorNodeCount?: long(name='MonitorNodeCount', description='The number of monitoring nodes.', example='5'),
  monitorTaskCount?: long(name='MonitorTaskCount', description='The number of monitoring tasks.', example='2'),
  overseaDDosDefendFlow?: long(name='OverseaDDosDefendFlow', description='The DDoS protection traffic outside the Chinese mainland. Unit: GB.', example='1'),
  overseaLine?: string(name='OverseaLine', description='The line outside the Chinese mainland.'),
  paymentType?: string(name='PaymentType', description='The billing method.', example='Subscription'),
  regionLines?: boolean(name='RegionLines', description='Indicates whether the DNS request lines are regional lines. Valid values:

*   true: The DNS request lines are regional lines.
*   false: The DNS request lines are not regional lines.', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  searchEngineLines?: string(name='SearchEngineLines', description='The search engine resolution lines. Valid values:

*   Google
*   Baidu
*   Bing
*   Youdao'),
  startTime?: string(name='StartTime', description='The time when the instance was purchased. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2015-12-12T09:23Z'),
  startTimestamp?: long(name='StartTimestamp', description='The time when the instance was purchased. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1474335170000'),
  subDomainLevel?: long(name='SubDomainLevel', description='The number of subdomain name levels.', example='6'),
  TTLMinValue?: long(name='TTLMinValue', description='The minimum time-to-live (TTL) period. Unit: seconds.', example='10'),
  URLForwardCount?: long(name='URLForwardCount', description='The number of the forwarded URLs.', example='20'),
  versionCode?: string(name='VersionCode', description='The version code of Alibaba Cloud DNS.', example='version1'),
  versionName?: string(name='VersionName', description='The edition of Alibaba Cloud DNS.'),
}

model DescribeDnsProductInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsProductInstanceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDnsProductInstance  DescribeDnsProductInstanceRequest
  * @return DescribeDnsProductInstanceResponse
 */
async function describeDnsProductInstance(request: DescribeDnsProductInstanceRequest): DescribeDnsProductInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsProductInstance', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsProductInstancesRequest {
  direction?: string(name='Direction', description='The order in which you want to sort returned entries. Valid values:

*   DESC: Returned entries are sorted in descending order. If this parameter is left empty, returned entries are sorted in descending order by default.
*   ASC: Returned entries are sorted in ascending order.', example='DESC', position='Query'),
  domainType?: string(name='DomainType', description='The type of the domain name. Valid values:

*   PUBLIC (default): hosted public domain name
*   CACHE: cached public domain name', example='PUBLIC', position='Query'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en', example='en', position='Query'),
  orderBy?: string(name='OrderBy', description='The method that is used to sort returned entries. Valid values:

*   createDate: sorts returned entries by creation time. If this parameter is left empty, returned entries are sorted by creation time by default.
*   expireDate: sorts returned entries by expiration time.', example='createDate', position='Query'),
  pageNumber?: long(name='PageNumber', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page. Maximum value: **100**. Default value: **20**.', example='20', minimum=1, maximum=1000, position='Query'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0', position='Query'),
  versionCode?: string(name='VersionCode', description='The version code of the Alibaba Cloud DNS instance.', example='version1', position='Query'),
}

model DescribeDnsProductInstancesResponseBody = {
  dnsProducts?: {
    dnsProduct?: [ 
    {
      autoRenewal?: boolean(name='AutoRenewal', description='Indicates whether auto-renewal was enabled. Valid values:

*   true: Auto-renewal was enabled.
*   false: Auto-renewal was not enabled.', example='true'),
      bindCount?: long(name='BindCount', description='The number of times you can change domain names that are bound to the DNS instance. It can be specified by the user who uses Alibaba Cloud DNS of the custom version.', example='3'),
      bindDomainCount?: long(name='BindDomainCount', description='The number of domain names that can be bound to the DNS instance.', example='5'),
      bindDomainUsedCount?: long(name='BindDomainUsedCount', description='The number of domain names that have been bound to the DNS instance.', example='3'),
      bindUsedCount?: long(name='BindUsedCount', description='The number of times you have changed domain names that are bound to the DNS instance. It can be specified by the user who uses Alibaba Cloud DNS of the custom version.', example='1'),
      dDosDefendFlow?: long(name='DDosDefendFlow', description='The DDoS protection traffic. Unit: GB.', example='50'),
      dDosDefendQuery?: long(name='DDosDefendQuery', description='The DDoS protection frequency. Unit: 10,000 QPS.', example='50'),
      dnsSLBCount?: long(name='DnsSLBCount', description='The number of IP addresses supported by a domain name or line.', example='15'),
      dnsSecurity?: string(name='DnsSecurity', description='The level of DNS protection. Valid values:

*   no: No DNS protection is provided.
*   basic: Basic DNS protection is provided.
*   advanced: Advanced DNS protection is provided.', example='no'),
      domain?: string(name='Domain', description='The bound domain name.', example='example.com'),
      endTime?: string(name='EndTime', description='The time at which the instance expired.', example='2015-12-12T00:00Z'),
      endTimestamp?: long(name='EndTimestamp', description='The UNIX timestamp representing the expiration time of the instance.', example='1474335170000'),
      gslb?: boolean(name='Gslb', description='Indicates whether global server load balancing (GSLB) is supported.

*   true: GSLB is supported.
*   false: GSLB is not supported.', example='true'),
      ISPLines?: string(name='ISPLines', description='The ISP resolution lines.

*   China Telecom
*   China Mobile
*   China Unicom
*   CERNET
*   China Broadcasting Network (CBN)
*   Dr Peng Telecom & Media Group', example='China Mobile,China Unicom,China Telecom,China Edu'),
      ISPRegionLines?: string(name='ISPRegionLines', description='The regional ISP resolution lines. Valid values:

*   China Telecom (province)
*   China Mobile (province)
*   China Unicom (province)
*   China Education and Research Network (CERNET) (province)', example='Telecom (Province), Mobile (Province), Unicom (Province), Education Network (Province)'),
      inBlackHole?: boolean(name='InBlackHole', description='Indicates whether the Domain Name System (DNS) servers stopped responding to all requests. Valid values:

*   true: The DNS servers stopped responding to all requests.
*   false: The DNS servers did not stop responding to all requests.', example='false'),
      inClean?: boolean(name='InClean', description='Indicates whether the request for domain name resolution was being cleared.', example='false'),
      instanceId?: string(name='InstanceId', description='The ID of the Alibaba Cloud DNS instance.', example='i-8fj'),
      monitorFrequency?: long(name='MonitorFrequency', description='The monitoring frequency. Unit: minutes.', example='50'),
      monitorNodeCount?: long(name='MonitorNodeCount', description='The number of monitored nodes.', example='5'),
      monitorTaskCount?: long(name='MonitorTaskCount', description='The number of monitoring tasks.', example='2'),
      overseaDDosDefendFlow?: long(name='OverseaDDosDefendFlow', description='DDoS protection traffic outside China. Unit: GB.', example='1'),
      overseaLine?: string(name='OverseaLine', description='The type of the overseas line.', example='Countries'),
      paymentType?: string(name='PaymentType', description='The billing method.', example='Subscription'),
      regionLines?: boolean(name='RegionLines', description='Indicates whether the DNS request lines are regional lines.

*   true: The DNS request lines are regional lines.
*   false: The DNS request lines are not regional lines.', example='true'),
      searchEngineLines?: string(name='SearchEngineLines', description='The search engine resolution lines. Valid values:

*   Google
*   Baidu
*   Bing
*   Youdao', example='Search Engine Robots,Google Robots,Baidu Robots,Bing Robots'),
      startTime?: string(name='StartTime', description='The time when the DNS instance was purchased.', example='2015-11-12T09:23Z'),
      startTimestamp?: long(name='StartTimestamp', description='The UNIX timestamp representing when the DNS instance was purchased.', example='1474335170000'),
      subDomainLevel?: long(name='SubDomainLevel', description='The number of subdomain name levels.', example='6'),
      TTLMinValue?: long(name='TTLMinValue', description='The minimum TTL. Unit: seconds.', example='10'),
      URLForwardCount?: long(name='URLForwardCount', description='The URL forwarding quantity.', example='20'),
      versionCode?: string(name='VersionCode', description='The version code of the Alibaba Cloud DNS instance.', example='version1'),
      versionName?: string(name='VersionName', description='The version name of the Alibaba Cloud DNS instance.', example='Alibaba Cloud DNS'),
    }
  ](name='DnsProduct')
  }(name='DnsProducts', description='The paid Alibaba Cloud DNS instances.'),
  domainType?: string(name='DomainType', description='The type of the domain name. Valid values:

*   PUBLIC (default): hosted public domain name
*   CACHE: cached public domain name', example='PUBLIC'),
  pageNumber?: long(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries returned per page.', example='2'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: long(name='TotalCount', description='The total number of domain names.', example='2'),
}

model DescribeDnsProductInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsProductInstancesResponseBody(name='body'),
}

/**
  * @description >  If the response parameters of an Alibaba Cloud DNS instance do not contain domain names, no domain names are bound to the instance.
  * @param request  the request parameters of DescribeDnsProductInstances  DescribeDnsProductInstancesRequest
  * @return DescribeDnsProductInstancesResponse
 */
async function describeDnsProductInstances(request: DescribeDnsProductInstancesRequest): DescribeDnsProductInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsProductInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDohAccountStatisticsRequest {
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the YYYY-MM-DD format.

The default value is the day when you perform the operation.', example='2019-07-04', position='Query'),
  lang?: string(name='Lang', description='The language type.', example='en', position='Query'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.

You can query only the DNS records of the latest 90 days.`The value of StartDate must be greater than or equal to the difference between the current date and 90`.', example='2019-07-04', position='Query'),
}

model DescribeDohAccountStatisticsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0F32959D-417B-4D66-8463-68606605E3E2'),
  statistics?: [ 
    {
      timestamp?: long(name='Timestamp', description='The timestamp.', example='1544976000000'),
      totalCount?: long(name='TotalCount', description='The total number of requests.', example='3141592653'),
      v4HttpCount?: long(name='V4HttpCount', description='The number of IPv4-based HTTP requests.', example='3141592653'),
      v4HttpsCount?: long(name='V4HttpsCount', description='The number of IPv4-based HTTPS requests.', example='3141592653'),
      v6HttpCount?: long(name='V6HttpCount', description='The number of IPv6-based HTTP requests.', example='3141592653'),
      v6HttpsCount?: long(name='V6HttpsCount', description='The number of IPv6-based HTTPS requests.', example='3141592653'),
    }
  ](name='Statistics', description='The statistics list.'),
}

model DescribeDohAccountStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDohAccountStatisticsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDohAccountStatistics  DescribeDohAccountStatisticsRequest
  * @return DescribeDohAccountStatisticsResponse
 */
async function describeDohAccountStatistics(request: DescribeDohAccountStatisticsRequest): DescribeDohAccountStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDohAccountStatistics', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDohDomainStatisticsRequest {
  domainName: string(name='DomainName', description='The domain name.

This parameter is required.', example='example.com', position='Query'),
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the YYYY-MM-DD format.

The default value is the day when you perform the operation.', example='2019-07-04', position='Query'),
  lang?: string(name='Lang', description='The language type.', example='en', position='Query'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.

You can query only the DNS records of the latest 90 days. `The value of StartDate must be greater than or equal to the difference between the current date and 90`.', example='2019-07-04', position='Query'),
}

model DescribeDohDomainStatisticsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0F32959D-417B-4D66-8463-68606605E3E2'),
  statistics?: [ 
    {
      timestamp?: long(name='Timestamp', description='The timestamp.', example='1544976000000'),
      totalCount?: long(name='TotalCount', description='The total number of requests.', example='3141592653'),
      v4HttpCount?: long(name='V4HttpCount', description='The number of IPv4-based HTTP requests.', example='3141592653'),
      v4HttpsCount?: long(name='V4HttpsCount', description='The number of IPv4-based HTTPS requests.', example='3141592653'),
      v6HttpCount?: long(name='V6HttpCount', description='The number of IPv6-based HTTP requests.', example='3141592653'),
      v6HttpsCount?: long(name='V6HttpsCount', description='The number of IPv6-based HTTPS requests.', example='3141592653'),
    }
  ](name='Statistics', description='The statistics list.'),
}

model DescribeDohDomainStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDohDomainStatisticsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDohDomainStatistics  DescribeDohDomainStatisticsRequest
  * @return DescribeDohDomainStatisticsResponse
 */
async function describeDohDomainStatistics(request: DescribeDohDomainStatisticsRequest): DescribeDohDomainStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDohDomainStatistics', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDohDomainStatisticsSummaryRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com', position='Query'),
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the YYYY-MM-DD format.

The default value is the day when you perform the operation.', example='2019-07-04', position='Query'),
  lang?: string(name='Lang', description='The language type.', example='en', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 100. Default value: 20.', example='20', minimum=1, maximum=100, position='Query'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.

You can query only the DNS records of the last 90 days. `The value of StartDate must be greater than or equal to the difference between the current date and 90`.', example='2019-07-04', position='Query'),
}

model DescribeDohDomainStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0F32959D-417B-4D66-8463-68606605E3E2'),
  statistics?: [ 
    {
      domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
      httpCount?: long(name='HttpCount', description='The number of HTTP requests.', example='3141592653'),
      httpsCount?: long(name='HttpsCount', description='The number of HTTPS requests.', example='3141592653'),
      ipCount?: long(name='IpCount', description='The number of IP addresses.', example='20'),
      totalCount?: long(name='TotalCount', description='The total number of requests.', example='14141592653'),
      v4HttpCount?: long(name='V4HttpCount', description='The number of IPv4-based HTTP requests.', example='3141592653'),
      v4HttpsCount?: long(name='V4HttpsCount', description='The number of IPv4-based HTTPS requests.', example='3141592653'),
      v6HttpCount?: long(name='V6HttpCount', description='The number of IPv6-based HTTP requests.', example='3141592653'),
      v6HttpsCount?: long(name='V6HttpsCount', description='The number of IPv6-based HTTPS requests.', example='3141592653'),
    }
  ](name='Statistics', description='The statistics list.'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned.', example='300'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='50'),
}

model DescribeDohDomainStatisticsSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDohDomainStatisticsSummaryResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDohDomainStatisticsSummary  DescribeDohDomainStatisticsSummaryRequest
  * @return DescribeDohDomainStatisticsSummaryResponse
 */
async function describeDohDomainStatisticsSummary(request: DescribeDohDomainStatisticsSummaryRequest): DescribeDohDomainStatisticsSummaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDohDomainStatisticsSummary', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDohSubDomainStatisticsRequest {
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the YYYY-MM-DD format.

The default value is the day when you perform the operation.', example='2019-07-04', position='Query'),
  lang?: string(name='Lang', description='The language type.', example='en', position='Query'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.

You can query only the DNS records of the latest 90 days. `The value of StartDate must be greater than or equal to the difference between the current date and 90`.', example='2019-07-04', position='Query'),
  subDomain: string(name='SubDomain', description='The subdomain whose statistics you want to query.

This parameter is required.', example='www.example.com', position='Query'),
}

model DescribeDohSubDomainStatisticsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0F32959D-417B-4D66-8463-68606605E3E2'),
  statistics?: [ 
    {
      timestamp?: long(name='Timestamp', description='The timestamp.', example='1544976000000'),
      totalCount?: long(name='TotalCount', description='The total number of requests.', example='3141592653'),
      v4HttpCount?: long(name='V4HttpCount', description='The number of IPv4-based HTTP requests.', example='3141592653'),
      v4HttpsCount?: long(name='V4HttpsCount', description='The number of IPv4-based HTTPS requests.', example='3141592653'),
      v6HttpCount?: long(name='V6HttpCount', description='The number of IPv6-based HTTP requests.', example='3141592653'),
      v6HttpsCount?: long(name='V6HttpsCount', description='The number of IPv6-based HTTPS requests.', example='3141592653'),
    }
  ](name='Statistics', description='The statistics list.'),
}

model DescribeDohSubDomainStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDohSubDomainStatisticsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDohSubDomainStatistics  DescribeDohSubDomainStatisticsRequest
  * @return DescribeDohSubDomainStatisticsResponse
 */
async function describeDohSubDomainStatistics(request: DescribeDohSubDomainStatisticsRequest): DescribeDohSubDomainStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDohSubDomainStatistics', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDohSubDomainStatisticsSummaryRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com', position='Query'),
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the YYYY-MM-DD format.

The default value is the day when you query the required data.', example='2019-07-04', position='Query'),
  lang?: string(name='Lang', description='The language type.', example='en', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 100. Default value: 20.', example='20', minimum=1, maximum=100, position='Query'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.

You can query only the DNS records of the last 90 days. `The value of StartDate must be greater than or equal to the difference between the current date and 90`.', example='2019-07-04', position='Query'),
  subDomain?: string(name='SubDomain', description='The subdomain.', example='www.example.com', position='Query'),
}

model DescribeDohSubDomainStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0F32959D-417B-4D66-8463-68606605E3E2'),
  statistics?: [ 
    {
      httpCount?: long(name='HttpCount', description='The number of HTTP requests.', example='3141592653'),
      httpsCount?: long(name='HttpsCount', description='The number of HTTPS requests.', example='3141592653'),
      ipCount?: long(name='IpCount', description='The number of IP addresses.', example='20'),
      subDomain?: string(name='SubDomain', description='The subdomain.', example='www.example.com'),
      totalCount?: long(name='TotalCount', description='Total number of requests.', example='14141592653'),
      v4HttpCount?: long(name='V4HttpCount', description='The number of IPv4-based HTTP requests.', example='3141592653'),
      v4HttpsCount?: long(name='V4HttpsCount', description='The number of IPv4-based HTTPS requests.', example='3141592653'),
      v6HttpCount?: long(name='V6HttpCount', description='The number of IPv6-based HTTP requests.', example='3141592653'),
      v6HttpsCount?: long(name='V6HttpsCount', description='The number of IPv6-based HTTPS requests.', example='3141592653'),
    }
  ](name='Statistics', description='The statistics list.'),
  totalItems?: int32(name='TotalItems', description='Total number of entries returned.', example='100'),
  totalPages?: int32(name='TotalPages', description='Total number of pages returned.', example='50'),
}

model DescribeDohSubDomainStatisticsSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDohSubDomainStatisticsSummaryResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDohSubDomainStatisticsSummary  DescribeDohSubDomainStatisticsSummaryRequest
  * @return DescribeDohSubDomainStatisticsSummaryResponse
 */
async function describeDohSubDomainStatisticsSummary(request: DescribeDohSubDomainStatisticsSummaryRequest): DescribeDohSubDomainStatisticsSummaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDohSubDomainStatisticsSummary', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDohUserInfoRequest {
  endDate?: string(name='EndDate', description='The end time for the query. Format: YYYY-MM-DD

If you do not specify this parameter, the default value is the time when you perform the query.', example='2019-07-04', position='Query'),
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.', example='en', position='Query'),
  startDate?: string(name='StartDate', description='The start time for the query. Format: YYYY-MM-DD

You can query the user information of the last 90 days only. `Set the parameter to a value no earlier than 90 days from the current time`.', example='2019-07-04', position='Query'),
}

model DescribeDohUserInfoResponseBody = {
  domainCount?: int32(name='DomainCount', description='The number of accessed domains.', example='123'),
  pdnsId?: long(name='PdnsId', description='The ID of the Alibaba Cloud public DNS user.', example='12345678'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0F32959D-417B-4D66-8463-68606605E3E2'),
  subDomainCount?: int32(name='SubDomainCount', description='The number of accessed subdomains.', example='123'),
}

model DescribeDohUserInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDohUserInfoResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDohUserInfo  DescribeDohUserInfoRequest
  * @return DescribeDohUserInfoResponse
 */
async function describeDohUserInfo(request: DescribeDohUserInfoRequest): DescribeDohUserInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDohUserInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainDnssecInfoRequest {
  domainName: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.

This parameter is required.', example='example.com', position='Query'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English

Default value: **zh**', example='en', position='Query'),
}

model DescribeDomainDnssecInfoResponseBody = {
  algorithm?: string(name='Algorithm', description='The algorithm type. This parameter is returned if DNSSEC is enabled.', example='13'),
  digest?: string(name='Digest', description='The digest. This parameter is returned if DNSSEC is enabled.', example='C1A0424B97A049F1F9B2EA139CC298533219668164E343BD21203ABC4608C02A'),
  digestType?: string(name='DigestType', description='The digest type. This parameter is returned if DNSSEC is enabled.', example='SHA256'),
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  dsRecord?: string(name='DsRecord', description='The delegation signer (DS) record. This parameter is returned if DNSSEC is enabled.', example='example.com. 3600 IN DS 2371 13 2 C1A0424B97A049F1F9B2EA139CC298533219668164E343BD21203ABC4608C02A'),
  flags?: string(name='Flags', description='The flag. This parameter is returned if DNSSEC is enabled.', example='257 (KSK)'),
  keyTag?: string(name='KeyTag', description='The key tag. This parameter is returned if DNSSEC is enabled.', example='54931'),
  publicKey?: string(name='PublicKey', description='The public key. This parameter is returned if DNSSEC is enabled.', example='mdsswUyr3DPW132mOi8V9xESWE8jTo0dxCjjnopKl+GqJxpVXckHAeF+KkxLbxILfDLUT0rAK9iUzy1L53eKGQ=='),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  status?: string(name='Status', description='The state of the DNSSEC. Valid values:

*   ON
*   OFF', example='ON'),
}

model DescribeDomainDnssecInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainDnssecInfoResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDomainDnssecInfo  DescribeDomainDnssecInfoRequest
  * @return DescribeDomainDnssecInfoResponse
 */
async function describeDomainDnssecInfo(request: DescribeDomainDnssecInfoRequest): DescribeDomainDnssecInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainDnssecInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainGroupsRequest {
  keyWord?: string(name='KeyWord', description='The keyword of the domain name group for searches in %KeyWord% mode. The value is not case-sensitive.', example='Group', position='Query'),
  lang?: string(name='Lang', description='The language.', example='en', position='Query'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: **1 to 100**. Default value: **20**.', example='20', maximum=110, position='Query'),
}

model DescribeDomainGroupsResponseBody = {
  domainGroups?: {
    domainGroup?: [ 
    {
      domainCount?: long(name='DomainCount', description='The number of domain name groups.', example='2'),
      groupId?: string(name='GroupId', description='The ID of the domain name group. Valid values:

*   defaultGroup: the default group
*   If an empty string is returned, it indicates the group that contains all domain names.', example='2223'),
      groupName?: string(name='GroupName', description='The name of the domain name group.', example='MyGroup'),
    }
  ](name='DomainGroup')
  }(name='DomainGroups', description='The domain name groups.'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: **1 to 100**. Default value: **20**.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model DescribeDomainGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainGroupsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDomainGroups  DescribeDomainGroupsRequest
  * @return DescribeDomainGroupsResponse
 */
async function describeDomainGroups(request: DescribeDomainGroupsRequest): DescribeDomainGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainGroups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainInfoRequest {
  domainName: string(name='DomainName', description='The domain name.

This parameter is required.', example='dns-example.com', position='Query'),
  lang?: string(name='Lang', description='The language type.', example='en', position='Query'),
  needDetailAttributes?: boolean(name='NeedDetailAttributes', description='Specifies whether detailed attributes are required. Default value: **false**, which indicates that detailed attributes are not returned.

If you set this parameter to **true**, the values of the following parameters are returned: LineType, MinTtl, RecordLineTreeJson, RecordLines, LineCode, LineDisplayName, LineName, RegionLines, and SlaveDns.', example='true', position='Query'),
}

model DescribeDomainInfoResponseBody = {
  aliDomain?: boolean(name='AliDomain', description='Indicates whether the domain name was registered in Alibaba Cloud.', example='true'),
  availableTtls?: {
    availableTtl?: [ string ](name='AvailableTtl')
  }(name='AvailableTtls', description='The available time to live (TTL) values that can be configured for the domain name. Available TTL values are not returned by default. If you want to query such information, set NeedDetailAttributes to true.'),
  createTime?: string(name='CreateTime', description='The time when the domain name was created.', example='2015-12-12T09:23Z'),
  dnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='DnsServers', description='The DNS servers that are used to resolve the domain name.'),
  domainId?: string(name='DomainId', description='The ID of the domain name.', example='00efd71a-770e-4255-b54e-6fe5659baffe'),
  domainLoggingSwitchStatus?: string(name='DomainLoggingSwitchStatus', description='Indicates whether the DNS traffic analysis feature is enabled. Valid values:'),
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  groupId?: string(name='GroupId', description='The ID of the domain name group.', example='2223'),
  groupName?: string(name='GroupName', description='The name of the domain name group.', example='mygroup'),
  inBlackHole?: boolean(name='InBlackHole', description='Indicates whether blackhole filtering was triggered.', example='false'),
  inClean?: boolean(name='InClean', description='Indicates whether traffic scrubbing was in progress.', example='false'),
  instanceId?: string(name='InstanceId', description='The ID of the Alibaba Cloud DNS instance.', example='i-7bg'),
  lineType?: string(name='LineType', description='The type of the DNS request line.', example='region_province'),
  minTtl?: long(name='MinTtl', description='The minimum TTL value.', example='1'),
  punyCode?: string(name='PunyCode', description='The Punycode for the domain name. This parameter is returned only for Chinese domain names.', example='example.com'),
  recordLineTreeJson?: string(name='RecordLineTreeJson', description='The tree-structure DNS request lines.', example='{"default":{},"unicom":{},"telecom":{},"mobile":{},"edu":{},"oversea":{},"baidu":{},"biying":{},"google":{}}'),
  recordLines?: {
    recordLine?: [ 
    {
      fatherCode?: string(name='FatherCode', description='The code of the parent line. This parameter is not returned if the line has no parent line.', example='internal'),
      lineCode?: string(name='LineCode', description='The code of the line.', example='cn_region_xibei'),
      lineDisplayName?: string(name='LineDisplayName', description='The name of the parent line.'),
      lineName?: string(name='LineName', description='The name of the line.'),
    }
  ](name='RecordLine')
  }(name='RecordLines', description='The DNS request lines.'),
  regionLines?: boolean(name='RegionLines', description='Indicates whether the DNS request lines are regional lines.', example='false'),
  remark?: string(name='Remark', description='The description.', example='remark'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-aek3dj3wvclgcxo'),
  slaveDns?: boolean(name='SlaveDns', description='Indicates whether secondary DNS is supported.', example='true'),
  subDomain?: boolean(name='SubDomain', description='Indicates whether the queried domain name is a hosted subdomain name. Valid values:

*   true
*   false', example='false'),
  versionCode?: string(name='VersionCode', description='The version ID of Alibaba Cloud DNS.', example='version1'),
  versionName?: string(name='VersionName', description='The edition of Alibaba Cloud DNS.'),
}

model DescribeDomainInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainInfoResponseBody(name='body'),
}

/**
  * @description In this example, the domain name is bound to an instance of Alibaba Cloud DNS Enterprise Ultimate Edition. For more information about valid Domain Name System (DNS) request lines, see the return values of the RecordLines parameter.
  * @param request  the request parameters of DescribeDomainInfo  DescribeDomainInfoRequest
  * @return DescribeDomainInfoResponse
 */
async function describeDomainInfo(request: DescribeDomainInfoRequest): DescribeDomainInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainLogsRequest {
  groupId?: string(name='GroupId', description='The ID of the domain name group.', example='2223', position='Query'),
  keyWord?: string(name='KeyWord', description='The keyword for the query in "%KeyWord%" mode. The keyword is not case-sensitive.', example='test', position='Query'),
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.', example='en', position='Query'),
  pageNumber?: long(name='PageNumber', description='The page number to return. The page number starts from **1**. Default value: **1**.', example='1', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries to return per page. Maximum value: **100**. Default value: **20**.', example='20', minimum=1, maximum=100, position='Query'),
  startDate?: string(name='StartDate', description='The start time for the query. Format: **YYYY-MM-DD**', example='2019-07-04', position='Query'),
  type?: string(name='Type', description='The type of object of which you want to query operation logs. Valid values:

*   domain: domain name
*   slavedns: secondary Domain Name System (DNS)', example='domain', position='Query'),
  endDate?: string(name='endDate', description='The end time for the query. Format: **YYYY-MM-DD**', example='2019-07-04', position='Query'),
}

model DescribeDomainLogsResponseBody = {
  domainLogs?: {
    domainLog?: [ 
    {
      action?: string(name='Action', description='The operation.', example='Add'),
      actionTime?: string(name='ActionTime', description='The time when the operation is performed. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2015-12-12T09:23Z'),
      actionTimestamp?: long(name='ActionTimestamp', description='The time when the operation was performed. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='143562300000'),
      clientIp?: string(name='ClientIp', description='The IP address of the operator.', example='182.92.253.20'),
      domainName?: string(name='DomainName', description='The domain name.', example='abc.com'),
      message?: string(name='Message', description='The message for the operation.', example='To the DNS record list'),
      zoneId?: string(name='ZoneId', description='The ID of the private zone.', example='cxfd345sd234'),
    }
  ](name='DomainLog')
  }(name='DomainLogs', description='The operation logs.'),
  pageNumber?: long(name='PageNumber', description='The page number.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='2'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model DescribeDomainLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainLogsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDomainLogs  DescribeDomainLogsRequest
  * @return DescribeDomainLogsResponse
 */
async function describeDomainLogs(request: DescribeDomainLogsRequest): DescribeDomainLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainLogs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainNsRequest {
  domainName: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.

This parameter is required.', example='example.com', position='Query'),
  lang?: string(name='Lang', description='The language of the content in the request and response.

Valid values:

zh: Chinese\\
en: English

Default value: **zh**', example='en', position='Query'),
}

model DescribeDomainNsResponseBody = {
  allAliDns?: boolean(name='AllAliDns', description='Indicates whether all the name servers are Alibaba Cloud DNS servers.', example='true'),
  detectFailedReasonCode?: string(name='DetectFailedReasonCode', description='The cause code of the detection failure.', example='DnsCheck.Failed'),
  dnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='DnsServers', description='The DNS server names configured for the domain name.'),
  expectDnsServers?: {
    expectDnsServer?: [ string ](name='ExpectDnsServer')
  }(name='ExpectDnsServers', description='The Domain Name System (DNS) server names assigned by Alibaba Cloud DNS.'),
  includeAliDns?: boolean(name='IncludeAliDns', description='Indicates whether the name servers include Alibaba Cloud DNS servers.', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='16C7DC7A-2FA7-4D14-8B12-88A2BB6373DB'),
}

model DescribeDomainNsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainNsResponseBody(name='body'),
}

/**
  * @description >  You can call this operation to query the authoritative servers of a domain name registry to obtain the name servers for a domain name. If the domain name is in an invalid state, such as serverHold or clientHold, an error may be returned.
  * @param request  the request parameters of DescribeDomainNs  DescribeDomainNsRequest
  * @return DescribeDomainNsResponse
 */
async function describeDomainNs(request: DescribeDomainNsRequest): DescribeDomainNsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainNs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainRecordInfoRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en', position='Query'),
  recordId: string(name='RecordId', description='The ID of the DNS record. You can call the [DescribeDomainRecords](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomainrecords?spm=a2c63.p38356.help-menu-search-29697.d_0) to obtain the ID.

This parameter is required.', example='9999985', position='Query'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0', position='Query'),
}

model DescribeDomainRecordInfoResponseBody = {
  domainId?: string(name='DomainId', description='The ID of the domain name.', example='00efd71a-770e-4255-b54e-6fe5659baffe'),
  domainName?: string(name='DomainName', description='The domain name.', example='dns-example.top'),
  groupId?: string(name='GroupId', description='The ID of the domain name group.', example='2223'),
  groupName?: string(name='GroupName', description='The name of the domain name group.', example='MyGroup'),
  line?: string(name='Line', description='The DNS resolution line.', example='default'),
  locked?: boolean(name='Locked', description='The lock state of the DNS record. Valid values: **true and false**.', example='true'),
  priority?: long(name='Priority', description='The priority of the mail exchanger (MX) record.', example='5'),
  punyCode?: string(name='PunyCode', description='The Punycode for the domain name. This parameter is returned only for Chinese domain names.', example='xn--fsq270a.com'),
  rr?: string(name='RR', description='The hostname.', example='@'),
  recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
  remark?: string(name='Remark', description='The description of your DNS record.', example='test'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  status?: string(name='Status', description='The status of the DNS record. Valid values:

Enable: enabled

Disable: disabled', example='Enable'),
  TTL?: long(name='TTL', description='The time for which the DNS record is cached in a local DNS system.', example='600'),
  type?: string(name='Type', description='The type of the DNS record.', example='MX'),
  value?: string(name='Value', description='The record value.', example='1.1.XX.XX'),
}

model DescribeDomainRecordInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainRecordInfoResponseBody(name='body'),
}

/**
  * @description ## Debugging
  * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=Alidns\\&api=DescribeDomainRecordInfo\\&type=RPC\\&version=2015-01-09)
  * @param request  the request parameters of DescribeDomainRecordInfo  DescribeDomainRecordInfoRequest
  * @return DescribeDomainRecordInfoResponse
 */
async function describeDomainRecordInfo(request: DescribeDomainRecordInfoRequest): DescribeDomainRecordInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainRecordInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainRecordsRequest {
  direction?: string(name='Direction', description='The order in which you want to sort the returned DNS records. Valid values: DESC and ASC. Default value: DESC.', example='DESC', position='Query'),
  domainName: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.

This parameter is required.', example='example.com', position='Query'),
  groupId?: long(name='GroupId', description='The ID of the domain name group.

*   If you do not specify GroupId, all domain names are queried.
*   If you set GroupId to 0, no value is returned.
*   If you set GroupId to 1, the domain names in the default group are queried.
*   If you set GroupId to -2, all domain names are queried.
*   You can also specify GroupId based on the actual group ID.

You can call the [DescribeDomainGroups ](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomaingroups?spm=a2c63.p38356.help-menu-search-29697.d_0)operation to obtain the ID of the domain name group.', example='2223', position='Query'),
  keyWord?: string(name='KeyWord', description='The keyword.', example='test', position='Query'),
  lang?: string(name='Lang', description='The language.', example='en', position='Query'),
  line?: string(name='Line', description='The resolution line. Default value: **default**.

For more information, see

[DNS lines](https://www.alibabacloud.com/help/zh/doc-detail/29807.htm).', example='cn_mobile_anhui', position='Query'),
  orderBy?: string(name='OrderBy', description='The method that is used to sort the returned DNS records. By default, the DNS records are sorted in reverse chronological order based on the time when they were added.', example='default', position='Query'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: **1 to 500**. Default value: **20**.', example='20', minimum=1, maximum=500, position='Query'),
  RRKeyWord?: string(name='RRKeyWord', description='The hostname keyword based on which the system queries DNS records. The system queries DNS records based on the value of this parameter in fuzzy match mode. The value is not case-sensitive.', example='www', position='Query'),
  searchMode?: string(name='SearchMode', description='The search mode. Valid values: **LIKE, EXACT, and ADVANCED**.

*   If you set SearchMode to LIKE or EXACT, specify KeyWord. In this case, RRKeyWord, TypeKeyWord, ValueKeyWord, Type, Line, and Status are invalid.

*   If you set SearchMode to ADVANCED, specify RRKeyWord, TypeKeyWord, ValueKeyWord, Type, Line, and Status.

*   If you do not specify SearchMode, the system determines the search mode based on the following rules:

    *   If KeyWord is specified, the system uses the LIKE mode.
    *   If KeyWord is not specified, the system queries DNS records based on values of RRKeyWord and ValueKeyWord in fuzzy match mode, and based on the values of TypeKeyWord, Type, Line, and Status in exact match mode.', example='LIKE', position='Query'),
  status?: string(name='Status', description='The status of the DNS records to query. Valid values: **Enable and Disable**.', example='Enable', position='Query'),
  type?: string(name='Type', description='The type of the DNS records to query. For more information, see

[DNS record types](https://www.alibabacloud.com/help/zh/doc-detail/29805.htm).', example='A', position='Query'),
  typeKeyWord?: string(name='TypeKeyWord', description='The type keyword based on which the system queries DNS records. The system queries DNS records based on the value of this parameter in exact match mode. The value is not case-sensitive.', example='MX', position='Query'),
  valueKeyWord?: string(name='ValueKeyWord', description='The record value keyword based on which the system queries DNS records. The system queries DNS records based on the value of this parameter in fuzzy match mode. The value is not case-sensitive.', example='com', position='Query'),
}

model DescribeDomainRecordsResponseBody = {
  domainRecords?: {
    record?: [ 
    {
      createTimestamp?: long(name='CreateTimestamp', description='The time when the DNS record was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since 00:00:00 UTC on January 1, 1970.', example='1666501957000'),
      domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
      line?: string(name='Line', description='The resolution line.', example='default'),
      locked?: boolean(name='Locked', description='Indicates whether the DNS record is locked.', example='false'),
      priority?: long(name='Priority', description='The priority of the mail exchanger (MX) record.', example='5'),
      rr?: string(name='RR', description='The hostname.', example='www'),
      recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
      remark?: string(name='Remark', description='The description of the DNS record.', example='test'),
      status?: string(name='Status', description='The status of the DNS record.', example='Enable'),
      TTL?: long(name='TTL', description='The time-to-live (TTL) of the cached DNS record. Unit: seconds.', example='600'),
      type?: string(name='Type', description='The type of the DNS record.', example='MX'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The time when the DNS record was updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since 00:00:00 UTC on January 1, 1970.', example='1676872961000'),
      value?: string(name='Value', description='The record value.', example='mail1.hichina.com'),
      weight?: int32(name='Weight', description='The weight of the DNS record.', example='2'),
    }
  ](name='Record')
  }(name='DomainRecords', description='The returned Domain Name System (DNS) records.'),
  pageNumber?: long(name='PageNumber', description='The page number.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model DescribeDomainRecordsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainRecordsResponseBody(name='body'),
}

/**
  * @description *   You can specify DomainName, PageNumber, and PageSize to query the DNS records of the specified domain names.
  * *   You can also specify RRKeyWord, TypeKeyWord, or ValueKeyWord to query the DNS records that contain the specified keyword.
  * *   By default, the DNS records are sorted in reverse chronological order based on the time when they were added.
  * *   You can specify GroupId to query the DNS records of the specified domain names based on the group ID. You can query the DNS records of all domain names and the domain names in the default group.
  * @param request  the request parameters of DescribeDomainRecords  DescribeDomainRecordsRequest
  * @return DescribeDomainRecordsResponse
 */
async function describeDomainRecords(request: DescribeDomainRecordsRequest): DescribeDomainRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainRecords', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainResolveStatisticsSummaryRequest {
  direction?: string(name='Direction', description='The order in which you want to sort the returned entries. Valid values:

*   DESC: the descending order
*   ASC: the ascending order', example='DESC', position='Query'),
  endDate?: string(name='EndDate', description='The end time in the yyyy-MM-dd format, for example, 2023-03-13.', example='2023-03-01', position='Query'),
  keyword?: string(name='Keyword', description='The keyword. The Keyword parameter is used together with the SearchMode parameter.', example='test', position='Query'),
  lang?: string(name='Lang', description='The language. Valid values: zh, en, and ja.', example='zh', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 1000.', example='10', minimum=1, position='Query'),
  searchMode?: string(name='SearchMode', description='The search mode of the keyword. Valid values:

*   LIKE (default): fuzzy search
*   EXACT: exact search', example='EXACT', position='Query'),
  startDate: string(name='StartDate', description='The start time in the yyyy-MM-dd format, for example, 2023-03-01.

This parameter is required.', example='2023-03-01', position='Query'),
  threshold?: long(name='Threshold', description='The threshold for the number of Domain Name System (DNS) requests. You can query the domain names at the specified quantity level of DNS requests and query the number of DNS requests for each domain name.

If you do not specify this parameter, the data about the domain names that have DNS requests is obtained.

If you set this parameter to a value less than 0, the data about all domain names is obtained.

If you set this parameter to 0, the data about the domain names that do not have DNS requests is obtained.

If you set this parameter to a value greater than 0, the data about the domain names whose number of DNS requests is less than or equal to the value of this parameter is obtained.', example='-1', position='Query'),
}

model DescribeDomainResolveStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Maximum value: **100**. Default value: **20**.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  statistics?: [ 
    {
      count?: string(name='Count', description='The number of DNS requests.', example='35509014'),
      domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
      domainType?: string(name='DomainType', description='The type of the domain name. Valid values:

*   PUBLIC: hosted public domain name
*   CACHE: cache-accelerated domain name', example='CACHE'),
    }
  ](name='Statistics', description='The statistics.'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned.', example='1'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeDomainResolveStatisticsSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainResolveStatisticsSummaryResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDomainResolveStatisticsSummary  DescribeDomainResolveStatisticsSummaryRequest
  * @return DescribeDomainResolveStatisticsSummaryResponse
 */
async function describeDomainResolveStatisticsSummary(request: DescribeDomainResolveStatisticsSummaryRequest): DescribeDomainResolveStatisticsSummaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainResolveStatisticsSummary', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainStatisticsRequest {
  domainName?: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.', example='example.com', position='Query'),
  domainType?: string(name='DomainType', description='The type of the domain name. Valid values:

*   PUBLIC (default): hosted public domain name
*   CACHE: cached public domain name', example='PUBLIC CACHE', position='Query'),
  endDate?: string(name='EndDate', description='The end date of the query. Specify the end date in the **YYYY-MM-DD** format.

The default value is the day when you query the data.', example='2019-07-04', position='Query'),
  lang?: string(name='Lang', description='The language of the content within the request and response.

*   **zh**: Chinese (default)
*   **en**: English', example='en', position='Query'),
  startDate: string(name='StartDate', description='The start date of the query. Specify the start date in the **YYYY-MM-DD** format.

You can only query the DNS records within the last 90 days.``

This parameter is required.', example='2019-07-04', position='Query'),
}

model DescribeDomainStatisticsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='6AEC7A64-3CB1-4C49-8B35-0B901F1E26BF'),
  statistics?: {
    statistic?: [ 
    {
      count?: long(name='Count', description='The number of DNS requests.', example='15292887'),
      domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
      timestamp?: long(name='Timestamp', description='The statistical timestamp. Unit: milliseconds. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1556640000000'),
    }
  ](name='Statistic')
  }(name='Statistics', description='The statistics on the Domain Name System (DNS) requests.'),
}

model DescribeDomainStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainStatisticsResponseBody(name='body'),
}

/**
  * @description Real-time data is collected per hour.
  * @param request  the request parameters of DescribeDomainStatistics  DescribeDomainStatisticsRequest
  * @return DescribeDomainStatisticsResponse
 */
async function describeDomainStatistics(request: DescribeDomainStatisticsRequest): DescribeDomainStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainStatistics', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainStatisticsSummaryRequest {
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the **YYYY-MM-DD** format.

The default value is the day when you perform the operation.', example='2019-07-04', position='Query'),
  keyword?: string(name='Keyword', description='The keyword for searches in %KeyWord% mode. The value is not case-sensitive.', example='test', position='Query'),
  lang?: string(name='Lang', description='The language type.', example='en', position='Query'),
  pageNumber?: long(name='PageNumber', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: **1 to 100**. Default value: **20**.', example='20', minimum=1, maximum=100, position='Query'),
  searchMode?: string(name='SearchMode', description='The search mode of the keyword. Valid values:

*   **LIKE**: fuzzy match (default).
*   **EXACT**: exact match.', example='LIKE', position='Query'),
  startDate: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the **YYYY-MM-DD** format.

You can only query DNS records of the last 90 days.

This parameter is required.', example='2019-07-04', position='Query'),
  threshold?: long(name='Threshold', description='The threshold of query volume that can be obtained. You can also obtain data about a domain name with the query volume less than or equal to the threshold. For example, if you set this parameter to 100, you can query domain names with less than 100 queries.', example='12', minimum=0, position='Query'),
}

model DescribeDomainStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='5'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CC625C21-8832-4683-BF10-C3CFB1A4FA13'),
  statistics?: {
    statistic?: [ 
    {
      count?: long(name='Count', description='The number of DNS requests.', example='35509014'),
      domainName?: string(name='DomainName', description='The domain name.', example='ali-gslb.com'),
      domainType?: string(name='DomainType', description='The type of the domain name. The parameter value is not case-sensitive. Valid values:

PUBLIC (default): hosted public domain name

CACHE: cache-accelerated domain name', example='PUBLIC'),
      resolveAnalysisStatus?: string(name='resolveAnalysisStatus', description='Indicates whether the DNS traffic analysis feature is enabled for the domain name. Valid values:

*   OPEN
*   CLOSE', example='OPEN'),
    }
  ](name='Statistic')
  }(name='Statistics', description='The statistics on the Domain Name System (DNS) requests.'),
  totalItems?: int32(name='TotalItems', description='The total number of data records.', example='68'),
  totalPages?: int32(name='TotalPages', description='The total number of returned pages.', example='14'),
}

model DescribeDomainStatisticsSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainStatisticsSummaryResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDomainStatisticsSummary  DescribeDomainStatisticsSummaryRequest
  * @return DescribeDomainStatisticsSummaryResponse
 */
async function describeDomainStatisticsSummary(request: DescribeDomainStatisticsSummaryRequest): DescribeDomainStatisticsSummaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainStatisticsSummary', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainsRequest {
  groupId?: string(name='GroupId', description='The ID of the domain name group. If you do not specify this parameter, all domain names are queried by default.', example='2223', position='Query'),
  keyWord?: string(name='KeyWord', description='The keyword for searches in "%KeyWord%" mode. The value is not case-sensitive.', example='com', position='Query'),
  lang?: string(name='Lang', description='The language type.', example='en', position='Query'),
  pageNumber?: long(name='PageNumber', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page. Maximum value: **100**. Default value: **20**.', example='20', minimum=1, maximum=100, position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-resourcegroupid01', position='Query'),
  searchMode?: string(name='SearchMode', description='The search mode. Valid values:

*   **LIKE**: fuzzy match.
*   **EXACT**: exact match.', example='LIKE', position='Query'),
  starmark?: boolean(name='Starmark', description='Specifies whether to query the starmark of the domain name.', example='true', position='Query'),
}

model DescribeDomainsResponseBody = {
  domains?: {
    domain?: [ 
    {
      aliDomain?: boolean(name='AliDomain', description='Indicates whether the domain name was registered with Alibaba Cloud.', example='true'),
      createTime?: string(name='CreateTime', description='The time when the domain name was added. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2019-01-30T05:25Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The time when the domain name was added. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1660546144000'),
      dnsServers?: {
        dnsServer?: [ string ](name='DnsServer')
      }(name='DnsServers', description='The names of the DNS servers configured for the domain name assigned by Alibaba Cloud DNS.'),
      domainId?: string(name='DomainId', description='The ID of the domain name.', example='00efd71a-770e-4255-b54e-6fe5659baffe'),
      domainLoggingSwitchStatus?: string(name='DomainLoggingSwitchStatus', description='Indicates whether the DNS traffic analysis feature is enabled for the domain name. Valid values:

*   OPEN
*   CLOSE', example='OPEN'),
      domainName?: string(name='DomainName', description='The domain name.', example='abc.com'),
      groupId?: string(name='GroupId', description='The ID of the domain name group.', example='2223'),
      groupName?: string(name='GroupName', description='The name of the domain name group.', example='mygroup'),
      instanceEndTime?: string(name='InstanceEndTime', description='The time when the Alibaba Cloud DNS instance expires. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2020-03-14T16:00Z'),
      instanceExpired?: boolean(name='InstanceExpired', description='Indicates whether the Alibaba Cloud DNS instance expires.', example='false'),
      instanceId?: string(name='InstanceId', description='The ID of the Alibaba Cloud DNS instance.', example='i-7bg'),
      punyCode?: string(name='PunyCode', description='The Punycode for the domain name. This parameter is returned only for Chinese domain names.', example='abc.com'),
      recordCount?: long(name='RecordCount', description='The number of Domain Name System (DNS) records added for the domain name.', example='100'),
      registrantEmail?: string(name='RegistrantEmail', description='The email address of the registrant.', example='test@example.com'),
      remark?: string(name='Remark', description='The description of the domain name.', example='remark'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the domain name belongs.', example='rg-acf'),
      starmark?: boolean(name='Starmark', description='Indicates whether the domain name was added to favorites.', example='true'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key', description='The key of tag N added to the resource.'),
          value?: string(name='Value', description='The value of tag N added to the resource.'),
        }
      ](name='Tag')
      }(name='Tags', description='The tags added to the resource.'),
      versionCode?: string(name='VersionCode', description='The edition code of Alibaba Cloud DNS.', example='version_enterprise_basic'),
      versionName?: string(name='VersionName', description='The edition of Alibaba Cloud DNS.'),
    }
  ](name='Domain')
  }(name='Domains', description='The domain names.'),
  pageNumber?: long(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries returned per page.', example='2'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='68386699-8B9E-4D5B-BC4C-75A28F6C2A00'),
  totalCount?: long(name='TotalCount', description='The total number of domain names.', example='2'),
}

model DescribeDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainsResponseBody(name='body'),
}

/**
  * @description *   You can specify the PageNumber and PageSize parameters to query domain names.
  * *   You can specify the KeyWord parameter to query domain names that contain the specified keyword.
  * *   By default, the domain names in a list are sorted in descending order of the time they were added.
  * *   You can specify the GroupId parameter. If you do not specify this parameter, all domain names are queried by default.
  * @param request  the request parameters of DescribeDomains  DescribeDomainsRequest
  * @return DescribeDomainsResponse
 */
async function describeDomains(request: DescribeDomainsRequest): DescribeDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomains', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmAccessStrategiesRequest {
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance whose access policies you want to query.', example='instance1', position='Query'),
  lang?: string(name='Lang', description='The language used by the user.', example='en', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return per page.', example='20', position='Query'),
}

model DescribeGtmAccessStrategiesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The number of the page returned.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0CCC9971-CEC9-4132-824B-4AE611C07623'),
  strategies?: {
    strategy?: [ 
    {
      accessMode?: string(name='AccessMode', description='The access policy. Valid values:

*   **AUTO**: Automatic switch
*   **DEFAULT**: Default address pool
*   **FAILOVER**: Failover address pool', example='DEFAULT'),
      accessStatus?: string(name='AccessStatus', description='The access status. Valid values:

*   **DEFAULT**: The default address pool is currently accessed.
*   **FAILOVER**: The failover address pool is currently accessed.', example='DEFAULT'),
      createTime?: string(name='CreateTime', description='The time when the access policy was created.', example='2018-08-09T00:10Z'),
      createTimestamp?: long(name='CreateTimestamp', example='1533773400000'),
      defaultAddrPoolId?: string(name='DefaultAddrPoolId', description='The ID of the default address pool.', example='hra0i1'),
      defaultAddrPoolMonitorStatus?: string(name='DefaultAddrPoolMonitorStatus', description='Indicates whether health check was enabled for the default address pool. Valid values:

*   **OPEN**: Enabled
*   **CLOSE**: Disabled
*   **UNCONFIGURED**: Not configured', example='OPEN'),
      defaultAddrPoolName?: string(name='DefaultAddrPoolName', description='The name of the default address pool.'),
      defaultAddrPoolStatus?: string(name='DefaultAddrPoolStatus', description='The availability status of the default address pool. Valid values:

*   **AVAILABLE**: Available
*   **NOT_AVAILABLE**: Unavailable', example='AVAILABLE'),
      failoverAddrPoolId?: string(name='FailoverAddrPoolId', description='The ID of the failover address pool.', example='hra0i2'),
      failoverAddrPoolMonitorStatus?: string(name='FailoverAddrPoolMonitorStatus', description='Indicates whether health check was enabled for the failover address pool.', example='OPEN'),
      failoverAddrPoolName?: string(name='FailoverAddrPoolName', description='The name of the failover address pool.'),
      failoverAddrPoolStatus?: string(name='FailoverAddrPoolStatus', description='The availability status of the failover address pool.', example='AVAILABLE'),
      instanceId?: string(name='InstanceId', description='The ID of the GTM instance whose access policies you want to query.', example='instance1'),
      lines?: {
        line?: [ 
        {
          groupCode?: string(name='GroupCode', description='The code of the access region group.', example='DEFAULT'),
          groupName?: string(name='GroupName', description='The name of the access region group.'),
          lineCode?: string(name='LineCode', description='The code for the line of the access region.', example='default'),
          lineName?: string(name='LineName', description='The name for the line of the access region.'),
        }
      ](name='Line')
      }(name='Lines', description='The returned lines of access regions.'),
      strategyId?: string(name='StrategyId', description='The ID of the access policy.', example='hra0hs'),
      strategyMode?: string(name='StrategyMode', description='The mode of the access policy. **SELF_DEFINED** indicates that the access policy is user-defined.', example='SELF_DEFINED'),
      strategyName?: string(name='StrategyName', description='The name of the access policy.'),
    }
  ](name='Strategy')
  }(name='Strategies', description='The returned list of access policies of the GTM instance.'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned on all pages.', example='1'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeGtmAccessStrategiesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmAccessStrategiesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeGtmAccessStrategies  DescribeGtmAccessStrategiesRequest
  * @return DescribeGtmAccessStrategiesResponse
 */
async function describeGtmAccessStrategies(request: DescribeGtmAccessStrategiesRequest): DescribeGtmAccessStrategiesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmAccessStrategies', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmAccessStrategyRequest {
  lang?: string(name='Lang', description='The language used by the user.', example='en', position='Query'),
  strategyId: string(name='StrategyId', description='The ID of the access policy that you want to query.

This parameter is required.', example='hra0hs', position='Query'),
}

model DescribeGtmAccessStrategyResponseBody = {
  accessMode?: string(name='AccessMode', description='The access policy.', example='AUTO'),
  accessStatus?: string(name='AccessStatus', description='The access status. Valid values:

*   **DEFAULT**: Indicates normal when the default address pool is accessed.
*   **FAILOVER**: Indicates an exception when a failover address pool is accessed.', example='DEFAULT'),
  defaultAddrPoolMonitorStatus?: string(name='DefaultAddrPoolMonitorStatus', description='Indicates whether health check is enabled for the default address pool.', example='OPEN'),
  defaultAddrPoolName?: string(name='DefaultAddrPoolName', description='The name of the default address pool.'),
  defaultAddrPoolStatus?: string(name='DefaultAddrPoolStatus', description='The availability status of the default address pool.', example='AVAILABLE'),
  defultAddrPoolId?: string(name='DefultAddrPoolId', description='The ID of the default address pool.', example='hra0i1'),
  failoverAddrPoolId?: string(name='FailoverAddrPoolId', description='The ID of the failover address pool.', example='hra0i2'),
  failoverAddrPoolMonitorStatus?: string(name='FailoverAddrPoolMonitorStatus', description='Indicates whether health check is enabled for the failover address pool.', example='OPEN'),
  failoverAddrPoolName?: string(name='FailoverAddrPoolName', description='The name of the failover address pool.'),
  failoverAddrPoolStatus?: string(name='FailoverAddrPoolStatus', description='The availability status of the failover address pool.', example='AVAILABLE'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance whose access policy details you want to query.', example='instance1'),
  lines?: {
    line?: [ 
    {
      groupCode?: string(name='GroupCode', description='The code of the access region group.', example='DEFAULT'),
      groupName?: string(name='GroupName', description='The name of the access region group.', example='Global'),
      lineCode?: string(name='LineCode', description='The code for the line of the access region.', example='default'),
      lineName?: string(name='LineName', description='The name for the line of the access region.', example='Global'),
    }
  ](name='Line')
  }(name='Lines', description='The returned lines of access regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BA1608CA-834C-4E63-8682-8AF0B11ED72D'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy queried.', example='hra0hs'),
  strategyMode?: string(name='StrategyMode', description='The mode of traffic scheduling.', example='SELF_DEFINED'),
  strategyName?: string(name='StrategyName', description='The name of the access policy queried.'),
}

model DescribeGtmAccessStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmAccessStrategyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeGtmAccessStrategy  DescribeGtmAccessStrategyRequest
  * @return DescribeGtmAccessStrategyResponse
 */
async function describeGtmAccessStrategy(request: DescribeGtmAccessStrategyRequest): DescribeGtmAccessStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmAccessStrategy', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmAccessStrategyAvailableConfigRequest {
  instanceId: string(name='InstanceId', description='The ID of the Global Traffic Manager (GTM) instance.

This parameter is required.', example='gtm-cn-xxxx', position='Query'),
  lang?: string(name='Lang', description='The language.', example='en', position='Query'),
}

model DescribeGtmAccessStrategyAvailableConfigResponseBody = {
  addrPools?: {
    addrPool?: [ 
    {
      addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.', example='hra0ix'),
      addrPoolName?: string(name='AddrPoolName', description='The name of the address pool.', example='test'),
    }
  ](name='AddrPool')
  }(name='AddrPools', description='The address pools.'),
  lines?: {
    line?: [ 
    {
      fatherCode?: string(name='FatherCode', description='The code of the parent line. No value is returned if no parent line exists.', example='telecom'),
      groupCode?: string(name='GroupCode', description='The group number of the DNS request source.', example='ISP'),
      groupName?: string(name='GroupName', description='The group name of the DNS request source.', example='Mainland China'),
      lineCode?: string(name='LineCode', description='The code of the DNS request source.', example='cn_telecom_hubei'),
      lineName?: string(name='LineName', description='The name of the DNS request source.', example='South China'),
      status?: string(name='Status', description='The state of the line. Valid values:

*   **FORBIDDEN**: The line is unavailable.
*   **OPTIONAL**: The line is available.', example='FORBIDDEN'),
    }
  ](name='Line')
  }(name='Lines', description='The Domain Name System (DNS) request sources.'),
  requestId?: string(name='RequestId', description='The request ID.', example='C2851BA9-CE56-49AF-8D12-4FC6A49EE688'),
  suggestSetDefaultLine?: boolean(name='SuggestSetDefaultLine', description='Indicates whether the global line is recommended.', example='True'),
}

model DescribeGtmAccessStrategyAvailableConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmAccessStrategyAvailableConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeGtmAccessStrategyAvailableConfig  DescribeGtmAccessStrategyAvailableConfigRequest
  * @return DescribeGtmAccessStrategyAvailableConfigResponse
 */
async function describeGtmAccessStrategyAvailableConfig(request: DescribeGtmAccessStrategyAvailableConfigRequest): DescribeGtmAccessStrategyAvailableConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmAccessStrategyAvailableConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmAvailableAlertGroupRequest {
  lang?: string(name='Lang', description='The language used by the user.', example='en', position='Query'),
}

model DescribeGtmAvailableAlertGroupResponseBody = {
  availableAlertGroup?: string(name='AvailableAlertGroup', description='The available alert groups of the GTM instance.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
}

model DescribeGtmAvailableAlertGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmAvailableAlertGroupResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeGtmAvailableAlertGroup  DescribeGtmAvailableAlertGroupRequest
  * @return DescribeGtmAvailableAlertGroupResponse
 */
async function describeGtmAvailableAlertGroup(request: DescribeGtmAvailableAlertGroupRequest): DescribeGtmAvailableAlertGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmAvailableAlertGroup', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmInstanceRequest {
  instanceId: string(name='InstanceId', description='The ID of the GTM instance.

This parameter is required.', example='instance1', position='Query'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters.', example='en', position='Query'),
  needDetailAttributes?: boolean(name='NeedDetailAttributes', description='Specifies whether additional information is required. Default value: **false**. If the value is **true**, the AccessStrategyNum and AddressPoolNum parameters are returned.', example='false', position='Query'),
}

model DescribeGtmInstanceResponseBody = {
  accessStrategyNum?: int32(name='AccessStrategyNum', description='The number of access policies of the GTM instance.', example='5'),
  addressPoolNum?: int32(name='AddressPoolNum', description='The number of address pools of the GTM instance.', example='5'),
  alertGroup?: string(name='AlertGroup', description='The alert group of the GTM instance.', example='[\\\\"Daily test - R\\&D group\\\\"]'),
  cname?: string(name='Cname', description='The domain name of the GTM instance to which the service domain name is mapped by using a CNAME record.', example='instance1.14.com'),
  cnameMode?: string(name='CnameMode', description='Indicates whether the CNAME is a custom domain name or is assigned by the system. Valid values:

*   **SYSTEM_ASSIGN**
*   **CUSTOM**', example='SYSTEM_ASSIGN'),
  createTime?: string(name='CreateTime', description='The time when the GTM instance was created.', example='2018-06-06T11:34Z'),
  createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates the time when the GTM instance was created.', example='1528284856000'),
  expireTime?: string(name='ExpireTime', description='The time when the GTM instance expires.', example='2018-06-06T11:34Z'),
  expireTimestamp?: long(name='ExpireTimestamp', description='The timestamp that indicates the time when the GTM instance expires.', example='1528284856000'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance.', example='instance1'),
  instanceName?: string(name='InstanceName', description='The name of the GTM instance.', example='test'),
  lbaStrategy?: string(name='LbaStrategy', description='The load balancing policy. Valid values:

*   **ALL_RR**: round robin
*   **RATIO**: weighted round-robin', example='RATIO'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E41AA251-F9BA-48C6-99B2-2B82B26A573A'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-testgroupid'),
  ttl?: int32(name='Ttl', description='The global time to live (TTL).', example='60'),
  userDomainName?: string(name='UserDomainName', description='The domain name of the application.', example='www.example.com'),
  versionCode?: string(name='VersionCode', description='The version code.', example='biaozhun'),
}

model DescribeGtmInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmInstanceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeGtmInstance  DescribeGtmInstanceRequest
  * @return DescribeGtmInstanceResponse
 */
async function describeGtmInstance(request: DescribeGtmInstanceRequest): DescribeGtmInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmInstance', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmInstanceAddressPoolRequest {
  addrPoolId: string(name='AddrPoolId', description='The ID of the address pool that you want to query.

This parameter is required.', example='1234', position='Query'),
  lang?: string(name='Lang', description='The language used by the user.', example='en', position='Query'),
}

model DescribeGtmInstanceAddressPoolResponseBody = {
  addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool queried.', example='2'),
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.', example='1234abc'),
  addrs?: {
    addr?: [ 
    {
      addrId?: long(name='AddrId', description='The ID of the address.', example='123'),
      alertStatus?: string(name='AlertStatus', description='Indicates whether health check was enabled for the address. Valid values:

*   **OK**: Normal
*   **ALERT**: Alert', example='OK'),
      createTime?: string(name='CreateTime', description='The time when the address pool was created.', example='2017-12-28T13:08Z'),
      createTimestamp?: long(name='CreateTimestamp', example='1527690629357'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address.', example='1'),
      mode?: string(name='Mode', description='The mode of the address. Valid values:

*   **SMART**: Intelligent return
*   **ONLINE**: Always online
*   **OFFLINE**: Always offline', example='SMART'),
      updateTime?: string(name='UpdateTime', description='The last time when the address was updated.', example='2017-12-28T13:08Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='A timestamp that indicates the last time when the address was updated.', example='1527690629357'),
      value?: string(name='Value', description='The address.', example='1.1.1.1'),
    }
  ](name='Addr')
  }(name='Addrs', description='The addresses in the address pool.'),
  createTime?: string(name='CreateTime', description='The time when the address pool was created.', example='2017-12-28T13:08Z'),
  createTimestamp?: long(name='CreateTimestamp', example='1527690629357'),
  minAvailableAddrNum?: int32(name='MinAvailableAddrNum', description='The minimum number of available addresses in the address pool.', example='2'),
  monitorConfigId?: string(name='MonitorConfigId', description='The health check ID of the address pool.', example='100abc'),
  monitorStatus?: string(name='MonitorStatus', description='Indicates whether health check was enabled for the address pool. Valid values:

*   **OPEN**: Enabled
*   **CLOSE**: Disabled
*   **UNCONFIGURED**: Not configured', example='OPEN'),
  name?: string(name='Name', description='The name of the address pool.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  status?: string(name='Status', description='The availability status of the address pool. Valid values:

*   **AVAILABLE**: Available
*   **NOT_AVAILABLE**: Unavailable', example='AVAILABLE'),
  type?: string(name='Type', description='The type of the address pool. Valid values:

*   **IP**: IP address
*   **DOMAIN**: Domain name', example='IP'),
  updateTime?: string(name='UpdateTime', description='The last time when the address pool was updated.', example='2017-12-28T13:08Z'),
  updateTimestamp?: long(name='UpdateTimestamp', description='A timestamp that indicates the last time the address pool was updated.', example='1527690629357'),
}

model DescribeGtmInstanceAddressPoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmInstanceAddressPoolResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeGtmInstanceAddressPool  DescribeGtmInstanceAddressPoolRequest
  * @return DescribeGtmInstanceAddressPoolResponse
 */
async function describeGtmInstanceAddressPool(request: DescribeGtmInstanceAddressPoolRequest): DescribeGtmInstanceAddressPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmInstanceAddressPool', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmInstanceAddressPoolsRequest {
  instanceId: string(name='InstanceId', description='The ID of the GTM instance that you want to query.

This parameter is required.', example='gtmtest', position='Query'),
  lang?: string(name='Lang', description='The language used by the user.', example='en', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return per page. Maximum value: **100**. Default value: **20**.', example='20', minimum=1, maximum=100, position='Query'),
}

model DescribeGtmInstanceAddressPoolsResponseBody = {
  addrPools?: {
    addrPool?: [ 
    {
      addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='2'),
      addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.', example='1234abc'),
      createTime?: string(name='CreateTime', description='The time when this address pool was created.', example='2017-12-28T13:08Z'),
      createTimestamp?: long(name='CreateTimestamp', example='1527690629357'),
      minAvailableAddrNum?: int32(name='MinAvailableAddrNum', description='The minimum number of available addresses in the address pool.', example='2'),
      monitorConfigId?: string(name='MonitorConfigId', description='The health check ID of the address pool.', example='100abc'),
      monitorStatus?: string(name='MonitorStatus', description='Indicates whether health check was enabled for the address pool. Valid values:

*   **OPEN**: Enabled
*   **CLOSE**: Disabled
*   **UNCONFIGURED**: Not configured', example='OPEN'),
      name?: string(name='Name', description='The name of the address pool.'),
      status?: string(name='Status', description='The availability status of the address pool. Valid values:

*   **AVAILABLE**: Available
*   **NOT_AVAILABLE**: Unavailable', example='AVAILABLE'),
      type?: string(name='Type', description='The type of the address pool. Valid values:

*   **IP**: IP address
*   **DOMAIN**: Domain name', example='IP'),
      updateTime?: string(name='UpdateTime', description='The last time when the address pool was updated.', example='2017-12-28T13:08Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='A timestamp that indicates the last time the address pool was updated.', example='1527690629357'),
    }
  ](name='AddrPool')
  }(name='AddrPools', description='The returned list of address pools of the GTM instance.'),
  pageNumber?: int32(name='PageNumber', description='The number of the page returned.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned on all pages.', example='2'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeGtmInstanceAddressPoolsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmInstanceAddressPoolsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeGtmInstanceAddressPools  DescribeGtmInstanceAddressPoolsRequest
  * @return DescribeGtmInstanceAddressPoolsResponse
 */
async function describeGtmInstanceAddressPools(request: DescribeGtmInstanceAddressPoolsRequest): DescribeGtmInstanceAddressPoolsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmInstanceAddressPools', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmInstanceStatusRequest {
  instanceId: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='instance1', position='Query'),
  lang?: string(name='Lang', description='The language.', example='en', position='Query'),
}

model DescribeGtmInstanceStatusResponseBody = {
  addrNotAvailableNum?: int32(name='AddrNotAvailableNum', description='The number of unavailable addresses.', example='10'),
  addrPoolNotAvailableNum?: int32(name='AddrPoolNotAvailableNum', description='The number of unavailable address pools.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='389DFFA3-77A5-4A9E-BF3D-147C6F98A5BA'),
  status?: string(name='Status', description='The state of the instance. Valid values:

*   ALLOW: The operation on the instance is allowed.
*   DENY: The operation on the instance is not allowed.', example='ALLOW'),
  statusReason?: string(name='StatusReason', description='The reasons why the instance is in the current state. Valid values:

*   INSTANCE_OPERATE_BLACK_LIST: The operation on the instance is not allowed.
*   BETA_INSTANCE: The instance is in public preview.', example='["BETA_INSTANCE"]'),
  strategyNotAvailableNum?: int32(name='StrategyNotAvailableNum', description='The number of unavailable access policies.', example='10'),
  switchToFailoverStrategyNum?: int32(name='SwitchToFailoverStrategyNum', description='The number of access policies switched to the secondary address pool.', example='10'),
}

model DescribeGtmInstanceStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmInstanceStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeGtmInstanceStatus  DescribeGtmInstanceStatusRequest
  * @return DescribeGtmInstanceStatusResponse
 */
async function describeGtmInstanceStatus(request: DescribeGtmInstanceStatusRequest): DescribeGtmInstanceStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmInstanceStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmInstanceSystemCnameRequest {
  instanceId: string(name='InstanceId', description='The ID of the Global Traffic Manager (GTM) instance.

This parameter is required.', example='instance1', position='Query'),
  lang?: string(name='Lang', description='The language used by the user.', example='en', position='Query'),
}

model DescribeGtmInstanceSystemCnameResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  systemCname?: string(name='SystemCname', description='The CNAME record assigned by the system.', example='gtm-cn-mp91004xxxx.gtm-a2b4.com'),
}

model DescribeGtmInstanceSystemCnameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmInstanceSystemCnameResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeGtmInstanceSystemCname  DescribeGtmInstanceSystemCnameRequest
  * @return DescribeGtmInstanceSystemCnameResponse
 */
async function describeGtmInstanceSystemCname(request: DescribeGtmInstanceSystemCnameRequest): DescribeGtmInstanceSystemCnameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmInstanceSystemCname', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmInstancesRequest {
  keyword?: string(name='Keyword', description='The keyword that you use for query. Exact match is supported by instance ID or instance name.', example='test', position='Query'),
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.', example='en', position='Query'),
  needDetailAttributes?: boolean(name='NeedDetailAttributes', description='Specifies whether additional information is required. Default value: **false**.', example='false', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number to return.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return per page.', example='20', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-xxxxx', position='Query'),
}

model DescribeGtmInstancesResponseBody = {
  gtmInstances?: {
    gtmInstance?: [ 
    {
      accessStrategyNum?: int32(name='AccessStrategyNum', description='The number of access policies.', example='5'),
      addressPoolNum?: int32(name='AddressPoolNum', description='The number of address pools.', example='5'),
      alertGroup?: string(name='AlertGroup', description='The name of the alert group.', example='[\\\\"R\\&D group\\\\"]'),
      cname?: string(name='Cname', description='The CNAME domain name that is used to access the instance.', example='instance1.14.com'),
      cnameMode?: string(name='CnameMode', description='The CNAME domain name used to access the instance. Valid values:

*   **SYSTEM_ASSIGN**: A CNAME domain name assigned by the system is used.
*   **CUSTOM**: A custom CNAME domain name is used.', example='SYSTEM_ASSIGN'),
      createTime?: string(name='CreateTime', description='The time when the instance was created.', example='2018-06-06T11:34Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The UNIX timestamp that indicates when the instance was created.', example='1528284856000'),
      expireTime?: string(name='ExpireTime', description='The time when the instance expires.', example='2018-06-06T11:34Z'),
      expireTimestamp?: long(name='ExpireTimestamp', description='The UNIX timestamp that indicates when the instance expires.', example='1528284856000'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='instance1'),
      instanceName?: string(name='InstanceName', description='The name of the instance.', example='test'),
      lbaStrategy?: string(name='LbaStrategy', description='The load balancing policy that is used. Valid values:

*   **ALL_RR**: Load balancing
*   **RATIO**: Weighted round-robin', example='RATIO'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs.', example='rg-acfm2q2jqpjh***'),
      ttl?: int32(name='Ttl', description='The global time to live (TTL).', example='60'),
      userDomainName?: string(name='UserDomainName', description='The domain name of the user.', example='www.example.com'),
      versionCode?: string(name='VersionCode', description='The version code of the instance.', example='biaozhun'),
    }
  ](name='GtmInstance')
  }(name='GtmInstances', description='The list of queried instances.'),
  pageNumber?: int32(name='PageNumber', description='The returned page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='193B0163-7F93-42DF-AB05-ACEEB7D22707'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned.', example='1'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeGtmInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmInstancesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeGtmInstances  DescribeGtmInstancesRequest
  * @return DescribeGtmInstancesResponse
 */
async function describeGtmInstances(request: DescribeGtmInstancesRequest): DescribeGtmInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmLogsRequest {
  endTimestamp?: long(name='EndTimestamp', description='The timestamp that specifies the end of the time range to query.', example='1363453350000', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance whose logs you want to query.', example='gtm-cn-xxxxx', position='Query'),
  keyword?: string(name='Keyword', description='The keyword for searching logs, in case-insensitive "%Keyword%" format.', example='test', position='Query'),
  lang?: string(name='Lang', description='The language used by the user.', example='en', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: **100**. Default value: **20**.', example='20', minimum=1, maximum=100, position='Query'),
  startTimestamp?: long(name='StartTimestamp', description='The beginning of the time range to query.', example='1363453340000', position='Query'),
}

model DescribeGtmLogsResponseBody = {
  logs?: {
    log?: [ 
    {
      content?: string(name='Content', description='The formatted message content.', example='addtest-pool-1'),
      entityId?: string(name='EntityId', description='The ID of the object that was operated on.', example='121212'),
      entityName?: string(name='EntityName', description='The name of the object that was operated on.', example='test-pool-1'),
      entityType?: string(name='EntityType', description='The type of the object that was operated on.', example='POOL'),
      id?: long(name='Id', description='The ID of the log record.', example='6726'),
      operAction?: string(name='OperAction', description='The operation performed.', example='add'),
      operIp?: string(name='OperIp', description='The IP address subject to the operation.', example='106.11.34.X'),
      operTime?: string(name='OperTime', description='The time when the operation was performed.', example='2018-01-24T07:35Z'),
      operTimestamp?: long(name='OperTimestamp', description='A timestamp that indicates the time when the operation was performed.', example='1516779348000'),
    }
  ](name='Log')
  }(name='Logs', description='The list of logs returned.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='50C60A29-2E93-425A-ABA8-068686E28873'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned on all pages.', example='224'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='224'),
}

model DescribeGtmLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmLogsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeGtmLogs  DescribeGtmLogsRequest
  * @return DescribeGtmLogsResponse
 */
async function describeGtmLogs(request: DescribeGtmLogsRequest): DescribeGtmLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmLogs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmMonitorAvailableConfigRequest {
  lang?: string(name='Lang', description='The language of the values of specific response parameters.', example='en', position='Query'),
}

model DescribeGtmMonitorAvailableConfigResponseBody = {
  ispCityNodes?: {
    ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the city where the monitored node is deployed.', example='503'),
      cityName?: string(name='CityName', description='The display name of the city where the monitored node is deployed.', example='Zhangjiakou'),
      defaultSelected?: boolean(name='DefaultSelected', description='Indicates whether the monitored node is selected for the health check by default.', example='true'),
      groupName?: string(name='GroupName', description='The name of the group to which the monitored node belongs.

Valid values: Overseas Nodes, BGP Nodes, and ISP Nodes.', example='Overseas Nodes'),
      groupType?: string(name='GroupType', description='The type of the group to which the monitored node belongs.

Valid values: BGP, OVERSEAS, and ISP.', example='OVERSEAS'),
      ispCode?: string(name='IspCode', description='The code of the Internet service provider (ISP) to which the monitored node belongs.

*   If the value of the GroupType parameter is BGP or OVERSEAS, the value of IspCode is 465 by default.
*   If the value of the GroupType parameter is not BGP or OVERSEAS, valid values of IspCode are 232, 132, and 5. and is used together with CityCode.', example='465'),
      ispName?: string(name='IspName', description='The display name of the ISP to which the monitored node belongs.', example='Alibaba'),
      mainland?: boolean(name='Mainland', description='Indicates whether the monitored node is deployed in the Chinese mainland.', example='true'),
    }
  ](name='IspCityNode')
  }(name='IspCityNodes', description='The monitored nodes.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model DescribeGtmMonitorAvailableConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmMonitorAvailableConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeGtmMonitorAvailableConfig  DescribeGtmMonitorAvailableConfigRequest
  * @return DescribeGtmMonitorAvailableConfigResponse
 */
async function describeGtmMonitorAvailableConfig(request: DescribeGtmMonitorAvailableConfigRequest): DescribeGtmMonitorAvailableConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmMonitorAvailableConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmMonitorConfigRequest {
  lang?: string(name='Lang', description='The language of the values of specific response parameters.', example='en', position='Query'),
  monitorConfigId: string(name='MonitorConfigId', description='The ID of the health check configuration.

This parameter is required.', example='100', position='Query'),
}

model DescribeGtmMonitorConfigResponseBody = {
  createTime?: string(name='CreateTime', description='The time when the health check configuration was created.', example='2017-12-28T13:08Z'),
  createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates the time when the health check configuration was created.', example='1527690629357'),
  evaluationCount?: int32(name='EvaluationCount', description='The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.', example='3'),
  interval?: int32(name='Interval', description='The health check interval. Unit: seconds. The value is 60.', example='60'),
  ispCityNodes?: {
    ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the city where the monitored node is deployed.', example='503'),
      cityName?: string(name='CityName', description='The display name of the city where the monitored node is deployed.', example='Zhangjiakou'),
      countryCode?: string(name='CountryCode', description='The code of the country where the monitored node is deployed.', example='001'),
      countryName?: string(name='CountryName', description='The display name of the country where the monitored node is deployed.', example='China'),
      ispCode?: string(name='IspCode', description='The code of the Internet service provider (ISP) to which the monitored node belongs.', example='465'),
      ispName?: string(name='IspName', description='The display name of the ISP to which the monitored node belongs.', example='Alibaba'),
    }
  ](name='IspCityNode')
  }(name='IspCityNodes', description='The monitored nodes.'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.', example='1234abc'),
  monitorExtendInfo?: string(name='MonitorExtendInfo', description='The extended information, that is, the parameters required for the protocol. Different protocols require different parameters:

HTTP or HTTPS:

*   port: the port to check.
*   failureRate: the failure rate.
*   code: the status code threshold. If the returned status code is greater than the specified threshold, the application service is deemed abnormal. Valid values: 400 and 500.
*   host: the host configuration.
*   path: the health check URL.

PING:

*   packetNum: the number of ping packets.
*   packetLossRate: the loss rate of ping packets.
*   failureRate: the failure rate.

TCP:

*   port: the port to check.
*   failureRate: the failure rate.', example='{\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}'),
  protocolType?: string(name='ProtocolType', description='The protocol used for the health check.', example='HTTP'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  timeout?: int32(name='Timeout', description='The health check timeout period. Unit: milliseconds. Valid values: 2000, 3000, 5000, and 10000.', example='3000'),
  updateTime?: string(name='UpdateTime', description='The time when the health check configuration was last updated.', example='2017-12-28T13:08Z'),
  updateTimestamp?: long(name='UpdateTimestamp', description='The timestamp that indicates the time when the health check configuration was last updated.', example='1527690629357'),
}

model DescribeGtmMonitorConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmMonitorConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeGtmMonitorConfig  DescribeGtmMonitorConfigRequest
  * @return DescribeGtmMonitorConfigResponse
 */
async function describeGtmMonitorConfig(request: DescribeGtmMonitorConfigRequest): DescribeGtmMonitorConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmMonitorConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmRecoveryPlanRequest {
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en.', example='en', position='Query'),
  recoveryPlanId: long(name='RecoveryPlanId', description='The ID of the disaster recovery plan.

This parameter is required.', example='100', position='Query'),
}

model DescribeGtmRecoveryPlanResponseBody = {
  createTime?: string(name='CreateTime', description='The time when the disaster recovery plan was created. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.', example='2019-08-11T05:04Z'),
  createTimestamp?: long(name='CreateTimestamp', description='The time when the disaster recovery plan was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1565499867000'),
  faultAddrPoolNum?: int32(name='FaultAddrPoolNum', description='The number of faulty address pools.', example='2'),
  faultAddrPools?: {
    faultAddrPool?: [ 
    {
      addrPoolId?: string(name='AddrPoolId', description='The address pool ID.', example='hra0oq'),
      addrPoolName?: string(name='AddrPoolName', description='The address pool name.'),
      addrs?: {
        addr?: [ 
        {
          id?: long(name='Id', description='The address ID.', example='739'),
          mode?: string(name='Mode', description='The address mode.', example='OFFLINE'),
          value?: string(name='Value', description='The address.', example='1.1.1.1'),
        }
      ](name='Addr')
      }(name='Addrs'),
      instanceId?: string(name='InstanceId', description='The instance ID.', example='instance-zwy-38'),
    }
  ](name='FaultAddrPool')
  }(name='FaultAddrPools', description='The faulty address pools.'),
  lastExecuteTime?: string(name='LastExecuteTime', description='The time when the disaster recovery plan was last executed. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.', example='2019-08-11T05:04Z'),
  lastExecuteTimestamp?: long(name='LastExecuteTimestamp', description='The time when the disaster recovery plan was last executed. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1565505898000'),
  lastRollbackTime?: string(name='LastRollbackTime', description='The time when the disaster recovery plan was last rolled back. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='2019-08-11T06:45Z'),
  lastRollbackTimestamp?: long(name='LastRollbackTimestamp', description='The time when the disaster recovery plan was last rolled back. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1565505919000'),
  name?: string(name='Name', description='The name of the disaster recovery plan.', example='name-example'),
  recoveryPlanId?: long(name='RecoveryPlanId', description='The ID of the disaster recovery plan.', example='55'),
  remark?: string(name='Remark', description='The description of the disaster recovery plan.', example='remark-example'),
  requestId?: string(name='RequestId', description='The request ID.', example='0A5F4315-D6E8-435E-82DF-24F4C97D6999'),
  status?: string(name='Status', description='The status of the disaster recovery plan.', example='UNEXECUTED'),
  updateTime?: string(name='UpdateTime', description='The time when the disaster recovery plan was last modified. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.', example='2019-08-11T06:45Z'),
  updateTimestamp?: long(name='UpdateTimestamp', description='The time when the disaster recovery plan was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1565499867000'),
}

model DescribeGtmRecoveryPlanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmRecoveryPlanResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeGtmRecoveryPlan  DescribeGtmRecoveryPlanRequest
  * @return DescribeGtmRecoveryPlanResponse
 */
async function describeGtmRecoveryPlan(request: DescribeGtmRecoveryPlanRequest): DescribeGtmRecoveryPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmRecoveryPlan', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmRecoveryPlanAvailableConfigRequest {
  lang?: string(name='Lang', description='The language in which the returned results are displayed. Valid values:

*   zh: Chinese
*   en: English

Default value: en.', example='en', position='Query'),
}

model DescribeGtmRecoveryPlanAvailableConfigResponseBody = {
  instances?: {
    instance?: [ 
    {
      addrPools?: {
        addrPool?: [ 
        {
          addrPoolId?: string(name='AddrPoolId', description='The address pool ID.'),
          name?: string(name='Name', description='The name of the address pool.', example='hra0i9'),
        }
      ](name='AddrPool')
      }(name='AddrPools', description='The address pools.'),
      instanceId?: string(name='InstanceId', description='The instance ID.', example='instance-example'),
      instanceName?: string(name='InstanceName', description='The instance name.', example='instance-name-example'),
    }
  ](name='Instance')
  }(name='Instances', description='The instances.'),
  requestId?: string(name='RequestId', description='The request ID.', example='F8F8EF50-8B7F-4702-B294-97170A423403'),
}

model DescribeGtmRecoveryPlanAvailableConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmRecoveryPlanAvailableConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeGtmRecoveryPlanAvailableConfig  DescribeGtmRecoveryPlanAvailableConfigRequest
  * @return DescribeGtmRecoveryPlanAvailableConfigResponse
 */
async function describeGtmRecoveryPlanAvailableConfig(request: DescribeGtmRecoveryPlanAvailableConfigRequest): DescribeGtmRecoveryPlanAvailableConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmRecoveryPlanAvailableConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmRecoveryPlansRequest {
  keyword?: string(name='Keyword', description='The keyword for the query. Fuzzy match is supported by disaster recovery plan name.', example='test', position='Query'),
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.', example='en', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number to return. The page number starts from **1**. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return per page. Maximum value: **100**. Default value: **20**.', example='20', position='Query'),
}

model DescribeGtmRecoveryPlansResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  recoveryPlans?: {
    recoveryPlan?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the disaster recovery plan was created.', example='2019-08-11T06:45Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The UNIX timestamp that indicates when the disaster recovery plan was created.', example='1565499867000'),
      faultAddrPoolNum?: int32(name='FaultAddrPoolNum', description='The number of faulty address pools.', example='0'),
      lastExecuteTime?: string(name='LastExecuteTime', description='The last time when the disaster recovery plan was executed.', example='2019-08-11T06:44Z'),
      lastExecuteTimestamp?: long(name='LastExecuteTimestamp', description='The UNIX timestamp that indicates the last time when the disaster recovery plan was executed.', example='1565505898000'),
      lastRollbackTime?: string(name='LastRollbackTime', description='The last time when the disaster recovery plan was rolled back.', example='2019-08-11T06:45Z'),
      lastRollbackTimestamp?: long(name='LastRollbackTimestamp', description='The UNIX timestamp that indicates the last time when the disaster recovery plan was rolled back.', example='1565505919000'),
      name?: string(name='Name', description='The name of the disaster recovery plan.', example='name-example'),
      recoveryPlanId?: long(name='RecoveryPlanId', description='The ID of the disaster recovery plan.', example='55'),
      remark?: string(name='Remark', description='The remarks about the disaster recovery plan.', example='remark-example'),
      status?: string(name='Status', description='The status of the disaster recovery plan. Valid values:

*   **UNEXECUTED**: The plan is not executed.
*   **EXECUTED**: The plan is executed.
*   **ROLLED_BACK**: The plan is rolled back.', example='UNEXECUTED'),
      updateTime?: string(name='UpdateTime', description='The last time when the disaster recovery plan was updated.', example='2019-08-11T06:45Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The UNIX timestamp that indicates the last time when the disaster recovery plan was updated.', example='1565505919000'),
    }
  ](name='RecoveryPlan')
  }(name='RecoveryPlans', description='The details about the queried disaster recovery plans.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2BA072CF-CA21-4A34-B6C2-227BE2C58079'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned.', example='10'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeGtmRecoveryPlansResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmRecoveryPlansResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeGtmRecoveryPlans  DescribeGtmRecoveryPlansRequest
  * @return DescribeGtmRecoveryPlansResponse
 */
async function describeGtmRecoveryPlans(request: DescribeGtmRecoveryPlansRequest): DescribeGtmRecoveryPlansResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmRecoveryPlans', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceDomainsRequest {
  instanceId: string(name='InstanceId', description='The ID of the Alibaba Cloud Domain Name System (DNS) instance. You can call the [DescribeDomainInfo](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomaininfo?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.

This parameter is required.', example='weriwieru', position='Query'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: English.', example='en', position='Query'),
  pageNumber?: long(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: 1 to 100. Default value: 20.', example='2', position='Query'),
}

model DescribeInstanceDomainsResponseBody = {
  instanceDomains?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the instance was created. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2020-03-09T02:15Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The time when the instance was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1583720154000'),
      domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
    }
  ](name='InstanceDomains', description='The domain names that are bound to the DNS instance.'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: **1 to 100**. Default value: **20**.', example='2'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='68386699-8B9E-4D5B-BC4C-75A28F6C2A00'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned on all pages.', example='2'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='2'),
}

model DescribeInstanceDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInstanceDomainsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeInstanceDomains  DescribeInstanceDomainsRequest
  * @return DescribeInstanceDomainsResponse
 */
async function describeInstanceDomains(request: DescribeInstanceDomainsRequest): DescribeInstanceDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceDomains', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInternetDnsLogsRequest {
  accountId?: long(name='AccountId', description='The account ID displayed on the Recursive Resolution (Public DNS) page after you activate Alibaba Cloud Public DNS.', example='51**4', position='Query'),
  domainName?: string(name='DomainName', description='The domain name.', example='example.com', position='Query'),
  endTimestamp?: long(name='EndTimestamp', description='The end time of the query (timestamp, unit: milliseconds). >Warning: If the query time span is too large and the amount of resolution logs for the queried domain is excessive, it may lead to a query timeout or inaccurate query results.', example='1709196299999', position='Query'),
  lang?: string(name='Lang', description='Return value language, options: 
- zh: Chinese 
- en: English

Default: en', example='en', position='Query'),
  module?: string(name='Module', description='Module type 
- AUTHORITY (default): Public Authoritative DNS 
- RECURSION: Public Recursive DNS', example='AUTHORITY', position='Query'),
  pageNumber?: int32(name='PageNumber', description='Page number, default value is 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='Page size for query.', example='10', position='Query'),
  queryCondition?: string(name='QueryCondition', description='Query parameters 
- sourceIp: Source IP address 
- queryNameFuzzy: Domain name (fuzzy value) 
- queryType: Record type 
- value: Resolution result 
- status: Status 
- serverIp: Resolution server IP', example='{"sourceIp":"59.82.XX.XX","queryType":"A"}', position='Query'),
  startTimestamp?: long(name='StartTimestamp', description='The start time of the query (timestamp, unit: milliseconds).', example='1709192640000', position='Query'),
}

model DescribeInternetDnsLogsResponseBody = {
  complete?: boolean(name='Complete', description='Indicates whether the log query is precise.', example='true'),
  curPage?: int32(name='CurPage', description='Current page number.', example='1'),
  logs?: {
    log?: [ 
    {
      dnsMsgId?: string(name='DnsMsgId', description='Parse log ID (can be duplicated).', example='3583'),
      logTime?: long(name='LogTime', description='Parse timestamp.', example='1709196249000'),
      protocol?: string(name='Protocol', description='The protocol type of the domain name resolution query request:
- UDP
- TCP
- HTTP
- HTTPS
- DOH', example='UDP'),
      queryName?: string(name='QueryName', description='The domain name for which you want to query Domain Name System (DNS) records.', example='example.com'),
      queryType?: string(name='QueryType', description='Record type.', example='A'),
      rt?: int32(name='Rt', description='Parse response time.', example='0'),
      serverIp?: string(name='ServerIp', description='Parse server IP.', example='140.205.XX.XX'),
      sourceIp?: string(name='SourceIp', description='Source IP address.', example='59.82.XX.XX'),
      status?: string(name='Status', description='Response status.', example='NOERROR'),
      subnetIp?: string(name='SubnetIp', description='The value set for the edns-client-subnet option.', example='170.33.XX.XX'),
      value?: {
        value?: [ string ](name='Value')
      }(name='Value', description='Array of parsing results.'),
      zoneName?: string(name='ZoneName', description='The zone name.', example='example.com'),
    }
  ](name='Log')
  }(name='Logs', description='The queried logs.'),
  pageSize?: int32(name='PageSize', description='Page size for query.', example='10'),
  requestId?: string(name='RequestId', description='Unique request identifier.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalPage?: int32(name='TotalPage', description='Total number of pages.', example='5'),
  totalSize?: int32(name='TotalSize', description='Total quantity.', example='48'),
}

model DescribeInternetDnsLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInternetDnsLogsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeInternetDnsLogs  DescribeInternetDnsLogsRequest
  * @return DescribeInternetDnsLogsResponse
 */
async function describeInternetDnsLogs(request: DescribeInternetDnsLogsRequest): DescribeInternetDnsLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInternetDnsLogs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeIspFlushCacheInstancesRequest {
  direction?: string(name='Direction', position='Query'),
  isp?: string(name='Isp', position='Query'),
  keyword?: string(name='Keyword', position='Query'),
  lang?: string(name='Lang', position='Query'),
  orderBy?: string(name='OrderBy', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=9999999, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  type?: string(name='Type', position='Query'),
}

model DescribeIspFlushCacheInstancesResponseBody = {
  ispFlushCacheInstances?: [ 
    {
      expireTime?: string(name='ExpireTime'),
      expireTimestamp?: long(name='ExpireTimestamp'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      isp?: string(name='Isp'),
      quotaInfo?: {
        instanceQuota?: int32(name='InstanceQuota'),
        instanceQuotaUsed?: int32(name='InstanceQuotaUsed'),
      }(name='QuotaInfo'),
      status?: string(name='Status'),
      versionCode?: string(name='VersionCode'),
    }
  ](name='IspFlushCacheInstances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeIspFlushCacheInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeIspFlushCacheInstancesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeIspFlushCacheInstances  DescribeIspFlushCacheInstancesRequest
  * @return DescribeIspFlushCacheInstancesResponse
 */
async function describeIspFlushCacheInstances(request: DescribeIspFlushCacheInstancesRequest): DescribeIspFlushCacheInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeIspFlushCacheInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeIspFlushCacheRemainQuotaRequest {
  lang?: string(name='Lang', position='Query'),
}

model DescribeIspFlushCacheRemainQuotaResponseBody = {
  requestId?: string(name='RequestId'),
  telecomRemainQuota?: int32(name='TelecomRemainQuota'),
}

model DescribeIspFlushCacheRemainQuotaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeIspFlushCacheRemainQuotaResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeIspFlushCacheRemainQuota  DescribeIspFlushCacheRemainQuotaRequest
  * @return DescribeIspFlushCacheRemainQuotaResponse
 */
async function describeIspFlushCacheRemainQuota(request: DescribeIspFlushCacheRemainQuotaRequest): DescribeIspFlushCacheRemainQuotaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeIspFlushCacheRemainQuota', 'POST', '/', 'json', false, 'json', request);
}

model DescribeIspFlushCacheTaskRequest {
  lang?: string(name='Lang', position='Query'),
  taskId: string(name='TaskId', description='This parameter is required.', position='Query'),
}

model DescribeIspFlushCacheTaskResponseBody = {
  createTime?: string(name='CreateTime'),
  createTimestamp?: long(name='CreateTimestamp'),
  domainName?: string(name='DomainName'),
  flushCacheResults?: [ 
    {
      dnsNodes?: [ 
        {
          answers?: [ 
            {
              name?: string(name='Name'),
              record?: string(name='Record'),
              ttl?: long(name='Ttl'),
              type?: string(name='Type'),
            }
          ](name='Answers'),
          nodeIp?: string(name='NodeIp'),
          spName?: string(name='SpName'),
          status?: string(name='Status'),
        }
      ](name='DnsNodes'),
      province?: string(name='Province'),
    }
  ](name='FlushCacheResults'),
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  isp?: string(name='Isp'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
  taskStatus?: string(name='TaskStatus'),
}

model DescribeIspFlushCacheTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeIspFlushCacheTaskResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeIspFlushCacheTask  DescribeIspFlushCacheTaskRequest
  * @return DescribeIspFlushCacheTaskResponse
 */
async function describeIspFlushCacheTask(request: DescribeIspFlushCacheTaskRequest): DescribeIspFlushCacheTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeIspFlushCacheTask', 'POST', '/', 'json', false, 'json', request);
}

model DescribeIspFlushCacheTasksRequest {
  direction?: string(name='Direction', position='Query'),
  domainName?: string(name='DomainName', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  isp?: string(name='Isp', position='Query'),
  lang?: string(name='Lang', position='Query'),
  orderBy?: string(name='OrderBy', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=9999999, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
}

model DescribeIspFlushCacheTasksResponseBody = {
  ispFlushCacheTasks?: [ 
    {
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      domainName?: string(name='DomainName'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      isp?: string(name='Isp'),
      taskId?: string(name='TaskId'),
      taskStatus?: string(name='TaskStatus'),
    }
  ](name='IspFlushCacheTasks'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeIspFlushCacheTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeIspFlushCacheTasksResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeIspFlushCacheTasks  DescribeIspFlushCacheTasksRequest
  * @return DescribeIspFlushCacheTasksResponse
 */
async function describeIspFlushCacheTasks(request: DescribeIspFlushCacheTasksRequest): DescribeIspFlushCacheTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeIspFlushCacheTasks', 'POST', '/', 'json', false, 'json', request);
}

model DescribePdnsAccountSummaryRequest {
  endDate?: string(name='EndDate', position='Query'),
  lang?: string(name='Lang', position='Query'),
  startDate?: string(name='StartDate', position='Query'),
}

model DescribePdnsAccountSummaryResponseBody = {
  data?: {
    domainCount?: long(name='DomainCount'),
    httpCount?: long(name='HttpCount'),
    httpsCount?: long(name='HttpsCount'),
    subDomainCount?: long(name='SubDomainCount'),
    threatCount?: long(name='ThreatCount'),
    totalCount?: long(name='TotalCount'),
    userId?: long(name='UserId'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribePdnsAccountSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePdnsAccountSummaryResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribePdnsAccountSummary  DescribePdnsAccountSummaryRequest
  * @return DescribePdnsAccountSummaryResponse
 */
async function describePdnsAccountSummary(request: DescribePdnsAccountSummaryRequest): DescribePdnsAccountSummaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePdnsAccountSummary', 'POST', '/', 'json', false, 'json', request);
}

model DescribePdnsAppKeyRequest {
  appKeyId?: string(name='AppKeyId', position='Query'),
  authCode?: string(name='AuthCode', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model DescribePdnsAppKeyResponseBody = {
  appKey?: {
    appKeyId?: string(name='AppKeyId'),
    appKeySecret?: string(name='AppKeySecret'),
    createDate?: string(name='CreateDate'),
    createTimestamp?: long(name='CreateTimestamp'),
    remark?: string(name='Remark'),
    state?: string(name='State'),
  }(name='AppKey'),
  requestId?: string(name='RequestId'),
}

model DescribePdnsAppKeyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePdnsAppKeyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribePdnsAppKey  DescribePdnsAppKeyRequest
  * @return DescribePdnsAppKeyResponse
 */
async function describePdnsAppKey(request: DescribePdnsAppKeyRequest): DescribePdnsAppKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePdnsAppKey', 'POST', '/', 'json', false, 'json', request);
}

model DescribePdnsAppKeysRequest {
  lang?: string(name='Lang', position='Query'),
}

model DescribePdnsAppKeysResponseBody = {
  appKeys?: [ 
    {
      appKeyId?: string(name='AppKeyId'),
      createDate?: string(name='CreateDate'),
      createTimestamp?: long(name='CreateTimestamp'),
      remark?: string(name='Remark'),
      state?: string(name='State'),
    }
  ](name='AppKeys'),
  requestId?: string(name='RequestId'),
}

model DescribePdnsAppKeysResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePdnsAppKeysResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribePdnsAppKeys  DescribePdnsAppKeysRequest
  * @return DescribePdnsAppKeysResponse
 */
async function describePdnsAppKeys(request: DescribePdnsAppKeysRequest): DescribePdnsAppKeysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePdnsAppKeys', 'POST', '/', 'json', false, 'json', request);
}

model DescribePdnsOperateLogsRequest {
  actionType?: string(name='ActionType', position='Query'),
  endDate?: string(name='EndDate', position='Query'),
  keyword?: string(name='Keyword', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  startDate?: string(name='StartDate', position='Query'),
}

model DescribePdnsOperateLogsResponseBody = {
  logs?: [ 
    {
      action?: string(name='Action'),
      operateTime?: string(name='OperateTime'),
      type?: string(name='Type'),
      content?: string(name='content'),
    }
  ](name='Logs'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePdnsOperateLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePdnsOperateLogsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribePdnsOperateLogs  DescribePdnsOperateLogsRequest
  * @return DescribePdnsOperateLogsResponse
 */
async function describePdnsOperateLogs(request: DescribePdnsOperateLogsRequest): DescribePdnsOperateLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePdnsOperateLogs', 'POST', '/', 'json', false, 'json', request);
}

model DescribePdnsRequestStatisticRequest {
  domainName?: string(name='DomainName', description='The primary domain name whose statistics you want to query.', example='example.com', position='Query'),
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the **YYYY-MM-DD** format.

The default value is the day when you query the data.', example='2024-7-1 00:00:00', position='Query'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh', position='Query'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the **YYYY-MM-DD** format.

You can query only records of the last 90 days.', example='2024-06-14 00:00:00', position='Query'),
  subDomain?: string(name='SubDomain', description='The subdomain name whose statistics you want to query.', example='www.example.com', position='Query'),
  type?: string(name='Type', description='The type of the request statistics that you want to query. Valid values:

*   **ACCOUNT**: queries the request statistics by account.
*   **DOMAIN**: queries the request statistics by domain name.
*   **SUB_DOMAIN**: queries the request statistics by subdomain name.', example='ACCOUNT', position='Query'),
}

model DescribePdnsRequestStatisticResponseBody = {
  data?: [ 
    {
      dohTotalCount?: long(name='DohTotalCount', description='The total number of DoH requests, including HTTP and HTTPS requests.', example='0'),
      httpCount?: long(name='HttpCount', description='The number of HTTP requests.', example='0'),
      httpsCount?: long(name='HttpsCount', description='The number of HTTPS requests. On the Traffic Analysis tab of the Public DNS console, the value of this parameter includes the number of DNS over HTTPs (DoH) requests. Therefore, the number of DoH requests is not separately displayed in the console.', example='0'),
      ipCount?: long(name='IpCount', description='The number of source IP addresses.', example='10'),
      timestamp?: long(name='Timestamp', description='The statistical timestamp. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1706716800000'),
      totalCount?: long(name='TotalCount', description='The total number of requests.', example='0'),
      udpTotalCount?: long(name='UdpTotalCount', description='The total number of UDP requests.', example='5000'),
      v4Count?: long(name='V4Count', description='The number of IPv4-based requests.', example='0'),
      v4HttpCount?: long(name='V4HttpCount', description='The number of IPv4-based HTTP requests.', example='0'),
      v4HttpsCount?: long(name='V4HttpsCount', description='The number of IPv4-based HTTPS requests.', example='0'),
      v6Count?: long(name='V6Count', description='The number of IPv6-based requests.', example='0'),
      v6HttpCount?: long(name='V6HttpCount', description='The number of IPv6-based HTTP requests.', example='0'),
      v6HttpsCount?: long(name='V6HttpsCount', description='The number of IPv6-based HTTPS requests.', example='0'),
    }
  ](name='Data', description='The statistics on the DNS requests.'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model DescribePdnsRequestStatisticResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePdnsRequestStatisticResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribePdnsRequestStatistic  DescribePdnsRequestStatisticRequest
  * @return DescribePdnsRequestStatisticResponse
 */
async function describePdnsRequestStatistic(request: DescribePdnsRequestStatisticRequest): DescribePdnsRequestStatisticResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePdnsRequestStatistic', 'POST', '/', 'json', false, 'json', request);
}

model DescribePdnsRequestStatisticsRequest {
  domainName?: string(name='DomainName', description='The primary domain name whose statistics you want to query.', example='example.com', position='Query'),
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the YYYY-MM-DD format.

The default value is the day when you query the data.', example='2024-07-14 00:00:00', position='Query'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh', position='Query'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Default value: 20. Valid values: 1 to 100.', example='20', position='Query'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.

You can query only records of the last 90 days.', example='2024-06-14 00:00:00', position='Query'),
  subDomain?: string(name='SubDomain', description='The subdomain name whose statistics you want to query.', example='www.example.com', position='Query'),
  type?: string(name='Type', description='The type of the request statistics that you want to query. Valid values:

*   DOMAIN: queries the request statistics by domain name.
*   SUB_DOMAIN: queries the request statistics by subdomain name.', example='DOMAIN', position='Query'),
}

model DescribePdnsRequestStatisticsResponseBody = {
  data?: [ 
    {
      dohTotalCount?: long(name='DohTotalCount', description='The total number of DoH requests, including the HTTP and HTTPS requests.', example='0'),
      domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
      httpCount?: long(name='HttpCount', description='The number of HTTP requests.', example='0'),
      httpsCount?: long(name='HttpsCount', description='The number of HTTPS requests. On the Traffic Analysis tab of the public DNS console, the value of this parameter includes the number of DNS over HTTPs (DoH) requests. Therefore, the number of DoH requests is not separately displayed in the console.', example='0'),
      ipCount?: long(name='IpCount', description='The number of source IP addresses.', example='10'),
      maxThreatLevel?: string(name='MaxThreatLevel', description='The current version does not support this parameter.', example='-'),
      subDomain?: string(name='SubDomain', description='The subdomain name.', example='www.example.com'),
      threatCount?: long(name='ThreatCount', description='The current version does not support this parameter.', example='-'),
      threatInfo?: [ 
        {
          threatLevel?: string(name='ThreatLevel', description='The current version does not support this parameter.', example='-'),
          threatType?: string(name='ThreatType', description='The current version does not support this parameter.', example='-'),
        }
      ](name='ThreatInfo', description='The current version does not support this parameter.'),
      totalCount?: long(name='TotalCount', description='The total number of requests.', example='500'),
      udpTotalCount?: long(name='UdpTotalCount', description='The total number of UDP requests.', example='500'),
      v4Count?: long(name='V4Count', description='The number of IPv4-based requests.', example='0'),
      v4HttpCount?: long(name='V4HttpCount', description='The number of IPv4-based HTTP requests.', example='0'),
      v4HttpsCount?: long(name='V4HttpsCount', description='The number of IPv4-based HTTPS requests.', example='0'),
      v6Count?: long(name='V6Count', description='The number of IPv6-based requests.', example='0'),
      v6HttpCount?: long(name='V6HttpCount', description='The number of IPv6-based HTTP requests.', example='0'),
      v6HttpsCount?: long(name='V6HttpsCount', description='The number of IPv6-based HTTPS requests.', example='0'),
    }
  ](name='Data', description='The statistics on the DNS requests.'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Default value: **20**. Valid values: **1 to 100**.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='49'),
}

model DescribePdnsRequestStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePdnsRequestStatisticsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribePdnsRequestStatistics  DescribePdnsRequestStatisticsRequest
  * @return DescribePdnsRequestStatisticsResponse
 */
async function describePdnsRequestStatistics(request: DescribePdnsRequestStatisticsRequest): DescribePdnsRequestStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePdnsRequestStatistics', 'POST', '/', 'json', false, 'json', request);
}

model DescribePdnsThreatLogsRequest {
  endDate?: string(name='EndDate', position='Query'),
  keyword?: string(name='Keyword', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  startDate?: string(name='StartDate', position='Query'),
  threatLevel?: string(name='ThreatLevel', position='Query'),
  threatSourceIp?: string(name='ThreatSourceIp', position='Query'),
  threatType?: string(name='ThreatType', position='Query'),
}

model DescribePdnsThreatLogsResponseBody = {
  logs?: [ 
    {
      sourceIp?: string(name='SourceIp'),
      subDomain?: string(name='SubDomain'),
      threatLevel?: string(name='ThreatLevel'),
      threatTime?: string(name='ThreatTime'),
      threatType?: string(name='ThreatType'),
    }
  ](name='Logs'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePdnsThreatLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePdnsThreatLogsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribePdnsThreatLogs  DescribePdnsThreatLogsRequest
  * @return DescribePdnsThreatLogsResponse
 */
async function describePdnsThreatLogs(request: DescribePdnsThreatLogsRequest): DescribePdnsThreatLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePdnsThreatLogs', 'POST', '/', 'json', false, 'json', request);
}

model DescribePdnsThreatStatisticRequest {
  endDate?: string(name='EndDate', position='Query'),
  lang?: string(name='Lang', position='Query'),
  startDate?: string(name='StartDate', position='Query'),
  threatSourceIp?: string(name='ThreatSourceIp', position='Query'),
}

model DescribePdnsThreatStatisticResponseBody = {
  data?: [ 
    {
      dohTotalCount?: long(name='DohTotalCount'),
      threatLevel?: string(name='ThreatLevel'),
      threatType?: string(name='ThreatType'),
      timestamp?: long(name='Timestamp'),
      totalCount?: long(name='TotalCount'),
      udpTotalCount?: long(name='UdpTotalCount'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribePdnsThreatStatisticResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePdnsThreatStatisticResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribePdnsThreatStatistic  DescribePdnsThreatStatisticRequest
  * @return DescribePdnsThreatStatisticResponse
 */
async function describePdnsThreatStatistic(request: DescribePdnsThreatStatisticRequest): DescribePdnsThreatStatisticResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePdnsThreatStatistic', 'POST', '/', 'json', false, 'json', request);
}

model DescribePdnsThreatStatisticsRequest {
  direction?: string(name='Direction', position='Query'),
  domainName?: string(name='DomainName', position='Query'),
  endDate?: string(name='EndDate', position='Query'),
  lang?: string(name='Lang', position='Query'),
  orderBy?: string(name='OrderBy', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  startDate?: string(name='StartDate', position='Query'),
  subDomain?: string(name='SubDomain', position='Query'),
  threatLevel?: string(name='ThreatLevel', position='Query'),
  threatSourceIp?: string(name='ThreatSourceIp', position='Query'),
  threatType?: string(name='ThreatType', position='Query'),
  type?: string(name='Type', position='Query'),
}

model DescribePdnsThreatStatisticsResponseBody = {
  data?: [ 
    {
      dohTotalCount?: long(name='DohTotalCount'),
      domainCount?: long(name='DomainCount'),
      domainName?: string(name='DomainName'),
      latestThreatTime?: long(name='LatestThreatTime'),
      maxThreatLevel?: string(name='MaxThreatLevel'),
      sourceIp?: string(name='SourceIp'),
      subDomain?: string(name='SubDomain'),
      threatLevel?: string(name='ThreatLevel'),
      threatType?: string(name='ThreatType'),
      totalCount?: long(name='TotalCount'),
      udpTotalCount?: long(name='UdpTotalCount'),
    }
  ](name='Data'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePdnsThreatStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePdnsThreatStatisticsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribePdnsThreatStatistics  DescribePdnsThreatStatisticsRequest
  * @return DescribePdnsThreatStatisticsResponse
 */
async function describePdnsThreatStatistics(request: DescribePdnsThreatStatisticsRequest): DescribePdnsThreatStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePdnsThreatStatistics', 'POST', '/', 'json', false, 'json', request);
}

model DescribePdnsUdpIpSegmentsRequest {
  lang?: string(name='Lang', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
}

model DescribePdnsUdpIpSegmentsResponseBody = {
  ipSegments?: [ 
    {
      createDate?: string(name='CreateDate'),
      createTimestamp?: long(name='CreateTimestamp'),
      id?: string(name='Id'),
      ip?: string(name='Ip'),
      mask?: long(name='Mask'),
      name?: string(name='Name'),
      secretKey?: string(name='SecretKey'),
      state?: string(name='State'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='IpSegments'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
  totalPages?: string(name='TotalPages'),
}

model DescribePdnsUdpIpSegmentsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePdnsUdpIpSegmentsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribePdnsUdpIpSegments  DescribePdnsUdpIpSegmentsRequest
  * @return DescribePdnsUdpIpSegmentsResponse
 */
async function describePdnsUdpIpSegments(request: DescribePdnsUdpIpSegmentsRequest): DescribePdnsUdpIpSegmentsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePdnsUdpIpSegments', 'POST', '/', 'json', false, 'json', request);
}

model DescribePdnsUserInfoRequest {
  lang?: string(name='Lang', example='en', position='Query'),
}

model DescribePdnsUserInfoResponseBody = {
  requestId?: string(name='RequestId', example='FD552816-FCC8-4832-B4A2-2DA0C2BA1688'),
  userInfo?: {
    availableAccessSecurityType?: string(name='AvailableAccessSecurityType', example='SECURE'),
    availableService?: string(name='AvailableService', example='HTTP,HTTPS'),
    pdnsId?: long(name='PdnsId', example='10001'),
    secretKey?: string(name='SecretKey', example='1c092d715b7a48de'),
    serviceType?: string(name='ServiceType', example='normal'),
    state?: string(name='State', example='AVAILABLE'),
    statisticSwitchStatus?: string(name='StatisticSwitchStatus', example='CLOSED'),
    stoppedService?: string(name='StoppedService'),
  }(name='UserInfo'),
}

model DescribePdnsUserInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePdnsUserInfoResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribePdnsUserInfo  DescribePdnsUserInfoRequest
  * @return DescribePdnsUserInfoResponse
 */
async function describePdnsUserInfo(request: DescribePdnsUserInfoRequest): DescribePdnsUserInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePdnsUserInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRecordLogsRequest {
  domainName: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.

This parameter is required.', example='example.com', position='Query'),
  keyWord?: string(name='KeyWord', description='The keyword for searches in "%KeyWord%" mode. The value is not case-sensitive.', example='test', position='Query'),
  lang?: string(name='Lang', description='The language.', example='en', position='Query'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: **1 to 100**. Default value: **20**.', example='20', minimum=1, maximum=100, position='Query'),
  startDate?: string(name='StartDate', description='The start date of the query. Specify the start date in the **YYYY-MM-DD** format.', example='2015-12-12', position='Query'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='1.1.1.1', position='Query'),
  endDate?: string(name='endDate', description='The end date of the query. Specify the end date in the **YYYY-MM-DD** format.', example='2015-12-12', position='Query'),
}

model DescribeRecordLogsResponseBody = {
  pageNumber?: long(name='PageNumber', description='The page number.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='2'),
  recordLogs?: {
    recordLog?: [ 
    {
      action?: string(name='Action', description='The operation that you performed.'),
      actionTime?: string(name='ActionTime', description='The time when you performed the operation.', example='2015-12-12T09:23Z'),
      actionTimestamp?: long(name='ActionTimestamp', description='The time when you performed the operation. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='134514540000'),
      clientIp?: string(name='ClientIp', description='The IP address of the operator.', example='182.92.253.XX'),
      message?: string(name='Message', description='The operation message.'),
    }
  ](name='RecordLog')
  }(name='RecordLogs', description='The operation logs.'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model DescribeRecordLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRecordLogsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeRecordLogs  DescribeRecordLogsRequest
  * @return DescribeRecordLogsResponse
 */
async function describeRecordLogs(request: DescribeRecordLogsRequest): DescribeRecordLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRecordLogs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRecordResolveStatisticsSummaryRequest {
  direction?: string(name='Direction', description='The order in which the returned entries are sorted. Valid values:

*   DESC (default): descending order
*   ASC: ascending order', example='DESC', position='Query'),
  domainName: string(name='DomainName', description='The domain name.

This parameter is required.', example='example.com', position='Query'),
  domainType?: string(name='DomainType', description='The type of the domain name. The parameter value is not case-sensitive. Valid values:

*   PUBLIC (default): hosted public domain name
*   CACHE: cache-accelerated domain name', example='PUBLIC', position='Query'),
  endDate?: string(name='EndDate', description='The end date of the time range to be queried. Specify the time in the yyyy-MM-dd format, such as 2023-03-13.', example='2023-03-29', position='Query'),
  keyword?: string(name='Keyword', description='The keyword. Keyword is used together with SearchMode.', example='test', position='Query'),
  lang?: string(name='Lang', description='The language. Valid values: zh, en, and ja.', example='zh', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 1000.', example='10', minimum=1, position='Query'),
  searchMode?: string(name='SearchMode', description='The search mode of the keyword. Valid values:

*   LIKE (default): fuzzy search
*   EXACT: exact search', example='LIKE', position='Query'),
  startDate: string(name='StartDate', description='The start date of the time range to be queried. Specify the time in the yyyy-MM-dd format, such as 2023-03-01.

This parameter is required.', example='2023-03-29', position='Query'),
  threshold?: long(name='Threshold', description='The threshold for the number of Domain Name System (DNS) requests. You can query the subdomain names at the specified quantity level of DNS requests and query the number of DNS requests for each subdomain name.

If you do not specify this parameter, the data about the subdomain names that have DNS requests is obtained.

If you set this parameter to a value less than 0, the data about all subdomain names is obtained.

If you set this parameter to 0, the data about the subdomain names that do not have DNS requests is obtained.

If you set this parameter to a value greater than 0, the data about the subdomain names whose number of DNS requests is less than or equal to the value of this parameter is obtained.', example='-1', position='Query'),
}

model DescribeRecordResolveStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: **1 to 500**. Default value: **20**.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='389DFFA3-77A5-4A9E-BF3D-147C6F98A5BA'),
  statistics?: [ 
    {
      count?: string(name='Count', description='The number of DNS requests.', example='330'),
      domainName?: string(name='DomainName', description='The subdomain name.', example='tes.example.com'),
      domainType?: string(name='DomainType', description='The type of the domain name. The parameter value is not case-sensitive. Valid values:

*   PUBLIC (default): hosted public domain name
*   CACHE: cache-accelerated domain name', example='PUBLIC'),
      subDomain?: string(name='SubDomain', description='The subdomain.', example='test.example.com'),
    }
  ](name='Statistics', description='The statistics.'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned.', example='1'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeRecordResolveStatisticsSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRecordResolveStatisticsSummaryResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeRecordResolveStatisticsSummary  DescribeRecordResolveStatisticsSummaryRequest
  * @return DescribeRecordResolveStatisticsSummaryResponse
 */
async function describeRecordResolveStatisticsSummary(request: DescribeRecordResolveStatisticsSummaryRequest): DescribeRecordResolveStatisticsSummaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRecordResolveStatisticsSummary', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRecordStatisticsRequest {
  domainName: string(name='DomainName', description='The primary domain name.

This parameter is required.', example='dns-example.com', position='Query'),
  domainType?: string(name='DomainType', description='The type of the domain name. The parameter value is not case-sensitive. Valid values:

*   PUBLIC (default): hosted public domain name
*   CACHE: cache-accelerated domain name', example='PUBLIC', position='Query'),
  endDate?: string(name='EndDate', description='The end date of the query. Specify the end date in the **YYYY-MM-DD** format.

The default value is the day when you query the data.', example='2019-07-04', position='Query'),
  lang?: string(name='Lang', description='The language.', example='en', position='Query'),
  rr: string(name='Rr', description='The hostname. If you want to resolve www.dns-exmaple.top, set Rr to www.

This parameter is required.', example='www', position='Query'),
  startDate: string(name='StartDate', description='The start date of the query. Specify the start date in the **YYYY-MM-DD** format.

You can only query the DNS records within the last 90 days.``

If the time range is less than or equal to seven days, data is returned on an hourly basis.````

If the time range is greater than seven days, data is returned on a daily basis.````

This parameter is required.', example='2019-07-04', position='Query'),
}

model DescribeRecordStatisticsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='6AEC7A64-3CB1-4C49-8B35-0B901F1E26BF'),
  statistics?: {
    statistic?: [ 
    {
      count?: long(name='Count', description='The number of DNS requests.', example='15292887'),
      timestamp?: long(name='Timestamp', description='The statistical timestamp. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1556640000000'),
    }
  ](name='Statistic')
  }(name='Statistics', description='The statistics on the DNS requests.'),
}

model DescribeRecordStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRecordStatisticsResponseBody(name='body'),
}

/**
  * @description Real-time data is collected per hour.
  * @param request  the request parameters of DescribeRecordStatistics  DescribeRecordStatisticsRequest
  * @return DescribeRecordStatisticsResponse
 */
async function describeRecordStatistics(request: DescribeRecordStatisticsRequest): DescribeRecordStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRecordStatistics', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRecordStatisticsSummaryRequest {
  domainName: string(name='DomainName', description='The domain name.

This parameter is required.', example='dns-example.com', position='Query'),
  domainType?: string(name='DomainType', description='The type of the domain name. The parameter value is not case-sensitive. Valid values:

*   PUBLIC (default): hosted public domain name
*   CACHE: cache-accelerated domain name', example='PUBLIC', position='Query'),
  endDate?: string(name='EndDate', description='The end date of the query. Specify the start date in the **YYYY-MM-DD** format.

The default value is the day when you query the data.', example='2019-07-04', position='Query'),
  keyword?: string(name='Keyword', description='The keyword for searches in %KeyWord% mode. The value is not case-sensitive.', example='test', position='Query'),
  lang?: string(name='Lang', description='The language.', example='en', position='Query'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: **1 to 100**. Default value: **20**.', example='20', minimum=1, maximum=100, position='Query'),
  searchMode?: string(name='SearchMode', description='The search mode of the keyword. Valid values:

*   **LIKE** (default): fuzzy search
*   **EXACT**: exact search', example='EXACT', position='Query'),
  startDate: string(name='StartDate', description='The start date of the query. Specify the start date in the **YYYY-MM-DD** format.

You can only query the DNS records within the last 90 days.``

This parameter is required.', example='2019-07-04', position='Query'),
  threshold?: long(name='Threshold', description='The maximum number of DNS requests that you can obtain. You can obtain data about a domain name with DNS request volume less than or equal to the maximum number. For example, if you set this parameter to 100, you can query domain names with less than 100 DNS requests.', example='12', position='Query'),
}

model DescribeRecordStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: **1 to 100**. Default value: **20**.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='E49F0023-4A98-486F-8BA3-6003D5664105'),
  statistics?: {
    statistic?: [ 
    {
      count?: long(name='Count', description='The number of DNS requests.', example='838711553'),
      subDomain?: string(name='SubDomain', description='The subdomain.', example='t1.alitest2.com'),
    }
  ](name='Statistic')
  }(name='Statistics', description='The DNS requests.'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned.', example='3'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeRecordStatisticsSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRecordStatisticsSummaryResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeRecordStatisticsSummary  DescribeRecordStatisticsSummaryRequest
  * @return DescribeRecordStatisticsSummaryResponse
 */
async function describeRecordStatisticsSummary(request: DescribeRecordStatisticsSummaryRequest): DescribeRecordStatisticsSummaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRecordStatisticsSummary', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSubDomainRecordsRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com', position='Query'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en', position='Query'),
  line?: string(name='Line', description='The DNS resolution line.', example='default', position='Query'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: **1 to 100**. Default value: **20**.', example='20', minimum=1, maximum=500, position='Query'),
  subDomain: string(name='SubDomain', description='If you set SubDomain to `a.www.example.com` and leave

DomainName empty, the system returns the DNS records that contain the hostname `a.www` for the domain name example.com. If you set SubDomain to a.www.example.com and set DomainName to www.example.com, the system returns the DNS records that contain the hostname `a` for the domain name www.example.com. If you set SubDomain to a.www.example.com and set DomainName to a.www.example.com, the system returns the DNS records that contain the hostname `@` for the domain name a.www.example.com.

This parameter is required.', example='a.www.example.com', position='Query'),
  type?: string(name='Type', description='The type of DNS records. If you do not specify this parameter, all types of DNS records for the subdomain name are returned.

Valid values: **A, MX, CNAME, TXT, REDIRECT_URL, FORWORD_URL, NS, AAAA, and SRV**.', example='MX', position='Query'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0', position='Query'),
}

model DescribeSubDomainRecordsResponseBody = {
  domainRecords?: {
    record?: [ 
    {
      domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
      line?: string(name='Line', description='The DNS resolution line.', example='default'),
      locked?: boolean(name='Locked', description='The lock status of the DNS record.', example='false'),
      priority?: long(name='Priority', description='The priority of the mail exchanger (MX) record.', example='2'),
      rr?: string(name='RR', description='The hostname.', example='www'),
      recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
      remark?: string(name='Remark', description='The description of the DNS record.', example='test'),
      status?: string(name='Status', description='The status of the DNS record.', example='Enable'),
      TTL?: long(name='TTL', description='The time-to-live (TTL) of the DNS record.', example='600'),
      type?: string(name='Type', description='The type of the DNS record.', example='CNAME'),
      value?: string(name='Value', description='The record value.', example='example.net'),
      weight?: int32(name='Weight', description='The weight of the DNS record.', example='10'),
    }
  ](name='Record')
  }(name='DomainRecords', description='The returned Domain Name System (DNS) records.'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='2'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model DescribeSubDomainRecordsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSubDomainRecordsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeSubDomainRecords  DescribeSubDomainRecordsRequest
  * @return DescribeSubDomainRecordsResponse
 */
async function describeSubDomainRecords(request: DescribeSubDomainRecordsRequest): DescribeSubDomainRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSubDomainRecords', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSupportLinesRequest {
  domainName?: string(name='DomainName', example='example.com', position='Query'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en', position='Query'),
  userClientIp?: string(name='UserClientIp', example='1.1.*.*', position='Query'),
}

model DescribeSupportLinesResponseBody = {
  recordLines?: {
    recordLine?: [ 
    {
      fatherCode?: string(name='FatherCode', description='The code of the parent line. Currently, no data is returned.', example='unicom'),
      lineCode?: string(name='LineCode', description='The code of the child line.', example='cn_unicom_shanxi'),
      lineDisplayName?: string(name='LineDisplayName', description='The display name of the line.', example='China Unicom'),
      lineName?: string(name='LineName', description='The name of the child line.', example='China Unicom_Shanxi'),
    }
  ](name='RecordLine')
  }(name='RecordLines', description='The Alibaba Cloud DNS lines.'),
  requestId?: string(name='RequestId', example='CFDA0830-7D6E-4C13-8632-B57C7EDCF079'),
}

model DescribeSupportLinesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSupportLinesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeSupportLines  DescribeSupportLinesRequest
  * @return DescribeSupportLinesResponse
 */
async function describeSupportLines(request: DescribeSupportLinesRequest): DescribeSupportLinesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSupportLines', 'POST', '/', 'json', false, 'json', request);
}

model DescribeTagsRequest {
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries to return per page. Default value: 200.', example='200', position='Query'),
  resourceType: string(name='ResourceType', description='The type of the resource. Valid values:

*   **DOMAIN**: domain name

This parameter is required.', example='DOMAIN', position='Query'),
}

model DescribeTagsResponseBody = {
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Default value: 200.', example='200'),
  requestId?: string(name='RequestId', description='The request ID.', example='89184F33-48A1-4401-9C0F-40E45DB091AB'),
  tags?: [ 
    {
      key?: string(name='Key', description='The key of tag N added to the resource.', example='abc'),
      values?: [ string ](name='Values', description='The values of tags added to the resource.'),
    }
  ](name='Tags', description='The tags added to the resource.'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='5'),
}

model DescribeTagsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTagsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeTags  DescribeTagsRequest
  * @return DescribeTagsResponse
 */
async function describeTags(request: DescribeTagsRequest): DescribeTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTags', 'POST', '/', 'json', false, 'json', request);
}

model DescribeTransferDomainsRequest {
  domainName?: string(name='DomainName', description='Specifies the domain name for which you want to view the transfer record.', example='alidns.com', position='Query'),
  fromUserId?: long(name='FromUserId', description='The user ID from which the domain name was transferred to the current account.', example='123456', position='Query'),
  lang?: string(name='Lang', description='The language.', example='en', position='Query'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: 1 to 100. Default value: 20.', example='20', minimum=1, maximum=100, position='Query'),
  targetUserId?: long(name='TargetUserId', description='The user ID to which the domain name was transferred from the current account.', example='123456', position='Query'),
  transferType: string(name='TransferType', description='The transfer type. Valid values:

*   IN: The domain name was transferred to the current account.
*   OUT: The domain name was transferred from the current account.

This parameter is required.', example='IN', position='Query'),
}

model DescribeTransferDomainsResponseBody = {
  domainTransfers?: {
    domainTransfer?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the domain name was created. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2019-10-30T07:16Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The time when the domain name was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1572419764000'),
      domainName?: string(name='DomainName', description='The domain name.', example='test.com'),
      fromUserId?: long(name='FromUserId', description='The user ID from which the domain name was transferred.', example='2222'),
      id?: long(name='Id', description='The ID of the domain name that was transferred.', example='1'),
      targetUserId?: long(name='TargetUserId', description='The user ID to which the domain name was transferred.', example='111111'),
    }
  ](name='DomainTransfer')
  }(name='DomainTransfers', description='The domain names that were transferred between accounts.'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: 1 to 100. Default value: 20.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model DescribeTransferDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTransferDomainsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeTransferDomains  DescribeTransferDomainsRequest
  * @return DescribeTransferDomainsResponse
 */
async function describeTransferDomains(request: DescribeTransferDomainsRequest): DescribeTransferDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTransferDomains', 'POST', '/', 'json', false, 'json', request);
}

model ExecuteGtmRecoveryPlanRequest {
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: English.', example='en', position='Query'),
  recoveryPlanId: long(name='RecoveryPlanId', description='The ID of the disaster recovery plan.

This parameter is required.', example='100', position='Query'),
}

model ExecuteGtmRecoveryPlanResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model ExecuteGtmRecoveryPlanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExecuteGtmRecoveryPlanResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ExecuteGtmRecoveryPlan  ExecuteGtmRecoveryPlanRequest
  * @return ExecuteGtmRecoveryPlanResponse
 */
async function executeGtmRecoveryPlan(request: ExecuteGtmRecoveryPlanRequest): ExecuteGtmRecoveryPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExecuteGtmRecoveryPlan', 'POST', '/', 'json', false, 'json', request);
}

model GetMainDomainNameRequest {
  inputString: string(name='InputString', description='The string. The string can be up to 128 characters in length.

This parameter is required.', example='www.example.com', position='Query'),
  lang?: string(name='Lang', description='The language.', example='en', position='Query'),
}

model GetMainDomainNameResponseBody = {
  domainLevel?: long(name='DomainLevel', description='The level of the entered domain name.', example='2'),
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  rr?: string(name='RR', description='The hostname.', example='www'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model GetMainDomainNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMainDomainNameResponseBody(name='body'),
}

/**
  * @description For more information about the difference between primary domain names and subdomain names, see
  * [Subdomain levels](https://www.alibabacloud.com/help/zh/faq-detail/39803.htm). For example, if you enter `www.abc.com`, abc.com is obtained.
  * @param request  the request parameters of GetMainDomainName  GetMainDomainNameRequest
  * @return GetMainDomainNameResponse
 */
async function getMainDomainName(request: GetMainDomainNameRequest): GetMainDomainNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMainDomainName', 'POST', '/', 'json', false, 'json', request);
}

model GetTxtRecordForVerifyRequest {
  domainName?: string(name='DomainName', description='The ID of the Domain Name System (DNS) record. You can call the [DescribeDomainRecords](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomainrecords?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.', example='example.com', position='Query'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en', position='Query'),
  type: string(name='Type', description='The feature verified by using the TXT record. Valid values:

*   ADD_SUB_DOMAIN: add a subdomain for verification.
*   RETRIEVAL: add other subdomains for verification

This parameter is required.', example='ADD_SUB_DOMAIN', position='Query'),
}

model GetTxtRecordForVerifyResponseBody = {
  domainName?: string(name='DomainName', description='The domain name.

>  If you do not specify this parameter, it is not returned.', example='example.com'),
  parentDomainName?: string(name='ParentDomainName', description='The top-level domain name.', example='com'),
  rr?: string(name='RR', description='The hostname.', example='aliyunRetrieval'),
  requestId?: string(name='RequestId', description='The request ID.', example='9CC0D642-49D4-48DE-A1A5-9F218652E4A7'),
  value?: string(name='Value', description='The record value.

>  The validity period is three days.', example='c99419e6997f41daaa3e*****'),
}

model GetTxtRecordForVerifyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTxtRecordForVerifyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetTxtRecordForVerify  GetTxtRecordForVerifyRequest
  * @return GetTxtRecordForVerifyResponse
 */
async function getTxtRecordForVerify(request: GetTxtRecordForVerifyRequest): GetTxtRecordForVerifyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTxtRecordForVerify', 'POST', '/', 'json', false, 'json', request);
}

model ListCloudGtmAddressPoolsRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  addressPoolName?: string(name='AddressPoolName', description='Address pool name.', example='AddressPool-1', position='Query'),
  addressPoolType?: string(name='AddressPoolType', description='The type of the address pool. Valid values:

*   IPv4: indicates that the service address to be resolved is an IPv4 address.
*   IPv6: indicates that the service address to be resolved is an IPv6 address.
*   domain: indicates that the service address to be resolved is a domain name.', example='IPv4', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  enableStatus?: string(name='EnableStatus', description='The enabling state of the address pool. Valid values:

*   enable: The address pool is enabled.
*   disable: The address pool is disabled.', example='enable', position='Query'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting at **1**, default is **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of **100**, and a default of **20**.', example='20', position='Query'),
  remark?: string(name='Remark', description='The additional description of the address pool.', example='test', position='Query'),
}

model ListCloudGtmAddressPoolsResponseBody = {
  addressPools?: {
    addressPool?: [ 
    {
      addressLbStrategy?: string(name='AddressLbStrategy', description='Load balancing policy among addresses in the address pool:
- round_robin: Round-robin, for any source of DNS resolution requests, all addresses are returned. The order of all addresses is rotated each time.
- sequence: Sequential, for any source of DNS resolution requests, the address with the smaller sequence number (the sequence number indicates the priority of address returns, with smaller numbers having higher priority) is returned. If the address with the smaller sequence number is unavailable, the next address with a smaller sequence number is returned.
- weight: Weighted, supports setting different weight values for each address, realizing the return of addresses according to the ratio of weights in resolution queries.
- source_nearest: Source-nearest, i.e., intelligent resolution function, where GTM can return different addresses based on the source of different DNS resolution requests, achieving the effect of users accessing nearby.', example='round_robin'),
      addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
      addressPoolName?: string(name='AddressPoolName', description='Address pool name.', example='AddressPool-1'),
      addressPoolType?: string(name='AddressPoolType', description='Address pool type:
- IPv4
- IPv6
- domain', example='IPv4'),
      addresses?: {
        address?: [ 
        {
          address?: string(name='Address', description='IP address or domain name.', example='223.5.XX.XX'),
          addressId?: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.', example='addr-895182181143688192'),
          attributeInfo?: string(name='AttributeInfo', description='Address ownership information, not supported in the current version.', example='The current version does not support returning this parameter.'),
          availableMode?: string(name='AvailableMode', description='The failover mode that is used when address exceptions are identified. Valid values:

*   auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
*   manual: the manual mode. If an address is in the unavailable state, the address is not returned for DNS requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.', example='auto'),
          availableStatus?: string(name='AvailableStatus', description='The availability state of the address. Valid values:

*   available: The address is available.
*   unavailable: The address is unavailable.', example='available'),
          createTime?: string(name='CreateTime', description='Address creation time.', example='2024-03-15T01:46Z'),
          createTimestamp?: long(name='CreateTimestamp', description='Address creation time (timestamp).', example='1527690629357'),
          enableStatus?: string(name='EnableStatus', description='Address enable status:
- enable: Enabled status
- disable: Disabled status', example='enable'),
          healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address. Valid values:

*   any_ok: The health check results of at least one health check template are normal.
*   p30_ok: The health check results of at least 30% of health check templates are normal.
*   p50_ok: The health check results of at least 50% of health check templates are normal.
*   p70_ok: The health check results of at least 70% of health check templates are normal.
*   all_ok: The health check results of all health check templates are normal.', example='any_ok'),
          healthStatus?: string(name='HealthStatus', description='The health check state of the address. Valid values:

*   ok: The address passes all health checks of the referenced health check templates.
*   ok_alert: The address fails some health checks of the referenced health check templates but the address is deemed normal.
*   ok_no_monitor: The address does not reference any health check template and is normal.
*   exceptional: The address fails some or all health checks of the referenced health check templates and the address is deemed abnormal.', example='ok'),
          healthTasks?: {
            healthTask?: [ 
            {
              port?: int32(name='Port', description='The target service port for health checks. When the Ping protocol is selected for health checks, configuration of the service port is not supported.', example='80'),
              templateId?: string(name='TemplateId', description='The ID of the health check template.', example='mtp-895180524251002880'),
              templateName?: string(name='TemplateName', description='Health check template name.', example='IPv4-Ping'),
            }
          ](name='HealthTask')
          }(name='HealthTasks', description='The health check tasks.'),
          manualAvailableStatus?: string(name='ManualAvailableStatus', description='The availability state of the address when AvailableMode is set to manual for the address. Valid values:

*   available: The address is available. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
*   unavailable: The address is unavailable. In this state, the address is not returned for DNS requests even if the address passes health checks.', example='available'),
          name?: string(name='Name', description='Address name.', example='Address-1'),
          remark?: string(name='Remark', description='Address remarks.', example='test'),
          requestSource?: {
            requestSource?: [ string ](name='RequestSource')
          }(name='RequestSource', description='List of request sources.'),
          seqNonPreemptiveSchedule?: boolean(name='SeqNonPreemptiveSchedule', description='Indicates whether the mode of the sequence policy for load balancing between address pools is non-preemptive. This parameter is available only for the multicloud integration scenario. Valid values:

*   true
*   false', example='false'),
          serialNumber?: int32(name='SerialNumber', description='Sequence number, indicating the priority of address return, where smaller numbers have higher priority.', example='1'),
          type?: string(name='Type', description='Address type:
- IPv4: IPv4 address
- IPv6: IPv6 address
- domain: Domain name', example='IPv4'),
          updateTime?: string(name='UpdateTime', description='The last time the address was modified.', example='2024-03-15T01:46Z'),
          updateTimestamp?: long(name='UpdateTimestamp', description='The last modification time of the address (timestamp).', example='1527690629357'),
          weightValue?: int32(name='WeightValue', description='Weight value (integer between 1 and 100), supports setting different weight values for each address, enabling resolution queries to return addresses according to the weight ratio.', example='1'),
        }
      ](name='Address')
      }(name='Addresses', description='The addresses.'),
      availableStatus?: string(name='AvailableStatus', description='The availability state of the address pool. Valid values:

*   Available: The address pool is available.
*   unavailable: The address pool is unavailable.', example='available'),
      createTime?: string(name='CreateTime', description='Address pool creation time.', example='2024-03-15T01:46Z'),
      createTimestamp?: long(name='CreateTimestamp', description='Address pool creation time (timestamp).', example='1527690629357'),
      enableStatus?: string(name='EnableStatus', description='The enabling state of the address pool. Valid values:

*   enable: The address pool is enabled.
*   disable: The address pool is disabled.', example='enable'),
      healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health state of the address. Valid values:

*   any_ok: The health check results of at least one health check template are normal.
*   p30_ok: The health check results of at least 30% of health check templates are normal.
*   p50_ok: The health check results of at least 50% of health check templates are normal.
*   p70_ok: The health check results of at least 70% of health check templates are normal.
*   all_ok: The health check results of all health check templates are normal.', example='any_ok'),
      healthStatus?: string(name='HealthStatus', description='The health state of the address pool. Valid values:

*   ok: The health state of the address pool is Normal and all addresses that are referenced by the address pool are available.
*   ok_alert: The health state of the address pool is Warning and some of the addresses that are referenced by the address pool are unavailable. However, the address pool is deemed normal. In this state, available address pools are normally used for DNS resolution, but unavailable address pools cannot be used for DNS resolution.
*   exceptional: The health state of the address pool is Abnormal and some or all of the addresses that are referenced by the address pool are unavailable. In this case, the address pool is deemed abnormal.', example='ok'),
      remark?: string(name='Remark', description='Remark', example='test'),
      sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address with the smallest sequence number is recovered. This parameter is required only when AddressLbStrategy is set to sequence. Valid values:

*   preemptive: The address with the smallest sequence number is preferentially used if this address is recovered.
*   non_preemptive: The current address is still used even if the address with the smallest sequence number is recovered.', example='preemptive'),
      updateTime?: string(name='UpdateTime', description='Last modification time of the address pool.', example='2024-03-15T01:46Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='Last modification time of the address pool (timestamp).', example='1527690629357'),
    }
  ](name='AddressPool')
  }(name='AddressPools', description='The address pools.'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting at **1**, default is **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.', example='20'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalItems?: int32(name='TotalItems', description='Total number of entries in the address pool.', example='11'),
  totalPages?: int32(name='TotalPages', description='Total number of pages.', example='1'),
}

model ListCloudGtmAddressPoolsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCloudGtmAddressPoolsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListCloudGtmAddressPools  ListCloudGtmAddressPoolsRequest
  * @return ListCloudGtmAddressPoolsResponse
 */
async function listCloudGtmAddressPools(request: ListCloudGtmAddressPoolsRequest): ListCloudGtmAddressPoolsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCloudGtmAddressPools', 'POST', '/', 'json', false, 'json', request);
}

model ListCloudGtmAddressesRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='Return language value, options:
- zh-CN: Chinese.
- en-US: English.', example='en-US', position='Query'),
  address?: string(name='Address', description='IP address or domain name.', example='223.5.XX.XX', position='Query'),
  addressId?: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.', example='addr-89518218114368**92', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  enableStatus?: string(name='EnableStatus', description='Indicates the current availability of the address:
- enable: Enabled status
- disable: Disabled status', example='enable', position='Query'),
  healthStatus?: string(name='HealthStatus', description='The health check state of the address. Valid values:

*   ok: The address passes all health checks of the referenced health check templates.
*   ok_alert: The address fails some health checks of the referenced health check templates but the address is deemed normal.
*   ok_no_monitor: The address does not reference a health check template.
*   exceptional: The address fails some or all health checks of the referenced health check templates and the address is deemed abnormal.', example='ok', position='Query'),
  monitorTemplateId?: string(name='MonitorTemplateId', description='The ID of the health check template. This ID uniquely identifies the health check template.', example='mtp-89518052425100**80', position='Query'),
  name?: string(name='Name', description='Address name.', example='test', position='Query'),
  pageNumber: int32(name='PageNumber', description='Current page number, starting from **1**, default is **1**.

This parameter is required.', example='1', position='Query'),
  pageSize: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.

This parameter is required.', example='20', position='Query'),
  type?: string(name='Type', description='Address type:
- IPv4
- IPv6
- domain', example='IPv4', position='Query'),
}

model ListCloudGtmAddressesResponseBody = {
  addresses?: {
    address?: [ 
    {
      address?: string(name='Address', description='IP address or domain name.', example='223.5.XX.XX'),
      addressId?: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.', example='addr-89518218114368**92'),
      attributeInfo?: string(name='AttributeInfo', description='Address ownership information.', example='Not supported in current version, this parameter should be none.'),
      availableMode?: string(name='AvailableMode', description='The failover method that is used if the address fails health checks. Valid values:

auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.

manual: the manual mode. If an address is in the unavailable state, the address is not returned for Domain Name System (DNS) requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.', example='auto'),
      availableStatus?: string(name='AvailableStatus', description='The availability state of the address. Valid values:

*   available: The address is available.
*   unavailable: The address is unavailable.', example='available'),
      createTime?: string(name='CreateTime', description='Address creation time.', example='2024-03-23T13:09Z'),
      createTimestamp?: long(name='CreateTimestamp', description='Creation time (timestamp).', example='1527690629357'),
      enableStatus?: string(name='EnableStatus', description='Indicates the current availability of the address:
- enable: Enabled status 
- disable: Disabled status', example='enable'),
      healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address. Valid values:

*   any_ok: The health check results of at least one health check template are normal.
*   p30_ok: The health check results of at least 30% of health check templates are normal.
*   p50_ok: The health check results of at least 50% of health check templates are normal.
*   p70_ok: The health check results of at least 70% of health check templates are normal.
*   all_ok: The health check results of all health check templates are normal.', example='p50_ok'),
      healthStatus?: string(name='HealthStatus', description='The health check state of the address. Valid values:

*   ok: The address passes all health checks of the referenced health check templates.
*   ok_alert: The address fails some health checks of the referenced health check templates but the address is deemed normal.
*   ok_no_monitor: The address does not reference a health check template.
*   exceptional: The address fails some or all health checks of the referenced health check templates and the address is deemed abnormal.', example='ok'),
      healthTasks?: {
        healthTask?: [ 
        {
          monitorStatus?: string(name='MonitorStatus', description='The state of the health check task. Valid values:

*   ok: The task is normal.
*   alert: An alert is triggered.
*   no_data: No data is available. In most cases, the health check task is newly created and no data is collected.', example='ok'),
          port?: int32(name='Port', description='The target service port for health check probes. When the health check protocol is set to Ping, configuration of the service port is not supported.', example='80'),
          templateId?: string(name='TemplateId', description='The ID of the health check template associated with the address.', example='mtp-89518052425100**80'),
          templateName?: string(name='TemplateName', description='Health check template name.', example='Ping-IPv4'),
        }
      ](name='HealthTask')
      }(name='HealthTasks', description='The health check tasks referenced by the address.'),
      manualAvailableStatus?: string(name='ManualAvailableStatus', description='The availability state of the address when AvailableMode is set to manual. Valid values:

available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.

unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.', example='available'),
      name?: string(name='Name', description='Address name.', example='Address-1'),
      remark?: string(name='Remark', description='Remarks.', example='app'),
      type?: string(name='Type', description='Address type:
- IPv4
- IPv6
- domain', example='IPv4'),
      updateTime?: string(name='UpdateTime', description='Address modification time.', example='2024-03-29T13:20Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='Update time (timestamp).', example='1527690824357'),
    }
  ](name='Address')
  }(name='Addresses', description='The addresses.'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from **1**, default is **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.', example='20'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalItems?: int32(name='TotalItems', description='Get the total number of addresses in the address list.', example='30'),
  totalPages?: int32(name='TotalPages', description='Total number of pages.', example='2'),
}

model ListCloudGtmAddressesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCloudGtmAddressesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListCloudGtmAddresses  ListCloudGtmAddressesRequest
  * @return ListCloudGtmAddressesResponse
 */
async function listCloudGtmAddresses(request: ListCloudGtmAddressesRequest): ListCloudGtmAddressesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCloudGtmAddresses', 'POST', '/', 'json', false, 'json', request);
}

model ListCloudGtmAlertLogsRequest {
  actionType?: string(name='ActionType', description='Alert type:
- ALERT
- RESUME', example='ALERT', position='Query'),
  endTimestamp: long(name='EndTimestamp', description='The end time of the query (timestamp).

This parameter is required.', example='1711328826977', position='Query'),
  entityType?: string(name='EntityType', description='Alarm object types:
- GTM_ADDRESS: Address
- GTM_ADDRESS_POOL: Address Pool
- GTM_INSTANCE: Instance
- GTM_MONITOR_TEMPLATE: Health Check Template', example='GTM_ADDRESS', position='Query'),
  keyword?: string(name='Keyword', description='Search keyword, usually an address ID, address pool ID, domain information, etc.', example='pool-895280232254422016', position='Query'),
  lang?: string(name='Lang', description='Language type of the returned information:
- zh-CN: Chinese
- en-US: English', example='zh-CN', position='Query'),
  pageNumber: int32(name='PageNumber', description='Current page number, starting from **1**, default is **1**.

This parameter is required.', example='1', position='Query'),
  pageSize: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.

This parameter is required.', example='20', position='Query'),
  startTimestamp: long(name='StartTimestamp', description='The start time of the query (timestamp).

This parameter is required.', example='1611328826977', position='Query'),
}

model ListCloudGtmAlertLogsResponseBody = {
  logs?: {
    log?: [ 
    {
      actionType?: string(name='ActionType', description='Alert type:
- ALERT
- RESUME', example='ALERT'),
      content?: string(name='Content', description='The alert content.', example='The alert content.'),
      entityType?: string(name='EntityType', description='Alarm object types:
- GTM_ADDRESS: Address
- GTM_ADDRESS_POOL: Address Pool
- GTM_INSTANCE: Instance
- GTM_MONITOR_TEMPLATE: Health Check Template', example='GTM_ADDRESS'),
      timestamp?: long(name='Timestamp', description='Alert log time (timestamp).', example='1711328826977'),
    }
  ](name='Log')
  }(name='Logs', description='The alert logs.'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from 1, default is 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.', example='20'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalItems?: int32(name='TotalItems', description='Total number of alarm log entries.', example='15'),
  totalPages?: int32(name='TotalPages', description='Total number of pages.', example='1'),
}

model ListCloudGtmAlertLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCloudGtmAlertLogsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListCloudGtmAlertLogs  ListCloudGtmAlertLogsRequest
  * @return ListCloudGtmAlertLogsResponse
 */
async function listCloudGtmAlertLogs(request: ListCloudGtmAlertLogsRequest): ListCloudGtmAlertLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCloudGtmAlertLogs', 'POST', '/', 'json', false, 'json', request);
}

model ListCloudGtmAvailableAlertGroupsRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   **zh-CN**: Chinese
*   **en-US**: English', example='en-US', position='Query'),
}

model ListCloudGtmAvailableAlertGroupsResponseBody = {
  alertGroups?: {
    alertGroup?: [ 
    {
      groupName?: string(name='GroupName', description='The name of the alert contact group.', example='[\\"Default\\"]'),
    }
  ](name='AlertGroup')
  }(name='AlertGroups', description='The alert contact groups.'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model ListCloudGtmAvailableAlertGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCloudGtmAvailableAlertGroupsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListCloudGtmAvailableAlertGroups  ListCloudGtmAvailableAlertGroupsRequest
  * @return ListCloudGtmAvailableAlertGroupsResponse
 */
async function listCloudGtmAvailableAlertGroups(request: ListCloudGtmAvailableAlertGroupsRequest): ListCloudGtmAvailableAlertGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCloudGtmAvailableAlertGroups', 'POST', '/', 'json', false, 'json', request);
}

model ListCloudGtmInstanceConfigsRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  enableStatus?: string(name='EnableStatus', description='The enabling state of the access domain name. Valid values:

*   enable: The access domain name is enabled and the intelligent scheduling policy of the GTM instance takes effect.
*   disable: The access domain name is disabled and the intelligent scheduling policy of the GTM instance does not take effect.', example='enable', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance.', example='gtm-cn-wwo3a3hbz**', position='Query'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting at **1**, default is **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of **100**, and a default of **20**.', example='20', position='Query'),
  remark?: string(name='Remark', description='Remarks.', example='test', position='Query'),
  scheduleDomainName?: string(name='ScheduleDomainName', description='The GTM access domain name. The value of this parameter is composed of the value of ScheduleHostname and the value of ScheduleZoneName.', example='www.example.com', position='Query'),
  scheduleZoneName?: string(name='ScheduleZoneName', description='The zone (such as example.com) or subzone (such as a.example.com) of the GTM access domain name. In most cases, the zone or subzone is hosted in Authoritative DNS Resolution of the Alibaba Cloud DNS console within the account to which the GTM instance belongs.', example='example.com', position='Query'),
}

model ListCloudGtmInstanceConfigsResponseBody = {
  instanceConfigs?: {
    instanceConfig?: [ 
    {
      addressPoolLbStrategy?: string(name='AddressPoolLbStrategy', description='The policy for load balancing between address pools. Valid values:

*   round_robin: All address pools are returned for DNS requests from any source. All address pools are sorted in round-robin mode each time they are returned.
*   sequence: The address pool with the smallest sequence number is preferentially returned for DNS requests from any source. The sequence number indicates the priority for returning the address pool. A smaller sequence number indicates a higher priority. If the address pool with the smallest sequence number is unavailable, the address pool with the second smallest sequence number is returned.
*   weight: You can set a different weight value for each address pool. This way, address pools are returned based on the weight values.
*   source_nearest: GTM returns different address pools based on the sources of DNS requests. This way, users can access nearby addresses.', example='round_robin'),
      addressPools?: {
        addressPool?: [ 
        {
          addressLbStrategy?: string(name='AddressLbStrategy', description='Load balancing policy among addresses in the address pool:
- round_robin: Round-robin, for any source of DNS resolution requests, returns all addresses and rotates the order of all addresses each time.
- sequence: Sequential, for any source of DNS resolution requests, returns the address with the smaller sequence number (the sequence number indicates the priority of the address return, the smaller the higher the priority). If the address with the smaller sequence number is unavailable, return the next address with a smaller sequence number.
- weight: Weighted, supports setting different weight values for each address to realize returning addresses according to the weight ratio for resolution queries.
- source_nearest: Source-nearest, i.e., intelligent resolution function, where GTM can return different addresses based on the source of different DNS resolution requests, achieving the effect of users accessing nearby.', example='round_robin'),
          addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
          addressPoolName?: string(name='AddressPoolName', description='Address pool name.', example='AddressPool-1'),
          addressPoolType?: string(name='AddressPoolType', description='Address pool type:
- IPv4
- IPv6
- domain', example='IPv4'),
          availableStatus?: string(name='AvailableStatus', description='Address pool availability status:
- available: Available
- unavailable: Unavailable', example='available'),
          createTime?: string(name='CreateTime', description='Address pool creation time.', example='2024-03-15T01:46Z'),
          createTimestamp?: long(name='CreateTimestamp', description='Address pool creation time (timestamp).', example='1527690629357'),
          enableStatus?: string(name='EnableStatus', description='Address pool status:
- enable: Enabled status
- disable: Disabled status', example='enable'),
          healthJudgement?: string(name='HealthJudgement', description='The health state of the address pool. Valid values:

*   ok: The health state of the address pool is Normal and all addresses that are referenced by the address pool are available.
*   ok_alert: The health state of the address pool is Warning and some of the addresses that are referenced by the address pool are unavailable. However, the address pool is deemed normal. In this case, available address pools are normally used for DNS resolution, but unavailable address pools cannot be used for DNS resolution.
*   exceptional: The health state of the address pool is Abnormal and some or all of the addresses that are referenced by the address pool are unavailable. In this case, the address pool is deemed abnormal.', example='ok'),
          healthStatus?: string(name='HealthStatus', description='The health state of the address pool. Valid values:

*   ok: The health state of the address pool is Normal and all addresses that are referenced by the address pool are available.
*   ok_alert: The health state of the address pool is Warning and some of the addresses that are referenced by the address pool are unavailable. However, the address pool is deemed normal. In this case, available address pools are normally used for DNS resolution, but unavailable address pools cannot be used for DNS resolution.
*   exceptional: The health state of the address pool is Abnormal and some or all of the addresses that are referenced by the address pool are unavailable. In this case, the address pool is deemed abnormal.', example='ok'),
          requestSource?: {
            requestSource?: [ string ](name='RequestSource')
          }(name='RequestSource', description='Parse the request source list.'),
          seqNonPreemptiveSchedule?: boolean(name='SeqNonPreemptiveSchedule', description='Indicates whether the mode of the sequence policy for load balancing between address pools is non-preemptive. This parameter is available only for the multicloud integration scenario. Valid values:

*   true
*   false', example='false'),
          sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address with the smallest sequence number is recovered. This parameter is required only when AddressLbStrategy is set to sequence. Valid values:

*   preemptive: The address with the smallest sequence number is preferentially used if this address is recovered.
*   non_preemptive: The current address is still used even if the address with the smallest sequence number is recovered.', example='preemptive'),
          serialNumber?: int32(name='SerialNumber', description='Sequence number. For any parsing request, the address pool with the smaller sequence number (indicating the priority of the address pool returned, with smaller numbers having higher priority) is returned.', example='1'),
          updateTime?: string(name='UpdateTime', description='Last modification time of the address pool.', example='2024-03-15T01:46Z'),
          updateTimestamp?: long(name='UpdateTimestamp', description='Last modification time of the address pool (timestamp).', example='1527690629357'),
          weightValue?: int32(name='WeightValue', description='Weight value (an integer between 1 and 100, including both 1 and 100), which supports setting different weight values for each address pool, enabling the resolution query to return address pools according to the weighted ratio.', example='1'),
        }
      ](name='AddressPool')
      }(name='AddressPools', description='The address pools.'),
      availableStatus?: string(name='AvailableStatus', description='The availability state of the access domain name. Valid values:

*   available: If the access domain name is **enabled** and the health state of the access domain name is **Normal**, the access domain name is deemed **Available**.
*   unavailable: If the access domain name is **disabled** or the health state of the access domain name is **Abnormal**, the access domain name is deemed **Unavailable**.', example='available'),
      commodityCode?: string(name='CommodityCode', description='The commodity code. Valid values:

*   dns_gtm_public_cn: the commodity code on the China site (aliyun.com)
*   dns_gtm_public_intl: the commodity code on the international site (alibabacloud.com)', example='dns_gtm_public_cn'),
      configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.', example='Config-000**11'),
      createTime?: string(name='CreateTime', description='Instance configuration creation time.', example='2024-03-15T01:46Z'),
      createTimestamp?: long(name='CreateTimestamp', description='Instance creation time (timestamp).', example='1527690629357'),
      enableStatus?: string(name='EnableStatus', description='The enabling state of the access domain name. Valid values:

*   enable: The access domain name is enabled and the intelligent scheduling policy of the GTM instance takes effect.
*   disable: The access domain name is disabled and the intelligent scheduling policy of the GTM instance does not take effect.', example='enable'),
      healthStatus?: string(name='HealthStatus', description='The health state of the access domain name. Valid values:

*   ok: The health state of the access domain name is Normal and all address pools that are referenced by the access domain name are available.
*   ok_alert: The health state of the access domain name is Warning and some of the address pools that are referenced by the access domain name are unavailable. In this case, available address pools are normally used for DNS resolution, but unavailable address pools cannot be used for DNS resolution.
*   exceptional: The health state of the access domain name is Abnormal and all address pools that are referenced by the access domain name are unavailable. In this case, addresses in the non-empty address pool with the smallest sequence number are preferentially used for fallback resolution. This returns DNS results for clients as much as possible.', example='ok'),
      instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance.', example='gtm-cn-wwo3a3hbz**'),
      remark?: string(name='Remark', description='Remarks on the configuration of domain instance.', example='test'),
      scheduleDomainName?: string(name='ScheduleDomainName', description='The GTM access domain name. The value of this parameter is composed of the value of ScheduleHostname and the value of ScheduleZoneName.', example='www.example.com'),
      scheduleHostname?: string(name='ScheduleHostname', description='Host record of the domain accessed by GTM.', example='www'),
      scheduleRrType?: string(name='ScheduleRrType', description='DNS record types for the scheduling domain:
- A: IPv4 address
- AAAA: IPv6 address
- CNAME: Domain name', example='A'),
      scheduleZoneMode?: string(name='ScheduleZoneMode', description='The allocation mode of the access domain name. Valid values:

*   custom: custom allocation. You must specify a custom hostname and associate the hostname with a zone within the account to which the GTM instance belongs to generate an access domain name.
*   sys_assign: system allocation. This mode is not supported. Do not set ScheduleZoneMode to sys_assign.', example='custom'),
      scheduleZoneName?: string(name='ScheduleZoneName', description='The zone (such as example.com) or subzone (such as a.example.com) of the GTM access domain name. In most cases, the zone or subzone is hosted in Authoritative DNS Resolution of the Alibaba Cloud DNS console within the account to which the GTM instance belongs.', example='example.com'),
      sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address pool with the smallest sequence number is recovered. This parameter is required when AddressPoolLbStrategy is set to sequence. Valid values:

*   preemptive: The address pool with the smallest sequence number is preferentially used if this address pool is recovered.
*   non_preemptive: The current address pool is still used even if the address pool with the smallest sequence number is recovered.', example='preemptive'),
      ttl?: int32(name='Ttl', description='Global TTL (in seconds), the TTL value for domain resolution to addresses in the address pool, affecting the caching time of DNS records in the ISP\\"s LocalDNS. Supports custom TTL values.', example='60'),
      updateTime?: string(name='UpdateTime', description='The last modified time of the instance configuration.', example='2024-03-15T01:46Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The last modification time of the instance configuration (timestamp).', example='1527690629357'),
      versionCode?: string(name='VersionCode', description='The edition of the GTM 3.0 instance. Valid values:

*   standard: Standard Edition
*   ultimate: Ultimate Edition', example='ultimate'),
    }
  ](name='InstanceConfig')
  }(name='InstanceConfigs', description='The configurations of the instance.'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from **1**, default is **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.', example='20'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalItems?: int32(name='TotalItems', description='Total number of entries for domain instance configurations.', example='10'),
  totalPages?: int32(name='TotalPages', description='Total number of pages.', example='1'),
}

model ListCloudGtmInstanceConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCloudGtmInstanceConfigsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListCloudGtmInstanceConfigs  ListCloudGtmInstanceConfigsRequest
  * @return ListCloudGtmInstanceConfigsResponse
 */
async function listCloudGtmInstanceConfigs(request: ListCloudGtmInstanceConfigsRequest): ListCloudGtmInstanceConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCloudGtmInstanceConfigs', 'POST', '/', 'json', false, 'json', request);
}

model ListCloudGtmInstancesRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='Return language value. Options:
- zh-CN: Chinese.
- en-US: English.', example='en-US', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance.', example='gtm-cn-jmp3qnw**03', position='Query'),
  instanceName?: string(name='InstanceName', description='Instance name, used to distinguish the business purpose of the instance.', example='test', position='Query'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from **1**, default is **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of **100**, and a default of **20**.', example='20', position='Query'),
}

model ListCloudGtmInstancesResponseBody = {
  instances?: {
    instance?: [ 
    {
      commodityCode?: string(name='CommodityCode', description='The commodity code. Valid values:

*   dns_gtm_public_cn: commodity code on the China site (aliyun.com)
*   dns_gtm_public_intl: commodity code on the international site (alibabacloud.com)', example='dns_gtm_public_cn'),
      createTime?: string(name='CreateTime', description='Instance creation time.', example='2024-03-15T01:46Z'),
      createTimestamp?: long(name='CreateTimestamp', description='Instance creation time (timestamp).', example='1231298343343'),
      expireTime?: string(name='ExpireTime', description='Instance expiration time.', example='2024-03-15T01:46Z'),
      expireTimestamp?: long(name='ExpireTimestamp', description='Instance expiration time (timestamp).', example='1231298343343'),
      instanceId?: string(name='InstanceId', description='The ID of the GTM instance.', example='gtm-cn-jmp3qnw**03'),
      instanceName?: string(name='InstanceName', description='Instance name.', example='test'),
      monitorTaskQuota?: int32(name='MonitorTaskQuota', description='Monitor probe task quota.', example='100'),
      monthlyEmailUsed?: int32(name='MonthlyEmailUsed', description='Monthly email sending volume.', example='50'),
      monthlySmsQuota?: int32(name='MonthlySmsQuota', description='SMS quota, only supported on the China site as international sites do not support SMS.', example='1000'),
      monthlySmsUsed?: int32(name='MonthlySmsUsed', description='Monthly SMS sending volume, only supported by the China site as international sites do not support SMS.', example='100'),
      monthlyWebhookUsed?: int32(name='MonthlyWebhookUsed', description='Monthly webhook send volume.', example='80'),
      scheduleDomainName?: string(name='ScheduleDomainName', description='The access domain name, which consists of a hostname and a zone or a subzone.', example='www.example.com'),
      updateTime?: string(name='UpdateTime', description='The last time the instance was modified.', example='2024-03-15T01:46Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The last modification time of the instance (timestamp).', example='1231298343343'),
      versionCode?: string(name='VersionCode', description='GTM instance version:
- standard: Standard Edition
- ultimate: Ultimate Edition', example='ultimate'),
    }
  ](name='Instance')
  }(name='Instances', description='The instances.'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting with **1**, default is **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.', example='20'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalItems?: int32(name='TotalItems', description='Total number of instance entries.', example='15'),
  totalPages?: int32(name='TotalPages', description='Total number of pages.', example='1'),
}

model ListCloudGtmInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCloudGtmInstancesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListCloudGtmInstances  ListCloudGtmInstancesRequest
  * @return ListCloudGtmInstancesResponse
 */
async function listCloudGtmInstances(request: ListCloudGtmInstancesRequest): ListCloudGtmInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCloudGtmInstances', 'POST', '/', 'json', false, 'json', request);
}

model ListCloudGtmMonitorNodesRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   **zh-CN**: Chinese
*   **en-US** (default): English', example='en-US', position='Query'),
}

model ListCloudGtmMonitorNodesResponseBody = {
  ipv4IspCityNodes?: {
    ipv4IspCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='City code.', example='503'),
      cityName?: string(name='CityName', description='City name.', example='Beijing'),
      countryCode?: string(name='CountryCode', description='Country code.', example='629'),
      countryName?: string(name='CountryName', description='Country name.', example='China'),
      defaultSelected?: boolean(name='DefaultSelected', description='Monitor node default selection:
- true: Selected by default
- false: Not selected by default', example='true'),
      groupName?: string(name='GroupName', description='Monitor probe group name.', example='BGP Nodes'),
      groupType?: string(name='GroupType', description='Monitoring node group type, currently supported:
- BGP: BGP node
- OVERSEAS: International node
- ISP: Carrier node', example='BGP'),
      ips?: {
        ip?: [ string ](name='Ip')
      }(name='Ips', description='List of node IP addresses.'),
      ispCode?: string(name='IspCode', description='Operator code.', example='465'),
      ispName?: string(name='IspName', description='Operator name.', example='Alibaba'),
      nodeId?: string(name='NodeId', description='Unique identifier ID of the probe node.', example='node-ewze1bysndy4gf**j8'),
    }
  ](name='Ipv4IspCityNode')
  }(name='Ipv4IspCityNodes', description='Public IPv4 monitoring node list.'),
  ipv6IspCityNodes?: {
    ipv6IspCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='City code.', example='357'),
      cityName?: string(name='CityName', description='City name.', example='Shanghai'),
      countryCode?: string(name='CountryCode', description='Country code.', example='629'),
      countryName?: string(name='CountryName', description='Country name.', example='China'),
      defaultSelected?: boolean(name='DefaultSelected', description='Monitor node default selection:
- true: Selected by default
- false: Not selected by default', example='true'),
      groupName?: string(name='GroupName', description='Monitoring probe group name.', example='BGP'),
      groupType?: string(name='GroupType', description='Monitoring node group type, currently supported:
- BGP: BGP node
- OVERSEAS: International node
- ISP: Carrier node', example='BGP'),
      ips?: {
        ip?: [ string ](name='Ip')
      }(name='Ips', description='List of node IP addresses.'),
      ispCode?: string(name='IspCode', description='Operator code.', example='465'),
      ispName?: string(name='IspName', description='Operator name.', example='Alibaba'),
      nodeId?: string(name='NodeId', description='Unique identifier ID of the probe node.', example='node-ewze1bysndy4gf**j8'),
    }
  ](name='Ipv6IspCityNode')
  }(name='Ipv6IspCityNodes', description='List of public IPv6 monitoring nodes.'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model ListCloudGtmMonitorNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCloudGtmMonitorNodesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListCloudGtmMonitorNodes  ListCloudGtmMonitorNodesRequest
  * @return ListCloudGtmMonitorNodesResponse
 */
async function listCloudGtmMonitorNodes(request: ListCloudGtmMonitorNodesRequest): ListCloudGtmMonitorNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCloudGtmMonitorNodes', 'POST', '/', 'json', false, 'json', request);
}

model ListCloudGtmMonitorTemplatesRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  ipVersion?: string(name='IpVersion', description='The IP address type of health check nodes. Valid values:

*   IPv4: applicable when health checks are performed on IPv4 addresses.
*   IPv6: applicable when health checks are performed on IPv6 addresses.', example='IPv4', position='Query'),
  name?: string(name='Name', description='The name of the health check probe template, which is recommended to be distinguishable for configuration personnel to differentiate and remember, ideally indicating the health check protocol.', example='IPv4-Ping', position='Query'),
  pageNumber: int32(name='PageNumber', description='Current page number, starting from **1**, default is **1**.

This parameter is required.', example='1', position='Query'),
  pageSize: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.

This parameter is required.', example='20', position='Query'),
  protocol?: string(name='Protocol', description='Protocol types for initiating probes to the target IP address:
- ping
- tcp
- http
- https', example='ping', position='Query'),
}

model ListCloudGtmMonitorTemplatesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from 1, default is 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.', example='20'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='75446CC1-FC9A-4595-8D96-089D73D7A63D'),
  templates?: {
    template?: [ 
    {
      createTime?: string(name='CreateTime', description='Health check template creation time.', example='2024-03-23T13:09Z'),
      createTimestamp?: long(name='CreateTimestamp', description='Health check template creation time (timestamp).', example='1527690629357'),
      evaluationCount?: int32(name='EvaluationCount', description='The number of retries. The system will only judge the application service as abnormal after consecutive monitoring failures to prevent inaccurate monitoring results due to momentary network fluctuations or other reasons. Available retry options are:
- 1 - 2 - 3', example='2'),
      extendInfo?: string(name='ExtendInfo', description='The extended information. The value of this parameter is a JSON string. The required parameters vary based on the health check protocol.

*   HTTP or HTTPS:

    **host**: the Host field of an HTTP or HTTPS request header during an HTTP or HTTPS health check. The parameter value indicates the HTTP website that you want to visit. By default, the value is the primary domain name. You can change the value based on your business requirements.

    **path**: the URL for HTTP or HTTPS health checks. Default value: /.

    **code**: the alert threshold. During an HTTP or HTTPS health check, the system checks whether a web server functions as expected based on the status code that is returned from the web server. If the returned status code is greater than the specified threshold, the corresponding application service address is deemed abnormal. Valid values:

    *   400: indicates an invalid request. If an HTTP or HTTPS request contains invalid request parameters, a web server returns a status code that is greater than 400. You must specify an exact URL for path if you set code to 400.
    *   500: indicates a server error. If some exceptions occur on a web server, the web server returns a status code that is greater than 500. This value is used by default.

    **sni**: indicates whether Server Name Indication (SNI) is enabled. This parameter is used only when the health check protocol is HTTPS. SNI is an extension to the Transport Layer Security (TLS) protocol, which allows a client to specify the host to be connected when the client sends a TLS handshake request. TLS handshakes occur before any data of HTTP requests is sent. Therefore, SNI enables servers to identify the services that clients are attempting to access before certificates are sent. This allows the servers to present correct certificates to the clients. Valid values:

    *   true: SNI is enabled.
    *   false: SNI is disabled.

    **followRedirect**: indicates whether 3XX redirects are followed. Valid values:

    *   true: 3XX redirects are followed. You are redirected to the destination address if a 3XX status code such as 301, 302, 303, 307, or 308 is returned.
    *   false: 3XX redirects are not followed.

*   ping:

    **packetNum**: the total number of Internet Control Message Protocol (ICMP) packets that are sent to the address for each ping-based health check. Valid values: 20, 50, and 100.

    **packetLossRate**: the ICMP packet loss rate for each ping-based health check. The packet loss rate in a health check can be calculated by using the following formula: Packet loss rate in a health check = (Number of lost packets/Total number of sent ICMP packets) × 100%. If the packet loss rate reaches the threshold, an alert is triggered. Valid values: 10, 30, 40, 80, 90, and 100.', example='{\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}'),
      failureRate?: int32(name='FailureRate', description='Percentage of selected node probe failures (%), that is, the percentage of unhealthy check points among total probe points. When the failure ratio exceeds the set threshold, the service address is judged as abnormal. The available failure ratio thresholds are:
- 20
- 50
- 80
- 100', example='50'),
      interval?: int32(name='Interval', description='The time interval between each check (in seconds), with a default of probing once every minute. The minimum supported health check interval is 15 seconds, available for flagship edition instances.', example='60'),
      ipVersion?: string(name='IpVersion', description='The IP address type of health check nodes. Valid values:

*   IPv4: applicable when health checks are performed on IPv4 addresses.
*   IPv6: applicable when health checks are performed on IPv6 addresses.', example='IPv4'),
      ispCityNodes?: {
        ispCityNode?: [ 
        {
          cityCode?: string(name='CityCode', description='City code.', example='738'),
          cityName?: string(name='CityName', description='City name.', example='Beijing'),
          countryCode?: string(name='CountryCode', description='Country code.', example='629'),
          countryName?: string(name='CountryName', description='Country name.', example='China'),
          groupName?: string(name='GroupName', description='Probe node group name.', example='BGP Nodes'),
          groupType?: string(name='GroupType', description='Probe node group types:
- BGP: BGP nodes
- OVERSEAS: International nodes
- ISP: Carrier nodes', example='BGP'),
          ispCode?: string(name='IspCode', description='Operator code.', example='465'),
          ispName?: string(name='IspName', description='Operator name.', example='Alibaba'),
        }
      ](name='IspCityNode')
      }(name='IspCityNodes', description='The health check nodes. You can call the [ListCloudGtmMonitorNodes](~~ListCloudGtmMonitorNodes~~) operation to obtain the health check nodes.'),
      name?: string(name='Name', description='The name of the health check probe template, generally for the convenience of configuration personnel to distinguish and remember.', example='IPv4-Ping'),
      protocol?: string(name='Protocol', description='Protocol types for initiating probes to the target IP address:
- ping
- tcp
- http
- https', example='ping'),
      remark?: string(name='Remark', description='Remarks for the health check template.', example='test'),
      templateId?: string(name='TemplateId', description='The ID of the health check template. This ID uniquely identifies the health check template.', example='mtp-89518052425100**80'),
      timeout?: int32(name='Timeout', description='Probe timeout (in milliseconds), data packets not returned within the timeout period are deemed as health check timeouts:
- 2000
- 3000
- 5000
- 10000', example='5000'),
      updateTime?: string(name='UpdateTime', description='Last modification time of the health check template.', example='2024-03-29T13:20Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='Health check template configuration modification time (timestamp).', example='1527690629357'),
    }
  ](name='Template')
  }(name='Templates', description='The health check templates.'),
  totalItems?: int32(name='TotalItems', description='Total number of health check template entries retrieved.', example='30'),
  totalPages?: int32(name='TotalPages', description='Total number of pages after data pagination.', example='2'),
}

model ListCloudGtmMonitorTemplatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCloudGtmMonitorTemplatesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListCloudGtmMonitorTemplates  ListCloudGtmMonitorTemplatesRequest
  * @return ListCloudGtmMonitorTemplatesResponse
 */
async function listCloudGtmMonitorTemplates(request: ListCloudGtmMonitorTemplatesRequest): ListCloudGtmMonitorTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCloudGtmMonitorTemplates', 'POST', '/', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en', position='Query'),
  nextToken?: string(name='NextToken', description='The pagination token. It can be used in the next request to retrieve a new page of results.', example='4698691', position='Query'),
  resourceId?: [ string ](name='ResourceId', description='The ID of the resource.', position='Query'),
  resourceType: string(name='ResourceType', description='The type of the resource. Valid values:

*   **DOMAIN**: domain name

This parameter is required.', example='DOMAIN', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='abcd'),
      value?: string(name='Value', description='The key value.', example='abcd'),
    }
  ](name='Tag', description='The tags.', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. If NextToken is empty, no next page exists.', example='4698691'),
  requestId?: string(name='RequestId', description='The request ID.', example='61092C8D-6AEB-4310-B74D-C632F89BF4FB'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId', description='The ID of the resource.', example='dns-example.com'),
      resourceType?: string(name='ResourceType', description='The type of the resource. Only DOMAIN is returned.', example='DOMAIN'),
      tagKey?: string(name='TagKey', description='The tag key.', example='abcd'),
      tagValue?: string(name='TagValue', description='The tag value.', example='abcd'),
    }
  ](name='TagResources', description='An array that consists of the resource and the tags that are added to the resource, including information such as the resource ID, resource type, tag keys, and tag values.'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesResponseBody(name='body'),
}

/**
  * @description *   Set ResourceId.N or Tag.N that consists of Tag.N.Key and Tag.N.Value in the request to specify the object to be queried.
  * *   Tag.N is a resource tag that consists of a key-value pair. If you set only Tag.N.Key, all tag values that are assigned to the specified key are returned. If you set only Tag.N.Value, an error message is returned.
  * *   If you set both Tag.N and ResourceId.N to filter tags, ResourceId.N must match all specified key-value pairs.
  * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
  * @param request  the request parameters of ListTagResources  ListTagResourcesRequest
  * @return ListTagResourcesResponse
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', '/', 'json', false, 'json', request);
}

model ModifyHichinaDomainDNSRequest {
  domainName: string(name='DomainName', description='The domain name.

This parameter is required.', example='example.com', position='Query'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en', example='en', position='Query'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0', position='Query'),
}

model ModifyHichinaDomainDNSResponseBody = {
  newDnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='NewDnsServers', description='The DNS server names after modification.'),
  originalDnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='OriginalDnsServers', description='The DNS server names before modification.'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model ModifyHichinaDomainDNSResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyHichinaDomainDNSResponseBody(name='body'),
}

/**
  * @description If the operation succeeds, the names of DNS servers change to those of Alibaba Cloud DNS servers (ending with hichina.com).
  * >  **Before you call this operation, make sure that your domain name has been registered with Alibaba Cloud and the DNS servers in use are not Alibaba Cloud DNS servers.
  * @param request  the request parameters of ModifyHichinaDomainDNS  ModifyHichinaDomainDNSRequest
  * @return ModifyHichinaDomainDNSResponse
 */
async function modifyHichinaDomainDNS(request: ModifyHichinaDomainDNSRequest): ModifyHichinaDomainDNSResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyHichinaDomainDNS', 'POST', '/', 'json', false, 'json', request);
}

model MoveDomainResourceGroupRequest {
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
  newResourceGroupId: string(name='NewResourceGroupId', description='The ID of the new resource group.

You can view the resource group ID in the [Resource Management console](https://resourcemanager.console.aliyun.com/resource-groups?).

This parameter is required.', example='rg-aekzzk7hx3glaoq', position='Query'),
  resourceId: string(name='ResourceId', description='The domain name.

This parameter is required.', example='example.com', position='Query'),
}

model MoveDomainResourceGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='C6F1D541-E7A6-447A-A2B5-9F7A20B2A8FB'),
}

model MoveDomainResourceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MoveDomainResourceGroupResponseBody(name='body'),
}

/**
  * @param request  the request parameters of MoveDomainResourceGroup  MoveDomainResourceGroupRequest
  * @return MoveDomainResourceGroupResponse
 */
async function moveDomainResourceGroup(request: MoveDomainResourceGroupRequest): MoveDomainResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'MoveDomainResourceGroup', 'POST', '/', 'json', false, 'json', request);
}

model MoveGtmResourceGroupRequest {
  lang?: string(name='Lang', example='en', position='Query'),
  newResourceGroupId: string(name='NewResourceGroupId', description='This parameter is required.', example='AgIDE1MA_XXX', position='Query'),
  resourceId: string(name='ResourceId', description='This parameter is required.', example='rg-aekzzk7hx3*****', position='Query'),
}

model MoveGtmResourceGroupResponseBody = {
  requestId?: string(name='RequestId', example='C6F1D541-E7A6-447A-A2B5-9F7A20B2A8FB'),
}

model MoveGtmResourceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MoveGtmResourceGroupResponseBody(name='body'),
}

/**
  * @param request  the request parameters of MoveGtmResourceGroup  MoveGtmResourceGroupRequest
  * @return MoveGtmResourceGroupResponse
 */
async function moveGtmResourceGroup(request: MoveGtmResourceGroupRequest): MoveGtmResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'MoveGtmResourceGroup', 'POST', '/', 'json', false, 'json', request);
}

model OperateBatchDomainRequest {
  domainRecordInfo: [ 
    {
      domain: string(name='Domain', description='The domain name.

>  You can submit 1 to 1,000 domain names. Due to the limit on the length of HTTP request headers, excessive domain names are ignored. Do not enter more than 1,000 domain names.

This parameter is required.', example='example.com'),
      line?: string(name='Line', description='The DNS request source. Default value: default.', example='default'),
      newRr?: string(name='NewRr', description='The new hostname (used only for modification operations, not for external users).', example='mail'),
      newType?: string(name='NewType', description='The new type of the DNS record (used only for modification operations, not for external users).', example='AAAA'),
      newValue?: string(name='NewValue', description='The new value of the DNS record (used only for modification operations, not for external users).', example='114.92.XX.XX'),
      priority?: int32(name='Priority', description='The priority of the mail exchanger (MX) record.

This parameter is required if the type of the DNS record is MX. Default value: 10.', example='5'),
      rr?: string(name='Rr', description='The hostname.

>  This parameter is required if you set Type to **RR_ADD** or **RR_DEL**.', example='zhaohui'),
      ttl?: int32(name='Ttl', description='The time-to-live (TTL) value of the cached DNS record. Unit: seconds. Default value: ***600***.', example='600'),
      type?: string(name='Type', description='The type of the DNS record. Valid values: A, AAAA, TXT, MX, and CNAME.

>  This parameter is required if you set Type to **RR_ADD** or **RR_DEL**.', example='MX'),
      value?: string(name='Value', description='The value of the DNS record.

>  This parameter is required if you set Type to **RR_ADD** or **RR_DEL**.', example='fd87da3c4528844d45af39200155a905'),
    }
  ](name='DomainRecordInfo', description='The DNS records. You can submit up to 1,000 DNS records.

This parameter is required.', position='Query'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: zh', example='en', position='Query'),
  type: string(name='Type', description='The type of the batch operation. Valid values:

*   **DOMAIN_ADD**: adds domain names in batches.
*   **DOMAIN_DEL**: deletes domain names in batches.
*   **RR_ADD**: adds DNS records in batches.
*   **RR_DEL**: deletes DNS records in batches. This operation deletes the DNS records with the specified hostname or record value. If you do not specify the Rr and Value parameters, this operation deletes the DNS records that are added for the specified domain names.

This parameter is required.', example='RR_ADD', position='Query'),
}

model OperateBatchDomainResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='75446CC1-FC9A-4595-8D96-089D73D7A63D'),
  taskId?: long(name='TaskId', description='The task ID.', example='345345'),
}

model OperateBatchDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OperateBatchDomainResponseBody(name='body'),
}

/**
  * @description Scenario: You need to execute a large number of tasks related to DNS resolution and you do not have high requirements for efficiency.
  * @param request  the request parameters of OperateBatchDomain  OperateBatchDomainRequest
  * @return OperateBatchDomainResponse
 */
async function operateBatchDomain(request: OperateBatchDomainRequest): OperateBatchDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OperateBatchDomain', 'POST', '/', 'json', false, 'json', request);
}

model PausePdnsServiceRequest {
  lang?: string(name='Lang', position='Query'),
  serviceType?: string(name='ServiceType', position='Query'),
}

model PausePdnsServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model PausePdnsServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PausePdnsServiceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PausePdnsService  PausePdnsServiceRequest
  * @return PausePdnsServiceResponse
 */
async function pausePdnsService(request: PausePdnsServiceRequest): PausePdnsServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PausePdnsService', 'POST', '/', 'json', false, 'json', request);
}

model PreviewGtmRecoveryPlanRequest {
  lang?: string(name='Lang', description='The language used by the user.', example='en', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on per page. Maximum value: **20**. Default value: **5**.', example='5', position='Query'),
  recoveryPlanId: long(name='RecoveryPlanId', description='The ID of the disaster recovery plan that you want to preview.

This parameter is required.', example='100', position='Query'),
}

model PreviewGtmRecoveryPlanResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='5'),
  previews?: {
    preview?: [ 
    {
      instanceId?: string(name='InstanceId', description='The ID of the GTM instance to which the previewed disaster recovery plan belongs.', example='instance-example'),
      name?: string(name='Name', description='The name of the GTM instance to which the previewed disaster recovery plan belongs.', example='name-example'),
      switchInfos?: {
        switchInfo?: [ 
        {
          content?: string(name='Content', description='The formatted message content.'),
          strategyName?: string(name='StrategyName', description='The name of the switching policy for address pools.', example='strategy-name-example-1'),
        }
      ](name='SwitchInfo')
      }(name='SwitchInfos', description='The returned information of the switching policies for address pools.'),
      userDomainName?: string(name='UserDomainName', description='The user\\"s domain name or domain name list.', example='30.yyy.com'),
    }
  ](name='Preview')
  }(name='Previews', description='The returned preview information of the disaster recovery plan.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='853805EA-3D47-47D5-9A1A-A45C24313ABD'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned on all pages.', example='15'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='3'),
}

model PreviewGtmRecoveryPlanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PreviewGtmRecoveryPlanResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PreviewGtmRecoveryPlan  PreviewGtmRecoveryPlanRequest
  * @return PreviewGtmRecoveryPlanResponse
 */
async function previewGtmRecoveryPlan(request: PreviewGtmRecoveryPlanRequest): PreviewGtmRecoveryPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PreviewGtmRecoveryPlan', 'POST', '/', 'json', false, 'json', request);
}

model RemovePdnsAppKeyRequest {
  appKeyId?: string(name='AppKeyId', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model RemovePdnsAppKeyResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemovePdnsAppKeyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemovePdnsAppKeyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RemovePdnsAppKey  RemovePdnsAppKeyRequest
  * @return RemovePdnsAppKeyResponse
 */
async function removePdnsAppKey(request: RemovePdnsAppKeyRequest): RemovePdnsAppKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemovePdnsAppKey', 'POST', '/', 'json', false, 'json', request);
}

model RemovePdnsUdpIpSegmentRequest {
  ip?: string(name='Ip', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model RemovePdnsUdpIpSegmentResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemovePdnsUdpIpSegmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemovePdnsUdpIpSegmentResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RemovePdnsUdpIpSegment  RemovePdnsUdpIpSegmentRequest
  * @return RemovePdnsUdpIpSegmentResponse
 */
async function removePdnsUdpIpSegment(request: RemovePdnsUdpIpSegmentRequest): RemovePdnsUdpIpSegmentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemovePdnsUdpIpSegment', 'POST', '/', 'json', false, 'json', request);
}

model ReplaceCloudGtmAddressPoolAddressRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   **zh-CN**: Chinese
*   **en-US (default)**: English', example='en-US', position='Query'),
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool for which you want to replace addresses. This ID uniquely identifies the address pool.', example='pool-89618921167339**24', position='Query'),
  addresses?: [ 
    {
      addressId?: string(name='AddressId', description='The ID of the new address. This ID uniquely identifies the address.

*   If you specify this parameter, the original addresses in the address pool will be deleted and replaced with new addresses.
*   If you do not specify this parameter, all addresses in the address pool will be deleted and the address pool will be left empty.', example='addr-89636516932803**44'),
      requestSource?: [ string ](name='RequestSource', description='The DNS request sources.'),
      serialNumber?: int32(name='SerialNumber', description='The sequence number that specifies the priority for returning the new address. A smaller sequence number specifies a higher priority. This setting takes effect for new addresses.', example='1'),
      weightValue?: int32(name='WeightValue', description='The weight value of the new address. You can set a different weight value for each address. This way, addresses are returned based on the weight values for Domain Name System (DNS) requests. A weight value must be an integer that ranges from 1 to 100. This setting takes effect for new addresses.', example='1'),
    }
  ](name='Addresses', description='The addresses.', shrink='json', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
}

model ReplaceCloudGtmAddressPoolAddressResponseBody = {
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89618921167339**24'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
  success?: boolean(name='Success', description='Indicates whether the operation was successful:
- true: Successful. - false: Failed.', example='true'),
}

model ReplaceCloudGtmAddressPoolAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReplaceCloudGtmAddressPoolAddressResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ReplaceCloudGtmAddressPoolAddress  ReplaceCloudGtmAddressPoolAddressRequest
  * @return ReplaceCloudGtmAddressPoolAddressResponse
 */
async function replaceCloudGtmAddressPoolAddress(request: ReplaceCloudGtmAddressPoolAddressRequest): ReplaceCloudGtmAddressPoolAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReplaceCloudGtmAddressPoolAddress', 'POST', '/', 'json', false, 'json', request);
}

model ReplaceCloudGtmInstanceConfigAddressPoolRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  addressPools?: [ 
    {
      addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.

*   If you specify this parameter, the address pools that are associated with the desired instance are removed and the instance is associated with new address pools.
*   If this parameter is left empty, the address pools that are associated with the desired instance are removed and no address pool is associated with the instance.', example='pool-89564542105737**12'),
      requestSource?: [ string ](name='RequestSource', description='The DNS request sources.'),
      serialNumber?: int32(name='SerialNumber', description='The sequence number of the new address pool. The address pool with the smallest sequence number is preferentially returned for DNS requests from any source. The sequence number specifies the priority for returning the address pool. A smaller sequence number specifies a higher priority.', example='1'),
      weightValue?: int32(name='WeightValue', description='The weight value of the new address pool. You can set a different weight value for each address pool. This way, address pools are returned based on the weight values for Domain Name System (DNS) requests. A weight value must be an integer that ranges from 1 to 100.', example='1'),
    }
  ](name='AddressPools', description='The address pools.', shrink='json', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.

You can call the [ListCloudGtmInstanceConfigs](~~ListCloudGtmInstanceConfigs~~) operation to query the configuration ID of the access domain name.', example='Config-000**11', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance for which you want to change address pools.', example='gtm-cn-wwo3a3hbz**', position='Query'),
}

model ReplaceCloudGtmInstanceConfigAddressPoolResponseBody = {
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  success?: boolean(name='Success', description='Indicates whether the operation was successful, with values: 
- true: Success. 
- false: Failure.', example='true'),
}

model ReplaceCloudGtmInstanceConfigAddressPoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReplaceCloudGtmInstanceConfigAddressPoolResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ReplaceCloudGtmInstanceConfigAddressPool  ReplaceCloudGtmInstanceConfigAddressPoolRequest
  * @return ReplaceCloudGtmInstanceConfigAddressPoolResponse
 */
async function replaceCloudGtmInstanceConfigAddressPool(request: ReplaceCloudGtmInstanceConfigAddressPoolRequest): ReplaceCloudGtmInstanceConfigAddressPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReplaceCloudGtmInstanceConfigAddressPool', 'POST', '/', 'json', false, 'json', request);
}

model ResumePdnsServiceRequest {
  lang?: string(name='Lang', position='Query'),
  serviceType?: string(name='ServiceType', position='Query'),
}

model ResumePdnsServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResumePdnsServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResumePdnsServiceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ResumePdnsService  ResumePdnsServiceRequest
  * @return ResumePdnsServiceResponse
 */
async function resumePdnsService(request: ResumePdnsServiceRequest): ResumePdnsServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResumePdnsService', 'POST', '/', 'json', false, 'json', request);
}

model RetrieveDomainRequest {
  domainName: string(name='DomainName', description='The domain name.

This parameter is required.', example='example.com', position='Query'),
  lang?: string(name='Lang', description='The language.', example='en', position='Query'),
}

model RetrieveDomainResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9CC0D642-49D4-48DE-A1A5-9F218652E4A7'),
}

model RetrieveDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RetrieveDomainResponseBody(name='body'),
}

/**
  * @description To retrieve a domain name, you must verify a text (TXT) record. Therefore, before you call this API operation to retrieve a domain name, call the [GetTxtRecordForVerify](https://www.alibabacloud.com/help/en/alibaba-cloud-dns/latest/generating-a-txt-record) operation to generate a TXT record.
  * @param request  the request parameters of RetrieveDomain  RetrieveDomainRequest
  * @return RetrieveDomainResponse
 */
async function retrieveDomain(request: RetrieveDomainRequest): RetrieveDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RetrieveDomain', 'POST', '/', 'json', false, 'json', request);
}

model RollbackGtmRecoveryPlanRequest {
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en.', example='en', position='Query'),
  recoveryPlanId: long(name='RecoveryPlanId', description='The ID of the disaster recovery plan.

This parameter is required.', example='100', position='Query'),
}

model RollbackGtmRecoveryPlanResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='853805EA-3D47-47D5-9A1A-A45C24313ABD'),
}

model RollbackGtmRecoveryPlanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RollbackGtmRecoveryPlanResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RollbackGtmRecoveryPlan  RollbackGtmRecoveryPlanRequest
  * @return RollbackGtmRecoveryPlanResponse
 */
async function rollbackGtmRecoveryPlan(request: RollbackGtmRecoveryPlanRequest): RollbackGtmRecoveryPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RollbackGtmRecoveryPlan', 'POST', '/', 'json', false, 'json', request);
}

model SearchCloudGtmAddressPoolsRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  addressPoolName?: string(name='AddressPoolName', description='Address pool name, supports fuzzy search for the entered address pool name.', example='AddressPool-1', position='Query'),
  addressPoolType?: string(name='AddressPoolType', description='Address pool type, supports precise query for address pool types:
- IPv4
- IPv6
- domain', example='IPv4', position='Query'),
  availableStatus?: string(name='AvailableStatus', description='Address pool availability status, supporting precise queries for address pool availability:
- available: Available
- unavailable: Unavailable', example='available', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  enableStatus?: string(name='EnableStatus', description='Address pool enable status, supports precise query of address pool enable status:
- enable: Enabled status
- disable: Disabled status', example='enable', position='Query'),
  healthStatus?: string(name='HealthStatus', description='The health state of the address pool. You can enter a health state for exact search. Valid values:

ok: The health state of the address pool is normal and all addresses that are referenced by the address pool are available.

ok_alert: The health state of the address pool is warning and some of the addresses that are referenced by the address pool are unavailable. However, the address pool is deemed normal. In this case, only the available addresses are returned for Domain Name System (DNS) requests.

exceptional: The health state of the address pool is abnormal and some or all of the addresses that are referenced by the address pool are unavailable. In this case, the address pool is deemed abnormal.', example='ok', position='Query'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from 1, default is 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.', example='20', position='Query'),
  remark?: string(name='Remark', description='Address pool remarks, supporting fuzzy search for the input remarks.', example='test', position='Query'),
}

model SearchCloudGtmAddressPoolsResponseBody = {
  addressPools?: {
    addressPool?: [ 
    {
      addressLbStrategy?: string(name='AddressLbStrategy', description='Load balancing policy among addresses in the address pool:
- round_robin: Round-robin, for any source of DNS resolution requests, returns all addresses and rotates the order of all addresses each time.
- sequence: Sequential, for any source of DNS resolution requests, returns the address with the smaller sequence number (the sequence number indicates the priority of the address return, the smaller the higher the priority). If the address with the smaller sequence number is unavailable, return the next address with a smaller sequence number.
- weight: Weighted, supports setting different weight values for each address to realize returning addresses according to the weight ratio for resolution queries.
- source_nearest: Source-nearest, i.e., intelligent resolution function, where GTM can return different addresses based on the source of different DNS resolution requests, achieving the effect of users accessing nearby.', example='round_robin'),
      addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-895280232254422016'),
      addressPoolName?: string(name='AddressPoolName', description='Address pool name.', example='AddressPool-1'),
      addressPoolType?: string(name='AddressPoolType', description='Address pool type:
- IPv4
- IPv6
- domain', example='IPv4'),
      addresses?: {
        address?: [ 
        {
          address?: string(name='Address', description='IP address or domain name.', example='223.5.XX.XX'),
          addressId?: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.', example='addr-895182181143688192'),
          attributeInfo?: string(name='AttributeInfo', description='Address ownership information, not supported in the current version.', example='Not supported in the current version.'),
          availableMode?: string(name='AvailableMode', description='The failover method that is used if the address fails health checks. Valid values:

*   auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
*   manual: the manual mode. If an address is in the unavailable state, the address is not returned for DNS requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.', example='auto'),
          availableStatus?: string(name='AvailableStatus', description='Address availability status:
- available: Address is available
- unavailable: Address is unavailable', example='available'),
          createTime?: string(name='CreateTime', description='Address creation time.', example='2024-03-15T01:46Z'),
          createTimestamp?: long(name='CreateTimestamp', description='Address creation time (timestamp).', example='1527690629357'),
          enableStatus?: string(name='EnableStatus', description='Address enable status, indicating whether the address is currently available:
- enable: Enabled status 
- disable: Disabled status', example='enable'),
          healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address. Valid values:

*   any_ok: The health check results of at least one health check template are normal.
*   p30_ok: The health check results of at least 30% of health check templates are normal.
*   p50_ok: The health check results of at least 50% of health check templates are normal.
*   p70_ok: The health check results of at least 70% of health check templates are normal.
*   all_ok: The health check results of all health check templates are normal.', example='any_ok'),
          healthStatus?: string(name='HealthStatus', description='The health check state of the address. Valid values:

*   ok: The address passes all health checks of the referenced health check templates.
*   ok_alert: The address fails some health checks of the referenced health check templates but the address is deemed normal.
*   ok_no_monitor: The address does not reference a health check template and is normal.
*   exceptional: The address fails some or all health checks of the referenced health check templates and the address is deemed abnormal.', example='ok'),
          healthTasks?: {
            healthTask?: [ 
            {
              port?: int32(name='Port', description='The target service port for health checks. When the Ping protocol is selected for health checks, configuration of the service port is not supported.', example='80'),
              templateId?: string(name='TemplateId', description='The ID of the health check template associated with the address.', example='mtp-89518052425100**80'),
              templateName?: string(name='TemplateName', description='Health check template name.', example='IPv4-Ping'),
            }
          ](name='HealthTask')
          }(name='HealthTasks', description='The health check tasks.'),
          manualAvailableStatus?: string(name='ManualAvailableStatus', description='The availability state of the address when AvailableMode is set to manual. Valid values:

*   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
*   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.', example='available'),
          name?: string(name='Name', description='Address name.', example='Address-1'),
          remark?: string(name='Remark', description='Remarks.', example='test'),
          requestSource?: string(name='RequestSource', description='Request source, referring to the source of the request. GTM schedules based on the exit IP of the LocalDNS used by the terminal. If the LocalDNS supports ECS (edns-client-subnet), intelligent scheduling can also be performed based on the IP of the visiting terminal.', example='default'),
          serialNumber?: int32(name='SerialNumber', description='Sequence number, indicating the priority of address return, where smaller numbers have higher priority.', example='1'),
          type?: string(name='Type', description='Address type:
- IPv4: ipv4 address - IPv6: ipv6 address - domain: domain name', example='IPv4'),
          updateTime?: string(name='UpdateTime', description='The last time the address was modified.', example='2024-03-15T01:46Z'),
          updateTimestamp?: long(name='UpdateTimestamp', description='The last modification time of the address (timestamp).', example='1527690629357'),
          weightValue?: int32(name='WeightValue', description='Weight value (an integer between 1 and 100), allowing different weight values to be set for each address, enabling resolution queries to return addresses according to the weighted ratio.', example='1'),
        }
      ](name='Address')
      }(name='Addresses', description='The IP addresses or domain names.'),
      availableStatus?: string(name='AvailableStatus', description='Address pool availability status:
- available: Available
- unavailable: Unavailable', example='available'),
      createTime?: string(name='CreateTime', description='Address pool creation time.', example='2024-03-15T01:46Z'),
      createTimestamp?: long(name='CreateTimestamp', description='Address pool creation time (timestamp).', example='1527690629357'),
      enableStatus?: string(name='EnableStatus', description='Address pool status:
- enable: Enabled status
- disable: Disabled status', example='enable'),
      healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address pool. Valid values:

*   any_ok: At least one address in the address pool is available.
*   p30_ok: At least 30% of the addresses in the address pool are available.
*   p50_ok: At least 50% of the addresses in the address pool are available.
*   p70_ok: At least 70% of the addresses in the address pool are available.
*   all_ok: All addresses in the address pool are available.', example='any_ok'),
      healthStatus?: string(name='HealthStatus', description='The health state of the address pool. Valid values:

*   ok: The health state of the address pool is normal and all addresses that are referenced by the address pool are available.
*   ok_alert: The health state of the address pool is warning and some of the addresses that are referenced by the address pool are unavailable. However, the address pool is deemed normal. In this case, only the available addresses are returned for DNS requests.
*   exceptional: The health state of the address pool is abnormal and some or all of the addresses that are referenced by the address pool are unavailable. In this case, the address pool is deemed abnormal.', example='ok'),
      remark?: string(name='Remark', description='Address remarks.', example='test'),
      sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address with the smallest sequence number is recovered. This parameter is returned only when the policy for load balancing between addresses is sequence. Valid values:

*   preemptive: The address with the smallest sequence number is preferentially used if this address is recovered.
*   non_preemptive: The current address is still used even if the address with the smallest sequence number is recovered.', example='preemptive'),
      updateTime?: string(name='UpdateTime', description='Last modification time of the address pool.', example='024-03-15T01:46Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='Last modification time of the address pool (timestamp).', example='1527690629357'),
    }
  ](name='AddressPool')
  }(name='AddressPools', description='The address pools.'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from 1, default is 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.', example='20'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalItems?: int32(name='TotalItems', description='Total number of address pools matching the query conditions.', example='11'),
  totalPages?: int32(name='TotalPages', description='Total number of pages.', example='1'),
}

model SearchCloudGtmAddressPoolsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchCloudGtmAddressPoolsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SearchCloudGtmAddressPools  SearchCloudGtmAddressPoolsRequest
  * @return SearchCloudGtmAddressPoolsResponse
 */
async function searchCloudGtmAddressPools(request: SearchCloudGtmAddressPoolsRequest): SearchCloudGtmAddressPoolsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchCloudGtmAddressPools', 'POST', '/', 'json', false, 'json', request);
}

model SearchCloudGtmAddressesRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  address?: string(name='Address', description='Query by service address with precise conditions, supporting IP addresses or domain names.', example='223.5.XX.XX', position='Query'),
  addressId?: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.', example='addr-89518218114368**92', position='Query'),
  availableStatus?: string(name='AvailableStatus', description='Search by address availability status with precise conditions:
- available
- unavailable', example='available', position='Query'),
  enableStatus?: string(name='EnableStatus', description='Query by exact address enable status:
- enable: enabled status
- disable: disabled status', example='enable', position='Query'),
  healthStatus?: string(name='HealthStatus', description='The health state of the addresses that you want to query. Valid values:

*   ok: The addresses pass all health checks of the referenced health check templates.
*   ok_alert: The addresses fail some health checks of the referenced health check templates, but the addresses are deemed available.
*   ok_no_monitor: The addresses do not reference any health check template.
*   exceptional: The addresses fail some or all health checks of the referenced health check templates, and the addresses are deemed unavailable.', example='ok', position='Query'),
  monitorTemplateName?: string(name='MonitorTemplateName', description='Health check template name.', example='Ping-IPv4', position='Query'),
  nameSearchCondition?: string(name='NameSearchCondition', description='The logical condition for querying addresses by name. This parameter is required if you want to query addresses by name. Valid values:

*   and: displays the results that match all search conditions.
*   or: displays the results that match some or all search conditions.', example='or', position='Query'),
  names?: [ string ](name='Names', description='Address name, usually for users to distinguish between different addresses.', position='Query'),
  pageNumber: int32(name='PageNumber', description='Current page number, starting from 1, default is 1.

This parameter is required.', example='1', position='Query'),
  pageSize: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.

This parameter is required.', example='20', position='Query'),
  remarkSearchCondition?: string(name='RemarkSearchCondition', description='The logical condition for querying addresses by additional description. This parameter is required if you want to query addresses by additional description. Valid values:

and: displays the results that match all search conditions.

or: displays the results that match some or all search conditions.', example='or', position='Query'),
  remarks?: [ string ](name='Remarks', description='Remarks for the address.', position='Query'),
  type?: string(name='Type', description='Search precisely by address type conditions:
- IPv4
- IPv6
- domain', example='IPv4', position='Query'),
}

model SearchCloudGtmAddressesResponseBody = {
  addresses?: {
    address?: [ 
    {
      address?: string(name='Address', description='IP address or domain name.', example='223.5.XX.XX'),
      addressId?: string(name='AddressId', description='ID of the address, unique identifier for the address.', example='addr-89518218114368**92'),
      attributeInfo?: string(name='AttributeInfo', description='Address ownership information, not supported in the current version.', example='The parameter should be none.'),
      availableMode?: string(name='AvailableMode', description='The failover method that is used if the address fails health checks. Valid values:

*   auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
*   manual: the manual mode. If an address is in the unavailable state, the address is not returned for Domain Name System (DNS) requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.', example='auto'),
      availableStatus?: string(name='AvailableStatus', description='The availability state of the address when AvailableMode is set to manual. Valid values:

*   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
*   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.', example='available'),
      createTime?: string(name='CreateTime', description='Creation time of the address.', example='2024-03-23T13:09Z'),
      createTimestamp?: long(name='CreateTimestamp', description='Creation time of the address (timestamp).', example='1527690629357'),
      enableStatus?: string(name='EnableStatus', description='Current activation status of the address:
- enable: Enabled status
- disable: Disabled status', example='enable'),
      healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address. Valid values:

*   any_ok: The health check results of at least one health check template are normal.
*   p30_ok: The health check results of at least 30% of health check templates are normal.
*   p50_ok: The health check results of at least 50% of health check templates are normal.
*   p70_ok: The health check results of at least 70% of health check templates are normal.
*   all_ok: The health check results of all health check templates are normal.', example='p50_ok'),
      healthStatus?: string(name='HealthStatus', description='The health check state of the address. Valid values:

*   ok: The address passes all health checks of the referenced health check templates.
*   ok_alert: The address fails some health checks of the referenced health check templates, but the address is deemed available.
*   ok_no_monitor: The address does not reference any health check template.
*   exceptional: The address fails some or all health checks of the referenced health check templates, and the address is deemed unavailable.', example='ok'),
      healthTasks?: {
        healthTask?: [ 
        {
          monitorStatus?: string(name='MonitorStatus', description='The state of the health check task. Valid values:

*   ok: The task is normal.
*   alert: The task has an alert.
*   no_data: No data is available. In most cases, the health check task is newly created and no data is collected.', example='ok'),
          port?: int32(name='Port', description='The target service port for health check probes. When the health check protocol is set to Ping, configuration of the service port is not supported.', example='80'),
          templateId?: string(name='TemplateId', description='The ID of the health check template associated with the address.', example='mtp-895180524251002880'),
          templateName?: string(name='TemplateName', description='Health check template name.', example='IPv4-Ping'),
        }
      ](name='HealthTask')
      }(name='HealthTasks', description='The health check tasks.'),
      manualAvailableStatus?: string(name='ManualAvailableStatus', description='The availability state of the address when AvailableMode is set to manual. Valid values:

*   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
*   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.', example='available'),
      name?: string(name='Name', description='Address name.', example='Address-1'),
      remark?: string(name='Remark', description='Remarks.', example='test'),
      type?: string(name='Type', description='Address type:
- IPv4: ipv4 address - IPv6: ipv6 address - domain: domain name', example='IPv4'),
      updateTime?: string(name='UpdateTime', description='The last modification time of the address.', example='2024-03-29T13:20Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The last modification time of the address (timestamp).', example='1527690629357'),
    }
  ](name='Address')
  }(name='Addresses', description='The addresses.'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from **1**, default is **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of **100** and a default of **20**.', example='20'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalItems?: int32(name='TotalItems', description='Total number of address entries that meet the query conditions.', example='15'),
  totalPages?: int32(name='TotalPages', description='Total number of pages.', example='1'),
}

model SearchCloudGtmAddressesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchCloudGtmAddressesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SearchCloudGtmAddresses  SearchCloudGtmAddressesRequest
  * @return SearchCloudGtmAddressesResponse
 */
async function searchCloudGtmAddresses(request: SearchCloudGtmAddressesRequest): SearchCloudGtmAddressesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchCloudGtmAddresses', 'POST', '/', 'json', false, 'json', request);
}

model SearchCloudGtmInstanceConfigsRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='zh-CN', position='Query'),
  availableStatus?: string(name='AvailableStatus', description='The availability state of the access domain name. Valid values:

*   available: If the access domain name is **enabled** and the health state is **normal**, the access domain name is deemed **available**.
*   unavailable: If the access domain name is **disabled** or the health state is **abnormal**, the access domain name is deemed **unavailable**.', example='available', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  enableStatus?: string(name='EnableStatus', description='The enabling state of the access domain name. Valid values:

*   enable: The access domain name is enabled and the intelligent scheduling policy of the corresponding GTM instance takes effect.
*   disable: The access domain name is disabled and the intelligent scheduling policy of the corresponding GTM instance does not take effect.', example='enable', position='Query'),
  healthStatus?: string(name='HealthStatus', description='The health state of the access domain name. Valid values:

*   ok: The health state of the access domain name is normal and all address pools that are referenced by the access domain name are available.
*   ok_alert: The health state of the access domain name is warning and some of the address pools that are referenced by the access domain name are unavailable. In this case, only the available address pools are returned for Domain Name System (DNS) requests.
*   exceptional: The health state of the access domain name is abnormal and all address pools that are referenced by the access domain name are unavailable. In this case, addresses in the non-empty address pool with the smallest sequence number are preferentially used for fallback resolution. This returns DNS results for clients as much as possible.', example='ok', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the Global Traffic Manager (GTM) 3.0 instance.', example='gtm-cn-wwo3a3hbz**', position='Query'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from 1, default is 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of **100**, and a default of **20**.', example='20', position='Query'),
  remark?: string(name='Remark', description='Remarks for the domain instance.', example='test', position='Query'),
  scheduleDomainName?: string(name='ScheduleDomainName', description='The access domain name. The value of this parameter is composed of the value of ScheduleHostname and the value of ScheduleZoneName.', example='www.example.com', position='Query'),
  scheduleZoneName?: string(name='ScheduleZoneName', description='The zone such as example.com or subzone such as a.example.com of the access domain name. In most cases, the zone or subzone is hosted by the Public Authoritative DNS module of Alibaba Cloud DNS. This zone belongs to the account to which the GTM instance belongs.', example='example.com', position='Query'),
}

model SearchCloudGtmInstanceConfigsResponseBody = {
  instanceConfigs?: {
    instanceConfig?: [ 
    {
      addressPoolLbStrategy?: string(name='AddressPoolLbStrategy', description='The policy for load balancing between address pools. Valid values:

*   round_robin: All address pools are returned for DNS requests from any source. All address pools are sorted in round-robin mode each time they are returned.
*   sequence: The address pool with the smallest sequence number is preferentially returned for DNS requests from any source. The sequence number indicates the priority for returning the address pool. A smaller sequence number indicates a higher priority. If the address pool with the smallest sequence number is unavailable, the address pool with the second smallest sequence number is returned.
*   weight: You can set a different weight value for each address pool. This way, address pools are returned based on the weight values.
*   source_nearest: Different address pools are returned based on the sources of DNS requests. This way, users can access nearby address pools.', example='round_robin'),
      addressPools?: {
        addressPool?: [ 
        {
          addressLbStrategy?: string(name='AddressLbStrategy', description='Load balancing policy among addresses in the address pool:
- round_robin: Round-robin, where for any source of DNS resolution requests, all addresses are returned, with a rotation of the order for every request.
- sequence: Sequential, where for any source of DNS resolution requests, the address with the lower sequence number (indicating a higher priority, the smaller the number, the higher the priority) is returned. If the address with the lower sequence number is unavailable, the next address with a lower sequence number is returned.
- weight: Weighted, supporting the setting of different weight values for each address to realize returning addresses according to the ratio of weights in DNS query resolutions.
- source_nearest: Source-nearest, referring to the intelligent resolution feature, where GTM can return different addresses based on the source of different DNS resolution requests, achieving the effect of users accessing the nearest server.', example='round_robin'),
          addressPoolId?: string(name='AddressPoolId', description='Address pool ID, uniquely identifying the address pool.', example='pool-89564504435014**60'),
          addressPoolName?: string(name='AddressPoolName', description='Address pool name.', example='AddressPool-1'),
          addressPoolType?: string(name='AddressPoolType', description='Address pool type:
- IPv4
- IPv6
- domain', example='IPv4'),
          availableStatus?: string(name='AvailableStatus', description='Address pool availability status:
- available: Available
- unavailable: Unavailable', example='available'),
          createTime?: string(name='CreateTime', description='Address pool creation time.', example='2024-03-15T01:46Z'),
          createTimestamp?: long(name='CreateTimestamp', description='Address pool creation time (timestamp).', example='1527690629357'),
          enableStatus?: string(name='EnableStatus', description='Address pool status:
- enable: Enabled status
- disable: Disabled status', example='enable'),
          healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address pool. Valid values:

*   any_ok: At least one address in the address pool is available.
*   p30_ok: At least 30% of the addresses in the address pool are available.
*   p50_ok: At least 50% of the addresses in the address pool are available.
*   p70_ok: At least 70% of the addresses in the address pool are available.
*   all_ok: All addresses in the address pool are available.', example='any_ok'),
          healthStatus?: string(name='HealthStatus', description='The health state of the address pool. Valid values:

*   ok: The health state of the address pool is normal and all addresses that are referenced by the address pool are available.
*   ok_alert: The health state of the address pool is warning and some of the addresses that are referenced by the address pool are unavailable. However, the address pool is deemed normal. In this case, only the available addresses are returned for DNS requests.
*   exceptional: The health state of the address pool is abnormal and some or all of the addresses that are referenced by the address pool are unavailable. In this case, the address pool is deemed abnormal.', example='ok'),
          requestSource?: {
            requestSource?: [ string ](name='RequestSource')
          }(name='RequestSource', description='Parse the request source list.'),
          seqNonPreemptiveSchedule?: boolean(name='SeqNonPreemptiveSchedule', description='Indicates whether it is a sequential (non-preemptive) scheduling object for hybrid cloud management scenarios: 
- true: yes 
- false: no', example='false'),
          sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address with the smallest sequence number is recovered. This parameter is required only when the policy for load balancing between addresses is sequence. Valid values:

*   preemptive: The address with the smallest sequence number is preferentially used if this address is recovered.
*   non_preemptive: The current address is still used even if the address with the smallest sequence number is recovered.', example='preemptive'),
          serialNumber?: int32(name='SerialNumber', description='Sequence number. For any parsing request, the address pool with the smaller sequence number (indicating the priority of the address pool returned, with smaller numbers having higher priority) will be returned.', example='1'),
          updateTime?: string(name='UpdateTime', description='Last modification time of the address pool.', example='2024-03-15T01:46Z'),
          updateTimestamp?: long(name='UpdateTimestamp', description='Update time (timestamp).', example='1527690629357'),
          weightValue?: int32(name='WeightValue', description='Weight value (an integer between 1 and 100, inclusive), allowing different weight values to be set for each address pool, implementing the return of address pools according to weight ratios in resolution queries.', example='1'),
        }
      ](name='AddressPool')
      }(name='AddressPools', description='The address pools.'),
      availableStatus?: string(name='AvailableStatus', description='The availability state of the access domain name. Valid values:

*   available: If the access domain name is **enabled** and the health state is **normal**, the access domain name is deemed **available**.
*   unavailable: If the access domain name is **disabled** or the health state is **abnormal**, the access domain name is deemed **unavailable**.', example='available'),
      commodityCode?: string(name='CommodityCode', description='The commodity code. Valid values:

*   dns_gtm_public_cn: the commodity code on the China site (aliyun.com)
*   dns_gtm_public_intl: the commodity code on the international site (alibabacloud.com)', example='dns_gtm_public_cn'),
      configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.', example='Config-000**11'),
      createTime?: string(name='CreateTime', description='Domain instance creation time.', example='2024-03-15T01:46Z'),
      createTimestamp?: long(name='CreateTimestamp', description='Domain instance creation time (timestamp).', example='1527690629357'),
      enableStatus?: string(name='EnableStatus', description='The enabling state of the access domain name. Valid values:

*   enable: The access domain name is enabled and the intelligent scheduling policy of the corresponding GTM instance takes effect.
*   disable: The access domain name is disabled and the intelligent scheduling policy of the corresponding GTM instance does not take effect.', example='enable'),
      healthStatus?: string(name='HealthStatus', description='The health state of the access domain name. Valid values:

*   ok: The health state of the access domain name is normal and all address pools that are referenced by the access domain name are available.
*   ok_alert: The health state of the access domain name is warning and some of the address pools that are referenced by the access domain name are unavailable. In this case, only the available address pools are returned for DNS requests.
*   exceptional: The health state of the access domain name is abnormal and all address pools that are referenced by the access domain name are unavailable. In this case, addresses in the non-empty address pool with the smallest sequence number are preferentially used for fallback resolution. This returns DNS results for clients as much as possible.', example='ok'),
      instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance.', example='gtm-cn-x0r38e0**03'),
      remark?: string(name='Remark', description='Remarks for the domain instance.', example='test'),
      scheduleDomainName?: string(name='ScheduleDomainName', description='The access domain name. The value of this parameter is composed of the value of ScheduleHostname and the value of ScheduleZoneName.', example='www.example.com'),
      scheduleHostname?: string(name='ScheduleHostname', description='Host record of the domain accessed by GTM.', example='www'),
      scheduleRrType?: string(name='ScheduleRrType', description='DNS record types for the scheduling domain:
- A: IPv4 address
- AAAA: IPv6 address
- CNAME: Domain name', example='A'),
      scheduleZoneMode?: string(name='ScheduleZoneMode', description='The allocation mode of the access domain name. Valid values:

*   custom: custom allocation. You must specify a custom hostname and associate the hostname with a zone that is hosted by the Public Authoritative DNS module within the account to which the GTM instance belongs to generate an access domain name.
*   sys_assign: system allocation. This mode is not supported. Do not set ScheduleZoneMode to sys_assign.', example='custom'),
      scheduleZoneName?: string(name='ScheduleZoneName', description='The zone such as example.com or subzone such as a.example.com of the access domain name. In most cases, the zone or subzone is hosted by the Public Authoritative DNS module of Alibaba Cloud DNS. This zone belongs to the account to which the GTM instance belongs.', example='example.com'),
      sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address pool with the smallest sequence number is recovered. This parameter is returned when AddressPoolLbStrategy is set to sequence. Valid values:

*   preemptive: The address pool with the smallest sequence number is preferentially used if this address pool is recovered.
*   non_preemptive: The current address pool is still used even if the address pool with the smallest sequence number is recovered.', example='preemptive'),
      ttl?: int32(name='Ttl', description='Global TTL (in seconds), the TTL value for resolving the access domain name to the address pool, which affects the caching time of DNS records in the operator\\"s LocalDNS. Supports custom TTL values.', example='60'),
      updateTime?: string(name='UpdateTime', description='The last modification time of the domain instance.', example='2024-03-15T01:46Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The last modification time of the domain instance (timestamp).', example='1527690629357'),
      versionCode?: string(name='VersionCode', description='Global Traffic Management version 3.0 instance types:
- standard: Standard Edition
- ultimate: Ultimate Edition', example='ultimate'),
    }
  ](name='InstanceConfig')
  }(name='InstanceConfigs', description='The instances list.'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from 1, default is 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of **100**, and a default of **20**.', example='20'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='6AEC7A64-3CB1-4C49-8B35-0B901F1E26BF'),
  totalItems?: int32(name='TotalItems', description='Total number of instance configuration entries.', example='15'),
  totalPages?: int32(name='TotalPages', description='Total number of pages.', example='1'),
}

model SearchCloudGtmInstanceConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchCloudGtmInstanceConfigsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SearchCloudGtmInstanceConfigs  SearchCloudGtmInstanceConfigsRequest
  * @return SearchCloudGtmInstanceConfigsResponse
 */
async function searchCloudGtmInstanceConfigs(request: SearchCloudGtmInstanceConfigsRequest): SearchCloudGtmInstanceConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchCloudGtmInstanceConfigs', 'POST', '/', 'json', false, 'json', request);
}

model SearchCloudGtmInstancesRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the return value. Options are:
- **zh-CN**: Chinese. 
- **en-US**: English.', example='en-US', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see How to ensure idempotence.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the Global Traffic Manager (GTM) 3.0 instance.', example='gtm-cn-wwo3a3hbz**', position='Query'),
  instanceName?: string(name='InstanceName', description='Schedule instance name, supports fuzzy search.', example='test', position='Query'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from 1, default is 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of **100**, and a default of **20**.', example='20', position='Query'),
}

model SearchCloudGtmInstancesResponseBody = {
  instances?: {
    instance?: [ 
    {
      commodityCode?: string(name='CommodityCode', description='The commodity code. Valid values:

*   dns_gtm_public_cn: commodity code on the China site (aliyun.com)
*   dns_gtm_public_intl: commodity code on the international site (alibabacloud.com)', example='dns_gtm_public_cn'),
      createTime?: string(name='CreateTime', description='Instance creation time.', example='2024-03-15T01:46Z'),
      createTimestamp?: long(name='CreateTimestamp', description='Instance creation time (timestamp).', example='1710467214858'),
      expireTime?: long(name='ExpireTime', description='Instance expiration time.', example='2024-09-05T16:00Z'),
      expireTimestamp?: string(name='ExpireTimestamp', description='Instance expiration time (timestamp).', example='1725552000000'),
      instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance.', example='gtm-cn-wwo3a3hbz**'),
      instanceName?: string(name='InstanceName', description='Schedule instance name.', example='test'),
      monitorTaskQuota?: int32(name='MonitorTaskQuota', description='Monitor probe task quota.', example='100'),
      monthlyEmailUsed?: int32(name='MonthlyEmailUsed', description='Monthly email sending volume.', example='200'),
      monthlySmsQuota?: int32(name='MonthlySmsQuota', description='SMS quota, only supported on the China site. International site does not support SMS.', example='2000'),
      monthlySmsUsed?: int32(name='MonthlySmsUsed', description='Monthly SMS sending volume, only supported by the China site as international sites do not support SMS.', example='200'),
      monthlyWebhookUsed?: int32(name='MonthlyWebhookUsed', description='Monthly webhook dispatch volume.', example='100'),
      scheduleDomainName?: string(name='ScheduleDomainName', description='The access domain name, which consists of a hostname and a zone or a subzone.', example='www.example.com'),
      updateTime?: string(name='UpdateTime', description='The last modified time of the instance.', example='2024-03-15T01:46Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The last modified time of the instance (timestamp).', example='1710467214858'),
      versionCode?: string(name='VersionCode', description='Global Traffic Management version 3.0 instance types:
- standard: Standard Edition
- ultimate: Ultimate Edition', example='ultimate'),
    }
  ](name='Instance')
  }(name='Instances', description='The instances.'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting at **1**, default is **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.', example='20'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  totalItems?: int32(name='TotalItems', description='Total number of instances found from the search.', example='10'),
  totalPages?: int32(name='TotalPages', description='Total number of pages.', example='1'),
}

model SearchCloudGtmInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchCloudGtmInstancesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SearchCloudGtmInstances  SearchCloudGtmInstancesRequest
  * @return SearchCloudGtmInstancesResponse
 */
async function searchCloudGtmInstances(request: SearchCloudGtmInstancesRequest): SearchCloudGtmInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchCloudGtmInstances', 'POST', '/', 'json', false, 'json', request);
}

model SearchCloudGtmMonitorTemplatesRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  ipVersion?: string(name='IpVersion', description='The IP address type of health check nodes. An exact search is performed based on the IP address type. Valid values:

*   IPv4: applicable when the destination address of health checks is an IPv4 address
*   IPv6: applicable when the destination address of health checks is an IPv6 address', example='IPv4', position='Query'),
  name?: string(name='Name', example='IPv4-Ping', position='Query'),
  pageNumber: int32(name='PageNumber', description='This parameter is required.', example='1', position='Query'),
  pageSize: int32(name='PageSize', description='This parameter is required.', example='20', position='Query'),
  protocol?: string(name='Protocol', example='ping', position='Query'),
}

model SearchCloudGtmMonitorTemplatesResponseBody = {
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='20'),
  requestId?: string(name='RequestId', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  templates?: {
    template?: [ 
    {
      createTime?: string(name='CreateTime', example='2024-03-23T13:09Z'),
      createTimestamp?: long(name='CreateTimestamp', example='1527690629357'),
      evaluationCount?: int32(name='EvaluationCount', example='2'),
      extendInfo?: string(name='ExtendInfo', description='The extended information. The value of this parameter is a JSON string. The required parameters vary based on the health check protocol. Valid values:

*   **http(s)**:

    **host**: indicates the Host field of an HTTP or HTTPS request header during an HTTP or HTTPS health check. The parameter value indicates the HTTP website that you want to visit. By default, the value is the primary domain name. You can change the value based on your business requirements.

    **path**: the URL for HTTP or HTTPS health checks. Default value: /.

    **code**: indicates the alert threshold. During an HTTP or HTTPS health check, the system checks whether a web server functions as expected based on the status code that is returned from the web server. If the returned status code is greater than the specified threshold, the corresponding application service address is deemed abnormal. Valid values:

    *   400: indicates an invalid request. If an HTTP or HTTPS request contains invalid request parameters, a web server returns a status code that is greater than 400. If Verification Content is set to "The error code is greater than 400", you must specify an exact URL for the path parameter.
    *   500: indicates a server error. If some exceptions occur on a web server, the web server returns a status code that is greater than 500. The error code that is greater than 500 is used as the alert threshold by default.

    **sni**: indicates whether Server Name Indication (SNI) is enabled for HTTPS. SNI is an extension to the Transport Layer Security (TLS) protocol, which allows a client to specify the host to be connected when the client sends a TLS handshake request. TLS handshakes occur before any data of HTTP requests is sent. Therefore, SNI enables servers to identify the services that clients are attempting to access before certificates are sent. This allows the servers to present correct certificates to the clients. Valid values:

    *   true: SNI is enabled.
    *   false: SNI is disabled.

    **followRedirect**: indicates whether 3XX redirection is followed. Valid values:

    *   true: You are redirected to the destination address if a status code 3XX, such as 301, 302, 303, 307, or 308, is returned.
    *   false: You are not redirected to the destination address.

*   **ping**:

    **packetNum**: The total number of Internet Control Message Protocol (ICMP) packets that are sent to the address for each ping-based health check. Valid values: 20, 50, and 100.

    **packetLossRate**: The packet loss rate for each ping-based health check. The packet loss rate in a check can be calculated by using the following formula: Packet loss rate = (Number of lost packets/Total number of sent ICMP packets) × 100%. If the packet loss rate reaches the threshold, an alert is triggered. Valid values: 10, 30, 40, 80, 90, and 100.', example='{\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}'),
      failureRate?: int32(name='FailureRate', example='50'),
      interval?: int32(name='Interval', example='60'),
      ipVersion?: string(name='IpVersion', description='The IP address type of health check nodes. Valid values:

*   IPv4: applicable when the destination address of health checks is an IPv4 address
*   IPv6: applicable when the destination address of health checks is an IPv6 address', example='IPv4'),
      ispCityNodes?: {
        ispCityNode?: [ 
        {
          cityCode?: string(name='CityCode', example='503'),
          cityName?: string(name='CityName'),
          countryCode?: string(name='CountryCode', example='001'),
          countryName?: string(name='CountryName'),
          groupName?: string(name='GroupName', example='BGP'),
          groupType?: string(name='GroupType', description='The group type of health check nodes. Valid values:

*   BGP: BGP node
*   OVERSEAS: node outside the Chinese mainland
*   ISP: Internet service provider (ISP) node', example='BGP'),
          ispCode?: string(name='IspCode', example='465'),
          ispName?: string(name='IspName'),
        }
      ](name='IspCityNode')
      }(name='IspCityNodes', description='The health check nodes.'),
      name?: string(name='Name', example='IPv4-Ping'),
      protocol?: string(name='Protocol', example='ping'),
      remark?: string(name='Remark', example='test'),
      templateId?: string(name='TemplateId', example='mtp-89518052425100**80'),
      timeout?: int32(name='Timeout', example='5000'),
      updateTime?: string(name='UpdateTime', example='2024-03-29T13:20Z'),
      updateTimestamp?: long(name='UpdateTimestamp', example='1527690629357'),
    }
  ](name='Template')
  }(name='Templates', description='The health check templates.'),
  totalItems?: int32(name='TotalItems', example='1'),
  totalPages?: int32(name='TotalPages', example='1'),
}

model SearchCloudGtmMonitorTemplatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchCloudGtmMonitorTemplatesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SearchCloudGtmMonitorTemplates  SearchCloudGtmMonitorTemplatesRequest
  * @return SearchCloudGtmMonitorTemplatesResponse
 */
async function searchCloudGtmMonitorTemplates(request: SearchCloudGtmMonitorTemplatesRequest): SearchCloudGtmMonitorTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchCloudGtmMonitorTemplates', 'POST', '/', 'json', false, 'json', request);
}

model SetDNSSLBStatusRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com', position='Query'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en', position='Query'),
  line?: string(name='Line', description='The DNS resolution line. The line can be the default line, China Telecom, and China Mobile.', example='China Mobile.', position='Query'),
  open?: boolean(name='Open', description='Specifies whether to enable or disable weighted round-robin. Valid values:

*   **true** (default): enables weighted round-robin.
*   **false**: disables weighted round-robin.', example='true', position='Query'),
  subDomain: string(name='SubDomain', description='The subdomain name for which you want to enable weighted round-robin. Set the parameter to @.example.com instead of example.com.

This parameter is required.', example='www.example.com', position='Query'),
  type?: string(name='Type', description='The type of the Domain Name System (DNS) record. Valid values: A and AAAA. Default value: A.', example='A', position='Query'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0', position='Query'),
}

model SetDNSSLBStatusResponseBody = {
  open?: boolean(name='Open', description='Indicates whether weighted round-robin is enabled for the subdomain name.', example='true'),
  recordCount?: long(name='RecordCount', description='The number of A records that are matched.', example='8'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model SetDNSSLBStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetDNSSLBStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SetDNSSLBStatus  SetDNSSLBStatusRequest
  * @return SetDNSSLBStatusResponse
 */
async function setDNSSLBStatus(request: SetDNSSLBStatusRequest): SetDNSSLBStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDNSSLBStatus', 'POST', '/', 'json', false, 'json', request);
}

model SetDnsGtmAccessModeRequest {
  accessMode: string(name='AccessMode', description='The switchover policy for primary and secondary address pool sets. Valid values:

*   AUTO: performs automatic switchover between the primary and secondary address pool sets upon failures.
*   DEFAULT: the primary address pool set
*   FAILOVER: the secondary address pool set

This parameter is required.', example='auto', position='Query'),
  lang?: string(name='Lang', description='The language of the values for specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
  strategyId: string(name='StrategyId', description='The policy ID.

This parameter is required.', example='strategyId', position='Query'),
}

model SetDnsGtmAccessModeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
}

model SetDnsGtmAccessModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetDnsGtmAccessModeResponseBody(name='body'),
}

/**
  * @description ****
  * @param request  the request parameters of SetDnsGtmAccessMode  SetDnsGtmAccessModeRequest
  * @return SetDnsGtmAccessModeResponse
 */
async function setDnsGtmAccessMode(request: SetDnsGtmAccessModeRequest): SetDnsGtmAccessModeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDnsGtmAccessMode', 'POST', '/', 'json', false, 'json', request);
}

model SetDnsGtmMonitorStatusRequest {
  lang?: string(name='Lang', description='The language of the values for specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
  monitorConfigId: string(name='MonitorConfigId', description='The ID of the health check task.

This parameter is required.', example='MonitorConfigId1', position='Query'),
  status: string(name='Status', description='Specifies whether to enable the health check feature. Valid values:

*   OPEN: enables the health check feature.
*   CLOSE: disables the health check feature.

This parameter is required.', example='open', position='Query'),
}

model SetDnsGtmMonitorStatusResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model SetDnsGtmMonitorStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetDnsGtmMonitorStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SetDnsGtmMonitorStatus  SetDnsGtmMonitorStatusRequest
  * @return SetDnsGtmMonitorStatusResponse
 */
async function setDnsGtmMonitorStatus(request: SetDnsGtmMonitorStatusRequest): SetDnsGtmMonitorStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDnsGtmMonitorStatus', 'POST', '/', 'json', false, 'json', request);
}

model SetDomainDnssecStatusRequest {
  domainName: string(name='DomainName', description='The domain name for which you want to enable the DNSSEC. Only the users of the paid editions of Alibaba Cloud DNS can enable this feature.

This parameter is required.', example='example.com', position='Query'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en.', example='en', position='Query'),
  status: string(name='Status', description='The DNSSEC status. Valid values:

*   ON: enables DNSSEC for the domain name.
*   OFF: disables DNSSEC for the domain name.

This parameter is required.', example='ON', position='Query'),
}

model SetDomainDnssecStatusResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model SetDomainDnssecStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetDomainDnssecStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SetDomainDnssecStatus  SetDomainDnssecStatusRequest
  * @return SetDomainDnssecStatusResponse
 */
async function setDomainDnssecStatus(request: SetDomainDnssecStatusRequest): SetDomainDnssecStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDomainDnssecStatus', 'POST', '/', 'json', false, 'json', request);
}

model SetDomainRecordStatusRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en', position='Query'),
  recordId: string(name='RecordId', description='The ID of the DNS record. You can call the [DescribeDomainRecords](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomainrecords?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.

This parameter is required.', example='9999985', position='Query'),
  status: string(name='Status', description='The state of the DNS record. Valid values:

*   **Enable**: enables the DNS record.
*   **Disable**: disables the DNS record.

This parameter is required.', example='Disable', position='Query'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0', position='Query'),
}

model SetDomainRecordStatusResponseBody = {
  recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  status?: string(name='Status', description='The status of the DNS record.', example='Disable'),
}

model SetDomainRecordStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetDomainRecordStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SetDomainRecordStatus  SetDomainRecordStatusRequest
  * @return SetDomainRecordStatusResponse
 */
async function setDomainRecordStatus(request: SetDomainRecordStatusRequest): SetDomainRecordStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDomainRecordStatus', 'POST', '/', 'json', false, 'json', request);
}

model SetGtmAccessModeRequest {
  accessMode: string(name='AccessMode', description='The desired access policy. Valid values:

*   **AUTO: performs automatic switchover between the primary and secondary address pool sets upon failures.**
*   **DEFAULT: specifies the primary address pool set.**
*   **FAILOVER: specifies the secondary address pool set.

This parameter is required.', example='AUTO', position='Query'),
  lang?: string(name='Lang', description='The language.', example='en', position='Query'),
  strategyId: string(name='StrategyId', description='The ID of the access policy.

This parameter is required.', example='hra0hx', position='Query'),
}

model SetGtmAccessModeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
}

model SetGtmAccessModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetGtmAccessModeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SetGtmAccessMode  SetGtmAccessModeRequest
  * @return SetGtmAccessModeResponse
 */
async function setGtmAccessMode(request: SetGtmAccessModeRequest): SetGtmAccessModeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetGtmAccessMode', 'POST', '/', 'json', false, 'json', request);
}

model SetGtmMonitorStatusRequest {
  lang?: string(name='Lang', description='The language used by the user.', example='en', position='Query'),
  monitorConfigId: string(name='MonitorConfigId', description='The health check ID.

This parameter is required.', example='abc1234', position='Query'),
  status: string(name='Status', description='Specifies whether health check is enabled for the address pool. Valid values:

*   **OPEN**: Enabled
*   **CLOSE**: Disabled

This parameter is required.', example='OPEN', position='Query'),
}

model SetGtmMonitorStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model SetGtmMonitorStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetGtmMonitorStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SetGtmMonitorStatus  SetGtmMonitorStatusRequest
  * @return SetGtmMonitorStatusResponse
 */
async function setGtmMonitorStatus(request: SetGtmMonitorStatusRequest): SetGtmMonitorStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetGtmMonitorStatus', 'POST', '/', 'json', false, 'json', request);
}

model SubmitIspFlushCacheTaskRequest {
  clientToken: string(name='ClientToken', description='This parameter is required.', position='Query'),
  domainName: string(name='DomainName', description='This parameter is required.', position='Query'),
  isp: [ string ](name='Isp', description='This parameter is required.', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model SubmitIspFlushCacheTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model SubmitIspFlushCacheTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SubmitIspFlushCacheTaskResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SubmitIspFlushCacheTask  SubmitIspFlushCacheTaskRequest
  * @return SubmitIspFlushCacheTaskResponse
 */
async function submitIspFlushCacheTask(request: SubmitIspFlushCacheTaskRequest): SubmitIspFlushCacheTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitIspFlushCacheTask', 'POST', '/', 'json', false, 'json', request);
}

model SwitchDnsGtmInstanceStrategyModeRequest {
  instanceId: string(name='InstanceId', description='The ID of the GTM instance.

This parameter is required.', example='instance1', position='Query'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
  strategyMode: string(name='StrategyMode', description='The access policy type. Valid values:

*   GEO: geographical location-based
*   LATENCY: latency-based

This parameter is required.', example='GEO', position='Query'),
}

model SwitchDnsGtmInstanceStrategyModeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model SwitchDnsGtmInstanceStrategyModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SwitchDnsGtmInstanceStrategyModeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SwitchDnsGtmInstanceStrategyMode  SwitchDnsGtmInstanceStrategyModeRequest
  * @return SwitchDnsGtmInstanceStrategyModeResponse
 */
async function switchDnsGtmInstanceStrategyMode(request: SwitchDnsGtmInstanceStrategyModeRequest): SwitchDnsGtmInstanceStrategyModeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SwitchDnsGtmInstanceStrategyMode', 'POST', '/', 'json', false, 'json', request);
}

model TagResourcesRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en', position='Query'),
  resourceId: [ string ](name='ResourceId', description='The ID of the resource.

This parameter is required.', example='dns-example.com', position='Query'),
  resourceType: string(name='ResourceType', description='The type of the resource. Valid values:

*   **DOMAIN**: domain name

This parameter is required.', example='DOMAIN', position='Query'),
  tag: [ 
    {
      key?: string(name='Key', description='The tag key. The tag key can be up to 20 characters in length and cannot start with `acs:` or`aliyun`.', example='abcd'),
      value?: string(name='Value', description='The tag value. The tag value can be up to 20 bytes in length.', example='abcd'),
    }
  ](name='Tag', description='The tags.

This parameter is required.', position='Query'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='635B0CCD-15A7-48C9-B4D6-628FF57FF4B8'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TagResourcesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of TagResources  TagResourcesRequest
  * @return TagResourcesResponse
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagResources', 'POST', '/', 'json', false, 'json', request);
}

model TransferDomainRequest {
  domainNames: string(name='DomainNames', description='The domain names. Separate multiple domain names with commas (,). Only domain names registered with Alibaba Cloud are supported.

This parameter is required.', example='test1.com,test2.com', position='Query'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en', position='Query'),
  remark?: string(name='Remark', description='The description of the domain name.', example='test domain transfer', position='Query'),
  targetUserId: long(name='TargetUserId', description='The destination user ID. The domain names and their Domain Name System (DNS) records are transferred to the destination user ID.

This parameter is required.', example='12345678', position='Query'),
}

model TransferDomainResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  taskId?: long(name='TaskId', description='The task ID.', example='112233'),
}

model TransferDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TransferDomainResponseBody(name='body'),
}

/**
  * @param request  the request parameters of TransferDomain  TransferDomainRequest
  * @return TransferDomainResponse
 */
async function transferDomain(request: TransferDomainRequest): TransferDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TransferDomain', 'POST', '/', 'json', false, 'json', request);
}

model UnbindInstanceDomainsRequest {
  domainNames: string(name='DomainNames', description='The domain names.

Separate multiple domain names with commas (,). Up to 100 domain names can be entered.

This parameter is required.', example='example.com,example.net', position='Query'),
  instanceId: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='123', position='Query'),
  lang?: string(name='Lang', description='The language.', example='en', position='Query'),
}

model UnbindInstanceDomainsResponseBody = {
  failedCount?: int32(name='FailedCount', description='The number of domain names that failed to be unbound from the instance.', example='0'),
  requestId?: string(name='RequestId', description='The request ID.', example='123'),
  successCount?: int32(name='SuccessCount', description='The number of domain names that are unbound from the instance.', example='2'),
}

model UnbindInstanceDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnbindInstanceDomainsResponseBody(name='body'),
}

/**
  * @description A paid Alibaba Cloud DNS instance whose ID starts with dns is an instance of the new version. You can call an API operation to bind multiple domain names to the instance. If the upper limit is exceeded, an error message is returned.\\
  * A paid Alibaba Cloud DNS instance whose ID does not start with dns is an instance of the old version. You can call an API operation to bind only one domain name to the instance. However, if the instance that you want to bind to the desired domain name is already bound to a domain name, you can call this operation to unbind the original domain name from the instance and then bind the desired domain name to the instance.
  * @param request  the request parameters of UnbindInstanceDomains  UnbindInstanceDomainsRequest
  * @return UnbindInstanceDomainsResponse
 */
async function unbindInstanceDomains(request: UnbindInstanceDomainsRequest): UnbindInstanceDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnbindInstanceDomains', 'POST', '/', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to remove all tags. Default value: false. This parameter is valid only when TagKey is left empty. Valid values: true and false.', example='false', position='Query'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en', position='Query'),
  resourceId: [ string ](name='ResourceId', description='The ID of the resource.

This parameter is required.', example='The type of the resource.', position='Query'),
  resourceType: string(name='ResourceType', description='The type of the resource. Valid value: Valid values:

*   **DOMAIN**: domain name

This parameter is required.', example='DOMAIN', position='Query'),
  tagKey?: [ string ](name='TagKey', description='The tags added to the resource.', example='The domain name.', position='Query'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F152A869-DF77-4DF1-9A00-4E06978FE6A1'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UntagResourcesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UntagResources  UntagResourcesRequest
  * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UntagResources', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAppKeyStateRequest {
  appKeyId?: string(name='AppKeyId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  state?: string(name='State', position='Query'),
}

model UpdateAppKeyStateResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAppKeyStateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAppKeyStateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateAppKeyState  UpdateAppKeyStateRequest
  * @return UpdateAppKeyStateResponse
 */
async function updateAppKeyState(request: UpdateAppKeyStateRequest): UpdateAppKeyStateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAppKeyState', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCloudGtmAddressRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  address?: string(name='Address', description='The IP address or domain name.', example='223.5.XX.XX', position='Query'),
  addressId: string(name='AddressId', description='The ID of the address. This ID uniquely identifies the address.

This parameter is required.', example='addr-89518218114368**92', position='Query'),
  attributeInfo?: string(name='AttributeInfo', description='Address Attribution information.', example='This parameter is not supported in the current version and does not need to be input.', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  healthJudgement?: string(name='HealthJudgement', description='The new condition for determining the health state of the address. Valid values:

*   any_ok: The health check results of at least one health check template are normal.
*   p30_ok: The health check results of at least 30% of health check templates are normal.
*   p50_ok: The health check results of at least 50% of health check templates are normal.
*   p70_ok: The health check results of at least 70% of health check templates are normal.
*   all_ok: The health check results of all health check templates are normal.', example='p50_ok', position='Query'),
  healthTasks?: [ 
    {
      port?: int32(name='Port', description='The service port of the address on which health check tasks are performed. If the ping protocol is used for health checks, the configuration of the service port is not supported.

*   If you leave this parameter empty, the existing service port is deleted.
*   If you specify this parameter, the existing service port is updated based on the value of this parameter.', example='80'),
      templateId?: string(name='TemplateId', description='The ID of the health check template that is associated with the address. This parameter is required if you specify a service port of the address for health check tasks.

*   If you leave this parameter empty, the associated health check template is disassociated from the address.
*   If you specify this parameter, the associated health check template is updated based on the value of this parameter.', example='mtp-89518052425100**80'),
    }
  ](name='HealthTasks', description='The health check tasks.', shrink='json', position='Query'),
  name?: string(name='Name', description='The name of the address.', example='Address-1', position='Query'),
}

model UpdateCloudGtmAddressResponseBody = {
  requestId?: string(name='RequestId', description='Unique request identification code.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  success?: boolean(name='Success', description='Modify address base configuration operation status:
- true: Operation was successful
- false: Operation was failed', example='true'),
}

model UpdateCloudGtmAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmAddressResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateCloudGtmAddress  UpdateCloudGtmAddressRequest
  * @return UpdateCloudGtmAddressResponse
 */
async function updateCloudGtmAddress(request: UpdateCloudGtmAddressRequest): UpdateCloudGtmAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCloudGtmAddress', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCloudGtmAddressEnableStatusRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='返回结果显示的语言。取值：

- zh-CN：中文

- en-US：英文', example='en-US', position='Query'),
  addressId: string(name='AddressId', description='The ID of the address. This ID uniquely identifies the address.

This parameter is required.', example='addr-89518218114368**92', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  enableStatus: string(name='EnableStatus', description='The enabling state of the address. Valid values:

*   enable: The address is enabled and the address can be used for Domain Name System (DNS) resolution if the address passes health checks.
*   disable: The address is disabled and the address cannot be used for DNS resolution regardless of whether the address passes health checks or not.

This parameter is required.', example='enable', position='Query'),
}

model UpdateCloudGtmAddressEnableStatusResponseBody = {
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  success?: boolean(name='Success', description='Indicates whether the operation was successful. Valid values:

*   true: The operation was successful.
*   false: The operation was failed.', example='true'),
}

model UpdateCloudGtmAddressEnableStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmAddressEnableStatusResponseBody(name='body'),
}

/**
  * @description *   If an address is **enabled** and the health status of the address is **Normal**, the availability status of the address is **Available**.
  * *   If an address is **disabled** or the health status of the address is **Abnormal**, the availability status of the address is **Unavailable**.
  * @param request  the request parameters of UpdateCloudGtmAddressEnableStatus  UpdateCloudGtmAddressEnableStatusRequest
  * @return UpdateCloudGtmAddressEnableStatusResponse
 */
async function updateCloudGtmAddressEnableStatus(request: UpdateCloudGtmAddressEnableStatusRequest): UpdateCloudGtmAddressEnableStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCloudGtmAddressEnableStatus', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCloudGtmAddressManualAvailableStatusRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  addressId: string(name='AddressId', description='The ID of the address. This ID uniquely identifies the address.

This parameter is required.', example='addr-89518218114368**92', position='Query'),
  availableMode?: string(name='AvailableMode', description='The failover mode that is used when address exceptions are identified. Valid values:

*   auto: the automatic mode. The system determines whether to return an address based on health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
*   manual: the manual mode. If an address is in the unavailable state, the address is not returned for DNS requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.', example='manual', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  manualAvailableStatus?: string(name='ManualAvailableStatus', description='The availability state of the address when AvailableMode is set to manual. Valid values:

*   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
*   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.', example='available', position='Query'),
}

model UpdateCloudGtmAddressManualAvailableStatusResponseBody = {
  requestId?: string(name='RequestId', description='Unique request identification code.', example='0F32959D-417B-4D66-8463-68606605E3E2'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
}

model UpdateCloudGtmAddressManualAvailableStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmAddressManualAvailableStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateCloudGtmAddressManualAvailableStatus  UpdateCloudGtmAddressManualAvailableStatusRequest
  * @return UpdateCloudGtmAddressManualAvailableStatusResponse
 */
async function updateCloudGtmAddressManualAvailableStatus(request: UpdateCloudGtmAddressManualAvailableStatusRequest): UpdateCloudGtmAddressManualAvailableStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCloudGtmAddressManualAvailableStatus', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCloudGtmAddressPoolBasicConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16', position='Query'),
  addressPoolName?: string(name='AddressPoolName', description='Address pool name, helping users distinguish the purpose of address pools.', example='app', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address pool. Valid values:

*   any_ok: At least one address in the address pool is available.
*   p30_ok: At least 30% of the addresses in the address pool are available.
*   p50_ok: At least 50% of the addresses in the address pool are available.
*   p70_ok: At least 70% of the addresses in the address pool are available.
*   all_ok: All addresses in the address pool are available.', example='any_ok', position='Query'),
}

model UpdateCloudGtmAddressPoolBasicConfigResponseBody = {
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  success?: boolean(name='Success', description='Modify the basic configuration of the address pool operation success:
- true: Operation successful
- false: Operation failed', example='true'),
}

model UpdateCloudGtmAddressPoolBasicConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmAddressPoolBasicConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateCloudGtmAddressPoolBasicConfig  UpdateCloudGtmAddressPoolBasicConfigRequest
  * @return UpdateCloudGtmAddressPoolBasicConfigResponse
 */
async function updateCloudGtmAddressPoolBasicConfig(request: UpdateCloudGtmAddressPoolBasicConfigRequest): UpdateCloudGtmAddressPoolBasicConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCloudGtmAddressPoolBasicConfig', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCloudGtmAddressPoolEnableStatusRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  enableStatus?: string(name='EnableStatus', description='The enabling state of the address pool. Valid values:

*   enable: The address pool is enabled, and the addresses in the address pool are returned for DNS resolution when the health check results are normal.
*   disable: The address pool is disabled, and the addresses in the address pool are not returned for DNS resolution regardless of whether the health check results are normal or not.', example='enable', position='Query'),
}

model UpdateCloudGtmAddressPoolEnableStatusResponseBody = {
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='89184F33-48A1-4401-9C0F-40E45DB091AB'),
  success?: boolean(name='Success', description='Indicates whether the modification operation was successful:
- true: Operation was successful
- false: Operation failed', example='true'),
}

model UpdateCloudGtmAddressPoolEnableStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmAddressPoolEnableStatusResponseBody(name='body'),
}

/**
  * @description *   If an address pool is **enabled** and the health status of the address pool is **Normal**, the availability status of the address pool is **Available**.
  * *   If an address pool is **disabled** or the health status of the address pool is **Abnormal**, the availability status of the address pool is **unavailable**.
  * @param request  the request parameters of UpdateCloudGtmAddressPoolEnableStatus  UpdateCloudGtmAddressPoolEnableStatusRequest
  * @return UpdateCloudGtmAddressPoolEnableStatusResponse
 */
async function updateCloudGtmAddressPoolEnableStatus(request: UpdateCloudGtmAddressPoolEnableStatusRequest): UpdateCloudGtmAddressPoolEnableStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCloudGtmAddressPoolEnableStatus', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCloudGtmAddressPoolLbStrategyRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  addressLbStrategy?: string(name='AddressLbStrategy', description='Load balancing policy among addresses in the address pool:
- round_robin: Round-robin, for any source of DNS resolution requests, all addresses are returned. The order of all addresses is rotated each time.
- sequence: Sequential, for any source of DNS resolution requests, the address with the smaller sequence number (the sequence number indicates the priority of address returns, with smaller numbers having higher priority) is returned. If the address with the smaller sequence number is unavailable, the next address with a smaller sequence number is returned.
- weight: Weighted, supports setting different weight values for each address, realizing the return of addresses according to the weight ratio for resolution queries.
- source_nearest: Source-nearest, i.e., intelligent resolution function, where GTM can return different addresses based on the source of different DNS resolution requests, achieving the effect of users accessing nearby.', example='sequence', position='Query'),
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address with the smallest sequence number is recovered. This parameter is required only when AddressLbStrategy is set to sequence. Valid values:

*   preemptive: The address with the smallest sequence number is preferentially used if this address is recovered.
*   non_preemptive: The current address is still used even if the address with the smallest sequence number is recovered.', example='preemptive', position='Query'),
}

model UpdateCloudGtmAddressPoolLbStrategyResponseBody = {
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
  success?: boolean(name='Success', description='Indicates whether the modification operation was successful:
- true: Operation successful
- false: Operation failed', example='true'),
}

model UpdateCloudGtmAddressPoolLbStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmAddressPoolLbStrategyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateCloudGtmAddressPoolLbStrategy  UpdateCloudGtmAddressPoolLbStrategyRequest
  * @return UpdateCloudGtmAddressPoolLbStrategyResponse
 */
async function updateCloudGtmAddressPoolLbStrategy(request: UpdateCloudGtmAddressPoolLbStrategyRequest): UpdateCloudGtmAddressPoolLbStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCloudGtmAddressPoolLbStrategy', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCloudGtmAddressPoolRemarkRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  remark?: string(name='Remark', description='The input parameter serves as the updated note; if an empty value is passed, the note will be deleted.', example='test', position='Query'),
}

model UpdateCloudGtmAddressPoolRemarkResponseBody = {
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  success?: boolean(name='Success', description='Indicates whether the modification operation was successful:
- true: Operation successful
- false: Operation failed', example='true'),
}

model UpdateCloudGtmAddressPoolRemarkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmAddressPoolRemarkResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateCloudGtmAddressPoolRemark  UpdateCloudGtmAddressPoolRemarkRequest
  * @return UpdateCloudGtmAddressPoolRemarkResponse
 */
async function updateCloudGtmAddressPoolRemark(request: UpdateCloudGtmAddressPoolRemarkRequest): UpdateCloudGtmAddressPoolRemarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCloudGtmAddressPoolRemark', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCloudGtmAddressRemarkRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  addressId: string(name='AddressId', description='The ID of the address. This ID uniquely identifies the address.

This parameter is required.', example='addr-89518218114368**92', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  remark?: string(name='Remark', description='The input parameter serves as the updated note; if an empty value is passed, the note will be deleted.', example='test', position='Query'),
}

model UpdateCloudGtmAddressRemarkResponseBody = {
  requestId?: string(name='RequestId', description='Unique request identification code.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
  success?: boolean(name='Success', description='Indicates whether the modification operation was successful:
- true: Operation was successful
- false: Operation was failed', example='true'),
}

model UpdateCloudGtmAddressRemarkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmAddressRemarkResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateCloudGtmAddressRemark  UpdateCloudGtmAddressRemarkRequest
  * @return UpdateCloudGtmAddressRemarkResponse
 */
async function updateCloudGtmAddressRemark(request: UpdateCloudGtmAddressRemarkRequest): UpdateCloudGtmAddressRemarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCloudGtmAddressRemark', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCloudGtmGlobalAlertRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US: English', example='en-US', position='Query'),
  alertConfig?: [ 
    {
      dingtalkNotice?: boolean(name='DingtalkNotice', description='Specifies whether to configure DingTalk notifications. Valid values:

*   true: configures DingTalk notifications. DingTalk notifications are sent when alerts are triggered.
*   false: does not configure DingTalk notifications.', example='false'),
      emailNotice?: boolean(name='EmailNotice', description='Specifies whether to configure email notifications. Valid values:

*   true: configures email notifications. Emails are sent when alerts are triggered.
*   false｜null: does not configure email notifications.', example='true'),
      noticeType?: string(name='NoticeType', description='The type of the alert event. Valid values:

*   addr_alert: The address is unavailable.
*   addr_resume: The address becomes available.
*   addr_pool_unavailable: The address pool is unavailable.
*   addr_pool_available: The address pool becomes available.', example='addr_alert'),
      smsNotice?: boolean(name='SmsNotice', description='Specifies whether to configure text message notifications. Valid values:

*   true: configures text message notifications. Text messages are sent when alerts are triggered.
*   false｜null: does not configure text message notifications.

Only the China site (aliyun.com) supports text message notifications.', example='true'),
    }
  ](name='AlertConfig', description='The alert configurations.', shrink='json', position='Query'),
  alertGroup?: [ string ](name='AlertGroup', description='The alert contact groups.', shrink='json', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
}

model UpdateCloudGtmGlobalAlertResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model UpdateCloudGtmGlobalAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmGlobalAlertResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateCloudGtmGlobalAlert  UpdateCloudGtmGlobalAlertRequest
  * @return UpdateCloudGtmGlobalAlertResponse
 */
async function updateCloudGtmGlobalAlert(request: UpdateCloudGtmGlobalAlertRequest): UpdateCloudGtmGlobalAlertResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCloudGtmGlobalAlert', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCloudGtmInstanceConfigAlertRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US: English', example='zh-CN', position='Query'),
  alertConfig?: [ 
    {
      dingtalkNotice?: boolean(name='DingtalkNotice', description='Specifies whether to configure DingTalk notifications. Valid values:

*   true: configures DingTalk notifications. DingTalk notifications are sent when alerts are triggered.
*   false: does not configure DingTalk notifications.', example='true'),
      emailNotice?: boolean(name='EmailNotice', description='Specifies whether to configure email notifications. Valid values:

*   true: configures email notifications. Emails are sent when alerts are triggered.
*   false: does not configure email notifications.', example='true'),
      noticeType?: string(name='NoticeType', description='The type of the alert event. Valid values:

*   addr_alert: The address is unavailable.
*   addr_resume: The address becomes available.
*   addr_pool_unavailable: The address pool is unavailable.
*   addr_pool_available: The address pool becomes available.', example='addr_alert'),
      smsNotice?: boolean(name='SmsNotice', description='Specifies whether to configure text message notifications. Valid values:

*   true: configures text message notifications. Text messages are sent when alerts are triggered.
*   false: does not configure text message notifications.

Only the China site (aliyun.com) supports text message notifications.', example='true'),
    }
  ](name='AlertConfig', description='The alert configurations.', shrink='json', position='Query'),
  alertGroup?: [ string ](name='AlertGroup', description='The alert contact groups.', shrink='json', position='Query'),
  alertMode?: string(name='AlertMode', description='The alert configuration mode of the instance. Valid values:

*   global: global alert configuration
*   instance_config: custom alert configuration', example='global', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when an A record and an AAAA record are configured for the access domain name that is bound to the GTM instance. This ID uniquely identifies a configuration.', example='Config-000**11', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the Global Traffic Manager (GTM) 3.0 instance.', example='gtm-cn-zz11t58**0s', position='Query'),
}

model UpdateCloudGtmInstanceConfigAlertResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model UpdateCloudGtmInstanceConfigAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmInstanceConfigAlertResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateCloudGtmInstanceConfigAlert  UpdateCloudGtmInstanceConfigAlertRequest
  * @return UpdateCloudGtmInstanceConfigAlertResponse
 */
async function updateCloudGtmInstanceConfigAlert(request: UpdateCloudGtmInstanceConfigAlertRequest): UpdateCloudGtmInstanceConfigAlertResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCloudGtmInstanceConfigAlert', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCloudGtmInstanceConfigBasicRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   **zh-CN**: Chinese
*   **en-US** (default): English', example='en-US', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.

You can call the [ListCloudGtmInstanceConfigs](https://help.aliyun.com/document_detail/2797349.html) operation to query the value of ConfigId for the access domain name.', example='Config-000**11', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance for which you want to modify the TTL configuration.', example='gtm-cn-wwo3a3hbz**', position='Query'),
  scheduleHostname?: string(name='ScheduleHostname', description='Host record of the domain accessed by GTM.', example='www', position='Query'),
  scheduleZoneName?: string(name='ScheduleZoneName', description='The zone (such as example.com) or subzone (such as a.example.com) of the GTM access domain name. In most cases, the zone or subzone is hosted in Authoritative DNS Resolution of the Alibaba Cloud DNS console within the account to which the GTM instance belongs.', example='example.com', position='Query'),
  ttl?: int32(name='Ttl', description='The global TTL value, in seconds. The global TTL value affects how long the DNS records that map the access domain name to the addresses in the address pools are cached in the local DNS servers of Internet service providers (ISPs).', example='60', position='Query'),
}

model UpdateCloudGtmInstanceConfigBasicResponseBody = {
  requestId?: string(name='RequestId', description='Unique request identification code.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  success?: boolean(name='Success', description='Indicates whether the operation was successful: 
- **true**: The call succeeded. 
- **false**: The call failed.', example='true'),
}

model UpdateCloudGtmInstanceConfigBasicResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmInstanceConfigBasicResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateCloudGtmInstanceConfigBasic  UpdateCloudGtmInstanceConfigBasicRequest
  * @return UpdateCloudGtmInstanceConfigBasicResponse
 */
async function updateCloudGtmInstanceConfigBasic(request: UpdateCloudGtmInstanceConfigBasicRequest): UpdateCloudGtmInstanceConfigBasicResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCloudGtmInstanceConfigBasic', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCloudGtmInstanceConfigEnableStatusRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   **zh-CN**: Chinese
*   **en-US** (default): English', example='zh-CN', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.

You can call the [ListCloudGtmInstanceConfigs](~~ListCloudGtmInstanceConfigs~~) operation to query the configuration ID of the access domain name.', example='Config-000**11', position='Query'),
  enableStatus?: string(name='EnableStatus', description='The enabling state of the access domain name. Valid values:

*   enable
*   disable', example='enable', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the Global Traffic Manager (GTM) 3.0 instance.', example='gtm-cn-wwo3a3hbz**', position='Query'),
}

model UpdateCloudGtmInstanceConfigEnableStatusResponseBody = {
  requestId?: string(name='RequestId', description='Unique request identification code.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
  success?: boolean(name='Success', description='Indicates whether the operation was successful: 
- **true**: The call succeeded. 
- **false**: The call failed.', example='true'),
}

model UpdateCloudGtmInstanceConfigEnableStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmInstanceConfigEnableStatusResponseBody(name='body'),
}

/**
  * @description *   If an access domain name is **enabled** and the health state is **normal**, the access domain name is deemed **available**.
  * *   If an access domain name is **disabled** or the health state is **abnormal**, the access domain name is deemed **unavailable**.
  * @param request  the request parameters of UpdateCloudGtmInstanceConfigEnableStatus  UpdateCloudGtmInstanceConfigEnableStatusRequest
  * @return UpdateCloudGtmInstanceConfigEnableStatusResponse
 */
async function updateCloudGtmInstanceConfigEnableStatus(request: UpdateCloudGtmInstanceConfigEnableStatusRequest): UpdateCloudGtmInstanceConfigEnableStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCloudGtmInstanceConfigEnableStatus', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCloudGtmInstanceConfigLbStrategyRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language in which the returned results are displayed. Valid values:

*   **zh-CN**: Chinese
*   **en-US** (default): English', example='en-US', position='Query'),
  addressPoolLbStrategy?: string(name='AddressPoolLbStrategy', description='The new policy for load balancing between address pools. Valid values:

*   round_robin: All address pools are returned for Domain Name System (DNS) requests from any source. All address pools are sorted in round-robin mode each time they are returned.
*   sequence: The address pool with the smallest sequence number is preferentially returned for DNS requests from any source. The sequence number indicates the priority for returning the address pool. A smaller sequence number indicates a higher priority. If the address pool with the smallest sequence number is unavailable, the address pool with the second smallest sequence number is returned.
*   weight: You can set a different weight value for each address pool. This way, address pools are returned based on the weight values.
*   source_nearest: GTM returns different address pools based on the sources of DNS requests. This way, users can access nearby address pools.', example='sequence', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.

You can call the [ListCloudGtmInstanceConfigs](~~ListCloudGtmInstanceConfigs~~) operation to query the configuration ID of the desired access domain name.', example='Config-000**11', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance for which you want to modify the load balancing policy.', example='gtm-cn-wwo3a3hbz**', position='Query'),
  sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address pool with the smallest sequence number is recovered. This parameter is required when AddressPoolLbStrategy is set to sequence. Valid values:

*   preemptive: The address pool with the smallest sequence number is preferentially used if this address pool is recovered.
*   non_preemptive: The current address pool is still used even if the address pool with the smallest sequence number is recovered.', example='preemptive', position='Query'),
}

model UpdateCloudGtmInstanceConfigLbStrategyResponseBody = {
  requestId?: string(name='RequestId', example='0F32959D-417B-4D66-8463-68606605E3E2'),
  success?: boolean(name='Success', example='true'),
}

model UpdateCloudGtmInstanceConfigLbStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmInstanceConfigLbStrategyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateCloudGtmInstanceConfigLbStrategy  UpdateCloudGtmInstanceConfigLbStrategyRequest
  * @return UpdateCloudGtmInstanceConfigLbStrategyResponse
 */
async function updateCloudGtmInstanceConfigLbStrategy(request: UpdateCloudGtmInstanceConfigLbStrategyRequest): UpdateCloudGtmInstanceConfigLbStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCloudGtmInstanceConfigLbStrategy', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCloudGtmInstanceConfigRemarkRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language in which the returned results are displayed. Valid values:

*   **zh-CN**: Chinese
*   **en-US** (default): English', example='en-US', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.

You can call the [ListCloudGtmInstanceConfigs](~~ListCloudGtmInstanceConfigs~~) operation to query the configuration ID of the access domain name.', example='Config-000**11', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance for which you want to modify the description.', example='gtm-cn-wwo3a3hbz**', position='Query'),
  remark?: string(name='Remark', example='API', position='Query'),
}

model UpdateCloudGtmInstanceConfigRemarkResponseBody = {
  requestId?: string(name='RequestId', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
  success?: boolean(name='Success', example='true'),
}

model UpdateCloudGtmInstanceConfigRemarkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmInstanceConfigRemarkResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateCloudGtmInstanceConfigRemark  UpdateCloudGtmInstanceConfigRemarkRequest
  * @return UpdateCloudGtmInstanceConfigRemarkResponse
 */
async function updateCloudGtmInstanceConfigRemark(request: UpdateCloudGtmInstanceConfigRemarkRequest): UpdateCloudGtmInstanceConfigRemarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCloudGtmInstanceConfigRemark', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCloudGtmInstanceNameRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US: English', example='en-US', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the Global Traffic Manager (GTM) instance.', example='gtm-cn-jmp3qnw**03', position='Query'),
  instanceName?: string(name='InstanceName', description='The name of the instance. You cannot leave this parameter empty.', example='test', position='Query'),
}

model UpdateCloudGtmInstanceNameResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model UpdateCloudGtmInstanceNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmInstanceNameResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateCloudGtmInstanceName  UpdateCloudGtmInstanceNameRequest
  * @return UpdateCloudGtmInstanceNameResponse
 */
async function updateCloudGtmInstanceName(request: UpdateCloudGtmInstanceNameRequest): UpdateCloudGtmInstanceNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCloudGtmInstanceName', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCloudGtmMonitorTemplateRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  evaluationCount?: int32(name='EvaluationCount', description='The number of retries. The system will only judge the application service as abnormal after consecutive monitoring failures to prevent inaccurate monitoring results due to momentary network fluctuations or other reasons. Available retry options are:
- 1 
- 2 
- 3', example='2', position='Query'),
  extendInfo?: string(name='ExtendInfo', description='The extended information. The value of this parameter is a JSON string. The required parameters vary based on the health check protocol.

*   HTTP or HTTPS:

    host: the Host field of an HTTP or HTTPS request header during an HTTP or HTTPS health check. The parameter value indicates the HTTP website that you want to visit. By default, the value is the primary domain name. You can change the value based on your business requirements.

    path: the URL for HTTP or HTTPS health checks. Default value: /.

    code: the alert threshold. During an HTTP or HTTPS health check, the system checks whether a web server functions as expected based on the status code that is returned from the web server. If the returned status code is greater than the specified threshold, the corresponding application service address is deemed abnormal. Valid values:

    *   400: specifies an invalid request. If an HTTP or HTTPS request contains invalid request parameters, a web server returns a status code that is greater than 400. You must set path to an exact URL if you set code to 400.
    *   500: specifies a server error. If some exceptions occur on a web server, the web server returns a status code that is greater than 500. This value is used by default.

    sni: specifies whether to enable Server Name Indication (SNI). This parameter is used only when the health check protocol is HTTPS. SNI is an extension to the Transport Layer Security (TLS) protocol, which allows a client to specify the host to be connected when the client sends a TLS handshake request. TLS handshakes occur before any data of HTTP requests is sent. Therefore, SNI enables servers to identify the services that clients are attempting to access before certificates are sent. This allows the servers to present correct certificates to the clients. Valid values:

    *   true: enables SNI.
    *   false: disables SNI.

    followRedirect: specifies whether to follow 3XX redirects. Valid values:

    *   true: follows 3XX redirects. You are redirected to the destination address if a 3XX status code such as 301, 302, 303, 307, or 308 is returned.
    *   false: does not follow 3XX redirects.

*   ping:

    packetNum: the total number of Internet Control Message Protocol (ICMP) packets that are sent to the address for each ping-based health check. Valid values: 20, 50, and 100.

    packetLossRate: the ICMP packet loss rate for each ping-based health check. The packet loss rate in a health check can be calculated by using the following formula: Packet loss rate in a health check = (Number of lost packets/Total number of sent ICMP packets) × 100%. If the packet loss rate reaches the threshold, an alert is triggered. Valid values: 10, 30, 40, 80, 90, and 100.', example='{\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}', position='Query'),
  failureRate?: int32(name='FailureRate', description='Percentage of selected node probe failures (%), that is, the percentage of abnormal detection points among the total detection points. When the failure ratio exceeds the set threshold, the service address is judged as abnormal. The available failure ratio thresholds are:
- 20
- 50
- 80
- 100', example='50', position='Query'),
  interval?: int32(name='Interval', description='The time interval (in seconds) for each health check probe. By default, it probes every 60 seconds. The minimum supported interval for health checks is 15 seconds, available for flagship edition instances.', example='60', position='Query'),
  ispCityNodes?: [ 
    {
      cityCode?: string(name='CityCode', description='The city code of the health check node.', example='503'),
      ispCode?: string(name='IspCode', description='The Internet service provider (ISP) code of the health check node.', example='465'),
    }
  ](name='IspCityNodes', description='The health check nodes. You can call the [ListCloudGtmMonitorNodes](https://help.aliyun.com/document_detail/2797327.html) operation to obtain the health check nodes.', shrink='json', position='Query'),
  name?: string(name='Name', description='The name of the health check probe template, which is generally recommended to be distinguishable and memorable for configuration personnel, ideally indicating the health check protocol for easier identification.', example='Ping-IPv4', position='Query'),
  templateId: string(name='TemplateId', description='The ID of the health check template that you want to modify. This ID uniquely identifies the health check template.

This parameter is required.', example='mtp-89518052425100**80', position='Query'),
  timeout?: int32(name='Timeout', description='Probe timeout (in milliseconds), data packets not returned within the timeout period are considered as health check timeouts:
- 2000
- 3000
- 5000
- 10000', example='5000', position='Query'),
}

model UpdateCloudGtmMonitorTemplateResponseBody = {
  requestId?: string(name='RequestId', description='Unique request identification code.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  success?: boolean(name='Success', description='Modify the health check template operation status:
- true: Operation successful
- false: Operation failed', example='true'),
}

model UpdateCloudGtmMonitorTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmMonitorTemplateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateCloudGtmMonitorTemplate  UpdateCloudGtmMonitorTemplateRequest
  * @return UpdateCloudGtmMonitorTemplateResponse
 */
async function updateCloudGtmMonitorTemplate(request: UpdateCloudGtmMonitorTemplateRequest): UpdateCloudGtmMonitorTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCloudGtmMonitorTemplate', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCloudGtmMonitorTemplateRemarkRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US: English', example='en-US', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22', position='Query'),
  remark?: string(name='Remark', description='The new description of the template. If you do not specify this parameter, the original description is deleted.', example='test', position='Query'),
  templateId: string(name='TemplateId', description='The ID of the health check template. This ID uniquely identifies a health check template.

This parameter is required.', example='mtp-89518052455928**00', position='Query'),
}

model UpdateCloudGtmMonitorTemplateRemarkResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  success?: boolean(name='Success', description='Modify the health check template remark operation status:
- true: Operation successful
- false: Operation failed', example='true'),
}

model UpdateCloudGtmMonitorTemplateRemarkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmMonitorTemplateRemarkResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateCloudGtmMonitorTemplateRemark  UpdateCloudGtmMonitorTemplateRemarkRequest
  * @return UpdateCloudGtmMonitorTemplateRemarkResponse
 */
async function updateCloudGtmMonitorTemplateRemark(request: UpdateCloudGtmMonitorTemplateRemarkRequest): UpdateCloudGtmMonitorTemplateRemarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCloudGtmMonitorTemplateRemark', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCustomLineRequest {
  ipSegment?: [ 
    {
      endIp?: string(name='EndIp', description='The end IP address of the CIDR block.', example='2.2.2.2'),
      startIp?: string(name='StartIp', description='The start IP address of the CIDR block.', example='1.1.1.1'),
    }
  ](name='IpSegment', description='The CIDR blocks. Separate IP addresses with a hyphen (-). Enter a CIDR block in each row. You can enter 1 to 50 CIDR blocks at a time. If a CIDR block contains only one IP address, enter the IP address in the format of IP1-IP1. Different CIDR blocks cannot be overlapped.', position='Query'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en', position='Query'),
  lineId: long(name='LineId', description='The unique ID of the custom line. You can call the [DescribeCustomLines](https://www.alibabacloud.com/help/en/dns/api-alidns-2015-01-09-describecustomlines?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the unique ID.

This parameter is required.', example='1234', position='Query'),
  lineName?: string(name='LineName', description='The name of the custom line. The name must be 1 to 20 characters in length and can contain letters, digits, hyphens (-), and underscores (_).', position='Query'),
}

model UpdateCustomLineResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
}

model UpdateCustomLineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCustomLineResponseBody(name='body'),
}

/**
  * @description In each CIDR block, the end IP address must be greater than or equal to the start IP address.\\
  * The CIDR blocks that are specified for all custom lines of a domain name cannot be overlapped.
  * @param request  the request parameters of UpdateCustomLine  UpdateCustomLineRequest
  * @return UpdateCustomLineResponse
 */
async function updateCustomLine(request: UpdateCustomLineRequest): UpdateCustomLineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCustomLine', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDNSSLBWeightRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en', position='Query'),
  recordId: string(name='RecordId', description='The ID of the DNS record. You can call the [DescribeDomainRecords](https://www.alibabacloud.com/help/en/dns/api-alidns-2015-01-09-describedomainrecords?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.

This parameter is required.', example='9999985', position='Query'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='1.1.1.1', position='Query'),
  weight: int32(name='Weight', description='The weight of the DNS record that you want to specify. Valid values: `1 to 100`.

This parameter is required.', example='2', position='Query'),
}

model UpdateDNSSLBWeightResponseBody = {
  recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  weight?: int32(name='Weight', description='The updated weight.', example='2'),
}

model UpdateDNSSLBWeightResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDNSSLBWeightResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateDNSSLBWeight  UpdateDNSSLBWeightRequest
  * @return UpdateDNSSLBWeightResponse
 */
async function updateDNSSLBWeight(request: UpdateDNSSLBWeightRequest): UpdateDNSSLBWeightResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDNSSLBWeight', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDnsCacheDomainRequest {
  cacheTtlMax?: int32(name='CacheTtlMax', description='The maximum TTL period of the cached data retrieved from the origin DNS server. Unit: seconds. Valid values: 30 to 86400.', example='86400', minimum=30, maximum=86400, position='Query'),
  cacheTtlMin?: int32(name='CacheTtlMin', description='The minimum time-to-live (TTL) period of the cached data retrieved from the origin Domain Name System (DNS) server. Unit: seconds. Valid values: 30 to 86400.', example='30', minimum=30, maximum=86400, position='Query'),
  domainName: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtian the domain name.

This parameter is required.', example='dns.example.com', position='Query'),
  instanceId?: string(name='InstanceId', description='The instance ID of the cache-accelerated domain name. You can call the [ListCloudGtmInstances](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-listcloudgtminstances?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.', example='dns-sg-l9u2ux1fw01', position='Query'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English Default: **zh**', example='en', position='Query'),
  sourceDnsServer?: [ 
    {
      host?: string(name='Host', description='The domain name or IP address of the origin DNS server.', example='223.5.5.5'),
      port?: string(name='Port', description='The port of the origin DNS server.', example='53'),
    }
  ](name='SourceDnsServer', description='The origin DNS servers. A maximum of 10 origin DNS servers are supported.', position='Query'),
  sourceEdns?: string(name='SourceEdns', description='Specifies whether the origin DNS server supports Extension Mechanisms for DNS (EDNS). Valid values: NOT_SUPPORT and SUPPORT.', example='SUPPORT', position='Query'),
  sourceProtocol?: string(name='SourceProtocol', description='The origin protocol policy. Valid values: TCP and UDP. Default value: UDP.', example='UDP', position='Query'),
}

model UpdateDnsCacheDomainResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model UpdateDnsCacheDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDnsCacheDomainResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateDnsCacheDomain  UpdateDnsCacheDomainRequest
  * @return UpdateDnsCacheDomainResponse
 */
async function updateDnsCacheDomain(request: UpdateDnsCacheDomainRequest): UpdateDnsCacheDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDnsCacheDomain', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDnsCacheDomainRemarkRequest {
  domainName: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.

This parameter is required.', example='dns-example.com', position='Query'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English

Default: **zh**', example='en', position='Query'),
  remark?: string(name='Remark', description='The remarks. The remarks can be up to 50 characters in length and can contain only letters, digits, periods (.), underscores (_), and hyphens (-).

Delete the original remarks when it is empty.', example='test', position='Query'),
}

model UpdateDnsCacheDomainRemarkResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model UpdateDnsCacheDomainRemarkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDnsCacheDomainRemarkResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateDnsCacheDomainRemark  UpdateDnsCacheDomainRemarkRequest
  * @return UpdateDnsCacheDomainRemarkResponse
 */
async function updateDnsCacheDomainRemark(request: UpdateDnsCacheDomainRemarkRequest): UpdateDnsCacheDomainRemarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDnsCacheDomainRemark', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDnsGtmAccessStrategyRequest {
  accessMode?: string(name='AccessMode', description='The primary/secondary switchover policy for address pool sets. Valid values:

*   AUTO: performs automatic switchover between the primary and secondary address pool sets upon failures.
*   DEFAULT: the primary address pool set
*   FAILOVER: the secondary address pool set', example='DEFAULT', position='Query'),
  defaultAddrPool: [ 
    {
      id?: string(name='Id', description='The ID of the address pool in the primary address pool set.', example='pool1'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool in the primary address pool set.', example='1'),
    }
  ](name='DefaultAddrPool', description='The address pools in the primary address pool set.

This parameter is required.', position='Query'),
  defaultAddrPoolType: string(name='DefaultAddrPoolType', description='The type of the primary address pool. Valid values:

*   IPV4
*   IPV6
*   DOMAIN

This parameter is required.', example='ipv4', position='Query'),
  defaultLatencyOptimization?: string(name='DefaultLatencyOptimization', description='Specifies whether to enable Domain Name System (DNS) resolution with optimal latency for the primary address pool set. Valid values:

*   OPEN
*   CLOSE', example='open', position='Query'),
  defaultLbaStrategy?: string(name='DefaultLbaStrategy', description='The load balancing policy of the primary address pool set. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr', position='Query'),
  defaultMaxReturnAddrNum?: int32(name='DefaultMaxReturnAddrNum', description='The maximum number of addresses returned from the primary address pool set.', example='1', minimum=1, maximum=8, position='Query'),
  defaultMinAvailableAddrNum: int32(name='DefaultMinAvailableAddrNum', description='The minimum number of available addresses in the primary address pool set.

This parameter is required.', example='1', minimum=1, maximum=400, position='Query'),
  failoverAddrPool?: [ 
    {
      id?: string(name='Id', description='The ID of the address pool in the secondary address pool set.', example='pool1'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool in the secondary address pool set.', example='1'),
    }
  ](name='FailoverAddrPool', description='The address pools in the secondary address pool set. If no address pool exists in the secondary address pool set, set this parameter to EMPTY.', position='Query'),
  failoverAddrPoolType?: string(name='FailoverAddrPoolType', description='The type of the secondary address pool. Valid values:

*   IPV4
*   IPV6
*   DOMAIN', example='ipv4', position='Query'),
  failoverLatencyOptimization?: string(name='FailoverLatencyOptimization', description='Specifies whether to enable DNS resolution with optimal latency for the secondary address pool set. Valid values:

*   OPEN
*   CLOSE', example='open', position='Query'),
  failoverLbaStrategy?: string(name='FailoverLbaStrategy', description='The load balancing policy of the secondary address pool set. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr', position='Query'),
  failoverMaxReturnAddrNum?: int32(name='FailoverMaxReturnAddrNum', description='The maximum number of addresses returned from the secondary address pool set.', example='1', minimum=1, maximum=8, position='Query'),
  failoverMinAvailableAddrNum?: int32(name='FailoverMinAvailableAddrNum', description='The minimum number of available addresses in the secondary address pool set.', example='1', minimum=1, maximum=400, position='Query'),
  lang?: string(name='Lang', description='The language of the values for specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
  lines?: string(name='Lines', description='The line codes of the source regions. Example: `["default", "drpeng"]`, which indicates the global line and Dr. Peng Group line.', example='["default", "drpeng"]', position='Query'),
  strategyId: string(name='StrategyId', description='The ID of the access policy.

This parameter is required.', example='StrategyId1', position='Query'),
  strategyName: string(name='StrategyName', description='The name of the access policy.

This parameter is required.', example='StrategyName1', position='Query'),
}

model UpdateDnsGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy.', example='testStrategyId1'),
}

model UpdateDnsGtmAccessStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDnsGtmAccessStrategyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateDnsGtmAccessStrategy  UpdateDnsGtmAccessStrategyRequest
  * @return UpdateDnsGtmAccessStrategyResponse
 */
async function updateDnsGtmAccessStrategy(request: UpdateDnsGtmAccessStrategyRequest): UpdateDnsGtmAccessStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDnsGtmAccessStrategy', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDnsGtmAddressPoolRequest {
  addr: [ 
    {
      addr: string(name='Addr', description='The address in the address pool.

This parameter is required.', example='1.1.1.1'),
      attributeInfo?: string(name='AttributeInfo', description='The information about the source region of the address. The value of the parameter is a string in the JSON format. Valid values:

*   LineCode: the line code of the source region. This parameter is deprecated. Use lineCodes instead.

*   lineCodes: the line codes of the source region

*   lineCodeRectifyType: the rectification type of the line code. Default value: AUTO. Valid values:

    *   NO_NEED: no need for rectification
    *   RECTIFIED: rectified
    *   AUTO: automatic rectification', example='Linecode:default,lineCodes:["default"],lineCodeRectifyType:"NO_NEED"'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address.', example='1'),
      mode: string(name='Mode', description='The return mode of the addresses. Valid values:

*   SMART: smart return
*   ONLINE: always online
*   OFFLINE: always offline

This parameter is required.', example='online'),
      remark?: string(name='Remark', description='The description of the address pool.', example='test'),
    }
  ](name='Addr', description='The address pools.

This parameter is required.', position='Query'),
  addrPoolId: string(name='AddrPoolId', description='The ID of the address pool.

This parameter is required.', example='testpool1', position='Query'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
  lbaStrategy: string(name='LbaStrategy', description='The load balancing policy of the address pool. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.

This parameter is required.', example='all_rr', position='Query'),
  name?: string(name='Name', description='The name of the address pool.', example='testpoolname', position='Query'),
}

model UpdateDnsGtmAddressPoolResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model UpdateDnsGtmAddressPoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDnsGtmAddressPoolResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateDnsGtmAddressPool  UpdateDnsGtmAddressPoolRequest
  * @return UpdateDnsGtmAddressPoolResponse
 */
async function updateDnsGtmAddressPool(request: UpdateDnsGtmAddressPoolRequest): UpdateDnsGtmAddressPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDnsGtmAddressPool', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDnsGtmInstanceGlobalConfigRequest {
  alertConfig?: [ 
    {
      dingtalkNotice?: boolean(name='DingtalkNotice', example='true'),
      emailNotice?: boolean(name='EmailNotice', example='true'),
      noticeType?: string(name='NoticeType', example='ADDR_ALERT'),
      smsNotice?: boolean(name='SmsNotice', example='true'),
    }
  ](name='AlertConfig', position='Query'),
  alertGroup?: string(name='AlertGroup', description='The name of the alert group in the JSON format.', example='alertGroup1', position='Query'),
  cnameType?: string(name='CnameType', description='The type of the canonical name (CNAME).

*   Set the value to PUBLIC.', example='public', position='Query'),
  forceUpdate?: boolean(name='ForceUpdate', description='Specifies whether to enable force updates. Valid values:

*   true: enables force update without a conflict alert.
*   false: disables force update. If a conflict occurs, the system displays an alert. null: This valid value of ForceUpdate provides the same information as the false value.', example='true', position='Query'),
  instanceId: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='instance1', position='Query'),
  instanceName?: string(name='InstanceName', description='The name of the instance. This parameter is required only for the first update.', example='test', position='Query'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
  publicCnameMode?: string(name='PublicCnameMode', description='Specifies whether to use a custom CNAME domain name or a CNAME domain name assigned by the system to access the instance over the Internet. Valid values:

*   SYSTEM_ASSIGN: a CNAME domain name assigned by the system
*   CUSTOM: a custom CNAME domain name', example='custom', position='Query'),
  publicRr?: string(name='PublicRr', description='The hostname corresponding to the CNAME domain name that is used to access the instance over the Internet.', example='test.rr', position='Query'),
  publicUserDomainName?: string(name='PublicUserDomainName', description='The service domain name that is used over the Internet.', example='example.com', position='Query'),
  publicZoneName?: string(name='PublicZoneName', description='The CNAME domain name that is used to access the instance over the Internet, which is the primary domain name. This parameter is required when the PublicCnameMode parameter is set to CUSTOM.

>  You must use the primary domain name. Do not include the hostname specified by the PublicRr parameter.', example='gtm-003.com', position='Query'),
  ttl?: int32(name='Ttl', description='The global time to live (TTL).', example='1', minimum=1, maximum=9999999, position='Query'),
}

model UpdateDnsGtmInstanceGlobalConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
}

model UpdateDnsGtmInstanceGlobalConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDnsGtmInstanceGlobalConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateDnsGtmInstanceGlobalConfig  UpdateDnsGtmInstanceGlobalConfigRequest
  * @return UpdateDnsGtmInstanceGlobalConfigResponse
 */
async function updateDnsGtmInstanceGlobalConfig(request: UpdateDnsGtmInstanceGlobalConfigRequest): UpdateDnsGtmInstanceGlobalConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDnsGtmInstanceGlobalConfig', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDnsGtmMonitorRequest {
  evaluationCount?: int32(name='EvaluationCount', description='The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.', example='2', minimum=1, maximum=3, position='Query'),
  interval?: int32(name='Interval', description='The health check interval. Unit: seconds.', example='60', minimum=15, maximum=60, position='Query'),
  ispCityNode: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the city where the monitored node is deployed.', example='123'),
      ispCode?: string(name='IspCode', description='The code of the Internet service provider (ISP) to which the monitored node belongs.', example='123'),
    }
  ](name='IspCityNode', description='The monitored nodes.

This parameter is required.', position='Query'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en', position='Query'),
  monitorConfigId: string(name='MonitorConfigId', description='The ID of the health check configuration.

This parameter is required.', example='MonitorConfigId1', position='Query'),
  monitorExtendInfo: string(name='MonitorExtendInfo', description='The extended information. The required parameters vary based on the health check protocol.

*   HTTP or HTTPS

    *   port: the port that you want to check

    *   host: the host settings

    *   path: the URL path

    *   code: the return code. If the return value of code is greater than the specified value, the health check result is deemed abnormal. For example, if code is set to 400 and the code 404 is returned, the health check result is deemed abnormal.

    *   failureRate: the failure rate

    *   sni: specifies whether to enable server name indication (SNI). This parameter is available only when ProtocolType is set to HTTPS. Valid values:

        *   true: enables SNI.
        *   false: disables SNI.

    *   nodeType: the type of the monitoring node when the address pool type is domain name. Valid values:

        *   IPV4
        *   IPV6

*   PING

    *   failureRate: the failure rate

    *   packetNum: the number of ping packets

    *   packetLossRate: the loss rate of ping packets

    *   nodeType: the type of the monitoring node when the address pool type is domain name. Valid values:

        *   IPV4
        *   IPV6

*   TCP

    *   port: the port that you want to check

    *   failureRate: the failure rate

    *   nodeType: the type of the monitoring node when the address pool type is domain name. Valid values:

        *   IPV4
        *   IPV6

This parameter is required.', example='{\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}', position='Query'),
  protocolType: string(name='ProtocolType', description='The protocol used for the health check. Valid values:

*   HTTP
*   HTTPS
*   PING
*   TCP

This parameter is required.', example='http', position='Query'),
  timeout?: int32(name='Timeout', description='The timeout period. Unit: milliseconds.', example='3000', minimum=1000, maximum=10000, position='Query'),
}

model UpdateDnsGtmMonitorResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model UpdateDnsGtmMonitorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDnsGtmMonitorResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateDnsGtmMonitor  UpdateDnsGtmMonitorRequest
  * @return UpdateDnsGtmMonitorResponse
 */
async function updateDnsGtmMonitor(request: UpdateDnsGtmMonitorRequest): UpdateDnsGtmMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDnsGtmMonitor', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDomainGroupRequest {
  groupId: string(name='GroupId', description='The ID of the domain name group whose name you want to modify. You can call the [DescribeDomainGroups ](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomaingroups?spm=a2c63.p38356.help-menu-search-29697.d_0)operation to obtain the ID.

This parameter is required.', example='2223', position='Query'),
  groupName: string(name='GroupName', description='The new name of the domain name group.

This parameter is required.', example='NewName', position='Query'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en.', example='en', position='Query'),
}

model UpdateDomainGroupResponseBody = {
  groupId?: string(name='GroupId', description='The ID of the domain name group.', example='2223'),
  groupName?: string(name='GroupName', description='The new name of the domain name group.', example='NewName'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model UpdateDomainGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDomainGroupResponseBody(name='body'),
}

/**
  * @description Modifies the name of an existing domain name group.
  * @param request  the request parameters of UpdateDomainGroup  UpdateDomainGroupRequest
  * @return UpdateDomainGroupResponse
 */
async function updateDomainGroup(request: UpdateDomainGroupRequest): UpdateDomainGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDomainGroup', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDomainRecordRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en', position='Query'),
  line?: string(name='Line', description='The resolution line. Default value: **default**.

For more information, see

[DNS resolution lines](https://www.alibabacloud.com/help/zh/doc-detail/29807.htm).', example='default', position='Query'),
  priority?: long(name='Priority', description='The priority of the mail exchanger (MX) record. Valid values: `1 to 50`.

This parameter is required if the type of the DNS record is MX.', example='1', minimum=0, maximum=65535, position='Query'),
  rr: string(name='RR', description='The hostname.

For example, if you want to resolve @.example.com, you must set RR to an at sign (@) instead of leaving it empty.

This parameter is required.', example='www', position='Query'),
  recordId: string(name='RecordId', description='The ID of the Domain Name System (DNS) record.

You can call the [DescribeDomainRecords](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomainrecords?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.

This parameter is required.', example='9999985', position='Query'),
  TTL?: long(name='TTL', description='The time to live (TTL) period of the Alibaba Cloud DNS (DNS) record. Default value: 600. Unit: seconds.

For more information, see

[TTL definition](https://www.alibabacloud.com/help/zh/doc-detail/29806.htm).', example='600', minimum=1, maximum=86400, position='Query'),
  type: string(name='Type', description='The type of the DNS record. For more information, see

[DNS record types](https://www.alibabacloud.com/help/zh/doc-detail/29805.htm).

This parameter is required.', example='A', position='Query'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0', position='Query'),
  value: string(name='Value', description='The value of the DNS record.

This parameter is required.', example='192.0.2.254', position='Query'),
}

model UpdateDomainRecordResponseBody = {
  recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model UpdateDomainRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDomainRecordResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateDomainRecord  UpdateDomainRecordRequest
  * @return UpdateDomainRecordResponse
 */
async function updateDomainRecord(request: UpdateDomainRecordRequest): UpdateDomainRecordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDomainRecord', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDomainRecordRemarkRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='cn', position='Query'),
  recordId: string(name='RecordId', description='The ID of the DNS record. You can call the [DescribeDomainRecords](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomainrecords?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.

This parameter is required.', example='12345678', position='Query'),
  remark?: string(name='Remark', description='The description of the DNS record. This parameter is empty by default. If this parameter is empty, the original remarks are deleted.', position='Query'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0', position='Query'),
}

model UpdateDomainRecordRemarkResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model UpdateDomainRecordRemarkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDomainRecordRemarkResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateDomainRecordRemark  UpdateDomainRecordRemarkRequest
  * @return UpdateDomainRecordRemarkResponse
 */
async function updateDomainRecordRemark(request: UpdateDomainRecordRemarkRequest): UpdateDomainRecordRemarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDomainRecordRemark', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDomainRemarkRequest {
  domainName: string(name='DomainName', description='The domain name that already exists in Alibaba Cloud Domain Name System (DNS). You can call the [DescribeDomains ](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0)operation to obtain the domain name.

This parameter is required.', example='mydomain.com', position='Query'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en', example='cn', position='Query'),
  remark?: string(name='Remark', description='The description of the domain name.

It can be up to 50 characters in length and can contain digits, letters, and the following special characters: _ - , .', position='Query'),
}

model UpdateDomainRemarkResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model UpdateDomainRemarkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDomainRemarkResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateDomainRemark  UpdateDomainRemarkRequest
  * @return UpdateDomainRemarkResponse
 */
async function updateDomainRemark(request: UpdateDomainRemarkRequest): UpdateDomainRemarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDomainRemark', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGtmAccessStrategyRequest {
  accessLines?: string(name='AccessLines', description='The line codes of access regions.', example='["default", "mobile"]', position='Query'),
  defaultAddrPoolId?: string(name='DefaultAddrPoolId', description='The ID of the default address pool.', example='hrsix', position='Query'),
  failoverAddrPoolId?: string(name='FailoverAddrPoolId', description='The ID of the failover address pool.', example='hrsyw', position='Query'),
  lang?: string(name='Lang', description='The language used by the user.', example='en', position='Query'),
  strategyId: string(name='StrategyId', description='The ID of the access policy that you want to query for the GTM instance.

This parameter is required.', example='hrmxc', position='Query'),
  strategyName?: string(name='StrategyName', description='The name of the access policy.', position='Query'),
}

model UpdateGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
}

model UpdateGtmAccessStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateGtmAccessStrategyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateGtmAccessStrategy  UpdateGtmAccessStrategyRequest
  * @return UpdateGtmAccessStrategyResponse
 */
async function updateGtmAccessStrategy(request: UpdateGtmAccessStrategyRequest): UpdateGtmAccessStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGtmAccessStrategy', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGtmAddressPoolRequest {
  addr: [ 
    {
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool that you want to modify.', example='1'),
      mode?: string(name='Mode', description='The mode of the address pool that you want to modify.

*   **SMART**: Intelligent return
*   **ONLINE**: Always online
*   **OFFLINE**: Always offline', example='SMART'),
      value?: string(name='Value', description='The addresses in the address pool.', example='1.1.1.1'),
    }
  ](name='Addr', description='This parameter is required.', position='Query'),
  addrPoolId: string(name='AddrPoolId', description='The ID of the address pool that you want to modify.

This parameter is required.', example='1234abc', position='Query'),
  lang?: string(name='Lang', description='The language used by the user.', example='en', position='Query'),
  minAvailableAddrNum?: int32(name='MinAvailableAddrNum', description='The minimum number of available addresses in the address pool.', example='2', position='Query'),
  name?: string(name='Name', description='The name of the address pool that you want to modify.', position='Query'),
  type: string(name='Type', description='The type of the address pool that you want to modify.

This parameter is required.', example='IP', position='Query'),
}

model UpdateGtmAddressPoolResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model UpdateGtmAddressPoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateGtmAddressPoolResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateGtmAddressPool  UpdateGtmAddressPoolRequest
  * @return UpdateGtmAddressPoolResponse
 */
async function updateGtmAddressPool(request: UpdateGtmAddressPoolRequest): UpdateGtmAddressPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGtmAddressPool', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGtmInstanceGlobalConfigRequest {
  alertGroup?: string(name='AlertGroup', description='The alert group. Only one alert group is supported.

>  This parameter is required only for the first modification.', position='Query'),
  cnameCustomDomainName?: string(name='CnameCustomDomainName', description='If you set **CnameMode** to **CUSTOM**, you must specify the CnameCustomDomainName parameter, which must be set to a primary domain name.', example='www.example.com', position='Query'),
  cnameMode?: string(name='CnameMode', description='Specifies whether to use a system-assigned canonical name (CNAME) or a custom CNAME to access GTM. Valid values:

*   **SYSTEM_ASSIGN**: system-assigned CNAME
*   **CUSTOM**: custom CNAME', example='SYSTEM_ASSIGN', position='Query'),
  instanceId: string(name='InstanceId', description='The ID of the GTM instance.

This parameter is required.', example='instance1', position='Query'),
  instanceName?: string(name='InstanceName', description='The name of the GTM instance.

>  This parameter is required only for the first modification.', position='Query'),
  lang?: string(name='Lang', description='The language.', example='en', position='Query'),
  lbaStrategy?: string(name='LbaStrategy', description='The balancing policy. Valid values:

*   **ALL_RR**: load balancing
*   **RATIO**: weighted round-robin

>  This parameter is required only for the first modification.', example='RATIO', position='Query'),
  ttl?: int32(name='Ttl', description='The global time-to-live (TTL).', example='60', position='Query'),
  userDomainName?: string(name='UserDomainName', description='The primary domain name.

>  This parameter is required only for the first modification.', example='www.example.com', position='Query'),
}

model UpdateGtmInstanceGlobalConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
}

model UpdateGtmInstanceGlobalConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateGtmInstanceGlobalConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateGtmInstanceGlobalConfig  UpdateGtmInstanceGlobalConfigRequest
  * @return UpdateGtmInstanceGlobalConfigResponse
 */
async function updateGtmInstanceGlobalConfig(request: UpdateGtmInstanceGlobalConfigRequest): UpdateGtmInstanceGlobalConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGtmInstanceGlobalConfig', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGtmMonitorRequest {
  evaluationCount?: int32(name='EvaluationCount', description='The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.', example='3', position='Query'),
  interval?: int32(name='Interval', description='The health check interval. Unit: seconds. Set the value to 60.', example='60', position='Query'),
  ispCityNode: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the city where the monitored node is deployed.', example='572'),
      ispCode?: string(name='IspCode', description='*   The code of the Internet service provider (ISP) to which the monitored node belongs. For more information about specific values, see the response parameters of DescribeGtmMonitorAvailableConfig.
*   If the value of the GroupType parameter is BGP or OVERSEAS, IspCode is optional. The default value is 465.
*   If the value of the GroupType parameter is not BGP or OVERSEAS, IspCode is required and is used together with CityCode.', example='465'),
    }
  ](name='IspCityNode', description='The monitored nodes.

This parameter is required.', position='Query'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters.', example='en', position='Query'),
  monitorConfigId: string(name='MonitorConfigId', description='The ID of the health check configuration.

This parameter is required.', example='1234abc', position='Query'),
  monitorExtendInfo: string(name='MonitorExtendInfo', description='The extended information, that is, the parameters required for the protocol. Different protocols require different parameters:

HTTP or HTTPS:

*   port: the port to check.
*   failureRate: the failure rate.
*   code: the status code threshold. If the returned status code is greater than the specified threshold, the application service is deemed abnormal. Valid values: 400 and 500.
*   host: the host configuration.
*   path: the health check URL.

PING:

*   packetNum: the number of ping packets.
*   packetLossRate: the loss rate of ping packets.
*   failureRate: the failure rate.

TCP:

*   port: the port to check.
*   failureRate: the failure rate.

This parameter is required.', example='{\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}', position='Query'),
  protocolType: string(name='ProtocolType', description='The protocol used for the health check.

This parameter is required.', example='HTTP', position='Query'),
  timeout?: int32(name='Timeout', description='The health check timeout period. Unit: milliseconds. Valid values: 2000, 3000, 5000, and 10000.', example='3000', position='Query'),
}

model UpdateGtmMonitorResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model UpdateGtmMonitorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateGtmMonitorResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateGtmMonitor  UpdateGtmMonitorRequest
  * @return UpdateGtmMonitorResponse
 */
async function updateGtmMonitor(request: UpdateGtmMonitorRequest): UpdateGtmMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGtmMonitor', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGtmRecoveryPlanRequest {
  faultAddrPool?: string(name='FaultAddrPool', description='The list of faulty address pools.', example='["hra0or"]', position='Query'),
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.', example='en', position='Query'),
  name?: string(name='Name', description='The name of the disaster recovery plan.', example='abc', position='Query'),
  recoveryPlanId: long(name='RecoveryPlanId', description='The ID of the disaster recovery plan.

This parameter is required.', example='100', position='Query'),
  remark?: string(name='Remark', description='The remarks about the disaster recovery plan.', example='remark', position='Query'),
}

model UpdateGtmRecoveryPlanResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model UpdateGtmRecoveryPlanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateGtmRecoveryPlanResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateGtmRecoveryPlan  UpdateGtmRecoveryPlanRequest
  * @return UpdateGtmRecoveryPlanResponse
 */
async function updateGtmRecoveryPlan(request: UpdateGtmRecoveryPlanRequest): UpdateGtmRecoveryPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGtmRecoveryPlan', 'POST', '/', 'json', false, 'json', request);
}

model UpdateIspFlushCacheInstanceConfigRequest {
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  instanceName: string(name='InstanceName', description='This parameter is required.', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model UpdateIspFlushCacheInstanceConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIspFlushCacheInstanceConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateIspFlushCacheInstanceConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateIspFlushCacheInstanceConfig  UpdateIspFlushCacheInstanceConfigRequest
  * @return UpdateIspFlushCacheInstanceConfigResponse
 */
async function updateIspFlushCacheInstanceConfig(request: UpdateIspFlushCacheInstanceConfigRequest): UpdateIspFlushCacheInstanceConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateIspFlushCacheInstanceConfig', 'POST', '/', 'json', false, 'json', request);
}

model ValidateDnsGtmCnameRrCanUseRequest {
  cnameMode: string(name='CnameMode', description='This parameter is required.', position='Query'),
  cnameRr: string(name='CnameRr', description='This parameter is required.', position='Query'),
  cnameType: string(name='CnameType', description='This parameter is required.', position='Query'),
  cnameZone: string(name='CnameZone', description='This parameter is required.', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model ValidateDnsGtmCnameRrCanUseResponseBody = {
  requestId?: string(name='RequestId'),
}

model ValidateDnsGtmCnameRrCanUseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ValidateDnsGtmCnameRrCanUseResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ValidateDnsGtmCnameRrCanUse  ValidateDnsGtmCnameRrCanUseRequest
  * @return ValidateDnsGtmCnameRrCanUseResponse
 */
async function validateDnsGtmCnameRrCanUse(request: ValidateDnsGtmCnameRrCanUseRequest): ValidateDnsGtmCnameRrCanUseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ValidateDnsGtmCnameRrCanUse', 'POST', '/', 'json', false, 'json', request);
}

model ValidatePdnsUdpIpSegmentRequest {
  ip?: string(name='Ip', position='Query'),
  ipToken?: string(name='IpToken', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model ValidatePdnsUdpIpSegmentResponseBody = {
  requestId?: string(name='RequestId'),
}

model ValidatePdnsUdpIpSegmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ValidatePdnsUdpIpSegmentResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ValidatePdnsUdpIpSegment  ValidatePdnsUdpIpSegmentRequest
  * @return ValidatePdnsUdpIpSegmentResponse
 */
async function validatePdnsUdpIpSegment(request: ValidatePdnsUdpIpSegmentRequest): ValidatePdnsUdpIpSegmentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ValidatePdnsUdpIpSegment', 'POST', '/', 'json', false, 'json', request);
}

