/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Alidns';
  @version = '2015-01-09';
  @endpointRule = 'central';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AddCustomLineRequest {
  domainName: string(name='DomainName', position='Query'),
  ipSegment: [ 
    {
      endIp?: string(name='EndIp'),
      startIp?: string(name='StartIp'),
    }
  ](name='IpSegment', position='Query'),
  lang?: string(name='Lang', position='Query'),
  lineName: string(name='LineName', position='Query'),
}

model AddCustomLineResponseBody = {
  lineCode?: string(name='LineCode'),
  lineId?: long(name='LineId'),
  requestId?: string(name='RequestId'),
}

model AddCustomLineResponse = {
  headers: map[string]string(name='headers'),
  body: AddCustomLineResponseBody(name='body'),
}

async function addCustomLine(request: AddCustomLineRequest): AddCustomLineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddCustomLine', 'POST', '/', 'json', false, 'json', request);
}

model AddDnsCacheDomainRequest {
  cacheTtlMax: int32(name='CacheTtlMax', minimum=30, maximum=86400, position='Query'),
  cacheTtlMin: int32(name='CacheTtlMin', minimum=30, maximum=86400, position='Query'),
  domainName: string(name='DomainName', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  remark?: string(name='Remark', position='Query'),
  sourceDnsServer: [ 
    {
      host: string(name='Host'),
      port: string(name='Port'),
    }
  ](name='SourceDnsServer', position='Query'),
  sourceEdns: string(name='SourceEdns', position='Query'),
  sourceProtocol: string(name='SourceProtocol', position='Query'),
}

model AddDnsCacheDomainResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddDnsCacheDomainResponse = {
  headers: map[string]string(name='headers'),
  body: AddDnsCacheDomainResponseBody(name='body'),
}

async function addDnsCacheDomain(request: AddDnsCacheDomainRequest): AddDnsCacheDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddDnsCacheDomain', 'POST', '/', 'json', false, 'json', request);
}

model AddDnsGtmAccessStrategyRequest {
  defaultAddrPool: [ 
    {
      id?: string(name='Id'),
      lbaWeight?: int32(name='LbaWeight'),
    }
  ](name='DefaultAddrPool', position='Query'),
  defaultAddrPoolType: string(name='DefaultAddrPoolType', position='Query'),
  defaultLatencyOptimization?: string(name='DefaultLatencyOptimization', position='Query'),
  defaultLbaStrategy?: string(name='DefaultLbaStrategy', position='Query'),
  defaultMaxReturnAddrNum?: int32(name='DefaultMaxReturnAddrNum', minimum=1, maximum=8, position='Query'),
  defaultMinAvailableAddrNum: int32(name='DefaultMinAvailableAddrNum', minimum=1, maximum=400, position='Query'),
  failoverAddrPool?: [ 
    {
      id?: string(name='Id'),
      lbaWeight?: int32(name='LbaWeight'),
    }
  ](name='FailoverAddrPool', position='Query'),
  failoverAddrPoolType?: string(name='FailoverAddrPoolType', position='Query'),
  failoverLatencyOptimization?: string(name='FailoverLatencyOptimization', position='Query'),
  failoverLbaStrategy?: string(name='FailoverLbaStrategy', position='Query'),
  failoverMaxReturnAddrNum?: int32(name='FailoverMaxReturnAddrNum', minimum=1, maximum=8, position='Query'),
  failoverMinAvailableAddrNum?: int32(name='FailoverMinAvailableAddrNum', minimum=1, maximum=400, position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  lines?: string(name='Lines', position='Query'),
  strategyMode: string(name='StrategyMode', position='Query'),
  strategyName: string(name='StrategyName', position='Query'),
}

model AddDnsGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId'),
  strategyId?: string(name='StrategyId'),
}

model AddDnsGtmAccessStrategyResponse = {
  headers: map[string]string(name='headers'),
  body: AddDnsGtmAccessStrategyResponseBody(name='body'),
}

async function addDnsGtmAccessStrategy(request: AddDnsGtmAccessStrategyRequest): AddDnsGtmAccessStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddDnsGtmAccessStrategy', 'POST', '/', 'json', false, 'json', request);
}

model AddDnsGtmAddressPoolRequest {
  addr: [ 
    {
      addr: string(name='Addr'),
      attributeInfo: string(name='AttributeInfo'),
      lbaWeight?: int32(name='LbaWeight'),
      mode: string(name='Mode'),
      remark?: string(name='Remark'),
    }
  ](name='Addr', position='Query'),
  evaluationCount?: int32(name='EvaluationCount', minimum=1, maximum=9999999, position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  interval?: int32(name='Interval', minimum=1, maximum=9999999, position='Query'),
  ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode'),
      ispCode?: string(name='IspCode'),
    }
  ](name='IspCityNode', position='Query'),
  lang?: string(name='Lang', position='Query'),
  lbaStrategy: string(name='LbaStrategy', position='Query'),
  monitorExtendInfo?: string(name='MonitorExtendInfo', position='Query'),
  monitorStatus?: string(name='MonitorStatus', position='Query'),
  name: string(name='Name', position='Query'),
  protocolType?: string(name='ProtocolType', position='Query'),
  timeout?: int32(name='Timeout', minimum=1, maximum=9999999, position='Query'),
  type: string(name='Type', position='Query'),
}

model AddDnsGtmAddressPoolResponseBody = {
  addrPoolId?: string(name='AddrPoolId'),
  monitorConfigId?: string(name='MonitorConfigId'),
  requestId?: string(name='RequestId'),
}

model AddDnsGtmAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  body: AddDnsGtmAddressPoolResponseBody(name='body'),
}

async function addDnsGtmAddressPool(request: AddDnsGtmAddressPoolRequest): AddDnsGtmAddressPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddDnsGtmAddressPool', 'POST', '/', 'json', false, 'json', request);
}

model AddDnsGtmMonitorRequest {
  addrPoolId: string(name='AddrPoolId', position='Query'),
  evaluationCount: int32(name='EvaluationCount', minimum=1, maximum=3, position='Query'),
  interval: int32(name='Interval', minimum=15, maximum=60, position='Query'),
  ispCityNode: [ 
    {
      cityCode?: string(name='CityCode'),
      ispCode?: string(name='IspCode'),
    }
  ](name='IspCityNode', position='Query'),
  lang?: string(name='Lang', position='Query'),
  monitorExtendInfo: string(name='MonitorExtendInfo', position='Query'),
  protocolType: string(name='ProtocolType', position='Query'),
  timeout: int32(name='Timeout', minimum=1000, maximum=10000, position='Query'),
}

model AddDnsGtmMonitorResponseBody = {
  monitorConfigId?: string(name='MonitorConfigId'),
  requestId?: string(name='RequestId'),
}

model AddDnsGtmMonitorResponse = {
  headers: map[string]string(name='headers'),
  body: AddDnsGtmMonitorResponseBody(name='body'),
}

async function addDnsGtmMonitor(request: AddDnsGtmMonitorRequest): AddDnsGtmMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddDnsGtmMonitor', 'POST', '/', 'json', false, 'json', request);
}

model AddDomainRequest {
  domainName: string(name='DomainName', position='Query'),
  groupId?: string(name='GroupId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
}

model AddDomainResponseBody = {
  dnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='DnsServers'),
  domainId?: string(name='DomainId'),
  domainName?: string(name='DomainName'),
  groupId?: string(name='GroupId'),
  groupName?: string(name='GroupName'),
  punyCode?: string(name='PunyCode'),
  requestId?: string(name='RequestId'),
}

model AddDomainResponse = {
  headers: map[string]string(name='headers'),
  body: AddDomainResponseBody(name='body'),
}

async function addDomain(request: AddDomainRequest): AddDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddDomain', 'POST', '/', 'json', false, 'json', request);
}

model AddDomainBackupRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  periodType: string(name='PeriodType', position='Query'),
}

model AddDomainBackupResponseBody = {
  domainName?: string(name='DomainName'),
  periodType?: string(name='PeriodType'),
  requestId?: string(name='RequestId'),
}

model AddDomainBackupResponse = {
  headers: map[string]string(name='headers'),
  body: AddDomainBackupResponseBody(name='body'),
}

async function addDomainBackup(request: AddDomainBackupRequest): AddDomainBackupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddDomainBackup', 'POST', '/', 'json', false, 'json', request);
}

model AddDomainGroupRequest {
  groupName: string(name='GroupName', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model AddDomainGroupResponseBody = {
  groupId?: string(name='GroupId'),
  groupName?: string(name='GroupName'),
  requestId?: string(name='RequestId'),
}

model AddDomainGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AddDomainGroupResponseBody(name='body'),
}

async function addDomainGroup(request: AddDomainGroupRequest): AddDomainGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddDomainGroup', 'POST', '/', 'json', false, 'json', request);
}

model AddDomainRecordRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  line?: string(name='Line', position='Query'),
  priority?: long(name='Priority', minimum=1, maximum=50, position='Query'),
  rr: string(name='RR', position='Query'),
  TTL?: long(name='TTL', minimum=1, maximum=86400, position='Query'),
  type: string(name='Type', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
  value: string(name='Value', position='Query'),
}

model AddDomainRecordResponseBody = {
  recordId?: string(name='RecordId'),
  requestId?: string(name='RequestId'),
}

model AddDomainRecordResponse = {
  headers: map[string]string(name='headers'),
  body: AddDomainRecordResponseBody(name='body'),
}

async function addDomainRecord(request: AddDomainRecordRequest): AddDomainRecordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddDomainRecord', 'POST', '/', 'json', false, 'json', request);
}

model AddGtmAccessStrategyRequest {
  accessLines: string(name='AccessLines', position='Query'),
  defaultAddrPoolId: string(name='DefaultAddrPoolId', position='Query'),
  failoverAddrPoolId: string(name='FailoverAddrPoolId', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  strategyName: string(name='StrategyName', position='Query'),
}

model AddGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId'),
  strategyId?: string(name='StrategyId'),
}

model AddGtmAccessStrategyResponse = {
  headers: map[string]string(name='headers'),
  body: AddGtmAccessStrategyResponseBody(name='body'),
}

async function addGtmAccessStrategy(request: AddGtmAccessStrategyRequest): AddGtmAccessStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddGtmAccessStrategy', 'POST', '/', 'json', false, 'json', request);
}

model AddGtmAddressPoolRequest {
  addr: [ 
    {
      lbaWeight?: int32(name='LbaWeight'),
      mode?: string(name='Mode'),
      value?: string(name='Value'),
    }
  ](name='Addr', position='Query'),
  evaluationCount?: int32(name='EvaluationCount', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  interval?: int32(name='Interval', position='Query'),
  ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode'),
      ispCode?: string(name='IspCode'),
    }
  ](name='IspCityNode', position='Query'),
  lang?: string(name='Lang', position='Query'),
  minAvailableAddrNum: int32(name='MinAvailableAddrNum', position='Query'),
  monitorExtendInfo?: string(name='MonitorExtendInfo', position='Query'),
  monitorStatus?: string(name='MonitorStatus', position='Query'),
  name: string(name='Name', position='Query'),
  protocolType?: string(name='ProtocolType', position='Query'),
  timeout?: int32(name='Timeout', position='Query'),
  type: string(name='Type', position='Query'),
}

model AddGtmAddressPoolResponseBody = {
  addrPoolId?: string(name='AddrPoolId'),
  monitorConfigId?: string(name='MonitorConfigId'),
  requestId?: string(name='RequestId'),
}

model AddGtmAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  body: AddGtmAddressPoolResponseBody(name='body'),
}

async function addGtmAddressPool(request: AddGtmAddressPoolRequest): AddGtmAddressPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddGtmAddressPool', 'POST', '/', 'json', false, 'json', request);
}

model AddGtmMonitorRequest {
  addrPoolId: string(name='AddrPoolId', position='Query'),
  evaluationCount: int32(name='EvaluationCount', position='Query'),
  interval: int32(name='Interval', position='Query'),
  ispCityNode: [ 
    {
      cityCode?: string(name='CityCode'),
      ispCode?: string(name='IspCode'),
    }
  ](name='IspCityNode', position='Query'),
  lang?: string(name='Lang', position='Query'),
  monitorExtendInfo: string(name='MonitorExtendInfo', position='Query'),
  protocolType: string(name='ProtocolType', position='Query'),
  timeout: int32(name='Timeout', position='Query'),
}

model AddGtmMonitorResponseBody = {
  monitorConfigId?: string(name='MonitorConfigId'),
  requestId?: string(name='RequestId'),
}

model AddGtmMonitorResponse = {
  headers: map[string]string(name='headers'),
  body: AddGtmMonitorResponseBody(name='body'),
}

async function addGtmMonitor(request: AddGtmMonitorRequest): AddGtmMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddGtmMonitor', 'POST', '/', 'json', false, 'json', request);
}

model AddGtmRecoveryPlanRequest {
  faultAddrPool: string(name='FaultAddrPool', position='Query'),
  lang?: string(name='Lang', position='Query'),
  name: string(name='Name', position='Query'),
  remark?: string(name='Remark', position='Query'),
}

model AddGtmRecoveryPlanResponseBody = {
  recoveryPlanId?: string(name='RecoveryPlanId'),
  requestId?: string(name='RequestId'),
}

model AddGtmRecoveryPlanResponse = {
  headers: map[string]string(name='headers'),
  body: AddGtmRecoveryPlanResponseBody(name='body'),
}

async function addGtmRecoveryPlan(request: AddGtmRecoveryPlanRequest): AddGtmRecoveryPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddGtmRecoveryPlan', 'POST', '/', 'json', false, 'json', request);
}

model BindInstanceDomainsRequest {
  domainNames: string(name='DomainNames', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model BindInstanceDomainsResponseBody = {
  failedCount?: int32(name='FailedCount'),
  requestId?: string(name='RequestId'),
  successCount?: int32(name='SuccessCount'),
}

model BindInstanceDomainsResponse = {
  headers: map[string]string(name='headers'),
  body: BindInstanceDomainsResponseBody(name='body'),
}

async function bindInstanceDomains(request: BindInstanceDomainsRequest): BindInstanceDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BindInstanceDomains', 'POST', '/', 'json', false, 'json', request);
}

model ChangeDomainGroupRequest {
  domainName: string(name='DomainName', position='Query'),
  groupId?: string(name='GroupId', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model ChangeDomainGroupResponseBody = {
  groupId?: string(name='GroupId'),
  groupName?: string(name='GroupName'),
  requestId?: string(name='RequestId'),
}

model ChangeDomainGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ChangeDomainGroupResponseBody(name='body'),
}

async function changeDomainGroup(request: ChangeDomainGroupRequest): ChangeDomainGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ChangeDomainGroup', 'POST', '/', 'json', false, 'json', request);
}

model ChangeDomainOfDnsProductRequest {
  force?: boolean(name='Force', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  newDomain?: string(name='NewDomain', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model ChangeDomainOfDnsProductResponseBody = {
  originalDomain?: string(name='OriginalDomain'),
  requestId?: string(name='RequestId'),
}

model ChangeDomainOfDnsProductResponse = {
  headers: map[string]string(name='headers'),
  body: ChangeDomainOfDnsProductResponseBody(name='body'),
}

async function changeDomainOfDnsProduct(request: ChangeDomainOfDnsProductRequest): ChangeDomainOfDnsProductResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ChangeDomainOfDnsProduct', 'POST', '/', 'json', false, 'json', request);
}

model CopyGtmConfigRequest {
  copyType: string(name='CopyType', position='Query'),
  lang?: string(name='Lang', position='Query'),
  sourceId: string(name='SourceId', position='Query'),
  targetId: string(name='TargetId', position='Query'),
}

model CopyGtmConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model CopyGtmConfigResponse = {
  headers: map[string]string(name='headers'),
  body: CopyGtmConfigResponseBody(name='body'),
}

async function copyGtmConfig(request: CopyGtmConfigRequest): CopyGtmConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CopyGtmConfig', 'POST', '/', 'json', false, 'json', request);
}

model CreatePdnsAppKeyRequest {
  lang?: string(name='Lang', position='Query'),
}

model CreatePdnsAppKeyResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreatePdnsAppKeyResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePdnsAppKeyResponseBody(name='body'),
}

async function createPdnsAppKey(request: CreatePdnsAppKeyRequest): CreatePdnsAppKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreatePdnsAppKey', 'POST', '/', 'json', false, 'json', request);
}

model CreatePdnsUdpIpSegmentRequest {
  ip?: string(name='Ip', position='Query'),
  lang?: string(name='Lang', position='Query'),
  name?: string(name='Name', position='Query'),
}

model CreatePdnsUdpIpSegmentResponseBody = {
  requestId?: string(name='RequestId'),
  validMessage?: string(name='ValidMessage'),
}

model CreatePdnsUdpIpSegmentResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePdnsUdpIpSegmentResponseBody(name='body'),
}

async function createPdnsUdpIpSegment(request: CreatePdnsUdpIpSegmentRequest): CreatePdnsUdpIpSegmentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreatePdnsUdpIpSegment', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCustomLinesRequest {
  lang?: string(name='Lang', position='Query'),
  lineIds: string(name='LineIds', position='Query'),
}

model DeleteCustomLinesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCustomLinesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCustomLinesResponseBody(name='body'),
}

async function deleteCustomLines(request: DeleteCustomLinesRequest): DeleteCustomLinesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCustomLines', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDnsCacheDomainRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model DeleteDnsCacheDomainResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDnsCacheDomainResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDnsCacheDomainResponseBody(name='body'),
}

async function deleteDnsCacheDomain(request: DeleteDnsCacheDomainRequest): DeleteDnsCacheDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDnsCacheDomain', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDnsGtmAccessStrategyRequest {
  lang?: string(name='Lang', position='Query'),
  strategyId: string(name='StrategyId', position='Query'),
}

model DeleteDnsGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDnsGtmAccessStrategyResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDnsGtmAccessStrategyResponseBody(name='body'),
}

async function deleteDnsGtmAccessStrategy(request: DeleteDnsGtmAccessStrategyRequest): DeleteDnsGtmAccessStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDnsGtmAccessStrategy', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDnsGtmAddressPoolRequest {
  addrPoolId: string(name='AddrPoolId', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model DeleteDnsGtmAddressPoolResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDnsGtmAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDnsGtmAddressPoolResponseBody(name='body'),
}

async function deleteDnsGtmAddressPool(request: DeleteDnsGtmAddressPoolRequest): DeleteDnsGtmAddressPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDnsGtmAddressPool', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDomainRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model DeleteDomainResponseBody = {
  domainName?: string(name='DomainName'),
  requestId?: string(name='RequestId'),
}

model DeleteDomainResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDomainResponseBody(name='body'),
}

async function deleteDomain(request: DeleteDomainRequest): DeleteDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDomain', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDomainGroupRequest {
  groupId: string(name='GroupId', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model DeleteDomainGroupResponseBody = {
  groupName?: string(name='GroupName'),
  requestId?: string(name='RequestId'),
}

model DeleteDomainGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDomainGroupResponseBody(name='body'),
}

async function deleteDomainGroup(request: DeleteDomainGroupRequest): DeleteDomainGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDomainGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDomainRecordRequest {
  lang?: string(name='Lang', position='Query'),
  recordId: string(name='RecordId', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model DeleteDomainRecordResponseBody = {
  recordId?: string(name='RecordId'),
  requestId?: string(name='RequestId'),
}

model DeleteDomainRecordResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDomainRecordResponseBody(name='body'),
}

async function deleteDomainRecord(request: DeleteDomainRecordRequest): DeleteDomainRecordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDomainRecord', 'POST', '/', 'json', false, 'json', request);
}

model DeleteGtmAccessStrategyRequest {
  lang?: string(name='Lang', position='Query'),
  strategyId?: string(name='StrategyId', position='Query'),
}

model DeleteGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGtmAccessStrategyResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGtmAccessStrategyResponseBody(name='body'),
}

async function deleteGtmAccessStrategy(request: DeleteGtmAccessStrategyRequest): DeleteGtmAccessStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGtmAccessStrategy', 'POST', '/', 'json', false, 'json', request);
}

model DeleteGtmAddressPoolRequest {
  addrPoolId: string(name='AddrPoolId', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model DeleteGtmAddressPoolResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGtmAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGtmAddressPoolResponseBody(name='body'),
}

async function deleteGtmAddressPool(request: DeleteGtmAddressPoolRequest): DeleteGtmAddressPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGtmAddressPool', 'POST', '/', 'json', false, 'json', request);
}

model DeleteGtmRecoveryPlanRequest {
  lang?: string(name='Lang', position='Query'),
  recoveryPlanId: long(name='RecoveryPlanId', position='Query'),
}

model DeleteGtmRecoveryPlanResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGtmRecoveryPlanResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGtmRecoveryPlanResponseBody(name='body'),
}

async function deleteGtmRecoveryPlan(request: DeleteGtmRecoveryPlanRequest): DeleteGtmRecoveryPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGtmRecoveryPlan', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSubDomainRecordsRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  rr: string(name='RR', position='Query'),
  type?: string(name='Type', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model DeleteSubDomainRecordsResponseBody = {
  rr?: string(name='RR'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model DeleteSubDomainRecordsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSubDomainRecordsResponseBody(name='body'),
}

async function deleteSubDomainRecords(request: DeleteSubDomainRecordsRequest): DeleteSubDomainRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSubDomainRecords', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBatchResultCountRequest {
  batchType?: string(name='BatchType', position='Query'),
  lang?: string(name='Lang', position='Query'),
  taskId?: long(name='TaskId', position='Query'),
}

model DescribeBatchResultCountResponseBody = {
  batchType?: string(name='BatchType'),
  failedCount?: int32(name='FailedCount'),
  reason?: string(name='Reason'),
  requestId?: string(name='RequestId'),
  status?: int32(name='Status'),
  successCount?: int32(name='SuccessCount'),
  taskId?: long(name='TaskId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeBatchResultCountResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBatchResultCountResponseBody(name='body'),
}

async function describeBatchResultCount(request: DescribeBatchResultCountRequest): DescribeBatchResultCountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBatchResultCount', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBatchResultDetailRequest {
  batchType?: string(name='BatchType', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  status?: string(name='Status', position='Query'),
  taskId?: long(name='TaskId', position='Query'),
}

model DescribeBatchResultDetailResponseBody = {
  batchResultDetails?: {
    batchResultDetail?: [ 
    {
      batchType?: string(name='BatchType'),
      domain?: string(name='Domain'),
      line?: string(name='Line'),
      newRr?: string(name='NewRr'),
      newValue?: string(name='NewValue'),
      operateDateStr?: string(name='OperateDateStr'),
      priority?: string(name='Priority'),
      reason?: string(name='Reason'),
      recordId?: string(name='RecordId'),
      remark?: string(name='Remark'),
      rr?: string(name='Rr'),
      rrStatus?: string(name='RrStatus'),
      status?: boolean(name='Status'),
      ttl?: string(name='Ttl'),
      type?: string(name='Type'),
      value?: string(name='Value'),
    }
  ](name='BatchResultDetail')
  }(name='BatchResultDetails'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeBatchResultDetailResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBatchResultDetailResponseBody(name='body'),
}

async function describeBatchResultDetail(request: DescribeBatchResultDetailRequest): DescribeBatchResultDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBatchResultDetail', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCustomLineRequest {
  lang?: string(name='Lang', position='Query'),
  lineId?: long(name='LineId', position='Query'),
}

model DescribeCustomLineResponseBody = {
  code?: string(name='Code'),
  domainName?: string(name='DomainName'),
  id?: long(name='Id'),
  ipSegmentList?: [ 
    {
      endIp?: string(name='EndIp'),
      startIp?: string(name='StartIp'),
    }
  ](name='IpSegmentList'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
}

model DescribeCustomLineResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCustomLineResponseBody(name='body'),
}

async function describeCustomLine(request: DescribeCustomLineRequest): DescribeCustomLineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCustomLine', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCustomLinesRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
}

model DescribeCustomLinesResponseBody = {
  customLines?: [ 
    {
      code?: string(name='Code'),
      id?: long(name='Id'),
      name?: string(name='Name'),
    }
  ](name='CustomLines'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeCustomLinesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCustomLinesResponseBody(name='body'),
}

async function describeCustomLines(request: DescribeCustomLinesRequest): DescribeCustomLinesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCustomLines', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDNSSLBSubDomainsRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', maximum=100, position='Query'),
  rr?: string(name='Rr', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model DescribeDNSSLBSubDomainsResponseBody = {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  slbSubDomains?: {
    slbSubDomain?: [ 
    {
      lineAlgorithms?: {
        lineAlgorithm?: [ 
        {
          line?: string(name='Line'),
          open?: boolean(name='Open'),
        }
      ](name='LineAlgorithm')
      }(name='LineAlgorithms'),
      open?: boolean(name='Open'),
      recordCount?: long(name='RecordCount'),
      subDomain?: string(name='SubDomain'),
      type?: string(name='Type'),
    }
  ](name='SlbSubDomain')
  }(name='SlbSubDomains'),
  totalCount?: long(name='TotalCount'),
}

model DescribeDNSSLBSubDomainsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDNSSLBSubDomainsResponseBody(name='body'),
}

async function describeDNSSLBSubDomains(request: DescribeDNSSLBSubDomainsRequest): DescribeDNSSLBSubDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDNSSLBSubDomains', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsCacheDomainsRequest {
  keyword?: string(name='Keyword', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: long(name='PageNumber', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', minimum=1, maximum=100, position='Query'),
}

model DescribeDnsCacheDomainsResponseBody = {
  domains?: [ 
    {
      cacheTtlMax?: int32(name='CacheTtlMax'),
      cacheTtlMin?: int32(name='CacheTtlMin'),
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      domainId?: string(name='DomainId'),
      domainName?: string(name='DomainName'),
      expireTime?: string(name='ExpireTime'),
      expireTimestamp?: long(name='ExpireTimestamp'),
      instanceId?: string(name='InstanceId'),
      remark?: string(name='Remark'),
      sourceDnsServers?: [ 
        {
          host?: string(name='Host'),
          port?: string(name='Port'),
        }
      ](name='SourceDnsServers'),
      sourceEdns?: string(name='SourceEdns'),
      sourceProtocol?: string(name='SourceProtocol'),
      updateTime?: string(name='UpdateTime'),
      updateTimestamp?: long(name='UpdateTimestamp'),
      versionCode?: string(name='VersionCode'),
    }
  ](name='Domains'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeDnsCacheDomainsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDnsCacheDomainsResponseBody(name='body'),
}

async function describeDnsCacheDomains(request: DescribeDnsCacheDomainsRequest): DescribeDnsCacheDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsCacheDomains', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmAccessStrategiesRequest {
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  strategyMode: string(name='StrategyMode', position='Query'),
}

model DescribeDnsGtmAccessStrategiesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  strategies?: {
    strategy?: [ 
    {
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      effectiveAddrPoolGroupType?: string(name='EffectiveAddrPoolGroupType'),
      effectiveAddrPoolType?: string(name='EffectiveAddrPoolType'),
      effectiveAddrPools?: {
        effectiveAddrPool?: [ 
        {
          addrCount?: int32(name='AddrCount'),
          id?: string(name='Id'),
          lbaWeight?: int32(name='LbaWeight'),
          name?: string(name='Name'),
        }
      ](name='EffectiveAddrPool')
      }(name='EffectiveAddrPools'),
      effectiveLbaStrategy?: string(name='EffectiveLbaStrategy'),
      lines?: {
        line?: [ 
        {
          groupCode?: string(name='GroupCode'),
          groupName?: string(name='GroupName'),
          lineCode?: string(name='LineCode'),
          lineName?: string(name='LineName'),
        }
      ](name='Line')
      }(name='Lines'),
      strategyId?: string(name='StrategyId'),
      strategyName?: string(name='StrategyName'),
    }
  ](name='Strategy')
  }(name='Strategies'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeDnsGtmAccessStrategiesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDnsGtmAccessStrategiesResponseBody(name='body'),
}

async function describeDnsGtmAccessStrategies(request: DescribeDnsGtmAccessStrategiesRequest): DescribeDnsGtmAccessStrategiesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmAccessStrategies', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmAccessStrategyRequest {
  lang?: string(name='Lang', position='Query'),
  strategyId: string(name='StrategyId', position='Query'),
}

model DescribeDnsGtmAccessStrategyResponseBody = {
  accessMode?: string(name='AccessMode'),
  createTime?: string(name='CreateTime'),
  createTimestamp?: long(name='CreateTimestamp'),
  defaultAddrPoolGroupStatus?: string(name='DefaultAddrPoolGroupStatus'),
  defaultAddrPoolType?: string(name='DefaultAddrPoolType'),
  defaultAddrPools?: {
    defaultAddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount'),
      id?: string(name='Id'),
      lbaWeight?: int32(name='LbaWeight'),
      name?: string(name='Name'),
    }
  ](name='DefaultAddrPool')
  }(name='DefaultAddrPools'),
  defaultAvailableAddrNum?: int32(name='DefaultAvailableAddrNum'),
  defaultLatencyOptimization?: string(name='DefaultLatencyOptimization'),
  defaultLbaStrategy?: string(name='DefaultLbaStrategy'),
  defaultMaxReturnAddrNum?: int32(name='DefaultMaxReturnAddrNum'),
  defaultMinAvailableAddrNum?: int32(name='DefaultMinAvailableAddrNum'),
  effectiveAddrPoolGroupType?: string(name='EffectiveAddrPoolGroupType'),
  failoverAddrPoolGroupStatus?: string(name='FailoverAddrPoolGroupStatus'),
  failoverAddrPoolType?: string(name='FailoverAddrPoolType'),
  failoverAddrPools?: {
    failoverAddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount'),
      id?: string(name='Id'),
      lbaWeight?: int32(name='LbaWeight'),
      name?: string(name='Name'),
    }
  ](name='FailoverAddrPool')
  }(name='FailoverAddrPools'),
  failoverAvailableAddrNum?: int32(name='FailoverAvailableAddrNum'),
  failoverLatencyOptimization?: string(name='FailoverLatencyOptimization'),
  failoverLbaStrategy?: string(name='FailoverLbaStrategy'),
  failoverMaxReturnAddrNum?: int32(name='FailoverMaxReturnAddrNum'),
  failoverMinAvailableAddrNum?: int32(name='FailoverMinAvailableAddrNum'),
  instanceId?: string(name='InstanceId'),
  lines?: {
    line?: [ 
    {
      groupCode?: string(name='GroupCode'),
      groupName?: string(name='GroupName'),
      lineCode?: string(name='LineCode'),
      lineName?: string(name='LineName'),
    }
  ](name='Line')
  }(name='Lines'),
  requestId?: string(name='RequestId'),
  strategyId?: string(name='StrategyId'),
  strategyMode?: string(name='StrategyMode'),
  strategyName?: string(name='StrategyName'),
}

model DescribeDnsGtmAccessStrategyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDnsGtmAccessStrategyResponseBody(name='body'),
}

async function describeDnsGtmAccessStrategy(request: DescribeDnsGtmAccessStrategyRequest): DescribeDnsGtmAccessStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmAccessStrategy', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmAccessStrategyAvailableConfigRequest {
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  strategyMode: string(name='StrategyMode', position='Query'),
}

model DescribeDnsGtmAccessStrategyAvailableConfigResponseBody = {
  domainAddrPools?: {
    domainAddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount'),
      id?: string(name='Id'),
      name?: string(name='Name'),
    }
  ](name='DomainAddrPool')
  }(name='DomainAddrPools'),
  ipv4AddrPools?: {
    ipv4AddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount'),
      id?: string(name='Id'),
      name?: string(name='Name'),
    }
  ](name='Ipv4AddrPool')
  }(name='Ipv4AddrPools'),
  ipv6AddrPools?: {
    ipv6AddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount'),
      id?: string(name='Id'),
      name?: string(name='Name'),
    }
  ](name='Ipv6AddrPool')
  }(name='Ipv6AddrPools'),
  lines?: {
    line?: [ 
    {
      fatherCode?: string(name='FatherCode'),
      groupCode?: string(name='GroupCode'),
      groupName?: string(name='GroupName'),
      lineCode?: string(name='LineCode'),
      lineName?: string(name='LineName'),
    }
  ](name='Line')
  }(name='Lines'),
  requestId?: string(name='RequestId'),
  selectedDomainLines?: {
    selectedDomainLine?: [ string ](name='SelectedDomainLine')
  }(name='SelectedDomainLines'),
  selectedIpv4Lines?: {
    selectedIpv4Line?: [ string ](name='SelectedIpv4Line')
  }(name='SelectedIpv4Lines'),
  selectedIpv6Lines?: {
    selectedIpv6Line?: [ string ](name='SelectedIpv6Line')
  }(name='SelectedIpv6Lines'),
  suggestSetDefaultLine?: boolean(name='SuggestSetDefaultLine'),
}

model DescribeDnsGtmAccessStrategyAvailableConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody(name='body'),
}

async function describeDnsGtmAccessStrategyAvailableConfig(request: DescribeDnsGtmAccessStrategyAvailableConfigRequest): DescribeDnsGtmAccessStrategyAvailableConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmAccessStrategyAvailableConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmAddrAttributeInfoRequest {
  addrs: string(name='Addrs', position='Query'),
  lang?: string(name='Lang', position='Query'),
  type: string(name='Type', position='Query'),
}

model DescribeDnsGtmAddrAttributeInfoResponseBody = {
  addr?: {
    addr?: [ 
    {
      addr?: string(name='Addr'),
      attributeInfo?: {
        fatherCode?: string(name='FatherCode'),
        groupCode?: string(name='GroupCode'),
        groupName?: string(name='GroupName'),
        lineCode?: string(name='LineCode'),
        lineName?: string(name='LineName'),
      }(name='AttributeInfo'),
    }
  ](name='Addr')
  }(name='Addr'),
  requestId?: string(name='RequestId'),
}

model DescribeDnsGtmAddrAttributeInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDnsGtmAddrAttributeInfoResponseBody(name='body'),
}

async function describeDnsGtmAddrAttributeInfo(request: DescribeDnsGtmAddrAttributeInfoRequest): DescribeDnsGtmAddrAttributeInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmAddrAttributeInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmAddressPoolAvailableConfigRequest {
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model DescribeDnsGtmAddressPoolAvailableConfigResponseBody = {
  attributeInfos?: {
    attributeInfo?: [ 
    {
      fatherCode?: string(name='FatherCode'),
      groupCode?: string(name='GroupCode'),
      groupName?: string(name='GroupName'),
      lineCode?: string(name='LineCode'),
      lineName?: string(name='LineName'),
    }
  ](name='AttributeInfo')
  }(name='AttributeInfos'),
  requestId?: string(name='RequestId'),
}

model DescribeDnsGtmAddressPoolAvailableConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDnsGtmAddressPoolAvailableConfigResponseBody(name='body'),
}

async function describeDnsGtmAddressPoolAvailableConfig(request: DescribeDnsGtmAddressPoolAvailableConfigRequest): DescribeDnsGtmAddressPoolAvailableConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmAddressPoolAvailableConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmAvailableAlertGroupRequest {
  lang?: string(name='Lang', position='Query'),
}

model DescribeDnsGtmAvailableAlertGroupResponseBody = {
  availableAlertGroup?: string(name='AvailableAlertGroup'),
  requestId?: string(name='RequestId'),
}

model DescribeDnsGtmAvailableAlertGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDnsGtmAvailableAlertGroupResponseBody(name='body'),
}

async function describeDnsGtmAvailableAlertGroup(request: DescribeDnsGtmAvailableAlertGroupRequest): DescribeDnsGtmAvailableAlertGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmAvailableAlertGroup', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmInstanceRequest {
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model DescribeDnsGtmInstanceResponseBody = {
  config?: {
    alertConfig?: {
      alertConfig?: [ 
      {
        dingtalkNotice?: boolean(name='DingtalkNotice'),
        emailNotice?: boolean(name='EmailNotice'),
        noticeType?: string(name='NoticeType'),
        smsNotice?: boolean(name='SmsNotice'),
      }
    ](name='AlertConfig')
    }(name='AlertConfig'),
    alertGroup?: string(name='AlertGroup'),
    cnameType?: string(name='CnameType'),
    instanceName?: string(name='InstanceName'),
    pubicZoneName?: string(name='PubicZoneName'),
    publicCnameMode?: string(name='PublicCnameMode'),
    publicRr?: string(name='PublicRr'),
    publicUserDomainName?: string(name='PublicUserDomainName'),
    strategyMode?: string(name='StrategyMode'),
    ttl?: int32(name='Ttl'),
  }(name='Config'),
  createTime?: string(name='CreateTime'),
  createTimestamp?: long(name='CreateTimestamp'),
  expireTime?: string(name='ExpireTime'),
  expireTimestamp?: long(name='ExpireTimestamp'),
  instanceId?: string(name='InstanceId'),
  paymentType?: string(name='PaymentType'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  smsQuota?: int32(name='SmsQuota'),
  taskQuota?: int32(name='TaskQuota'),
  usedQuota?: {
    dingtalkUsedCount?: int32(name='DingtalkUsedCount'),
    emailUsedCount?: int32(name='EmailUsedCount'),
    smsUsedCount?: int32(name='SmsUsedCount'),
    taskUsedCount?: int32(name='TaskUsedCount'),
  }(name='UsedQuota'),
  versionCode?: string(name='VersionCode'),
}

model DescribeDnsGtmInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDnsGtmInstanceResponseBody(name='body'),
}

async function describeDnsGtmInstance(request: DescribeDnsGtmInstanceRequest): DescribeDnsGtmInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmInstance', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmInstanceAddressPoolRequest {
  addrPoolId: string(name='AddrPoolId', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model DescribeDnsGtmInstanceAddressPoolResponseBody = {
  addrCount?: int32(name='AddrCount'),
  addrPoolId?: string(name='AddrPoolId'),
  addrs?: {
    addr?: [ 
    {
      addr?: string(name='Addr'),
      alertStatus?: string(name='AlertStatus'),
      attributeInfo?: string(name='AttributeInfo'),
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      lbaWeight?: int32(name='LbaWeight'),
      mode?: string(name='Mode'),
      remark?: string(name='Remark'),
      updateTime?: string(name='UpdateTime'),
      updateTimestamp?: long(name='UpdateTimestamp'),
    }
  ](name='Addr')
  }(name='Addrs'),
  createTime?: string(name='CreateTime'),
  createTimestamp?: long(name='CreateTimestamp'),
  lbaStrategy?: string(name='LbaStrategy'),
  monitorConfigId?: string(name='MonitorConfigId'),
  monitorStatus?: string(name='MonitorStatus'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  type?: string(name='Type'),
  updateTime?: string(name='UpdateTime'),
  updateTimestamp?: long(name='UpdateTimestamp'),
}

model DescribeDnsGtmInstanceAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDnsGtmInstanceAddressPoolResponseBody(name='body'),
}

async function describeDnsGtmInstanceAddressPool(request: DescribeDnsGtmInstanceAddressPoolRequest): DescribeDnsGtmInstanceAddressPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmInstanceAddressPool', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmInstanceAddressPoolsRequest {
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=9999999, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
}

model DescribeDnsGtmInstanceAddressPoolsResponseBody = {
  addrPools?: {
    addrPool?: [ 
    {
      addrCount?: int32(name='AddrCount'),
      addrPoolId?: string(name='AddrPoolId'),
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      lbaStrategy?: string(name='LbaStrategy'),
      monitorConfigId?: string(name='MonitorConfigId'),
      monitorStatus?: string(name='MonitorStatus'),
      name?: string(name='Name'),
      type?: string(name='Type'),
      updateTime?: string(name='UpdateTime'),
      updateTimestamp?: long(name='UpdateTimestamp'),
    }
  ](name='AddrPool')
  }(name='AddrPools'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeDnsGtmInstanceAddressPoolsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDnsGtmInstanceAddressPoolsResponseBody(name='body'),
}

async function describeDnsGtmInstanceAddressPools(request: DescribeDnsGtmInstanceAddressPoolsRequest): DescribeDnsGtmInstanceAddressPoolsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmInstanceAddressPools', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmInstanceStatusRequest {
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model DescribeDnsGtmInstanceStatusResponseBody = {
  addrAvailableNum?: int32(name='AddrAvailableNum'),
  addrNotAvailableNum?: int32(name='AddrNotAvailableNum'),
  addrPoolGroupNotAvailableNum?: int32(name='AddrPoolGroupNotAvailableNum'),
  requestId?: string(name='RequestId'),
  strategyNotAvailableNum?: int32(name='StrategyNotAvailableNum'),
  switchToFailoverStrategyNum?: int32(name='SwitchToFailoverStrategyNum'),
}

model DescribeDnsGtmInstanceStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDnsGtmInstanceStatusResponseBody(name='body'),
}

async function describeDnsGtmInstanceStatus(request: DescribeDnsGtmInstanceStatusRequest): DescribeDnsGtmInstanceStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmInstanceStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmInstanceSystemCnameRequest {
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model DescribeDnsGtmInstanceSystemCnameResponseBody = {
  requestId?: string(name='RequestId'),
  systemCname?: string(name='SystemCname'),
}

model DescribeDnsGtmInstanceSystemCnameResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDnsGtmInstanceSystemCnameResponseBody(name='body'),
}

async function describeDnsGtmInstanceSystemCname(request: DescribeDnsGtmInstanceSystemCnameRequest): DescribeDnsGtmInstanceSystemCnameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmInstanceSystemCname', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmInstancesRequest {
  keyword?: string(name='Keyword', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=9999999, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
}

model DescribeDnsGtmInstancesResponseBody = {
  gtmInstances?: [ 
    {
      config?: {
        alertConfig?: [ 
          {
            dingtalkNotice?: string(name='DingtalkNotice'),
            emailNotice?: string(name='EmailNotice'),
            noticeType?: string(name='NoticeType'),
            smsNotice?: string(name='SmsNotice'),
          }
        ](name='AlertConfig'),
        alertGroup?: string(name='AlertGroup'),
        cnameType?: string(name='CnameType'),
        instanceName?: string(name='InstanceName'),
        publicCnameMode?: string(name='PublicCnameMode'),
        publicRr?: string(name='PublicRr'),
        publicUserDomainName?: string(name='PublicUserDomainName'),
        publicZoneName?: string(name='PublicZoneName'),
        strategyMode?: string(name='StrategyMode'),
        ttl?: int32(name='Ttl'),
      }(name='Config'),
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      expireTime?: string(name='ExpireTime'),
      expireTimestamp?: long(name='ExpireTimestamp'),
      instanceId?: string(name='InstanceId'),
      paymentType?: string(name='PaymentType'),
      resourceGroupId?: string(name='ResourceGroupId'),
      smsQuota?: int32(name='SmsQuota'),
      taskQuota?: int32(name='TaskQuota'),
      usedQuota?: {
        dingtalkUsedCount?: int32(name='DingtalkUsedCount'),
        emailUsedCount?: int32(name='EmailUsedCount'),
        smsUsedCount?: int32(name='SmsUsedCount'),
        taskUsedCount?: int32(name='TaskUsedCount'),
      }(name='UsedQuota'),
      versionCode?: string(name='VersionCode'),
    }
  ](name='GtmInstances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeDnsGtmInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDnsGtmInstancesResponseBody(name='body'),
}

async function describeDnsGtmInstances(request: DescribeDnsGtmInstancesRequest): DescribeDnsGtmInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmLogsRequest {
  endTimestamp?: long(name='EndTimestamp', minimum=1, maximum=999999999999999, position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  keyword?: string(name='Keyword', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=9999999, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  startTimestamp?: long(name='StartTimestamp', minimum=1, maximum=999999999999999, position='Query'),
}

model DescribeDnsGtmLogsResponseBody = {
  logs?: {
    log?: [ 
    {
      content?: string(name='Content'),
      entityId?: string(name='EntityId'),
      entityName?: string(name='EntityName'),
      entityType?: string(name='EntityType'),
      id?: long(name='Id'),
      operAction?: string(name='OperAction'),
      operTime?: string(name='OperTime'),
      operTimestamp?: long(name='OperTimestamp'),
    }
  ](name='Log')
  }(name='Logs'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeDnsGtmLogsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDnsGtmLogsResponseBody(name='body'),
}

async function describeDnsGtmLogs(request: DescribeDnsGtmLogsRequest): DescribeDnsGtmLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmLogs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmMonitorAvailableConfigRequest {
  lang?: string(name='Lang', position='Query'),
}

model DescribeDnsGtmMonitorAvailableConfigResponseBody = {
  domainIpv4IspCityNodes?: {
    domainIpv4IspCityNode?: [ 
    {
      cityCode?: string(name='CityCode'),
      cityName?: string(name='CityName'),
      defaultSelected?: boolean(name='DefaultSelected'),
      groupName?: string(name='GroupName'),
      groupType?: string(name='GroupType'),
      ips?: {
        ip?: [ string ](name='Ip')
      }(name='Ips'),
      ispCode?: string(name='IspCode'),
      ispName?: string(name='IspName'),
    }
  ](name='DomainIpv4IspCityNode')
  }(name='DomainIpv4IspCityNodes'),
  domainIpv6IspCityNodes?: {
    domainIpv6IspCityNode?: [ 
    {
      cityCode?: string(name='CityCode'),
      cityName?: string(name='CityName'),
      defaultSelected?: boolean(name='DefaultSelected'),
      groupName?: string(name='GroupName'),
      groupType?: string(name='GroupType'),
      ips?: {
        ip?: [ string ](name='ip')
      }(name='Ips'),
      ispCode?: string(name='IspCode'),
      ispName?: string(name='IspName'),
    }
  ](name='DomainIpv6IspCityNode')
  }(name='DomainIpv6IspCityNodes'),
  ipv4IspCityNodes?: {
    ipv4IspCityNode?: [ 
    {
      cityCode?: string(name='CityCode'),
      cityName?: string(name='CityName'),
      defaultSelected?: boolean(name='DefaultSelected'),
      groupName?: string(name='GroupName'),
      groupType?: string(name='GroupType'),
      ips?: {
        ip?: [ string ](name='Ip')
      }(name='Ips'),
      ispCode?: string(name='IspCode'),
      ispName?: string(name='IspName'),
    }
  ](name='Ipv4IspCityNode')
  }(name='Ipv4IspCityNodes'),
  ipv6IspCityNodes?: {
    ipv6IspCityNode?: [ 
    {
      cityCode?: string(name='CityCode'),
      cityName?: string(name='CityName'),
      defaultSelected?: boolean(name='DefaultSelected'),
      groupName?: string(name='GroupName'),
      groupType?: string(name='GroupType'),
      ips?: {
        ip?: [ string ](name='Ip')
      }(name='Ips'),
      ispCode?: string(name='IspCode'),
      ispName?: string(name='IspName'),
    }
  ](name='Ipv6IspCityNode')
  }(name='Ipv6IspCityNodes'),
  requestId?: string(name='RequestId'),
}

model DescribeDnsGtmMonitorAvailableConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDnsGtmMonitorAvailableConfigResponseBody(name='body'),
}

async function describeDnsGtmMonitorAvailableConfig(request: DescribeDnsGtmMonitorAvailableConfigRequest): DescribeDnsGtmMonitorAvailableConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmMonitorAvailableConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsGtmMonitorConfigRequest {
  lang?: string(name='Lang', position='Query'),
  monitorConfigId: string(name='MonitorConfigId', position='Query'),
}

model DescribeDnsGtmMonitorConfigResponseBody = {
  createTime?: string(name='CreateTime'),
  createTimestamp?: long(name='CreateTimestamp'),
  evaluationCount?: int32(name='EvaluationCount'),
  interval?: int32(name='Interval'),
  ispCityNodes?: {
    ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode'),
      cityName?: string(name='CityName'),
      countryCode?: string(name='CountryCode'),
      countryName?: string(name='CountryName'),
      ispCode?: string(name='IspCode'),
      ispName?: string(name='IspName'),
    }
  ](name='IspCityNode')
  }(name='IspCityNodes'),
  monitorConfigId?: string(name='MonitorConfigId'),
  monitorExtendInfo?: string(name='MonitorExtendInfo'),
  protocolType?: string(name='ProtocolType'),
  requestId?: string(name='RequestId'),
  timeout?: int32(name='Timeout'),
  updateTime?: string(name='UpdateTime'),
  updateTimestamp?: long(name='UpdateTimestamp'),
}

model DescribeDnsGtmMonitorConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDnsGtmMonitorConfigResponseBody(name='body'),
}

async function describeDnsGtmMonitorConfig(request: DescribeDnsGtmMonitorConfigRequest): DescribeDnsGtmMonitorConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsGtmMonitorConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsProductInstanceRequest {
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model DescribeDnsProductInstanceResponseBody = {
  bindCount?: long(name='BindCount'),
  bindDomainCount?: long(name='BindDomainCount'),
  bindDomainUsedCount?: long(name='BindDomainUsedCount'),
  bindUsedCount?: long(name='BindUsedCount'),
  dDosDefendFlow?: long(name='DDosDefendFlow'),
  dDosDefendQuery?: long(name='DDosDefendQuery'),
  dnsSLBCount?: long(name='DnsSLBCount'),
  dnsSecurity?: string(name='DnsSecurity'),
  dnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='DnsServers'),
  domain?: string(name='Domain'),
  domainType?: string(name='DomainType'),
  endTime?: string(name='EndTime'),
  endTimestamp?: long(name='EndTimestamp'),
  gslb?: boolean(name='Gslb'),
  ISPLines?: string(name='ISPLines'),
  ISPRegionLines?: string(name='ISPRegionLines'),
  inBlackHole?: boolean(name='InBlackHole'),
  inClean?: boolean(name='InClean'),
  instanceId?: string(name='InstanceId'),
  monitorFrequency?: long(name='MonitorFrequency'),
  monitorNodeCount?: long(name='MonitorNodeCount'),
  monitorTaskCount?: long(name='MonitorTaskCount'),
  overseaDDosDefendFlow?: long(name='OverseaDDosDefendFlow'),
  overseaLine?: string(name='OverseaLine'),
  paymentType?: string(name='PaymentType'),
  regionLines?: boolean(name='RegionLines'),
  requestId?: string(name='RequestId'),
  searchEngineLines?: string(name='SearchEngineLines'),
  startTime?: string(name='StartTime'),
  startTimestamp?: long(name='StartTimestamp'),
  subDomainLevel?: long(name='SubDomainLevel'),
  TTLMinValue?: long(name='TTLMinValue'),
  URLForwardCount?: long(name='URLForwardCount'),
  versionCode?: string(name='VersionCode'),
  versionName?: string(name='VersionName'),
}

model DescribeDnsProductInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDnsProductInstanceResponseBody(name='body'),
}

async function describeDnsProductInstance(request: DescribeDnsProductInstanceRequest): DescribeDnsProductInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsProductInstance', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDnsProductInstancesRequest {
  domainType?: string(name='DomainType', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: long(name='PageNumber', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', minimum=1, maximum=1000, position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
  versionCode?: string(name='VersionCode', position='Query'),
}

model DescribeDnsProductInstancesResponseBody = {
  dnsProducts?: {
    dnsProduct?: [ 
    {
      bindCount?: long(name='BindCount'),
      bindDomainCount?: long(name='BindDomainCount'),
      bindDomainUsedCount?: long(name='BindDomainUsedCount'),
      bindUsedCount?: long(name='BindUsedCount'),
      dDosDefendFlow?: long(name='DDosDefendFlow'),
      dDosDefendQuery?: long(name='DDosDefendQuery'),
      dnsSLBCount?: long(name='DnsSLBCount'),
      dnsSecurity?: string(name='DnsSecurity'),
      domain?: string(name='Domain'),
      endTime?: string(name='EndTime'),
      endTimestamp?: long(name='EndTimestamp'),
      gslb?: boolean(name='Gslb'),
      ISPLines?: string(name='ISPLines'),
      ISPRegionLines?: string(name='ISPRegionLines'),
      inBlackHole?: boolean(name='InBlackHole'),
      inClean?: boolean(name='InClean'),
      instanceId?: string(name='InstanceId'),
      monitorFrequency?: long(name='MonitorFrequency'),
      monitorNodeCount?: long(name='MonitorNodeCount'),
      monitorTaskCount?: long(name='MonitorTaskCount'),
      overseaDDosDefendFlow?: long(name='OverseaDDosDefendFlow'),
      overseaLine?: string(name='OverseaLine'),
      paymentType?: string(name='PaymentType'),
      regionLines?: boolean(name='RegionLines'),
      searchEngineLines?: string(name='SearchEngineLines'),
      startTime?: string(name='StartTime'),
      startTimestamp?: long(name='StartTimestamp'),
      subDomainLevel?: long(name='SubDomainLevel'),
      TTLMinValue?: long(name='TTLMinValue'),
      URLForwardCount?: long(name='URLForwardCount'),
      versionCode?: string(name='VersionCode'),
      versionName?: string(name='VersionName'),
    }
  ](name='DnsProduct')
  }(name='DnsProducts'),
  domainType?: string(name='DomainType'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeDnsProductInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDnsProductInstancesResponseBody(name='body'),
}

async function describeDnsProductInstances(request: DescribeDnsProductInstancesRequest): DescribeDnsProductInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDnsProductInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDohAccountStatisticsRequest {
  endDate?: string(name='EndDate', position='Query'),
  lang?: string(name='Lang', position='Query'),
  startDate?: string(name='StartDate', position='Query'),
}

model DescribeDohAccountStatisticsResponseBody = {
  requestId?: string(name='RequestId'),
  statistics?: [ 
    {
      timestamp?: long(name='Timestamp'),
      totalCount?: long(name='TotalCount'),
      v4HttpCount?: long(name='V4HttpCount'),
      v4HttpsCount?: long(name='V4HttpsCount'),
      v6HttpCount?: long(name='V6HttpCount'),
      v6HttpsCount?: long(name='V6HttpsCount'),
    }
  ](name='Statistics'),
}

model DescribeDohAccountStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDohAccountStatisticsResponseBody(name='body'),
}

async function describeDohAccountStatistics(request: DescribeDohAccountStatisticsRequest): DescribeDohAccountStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDohAccountStatistics', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDohDomainStatisticsRequest {
  domainName: string(name='DomainName', position='Query'),
  endDate?: string(name='EndDate', position='Query'),
  lang?: string(name='Lang', position='Query'),
  startDate?: string(name='StartDate', position='Query'),
}

model DescribeDohDomainStatisticsResponseBody = {
  requestId?: string(name='RequestId'),
  statistics?: [ 
    {
      timestamp?: long(name='Timestamp'),
      totalCount?: long(name='TotalCount'),
      v4HttpCount?: long(name='V4HttpCount'),
      v4HttpsCount?: long(name='V4HttpsCount'),
      v6HttpCount?: long(name='V6HttpCount'),
      v6HttpsCount?: long(name='V6HttpsCount'),
    }
  ](name='Statistics'),
}

model DescribeDohDomainStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDohDomainStatisticsResponseBody(name='body'),
}

async function describeDohDomainStatistics(request: DescribeDohDomainStatisticsRequest): DescribeDohDomainStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDohDomainStatistics', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDohDomainStatisticsSummaryRequest {
  domainName?: string(name='DomainName', position='Query'),
  endDate?: string(name='EndDate', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  startDate?: string(name='StartDate', position='Query'),
}

model DescribeDohDomainStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  statistics?: [ 
    {
      domainName?: string(name='DomainName'),
      httpCount?: long(name='HttpCount'),
      httpsCount?: long(name='HttpsCount'),
      ipCount?: long(name='IpCount'),
      totalCount?: long(name='TotalCount'),
      v4HttpCount?: long(name='V4HttpCount'),
      v4HttpsCount?: long(name='V4HttpsCount'),
      v6HttpCount?: long(name='V6HttpCount'),
      v6HttpsCount?: long(name='V6HttpsCount'),
    }
  ](name='Statistics'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeDohDomainStatisticsSummaryResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDohDomainStatisticsSummaryResponseBody(name='body'),
}

async function describeDohDomainStatisticsSummary(request: DescribeDohDomainStatisticsSummaryRequest): DescribeDohDomainStatisticsSummaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDohDomainStatisticsSummary', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDohSubDomainStatisticsRequest {
  endDate?: string(name='EndDate', position='Query'),
  lang?: string(name='Lang', position='Query'),
  startDate?: string(name='StartDate', position='Query'),
  subDomain: string(name='SubDomain', position='Query'),
}

model DescribeDohSubDomainStatisticsResponseBody = {
  requestId?: string(name='RequestId'),
  statistics?: [ 
    {
      timestamp?: long(name='Timestamp'),
      totalCount?: long(name='TotalCount'),
      v4HttpCount?: long(name='V4HttpCount'),
      v4HttpsCount?: long(name='V4HttpsCount'),
      v6HttpCount?: long(name='V6HttpCount'),
      v6HttpsCount?: long(name='V6HttpsCount'),
    }
  ](name='Statistics'),
}

model DescribeDohSubDomainStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDohSubDomainStatisticsResponseBody(name='body'),
}

async function describeDohSubDomainStatistics(request: DescribeDohSubDomainStatisticsRequest): DescribeDohSubDomainStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDohSubDomainStatistics', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDohSubDomainStatisticsSummaryRequest {
  domainName?: string(name='DomainName', position='Query'),
  endDate?: string(name='EndDate', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  startDate?: string(name='StartDate', position='Query'),
  subDomain?: string(name='SubDomain', position='Query'),
}

model DescribeDohSubDomainStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  statistics?: [ 
    {
      httpCount?: long(name='HttpCount'),
      httpsCount?: long(name='HttpsCount'),
      ipCount?: long(name='IpCount'),
      subDomain?: string(name='SubDomain'),
      totalCount?: long(name='TotalCount'),
      v4HttpCount?: long(name='V4HttpCount'),
      v4HttpsCount?: long(name='V4HttpsCount'),
      v6HttpCount?: long(name='V6HttpCount'),
      v6HttpsCount?: long(name='V6HttpsCount'),
    }
  ](name='Statistics'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeDohSubDomainStatisticsSummaryResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDohSubDomainStatisticsSummaryResponseBody(name='body'),
}

async function describeDohSubDomainStatisticsSummary(request: DescribeDohSubDomainStatisticsSummaryRequest): DescribeDohSubDomainStatisticsSummaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDohSubDomainStatisticsSummary', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDohUserInfoRequest {
  endDate?: string(name='EndDate', position='Query'),
  lang?: string(name='Lang', position='Query'),
  startDate?: string(name='StartDate', position='Query'),
}

model DescribeDohUserInfoResponseBody = {
  domainCount?: int32(name='DomainCount'),
  pdnsId?: long(name='PdnsId'),
  requestId?: string(name='RequestId'),
  subDomainCount?: int32(name='SubDomainCount'),
}

model DescribeDohUserInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDohUserInfoResponseBody(name='body'),
}

async function describeDohUserInfo(request: DescribeDohUserInfoRequest): DescribeDohUserInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDohUserInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainDnssecInfoRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model DescribeDomainDnssecInfoResponseBody = {
  algorithm?: string(name='Algorithm'),
  digest?: string(name='Digest'),
  digestType?: string(name='DigestType'),
  domainName?: string(name='DomainName'),
  dsRecord?: string(name='DsRecord'),
  flags?: string(name='Flags'),
  keyTag?: string(name='KeyTag'),
  publicKey?: string(name='PublicKey'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model DescribeDomainDnssecInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainDnssecInfoResponseBody(name='body'),
}

async function describeDomainDnssecInfo(request: DescribeDomainDnssecInfoRequest): DescribeDomainDnssecInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainDnssecInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainGroupsRequest {
  keyWord?: string(name='KeyWord', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', maximum=110, position='Query'),
}

model DescribeDomainGroupsResponseBody = {
  domainGroups?: {
    domainGroup?: [ 
    {
      domainCount?: long(name='DomainCount'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
    }
  ](name='DomainGroup')
  }(name='DomainGroups'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeDomainGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainGroupsResponseBody(name='body'),
}

async function describeDomainGroups(request: DescribeDomainGroupsRequest): DescribeDomainGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainGroups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainInfoRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  needDetailAttributes?: boolean(name='NeedDetailAttributes', position='Query'),
}

model DescribeDomainInfoResponseBody = {
  aliDomain?: boolean(name='AliDomain'),
  availableTtls?: {
    availableTtl?: [ string ](name='AvailableTtl')
  }(name='AvailableTtls'),
  createTime?: string(name='CreateTime'),
  dnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='DnsServers'),
  domainId?: string(name='DomainId'),
  domainName?: string(name='DomainName'),
  groupId?: string(name='GroupId'),
  groupName?: string(name='GroupName'),
  inBlackHole?: boolean(name='InBlackHole'),
  inClean?: boolean(name='InClean'),
  instanceId?: string(name='InstanceId'),
  lineType?: string(name='LineType'),
  minTtl?: long(name='MinTtl'),
  punyCode?: string(name='PunyCode'),
  recordLineTreeJson?: string(name='RecordLineTreeJson'),
  recordLines?: {
    recordLine?: [ 
    {
      fatherCode?: string(name='FatherCode'),
      lineCode?: string(name='LineCode'),
      lineDisplayName?: string(name='LineDisplayName'),
      lineName?: string(name='LineName'),
    }
  ](name='RecordLine')
  }(name='RecordLines'),
  regionLines?: boolean(name='RegionLines'),
  remark?: string(name='Remark'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  slaveDns?: boolean(name='SlaveDns'),
  versionCode?: string(name='VersionCode'),
  versionName?: string(name='VersionName'),
}

model DescribeDomainInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainInfoResponseBody(name='body'),
}

async function describeDomainInfo(request: DescribeDomainInfoRequest): DescribeDomainInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainLogsRequest {
  groupId?: string(name='GroupId', position='Query'),
  keyWord?: string(name='KeyWord', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: long(name='PageNumber', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', minimum=1, maximum=100, position='Query'),
  startDate?: string(name='StartDate', position='Query'),
  type?: string(name='Type', position='Query'),
  endDate?: string(name='endDate', position='Query'),
}

model DescribeDomainLogsResponseBody = {
  domainLogs?: {
    domainLog?: [ 
    {
      action?: string(name='Action'),
      actionTime?: string(name='ActionTime'),
      actionTimestamp?: long(name='ActionTimestamp'),
      clientIp?: string(name='ClientIp'),
      domainName?: string(name='DomainName'),
      message?: string(name='Message'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='DomainLog')
  }(name='DomainLogs'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeDomainLogsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainLogsResponseBody(name='body'),
}

async function describeDomainLogs(request: DescribeDomainLogsRequest): DescribeDomainLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainLogs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainNsRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model DescribeDomainNsResponseBody = {
  allAliDns?: boolean(name='AllAliDns'),
  dnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='DnsServers'),
  expectDnsServers?: {
    expectDnsServer?: [ string ](name='ExpectDnsServer')
  }(name='ExpectDnsServers'),
  includeAliDns?: boolean(name='IncludeAliDns'),
  requestId?: string(name='RequestId'),
}

model DescribeDomainNsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainNsResponseBody(name='body'),
}

async function describeDomainNs(request: DescribeDomainNsRequest): DescribeDomainNsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainNs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainRecordInfoRequest {
  lang?: string(name='Lang', position='Query'),
  recordId: string(name='RecordId', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model DescribeDomainRecordInfoResponseBody = {
  domainId?: string(name='DomainId'),
  domainName?: string(name='DomainName'),
  groupId?: string(name='GroupId'),
  groupName?: string(name='GroupName'),
  line?: string(name='Line'),
  locked?: boolean(name='Locked'),
  priority?: long(name='Priority'),
  punyCode?: string(name='PunyCode'),
  rr?: string(name='RR'),
  recordId?: string(name='RecordId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  TTL?: long(name='TTL'),
  type?: string(name='Type'),
  value?: string(name='Value'),
}

model DescribeDomainRecordInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainRecordInfoResponseBody(name='body'),
}

async function describeDomainRecordInfo(request: DescribeDomainRecordInfoRequest): DescribeDomainRecordInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainRecordInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainRecordsRequest {
  direction?: string(name='Direction', position='Query'),
  domainName: string(name='DomainName', position='Query'),
  groupId?: long(name='GroupId', position='Query'),
  keyWord?: string(name='KeyWord', position='Query'),
  lang?: string(name='Lang', position='Query'),
  line?: string(name='Line', position='Query'),
  orderBy?: string(name='OrderBy', position='Query'),
  pageNumber?: long(name='PageNumber', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', minimum=1, maximum=500, position='Query'),
  RRKeyWord?: string(name='RRKeyWord', position='Query'),
  searchMode?: string(name='SearchMode', position='Query'),
  status?: string(name='Status', position='Query'),
  type?: string(name='Type', position='Query'),
  typeKeyWord?: string(name='TypeKeyWord', position='Query'),
  valueKeyWord?: string(name='ValueKeyWord', position='Query'),
}

model DescribeDomainRecordsResponseBody = {
  domainRecords?: {
    record?: [ 
    {
      domainName?: string(name='DomainName'),
      line?: string(name='Line'),
      locked?: boolean(name='Locked'),
      priority?: long(name='Priority'),
      rr?: string(name='RR'),
      recordId?: string(name='RecordId'),
      remark?: string(name='Remark'),
      status?: string(name='Status'),
      TTL?: long(name='TTL'),
      type?: string(name='Type'),
      value?: string(name='Value'),
      weight?: int32(name='Weight'),
    }
  ](name='Record')
  }(name='DomainRecords'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeDomainRecordsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainRecordsResponseBody(name='body'),
}

async function describeDomainRecords(request: DescribeDomainRecordsRequest): DescribeDomainRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainRecords', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainStatisticsRequest {
  domainName: string(name='DomainName', position='Query'),
  domainType?: string(name='DomainType', position='Query'),
  endDate?: string(name='EndDate', position='Query'),
  lang?: string(name='Lang', position='Query'),
  startDate: string(name='StartDate', position='Query'),
}

model DescribeDomainStatisticsResponseBody = {
  requestId?: string(name='RequestId'),
  statistics?: {
    statistic?: [ 
    {
      count?: long(name='Count'),
      timestamp?: long(name='Timestamp'),
    }
  ](name='Statistic')
  }(name='Statistics'),
}

model DescribeDomainStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainStatisticsResponseBody(name='body'),
}

async function describeDomainStatistics(request: DescribeDomainStatisticsRequest): DescribeDomainStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainStatistics', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainStatisticsSummaryRequest {
  endDate?: string(name='EndDate', position='Query'),
  keyword?: string(name='Keyword', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: long(name='PageNumber', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', minimum=1, maximum=100, position='Query'),
  searchMode?: string(name='SearchMode', position='Query'),
  startDate: string(name='StartDate', position='Query'),
  threshold?: long(name='Threshold', minimum=0, position='Query'),
}

model DescribeDomainStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  statistics?: {
    statistic?: [ 
    {
      count?: long(name='Count'),
      domainName?: string(name='DomainName'),
      domainType?: string(name='DomainType'),
    }
  ](name='Statistic')
  }(name='Statistics'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeDomainStatisticsSummaryResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainStatisticsSummaryResponseBody(name='body'),
}

async function describeDomainStatisticsSummary(request: DescribeDomainStatisticsSummaryRequest): DescribeDomainStatisticsSummaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainStatisticsSummary', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainsRequest {
  groupId?: string(name='GroupId', position='Query'),
  keyWord?: string(name='KeyWord', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: long(name='PageNumber', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', minimum=1, maximum=100, position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  searchMode?: string(name='SearchMode', position='Query'),
  starmark?: boolean(name='Starmark', position='Query'),
}

model DescribeDomainsResponseBody = {
  domains?: {
    domain?: [ 
    {
      aliDomain?: boolean(name='AliDomain'),
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      dnsServers?: {
        dnsServer?: [ string ](name='DnsServer')
      }(name='DnsServers'),
      domainId?: string(name='DomainId'),
      domainName?: string(name='DomainName'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      instanceEndTime?: string(name='InstanceEndTime'),
      instanceExpired?: boolean(name='InstanceExpired'),
      instanceId?: string(name='InstanceId'),
      punyCode?: string(name='PunyCode'),
      recordCount?: long(name='RecordCount'),
      registrantEmail?: string(name='RegistrantEmail'),
      remark?: string(name='Remark'),
      resourceGroupId?: string(name='ResourceGroupId'),
      starmark?: boolean(name='Starmark'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      versionCode?: string(name='VersionCode'),
      versionName?: string(name='VersionName'),
    }
  ](name='Domain')
  }(name='Domains'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeDomainsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainsResponseBody(name='body'),
}

async function describeDomains(request: DescribeDomainsRequest): DescribeDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomains', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmAccessStrategiesRequest {
  instanceId?: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model DescribeGtmAccessStrategiesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  strategies?: {
    strategy?: [ 
    {
      accessMode?: string(name='AccessMode'),
      accessStatus?: string(name='AccessStatus'),
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      defaultAddrPoolId?: string(name='DefaultAddrPoolId'),
      defaultAddrPoolMonitorStatus?: string(name='DefaultAddrPoolMonitorStatus'),
      defaultAddrPoolName?: string(name='DefaultAddrPoolName'),
      defaultAddrPoolStatus?: string(name='DefaultAddrPoolStatus'),
      failoverAddrPoolId?: string(name='FailoverAddrPoolId'),
      failoverAddrPoolMonitorStatus?: string(name='FailoverAddrPoolMonitorStatus'),
      failoverAddrPoolName?: string(name='FailoverAddrPoolName'),
      failoverAddrPoolStatus?: string(name='FailoverAddrPoolStatus'),
      instanceId?: string(name='InstanceId'),
      lines?: {
        line?: [ 
        {
          groupCode?: string(name='GroupCode'),
          groupName?: string(name='GroupName'),
          lineCode?: string(name='LineCode'),
          lineName?: string(name='LineName'),
        }
      ](name='Line')
      }(name='Lines'),
      strategyId?: string(name='StrategyId'),
      strategyMode?: string(name='StrategyMode'),
      strategyName?: string(name='StrategyName'),
    }
  ](name='Strategy')
  }(name='Strategies'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeGtmAccessStrategiesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGtmAccessStrategiesResponseBody(name='body'),
}

async function describeGtmAccessStrategies(request: DescribeGtmAccessStrategiesRequest): DescribeGtmAccessStrategiesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmAccessStrategies', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmAccessStrategyRequest {
  lang?: string(name='Lang', position='Query'),
  strategyId: string(name='StrategyId', position='Query'),
}

model DescribeGtmAccessStrategyResponseBody = {
  accessMode?: string(name='AccessMode'),
  accessStatus?: string(name='AccessStatus'),
  defaultAddrPoolMonitorStatus?: string(name='DefaultAddrPoolMonitorStatus'),
  defaultAddrPoolName?: string(name='DefaultAddrPoolName'),
  defaultAddrPoolStatus?: string(name='DefaultAddrPoolStatus'),
  defultAddrPoolId?: string(name='DefultAddrPoolId'),
  failoverAddrPoolId?: string(name='FailoverAddrPoolId'),
  failoverAddrPoolMonitorStatus?: string(name='FailoverAddrPoolMonitorStatus'),
  failoverAddrPoolName?: string(name='FailoverAddrPoolName'),
  failoverAddrPoolStatus?: string(name='FailoverAddrPoolStatus'),
  instanceId?: string(name='InstanceId'),
  lines?: {
    line?: [ 
    {
      groupCode?: string(name='GroupCode'),
      groupName?: string(name='GroupName'),
      lineCode?: string(name='LineCode'),
      lineName?: string(name='LineName'),
    }
  ](name='Line')
  }(name='Lines'),
  requestId?: string(name='RequestId'),
  strategyId?: string(name='StrategyId'),
  strategyMode?: string(name='StrategyMode'),
  strategyName?: string(name='StrategyName'),
}

model DescribeGtmAccessStrategyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGtmAccessStrategyResponseBody(name='body'),
}

async function describeGtmAccessStrategy(request: DescribeGtmAccessStrategyRequest): DescribeGtmAccessStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmAccessStrategy', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmAccessStrategyAvailableConfigRequest {
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model DescribeGtmAccessStrategyAvailableConfigResponseBody = {
  addrPools?: {
    addrPool?: [ 
    {
      addrPoolId?: string(name='AddrPoolId'),
      addrPoolName?: string(name='AddrPoolName'),
    }
  ](name='AddrPool')
  }(name='AddrPools'),
  lines?: {
    line?: [ 
    {
      fatherCode?: string(name='FatherCode'),
      groupCode?: string(name='GroupCode'),
      groupName?: string(name='GroupName'),
      lineCode?: string(name='LineCode'),
      lineName?: string(name='LineName'),
      status?: string(name='Status'),
    }
  ](name='Line')
  }(name='Lines'),
  requestId?: string(name='RequestId'),
}

model DescribeGtmAccessStrategyAvailableConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGtmAccessStrategyAvailableConfigResponseBody(name='body'),
}

async function describeGtmAccessStrategyAvailableConfig(request: DescribeGtmAccessStrategyAvailableConfigRequest): DescribeGtmAccessStrategyAvailableConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmAccessStrategyAvailableConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmAvailableAlertGroupRequest {
  lang?: string(name='Lang', position='Query'),
}

model DescribeGtmAvailableAlertGroupResponseBody = {
  availableAlertGroup?: string(name='AvailableAlertGroup'),
  requestId?: string(name='RequestId'),
}

model DescribeGtmAvailableAlertGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGtmAvailableAlertGroupResponseBody(name='body'),
}

async function describeGtmAvailableAlertGroup(request: DescribeGtmAvailableAlertGroupRequest): DescribeGtmAvailableAlertGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmAvailableAlertGroup', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmInstanceRequest {
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  needDetailAttributes?: boolean(name='NeedDetailAttributes', position='Query'),
}

model DescribeGtmInstanceResponseBody = {
  accessStrategyNum?: int32(name='AccessStrategyNum'),
  addressPoolNum?: int32(name='AddressPoolNum'),
  alertGroup?: string(name='AlertGroup'),
  cname?: string(name='Cname'),
  cnameMode?: string(name='CnameMode'),
  createTime?: string(name='CreateTime'),
  createTimestamp?: long(name='CreateTimestamp'),
  expireTime?: string(name='ExpireTime'),
  expireTimestamp?: long(name='ExpireTimestamp'),
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  lbaStrategy?: string(name='LbaStrategy'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  ttl?: int32(name='Ttl'),
  userDomainName?: string(name='UserDomainName'),
  versionCode?: string(name='VersionCode'),
}

model DescribeGtmInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGtmInstanceResponseBody(name='body'),
}

async function describeGtmInstance(request: DescribeGtmInstanceRequest): DescribeGtmInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmInstance', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmInstanceAddressPoolRequest {
  addrPoolId: string(name='AddrPoolId', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model DescribeGtmInstanceAddressPoolResponseBody = {
  addrCount?: int32(name='AddrCount'),
  addrPoolId?: string(name='AddrPoolId'),
  addrs?: {
    addr?: [ 
    {
      addrId?: long(name='AddrId'),
      alertStatus?: string(name='AlertStatus'),
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      lbaWeight?: int32(name='LbaWeight'),
      mode?: string(name='Mode'),
      updateTime?: string(name='UpdateTime'),
      updateTimestamp?: long(name='UpdateTimestamp'),
      value?: string(name='Value'),
    }
  ](name='Addr')
  }(name='Addrs'),
  createTime?: string(name='CreateTime'),
  createTimestamp?: long(name='CreateTimestamp'),
  minAvailableAddrNum?: int32(name='MinAvailableAddrNum'),
  monitorConfigId?: string(name='MonitorConfigId'),
  monitorStatus?: string(name='MonitorStatus'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  type?: string(name='Type'),
  updateTime?: string(name='UpdateTime'),
  updateTimestamp?: long(name='UpdateTimestamp'),
}

model DescribeGtmInstanceAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGtmInstanceAddressPoolResponseBody(name='body'),
}

async function describeGtmInstanceAddressPool(request: DescribeGtmInstanceAddressPoolRequest): DescribeGtmInstanceAddressPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmInstanceAddressPool', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmInstanceAddressPoolsRequest {
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
}

model DescribeGtmInstanceAddressPoolsResponseBody = {
  addrPools?: {
    addrPool?: [ 
    {
      addrCount?: int32(name='AddrCount'),
      addrPoolId?: string(name='AddrPoolId'),
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      minAvailableAddrNum?: int32(name='MinAvailableAddrNum'),
      monitorConfigId?: string(name='MonitorConfigId'),
      monitorStatus?: string(name='MonitorStatus'),
      name?: string(name='Name'),
      status?: string(name='Status'),
      type?: string(name='Type'),
      updateTime?: string(name='UpdateTime'),
      updateTimestamp?: long(name='UpdateTimestamp'),
    }
  ](name='AddrPool')
  }(name='AddrPools'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeGtmInstanceAddressPoolsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGtmInstanceAddressPoolsResponseBody(name='body'),
}

async function describeGtmInstanceAddressPools(request: DescribeGtmInstanceAddressPoolsRequest): DescribeGtmInstanceAddressPoolsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmInstanceAddressPools', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmInstanceStatusRequest {
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model DescribeGtmInstanceStatusResponseBody = {
  addrNotAvailableNum?: int32(name='AddrNotAvailableNum'),
  addrPoolNotAvailableNum?: int32(name='AddrPoolNotAvailableNum'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  statusReason?: string(name='StatusReason'),
  strategyNotAvailableNum?: int32(name='StrategyNotAvailableNum'),
  switchToFailoverStrategyNum?: int32(name='SwitchToFailoverStrategyNum'),
}

model DescribeGtmInstanceStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGtmInstanceStatusResponseBody(name='body'),
}

async function describeGtmInstanceStatus(request: DescribeGtmInstanceStatusRequest): DescribeGtmInstanceStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmInstanceStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmInstanceSystemCnameRequest {
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model DescribeGtmInstanceSystemCnameResponseBody = {
  requestId?: string(name='RequestId'),
  systemCname?: string(name='SystemCname'),
}

model DescribeGtmInstanceSystemCnameResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGtmInstanceSystemCnameResponseBody(name='body'),
}

async function describeGtmInstanceSystemCname(request: DescribeGtmInstanceSystemCnameRequest): DescribeGtmInstanceSystemCnameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmInstanceSystemCname', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmInstancesRequest {
  keyword?: string(name='Keyword', position='Query'),
  lang?: string(name='Lang', position='Query'),
  needDetailAttributes?: boolean(name='NeedDetailAttributes', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
}

model DescribeGtmInstancesResponseBody = {
  gtmInstances?: {
    gtmInstance?: [ 
    {
      accessStrategyNum?: int32(name='AccessStrategyNum'),
      addressPoolNum?: int32(name='AddressPoolNum'),
      alertGroup?: string(name='AlertGroup'),
      cname?: string(name='Cname'),
      cnameMode?: string(name='CnameMode'),
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      expireTime?: string(name='ExpireTime'),
      expireTimestamp?: long(name='ExpireTimestamp'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      lbaStrategy?: string(name='LbaStrategy'),
      resourceGroupId?: string(name='ResourceGroupId'),
      ttl?: int32(name='Ttl'),
      userDomainName?: string(name='UserDomainName'),
      versionCode?: string(name='VersionCode'),
    }
  ](name='GtmInstance')
  }(name='GtmInstances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeGtmInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGtmInstancesResponseBody(name='body'),
}

async function describeGtmInstances(request: DescribeGtmInstancesRequest): DescribeGtmInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmLogsRequest {
  endTimestamp?: long(name='EndTimestamp', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  keyword?: string(name='Keyword', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  startTimestamp?: long(name='StartTimestamp', position='Query'),
}

model DescribeGtmLogsResponseBody = {
  logs?: {
    log?: [ 
    {
      content?: string(name='Content'),
      entityId?: string(name='EntityId'),
      entityName?: string(name='EntityName'),
      entityType?: string(name='EntityType'),
      id?: long(name='Id'),
      operAction?: string(name='OperAction'),
      operIp?: string(name='OperIp'),
      operTime?: string(name='OperTime'),
      operTimestamp?: long(name='OperTimestamp'),
    }
  ](name='Log')
  }(name='Logs'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeGtmLogsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGtmLogsResponseBody(name='body'),
}

async function describeGtmLogs(request: DescribeGtmLogsRequest): DescribeGtmLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmLogs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmMonitorAvailableConfigRequest {
  lang?: string(name='Lang', position='Query'),
}

model DescribeGtmMonitorAvailableConfigResponseBody = {
  ispCityNodes?: {
    ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode'),
      cityName?: string(name='CityName'),
      defaultSelected?: boolean(name='DefaultSelected'),
      groupName?: string(name='GroupName'),
      groupType?: string(name='GroupType'),
      ispCode?: string(name='IspCode'),
      ispName?: string(name='IspName'),
      mainland?: boolean(name='Mainland'),
    }
  ](name='IspCityNode')
  }(name='IspCityNodes'),
  requestId?: string(name='RequestId'),
}

model DescribeGtmMonitorAvailableConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGtmMonitorAvailableConfigResponseBody(name='body'),
}

async function describeGtmMonitorAvailableConfig(request: DescribeGtmMonitorAvailableConfigRequest): DescribeGtmMonitorAvailableConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmMonitorAvailableConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmMonitorConfigRequest {
  lang?: string(name='Lang', position='Query'),
  monitorConfigId: string(name='MonitorConfigId', position='Query'),
}

model DescribeGtmMonitorConfigResponseBody = {
  createTime?: string(name='CreateTime'),
  createTimestamp?: long(name='CreateTimestamp'),
  evaluationCount?: int32(name='EvaluationCount'),
  interval?: int32(name='Interval'),
  ispCityNodes?: {
    ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode'),
      cityName?: string(name='CityName'),
      countryCode?: string(name='CountryCode'),
      countryName?: string(name='CountryName'),
      ispCode?: string(name='IspCode'),
      ispName?: string(name='IspName'),
    }
  ](name='IspCityNode')
  }(name='IspCityNodes'),
  monitorConfigId?: string(name='MonitorConfigId'),
  monitorExtendInfo?: string(name='MonitorExtendInfo'),
  protocolType?: string(name='ProtocolType'),
  requestId?: string(name='RequestId'),
  timeout?: int32(name='Timeout'),
  updateTime?: string(name='UpdateTime'),
  updateTimestamp?: long(name='UpdateTimestamp'),
}

model DescribeGtmMonitorConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGtmMonitorConfigResponseBody(name='body'),
}

async function describeGtmMonitorConfig(request: DescribeGtmMonitorConfigRequest): DescribeGtmMonitorConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmMonitorConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmRecoveryPlanRequest {
  lang?: string(name='Lang', position='Query'),
  recoveryPlanId: long(name='RecoveryPlanId', position='Query'),
}

model DescribeGtmRecoveryPlanResponseBody = {
  createTime?: string(name='CreateTime'),
  createTimestamp?: long(name='CreateTimestamp'),
  faultAddrPoolNum?: int32(name='FaultAddrPoolNum'),
  faultAddrPools?: {
    faultAddrPool?: [ 
    {
      addrPoolId?: string(name='AddrPoolId'),
      addrPoolName?: string(name='AddrPoolName'),
      addrs?: {
        addr?: [ 
        {
          id?: long(name='Id'),
          mode?: string(name='Mode'),
          value?: string(name='Value'),
        }
      ](name='Addr')
      }(name='Addrs'),
      instanceId?: string(name='InstanceId'),
    }
  ](name='FaultAddrPool')
  }(name='FaultAddrPools'),
  lastExecuteTime?: string(name='LastExecuteTime'),
  lastExecuteTimestamp?: long(name='LastExecuteTimestamp'),
  lastRollbackTime?: string(name='LastRollbackTime'),
  lastRollbackTimestamp?: long(name='LastRollbackTimestamp'),
  name?: string(name='Name'),
  recoveryPlanId?: long(name='RecoveryPlanId'),
  remark?: string(name='Remark'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  updateTime?: string(name='UpdateTime'),
  updateTimestamp?: long(name='UpdateTimestamp'),
}

model DescribeGtmRecoveryPlanResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGtmRecoveryPlanResponseBody(name='body'),
}

async function describeGtmRecoveryPlan(request: DescribeGtmRecoveryPlanRequest): DescribeGtmRecoveryPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmRecoveryPlan', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmRecoveryPlanAvailableConfigRequest {
  lang?: string(name='Lang', position='Query'),
}

model DescribeGtmRecoveryPlanAvailableConfigResponseBody = {
  instances?: {
    instance?: [ 
    {
      addrPools?: {
        addrPool?: [ 
        {
          addrPoolId?: string(name='AddrPoolId'),
          name?: string(name='Name'),
        }
      ](name='AddrPool')
      }(name='AddrPools'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
    }
  ](name='Instance')
  }(name='Instances'),
  requestId?: string(name='RequestId'),
}

model DescribeGtmRecoveryPlanAvailableConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGtmRecoveryPlanAvailableConfigResponseBody(name='body'),
}

async function describeGtmRecoveryPlanAvailableConfig(request: DescribeGtmRecoveryPlanAvailableConfigRequest): DescribeGtmRecoveryPlanAvailableConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmRecoveryPlanAvailableConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGtmRecoveryPlansRequest {
  keyword?: string(name='Keyword', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model DescribeGtmRecoveryPlansResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  recoveryPlans?: {
    recoveryPlan?: [ 
    {
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      faultAddrPoolNum?: int32(name='FaultAddrPoolNum'),
      lastExecuteTime?: string(name='LastExecuteTime'),
      lastExecuteTimestamp?: long(name='LastExecuteTimestamp'),
      lastRollbackTime?: string(name='LastRollbackTime'),
      lastRollbackTimestamp?: long(name='LastRollbackTimestamp'),
      name?: string(name='Name'),
      recoveryPlanId?: long(name='RecoveryPlanId'),
      remark?: string(name='Remark'),
      status?: string(name='Status'),
      updateTime?: string(name='UpdateTime'),
      updateTimestamp?: long(name='UpdateTimestamp'),
    }
  ](name='RecoveryPlan')
  }(name='RecoveryPlans'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeGtmRecoveryPlansResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGtmRecoveryPlansResponseBody(name='body'),
}

async function describeGtmRecoveryPlans(request: DescribeGtmRecoveryPlansRequest): DescribeGtmRecoveryPlansResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGtmRecoveryPlans', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceDomainsRequest {
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
}

model DescribeInstanceDomainsResponseBody = {
  instanceDomains?: [ 
    {
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      domainName?: string(name='DomainName'),
    }
  ](name='InstanceDomains'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeInstanceDomainsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceDomainsResponseBody(name='body'),
}

async function describeInstanceDomains(request: DescribeInstanceDomainsRequest): DescribeInstanceDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceDomains', 'POST', '/', 'json', false, 'json', request);
}

model DescribeIspFlushCacheInstancesRequest {
  direction?: string(name='Direction', position='Query'),
  isp?: string(name='Isp', position='Query'),
  keyword?: string(name='Keyword', position='Query'),
  lang?: string(name='Lang', position='Query'),
  orderBy?: string(name='OrderBy', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=9999999, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  type?: string(name='Type', position='Query'),
}

model DescribeIspFlushCacheInstancesResponseBody = {
  ispFlushCacheInstances?: [ 
    {
      expireTime?: string(name='ExpireTime'),
      expireTimestamp?: long(name='ExpireTimestamp'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      isp?: string(name='Isp'),
      quotaInfo?: {
        instanceQuota?: int32(name='InstanceQuota'),
        instanceQuotaUsed?: int32(name='InstanceQuotaUsed'),
      }(name='QuotaInfo'),
      status?: string(name='Status'),
      versionCode?: string(name='VersionCode'),
    }
  ](name='IspFlushCacheInstances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeIspFlushCacheInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIspFlushCacheInstancesResponseBody(name='body'),
}

async function describeIspFlushCacheInstances(request: DescribeIspFlushCacheInstancesRequest): DescribeIspFlushCacheInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeIspFlushCacheInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeIspFlushCacheRemainQuotaRequest {
  lang?: string(name='Lang', position='Query'),
}

model DescribeIspFlushCacheRemainQuotaResponseBody = {
  requestId?: string(name='RequestId'),
  telecomRemainQuota?: int32(name='TelecomRemainQuota'),
}

model DescribeIspFlushCacheRemainQuotaResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIspFlushCacheRemainQuotaResponseBody(name='body'),
}

async function describeIspFlushCacheRemainQuota(request: DescribeIspFlushCacheRemainQuotaRequest): DescribeIspFlushCacheRemainQuotaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeIspFlushCacheRemainQuota', 'POST', '/', 'json', false, 'json', request);
}

model DescribeIspFlushCacheTaskRequest {
  lang?: string(name='Lang', position='Query'),
  taskId: string(name='TaskId', position='Query'),
}

model DescribeIspFlushCacheTaskResponseBody = {
  createTime?: string(name='CreateTime'),
  createTimestamp?: long(name='CreateTimestamp'),
  domainName?: string(name='DomainName'),
  flushCacheResults?: [ 
    {
      dnsNodes?: [ 
        {
          answers?: [ 
            {
              name?: string(name='Name'),
              record?: string(name='Record'),
              ttl?: long(name='Ttl'),
              type?: string(name='Type'),
            }
          ](name='Answers'),
          nodeIp?: string(name='NodeIp'),
          spName?: string(name='SpName'),
          status?: string(name='Status'),
        }
      ](name='DnsNodes'),
      province?: string(name='Province'),
    }
  ](name='FlushCacheResults'),
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  isp?: string(name='Isp'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
  taskStatus?: string(name='TaskStatus'),
}

model DescribeIspFlushCacheTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIspFlushCacheTaskResponseBody(name='body'),
}

async function describeIspFlushCacheTask(request: DescribeIspFlushCacheTaskRequest): DescribeIspFlushCacheTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeIspFlushCacheTask', 'POST', '/', 'json', false, 'json', request);
}

model DescribeIspFlushCacheTasksRequest {
  direction?: string(name='Direction', position='Query'),
  domainName?: string(name='DomainName', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  isp?: string(name='Isp', position='Query'),
  lang?: string(name='Lang', position='Query'),
  orderBy?: string(name='OrderBy', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=9999999, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
}

model DescribeIspFlushCacheTasksResponseBody = {
  ispFlushCacheTasks?: [ 
    {
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      domainName?: string(name='DomainName'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      isp?: string(name='Isp'),
      taskId?: string(name='TaskId'),
      taskStatus?: string(name='TaskStatus'),
    }
  ](name='IspFlushCacheTasks'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeIspFlushCacheTasksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIspFlushCacheTasksResponseBody(name='body'),
}

async function describeIspFlushCacheTasks(request: DescribeIspFlushCacheTasksRequest): DescribeIspFlushCacheTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeIspFlushCacheTasks', 'POST', '/', 'json', false, 'json', request);
}

model DescribePdnsAccountSummaryRequest {
  endDate?: string(name='EndDate', position='Query'),
  lang?: string(name='Lang', position='Query'),
  startDate?: string(name='StartDate', position='Query'),
}

model DescribePdnsAccountSummaryResponseBody = {
  data?: {
    domainCount?: long(name='DomainCount'),
    httpCount?: long(name='HttpCount'),
    httpsCount?: long(name='HttpsCount'),
    subDomainCount?: long(name='SubDomainCount'),
    threatCount?: long(name='ThreatCount'),
    totalCount?: long(name='TotalCount'),
    userId?: long(name='UserId'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribePdnsAccountSummaryResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePdnsAccountSummaryResponseBody(name='body'),
}

async function describePdnsAccountSummary(request: DescribePdnsAccountSummaryRequest): DescribePdnsAccountSummaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePdnsAccountSummary', 'POST', '/', 'json', false, 'json', request);
}

model DescribePdnsAppKeyRequest {
  appKeyId?: string(name='AppKeyId', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model DescribePdnsAppKeyResponseBody = {
  appKey?: {
    appKeyId?: string(name='AppKeyId'),
    appKeySecret?: string(name='AppKeySecret'),
    createDate?: string(name='CreateDate'),
    state?: string(name='State'),
  }(name='AppKey'),
  requestId?: string(name='RequestId'),
}

model DescribePdnsAppKeyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePdnsAppKeyResponseBody(name='body'),
}

async function describePdnsAppKey(request: DescribePdnsAppKeyRequest): DescribePdnsAppKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePdnsAppKey', 'POST', '/', 'json', false, 'json', request);
}

model DescribePdnsAppKeysRequest {
  lang?: string(name='Lang', position='Query'),
}

model DescribePdnsAppKeysResponseBody = {
  appKeys?: [ 
    {
      appKeyId?: string(name='AppKeyId'),
      createDate?: string(name='CreateDate'),
      state?: string(name='State'),
    }
  ](name='AppKeys'),
  requestId?: string(name='RequestId'),
}

model DescribePdnsAppKeysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePdnsAppKeysResponseBody(name='body'),
}

async function describePdnsAppKeys(request: DescribePdnsAppKeysRequest): DescribePdnsAppKeysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePdnsAppKeys', 'POST', '/', 'json', false, 'json', request);
}

model DescribePdnsOperateLogsRequest {
  actionType?: string(name='ActionType', position='Query'),
  endDate?: string(name='EndDate', position='Query'),
  keyword?: string(name='Keyword', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  startDate?: string(name='StartDate', position='Query'),
}

model DescribePdnsOperateLogsResponseBody = {
  logs?: [ 
    {
      action?: string(name='Action'),
      operateTime?: string(name='OperateTime'),
      type?: string(name='Type'),
      content?: string(name='content'),
    }
  ](name='Logs'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePdnsOperateLogsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePdnsOperateLogsResponseBody(name='body'),
}

async function describePdnsOperateLogs(request: DescribePdnsOperateLogsRequest): DescribePdnsOperateLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePdnsOperateLogs', 'POST', '/', 'json', false, 'json', request);
}

model DescribePdnsRequestStatisticRequest {
  domainName?: string(name='DomainName', position='Query'),
  endDate?: string(name='EndDate', position='Query'),
  lang?: string(name='Lang', position='Query'),
  startDate?: string(name='StartDate', position='Query'),
  subDomain?: string(name='SubDomain', position='Query'),
}

model DescribePdnsRequestStatisticResponseBody = {
  data?: [ 
    {
      dohTotalCount?: long(name='DohTotalCount'),
      httpCount?: long(name='HttpCount'),
      httpsCount?: long(name='HttpsCount'),
      ipCount?: long(name='IpCount'),
      timestamp?: long(name='Timestamp'),
      totalCount?: long(name='TotalCount'),
      udpTotalCount?: long(name='UdpTotalCount'),
      v4Count?: long(name='V4Count'),
      v4HttpCount?: long(name='V4HttpCount'),
      v4HttpsCount?: long(name='V4HttpsCount'),
      v6Count?: long(name='V6Count'),
      v6HttpCount?: long(name='V6HttpCount'),
      v6HttpsCount?: long(name='V6HttpsCount'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribePdnsRequestStatisticResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePdnsRequestStatisticResponseBody(name='body'),
}

async function describePdnsRequestStatistic(request: DescribePdnsRequestStatisticRequest): DescribePdnsRequestStatisticResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePdnsRequestStatistic', 'POST', '/', 'json', false, 'json', request);
}

model DescribePdnsRequestStatisticsRequest {
  domainName?: string(name='DomainName', position='Query'),
  endDate?: string(name='EndDate', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  startDate?: string(name='StartDate', position='Query'),
  subDomain?: string(name='SubDomain', position='Query'),
  type?: string(name='Type', position='Query'),
}

model DescribePdnsRequestStatisticsResponseBody = {
  data?: [ 
    {
      dohTotalCount?: long(name='DohTotalCount'),
      domainName?: string(name='DomainName'),
      httpCount?: long(name='HttpCount'),
      httpsCount?: long(name='HttpsCount'),
      ipCount?: long(name='IpCount'),
      maxThreatLevel?: string(name='MaxThreatLevel'),
      subDomain?: string(name='SubDomain'),
      threatCount?: long(name='ThreatCount'),
      threatInfo?: [ 
        {
          threatLevel?: string(name='ThreatLevel'),
          threatType?: string(name='ThreatType'),
        }
      ](name='ThreatInfo'),
      totalCount?: long(name='TotalCount'),
      udpTotalCount?: long(name='UdpTotalCount'),
      v4Count?: long(name='V4Count'),
      v4HttpCount?: long(name='V4HttpCount'),
      v4HttpsCount?: long(name='V4HttpsCount'),
      v6Count?: long(name='V6Count'),
      v6HttpCount?: long(name='V6HttpCount'),
      v6HttpsCount?: long(name='V6HttpsCount'),
    }
  ](name='Data'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePdnsRequestStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePdnsRequestStatisticsResponseBody(name='body'),
}

async function describePdnsRequestStatistics(request: DescribePdnsRequestStatisticsRequest): DescribePdnsRequestStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePdnsRequestStatistics', 'POST', '/', 'json', false, 'json', request);
}

model DescribePdnsThreatLogsRequest {
  endDate?: string(name='EndDate', position='Query'),
  keyword?: string(name='Keyword', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  startDate?: string(name='StartDate', position='Query'),
  threatLevel?: string(name='ThreatLevel', position='Query'),
  threatSourceIp?: string(name='ThreatSourceIp', position='Query'),
  threatType?: string(name='ThreatType', position='Query'),
}

model DescribePdnsThreatLogsResponseBody = {
  logs?: [ 
    {
      sourceIp?: string(name='SourceIp'),
      subDomain?: string(name='SubDomain'),
      threatLevel?: string(name='ThreatLevel'),
      threatTime?: string(name='ThreatTime'),
      threatType?: string(name='ThreatType'),
    }
  ](name='Logs'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePdnsThreatLogsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePdnsThreatLogsResponseBody(name='body'),
}

async function describePdnsThreatLogs(request: DescribePdnsThreatLogsRequest): DescribePdnsThreatLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePdnsThreatLogs', 'POST', '/', 'json', false, 'json', request);
}

model DescribePdnsThreatStatisticRequest {
  endDate?: string(name='EndDate', position='Query'),
  lang?: string(name='Lang', position='Query'),
  startDate?: string(name='StartDate', position='Query'),
  threatSourceIp?: string(name='ThreatSourceIp', position='Query'),
}

model DescribePdnsThreatStatisticResponseBody = {
  data?: [ 
    {
      dohTotalCount?: long(name='DohTotalCount'),
      threatLevel?: string(name='ThreatLevel'),
      threatType?: string(name='ThreatType'),
      timestamp?: long(name='Timestamp'),
      totalCount?: long(name='TotalCount'),
      udpTotalCount?: long(name='UdpTotalCount'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribePdnsThreatStatisticResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePdnsThreatStatisticResponseBody(name='body'),
}

async function describePdnsThreatStatistic(request: DescribePdnsThreatStatisticRequest): DescribePdnsThreatStatisticResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePdnsThreatStatistic', 'POST', '/', 'json', false, 'json', request);
}

model DescribePdnsThreatStatisticsRequest {
  direction?: string(name='Direction', position='Query'),
  domainName?: string(name='DomainName', position='Query'),
  endDate?: string(name='EndDate', position='Query'),
  lang?: string(name='Lang', position='Query'),
  orderBy?: string(name='OrderBy', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  startDate?: string(name='StartDate', position='Query'),
  subDomain?: string(name='SubDomain', position='Query'),
  threatLevel?: string(name='ThreatLevel', position='Query'),
  threatSourceIp?: string(name='ThreatSourceIp', position='Query'),
  threatType?: string(name='ThreatType', position='Query'),
  type?: string(name='Type', position='Query'),
}

model DescribePdnsThreatStatisticsResponseBody = {
  data?: [ 
    {
      dohTotalCount?: long(name='DohTotalCount'),
      domainCount?: long(name='DomainCount'),
      domainName?: string(name='DomainName'),
      latestThreatTime?: long(name='LatestThreatTime'),
      maxThreatLevel?: string(name='MaxThreatLevel'),
      sourceIp?: string(name='SourceIp'),
      subDomain?: string(name='SubDomain'),
      threatLevel?: string(name='ThreatLevel'),
      threatType?: string(name='ThreatType'),
      totalCount?: long(name='TotalCount'),
      udpTotalCount?: long(name='UdpTotalCount'),
    }
  ](name='Data'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePdnsThreatStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePdnsThreatStatisticsResponseBody(name='body'),
}

async function describePdnsThreatStatistics(request: DescribePdnsThreatStatisticsRequest): DescribePdnsThreatStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePdnsThreatStatistics', 'POST', '/', 'json', false, 'json', request);
}

model DescribePdnsUdpIpSegmentsRequest {
  lang?: string(name='Lang', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
}

model DescribePdnsUdpIpSegmentsResponseBody = {
  ipSegments?: [ 
    {
      createDate?: string(name='CreateDate'),
      ip?: string(name='Ip'),
      mask?: long(name='Mask'),
      name?: string(name='Name'),
      state?: string(name='State'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='IpSegments'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePdnsUdpIpSegmentsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePdnsUdpIpSegmentsResponseBody(name='body'),
}

async function describePdnsUdpIpSegments(request: DescribePdnsUdpIpSegmentsRequest): DescribePdnsUdpIpSegmentsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePdnsUdpIpSegments', 'POST', '/', 'json', false, 'json', request);
}

model DescribePdnsUserInfoRequest {
  lang?: string(name='Lang', position='Query'),
}

model DescribePdnsUserInfoResponseBody = {
  requestId?: string(name='RequestId'),
  userInfo?: {
    availableService?: string(name='AvailableService'),
    pdnsId?: long(name='PdnsId'),
    serviceType?: string(name='ServiceType'),
    state?: string(name='State'),
    stoppedService?: string(name='StoppedService'),
  }(name='UserInfo'),
}

model DescribePdnsUserInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePdnsUserInfoResponseBody(name='body'),
}

async function describePdnsUserInfo(request: DescribePdnsUserInfoRequest): DescribePdnsUserInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePdnsUserInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRecordLogsRequest {
  domainName: string(name='DomainName', position='Query'),
  keyWord?: string(name='KeyWord', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: long(name='PageNumber', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', minimum=1, maximum=100, position='Query'),
  startDate?: string(name='StartDate', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
  endDate?: string(name='endDate', position='Query'),
}

model DescribeRecordLogsResponseBody = {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  recordLogs?: {
    recordLog?: [ 
    {
      action?: string(name='Action'),
      actionTime?: string(name='ActionTime'),
      actionTimestamp?: long(name='ActionTimestamp'),
      clientIp?: string(name='ClientIp'),
      message?: string(name='Message'),
    }
  ](name='RecordLog')
  }(name='RecordLogs'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeRecordLogsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRecordLogsResponseBody(name='body'),
}

async function describeRecordLogs(request: DescribeRecordLogsRequest): DescribeRecordLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRecordLogs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRecordStatisticsRequest {
  domainName: string(name='DomainName', position='Query'),
  domainType?: string(name='DomainType', position='Query'),
  endDate?: string(name='EndDate', position='Query'),
  lang?: string(name='Lang', position='Query'),
  rr: string(name='Rr', position='Query'),
  startDate: string(name='StartDate', position='Query'),
}

model DescribeRecordStatisticsResponseBody = {
  requestId?: string(name='RequestId'),
  statistics?: {
    statistic?: [ 
    {
      count?: long(name='Count'),
      timestamp?: long(name='Timestamp'),
    }
  ](name='Statistic')
  }(name='Statistics'),
}

model DescribeRecordStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRecordStatisticsResponseBody(name='body'),
}

async function describeRecordStatistics(request: DescribeRecordStatisticsRequest): DescribeRecordStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRecordStatistics', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRecordStatisticsSummaryRequest {
  domainName: string(name='DomainName', position='Query'),
  domainType?: string(name='DomainType', position='Query'),
  endDate?: string(name='EndDate', position='Query'),
  keyword?: string(name='Keyword', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: long(name='PageNumber', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', minimum=1, maximum=100, position='Query'),
  searchMode?: string(name='SearchMode', position='Query'),
  startDate: string(name='StartDate', position='Query'),
  threshold?: long(name='Threshold', position='Query'),
}

model DescribeRecordStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  statistics?: {
    statistic?: [ 
    {
      count?: long(name='Count'),
      subDomain?: string(name='SubDomain'),
    }
  ](name='Statistic')
  }(name='Statistics'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeRecordStatisticsSummaryResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRecordStatisticsSummaryResponseBody(name='body'),
}

async function describeRecordStatisticsSummary(request: DescribeRecordStatisticsSummaryRequest): DescribeRecordStatisticsSummaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRecordStatisticsSummary', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSubDomainRecordsRequest {
  domainName?: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  line?: string(name='Line', position='Query'),
  pageNumber?: long(name='PageNumber', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', minimum=1, maximum=500, position='Query'),
  subDomain: string(name='SubDomain', position='Query'),
  type?: string(name='Type', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model DescribeSubDomainRecordsResponseBody = {
  domainRecords?: {
    record?: [ 
    {
      domainName?: string(name='DomainName'),
      line?: string(name='Line'),
      locked?: boolean(name='Locked'),
      priority?: long(name='Priority'),
      rr?: string(name='RR'),
      recordId?: string(name='RecordId'),
      remark?: string(name='Remark'),
      status?: string(name='Status'),
      TTL?: long(name='TTL'),
      type?: string(name='Type'),
      value?: string(name='Value'),
      weight?: int32(name='Weight'),
    }
  ](name='Record')
  }(name='DomainRecords'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeSubDomainRecordsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSubDomainRecordsResponseBody(name='body'),
}

async function describeSubDomainRecords(request: DescribeSubDomainRecordsRequest): DescribeSubDomainRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSubDomainRecords', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSupportLinesRequest {
  domainName?: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model DescribeSupportLinesResponseBody = {
  recordLines?: {
    recordLine?: [ 
    {
      fatherCode?: string(name='FatherCode'),
      lineCode?: string(name='LineCode'),
      lineDisplayName?: string(name='LineDisplayName'),
      lineName?: string(name='LineName'),
    }
  ](name='RecordLine')
  }(name='RecordLines'),
  requestId?: string(name='RequestId'),
}

model DescribeSupportLinesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSupportLinesResponseBody(name='body'),
}

async function describeSupportLines(request: DescribeSupportLinesRequest): DescribeSupportLinesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSupportLines', 'POST', '/', 'json', false, 'json', request);
}

model DescribeTagsRequest {
  lang?: string(name='Lang', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
}

model DescribeTagsResponseBody = {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  tags?: [ 
    {
      key?: string(name='Key'),
      values?: [ string ](name='Values'),
    }
  ](name='Tags'),
  totalCount?: long(name='TotalCount'),
}

model DescribeTagsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTagsResponseBody(name='body'),
}

async function describeTags(request: DescribeTagsRequest): DescribeTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTags', 'POST', '/', 'json', false, 'json', request);
}

model DescribeTransferDomainsRequest {
  domainName?: string(name='DomainName', position='Query'),
  fromUserId?: long(name='FromUserId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNumber?: long(name='PageNumber', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', minimum=1, maximum=100, position='Query'),
  targetUserId?: long(name='TargetUserId', position='Query'),
  transferType: string(name='TransferType', position='Query'),
}

model DescribeTransferDomainsResponseBody = {
  domainTransfers?: {
    domainTransfer?: [ 
    {
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      domainName?: string(name='DomainName'),
      fromUserId?: long(name='FromUserId'),
      id?: long(name='Id'),
      targetUserId?: long(name='TargetUserId'),
    }
  ](name='DomainTransfer')
  }(name='DomainTransfers'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeTransferDomainsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTransferDomainsResponseBody(name='body'),
}

async function describeTransferDomains(request: DescribeTransferDomainsRequest): DescribeTransferDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTransferDomains', 'POST', '/', 'json', false, 'json', request);
}

model ExecuteGtmRecoveryPlanRequest {
  lang?: string(name='Lang', position='Query'),
  recoveryPlanId: long(name='RecoveryPlanId', position='Query'),
}

model ExecuteGtmRecoveryPlanResponseBody = {
  requestId?: string(name='RequestId'),
}

model ExecuteGtmRecoveryPlanResponse = {
  headers: map[string]string(name='headers'),
  body: ExecuteGtmRecoveryPlanResponseBody(name='body'),
}

async function executeGtmRecoveryPlan(request: ExecuteGtmRecoveryPlanRequest): ExecuteGtmRecoveryPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExecuteGtmRecoveryPlan', 'POST', '/', 'json', false, 'json', request);
}

model GetMainDomainNameRequest {
  inputString: string(name='InputString', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model GetMainDomainNameResponseBody = {
  domainLevel?: long(name='DomainLevel'),
  domainName?: string(name='DomainName'),
  rr?: string(name='RR'),
  requestId?: string(name='RequestId'),
}

model GetMainDomainNameResponse = {
  headers: map[string]string(name='headers'),
  body: GetMainDomainNameResponseBody(name='body'),
}

async function getMainDomainName(request: GetMainDomainNameRequest): GetMainDomainNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMainDomainName', 'POST', '/', 'json', false, 'json', request);
}

model GetTxtRecordForVerifyRequest {
  domainName?: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  type: string(name='Type', position='Query'),
}

model GetTxtRecordForVerifyResponseBody = {
  domainName?: string(name='DomainName'),
  rr?: string(name='RR'),
  requestId?: string(name='RequestId'),
  value?: string(name='Value'),
}

model GetTxtRecordForVerifyResponse = {
  headers: map[string]string(name='headers'),
  body: GetTxtRecordForVerifyResponseBody(name='body'),
}

async function getTxtRecordForVerify(request: GetTxtRecordForVerifyRequest): GetTxtRecordForVerifyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTxtRecordForVerify', 'POST', '/', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  lang?: string(name='Lang', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  resourceId?: [ string ](name='ResourceId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', '/', 'json', false, 'json', request);
}

model ModifyHichinaDomainDNSRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model ModifyHichinaDomainDNSResponseBody = {
  newDnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='NewDnsServers'),
  originalDnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='OriginalDnsServers'),
  requestId?: string(name='RequestId'),
}

model ModifyHichinaDomainDNSResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyHichinaDomainDNSResponseBody(name='body'),
}

async function modifyHichinaDomainDNS(request: ModifyHichinaDomainDNSRequest): ModifyHichinaDomainDNSResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyHichinaDomainDNS', 'POST', '/', 'json', false, 'json', request);
}

model MoveDomainResourceGroupRequest {
  lang?: string(name='Lang', position='Query'),
  newResourceGroupId: string(name='NewResourceGroupId', position='Query'),
  resourceId: string(name='ResourceId', position='Query'),
}

model MoveDomainResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model MoveDomainResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: MoveDomainResourceGroupResponseBody(name='body'),
}

async function moveDomainResourceGroup(request: MoveDomainResourceGroupRequest): MoveDomainResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'MoveDomainResourceGroup', 'POST', '/', 'json', false, 'json', request);
}

model MoveGtmResourceGroupRequest {
  lang?: string(name='Lang', position='Query'),
  newResourceGroupId: string(name='NewResourceGroupId', position='Query'),
  resourceId: string(name='ResourceId', position='Query'),
}

model MoveGtmResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model MoveGtmResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: MoveGtmResourceGroupResponseBody(name='body'),
}

async function moveGtmResourceGroup(request: MoveGtmResourceGroupRequest): MoveGtmResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'MoveGtmResourceGroup', 'POST', '/', 'json', false, 'json', request);
}

model OperateBatchDomainRequest {
  domainRecordInfo: [ 
    {
      domain: string(name='Domain'),
      line?: string(name='Line'),
      newRr?: string(name='NewRr'),
      newType?: string(name='NewType'),
      newValue?: string(name='NewValue'),
      priority?: int32(name='Priority'),
      rr?: string(name='Rr'),
      ttl?: int32(name='Ttl'),
      type?: string(name='Type'),
      value?: string(name='Value'),
    }
  ](name='DomainRecordInfo', position='Query'),
  lang?: string(name='Lang', position='Query'),
  type: string(name='Type', position='Query'),
}

model OperateBatchDomainResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: long(name='TaskId'),
}

model OperateBatchDomainResponse = {
  headers: map[string]string(name='headers'),
  body: OperateBatchDomainResponseBody(name='body'),
}

async function operateBatchDomain(request: OperateBatchDomainRequest): OperateBatchDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OperateBatchDomain', 'POST', '/', 'json', false, 'json', request);
}

model PausePdnsServiceRequest {
  lang?: string(name='Lang', position='Query'),
  serviceType?: string(name='ServiceType', position='Query'),
}

model PausePdnsServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model PausePdnsServiceResponse = {
  headers: map[string]string(name='headers'),
  body: PausePdnsServiceResponseBody(name='body'),
}

async function pausePdnsService(request: PausePdnsServiceRequest): PausePdnsServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PausePdnsService', 'POST', '/', 'json', false, 'json', request);
}

model PreviewGtmRecoveryPlanRequest {
  lang?: string(name='Lang', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  recoveryPlanId: long(name='RecoveryPlanId', position='Query'),
}

model PreviewGtmRecoveryPlanResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  previews?: {
    preview?: [ 
    {
      instanceId?: string(name='InstanceId'),
      name?: string(name='Name'),
      switchInfos?: {
        switchInfo?: [ 
        {
          content?: string(name='Content'),
          strategyName?: string(name='StrategyName'),
        }
      ](name='SwitchInfo')
      }(name='SwitchInfos'),
      userDomainName?: string(name='UserDomainName'),
    }
  ](name='Preview')
  }(name='Previews'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model PreviewGtmRecoveryPlanResponse = {
  headers: map[string]string(name='headers'),
  body: PreviewGtmRecoveryPlanResponseBody(name='body'),
}

async function previewGtmRecoveryPlan(request: PreviewGtmRecoveryPlanRequest): PreviewGtmRecoveryPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PreviewGtmRecoveryPlan', 'POST', '/', 'json', false, 'json', request);
}

model RemovePdnsAppKeyRequest {
  appKeyId?: string(name='AppKeyId', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model RemovePdnsAppKeyResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemovePdnsAppKeyResponse = {
  headers: map[string]string(name='headers'),
  body: RemovePdnsAppKeyResponseBody(name='body'),
}

async function removePdnsAppKey(request: RemovePdnsAppKeyRequest): RemovePdnsAppKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemovePdnsAppKey', 'POST', '/', 'json', false, 'json', request);
}

model RemovePdnsUdpIpSegmentRequest {
  ip?: string(name='Ip', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model RemovePdnsUdpIpSegmentResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemovePdnsUdpIpSegmentResponse = {
  headers: map[string]string(name='headers'),
  body: RemovePdnsUdpIpSegmentResponseBody(name='body'),
}

async function removePdnsUdpIpSegment(request: RemovePdnsUdpIpSegmentRequest): RemovePdnsUdpIpSegmentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemovePdnsUdpIpSegment', 'POST', '/', 'json', false, 'json', request);
}

model ResumePdnsServiceRequest {
  lang?: string(name='Lang', position='Query'),
  serviceType?: string(name='ServiceType', position='Query'),
}

model ResumePdnsServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResumePdnsServiceResponse = {
  headers: map[string]string(name='headers'),
  body: ResumePdnsServiceResponseBody(name='body'),
}

async function resumePdnsService(request: ResumePdnsServiceRequest): ResumePdnsServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResumePdnsService', 'POST', '/', 'json', false, 'json', request);
}

model RetrieveDomainRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model RetrieveDomainResponseBody = {
  requestId?: string(name='RequestId'),
}

model RetrieveDomainResponse = {
  headers: map[string]string(name='headers'),
  body: RetrieveDomainResponseBody(name='body'),
}

async function retrieveDomain(request: RetrieveDomainRequest): RetrieveDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RetrieveDomain', 'POST', '/', 'json', false, 'json', request);
}

model RollbackGtmRecoveryPlanRequest {
  lang?: string(name='Lang', position='Query'),
  recoveryPlanId: long(name='RecoveryPlanId', position='Query'),
}

model RollbackGtmRecoveryPlanResponseBody = {
  requestId?: string(name='RequestId'),
}

model RollbackGtmRecoveryPlanResponse = {
  headers: map[string]string(name='headers'),
  body: RollbackGtmRecoveryPlanResponseBody(name='body'),
}

async function rollbackGtmRecoveryPlan(request: RollbackGtmRecoveryPlanRequest): RollbackGtmRecoveryPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RollbackGtmRecoveryPlan', 'POST', '/', 'json', false, 'json', request);
}

model SetDNSSLBStatusRequest {
  domainName?: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  line?: string(name='Line', position='Query'),
  open?: boolean(name='Open', position='Query'),
  subDomain: string(name='SubDomain', position='Query'),
  type?: string(name='Type', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SetDNSSLBStatusResponseBody = {
  open?: boolean(name='Open'),
  recordCount?: long(name='RecordCount'),
  requestId?: string(name='RequestId'),
}

model SetDNSSLBStatusResponse = {
  headers: map[string]string(name='headers'),
  body: SetDNSSLBStatusResponseBody(name='body'),
}

async function setDNSSLBStatus(request: SetDNSSLBStatusRequest): SetDNSSLBStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDNSSLBStatus', 'POST', '/', 'json', false, 'json', request);
}

model SetDnsGtmAccessModeRequest {
  accessMode: string(name='AccessMode', position='Query'),
  lang?: string(name='Lang', position='Query'),
  strategyId: string(name='StrategyId', position='Query'),
}

model SetDnsGtmAccessModeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetDnsGtmAccessModeResponse = {
  headers: map[string]string(name='headers'),
  body: SetDnsGtmAccessModeResponseBody(name='body'),
}

async function setDnsGtmAccessMode(request: SetDnsGtmAccessModeRequest): SetDnsGtmAccessModeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDnsGtmAccessMode', 'POST', '/', 'json', false, 'json', request);
}

model SetDnsGtmMonitorStatusRequest {
  lang?: string(name='Lang', position='Query'),
  monitorConfigId: string(name='MonitorConfigId', position='Query'),
  status: string(name='Status', position='Query'),
}

model SetDnsGtmMonitorStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetDnsGtmMonitorStatusResponse = {
  headers: map[string]string(name='headers'),
  body: SetDnsGtmMonitorStatusResponseBody(name='body'),
}

async function setDnsGtmMonitorStatus(request: SetDnsGtmMonitorStatusRequest): SetDnsGtmMonitorStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDnsGtmMonitorStatus', 'POST', '/', 'json', false, 'json', request);
}

model SetDomainDnssecStatusRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  status: string(name='Status', position='Query'),
}

model SetDomainDnssecStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetDomainDnssecStatusResponse = {
  headers: map[string]string(name='headers'),
  body: SetDomainDnssecStatusResponseBody(name='body'),
}

async function setDomainDnssecStatus(request: SetDomainDnssecStatusRequest): SetDomainDnssecStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDomainDnssecStatus', 'POST', '/', 'json', false, 'json', request);
}

model SetDomainRecordStatusRequest {
  lang?: string(name='Lang', position='Query'),
  recordId: string(name='RecordId', position='Query'),
  status: string(name='Status', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SetDomainRecordStatusResponseBody = {
  recordId?: string(name='RecordId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model SetDomainRecordStatusResponse = {
  headers: map[string]string(name='headers'),
  body: SetDomainRecordStatusResponseBody(name='body'),
}

async function setDomainRecordStatus(request: SetDomainRecordStatusRequest): SetDomainRecordStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDomainRecordStatus', 'POST', '/', 'json', false, 'json', request);
}

model SetGtmAccessModeRequest {
  accessMode: string(name='AccessMode', position='Query'),
  lang?: string(name='Lang', position='Query'),
  strategyId: string(name='StrategyId', position='Query'),
}

model SetGtmAccessModeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetGtmAccessModeResponse = {
  headers: map[string]string(name='headers'),
  body: SetGtmAccessModeResponseBody(name='body'),
}

async function setGtmAccessMode(request: SetGtmAccessModeRequest): SetGtmAccessModeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetGtmAccessMode', 'POST', '/', 'json', false, 'json', request);
}

model SetGtmMonitorStatusRequest {
  lang?: string(name='Lang', position='Query'),
  monitorConfigId: string(name='MonitorConfigId', position='Query'),
  status: string(name='Status', position='Query'),
}

model SetGtmMonitorStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetGtmMonitorStatusResponse = {
  headers: map[string]string(name='headers'),
  body: SetGtmMonitorStatusResponseBody(name='body'),
}

async function setGtmMonitorStatus(request: SetGtmMonitorStatusRequest): SetGtmMonitorStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetGtmMonitorStatus', 'POST', '/', 'json', false, 'json', request);
}

model SubmitIspFlushCacheTaskRequest {
  clientToken: string(name='ClientToken', description='token', position='Query'),
  domainName: string(name='DomainName', position='Query'),
  isp: [ string ](name='Isp', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model SubmitIspFlushCacheTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model SubmitIspFlushCacheTaskResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitIspFlushCacheTaskResponseBody(name='body'),
}

async function submitIspFlushCacheTask(request: SubmitIspFlushCacheTaskRequest): SubmitIspFlushCacheTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitIspFlushCacheTask', 'POST', '/', 'json', false, 'json', request);
}

model SwitchDnsGtmInstanceStrategyModeRequest {
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  strategyMode: string(name='StrategyMode', position='Query'),
}

model SwitchDnsGtmInstanceStrategyModeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SwitchDnsGtmInstanceStrategyModeResponse = {
  headers: map[string]string(name='headers'),
  body: SwitchDnsGtmInstanceStrategyModeResponseBody(name='body'),
}

async function switchDnsGtmInstanceStrategyMode(request: SwitchDnsGtmInstanceStrategyModeRequest): SwitchDnsGtmInstanceStrategyModeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SwitchDnsGtmInstanceStrategyMode', 'POST', '/', 'json', false, 'json', request);
}

model TagResourcesRequest {
  lang?: string(name='Lang', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagResources', 'POST', '/', 'json', false, 'json', request);
}

model TransferDomainRequest {
  domainNames: string(name='DomainNames', position='Query'),
  lang?: string(name='Lang', position='Query'),
  remark?: string(name='Remark', position='Query'),
  targetUserId: long(name='TargetUserId', position='Query'),
}

model TransferDomainResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: long(name='TaskId'),
}

model TransferDomainResponse = {
  headers: map[string]string(name='headers'),
  body: TransferDomainResponseBody(name='body'),
}

async function transferDomain(request: TransferDomainRequest): TransferDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TransferDomain', 'POST', '/', 'json', false, 'json', request);
}

model UnbindInstanceDomainsRequest {
  domainNames: string(name='DomainNames', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model UnbindInstanceDomainsResponseBody = {
  failedCount?: int32(name='FailedCount'),
  requestId?: string(name='RequestId'),
  successCount?: int32(name='SuccessCount'),
}

model UnbindInstanceDomainsResponse = {
  headers: map[string]string(name='headers'),
  body: UnbindInstanceDomainsResponseBody(name='body'),
}

async function unbindInstanceDomains(request: UnbindInstanceDomainsRequest): UnbindInstanceDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnbindInstanceDomains', 'POST', '/', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  all?: boolean(name='All', position='Query'),
  lang?: string(name='Lang', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tagKey?: [ string ](name='TagKey', position='Query'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UntagResources', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAppKeyStateRequest {
  appKeyId?: string(name='AppKeyId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  state?: string(name='State', position='Query'),
}

model UpdateAppKeyStateResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAppKeyStateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAppKeyStateResponseBody(name='body'),
}

async function updateAppKeyState(request: UpdateAppKeyStateRequest): UpdateAppKeyStateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAppKeyState', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCustomLineRequest {
  ipSegment?: [ 
    {
      endIp?: string(name='EndIp'),
      startIp?: string(name='StartIp'),
    }
  ](name='IpSegment', position='Query'),
  lang?: string(name='Lang', position='Query'),
  lineId: long(name='LineId', position='Query'),
  lineName?: string(name='LineName', position='Query'),
}

model UpdateCustomLineResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateCustomLineResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateCustomLineResponseBody(name='body'),
}

async function updateCustomLine(request: UpdateCustomLineRequest): UpdateCustomLineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCustomLine', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDNSSLBWeightRequest {
  lang?: string(name='Lang', position='Query'),
  recordId: string(name='RecordId', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
  weight: int32(name='Weight', position='Query'),
}

model UpdateDNSSLBWeightResponseBody = {
  recordId?: string(name='RecordId'),
  requestId?: string(name='RequestId'),
  weight?: int32(name='Weight'),
}

model UpdateDNSSLBWeightResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDNSSLBWeightResponseBody(name='body'),
}

async function updateDNSSLBWeight(request: UpdateDNSSLBWeightRequest): UpdateDNSSLBWeightResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDNSSLBWeight', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDnsCacheDomainRequest {
  cacheTtlMax?: int32(name='CacheTtlMax', minimum=30, maximum=86400, position='Query'),
  cacheTtlMin?: int32(name='CacheTtlMin', minimum=30, maximum=86400, position='Query'),
  domainName: string(name='DomainName', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  sourceDnsServer?: [ 
    {
      host?: string(name='Host'),
      port?: string(name='Port'),
    }
  ](name='SourceDnsServer', position='Query'),
  sourceEdns?: string(name='SourceEdns', position='Query'),
  sourceProtocol?: string(name='SourceProtocol', position='Query'),
}

model UpdateDnsCacheDomainResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDnsCacheDomainResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDnsCacheDomainResponseBody(name='body'),
}

async function updateDnsCacheDomain(request: UpdateDnsCacheDomainRequest): UpdateDnsCacheDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDnsCacheDomain', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDnsCacheDomainRemarkRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  remark?: string(name='Remark', position='Query'),
}

model UpdateDnsCacheDomainRemarkResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDnsCacheDomainRemarkResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDnsCacheDomainRemarkResponseBody(name='body'),
}

async function updateDnsCacheDomainRemark(request: UpdateDnsCacheDomainRemarkRequest): UpdateDnsCacheDomainRemarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDnsCacheDomainRemark', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDnsGtmAccessStrategyRequest {
  accessMode?: string(name='AccessMode', position='Query'),
  defaultAddrPool: [ 
    {
      id?: string(name='Id'),
      lbaWeight?: int32(name='LbaWeight'),
    }
  ](name='DefaultAddrPool', position='Query'),
  defaultAddrPoolType: string(name='DefaultAddrPoolType', position='Query'),
  defaultLatencyOptimization?: string(name='DefaultLatencyOptimization', position='Query'),
  defaultLbaStrategy?: string(name='DefaultLbaStrategy', position='Query'),
  defaultMaxReturnAddrNum?: int32(name='DefaultMaxReturnAddrNum', minimum=1, maximum=8, position='Query'),
  defaultMinAvailableAddrNum: int32(name='DefaultMinAvailableAddrNum', minimum=1, maximum=400, position='Query'),
  failoverAddrPool?: [ 
    {
      id?: string(name='Id'),
      lbaWeight?: int32(name='LbaWeight'),
    }
  ](name='FailoverAddrPool', position='Query'),
  failoverAddrPoolType?: string(name='FailoverAddrPoolType', position='Query'),
  failoverLatencyOptimization?: string(name='FailoverLatencyOptimization', position='Query'),
  failoverLbaStrategy?: string(name='FailoverLbaStrategy', position='Query'),
  failoverMaxReturnAddrNum?: int32(name='FailoverMaxReturnAddrNum', minimum=1, maximum=8, position='Query'),
  failoverMinAvailableAddrNum?: int32(name='FailoverMinAvailableAddrNum', minimum=1, maximum=400, position='Query'),
  lang?: string(name='Lang', position='Query'),
  lines?: string(name='Lines', position='Query'),
  strategyId: string(name='StrategyId', position='Query'),
  strategyName: string(name='StrategyName', position='Query'),
}

model UpdateDnsGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId'),
  strategyId?: string(name='StrategyId'),
}

model UpdateDnsGtmAccessStrategyResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDnsGtmAccessStrategyResponseBody(name='body'),
}

async function updateDnsGtmAccessStrategy(request: UpdateDnsGtmAccessStrategyRequest): UpdateDnsGtmAccessStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDnsGtmAccessStrategy', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDnsGtmAddressPoolRequest {
  addr: [ 
    {
      addr: string(name='Addr'),
      attributeInfo?: string(name='AttributeInfo'),
      lbaWeight?: int32(name='LbaWeight'),
      mode: string(name='Mode'),
      remark?: string(name='Remark'),
    }
  ](name='Addr', position='Query'),
  addrPoolId: string(name='AddrPoolId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  lbaStrategy: string(name='LbaStrategy', position='Query'),
  name?: string(name='Name', position='Query'),
}

model UpdateDnsGtmAddressPoolResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDnsGtmAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDnsGtmAddressPoolResponseBody(name='body'),
}

async function updateDnsGtmAddressPool(request: UpdateDnsGtmAddressPoolRequest): UpdateDnsGtmAddressPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDnsGtmAddressPool', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDnsGtmInstanceGlobalConfigRequest {
  alertConfig?: [ 
    {
      dingtalkNotice?: boolean(name='DingtalkNotice'),
      emailNotice?: boolean(name='EmailNotice'),
      noticeType?: string(name='NoticeType'),
      smsNotice?: boolean(name='SmsNotice'),
    }
  ](name='AlertConfig', position='Query'),
  alertGroup?: string(name='AlertGroup', position='Query'),
  cnameType?: string(name='CnameType', position='Query'),
  forceUpdate?: boolean(name='ForceUpdate', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  instanceName?: string(name='InstanceName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  publicCnameMode?: string(name='PublicCnameMode', position='Query'),
  publicRr?: string(name='PublicRr', position='Query'),
  publicUserDomainName?: string(name='PublicUserDomainName', position='Query'),
  publicZoneName?: string(name='PublicZoneName', position='Query'),
  ttl?: int32(name='Ttl', minimum=1, maximum=9999999, position='Query'),
}

model UpdateDnsGtmInstanceGlobalConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDnsGtmInstanceGlobalConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDnsGtmInstanceGlobalConfigResponseBody(name='body'),
}

async function updateDnsGtmInstanceGlobalConfig(request: UpdateDnsGtmInstanceGlobalConfigRequest): UpdateDnsGtmInstanceGlobalConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDnsGtmInstanceGlobalConfig', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDnsGtmMonitorRequest {
  evaluationCount?: int32(name='EvaluationCount', minimum=1, maximum=3, position='Query'),
  interval?: int32(name='Interval', minimum=15, maximum=60, position='Query'),
  ispCityNode: [ 
    {
      cityCode?: string(name='CityCode'),
      ispCode?: string(name='IspCode'),
    }
  ](name='IspCityNode', position='Query'),
  lang?: string(name='Lang', position='Query'),
  monitorConfigId: string(name='MonitorConfigId', position='Query'),
  monitorExtendInfo: string(name='MonitorExtendInfo', position='Query'),
  protocolType: string(name='ProtocolType', position='Query'),
  timeout?: int32(name='Timeout', minimum=1000, maximum=10000, position='Query'),
}

model UpdateDnsGtmMonitorResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDnsGtmMonitorResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDnsGtmMonitorResponseBody(name='body'),
}

async function updateDnsGtmMonitor(request: UpdateDnsGtmMonitorRequest): UpdateDnsGtmMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDnsGtmMonitor', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDomainGroupRequest {
  groupId: string(name='GroupId', position='Query'),
  groupName: string(name='GroupName', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model UpdateDomainGroupResponseBody = {
  groupId?: string(name='GroupId'),
  groupName?: string(name='GroupName'),
  requestId?: string(name='RequestId'),
}

model UpdateDomainGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDomainGroupResponseBody(name='body'),
}

async function updateDomainGroup(request: UpdateDomainGroupRequest): UpdateDomainGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDomainGroup', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDomainRecordRequest {
  lang?: string(name='Lang', position='Query'),
  line?: string(name='Line', position='Query'),
  priority?: long(name='Priority', minimum=1, maximum=50, position='Query'),
  rr: string(name='RR', position='Query'),
  recordId: string(name='RecordId', position='Query'),
  TTL?: long(name='TTL', minimum=1, maximum=86400, position='Query'),
  type: string(name='Type', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
  value: string(name='Value', position='Query'),
}

model UpdateDomainRecordResponseBody = {
  recordId?: string(name='RecordId'),
  requestId?: string(name='RequestId'),
}

model UpdateDomainRecordResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDomainRecordResponseBody(name='body'),
}

async function updateDomainRecord(request: UpdateDomainRecordRequest): UpdateDomainRecordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDomainRecord', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDomainRecordRemarkRequest {
  lang?: string(name='Lang', position='Query'),
  recordId: string(name='RecordId', position='Query'),
  remark?: string(name='Remark', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model UpdateDomainRecordRemarkResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDomainRecordRemarkResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDomainRecordRemarkResponseBody(name='body'),
}

async function updateDomainRecordRemark(request: UpdateDomainRecordRemarkRequest): UpdateDomainRecordRemarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDomainRecordRemark', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDomainRemarkRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  remark?: string(name='Remark', position='Query'),
}

model UpdateDomainRemarkResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDomainRemarkResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDomainRemarkResponseBody(name='body'),
}

async function updateDomainRemark(request: UpdateDomainRemarkRequest): UpdateDomainRemarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDomainRemark', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGtmAccessStrategyRequest {
  accessLines?: string(name='AccessLines', position='Query'),
  defaultAddrPoolId?: string(name='DefaultAddrPoolId', position='Query'),
  failoverAddrPoolId?: string(name='FailoverAddrPoolId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  strategyId: string(name='StrategyId', position='Query'),
  strategyName?: string(name='StrategyName', position='Query'),
}

model UpdateGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateGtmAccessStrategyResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGtmAccessStrategyResponseBody(name='body'),
}

async function updateGtmAccessStrategy(request: UpdateGtmAccessStrategyRequest): UpdateGtmAccessStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGtmAccessStrategy', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGtmAddressPoolRequest {
  addr: [ 
    {
      lbaWeight?: int32(name='LbaWeight'),
      mode?: string(name='Mode'),
      value?: string(name='Value'),
    }
  ](name='Addr', position='Query'),
  addrPoolId: string(name='AddrPoolId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  minAvailableAddrNum?: int32(name='MinAvailableAddrNum', position='Query'),
  name?: string(name='Name', position='Query'),
  type: string(name='Type', position='Query'),
}

model UpdateGtmAddressPoolResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateGtmAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGtmAddressPoolResponseBody(name='body'),
}

async function updateGtmAddressPool(request: UpdateGtmAddressPoolRequest): UpdateGtmAddressPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGtmAddressPool', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGtmInstanceGlobalConfigRequest {
  alertGroup?: string(name='AlertGroup', position='Query'),
  cnameCustomDomainName?: string(name='CnameCustomDomainName', position='Query'),
  cnameMode?: string(name='CnameMode', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  instanceName?: string(name='InstanceName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  lbaStrategy?: string(name='LbaStrategy', position='Query'),
  ttl?: int32(name='Ttl', position='Query'),
  userDomainName?: string(name='UserDomainName', position='Query'),
}

model UpdateGtmInstanceGlobalConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateGtmInstanceGlobalConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGtmInstanceGlobalConfigResponseBody(name='body'),
}

async function updateGtmInstanceGlobalConfig(request: UpdateGtmInstanceGlobalConfigRequest): UpdateGtmInstanceGlobalConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGtmInstanceGlobalConfig', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGtmMonitorRequest {
  evaluationCount?: int32(name='EvaluationCount', position='Query'),
  interval?: int32(name='Interval', position='Query'),
  ispCityNode: [ 
    {
      cityCode?: string(name='CityCode'),
      ispCode?: string(name='IspCode'),
    }
  ](name='IspCityNode', position='Query'),
  lang?: string(name='Lang', position='Query'),
  monitorConfigId: string(name='MonitorConfigId', position='Query'),
  monitorExtendInfo: string(name='MonitorExtendInfo', position='Query'),
  protocolType: string(name='ProtocolType', position='Query'),
  timeout?: int32(name='Timeout', position='Query'),
}

model UpdateGtmMonitorResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateGtmMonitorResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGtmMonitorResponseBody(name='body'),
}

async function updateGtmMonitor(request: UpdateGtmMonitorRequest): UpdateGtmMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGtmMonitor', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGtmRecoveryPlanRequest {
  faultAddrPool?: string(name='FaultAddrPool', position='Query'),
  lang?: string(name='Lang', position='Query'),
  name?: string(name='Name', position='Query'),
  recoveryPlanId: long(name='RecoveryPlanId', position='Query'),
  remark?: string(name='Remark', position='Query'),
}

model UpdateGtmRecoveryPlanResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateGtmRecoveryPlanResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGtmRecoveryPlanResponseBody(name='body'),
}

async function updateGtmRecoveryPlan(request: UpdateGtmRecoveryPlanRequest): UpdateGtmRecoveryPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGtmRecoveryPlan', 'POST', '/', 'json', false, 'json', request);
}

model UpdateIspFlushCacheInstanceConfigRequest {
  instanceId: string(name='InstanceId', position='Query'),
  instanceName: string(name='InstanceName', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model UpdateIspFlushCacheInstanceConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIspFlushCacheInstanceConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateIspFlushCacheInstanceConfigResponseBody(name='body'),
}

async function updateIspFlushCacheInstanceConfig(request: UpdateIspFlushCacheInstanceConfigRequest): UpdateIspFlushCacheInstanceConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateIspFlushCacheInstanceConfig', 'POST', '/', 'json', false, 'json', request);
}

model ValidateDnsGtmCnameRrCanUseRequest {
  cnameMode: string(name='CnameMode', position='Query'),
  cnameRr: string(name='CnameRr', position='Query'),
  cnameType: string(name='CnameType', position='Query'),
  cnameZone: string(name='CnameZone', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model ValidateDnsGtmCnameRrCanUseResponseBody = {
  requestId?: string(name='RequestId'),
}

model ValidateDnsGtmCnameRrCanUseResponse = {
  headers: map[string]string(name='headers'),
  body: ValidateDnsGtmCnameRrCanUseResponseBody(name='body'),
}

async function validateDnsGtmCnameRrCanUse(request: ValidateDnsGtmCnameRrCanUseRequest): ValidateDnsGtmCnameRrCanUseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ValidateDnsGtmCnameRrCanUse', 'POST', '/', 'json', false, 'json', request);
}

model ValidatePdnsUdpIpSegmentRequest {
  ip?: string(name='Ip', position='Query'),
  lang?: string(name='Lang', position='Query'),
}

model ValidatePdnsUdpIpSegmentResponseBody = {
  requestId?: string(name='RequestId'),
}

model ValidatePdnsUdpIpSegmentResponse = {
  headers: map[string]string(name='headers'),
  body: ValidatePdnsUdpIpSegmentResponseBody(name='body'),
}

async function validatePdnsUdpIpSegment(request: ValidatePdnsUdpIpSegmentRequest): ValidatePdnsUdpIpSegmentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ValidatePdnsUdpIpSegment', 'POST', '/', 'json', false, 'json', request);
}

