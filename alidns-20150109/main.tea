/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('alidns', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddCustomLineRequest {
  domainName?: string(name='DomainName', description='The name of the custom line.', example='example.com'),
  ipSegment?: [ 
    {
      endIp?: string(name='EndIp', description='The start IP address of the CIDR block.', example='192.0.2.254'),
      startIp?: string(name='StartIp', description='The unique ID of the custom line.', example='192.0.2.0'),
    }
  ](name='IpSegment'),
  lang?: string(name='Lang', description='The domain name for which you configure the custom line.', example='en'),
  lineName?: string(name='LineName', description='The end IP address of the CIDR block.'),
}

model AddCustomLineResponseBody = {
  lineCode?: string(name='LineCode', example='hra0yc-597'),
  lineId?: long(name='LineId', description='The ID of the request.', example='597'),
  requestId?: string(name='RequestId', description='The code of the custom line.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
}

model AddCustomLineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddCustomLineResponseBody(name='body'),
}

/**
  * The operation that you want to perform. Set the value to AddCustomLine.
  *
  * @param request AddCustomLineRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return AddCustomLineResponse
 */
async function addCustomLineWithOptions(request: AddCustomLineRequest, runtime: Util.RuntimeOptions): AddCustomLineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ipSegment)) {
    query['IpSegment'] = request.ipSegment;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lineName)) {
    query['LineName'] = request.lineName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddCustomLine',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The operation that you want to perform. Set the value to AddCustomLine.
  *
  * @param request AddCustomLineRequest
  * @return AddCustomLineResponse
 */
async function addCustomLine(request: AddCustomLineRequest): AddCustomLineResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCustomLineWithOptions(request, runtime);
}

model AddDnsCacheDomainRequest {
  cacheTtlMax?: int32(name='CacheTtlMax', description='The maximum TTL period of the cached data retrieved from the origin DNS server. Unit: seconds. Valid values: 30 to 86400.', example='86400'),
  cacheTtlMin?: int32(name='CacheTtlMin', description='The minimum time-to-live (TTL) period of the cached data retrieved from the origin Domain Name System (DNS) server. Unit: seconds. Valid values: 30 to 86400.', example='30'),
  domainName?: string(name='DomainName', description='The domain name.', example='dns.example.com'),
  instanceId?: string(name='InstanceId', description='The instance ID of the cache-accelerated domain name.', example='dns-cn-j6666'),
  lang?: string(name='Lang', description='The language.', example='en'),
  remark?: string(name='Remark', description='The remarks.', example='test'),
  sourceDnsServer?: [ 
    {
      host?: string(name='Host', description='The domain name or IP address of the origin DNS server.', example='192.0.0.0'),
      port?: string(name='Port', description='The port of the origin DNS server.', example='53'),
    }
  ](name='SourceDnsServer', description='The origin DNS servers. A maximum of 10 origin DNS servers are supported.'),
  sourceEdns?: string(name='SourceEdns', description='Specifies whether the origin DNS server supports Extension Mechanisms for DNS (EDNS). Valid values: NOT_SUPPORT and SUPPORT.', example='SUPPORT'),
  sourceProtocol?: string(name='SourceProtocol', description='The origin protocol policy. Valid values: TCP and UDP. Default value: UDP.', example='UDP'),
}

model AddDnsCacheDomainResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='B57C121B-A45F-44D8-A9B2-XXXXXXX'),
}

model AddDnsCacheDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddDnsCacheDomainResponseBody(name='body'),
}

async function addDnsCacheDomainWithOptions(request: AddDnsCacheDomainRequest, runtime: Util.RuntimeOptions): AddDnsCacheDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cacheTtlMax)) {
    query['CacheTtlMax'] = request.cacheTtlMax;
  }
  if (!Util.isUnset(request.cacheTtlMin)) {
    query['CacheTtlMin'] = request.cacheTtlMin;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.sourceDnsServer)) {
    query['SourceDnsServer'] = request.sourceDnsServer;
  }
  if (!Util.isUnset(request.sourceEdns)) {
    query['SourceEdns'] = request.sourceEdns;
  }
  if (!Util.isUnset(request.sourceProtocol)) {
    query['SourceProtocol'] = request.sourceProtocol;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDnsCacheDomain',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDnsCacheDomain(request: AddDnsCacheDomainRequest): AddDnsCacheDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDnsCacheDomainWithOptions(request, runtime);
}

model AddDnsGtmAccessStrategyRequest {
  defaultAddrPool?: [ 
    {
      id?: string(name='Id', description='The ID of the address pool in the primary address pool group.', example='pool1'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool in the primary address pool group.', example='1'),
    }
  ](name='DefaultAddrPool'),
  defaultAddrPoolType?: string(name='DefaultAddrPoolType', description='The type of the primary address pool. Valid values:

*   IPV4
*   IPV6
*   DOMAIN', example='ipv4'),
  defaultLatencyOptimization?: string(name='DefaultLatencyOptimization', description='Specifies whether to enable scheduling optimization for latency resolution for the primary address pool group. Valid values:

*   OPEN: enable
*   CLOSE: disable', example='open'),
  defaultLbaStrategy?: string(name='DefaultLbaStrategy', description='The load balancing policy of the primary address pool group. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr'),
  defaultMaxReturnAddrNum?: int32(name='DefaultMaxReturnAddrNum', description='The maximum number of addresses returned from the primary address pool group.', example='3'),
  defaultMinAvailableAddrNum?: int32(name='DefaultMinAvailableAddrNum', description='The minimum number of available addresses in the primary address pool group.', example='1'),
  failoverAddrPool?: [ 
    {
      id?: string(name='Id', description='The ID of the address pool in the secondary address pool group.', example='pool1'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool in the secondary address pool group.', example='1'),
    }
  ](name='FailoverAddrPool'),
  failoverAddrPoolType?: string(name='FailoverAddrPoolType', description='The type of the secondary address pool. Valid values:

*   IPV4
*   IPV6
*   DOMAIN', example='ipv4'),
  failoverLatencyOptimization?: string(name='FailoverLatencyOptimization', description='Specifies whether to enable scheduling optimization for latency resolution for the secondary address pool group. Valid values:

*   OPEN: enable
*   CLOSE: disable', example='open'),
  failoverLbaStrategy?: string(name='FailoverLbaStrategy', description='The load balancing policy of the secondary address pool group. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr'),
  failoverMaxReturnAddrNum?: int32(name='FailoverMaxReturnAddrNum', description='The maximum number of addresses returned from the secondary address pool group.', example='1'),
  failoverMinAvailableAddrNum?: int32(name='FailoverMinAvailableAddrNum', description='The minimum number of available addresses in the secondary address pool group.', example='1'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='instance1'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  lines?: string(name='Lines', description='The line codes of source regions. For example: `["default", "drpeng"]` indicates Global and Dr. Peng Telecom & Media Group.', example='["default", "drpeng"]'),
  strategyMode?: string(name='StrategyMode', description='The type of the access policy. Valid values:

*   GEO: geographical location-based
*   LATENCY: latency-based', example='geo'),
  strategyName?: string(name='StrategyName', description='The name of the access policy.', example='testStrategyName'),
}

model AddDnsGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy.', example='testStrategyId1'),
}

model AddDnsGtmAccessStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddDnsGtmAccessStrategyResponseBody(name='body'),
}

async function addDnsGtmAccessStrategyWithOptions(request: AddDnsGtmAccessStrategyRequest, runtime: Util.RuntimeOptions): AddDnsGtmAccessStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.defaultAddrPool)) {
    query['DefaultAddrPool'] = request.defaultAddrPool;
  }
  if (!Util.isUnset(request.defaultAddrPoolType)) {
    query['DefaultAddrPoolType'] = request.defaultAddrPoolType;
  }
  if (!Util.isUnset(request.defaultLatencyOptimization)) {
    query['DefaultLatencyOptimization'] = request.defaultLatencyOptimization;
  }
  if (!Util.isUnset(request.defaultLbaStrategy)) {
    query['DefaultLbaStrategy'] = request.defaultLbaStrategy;
  }
  if (!Util.isUnset(request.defaultMaxReturnAddrNum)) {
    query['DefaultMaxReturnAddrNum'] = request.defaultMaxReturnAddrNum;
  }
  if (!Util.isUnset(request.defaultMinAvailableAddrNum)) {
    query['DefaultMinAvailableAddrNum'] = request.defaultMinAvailableAddrNum;
  }
  if (!Util.isUnset(request.failoverAddrPool)) {
    query['FailoverAddrPool'] = request.failoverAddrPool;
  }
  if (!Util.isUnset(request.failoverAddrPoolType)) {
    query['FailoverAddrPoolType'] = request.failoverAddrPoolType;
  }
  if (!Util.isUnset(request.failoverLatencyOptimization)) {
    query['FailoverLatencyOptimization'] = request.failoverLatencyOptimization;
  }
  if (!Util.isUnset(request.failoverLbaStrategy)) {
    query['FailoverLbaStrategy'] = request.failoverLbaStrategy;
  }
  if (!Util.isUnset(request.failoverMaxReturnAddrNum)) {
    query['FailoverMaxReturnAddrNum'] = request.failoverMaxReturnAddrNum;
  }
  if (!Util.isUnset(request.failoverMinAvailableAddrNum)) {
    query['FailoverMinAvailableAddrNum'] = request.failoverMinAvailableAddrNum;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lines)) {
    query['Lines'] = request.lines;
  }
  if (!Util.isUnset(request.strategyMode)) {
    query['StrategyMode'] = request.strategyMode;
  }
  if (!Util.isUnset(request.strategyName)) {
    query['StrategyName'] = request.strategyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDnsGtmAccessStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDnsGtmAccessStrategy(request: AddDnsGtmAccessStrategyRequest): AddDnsGtmAccessStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDnsGtmAccessStrategyWithOptions(request, runtime);
}

model AddDnsGtmAddressPoolRequest {
  addr?: [ 
    {
      addr?: string(name='Addr', description='The address in the address pool.', example='1.1.1.1'),
      attributeInfo?: string(name='AttributeInfo', description='The source region of the address, in JSON-formatted string.

*   LineCode: the line code of the source region of the address.

*   lineCodeRectifyType: the rectification type of the line code. Default value: AUTO. Valid values:

    *   NO_NEED: no need for rectification.
    *   RECTIFIED: rectified.
    *   AUTO: automatic rectification.', example='default'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address.', example='1'),
      mode?: string(name='Mode', description='The response mode of address resolution. Valid values:

*   SMART: smart return.
*   ONLINE: always online.
*   OFFLINE: always offline.', example='online'),
      remark?: string(name='Remark', description='The additional information about the address.', example='test'),
    }
  ](name='Addr', description='The address pools.'),
  evaluationCount?: int32(name='EvaluationCount', description='The number of consecutive health check failures.', example='1'),
  instanceId?: string(name='InstanceId', description='The instance ID.', example='instance1'),
  interval?: int32(name='Interval', description='The health check interval. Unit: seconds.', example='1'),
  ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the city node to monitor.', example='503'),
      ispCode?: string(name='IspCode', description='The code of the Internet service provider (ISP) node to monitor.', example='465'),
    }
  ](name='IspCityNode', description='The city nodes to monitor.'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  lbaStrategy?: string(name='LbaStrategy', description='The load balancing policy of the address pool. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr'),
  monitorExtendInfo?: string(name='MonitorExtendInfo', description='The extended information. The required parameters vary based on the health check protocol.

*   HTTP or HTTPS:

    *   port: the check port.

    *   host: the host settings.

    *   path: the URL path.

    *   code: the return code greater than the specified value.

    *   failureRate: the failure rate.

    *   sni: specifies whether to enable server name indication (SNI). This parameter is available only when Health Check Protocol is set to HTTPS. Valid values:

        *   true: enables SNI.
        *   other: disables SNI.

    *   nodeType: The type of the node to monitor when the address pool type is DOMAIN. Valid values:

        *   IPV4
        *   IPV6

*   PING:

    *   failureRate: the failure rate.

    *   packetNum: the number of ping packets.

    *   packetLossRate: the loss rate of ping packets.

    *   nodeType: the type of the node to monitor when the address pool type is DOMAIN. Valid values:

        *   IPV4
        *   IPV6

*   TCP:

    *   port: the check port.

    *   failureRate: the failure rate.

    *   nodeType: the type of the node to monitor when the address pool type is DOMAIN. Valid values:

        *   IPV4
        *   IPV6', example='{\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}'),
  monitorStatus?: string(name='MonitorStatus', description='Specifies whether to enable the health check feature. If you set this parameter to OPEN, the system verifies the health check configurations. If you set this parameter to CLOSE, the system discards the health check configurations. Default value: CLOSE. Valid values:

*   OPEN: enables the health check feature.
*   CLOSE: disables the health check feature.', example='open'),
  name?: string(name='Name', description='The name of the address pool.', example='test'),
  protocolType?: string(name='ProtocolType', description='The health check protocol. Valid values:

*   HTTP
*   HTTPS
*   PING
*   TCP', example='http'),
  timeout?: int32(name='Timeout', description='The period of health check timeout. Unit: milliseconds.', example='1'),
  type?: string(name='Type', description='The type of the address pool. Valid values:

*   IPV4: IPv4 address.
*   IPV6: IPv6 address.
*   DOMAIN: domain name.', example='ipv4'),
}

model AddDnsGtmAddressPoolResponseBody = {
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.', example='testpool1'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check task.', example='test1'),
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model AddDnsGtmAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddDnsGtmAddressPoolResponseBody(name='body'),
}

async function addDnsGtmAddressPoolWithOptions(request: AddDnsGtmAddressPoolRequest, runtime: Util.RuntimeOptions): AddDnsGtmAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addr)) {
    query['Addr'] = request.addr;
  }
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispCityNode)) {
    query['IspCityNode'] = request.ispCityNode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lbaStrategy)) {
    query['LbaStrategy'] = request.lbaStrategy;
  }
  if (!Util.isUnset(request.monitorExtendInfo)) {
    query['MonitorExtendInfo'] = request.monitorExtendInfo;
  }
  if (!Util.isUnset(request.monitorStatus)) {
    query['MonitorStatus'] = request.monitorStatus;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDnsGtmAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDnsGtmAddressPool(request: AddDnsGtmAddressPoolRequest): AddDnsGtmAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDnsGtmAddressPoolWithOptions(request, runtime);
}

model AddDnsGtmMonitorRequest {
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.', example='pool1'),
  evaluationCount?: int32(name='EvaluationCount', description='The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.', example='1'),
  interval?: int32(name='Interval', description='The health check interval. Unit: seconds.', example='60'),
  ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the city where the monitored node is deployed.', example='123'),
      ispCode?: string(name='IspCode', description='The code of the Internet service provider (ISP) to which the monitored node belongs.', example='123'),
    }
  ](name='IspCityNode', description='The monitored nodes.'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  monitorExtendInfo?: string(name='MonitorExtendInfo', description='The extended information, that is, the parameters required for the protocol. Different protocols require different parameters:

*   HTTP or HTTPS:

    *   port: the port to check.

    *   host: the host configuration.

    *   path: the health check URL.

    *   code: the status code threshold. If the returned status code is greater than the specified threshold, the application service is deemed abnormal.

    *   failureRate: the failure rate.

    *   sni: specifies whether to enable Server Name Indication (SNI). This parameter is only required for the HTTPS protocol. Valid values:

        *   true: enables SNI.
        *   false: disables SNI.

    *   nodeType: the type of the monitored node when the address pool type is DOMAIN. Valid values:

        *   IPV4
        *   IPV6

*   PING:

    *   failureRate: the failure rate.

    *   packetNum: the number of ping packets.

    *   packetLossRate: the loss rate of ping packets.

    *   nodeType: the type of the monitored node when the address pool type is DOMAIN. Valid values:

        *   IPV4
        *   IPV6

*   TCP:

    *   port: the port to check.

    *   failureRate: the failure rate.

    *   nodeType: the type of the monitored node when the address pool type is DOMAIN. Valid values:

        *   IPV4
        *   IPV6', example='{\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}'),
  protocolType?: string(name='ProtocolType', description='The protocol used for the health check. Valid values:

*   HTTP
*   HTTPS
*   PING
*   TCP', example='http'),
  timeout?: int32(name='Timeout', description='The health check timeout period. Unit: milliseconds.', example='30000'),
}

model AddDnsGtmMonitorResponseBody = {
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.', example='MonitorConfigId1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model AddDnsGtmMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddDnsGtmMonitorResponseBody(name='body'),
}

/**
  * ***
  *
  * @param request AddDnsGtmMonitorRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return AddDnsGtmMonitorResponse
 */
async function addDnsGtmMonitorWithOptions(request: AddDnsGtmMonitorRequest, runtime: Util.RuntimeOptions): AddDnsGtmMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addrPoolId)) {
    query['AddrPoolId'] = request.addrPoolId;
  }
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispCityNode)) {
    query['IspCityNode'] = request.ispCityNode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.monitorExtendInfo)) {
    query['MonitorExtendInfo'] = request.monitorExtendInfo;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDnsGtmMonitor',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ***
  *
  * @param request AddDnsGtmMonitorRequest
  * @return AddDnsGtmMonitorResponse
 */
async function addDnsGtmMonitor(request: AddDnsGtmMonitorRequest): AddDnsGtmMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDnsGtmMonitorWithOptions(request, runtime);
}

model AddDomainRequest {
  domainName?: string(name='DomainName', description='The domain name to be added.'),
  groupId?: string(name='GroupId', description='The ID of the domain name group. The default value is the ID of the default domain name group.', example='2223'),
  lang?: string(name='Lang', description='The language of the domain name.', example='en'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-resourcegroupid'),
}

model AddDomainResponseBody = {
  dnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='DnsServers', description='The Domain Name System (DNS) servers that resolve the domain name.'),
  domainId?: string(name='DomainId', description='The ID of the domain name.', example='00efd71a-770e-4255-b54e-6fe5659baffe'),
  domainName?: string(name='DomainName', description='The domain name.'),
  groupId?: string(name='GroupId', description='The ID of the domain name group.', example='2223'),
  groupName?: string(name='GroupName', description='The name of the domain name group.', example='MyGroup'),
  punyCode?: string(name='PunyCode', description='The Punycode for the domain name. This parameter is returned only for Chinese domain names.', example='xn--fsq270a.com'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model AddDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddDomainResponseBody(name='body'),
}

/**
  * You can check whether a domain name is valid based on the following topic:
  * [Domain name validity](https://www.alibabacloud.com/help/zh/doc-detail/67788.htm)
  *
  * @param request AddDomainRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return AddDomainResponse
 */
async function addDomainWithOptions(request: AddDomainRequest, runtime: Util.RuntimeOptions): AddDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDomain',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can check whether a domain name is valid based on the following topic:
  * [Domain name validity](https://www.alibabacloud.com/help/zh/doc-detail/67788.htm)
  *
  * @param request AddDomainRequest
  * @return AddDomainResponse
 */
async function addDomain(request: AddDomainRequest): AddDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDomainWithOptions(request, runtime);
}

model AddDomainBackupRequest {
  domainName?: string(name='DomainName', description='The domain name for which you want to create a backup task.', example='test.aliyun.com'),
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.', example='en'),
  periodType?: string(name='PeriodType', description='The backup cycle. Valid values:

*   **DAY**: Backs up data once every day.
*   **HOUR**: Backs up data once every hour.', example='HOUR'),
}

model AddDomainBackupResponseBody = {
  domainName?: string(name='DomainName', description='The domain name.', example='test.aliyun.com'),
  periodType?: string(name='PeriodType', description='The backup cycle.', example='DAY'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='FD552816-FCC8-4832-B4A2-2DA0C2BA1688'),
}

model AddDomainBackupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddDomainBackupResponseBody(name='body'),
}

async function addDomainBackupWithOptions(request: AddDomainBackupRequest, runtime: Util.RuntimeOptions): AddDomainBackupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.periodType)) {
    query['PeriodType'] = request.periodType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDomainBackup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDomainBackup(request: AddDomainBackupRequest): AddDomainBackupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDomainBackupWithOptions(request, runtime);
}

model AddDomainGroupRequest {
  groupName?: string(name='GroupName', description='The ID of the request.', example='MyGroup'),
  lang?: string(name='Lang', description='The name of the domain name group.', example='en'),
}

model AddDomainGroupResponseBody = {
  groupId?: string(name='GroupId', description='The name of the domain name group.', example='2223'),
  groupName?: string(name='GroupName', example='NewName'),
  requestId?: string(name='RequestId', description='The ID of the domain name group.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model AddDomainGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddDomainGroupResponseBody(name='body'),
}

async function addDomainGroupWithOptions(request: AddDomainGroupRequest, runtime: Util.RuntimeOptions): AddDomainGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDomainGroup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDomainGroup(request: AddDomainGroupRequest): AddDomainGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDomainGroupWithOptions(request, runtime);
}

model AddDomainRecordRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  line?: string(name='Line', description='The resolution line. Default value: **default**.', example='default'),
  priority?: long(name='Priority', description='The priority of an MX-type DNS record. Valid values: `[1,50]`.

This parameter must be specified if the type of the DNS record is MX. A smaller value indicates a higher priority.', example='1'),
  RR?: string(name='RR', description='The host record.

For example, to resolve @.example.com, you must set RR to an at sign (@) instead of leaving it blank.', example='www'),
  TTL?: long(name='TTL', description='The TTL of the resolution. Default value: 600. Unit: seconds.', example='600'),
  type?: string(name='Type', description='The type of the DNS record. DNS record types

[dns records types](https://www.alibabacloud.com/help/en/alibaba-cloud-dns/latest/dns-record-types)', example='A'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0'),
  value?: string(name='Value', description='The value of the DNS record.', example='192.0.2.254'),
}

model AddDomainRecordResponseBody = {
  recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model AddDomainRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddDomainRecordResponseBody(name='body'),
}

async function addDomainRecordWithOptions(request: AddDomainRecordRequest, runtime: Util.RuntimeOptions): AddDomainRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.line)) {
    query['Line'] = request.line;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.RR)) {
    query['RR'] = request.RR;
  }
  if (!Util.isUnset(request.TTL)) {
    query['TTL'] = request.TTL;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDomainRecord',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDomainRecord(request: AddDomainRecordRequest): AddDomainRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDomainRecordWithOptions(request, runtime);
}

model AddGtmAccessStrategyRequest {
  accessLines?: string(name='AccessLines', description='The line codes of access regions.', example='["default", "drpeng"]'),
  defaultAddrPoolId?: string(name='DefaultAddrPoolId', description='The ID of the default address pool.', example='hrsix'),
  failoverAddrPoolId?: string(name='FailoverAddrPoolId', description='The ID of the failover address pool.

If the failover address pool is not set, pass the **Empty** value.', example='hrsyw'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance for which you want to create an access policy.', example='instance1'),
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  strategyName?: string(name='StrategyName', description='The name of the access policy.'),
}

model AddGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy created.', example='strategyid'),
}

model AddGtmAccessStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddGtmAccessStrategyResponseBody(name='body'),
}

async function addGtmAccessStrategyWithOptions(request: AddGtmAccessStrategyRequest, runtime: Util.RuntimeOptions): AddGtmAccessStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessLines)) {
    query['AccessLines'] = request.accessLines;
  }
  if (!Util.isUnset(request.defaultAddrPoolId)) {
    query['DefaultAddrPoolId'] = request.defaultAddrPoolId;
  }
  if (!Util.isUnset(request.failoverAddrPoolId)) {
    query['FailoverAddrPoolId'] = request.failoverAddrPoolId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyName)) {
    query['StrategyName'] = request.strategyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGtmAccessStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addGtmAccessStrategy(request: AddGtmAccessStrategyRequest): AddGtmAccessStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGtmAccessStrategyWithOptions(request, runtime);
}

model AddGtmAddressPoolRequest {
  addr?: [ 
    {
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address.', example='1'),
      mode?: string(name='Mode', description='The mode of the address. Valid values:

*   **SMART**: smart return
*   **ONLINE**: always online
*   **OFFLINE**: always offline', example='SMART'),
      value?: string(name='Value', description='The address.', example='1.1.1.1'),
    }
  ](name='Addr', description='The addresses in the address pool.'),
  evaluationCount?: int32(name='EvaluationCount', description='The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.', example='2'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance for which you want to create an address pool.', example='gtm-cn-xxxxxxx'),
  interval?: int32(name='Interval', description='The health check interval. Unit: seconds. Set the value to 60.', example='60'),
  ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the city where the monitored node is deployed. For more information about specific values, see the response parameters of DescribeGtmMonitorAvailableConfig.', example='546'),
      ispCode?: string(name='IspCode', description='*   The code of the Internet service provider (ISP) to which the monitored node belongs. For more information about specific values, see the response parameters of DescribeGtmMonitorAvailableConfig.
*   If the value of the GroupType parameter is BGP or OVERSEAS, IspCode is optional. The default value is 465.
*   If the value of the GroupType parameter is not BGP or OVERSEAS, IspCode is required and is used together with CityCode.', example='465'),
    }
  ](name='IspCityNode', description='The monitored nodes.'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters.', example='en'),
  minAvailableAddrNum?: int32(name='MinAvailableAddrNum', description='The minimum number of available addresses in the address pool.', example='2'),
  monitorExtendInfo?: string(name='MonitorExtendInfo', description='The extended information, that is, the parameters required for the protocol. Different protocols require different parameters:

HTTP or HTTPS:

*   port: the port to check.
*   failureRate: the failure rate.
*   code: the status code threshold. If the returned status code is greater than the specified threshold, the application service is deemed abnormal. Valid values: 400 and 500.
*   host: the host configuration.
*   path: the health check URL.

PING:

*   packetNum: the number of ping packets.
*   packetLossRate: the loss rate of ping packets.
*   failureRate: the failure rate.

TCP:

*   port: the port to check.
*   failureRate: the failure rate.', example='{"host":"aliyun.com","port":80}'),
  monitorStatus?: string(name='MonitorStatus', description='Specifies whether to enable the health check. Valid values:

*   **OPEN**: enables the health check.
*   **CLOSE**: disables the health check. This is the default value.', example='OPEN'),
  name?: string(name='Name', description='The name of the address pool that you want to create.', example='Alibaba Cloud cluster'),
  protocolType?: string(name='ProtocolType', description='The protocol used for the health check. Valid values:

*   HTTP
*   HTTPS
*   PING
*   TCP', example='HTTPS'),
  timeout?: int32(name='Timeout', description='The health check timeout period. Unit: milliseconds. Valid values: 2000, 3000, 5000, and 10000.', example='60'),
  type?: string(name='Type', description='The type of the address pool. Valid values:

*   **IP**: IPv4 address
*   **DOMAIN**: domain name', example='IP'),
}

model AddGtmAddressPoolResponseBody = {
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool created.', example='hraf3x'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.', example='hraf14'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model AddGtmAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddGtmAddressPoolResponseBody(name='body'),
}

async function addGtmAddressPoolWithOptions(request: AddGtmAddressPoolRequest, runtime: Util.RuntimeOptions): AddGtmAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addr)) {
    query['Addr'] = request.addr;
  }
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispCityNode)) {
    query['IspCityNode'] = request.ispCityNode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.minAvailableAddrNum)) {
    query['MinAvailableAddrNum'] = request.minAvailableAddrNum;
  }
  if (!Util.isUnset(request.monitorExtendInfo)) {
    query['MonitorExtendInfo'] = request.monitorExtendInfo;
  }
  if (!Util.isUnset(request.monitorStatus)) {
    query['MonitorStatus'] = request.monitorStatus;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGtmAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addGtmAddressPool(request: AddGtmAddressPoolRequest): AddGtmAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGtmAddressPoolWithOptions(request, runtime);
}

model AddGtmMonitorRequest {
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.', example='xxxx'),
  evaluationCount?: int32(name='EvaluationCount', description='The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.', example='3'),
  interval?: int32(name='Interval', description='The health check interval. Unit: seconds. Set the value to 60.', example='60'),
  ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the city where the monitored node is deployed.

For more information about specific values, see the response parameters of DescribeGtmMonitorAvailableConfig.', example='503'),
      ispCode?: string(name='IspCode', description='The code of the Internet service provider (ISP) to which the monitored node belongs. For more information about specific values, see the response parameters of DescribeGtmMonitorAvailableConfig.

*   If the value of the GroupType parameter is BGP or OVERSEAS, IspCode is optional. The default value is 465.
*   If the value of the GroupType parameter is not BGP or OVERSEAS, IspCode is required and is used together with CityCode.', example='465'),
    }
  ](name='IspCityNode', description='The monitored nodes.'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters.', example='en'),
  monitorExtendInfo?: string(name='MonitorExtendInfo', description='The extended information, that is, the parameters required for the protocol. Different protocols require different parameters:

HTTP or HTTPS:

*   port: the port to check.
*   failureRate: the failure rate.
*   code: the status code threshold. If the returned status code is greater than the specified threshold, the application service is deemed abnormal. Valid values: 400 and 500.
*   host: the host configuration.
*   path: the health check URL.

PING:

*   packetNum: the number of ping packets.
*   packetLossRate: the loss rate of ping packets.
*   failureRate: the failure rate.

TCP:

*   port: the port to check.
*   failureRate: the failure rate.', example='{\\"code\\":200,\\"path\\":\\"/index.htm\\",\\"host\\":\\"aliyun.com\\"}'),
  protocolType?: string(name='ProtocolType', description='The protocol used for the health check. Valid values:

*   HTTP
*   HTTPS
*   PING
*   TCP', example='HTTP'),
  timeout?: int32(name='Timeout', description='The health check timeout period. Unit: milliseconds. Valid values: 2000, 3000, 5000, and 10000.', example='3000'),
}

model AddGtmMonitorResponseBody = {
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.', example='1234abc'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model AddGtmMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddGtmMonitorResponseBody(name='body'),
}

async function addGtmMonitorWithOptions(request: AddGtmMonitorRequest, runtime: Util.RuntimeOptions): AddGtmMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addrPoolId)) {
    query['AddrPoolId'] = request.addrPoolId;
  }
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispCityNode)) {
    query['IspCityNode'] = request.ispCityNode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.monitorExtendInfo)) {
    query['MonitorExtendInfo'] = request.monitorExtendInfo;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGtmMonitor',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addGtmMonitor(request: AddGtmMonitorRequest): AddGtmMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGtmMonitorWithOptions(request, runtime);
}

model AddGtmRecoveryPlanRequest {
  faultAddrPool?: string(name='FaultAddrPool', description='The list of IDs of faulty address pools.', example='["hra0or"]'),
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  name?: string(name='Name', description='The name of the disaster recovery plan that you want to create.', example='name-example'),
  remark?: string(name='Remark', description='The remarks on the disaster recovery plan.', example='remark'),
}

model AddGtmRecoveryPlanResponseBody = {
  recoveryPlanId?: string(name='RecoveryPlanId', description='The ID of the disaster recovery plan created.', example='100'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model AddGtmRecoveryPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddGtmRecoveryPlanResponseBody(name='body'),
}

async function addGtmRecoveryPlanWithOptions(request: AddGtmRecoveryPlanRequest, runtime: Util.RuntimeOptions): AddGtmRecoveryPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.faultAddrPool)) {
    query['FaultAddrPool'] = request.faultAddrPool;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGtmRecoveryPlan',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addGtmRecoveryPlan(request: AddGtmRecoveryPlanRequest): AddGtmRecoveryPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGtmRecoveryPlanWithOptions(request, runtime);
}

model BindInstanceDomainsRequest {
  domainNames?: string(name='DomainNames', description='The list of domain names.

>  Separate multiple domain names with commas (,). A maximum of 100 domain names can be entered.', example='example.com,example.net'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='sdfasdf'),
  lang?: string(name='Lang', description='The language type.', example='en'),
}

model BindInstanceDomainsResponseBody = {
  failedCount?: int32(name='FailedCount', description='The number of domain names that failed to be bound.', example='0'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  successCount?: int32(name='SuccessCount', description='The number of domain names that have been bound.', example='2'),
}

model BindInstanceDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BindInstanceDomainsResponseBody(name='body'),
}

async function bindInstanceDomainsWithOptions(request: BindInstanceDomainsRequest, runtime: Util.RuntimeOptions): BindInstanceDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainNames)) {
    query['DomainNames'] = request.domainNames;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BindInstanceDomains',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function bindInstanceDomains(request: BindInstanceDomainsRequest): BindInstanceDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindInstanceDomainsWithOptions(request, runtime);
}

model ChangeDomainGroupRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  groupId?: string(name='GroupId', description='The ID of the target domain name group.', example='2223'),
  lang?: string(name='Lang', description='The language type.', example='en'),
}

model ChangeDomainGroupResponseBody = {
  groupId?: string(name='GroupId', description='The ID of the target domain name group.', example='2223'),
  groupName?: string(name='GroupName', description='The name of the target domain name group.', example='MyGroup'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model ChangeDomainGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangeDomainGroupResponseBody(name='body'),
}

async function changeDomainGroupWithOptions(request: ChangeDomainGroupRequest, runtime: Util.RuntimeOptions): ChangeDomainGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeDomainGroup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function changeDomainGroup(request: ChangeDomainGroupRequest): ChangeDomainGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeDomainGroupWithOptions(request, runtime);
}

model ChangeDomainOfDnsProductRequest {
  force?: boolean(name='Force', description='Specifies whether to force bind a domain name to the instance.', example='false'),
  instanceId?: string(name='InstanceId', description='The ID of the Alibaba Cloud DNS instance.', example='i-7sb'),
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.', example='en'),
  newDomain?: string(name='NewDomain', description='The domain name that you want to bind to the instance. If you do not specify this parameter, this operation unbinds the original domain name from the instance.', example='newdomain.com'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='1.1.1.1'),
}

model ChangeDomainOfDnsProductResponseBody = {
  originalDomain?: string(name='OriginalDomain', description='The original domain name that was bound to the instance. If the value of this parameter is empty, the instance is bound with a domain name for the first time.', example='originaldomain.com'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model ChangeDomainOfDnsProductResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangeDomainOfDnsProductResponseBody(name='body'),
}

/**
  * >  You can call this operation to change the domain name for an Alibaba Cloud DNS instance to which a domain name is bound. You can also call this operation to bind a domain name to an Alibaba Cloud DNS instance to which no domain name is bound. If you need to unbind a domain name from an Alibaba Cloud DNS instance, you can call this operation. In this case, the NewDomain parameter must not be specified.
  *
  * @param request ChangeDomainOfDnsProductRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ChangeDomainOfDnsProductResponse
 */
async function changeDomainOfDnsProductWithOptions(request: ChangeDomainOfDnsProductRequest, runtime: Util.RuntimeOptions): ChangeDomainOfDnsProductResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.newDomain)) {
    query['NewDomain'] = request.newDomain;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeDomainOfDnsProduct',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation to change the domain name for an Alibaba Cloud DNS instance to which a domain name is bound. You can also call this operation to bind a domain name to an Alibaba Cloud DNS instance to which no domain name is bound. If you need to unbind a domain name from an Alibaba Cloud DNS instance, you can call this operation. In this case, the NewDomain parameter must not be specified.
  *
  * @param request ChangeDomainOfDnsProductRequest
  * @return ChangeDomainOfDnsProductResponse
 */
async function changeDomainOfDnsProduct(request: ChangeDomainOfDnsProductRequest): ChangeDomainOfDnsProductResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeDomainOfDnsProductWithOptions(request, runtime);
}

model CopyGtmConfigRequest {
  copyType?: string(name='CopyType', description='The type of the object that you want to copy. Only the INSTANCE type is supported.', example='INSTANCE'),
  lang?: string(name='Lang', description='The language that specific response parameters will use.', example='en'),
  sourceId?: string(name='SourceId', description='The ID of the source object. Only instance IDs are supported.', example='gtm-cn-0pp1j84v60d'),
  targetId?: string(name='TargetId', description='The ID of the target object. Only instance IDs are supported.', example='gtm-cn-v0h1gaujg06'),
}

model CopyGtmConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='389DFFA3-77A5-4A9E-BF3D-147C6F98A5BA'),
}

model CopyGtmConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CopyGtmConfigResponseBody(name='body'),
}

async function copyGtmConfigWithOptions(request: CopyGtmConfigRequest, runtime: Util.RuntimeOptions): CopyGtmConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.copyType)) {
    query['CopyType'] = request.copyType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceId)) {
    query['SourceId'] = request.sourceId;
  }
  if (!Util.isUnset(request.targetId)) {
    query['TargetId'] = request.targetId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CopyGtmConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function copyGtmConfig(request: CopyGtmConfigRequest): CopyGtmConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return copyGtmConfigWithOptions(request, runtime);
}

model CreatePdnsAppKeyRequest {
  lang?: string(name='Lang'),
}

model CreatePdnsAppKeyResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreatePdnsAppKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePdnsAppKeyResponseBody(name='body'),
}

async function createPdnsAppKeyWithOptions(request: CreatePdnsAppKeyRequest, runtime: Util.RuntimeOptions): CreatePdnsAppKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePdnsAppKey',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPdnsAppKey(request: CreatePdnsAppKeyRequest): CreatePdnsAppKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPdnsAppKeyWithOptions(request, runtime);
}

model CreatePdnsUdpIpSegmentRequest {
  ip?: string(name='Ip'),
  lang?: string(name='Lang'),
  name?: string(name='Name'),
}

model CreatePdnsUdpIpSegmentResponseBody = {
  requestId?: string(name='RequestId'),
  validMessage?: string(name='ValidMessage'),
}

model CreatePdnsUdpIpSegmentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePdnsUdpIpSegmentResponseBody(name='body'),
}

async function createPdnsUdpIpSegmentWithOptions(request: CreatePdnsUdpIpSegmentRequest, runtime: Util.RuntimeOptions): CreatePdnsUdpIpSegmentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePdnsUdpIpSegment',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPdnsUdpIpSegment(request: CreatePdnsUdpIpSegmentRequest): CreatePdnsUdpIpSegmentResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPdnsUdpIpSegmentWithOptions(request, runtime);
}

model DeleteCustomLinesRequest {
  lang?: string(name='Lang', description='The language type.', example='en'),
  lineIds?: string(name='LineIds', description='The unique IDs of the custom lines that you want to delete. Separate the unique IDs with commas (,).', example='1234,1235'),
}

model DeleteCustomLinesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
}

model DeleteCustomLinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCustomLinesResponseBody(name='body'),
}

async function deleteCustomLinesWithOptions(request: DeleteCustomLinesRequest, runtime: Util.RuntimeOptions): DeleteCustomLinesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lineIds)) {
    query['LineIds'] = request.lineIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCustomLines',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCustomLines(request: DeleteCustomLinesRequest): DeleteCustomLinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCustomLinesWithOptions(request, runtime);
}

model DeleteDnsCacheDomainRequest {
  domainName?: string(name='DomainName', example='dns-example.top'),
  lang?: string(name='Lang', example='en'),
}

model DeleteDnsCacheDomainResponseBody = {
  requestId?: string(name='RequestId', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model DeleteDnsCacheDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDnsCacheDomainResponseBody(name='body'),
}

async function deleteDnsCacheDomainWithOptions(request: DeleteDnsCacheDomainRequest, runtime: Util.RuntimeOptions): DeleteDnsCacheDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDnsCacheDomain',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDnsCacheDomain(request: DeleteDnsCacheDomainRequest): DeleteDnsCacheDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDnsCacheDomainWithOptions(request, runtime);
}

model DeleteDnsGtmAccessStrategyRequest {
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy.', example='testStrategyId1'),
}

model DeleteDnsGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
}

model DeleteDnsGtmAccessStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDnsGtmAccessStrategyResponseBody(name='body'),
}

async function deleteDnsGtmAccessStrategyWithOptions(request: DeleteDnsGtmAccessStrategyRequest, runtime: Util.RuntimeOptions): DeleteDnsGtmAccessStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDnsGtmAccessStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDnsGtmAccessStrategy(request: DeleteDnsGtmAccessStrategyRequest): DeleteDnsGtmAccessStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDnsGtmAccessStrategyWithOptions(request, runtime);
}

model DeleteDnsGtmAddressPoolRequest {
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.', example='testpool1'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
}

model DeleteDnsGtmAddressPoolResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model DeleteDnsGtmAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDnsGtmAddressPoolResponseBody(name='body'),
}

async function deleteDnsGtmAddressPoolWithOptions(request: DeleteDnsGtmAddressPoolRequest, runtime: Util.RuntimeOptions): DeleteDnsGtmAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addrPoolId)) {
    query['AddrPoolId'] = request.addrPoolId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDnsGtmAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDnsGtmAddressPool(request: DeleteDnsGtmAddressPoolRequest): DeleteDnsGtmAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDnsGtmAddressPoolWithOptions(request, runtime);
}

model DeleteDomainRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  lang?: string(name='Lang', description='The language type.', example='en'),
}

model DeleteDomainResponseBody = {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model DeleteDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDomainResponseBody(name='body'),
}

/**
  * *   Given the unique nature of a HiChina domain name, you are not allowed to delete the HiChina domain name by calling the Alibaba Cloud DNS API.
  * *   If the system prompts that a domain name does not exist, it is an unregistered domain name, it does not exist under the account, or its format in the request parameters is incorrect.
  *
  * @param request DeleteDomainRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteDomainResponse
 */
async function deleteDomainWithOptions(request: DeleteDomainRequest, runtime: Util.RuntimeOptions): DeleteDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDomain',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   Given the unique nature of a HiChina domain name, you are not allowed to delete the HiChina domain name by calling the Alibaba Cloud DNS API.
  * *   If the system prompts that a domain name does not exist, it is an unregistered domain name, it does not exist under the account, or its format in the request parameters is incorrect.
  *
  * @param request DeleteDomainRequest
  * @return DeleteDomainResponse
 */
async function deleteDomain(request: DeleteDomainRequest): DeleteDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDomainWithOptions(request, runtime);
}

model DeleteDomainGroupRequest {
  groupId?: string(name='GroupId', description='The ID of the domain name group.', example='2223'),
  lang?: string(name='Lang', description='The language type.', example='en'),
}

model DeleteDomainGroupResponseBody = {
  groupName?: string(name='GroupName', description='The name of the domain name group.', example='MyGroup'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model DeleteDomainGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDomainGroupResponseBody(name='body'),
}

/**
  * >  A domain name group can be deleted only when it contains no domain names. The default group cannot be deleted.
  *
  * @param request DeleteDomainGroupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteDomainGroupResponse
 */
async function deleteDomainGroupWithOptions(request: DeleteDomainGroupRequest, runtime: Util.RuntimeOptions): DeleteDomainGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDomainGroup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  A domain name group can be deleted only when it contains no domain names. The default group cannot be deleted.
  *
  * @param request DeleteDomainGroupRequest
  * @return DeleteDomainGroupResponse
 */
async function deleteDomainGroup(request: DeleteDomainGroupRequest): DeleteDomainGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDomainGroupWithOptions(request, runtime);
}

model DeleteDomainRecordRequest {
  lang?: string(name='Lang', description='The language type.', example='en'),
  recordId?: string(name='RecordId', description='The ID of the DNS record.

This parameter is returned when you add a DNS record or when you query the list of DNS records.', example='9999985'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0'),
}

model DeleteDomainRecordResponseBody = {
  recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model DeleteDomainRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDomainRecordResponseBody(name='body'),
}

async function deleteDomainRecordWithOptions(request: DeleteDomainRecordRequest, runtime: Util.RuntimeOptions): DeleteDomainRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recordId)) {
    query['RecordId'] = request.recordId;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDomainRecord',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDomainRecord(request: DeleteDomainRecordRequest): DeleteDomainRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDomainRecordWithOptions(request, runtime);
}

model DeleteGtmAccessStrategyRequest {
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy that you want to delete.', example='hrskc'),
}

model DeleteGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
}

model DeleteGtmAccessStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGtmAccessStrategyResponseBody(name='body'),
}

async function deleteGtmAccessStrategyWithOptions(request: DeleteGtmAccessStrategyRequest, runtime: Util.RuntimeOptions): DeleteGtmAccessStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGtmAccessStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGtmAccessStrategy(request: DeleteGtmAccessStrategyRequest): DeleteGtmAccessStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGtmAccessStrategyWithOptions(request, runtime);
}

model DeleteGtmAddressPoolRequest {
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool that you want to delete.', example='1234'),
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
}

model DeleteGtmAddressPoolResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model DeleteGtmAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGtmAddressPoolResponseBody(name='body'),
}

async function deleteGtmAddressPoolWithOptions(request: DeleteGtmAddressPoolRequest, runtime: Util.RuntimeOptions): DeleteGtmAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addrPoolId)) {
    query['AddrPoolId'] = request.addrPoolId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGtmAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGtmAddressPool(request: DeleteGtmAddressPoolRequest): DeleteGtmAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGtmAddressPoolWithOptions(request, runtime);
}

model DeleteGtmRecoveryPlanRequest {
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  recoveryPlanId?: long(name='RecoveryPlanId', description='The ID of the disaster recovery plan that you want to delete.', example='100'),
}

model DeleteGtmRecoveryPlanResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model DeleteGtmRecoveryPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGtmRecoveryPlanResponseBody(name='body'),
}

async function deleteGtmRecoveryPlanWithOptions(request: DeleteGtmRecoveryPlanRequest, runtime: Util.RuntimeOptions): DeleteGtmRecoveryPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recoveryPlanId)) {
    query['RecoveryPlanId'] = request.recoveryPlanId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGtmRecoveryPlan',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGtmRecoveryPlan(request: DeleteGtmRecoveryPlanRequest): DeleteGtmRecoveryPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGtmRecoveryPlanWithOptions(request, runtime);
}

model DeleteSubDomainRecordsRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  RR?: string(name='RR', description='The host record.

For example, to resolve @.example.com, you must set RR to an at sign (@) instead of leaving it blank.', example='www'),
  type?: string(name='Type', description='The type of the DNS record. If you do not specify this parameter, all DNS record types corresponding to the subdomain name are returned.

DNS record types include **A, MX, CNAME, TXT, REDIRECT_URL, FORWORD_URL, NS, AAAA, and SRV**. The value is not case-sensitive.', example='A'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0'),
}

model DeleteSubDomainRecordsResponseBody = {
  RR?: string(name='RR', description='The host record.', example='www'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: string(name='TotalCount', description='The total number of deleted DNS records.', example='1'),
}

model DeleteSubDomainRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSubDomainRecordsResponseBody(name='body'),
}

/**
  * If the DNS records to be deleted contain locked DNS records, locked DNS records will not be deleted.
  *
  * @param request DeleteSubDomainRecordsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteSubDomainRecordsResponse
 */
async function deleteSubDomainRecordsWithOptions(request: DeleteSubDomainRecordsRequest, runtime: Util.RuntimeOptions): DeleteSubDomainRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.RR)) {
    query['RR'] = request.RR;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSubDomainRecords',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If the DNS records to be deleted contain locked DNS records, locked DNS records will not be deleted.
  *
  * @param request DeleteSubDomainRecordsRequest
  * @return DeleteSubDomainRecordsResponse
 */
async function deleteSubDomainRecords(request: DeleteSubDomainRecordsRequest): DeleteSubDomainRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSubDomainRecordsWithOptions(request, runtime);
}

model DescribeBatchResultCountRequest {
  batchType?: string(name='BatchType', description='The type of the batch operation. Valid values:

*   **DOMAIN_ADD**: adds domain names in batches.
*   **DOMAIN_DEL**: deletes domain names in batches.
*   **RR_ADD**: adds DNS records in batches.
*   **RR_DEL**: deletes DNS records in batches.', example='DOMAIN_ADD'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  taskId?: long(name='TaskId', description='The ID of the task.

If you specify TaskId, the execution result of the specified task is returned. If you do not specify TaskId, the execution result of the last task is returned.', example='123456'),
}

model DescribeBatchResultCountResponseBody = {
  batchType?: string(name='BatchType', description='The type of the batch operation.', example='DOMAIN_ADD'),
  failedCount?: int32(name='FailedCount', description='The total number of domain names or DNS records that failed to be processed.', example='2'),
  reason?: string(name='Reason', description='The cause of the execution failure.', example='failed_reason'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='75446CC1-FC9A-4595-8D96-089D73D7A63D'),
  status?: int32(name='Status', description='The status of the task. Valid values:

*   **-1**: No task for importing domain names or DNS records is submitted.
*   **0**: The task is being processed.
*   **1**: The task is completed.
*   **2**: The task failed.', example='0'),
  successCount?: int32(name='SuccessCount', description='The total number of successfully processed domain names or DNS records.', example='2'),
  taskId?: long(name='TaskId', description='The ID of the last task.', example='123456'),
  totalCount?: int32(name='TotalCount', description='The total number of DNS records that were processed in batches.', example='4'),
}

model DescribeBatchResultCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBatchResultCountResponseBody(name='body'),
}

async function describeBatchResultCountWithOptions(request: DescribeBatchResultCountRequest, runtime: Util.RuntimeOptions): DescribeBatchResultCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.batchType)) {
    query['BatchType'] = request.batchType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBatchResultCount',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBatchResultCount(request: DescribeBatchResultCountRequest): DescribeBatchResultCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBatchResultCountWithOptions(request, runtime);
}

model DescribeBatchResultDetailRequest {
  batchType?: string(name='BatchType', description='The type of the batch operation. Valid values:

*   **DOMAIN_ADD**: adds domain names in batches.
*   **DOMAIN_DEL**: deletes domain names in batches.
*   **RR_ADD**: adds DNS records in batches.
*   **RR_DEL**: deletes DNS records in batches.', example='DOMAIN_ADD'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='20'),
  status?: string(name='Status', example='SUCCESS'),
  taskId?: long(name='TaskId', description='The ID of the task.', example='83618818'),
}

model DescribeBatchResultDetailResponseBody = {
  batchResultDetails?: {
    batchResultDetail?: [ 
    {
      batchType?: string(name='BatchType', description='The type of the batch operation.', example='DOMAIN_ADD'),
      domain?: string(name='Domain', description='The domain name.', example='example.com'),
      line?: string(name='Line', description='The line code.', example='default'),
      newRr?: string(name='NewRr', description='The new host record.', example='demo-batch-7'),
      newValue?: string(name='NewValue', description='The new record value.', example='192.0.2.254'),
      operateDateStr?: string(name='OperateDateStr', description='The time when the operation was performed.', example='2019-08-22 18:02:58'),
      priority?: string(name='Priority', description='The priority of an MX-type DNS record.', example='10'),
      reason?: string(name='Reason', description='The cause of the execution failure.'),
      recordId?: string(name='RecordId', description='The ID of the DNS record.', example='123456789'),
      remark?: string(name='Remark', description='The description of the DNS record.', example='remark'),
      rr?: string(name='Rr', description='The host record.', example='www'),
      rrStatus?: string(name='RrStatus', description='The status of the DNS record.'),
      status?: boolean(name='Status', description='The execution result. Valid values:**true**: The execution succeeded.**false**: The execution failed.', example='true'),
      ttl?: string(name='Ttl', description='The TTL of the DNS record.', example='600'),
      type?: string(name='Type', description='The type of the DNS record.', example='A'),
      value?: string(name='Value', description='The value of the DNS record.', example='192.0.2.0'),
    }
  ](name='BatchResultDetail')
  }(name='BatchResultDetails', description='Detailed information about the batch operation result.'),
  pageNumber?: long(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='75446CC1-FC9A-4595-8D96-089D73D7A63D'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model DescribeBatchResultDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBatchResultDetailResponseBody(name='body'),
}

/**
  * Before you call this operation, make sure that the batch tasks have been executed.
  *
  * @param request DescribeBatchResultDetailRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeBatchResultDetailResponse
 */
async function describeBatchResultDetailWithOptions(request: DescribeBatchResultDetailRequest, runtime: Util.RuntimeOptions): DescribeBatchResultDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.batchType)) {
    query['BatchType'] = request.batchType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBatchResultDetail',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, make sure that the batch tasks have been executed.
  *
  * @param request DescribeBatchResultDetailRequest
  * @return DescribeBatchResultDetailResponse
 */
async function describeBatchResultDetail(request: DescribeBatchResultDetailRequest): DescribeBatchResultDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBatchResultDetailWithOptions(request, runtime);
}

model DescribeCustomLineRequest {
  lang?: string(name='Lang', description='The language type.', example='en'),
  lineId?: long(name='LineId', description='The unique ID of the custom line.', example='597'),
}

model DescribeCustomLineResponseBody = {
  code?: string(name='Code', description='The code of the custom line. The code is used when you configure a resolution record.', example='hra0yc-597'),
  domainName?: string(name='DomainName', description='The domain name for which the custom line is configured.', example='example.com'),
  id?: long(name='Id', description='The unique ID of the custom line.', example='597'),
  ipSegmentList?: [ 
    {
      endIp?: string(name='EndIp', description='The end IP address.', example='11.1.1.3'),
      startIp?: string(name='StartIp', description='The start IP address.', example='11.1.1.2'),
    }
  ](name='IpSegmentList', description='The list of CIDR blocks.'),
  name?: string(name='Name', description='The name of the custom line.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
}

model DescribeCustomLineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCustomLineResponseBody(name='body'),
}

async function describeCustomLineWithOptions(request: DescribeCustomLineRequest, runtime: Util.RuntimeOptions): DescribeCustomLineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lineId)) {
    query['LineId'] = request.lineId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCustomLine',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCustomLine(request: DescribeCustomLineRequest): DescribeCustomLineResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomLineWithOptions(request, runtime);
}

model DescribeCustomLinesRequest {
  domainName?: string(name='DomainName', example='example.com'),
  lang?: string(name='Lang', example='en'),
  pageNumber?: long(name='PageNumber', example='1'),
  pageSize?: long(name='PageSize', example='10'),
}

model DescribeCustomLinesResponseBody = {
  customLines?: [ 
    {
      code?: string(name='Code', example='hra0yc-597'),
      id?: long(name='Id', example='597'),
      name?: string(name='Name', example='hra0yd-597'),
    }
  ](name='CustomLines'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='10'),
  requestId?: string(name='RequestId', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
  totalItems?: int32(name='TotalItems', example='1'),
  totalPages?: int32(name='TotalPages', example='1'),
}

model DescribeCustomLinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCustomLinesResponseBody(name='body'),
}

async function describeCustomLinesWithOptions(request: DescribeCustomLinesRequest, runtime: Util.RuntimeOptions): DescribeCustomLinesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCustomLines',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCustomLines(request: DescribeCustomLinesRequest): DescribeCustomLinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomLinesWithOptions(request, runtime);
}

model DescribeDNSSLBSubDomainsRequest {
  domainName?: string(name='DomainName', description='The domain name whose subdomains you want to query.', example='example.com'),
  lang?: string(name='Lang', description='The language of the domain name.', example='en'),
  pageNumber?: long(name='PageNumber', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page. Maximum value: **100**. Default value: **20**.', example='20'),
  rr?: string(name='Rr'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client that you use to query subdomains.', example='1.1.1.1'),
}

model DescribeDNSSLBSubDomainsResponseBody = {
  pageNumber?: long(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: long(name='PageSize', description='The total number of subdomains returned.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  slbSubDomains?: {
    slbSubDomain?: [ 
    {
      lineAlgorithms?: {
        lineAlgorithm?: [ 
        {
          line?: string(name='Line'),
          open?: boolean(name='Open'),
        }
      ](name='LineAlgorithm')
      }(name='LineAlgorithms'),
      open?: boolean(name='Open', description='Indicates whether weighted round-robin is enabled for the subdomain.', example='true'),
      recordCount?: long(name='RecordCount', description='The number of DNS records added for the subdomain.', example='3'),
      subDomain?: string(name='SubDomain', description='The subdomain.', example='www.example.com'),
      type?: string(name='Type', description='The type of the DNS record that supports weighted round-robin. Valid values: A, AAAA, and CNAME.', example='A'),
    }
  ](name='SlbSubDomain')
  }(name='SlbSubDomains', description='The details of the subdomains.'),
  totalCount?: long(name='TotalCount', description='The number of domain name groups.', example='1'),
}

model DescribeDNSSLBSubDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDNSSLBSubDomainsResponseBody(name='body'),
}

async function describeDNSSLBSubDomainsWithOptions(request: DescribeDNSSLBSubDomainsRequest, runtime: Util.RuntimeOptions): DescribeDNSSLBSubDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.rr)) {
    query['Rr'] = request.rr;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDNSSLBSubDomains',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDNSSLBSubDomains(request: DescribeDNSSLBSubDomainsRequest): DescribeDNSSLBSubDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDNSSLBSubDomainsWithOptions(request, runtime);
}

model DescribeDnsCacheDomainsRequest {
  keyword?: string(name='Keyword', example='a\\"\\"'),
  lang?: string(name='Lang', example='zh'),
  pageNumber?: long(name='PageNumber', example='1'),
  pageSize?: long(name='PageSize', example='20'),
}

model DescribeDnsCacheDomainsResponseBody = {
  domains?: [ 
    {
      cacheTtlMax?: int32(name='CacheTtlMax', example='86400'),
      cacheTtlMin?: int32(name='CacheTtlMin', example='30'),
      createTime?: string(name='CreateTime', example='2022-10-17T06:13Z'),
      createTimestamp?: long(name='CreateTimestamp', example='1660546144000'),
      domainId?: string(name='DomainId', example='00efd71a-770e-4255-b54e-6fe5659baffe'),
      domainName?: string(name='DomainName', example='dns-example.top'),
      expireTime?: string(name='ExpireTime', example='2022-12-02T16:00Z'),
      expireTimestamp?: long(name='ExpireTimestamp', example='1692374400000'),
      instanceId?: string(name='InstanceId', example='i-7bg'),
      remark?: string(name='Remark', example='remark'),
      sourceDnsServers?: [ 
        {
          host?: string(name='Host', example='ns8.alidns.com'),
          port?: string(name='Port', example='53'),
        }
      ](name='SourceDnsServers'),
      sourceEdns?: string(name='SourceEdns', example='SUPPORT'),
      sourceProtocol?: string(name='SourceProtocol', example='UDP'),
      updateTime?: string(name='UpdateTime', example='2023-05-22T03:40Z'),
      updateTimestamp?: long(name='UpdateTimestamp', example='1671690491000'),
      versionCode?: string(name='VersionCode', example='ultimate'),
    }
  ](name='Domains'),
  pageNumber?: long(name='PageNumber', example='1'),
  pageSize?: long(name='PageSize', example='20'),
  requestId?: string(name='RequestId', example='57121A9C-CDCF-541F-AD39-275D89099420'),
  totalCount?: long(name='TotalCount', example='3'),
}

model DescribeDnsCacheDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsCacheDomainsResponseBody(name='body'),
}

async function describeDnsCacheDomainsWithOptions(request: DescribeDnsCacheDomainsRequest, runtime: Util.RuntimeOptions): DescribeDnsCacheDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsCacheDomains',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsCacheDomains(request: DescribeDnsCacheDomainsRequest): DescribeDnsCacheDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsCacheDomainsWithOptions(request, runtime);
}

model DescribeDnsGtmAccessStrategiesRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='instance1'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='1'),
  strategyMode?: string(name='StrategyMode', description='The type of the access policy. Valid values:

*   GEO: geographical location-based
*   LATENCY: latency-based', example='geo'),
}

model DescribeDnsGtmAccessStrategiesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0CCC9971-CEC9-4132-824B-4AE611C07623'),
  strategies?: {
    strategy?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the access policy was created.', example='2018-08-09T00:10Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates when the access policy was created.', example='1533773400000'),
      effectiveAddrPoolGroupType?: string(name='EffectiveAddrPoolGroupType', description='The type of the active address pool group. Valid values:

*   DEFAULT: the primary address pool group
*   FAILOVER: the secondary address pool group', example='default'),
      effectiveAddrPoolType?: string(name='EffectiveAddrPoolType', description='The type of the active address pools. Valid values:

*   IPV4
*   IPV6
*   DOMAIN', example='ipv4'),
      effectiveAddrPools?: {
        effectiveAddrPool?: [ 
        {
          addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='3'),
          id?: string(name='Id', description='The ID of the address pool.', example='pool1'),
          lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool.', example='1'),
          name?: string(name='Name', description='The name of the address pool.', example='test'),
        }
      ](name='EffectiveAddrPool')
      }(name='EffectiveAddrPools', description='The active address pool groups.'),
      effectiveLbaStrategy?: string(name='EffectiveLbaStrategy', description='The load balancing policy of the active address pool group. Data is returned when StrategyMode is set to GEO. Valid values: 

- ALL_RR: returns all addresses.
- RATIO: returns addresses by weight.', example='all_rr'),
      lines?: {
        line?: [ 
        {
          groupCode?: string(name='GroupCode', description='The code of the source region group.', example='default'),
          groupName?: string(name='GroupName', description='The name of the source region group.', example='global'),
          lineCode?: string(name='LineCode', description='The line code of the source region.', example='default'),
          lineName?: string(name='LineName', description='The line name of the source region.', example='global'),
        }
      ](name='Line')
      }(name='Lines', description='The source regions. Data is returned when StrategyMode is set to GEO. Valid values:'),
      strategyId?: string(name='StrategyId', description='The ID of the access policy.', example='strategyid1'),
      strategyName?: string(name='StrategyName', description='The name of the access policy.', example='strategname1'),
    }
  ](name='Strategy')
  }(name='Strategies', description='The access policies.'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned on all pages.', example='11'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='11'),
}

model DescribeDnsGtmAccessStrategiesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmAccessStrategiesResponseBody(name='body'),
}

async function describeDnsGtmAccessStrategiesWithOptions(request: DescribeDnsGtmAccessStrategiesRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmAccessStrategiesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.strategyMode)) {
    query['StrategyMode'] = request.strategyMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmAccessStrategies',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmAccessStrategies(request: DescribeDnsGtmAccessStrategiesRequest): DescribeDnsGtmAccessStrategiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmAccessStrategiesWithOptions(request, runtime);
}

model DescribeDnsGtmAccessStrategyRequest {
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy.', example='strategyId1'),
}

model DescribeDnsGtmAccessStrategyResponseBody = {
  accessMode?: string(name='AccessMode', description='The primary/secondary switchover policy for address pool groups. Valid values:

*   AUTO: performs automatic switchover between the primary and secondary address pool groups upon failures.
*   DEFAULT: uses the primary address pool group.
*   FAILOVER: uses the secondary address pool group.', example='auto'),
  createTime?: string(name='CreateTime', description='The time when the access policy was created.', example='2018-08-09T00:10Z'),
  createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates when the access policy was created.', example='1533773400000'),
  defaultAddrPoolGroupStatus?: string(name='DefaultAddrPoolGroupStatus', description='The status of the primary address pool group. Valid values:

*   AVAILABLE: available
*   NOT_AVAILABLE: unavailable', example='AVAILABLE'),
  defaultAddrPoolType?: string(name='DefaultAddrPoolType', description='The type of the primary address pool. Valid values:

*   IPV4
*   IPV6
*   DOMAIN', example='ipv4'),
  defaultAddrPools?: {
    defaultAddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='1'),
      id?: string(name='Id', description='The ID of the address pool.', example='pool1'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool.', example='1'),
      name?: string(name='Name', description='The name of the address pool.', example='test'),
    }
  ](name='DefaultAddrPool')
  }(name='DefaultAddrPools', description='The address pools in the primary address pool group.'),
  defaultAvailableAddrNum?: int32(name='DefaultAvailableAddrNum', description='The number of available addresses in the primary address pool.', example='1'),
  defaultLatencyOptimization?: string(name='DefaultLatencyOptimization', description='Indicates whether scheduling optimization for latency resolution was enabled for the primary address pool group. Valid values:

*   OPEN: enabled
*   CLOSE: disabled', example='open'),
  defaultLbaStrategy?: string(name='DefaultLbaStrategy', description='The load balancing policy of the primary address pool group. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr'),
  defaultMaxReturnAddrNum?: int32(name='DefaultMaxReturnAddrNum', description='The maximum number of addresses returned from the primary address pool group.', example='1'),
  defaultMinAvailableAddrNum?: int32(name='DefaultMinAvailableAddrNum', description='The minimum number of available addresses in the primary address pool group.', example='1'),
  effectiveAddrPoolGroupType?: string(name='EffectiveAddrPoolGroupType', description='The type of the active address pool group. Valid values:

*   DEFAULT: the primary address pool group
*   FAILOVER: the secondary address pool group', example='DEFAULT'),
  failoverAddrPoolGroupStatus?: string(name='FailoverAddrPoolGroupStatus', description='The status of the secondary address pool group. Valid values:

*   AVAILABLE: available
*   NOT_AVAILABLE: unavailable', example='AVAILABLE'),
  failoverAddrPoolType?: string(name='FailoverAddrPoolType', description='The type of the secondary address pool. Valid values:

*   IPV4
*   IPV6
*   DOMAIN', example='ipv4'),
  failoverAddrPools?: {
    failoverAddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='1'),
      id?: string(name='Id', description='The ID of the address pool.', example='pool1'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool.', example='1'),
      name?: string(name='Name', description='The name of the address pool.', example='test'),
    }
  ](name='FailoverAddrPool')
  }(name='FailoverAddrPools', description='The address pools in the secondary address pool group.'),
  failoverAvailableAddrNum?: int32(name='FailoverAvailableAddrNum', description='The number of available addresses in the secondary address pool.', example='1'),
  failoverLatencyOptimization?: string(name='FailoverLatencyOptimization', description='Indicates whether scheduling optimization for latency resolution was enabled for the secondary address pool group. Valid values:

*   OPEN: enabled
*   CLOSE: disabled', example='open'),
  failoverLbaStrategy?: string(name='FailoverLbaStrategy', description='The load balancing policy of the secondary address pool group. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr'),
  failoverMaxReturnAddrNum?: int32(name='FailoverMaxReturnAddrNum', description='The maximum number of addresses returned from the secondary address pool group.', example='1'),
  failoverMinAvailableAddrNum?: int32(name='FailoverMinAvailableAddrNum', description='The minimum number of available addresses in the secondary address pool group.', example='1'),
  instanceId?: string(name='InstanceId', description='The ID of the associated instance.', example='instance1'),
  lines?: {
    line?: [ 
    {
      groupCode?: string(name='GroupCode', description='The code of the source region group.', example='default'),
      groupName?: string(name='GroupName', description='The name of the source region group.', example='global'),
      lineCode?: string(name='LineCode', description='The line code of the source region.', example='default'),
      lineName?: string(name='LineName', description='The line name of the source region.', example='global'),
    }
  ](name='Line')
  }(name='Lines', description='The source regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BA1608CA-834C-4E63-8682-8AF0B11ED72D'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy.', example='strategyId1'),
  strategyMode?: string(name='StrategyMode', description='The type of the access policy. Valid values:

*   GEO: geographical location-based
*   LATENCY: latency-based', example='geo'),
  strategyName?: string(name='StrategyName', description='The name of the access policy.', example='strategyName1'),
}

model DescribeDnsGtmAccessStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmAccessStrategyResponseBody(name='body'),
}

async function describeDnsGtmAccessStrategyWithOptions(request: DescribeDnsGtmAccessStrategyRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmAccessStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmAccessStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmAccessStrategy(request: DescribeDnsGtmAccessStrategyRequest): DescribeDnsGtmAccessStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmAccessStrategyWithOptions(request, runtime);
}

model DescribeDnsGtmAccessStrategyAvailableConfigRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='instance1'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  strategyMode?: string(name='StrategyMode', description='The type of the access policy. Valid values:

*   GEO: geographical location-based
*   LATENCY: latency-based', example='geo'),
}

model DescribeDnsGtmAccessStrategyAvailableConfigResponseBody = {
  domainAddrPools?: {
    domainAddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='1'),
      id?: string(name='Id', description='The ID of the address pool.', example='pool1'),
      name?: string(name='Name', description='The name of the address pool.', example='testpool'),
    }
  ](name='DomainAddrPool')
  }(name='DomainAddrPools', description='The available address pools of the domain name type.'),
  ipv4AddrPools?: {
    ipv4AddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='1'),
      id?: string(name='Id', description='The ID of the address pool.', example='pool1'),
      name?: string(name='Name', description='The name of the address pool.', example='testpool'),
    }
  ](name='Ipv4AddrPool')
  }(name='Ipv4AddrPools', description='The available address pools of the IPv4 type.'),
  ipv6AddrPools?: {
    ipv6AddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='1'),
      id?: string(name='Id', description='The ID of the address pool.', example='pool1'),
      name?: string(name='Name', description='The name of the address pool.', example='testpool'),
    }
  ](name='Ipv6AddrPool')
  }(name='Ipv6AddrPools', description='The available address pools of the IPv6 type.'),
  lines?: {
    line?: [ 
    {
      fatherCode?: string(name='FatherCode', description='The parent line code of the source region. Leave it blank if no parent line exists.', example='telecom'),
      groupCode?: string(name='GroupCode', description='The line name of the source region.', example='default'),
      groupName?: string(name='GroupName', description='The name of the source region group.', example='global'),
      lineCode?: string(name='LineCode', description='The line code of the source region.', example='default'),
      lineName?: string(name='LineName', description='The code of the source region group.', example='global'),
    }
  ](name='Line')
  }(name='Lines', description='The source regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C2851BA9-CE56-49AF-8D12-4FC6A49EE688'),
  selectedDomainLines?: {
    selectedDomainLine?: [ string ](name='SelectedDomainLine')
  }(name='SelectedDomainLines'),
  selectedIpv4Lines?: {
    selectedIpv4Line?: [ string ](name='SelectedIpv4Line')
  }(name='SelectedIpv4Lines'),
  selectedIpv6Lines?: {
    selectedIpv6Line?: [ string ](name='SelectedIpv6Line')
  }(name='SelectedIpv6Lines'),
  suggestSetDefaultLine?: boolean(name='SuggestSetDefaultLine', description='Indicates whether we recommend that you set the source region to global.', example='true'),
}

model DescribeDnsGtmAccessStrategyAvailableConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody(name='body'),
}

async function describeDnsGtmAccessStrategyAvailableConfigWithOptions(request: DescribeDnsGtmAccessStrategyAvailableConfigRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmAccessStrategyAvailableConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyMode)) {
    query['StrategyMode'] = request.strategyMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmAccessStrategyAvailableConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmAccessStrategyAvailableConfig(request: DescribeDnsGtmAccessStrategyAvailableConfigRequest): DescribeDnsGtmAccessStrategyAvailableConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmAccessStrategyAvailableConfigWithOptions(request, runtime);
}

model DescribeDnsGtmAddrAttributeInfoRequest {
  addrs?: string(name='Addrs', description='The addresses whose source regions you want to query.', example='["1.1.1.1"]'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  type?: string(name='Type', description='The type of the addresses. Valid values:

*   IPV4: IPv4 address
*   IPV6: IPv6 address
*   DOMAIN: domain name', example='ipv4'),
}

model DescribeDnsGtmAddrAttributeInfoResponseBody = {
  addr?: {
    addr?: [ 
    {
      addr?: string(name='Addr', description='The address that was queried.', example='1.1.1.1'),
      attributeInfo?: {
        fatherCode?: string(name='FatherCode', description='The parent line code of the source region.', example='telecom'),
        groupCode?: string(name='GroupCode', description='The code of the source region group.', example='DEFAULT'),
        groupName?: string(name='GroupName', description='The name of the source region group.', example='Global'),
        lineCode?: string(name='LineCode', description='The line code of the source region.', example='default'),
        lineName?: string(name='LineName', description='The line name of the source region.', example='Global'),
      }(name='AttributeInfo', description='The source region of the address.'),
    }
  ](name='Addr')
  }(name='Addr', description='The addresses that were queried.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model DescribeDnsGtmAddrAttributeInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmAddrAttributeInfoResponseBody(name='body'),
}

async function describeDnsGtmAddrAttributeInfoWithOptions(request: DescribeDnsGtmAddrAttributeInfoRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmAddrAttributeInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addrs)) {
    query['Addrs'] = request.addrs;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmAddrAttributeInfo',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmAddrAttributeInfo(request: DescribeDnsGtmAddrAttributeInfoRequest): DescribeDnsGtmAddrAttributeInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmAddrAttributeInfoWithOptions(request, runtime);
}

model DescribeDnsGtmAddressPoolAvailableConfigRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='instance1'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
}

model DescribeDnsGtmAddressPoolAvailableConfigResponseBody = {
  attributeInfos?: {
    attributeInfo?: [ 
    {
      fatherCode?: string(name='FatherCode', description='The parent line code of the source region.', example='telecom'),
      groupCode?: string(name='GroupCode', description='The code of the source region group.', example='default'),
      groupName?: string(name='GroupName', description='The name of the request source group.', example='global'),
      lineCode?: string(name='LineCode', description='The line code of the source region.', example='default'),
      lineName?: string(name='LineName', description='The line name of the source region.', example='global'),
    }
  ](name='AttributeInfo')
  }(name='AttributeInfos', description='The supported source regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='199C3699-9A7B-41A1-BB5A-F1E862D3CB38'),
}

model DescribeDnsGtmAddressPoolAvailableConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmAddressPoolAvailableConfigResponseBody(name='body'),
}

async function describeDnsGtmAddressPoolAvailableConfigWithOptions(request: DescribeDnsGtmAddressPoolAvailableConfigRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmAddressPoolAvailableConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmAddressPoolAvailableConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmAddressPoolAvailableConfig(request: DescribeDnsGtmAddressPoolAvailableConfigRequest): DescribeDnsGtmAddressPoolAvailableConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmAddressPoolAvailableConfigWithOptions(request, runtime);
}

model DescribeDnsGtmAvailableAlertGroupRequest {
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
}

model DescribeDnsGtmAvailableAlertGroupResponseBody = {
  availableAlertGroup?: string(name='AvailableAlertGroup', description='The returned available alert groups.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model DescribeDnsGtmAvailableAlertGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmAvailableAlertGroupResponseBody(name='body'),
}

async function describeDnsGtmAvailableAlertGroupWithOptions(request: DescribeDnsGtmAvailableAlertGroupRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmAvailableAlertGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmAvailableAlertGroup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmAvailableAlertGroup(request: DescribeDnsGtmAvailableAlertGroupRequest): DescribeDnsGtmAvailableAlertGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmAvailableAlertGroupWithOptions(request, runtime);
}

model DescribeDnsGtmInstanceRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance about which you want to query the information.', example='instance1'),
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages. Default value: en. Valid values: en, zh, and ja.', example='en'),
}

model DescribeDnsGtmInstanceResponseBody = {
  config?: {
    alertConfig?: {
      alertConfig?: [ 
      {
        dingtalkNotice?: boolean(name='DingtalkNotice'),
        emailNotice?: boolean(name='EmailNotice', description='Indicates whether email notification is configured. Valid values:

*   true: Email notification is configured.
*   false: Email notification is not configured. null: Email notification is not configured.', example='true'),
        noticeType?: string(name='NoticeType', description='The type of the alert event. Valid values:

*   ADDR_ALERT: The address is unavailable.
*   ADDR_RESUME: The address is restored and becomes available.
*   ADDR_POOL_GROUP_UNAVAILABLE: The address pool group is unavailable.
*   ADDR_POOL_GROUP_AVAILABLE: The address pool group is restored and becomes available.
*   ACCESS_STRATEGY_POOL_GROUP_SWITCH: Switchover is triggered between the primary and secondary address pools.
*   MONITOR_NODE_IP_CHANGE: The IP address of the monitoring node has changed.', example='ADDR_ALERT'),
        smsNotice?: boolean(name='SmsNotice', description='Indicates whether SMS notification is configured. Valid values:

*   true: SMS notification is configured.
*   false: SMS notification is not configured. null: SMS notification is not configured.', example='true'),
      }
    ](name='AlertConfig')
    }(name='AlertConfig', description='The alert notification method.'),
    alertGroup?: string(name='AlertGroup', description='The name of the alert group.', example='alertgroup1'),
    cnameType?: string(name='CnameType', description='The type of the CNAME domain name that is used to access the instance. Valid value:

*   PUBLIC: The CNAME domain name is used to access the instance over the Internet.', example='public'),
    instanceName?: string(name='InstanceName', description='The name of the instance.', example='instancetest1'),
    pubicZoneName?: string(name='PubicZoneName', description='The domain name that is used to access the instance over the Internet.', example='test.rr.gtm-003.com'),
    publicCnameMode?: string(name='PublicCnameMode', description='Indicates whether a custom CNAME domain name or a CNAME domain name assigned by the system is used to access the instance over the Internet. Valid values:

*   CUSTOM: A custom CNAME domain name is used.
*   SYSTEM_ASSIGN: A CNAME domain name assigned by the system is used.', example='custom'),
    publicRr?: string(name='PublicRr', description='The hostname corresponding to the CNAME domain name that is used to access the instance over the Internet.', example='test.rr'),
    publicUserDomainName?: string(name='PublicUserDomainName', description='The service domain name that is used over the Internet.', example='example.com'),
    strategyMode?: string(name='StrategyMode', description='The type of the access policy. Valid values:

*   LATENCY: Latency-based
*   GEO: Geographical location-based', example='GEO'),
    ttl?: int32(name='Ttl', description='The global time to live (TTL).', example='1'),
  }(name='Config', description='The configurations of the instance.'),
  createTime?: string(name='CreateTime', description='The time when the instance was created.', example='2020-10-14T06:58Z'),
  createTimestamp?: long(name='CreateTimestamp', description='The UNIX timestamp that indicates when the instance was created.', example='1602656937000'),
  expireTime?: string(name='ExpireTime', description='The time when the instance expires.', example='2020-10-14T06:58Z'),
  expireTimestamp?: long(name='ExpireTimestamp', description='The UNIX timestamp that indicates when the instance expires.', example='1602656937000'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='instanceid1'),
  paymentType?: string(name='PaymentType', description='The billing method. Valid value:

*   Subscription: You can pay in advance for the use of resources.', example='Subscription'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='84314904-D047-4176-A0EC-256D7F68C7F5'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs.', example='resourcegroupid1'),
  smsQuota?: int32(name='SmsQuota', description='The total number of SMS notifications.', example='100'),
  taskQuota?: int32(name='TaskQuota', description='The total number of detection tasks.', example='100'),
  usedQuota?: {
    dingtalkUsedCount?: int32(name='DingtalkUsedCount'),
    emailUsedCount?: int32(name='EmailUsedCount', description='The total number of emails that were sent.', example='123'),
    smsUsedCount?: int32(name='SmsUsedCount', description='The total number of short messages that were sent.', example='123'),
    taskUsedCount?: int32(name='TaskUsedCount', description='The number of detection tasks that were created.', example='123'),
  }(name='UsedQuota', description='The used quota.'),
  versionCode?: string(name='VersionCode', description='The version of the instance.', example='versioncode1'),
}

model DescribeDnsGtmInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmInstanceResponseBody(name='body'),
}

async function describeDnsGtmInstanceWithOptions(request: DescribeDnsGtmInstanceRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmInstance',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmInstance(request: DescribeDnsGtmInstanceRequest): DescribeDnsGtmInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmInstanceWithOptions(request, runtime);
}

model DescribeDnsGtmInstanceAddressPoolRequest {
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.', example='testpool1'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
}

model DescribeDnsGtmInstanceAddressPoolResponseBody = {
  addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='1'),
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.', example='testpool1'),
  addrs?: {
    addr?: [ 
    {
      addr?: string(name='Addr', description='The address.', example='1.1.1.1'),
      alertStatus?: string(name='AlertStatus', description='The status of the last health check on the address. Valid values:

*   OK: No active alerts are triggered.
*   ALERT: Alerts are triggered based on the alert rules.', example='ok'),
      attributeInfo?: string(name='AttributeInfo', description='The source region of the address.

*   lineCode: the line code of the source region of the address. This parameter is deprecated, and lineCodes prevails.
*   lineName: the line name of the source region of the address. This parameter is deprecated.
*   lineCodes: the line codes of the source regions of the address.', example='"lineCode":"aliyun_r_cn-zhangjiakou", "lineName": "Alibaba Cloud_China (Zhangjiakou)", "lineCodes": \\["aliyun_r_cn-zhangjiakou"]'),
      createTime?: string(name='CreateTime', description='The time when the address was added into the address pool.', example='2017-12-28T13:08Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates the time when the address was added into the address pool.', example='1527690629357'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address.', example='1'),
      mode?: string(name='Mode', description='The mode of the address. Valid values:

*   SMART: smart return
*   ONLINE: always online
*   OFFLINE: always offline', example='online'),
      remark?: string(name='Remark', description='The description of the address.', example='test'),
      updateTime?: string(name='UpdateTime', description='The time when the address was last updated.', example='2017-12-28T13:08Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The timestamp that indicates the time when the address was last updated.', example='1527690629357'),
    }
  ](name='Addr')
  }(name='Addrs', description='The addresses in the address pool.'),
  createTime?: string(name='CreateTime', description='The time when the address pool was created.', example='2017-12-28T13:08Z'),
  createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates the time when the address pool was created.', example='1527690629357'),
  lbaStrategy?: string(name='LbaStrategy', description='The load balancing policy for the address pool. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.', example='test1'),
  monitorStatus?: string(name='MonitorStatus', description='Indicates the status of the health check. Valid values:

*   OPEN: The health check is enabled.
*   CLOSE: The health check is disabled.
*   UNCONFIGURED: The health check is not configured.', example='open'),
  name?: string(name='Name', description='The name of the address pool.', example='test'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  type?: string(name='Type', description='The type of the address pool. Valid values:

*   IPV4: IPv4 address
*   IPV6: IPv6 address
*   DOMAIN: domain name', example='ipv4'),
  updateTime?: string(name='UpdateTime', description='The time when the address pool was last updated.', example='2017-12-28T13:08Z'),
  updateTimestamp?: long(name='UpdateTimestamp', description='The timestamp that indicates the time when the address pool was last updated.', example='1527690629357'),
}

model DescribeDnsGtmInstanceAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmInstanceAddressPoolResponseBody(name='body'),
}

async function describeDnsGtmInstanceAddressPoolWithOptions(request: DescribeDnsGtmInstanceAddressPoolRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmInstanceAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addrPoolId)) {
    query['AddrPoolId'] = request.addrPoolId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmInstanceAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmInstanceAddressPool(request: DescribeDnsGtmInstanceAddressPoolRequest): DescribeDnsGtmInstanceAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmInstanceAddressPoolWithOptions(request, runtime);
}

model DescribeDnsGtmInstanceAddressPoolsRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='instance1'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 100. Default value: 20.', example='1'),
}

model DescribeDnsGtmInstanceAddressPoolsResponseBody = {
  addrPools?: {
    addrPool?: [ 
    {
      addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='1'),
      addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.', example='pool-1'),
      createTime?: string(name='CreateTime', description='The time when the address pool was created.', example='2017-12-28T13:08Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates when the address pool was created.', example='1527690629357'),
      lbaStrategy?: string(name='LbaStrategy', description='The load balancing policy of the address pool. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr'),
      monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check task.', example='abc123'),
      monitorStatus?: string(name='MonitorStatus', description='Indicates whether health checks are configured. Valid values:

*   OPEN: enabled
*   CLOSE: disabled
*   UNCONFIGURED: not configured', example='open'),
      name?: string(name='Name', description='The name of the address pool.', example='testpool'),
      type?: string(name='Type', description='The type of the address pool. Valid values:

*   IPV4: IPv4 address
*   IPV6: IPv6 address
*   DOMAIN: domain name', example='ipv4'),
      updateTime?: string(name='UpdateTime', description='The time when the address pool was updated.', example='2017-12-28T13:08Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The timestamp that indicates when the address pool was updated.', example='1527690629357'),
    }
  ](name='AddrPool')
  }(name='AddrPools', description='The returned address pools.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned on all pages.', example='1'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeDnsGtmInstanceAddressPoolsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmInstanceAddressPoolsResponseBody(name='body'),
}

async function describeDnsGtmInstanceAddressPoolsWithOptions(request: DescribeDnsGtmInstanceAddressPoolsRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmInstanceAddressPoolsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmInstanceAddressPools',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmInstanceAddressPools(request: DescribeDnsGtmInstanceAddressPoolsRequest): DescribeDnsGtmInstanceAddressPoolsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmInstanceAddressPoolsWithOptions(request, runtime);
}

model DescribeDnsGtmInstanceStatusRequest {
  instanceId?: string(name='InstanceId', description='The number of unavailable addresses.', example='instance1'),
  lang?: string(name='Lang', description='The ID of the instance.', example='en'),
}

model DescribeDnsGtmInstanceStatusResponseBody = {
  addrAvailableNum?: int32(name='AddrAvailableNum', description='The number of unavailable address pool groups.', example='1'),
  addrNotAvailableNum?: int32(name='AddrNotAvailableNum', description='The ID of the request.', example='1'),
  addrPoolGroupNotAvailableNum?: int32(name='AddrPoolGroupNotAvailableNum', description='The number of access policies switched to the secondary address pool group.', example='1'),
  requestId?: string(name='RequestId', description='The number of access policies that are unavailable in the current active address pool group.', example='389DFFA3-77A5-4A9E-BF3D-147C6F98A5BA'),
  strategyNotAvailableNum?: int32(name='StrategyNotAvailableNum', description='The number of available addresses.', example='1'),
  switchToFailoverStrategyNum?: int32(name='SwitchToFailoverStrategyNum', example='1'),
}

model DescribeDnsGtmInstanceStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmInstanceStatusResponseBody(name='body'),
}

async function describeDnsGtmInstanceStatusWithOptions(request: DescribeDnsGtmInstanceStatusRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmInstanceStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmInstanceStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmInstanceStatus(request: DescribeDnsGtmInstanceStatusRequest): DescribeDnsGtmInstanceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmInstanceStatusWithOptions(request, runtime);
}

model DescribeDnsGtmInstanceSystemCnameRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='instance1'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
}

model DescribeDnsGtmInstanceSystemCnameResponseBody = {
  requestId?: string(name='RequestId', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  systemCname?: string(name='SystemCname', description='The CNAME domain name assigned by the system.', example='gtminstance.com'),
}

model DescribeDnsGtmInstanceSystemCnameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmInstanceSystemCnameResponseBody(name='body'),
}

async function describeDnsGtmInstanceSystemCnameWithOptions(request: DescribeDnsGtmInstanceSystemCnameRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmInstanceSystemCnameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmInstanceSystemCname',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmInstanceSystemCname(request: DescribeDnsGtmInstanceSystemCnameRequest): DescribeDnsGtmInstanceSystemCnameResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmInstanceSystemCnameWithOptions(request, runtime);
}

model DescribeDnsGtmInstancesRequest {
  keyword?: string(name='Keyword', description='The keyword that you use for query. Fuzzy search by instance ID or instance name is supported.', example='instance1'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='1'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group where you want to query instances.', example='rg-testgroupid'),
}

model DescribeDnsGtmInstancesResponseBody = {
  gtmInstances?: [ 
    {
      config?: {
        alertConfig?: [ 
          {
            dingtalkNotice?: string(name='DingtalkNotice'),
            emailNotice?: string(name='EmailNotice', description='Indicates whether email notifications were configured. Valid values:

*   true: configured
*   false | null: not configured', example='true'),
            noticeType?: string(name='NoticeType', description='The type of the alert event. Valid values:

*   ADDR_ALERT: The address is unavailable.
*   ADDR_RESUME: The address is restored and becomes available.
*   ADDR_POOL_GROUP_UNAVAILABLE: The address pool group is unavailable.
*   ADDR_POOL_GROUP_AVAILABLE: The address pool group is restored and becomes available.
*   ACCESS_STRATEGY_POOL_GROUP_SWITCH: Switchover is triggered between the primary and secondary address pools.', example='ADDR_ALERT'),
            smsNotice?: string(name='SmsNotice', description='Indicates whether SMS notifications were configured. Valid values:

*   true: configured
*   false | null: not configured', example='true'),
          }
        ](name='AlertConfig', description='The alert notification methods.'),
        alertGroup?: string(name='AlertGroup', description='The alert group.', example='testgroup'),
        cnameType?: string(name='CnameType', description='The access type of the CNAME domain name.

*   The value was set to PUBLIC, which indicates Internet access.', example='public'),
        instanceName?: string(name='InstanceName', description='The name of the instance.', example='instanceTest'),
        publicCnameMode?: string(name='PublicCnameMode', description='Indicates whether a custom CNAME domain name or a CNAME domain name assigned by the system is used to access GTM over the Internet. Valid values:

*   CUSTOM: a custom CNAME domain name
*   SYSTEM_ASSIGN: a CNAME domain name assigned by the system', example='custom'),
        publicRr?: string(name='PublicRr', example='test.rr'),
        publicUserDomainName?: string(name='PublicUserDomainName', description='The website domain name that the user uses on the Internet.', example='example.com'),
        publicZoneName?: string(name='PublicZoneName', description='The domain name that is used to access GTM over the Internet.', example='test.rr.gtm-003.com'),
        strategyMode?: string(name='StrategyMode', description='The type of the access policy. Valid values:

*   LATENCY: latency-based
*   GEO: geographical location-based', example='geo'),
        ttl?: int32(name='Ttl', description='The global time to live (TTL).', example='1'),
      }(name='Config', description='The configurations of the instance.'),
      createTime?: string(name='CreateTime', description='The time when the instance was created.', example='2020-10-14T06:58Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates when the instance was created.', example='1602658709000'),
      expireTime?: string(name='ExpireTime', description='The time when the instance expires.', example='2020-10-14T06:58Z'),
      expireTimestamp?: long(name='ExpireTimestamp', description='The timestamp that indicates when the instance expires.', example='1602658709000'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='instance1'),
      paymentType?: string(name='PaymentType', description='The billing method of the instance.

*   The value is set to Subscription.', example='Subscription'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs.', example='resourceGroupid123'),
      smsQuota?: int32(name='SmsQuota', description='The total number of SMS notifications.', example='1'),
      taskQuota?: int32(name='TaskQuota', description='The total number of detection tasks.', example='1'),
      usedQuota?: {
        dingtalkUsedCount?: int32(name='DingtalkUsedCount'),
        emailUsedCount?: int32(name='EmailUsedCount', description='The total number of email notifications that were sent.', example='100'),
        smsUsedCount?: int32(name='SmsUsedCount', description='The total number of SMS notifications that were sent.', example='100'),
        taskUsedCount?: int32(name='TaskUsedCount', description='The number of detection tasks that were created.', example='100'),
      }(name='UsedQuota', description='The used quota.'),
      versionCode?: string(name='VersionCode', description='The version of the instance.', example='testVersion1'),
    }
  ](name='GtmInstances', description='The returned instances.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='84314904-D047-4176-A0EC-256D7F68C7F5'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned on all pages.', example='100'),
  totalPages?: int32(name='TotalPages', description='The total number of returned pages.', example='123'),
}

model DescribeDnsGtmInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmInstancesResponseBody(name='body'),
}

async function describeDnsGtmInstancesWithOptions(request: DescribeDnsGtmInstancesRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmInstances',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmInstances(request: DescribeDnsGtmInstancesRequest): DescribeDnsGtmInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmInstancesWithOptions(request, runtime);
}

model DescribeDnsGtmLogsRequest {
  endTimestamp?: long(name='EndTimestamp', description='The timestamp that specifies the end of the time range to query.', example='1516779348000'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='instance1'),
  keyword?: string(name='Keyword', description='The keyword for searches in "%KeyWord%" mode. The value is not case-sensitive.', example='demo'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 100. Default value: 20.', example='1'),
  startTimestamp?: long(name='StartTimestamp', description='The timestamp that specifies the beginning of the time range to query.', example='1516779348000'),
}

model DescribeDnsGtmLogsResponseBody = {
  logs?: {
    log?: [ 
    {
      content?: string(name='Content', description='The formatted message content.', example='addtest-pool-1'),
      entityId?: string(name='EntityId', description='The ID of the object on which the operation was performed.', example='121212'),
      entityName?: string(name='EntityName', description='The name of the object on which the operation was performed.', example='test-pool-1'),
      entityType?: string(name='EntityType', description='The type of the object on which the operation was performed.'),
      id?: long(name='Id', description='The ID of the record.', example='6726'),
      operAction?: string(name='OperAction', description='The operation performed.'),
      operTime?: string(name='OperTime', description='The time when the operation was performed.', example='2018-01-24T07:35Z'),
      operTimestamp?: long(name='OperTimestamp', description='The timestamp of the operation.', example='1516779348000'),
    }
  ](name='Log')
  }(name='Logs', description='The returned logs.'),
  pageNumber?: int32(name='PageNumber', description='The number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='50C60A29-2E93-425A-ABA8-068686E28873'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned on all pages.', example='1'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeDnsGtmLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmLogsResponseBody(name='body'),
}

async function describeDnsGtmLogsWithOptions(request: DescribeDnsGtmLogsRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTimestamp)) {
    query['EndTimestamp'] = request.endTimestamp;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTimestamp)) {
    query['StartTimestamp'] = request.startTimestamp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmLogs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmLogs(request: DescribeDnsGtmLogsRequest): DescribeDnsGtmLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmLogsWithOptions(request, runtime);
}

model DescribeDnsGtmMonitorAvailableConfigRequest {
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
}

model DescribeDnsGtmMonitorAvailableConfigResponseBody = {
  domainIpv4IspCityNodes?: {
    domainIpv4IspCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the city where the monitored node is deployed.', example='503'),
      cityName?: string(name='CityName', description='The display name of the city where the monitored node is deployed.', example='Zhangjiakou'),
      defaultSelected?: boolean(name='DefaultSelected', description='Indicates whether the monitored node is selected for the health check by default.', example='true'),
      groupName?: string(name='GroupName', description='The name of the group to which the monitored node belongs.', example='BGP Nodes'),
      groupType?: string(name='GroupType', description='The type of the group to which the monitored node belongs. Valid values:

*   BGP: BGP nodes
*   OVERSEAS: nodes outside the Chinese mainland
*   ISP: ISP nodes', example='BGP'),
      ips?: {
        ip?: [ string ](name='Ip')
      }(name='Ips'),
      ispCode?: string(name='IspCode', description='The code of the ISP to which the monitored node belongs.', example='465'),
      ispName?: string(name='IspName', description='The display name of the ISP to which the monitored node belongs.', example='Alibaba'),
    }
  ](name='DomainIpv4IspCityNode')
  }(name='DomainIpv4IspCityNodes', description='The monitored nodes that can be used to perform health checks on address pools that contain public domain names that are resolved to IPv4 addresses.'),
  domainIpv6IspCityNodes?: {
    domainIpv6IspCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the city where the monitored node is deployed.', example='503'),
      cityName?: string(name='CityName', description='The display name of the city where the monitored node is deployed.', example='Zhangjiakou'),
      defaultSelected?: boolean(name='DefaultSelected', description='Indicates whether the monitored node is selected for the health check by default.', example='false'),
      groupName?: string(name='GroupName', description='The name of the group to which the monitored node belongs.', example='BGP Nodes'),
      groupType?: string(name='GroupType', description='The type of the group to which the monitored node belongs. Valid values:

*   BGP: BGP nodes
*   OVERSEAS: nodes outside the Chinese mainland
*   ISP: ISP nodes', example='BGP'),
      ips?: {
        ip?: [ string ](name='ip')
      }(name='Ips'),
      ispCode?: string(name='IspCode', description='The code of the ISP to which the monitored node belongs.', example='465'),
      ispName?: string(name='IspName', description='The display name of the ISP to which the monitored node belongs.', example='Alibaba'),
    }
  ](name='DomainIpv6IspCityNode')
  }(name='DomainIpv6IspCityNodes', description='The monitored nodes that can be used to perform health checks on address pools that contain public domain names that are resolved to IPv6 addresses.'),
  ipv4IspCityNodes?: {
    ipv4IspCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the city where the monitored node is deployed.', example='503'),
      cityName?: string(name='CityName', description='The display name of the city where the monitored node is deployed.', example='Zhangjiakou'),
      defaultSelected?: boolean(name='DefaultSelected', description='Indicates whether the monitored node is selected for the health check by default.', example='true'),
      groupName?: string(name='GroupName', description='The name of the group to which the monitored node belongs.', example='BGP Nodes'),
      groupType?: string(name='GroupType', description='The type of the group to which the monitored node belongs. Valid values:

*   BGP: Border Gateway Protocol (BGP) nodes
*   OVERSEAS: nodes outside the Chinese mainland
*   ISP: ISP nodes', example='BGP'),
      ips?: {
        ip?: [ string ](name='Ip')
      }(name='Ips'),
      ispCode?: string(name='IspCode', description='The code of the Internet service provider (ISP) to which the monitored node belongs.', example='465'),
      ispName?: string(name='IspName', description='The display name of the ISP to which the monitored node belongs.', example='Alibaba'),
    }
  ](name='Ipv4IspCityNode')
  }(name='Ipv4IspCityNodes', description='The monitored nodes that can be used to perform health checks on address pools that contain public IPv4 addresses.'),
  ipv6IspCityNodes?: {
    ipv6IspCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the city where the monitored node is deployed.', example='503'),
      cityName?: string(name='CityName', description='The display name of the city where the monitored node is deployed.', example='Zhangjiakou'),
      defaultSelected?: boolean(name='DefaultSelected', description='Indicates whether the monitored node is selected for the health check by default.', example='true'),
      groupName?: string(name='GroupName', description='The name of the group to which the monitored node belongs.', example='BGP Nodes'),
      groupType?: string(name='GroupType', description='The type of the group to which the monitored node belongs. Valid values:

*   BGP: BGP nodes
*   OVERSEAS: nodes outside the Chinese mainland
*   ISP: ISP nodes', example='BGP'),
      ips?: {
        ip?: [ string ](name='Ip')
      }(name='Ips'),
      ispCode?: string(name='IspCode', description='The code of the ISP to which the monitored node belongs.', example='465'),
      ispName?: string(name='IspName', description='The display name of the ISP to which the monitored node belongs.', example='Alibaba'),
    }
  ](name='Ipv6IspCityNode')
  }(name='Ipv6IspCityNodes', description='The monitored nodes that can be used to perform health checks on address pools that contain public IPv6 addresses.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model DescribeDnsGtmMonitorAvailableConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmMonitorAvailableConfigResponseBody(name='body'),
}

async function describeDnsGtmMonitorAvailableConfigWithOptions(request: DescribeDnsGtmMonitorAvailableConfigRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmMonitorAvailableConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmMonitorAvailableConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmMonitorAvailableConfig(request: DescribeDnsGtmMonitorAvailableConfigRequest): DescribeDnsGtmMonitorAvailableConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmMonitorAvailableConfigWithOptions(request, runtime);
}

model DescribeDnsGtmMonitorConfigRequest {
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check task.', example='MonitorConfigId1'),
}

model DescribeDnsGtmMonitorConfigResponseBody = {
  createTime?: string(name='CreateTime', description='The time when the health check task was created.', example='2017-12-28T13:08Z'),
  createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates when the health check task was created.', example='1527690629357'),
  evaluationCount?: int32(name='EvaluationCount', description='The number of consecutive times of failed health check attempts.', example='1'),
  interval?: int32(name='Interval', description='The interval at which the health check task is executed. Unit: seconds.', example='1'),
  ispCityNodes?: {
    ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the monitored city node.', example='572'),
      cityName?: string(name='CityName', description='The display name of the monitored city node.', example='Qingdao'),
      countryCode?: string(name='CountryCode', description='The code of the country or region.', example='001'),
      countryName?: string(name='CountryName', description='The display name of the country or region.', example='China'),
      ispCode?: string(name='IspCode', description='The code of the monitored Internet service provider (ISP) node.', example='123'),
      ispName?: string(name='IspName', description='The name of the ISP.', example='Alibaba'),
    }
  ](name='IspCityNode')
  }(name='IspCityNodes', description='The monitored node.'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check task.', example='MonitorConfigId1'),
  monitorExtendInfo?: string(name='MonitorExtendInfo', description='The extended information. The following parameters are required for different health check protocols:

*   HTTP or HTTPS:

    *   port: the check port.

    *   host: the host settings.

    *   path: the URL path.

    *   code: the return code greater than the specified value.

    *   failureRate: the failure rate.

    *   sni: specifies whether to enable server name indication (SNI). This parameter is used only for the HTTPS protocol. Valid values:

        *   true: enable SNI.
        *   false: disable SNI.

    *   nodeType: the type of the node to monitor when the address pool type is DOMAIN. Valid values:

        *   IPV4
        *   IPV6

*   PING:

    *   failureRate: the failure rate.

    *   packetNum: the number of ping packets.

    *   packetLossRate: the loss rate of ping packets.

    *   nodeType: the type of the node to monitor when the address pool type is DOMAIN. Valid values:

        *   IPV4
        *   IPV6

*   TCP:

    *   port: the check port.

    *   failureRate: the failure rate.

    *   nodeType: the type of the node to monitor when the address pool type is DOMAIN. Valid values:

        *   IPV4
        *   IPV6', example='{\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}'),
  protocolType?: string(name='ProtocolType', description='The health check protocol. Valid values:

*   HTTP
*   HTTPS
*   PING
*   TCP', example='http'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  timeout?: int32(name='Timeout', description='The timeout period. Unit: milliseconds.', example='3000'),
  updateTime?: string(name='UpdateTime', description='The time when the information about the health check task was updated.', example='2018-01-03T08:57Z'),
  updateTimestamp?: long(name='UpdateTimestamp', description='The timestamp that indicates when the information about the health check task was updated.', example='1527690629357'),
}

model DescribeDnsGtmMonitorConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmMonitorConfigResponseBody(name='body'),
}

async function describeDnsGtmMonitorConfigWithOptions(request: DescribeDnsGtmMonitorConfigRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmMonitorConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.monitorConfigId)) {
    query['MonitorConfigId'] = request.monitorConfigId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmMonitorConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmMonitorConfig(request: DescribeDnsGtmMonitorConfigRequest): DescribeDnsGtmMonitorConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmMonitorConfigWithOptions(request, runtime);
}

model DescribeDnsProductInstanceRequest {
  instanceId?: string(name='InstanceId', description='The instance ID. You can call the **DescribeDomainInfo** operation to obtain the instance ID.', example='i-8fxxxx'),
  lang?: string(name='Lang', description='The language.', example='en'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0'),
}

model DescribeDnsProductInstanceResponseBody = {
  autoRenewal?: boolean(name='AutoRenewal'),
  bindCount?: long(name='BindCount', description='The number of times that you can change the domain names that are bound to the paid Alibaba Cloud DNS instance. This parameter applies to Alibaba Cloud DNS instances of the custom edition.', example='3'),
  bindDomainCount?: long(name='BindDomainCount', description='The number of domain names that can be bound to the paid Alibaba Cloud DNS instance. This parameter applies to Alibaba Cloud DNS instances of Personal Edition, Enterprise Standard Edition, and Enterprise Ultimate Edition.', example='5'),
  bindDomainUsedCount?: long(name='BindDomainUsedCount', description='The number of domain names that are bound to the paid Alibaba Cloud DNS instance. This parameter applies to Alibaba Cloud DNS instances of Personal Edition, Enterprise Standard Edition, and Enterprise Ultimate Edition.', example='3'),
  bindUsedCount?: long(name='BindUsedCount', description='The number of times that you have changed the domain names that are bound to the paid Alibaba Cloud DNS instance. This parameter applies to Alibaba Cloud DNS instances of the custom edition.', example='1'),
  DDosDefendFlow?: long(name='DDosDefendFlow', description='The DDoS protection traffic. Unit: GB.', example='50'),
  DDosDefendQuery?: long(name='DDosDefendQuery', description='The DDoS protection frequency. Unit: 10,000 QPS. This parameter applies to Alibaba Cloud DNS instances of the custom edition.', example='50'),
  dnsSLBCount?: long(name='DnsSLBCount', description='The maximum number of IP addresses that are used for load balancing in a single line of a domain name.', example='15'),
  dnsSecurity?: string(name='DnsSecurity', description='The DNS protection level. Valid values:

*   **no**: DNS protection is not provided.
*   **basic**: Basic DNS attack defense is provided.
*   **advanced**: Advanced DNS attack defense is provided.', example='advanced'),
  dnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='DnsServers', description='The DNS servers configured for the domain names.'),
  domain?: string(name='Domain', description='The domain name that is bound to the paid instance.

If no value is returned for this parameter, no domain name is bound to the paid instance.', example='example.com'),
  domainType?: string(name='DomainType', description='The type of the instance. Valid values:

*   PUBLIC: authoritative domain name
*   CACHE: cache-accelerated domain name', example='PUBLIC'),
  endTime?: string(name='EndTime', description='The time when the instance expired. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2015-12-12T09:23Z'),
  endTimestamp?: long(name='EndTimestamp', description='The time when the instance expired. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1474335170000'),
  gslb?: boolean(name='Gslb', description='Indicates whether global server load balancing (GSLB) is supported.', example='true'),
  ISPLines?: string(name='ISPLines', description='The Internet service provider (ISP) lines for DNS resolution.'),
  ISPRegionLines?: string(name='ISPRegionLines', description='The regional ISP lines for DNS resolution.'),
  inBlackHole?: boolean(name='InBlackHole', description='Indicates whether the Domain Name System (DNS) servers stopped responding to all requests sent to the domain names.', example='false'),
  inClean?: boolean(name='InClean', description='Indicates whether the DNS servers stopped responding to abnormal requests sent to the domain names.', example='false'),
  instanceId?: string(name='InstanceId', description='The ID of the Alibaba Cloud DNS instance.', example='i-8fxxx'),
  monitorFrequency?: long(name='MonitorFrequency', description='The interval at which the instance is monitored. Unit: minutes.', example='50'),
  monitorNodeCount?: long(name='MonitorNodeCount', description='The number of monitoring nodes.', example='5'),
  monitorTaskCount?: long(name='MonitorTaskCount', description='The number of monitoring tasks.', example='2'),
  overseaDDosDefendFlow?: long(name='OverseaDDosDefendFlow', description='The DDoS protection traffic outside the Chinese mainland. Unit: GB.', example='1'),
  overseaLine?: string(name='OverseaLine', description='The line outside the Chinese mainland.'),
  paymentType?: string(name='PaymentType', description='The billing method.', example='Subscription'),
  regionLines?: boolean(name='RegionLines', description='Indicates whether regional lines are supported.', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  searchEngineLines?: string(name='SearchEngineLines', description='The search engine lines for DNS resolution.'),
  startTime?: string(name='StartTime', description='The time when the instance was purchased. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2015-12-12T09:23Z'),
  startTimestamp?: long(name='StartTimestamp', description='The time when the instance was purchased. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1474335170000'),
  subDomainLevel?: long(name='SubDomainLevel', description='The number of subdomain name levels.', example='6'),
  TTLMinValue?: long(name='TTLMinValue', description='The minimum time-to-live (TTL) period. Unit: seconds.', example='10'),
  URLForwardCount?: long(name='URLForwardCount', description='The number of the forwarded URLs.', example='20'),
  versionCode?: string(name='VersionCode', description='The version code of Alibaba Cloud DNS.', example='version1'),
  versionName?: string(name='VersionName', description='The edition of Alibaba Cloud DNS.'),
}

model DescribeDnsProductInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsProductInstanceResponseBody(name='body'),
}

async function describeDnsProductInstanceWithOptions(request: DescribeDnsProductInstanceRequest, runtime: Util.RuntimeOptions): DescribeDnsProductInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsProductInstance',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsProductInstance(request: DescribeDnsProductInstanceRequest): DescribeDnsProductInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsProductInstanceWithOptions(request, runtime);
}

model DescribeDnsProductInstancesRequest {
  direction?: string(name='Direction', example='DESC'),
  domainType?: string(name='DomainType', example='PUBLIC'),
  lang?: string(name='Lang', description='The version code of the Alibaba Cloud DNS instance.', example='en'),
  orderBy?: string(name='OrderBy', example='createDate'),
  pageNumber?: long(name='PageNumber', description='The number of entries returned per page.', example='1'),
  pageSize?: long(name='PageSize', description='The ID of the request.', example='20'),
  userClientIp?: string(name='UserClientIp', description='The total number of domain names.', example='192.0.2.0'),
  versionCode?: string(name='VersionCode', description='The page number of the returned page.', example='version1'),
}

model DescribeDnsProductInstancesResponseBody = {
  dnsProducts?: {
    dnsProduct?: [ 
    {
      autoRenewal?: boolean(name='AutoRenewal'),
      bindCount?: long(name='BindCount', description='The time when the DNS instance was purchased.', example='3'),
      bindDomainCount?: long(name='BindDomainCount', description='Indicates whether regional lines were allowed.', example='5'),
      bindDomainUsedCount?: long(name='BindDomainUsedCount', description='The list of search engine lines.', example='3'),
      bindUsedCount?: long(name='BindUsedCount', description='The URL forwarding quantity.', example='1'),
      DDosDefendFlow?: long(name='DDosDefendFlow', description='The time at which the instance expired.', example='50'),
      DDosDefendQuery?: long(name='DDosDefendQuery', description='The number of subdomain name levels.', example='50'),
      dnsSLBCount?: long(name='DnsSLBCount', example='15'),
      dnsSecurity?: string(name='DnsSecurity', example='no'),
      domain?: string(name='Domain', description='The UNIX timestamp representing when the DNS instance was purchased.', example='example.com'),
      endTime?: string(name='EndTime', description='Indicates whether global server load balancing (GSLB) was allowed.', example='2015-12-12T09:23Z'),
      endTimestamp?: long(name='EndTimestamp', description='The number of times you have changed domain names that are bound to the DNS instance. It can be specified by the user who uses Alibaba Cloud DNS of the custom version.', example='1474335170000'),
      gslb?: boolean(name='Gslb', example='true'),
      ISPLines?: string(name='ISPLines', description='The version code of the Alibaba Cloud DNS instance.'),
      ISPRegionLines?: string(name='ISPRegionLines', description='The UNIX timestamp representing the expiration time of the instance.'),
      inBlackHole?: boolean(name='InBlackHole', description='The list of ISP lines.', example='false'),
      inClean?: boolean(name='InClean', description='The ID of the Alibaba Cloud DNS instance.', example='false'),
      instanceId?: string(name='InstanceId', description='The number of domain names that can be bound to the DNS instance.', example='i-8fj'),
      monitorFrequency?: long(name='MonitorFrequency', description='The DDoS protection frequency. Unit: 10,000 QPS.', example='50'),
      monitorNodeCount?: long(name='MonitorNodeCount', description='The minimum TTL. Unit: seconds.', example='5'),
      monitorTaskCount?: long(name='MonitorTaskCount', description='Indicates whether the request for domain name resolution was being cleared.', example='2'),
      overseaDDosDefendFlow?: long(name='OverseaDDosDefendFlow', description='The number of IP addresses supported by a domain name or line.', example='1'),
      overseaLine?: string(name='OverseaLine', description='The list of ISP line subdivisions.'),
      paymentType?: string(name='PaymentType', example='Subscription'),
      regionLines?: boolean(name='RegionLines', example='true'),
      searchEngineLines?: string(name='SearchEngineLines', description='The number of monitoring tasks.'),
      startTime?: string(name='StartTime', description='The DNS security policy. Valid values:

*   **no**: not required.
*   **basic**: anti-DDoS basic.
*   **advanced**: anti-DDoS advanced.', example='2015-12-12T09:23Z'),
      startTimestamp?: long(name='StartTimestamp', description='The number of times you can change domain names that are bound to the DNS instance. It can be specified by the user who uses Alibaba Cloud DNS of the custom version.', example='1474335170000'),
      subDomainLevel?: long(name='SubDomainLevel', description='DDoS protection traffic outside China. Unit: GB.', example='6'),
      TTLMinValue?: long(name='TTLMinValue', description='The version name of the Alibaba Cloud DNS instance.', example='10'),
      URLForwardCount?: long(name='URLForwardCount', description='The DDoS protection traffic. Unit: GB.', example='20'),
      versionCode?: string(name='VersionCode', description='The monitoring frequency. Unit: minutes.', example='version1'),
      versionName?: string(name='VersionName', description='The bound domain name.'),
    }
  ](name='DnsProduct')
  }(name='DnsProducts', description='The number of domain names that have been bound to the DNS instance.'),
  domainType?: string(name='DomainType', example='PUBLIC'),
  pageNumber?: long(name='PageNumber', description='Indicates whether the request for domain name resolution was in the black hole.', example='1'),
  pageSize?: long(name='PageSize', description='The type of the overseas line.', example='2'),
  requestId?: string(name='RequestId', description='The number of monitored nodes.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: long(name='TotalCount', description='The list of Alibaba Cloud DNS instances obtained by this operation.', example='2'),
}

model DescribeDnsProductInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsProductInstancesResponseBody(name='body'),
}

/**
  * The number of the page to return. Pages start from page **1**. Default value: **1**.
  *
  * @param request DescribeDnsProductInstancesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDnsProductInstancesResponse
 */
async function describeDnsProductInstancesWithOptions(request: DescribeDnsProductInstancesRequest, runtime: Util.RuntimeOptions): DescribeDnsProductInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.domainType)) {
    query['DomainType'] = request.domainType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  if (!Util.isUnset(request.versionCode)) {
    query['VersionCode'] = request.versionCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsProductInstances',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The number of the page to return. Pages start from page **1**. Default value: **1**.
  *
  * @param request DescribeDnsProductInstancesRequest
  * @return DescribeDnsProductInstancesResponse
 */
async function describeDnsProductInstances(request: DescribeDnsProductInstancesRequest): DescribeDnsProductInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsProductInstancesWithOptions(request, runtime);
}

model DescribeDohAccountStatisticsRequest {
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the YYYY-MM-DD format.

The default value is the day when you perform the operation.', example='2019-07-04'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.

You can query only the DNS records of the latest 90 days.`The value of StartDate must be greater than or equal to the difference between the current date and 90`.', example='2019-07-04'),
}

model DescribeDohAccountStatisticsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0F32959D-417B-4D66-8463-68606605E3E2'),
  statistics?: [ 
    {
      timestamp?: long(name='Timestamp', description='The timestamp.', example='1544976000000'),
      totalCount?: long(name='TotalCount', description='The total number of requests.', example='3141592653'),
      v4HttpCount?: long(name='V4HttpCount', description='The number of IPv4-based HTTP requests.', example='3141592653'),
      v4HttpsCount?: long(name='V4HttpsCount', description='The number of IPv4-based HTTPS requests.', example='3141592653'),
      v6HttpCount?: long(name='V6HttpCount', description='The number of IPv6-based HTTP requests.', example='3141592653'),
      v6HttpsCount?: long(name='V6HttpsCount', description='The number of IPv6-based HTTPS requests.', example='3141592653'),
    }
  ](name='Statistics', description='The statistics list.'),
}

model DescribeDohAccountStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDohAccountStatisticsResponseBody(name='body'),
}

async function describeDohAccountStatisticsWithOptions(request: DescribeDohAccountStatisticsRequest, runtime: Util.RuntimeOptions): DescribeDohAccountStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDohAccountStatistics',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDohAccountStatistics(request: DescribeDohAccountStatisticsRequest): DescribeDohAccountStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDohAccountStatisticsWithOptions(request, runtime);
}

model DescribeDohDomainStatisticsRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the YYYY-MM-DD format.

The default value is the day when you perform the operation.', example='2019-07-04'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.

You can query only the DNS records of the latest 90 days. `The value of StartDate must be greater than or equal to the difference between the current date and 90`.', example='2019-07-04'),
}

model DescribeDohDomainStatisticsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0F32959D-417B-4D66-8463-68606605E3E2'),
  statistics?: [ 
    {
      timestamp?: long(name='Timestamp', description='The timestamp.', example='1544976000000'),
      totalCount?: long(name='TotalCount', description='The total number of requests.', example='3141592653'),
      v4HttpCount?: long(name='V4HttpCount', description='The number of IPv4-based HTTP requests.', example='3141592653'),
      v4HttpsCount?: long(name='V4HttpsCount', description='The number of IPv4-based HTTPS requests.', example='3141592653'),
      v6HttpCount?: long(name='V6HttpCount', description='The number of IPv6-based HTTP requests.', example='3141592653'),
      v6HttpsCount?: long(name='V6HttpsCount', description='The number of IPv6-based HTTPS requests.', example='3141592653'),
    }
  ](name='Statistics', description='The statistics list.'),
}

model DescribeDohDomainStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDohDomainStatisticsResponseBody(name='body'),
}

async function describeDohDomainStatisticsWithOptions(request: DescribeDohDomainStatisticsRequest, runtime: Util.RuntimeOptions): DescribeDohDomainStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDohDomainStatistics',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDohDomainStatistics(request: DescribeDohDomainStatisticsRequest): DescribeDohDomainStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDohDomainStatisticsWithOptions(request, runtime);
}

model DescribeDohDomainStatisticsSummaryRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the YYYY-MM-DD format.

The default value is the day when you perform the operation.', example='2019-07-04'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 100. Default value: 20.', example='20'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.

You can query only the DNS records of the last 90 days. `The value of StartDate must be greater than or equal to the difference between the current date and 90`.', example='2019-07-04'),
}

model DescribeDohDomainStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0F32959D-417B-4D66-8463-68606605E3E2'),
  statistics?: [ 
    {
      domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
      httpCount?: long(name='HttpCount', description='The number of HTTP requests.', example='3141592653'),
      httpsCount?: long(name='HttpsCount', description='The number of HTTPS requests.', example='3141592653'),
      ipCount?: long(name='IpCount', description='The number of IP addresses.', example='20'),
      totalCount?: long(name='TotalCount', description='The total number of requests.', example='14141592653'),
      v4HttpCount?: long(name='V4HttpCount', description='The number of IPv4-based HTTP requests.', example='3141592653'),
      v4HttpsCount?: long(name='V4HttpsCount', description='The number of IPv4-based HTTPS requests.', example='3141592653'),
      v6HttpCount?: long(name='V6HttpCount', description='The number of IPv6-based HTTP requests.', example='3141592653'),
      v6HttpsCount?: long(name='V6HttpsCount', description='The number of IPv6-based HTTPS requests.', example='3141592653'),
    }
  ](name='Statistics', description='The statistics list.'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned.', example='300'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='50'),
}

model DescribeDohDomainStatisticsSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDohDomainStatisticsSummaryResponseBody(name='body'),
}

async function describeDohDomainStatisticsSummaryWithOptions(request: DescribeDohDomainStatisticsSummaryRequest, runtime: Util.RuntimeOptions): DescribeDohDomainStatisticsSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDohDomainStatisticsSummary',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDohDomainStatisticsSummary(request: DescribeDohDomainStatisticsSummaryRequest): DescribeDohDomainStatisticsSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDohDomainStatisticsSummaryWithOptions(request, runtime);
}

model DescribeDohSubDomainStatisticsRequest {
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the YYYY-MM-DD format.

The default value is the day when you perform the operation.', example='2019-07-04'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.

You can query only the DNS records of the latest 90 days. `The value of StartDate must be greater than or equal to the difference between the current date and 90`.', example='2019-07-04'),
  subDomain?: string(name='SubDomain', description='The subdomain whose statistics you want to query.', example='www.example.com'),
}

model DescribeDohSubDomainStatisticsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0F32959D-417B-4D66-8463-68606605E3E2'),
  statistics?: [ 
    {
      timestamp?: long(name='Timestamp', description='The timestamp.', example='1544976000000'),
      totalCount?: long(name='TotalCount', description='The total number of requests.', example='3141592653'),
      v4HttpCount?: long(name='V4HttpCount', description='The number of IPv4-based HTTP requests.', example='3141592653'),
      v4HttpsCount?: long(name='V4HttpsCount', description='The number of IPv4-based HTTPS requests.', example='3141592653'),
      v6HttpCount?: long(name='V6HttpCount', description='The number of IPv6-based HTTP requests.', example='3141592653'),
      v6HttpsCount?: long(name='V6HttpsCount', description='The number of IPv6-based HTTPS requests.', example='3141592653'),
    }
  ](name='Statistics', description='The statistics list.'),
}

model DescribeDohSubDomainStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDohSubDomainStatisticsResponseBody(name='body'),
}

async function describeDohSubDomainStatisticsWithOptions(request: DescribeDohSubDomainStatisticsRequest, runtime: Util.RuntimeOptions): DescribeDohSubDomainStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.subDomain)) {
    query['SubDomain'] = request.subDomain;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDohSubDomainStatistics',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDohSubDomainStatistics(request: DescribeDohSubDomainStatisticsRequest): DescribeDohSubDomainStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDohSubDomainStatisticsWithOptions(request, runtime);
}

model DescribeDohSubDomainStatisticsSummaryRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the YYYY-MM-DD format.

The default value is the day when you query the required data.', example='2019-07-04'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 100. Default value: 20.', example='20'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.

You can query only the DNS records of the last 90 days. `The value of StartDate must be greater than or equal to the difference between the current date and 90`.', example='2019-07-04'),
  subDomain?: string(name='SubDomain', description='The subdomain.', example='www.example.com'),
}

model DescribeDohSubDomainStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0F32959D-417B-4D66-8463-68606605E3E2'),
  statistics?: [ 
    {
      httpCount?: long(name='HttpCount', description='The number of HTTP requests.', example='3141592653'),
      httpsCount?: long(name='HttpsCount', description='The number of HTTPS requests.', example='3141592653'),
      ipCount?: long(name='IpCount', description='The number of IP addresses.', example='20'),
      subDomain?: string(name='SubDomain', description='The subdomain.', example='www.example.com'),
      totalCount?: long(name='TotalCount', description='Total number of requests.', example='14141592653'),
      v4HttpCount?: long(name='V4HttpCount', description='The number of IPv4-based HTTP requests.', example='3141592653'),
      v4HttpsCount?: long(name='V4HttpsCount', description='The number of IPv4-based HTTPS requests.', example='3141592653'),
      v6HttpCount?: long(name='V6HttpCount', description='The number of IPv6-based HTTP requests.', example='3141592653'),
      v6HttpsCount?: long(name='V6HttpsCount', description='The number of IPv6-based HTTPS requests.', example='3141592653'),
    }
  ](name='Statistics', description='The statistics list.'),
  totalItems?: int32(name='TotalItems', description='Total number of entries returned.', example='100'),
  totalPages?: int32(name='TotalPages', description='Total number of pages returned.', example='50'),
}

model DescribeDohSubDomainStatisticsSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDohSubDomainStatisticsSummaryResponseBody(name='body'),
}

async function describeDohSubDomainStatisticsSummaryWithOptions(request: DescribeDohSubDomainStatisticsSummaryRequest, runtime: Util.RuntimeOptions): DescribeDohSubDomainStatisticsSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.subDomain)) {
    query['SubDomain'] = request.subDomain;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDohSubDomainStatisticsSummary',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDohSubDomainStatisticsSummary(request: DescribeDohSubDomainStatisticsSummaryRequest): DescribeDohSubDomainStatisticsSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDohSubDomainStatisticsSummaryWithOptions(request, runtime);
}

model DescribeDohUserInfoRequest {
  endDate?: string(name='EndDate', description='The end time for the query. Format: YYYY-MM-DD

If you do not specify this parameter, the default value is the time when you perform the query.', example='2019-07-04'),
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.', example='en'),
  startDate?: string(name='StartDate', description='The start time for the query. Format: YYYY-MM-DD

You can query the user information of the last 90 days only. `Set the parameter to a value no earlier than 90 days from the current time`.', example='2019-07-04'),
}

model DescribeDohUserInfoResponseBody = {
  domainCount?: int32(name='DomainCount', description='The number of accessed domains.', example='123'),
  pdnsId?: long(name='PdnsId', description='The ID of the Alibaba Cloud public DNS user.', example='12345678'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0F32959D-417B-4D66-8463-68606605E3E2'),
  subDomainCount?: int32(name='SubDomainCount', description='The number of accessed subdomains.', example='123'),
}

model DescribeDohUserInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDohUserInfoResponseBody(name='body'),
}

async function describeDohUserInfoWithOptions(request: DescribeDohUserInfoRequest, runtime: Util.RuntimeOptions): DescribeDohUserInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDohUserInfo',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDohUserInfo(request: DescribeDohUserInfoRequest): DescribeDohUserInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDohUserInfoWithOptions(request, runtime);
}

model DescribeDomainDnssecInfoRequest {
  domainName?: string(name='DomainName', description='The domain name for which DNSSEC configurations to query.', example='example.com'),
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages, such as the region parameter. Default value: en. Valid values: en, zh, and ja.', example='en'),
}

model DescribeDomainDnssecInfoResponseBody = {
  algorithm?: string(name='Algorithm', description='The algorithm configured in a DNSSEC record. This parameter is returned if DNSSEC is enabled.', example='13'),
  digest?: string(name='Digest', description='The digest configured in a DNSSEC record. This parameter is returned if DNSSEC is enabled.', example='C1A0424B97A049F1F9B2EA139CC298533219668164E343BD21203ABC4608C02A'),
  digestType?: string(name='DigestType', description='The digest type configured in a DNSSEC record. This parameter is returned if DNSSEC is enabled.', example='SHA256'),
  domainName?: string(name='DomainName', description='The domain name that is queried.', example='example.com'),
  dsRecord?: string(name='DsRecord', description='The DS record. This parameter is returned if DNSSEC is enabled.', example='example.com. 3600 IN DS 2371 13 2 C1A0424B97A049F1F9B2EA139CC298533219668164E343BD21203ABC4608C02A'),
  flags?: string(name='Flags', description='The flag of a DNSSEC record. This parameter is returned if DNSSEC is enabled.', example='257 (KSK)'),
  keyTag?: string(name='KeyTag', description='The key tag of a DNSSEC record. This parameter is returned if DNSSEC is enabled.', example='54931'),
  publicKey?: string(name='PublicKey', description='The public key for a DNSSEC record. This parameter is returned if DNSSEC is enabled.', example='mdsswUyr3DPW132mOi8V9xESWE8jTo0dxCjjnopKl+GqJxpVXckHAeF+KkxLbxILfDLUT0rAK9iUzy1L53eKGQ=='),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  status?: string(name='Status', description='Indicates whether DNSSEC is enabled for the specified domain name.

*   ON: DNSSEC is enabled.
*   OFF: DNSSEC is disabled.', example='ON'),
}

model DescribeDomainDnssecInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainDnssecInfoResponseBody(name='body'),
}

async function describeDomainDnssecInfoWithOptions(request: DescribeDomainDnssecInfoRequest, runtime: Util.RuntimeOptions): DescribeDomainDnssecInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainDnssecInfo',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainDnssecInfo(request: DescribeDomainDnssecInfoRequest): DescribeDomainDnssecInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainDnssecInfoWithOptions(request, runtime);
}

model DescribeDomainGroupsRequest {
  keyWord?: string(name='KeyWord', description='The keyword of the domain name group for searches in %KeyWord% mode. The value is not case-sensitive.', example='Group'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  pageNumber?: long(name='PageNumber', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page. Maximum value: **100**. Default value: **20**.', example='20'),
}

model DescribeDomainGroupsResponseBody = {
  domainGroups?: {
    domainGroup?: [ 
    {
      domainCount?: long(name='DomainCount', description='The number of domain name groups.', example='2'),
      groupId?: string(name='GroupId', description='The ID of the domain name group.', example='2223'),
      groupName?: string(name='GroupName', description='The name of the domain name group.', example='MyGroup'),
    }
  ](name='DomainGroup')
  }(name='DomainGroups', description='The list of domain name groups.'),
  pageNumber?: long(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: long(name='TotalCount', description='The total number of domain name groups.', example='1'),
}

model DescribeDomainGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainGroupsResponseBody(name='body'),
}

async function describeDomainGroupsWithOptions(request: DescribeDomainGroupsRequest, runtime: Util.RuntimeOptions): DescribeDomainGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainGroups',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainGroups(request: DescribeDomainGroupsRequest): DescribeDomainGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainGroupsWithOptions(request, runtime);
}

model DescribeDomainInfoRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='dns-example.com'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  needDetailAttributes?: boolean(name='NeedDetailAttributes', description='Specifies whether detailed attributes are required. Default value: **false**, which indicates that detailed attributes are not required.

If you set this parameter to **true**, the values of the following parameters are returned: LineType, MinTtl, RecordLineTreeJson, RecordLines, LineCode, LineDisplayName, LineName, RegionLines, and SlaveDns.', example='true'),
}

model DescribeDomainInfoResponseBody = {
  aliDomain?: boolean(name='AliDomain', description='Indicates whether the domain name is an Alibaba Cloud HiChina domain name.', example='true'),
  availableTtls?: {
    availableTtl?: [ string ](name='AvailableTtl')
  }(name='AvailableTtls', description='The available time to live (TTL) values.'),
  createTime?: string(name='CreateTime', description='The time when the domain name was added to Alibaba Cloud CDN.', example='2015-12-12T09:23Z'),
  dnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='DnsServers', description='The information about DNS servers.'),
  domainId?: string(name='DomainId', description='The ID of the domain name.', example='00efd71a-770e-4255-b54e-6fe5659baffe'),
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  groupId?: string(name='GroupId', description='The ID of the domain name group.', example='2223'),
  groupName?: string(name='GroupName', description='The name of the domain name group.', example='mygroup'),
  inBlackHole?: boolean(name='InBlackHole', description='Indicates whether blackhole filtering was triggered.', example='false'),
  inClean?: boolean(name='InClean', description='Indicates whether traffic scrubbing was started.', example='false'),
  instanceId?: string(name='InstanceId', description='The ID of the Alibaba Cloud DNS instance.', example='i-7bg'),
  lineType?: string(name='LineType', description='The type of line.', example='region_province'),
  minTtl?: long(name='MinTtl', description='The minimum TTL.', example='1'),
  punyCode?: string(name='PunyCode', description='The Punycode for the domain name. This parameter is returned only for Chinese domain names.', example='example.com'),
  recordLineTreeJson?: string(name='RecordLineTreeJson', description='The tree-based lines.', example='{"default":{},"unicom":{},"telecom":{},"mobile":{},"edu":{},"oversea":{},"baidu":{},"biying":{},"google":{}}'),
  recordLines?: {
    recordLine?: [ 
    {
      fatherCode?: string(name='FatherCode', description='The code of the parent line. This parameter is left empty if the line has no parent line.', example='internal'),
      lineCode?: string(name='LineCode', description='The code of the line.', example='cn_region_xibei'),
      lineDisplayName?: string(name='LineDisplayName', description='The name of the parent line.'),
      lineName?: string(name='LineName', description='The name of the line.'),
    }
  ](name='RecordLine')
  }(name='RecordLines', description='The information about lines.'),
  regionLines?: boolean(name='RegionLines', description='Indicates whether the lines are regional lines.', example='false'),
  remark?: string(name='Remark', description='The description of the domain name.', example='remark'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-aek3dj3wvclgcxo'),
  slaveDns?: boolean(name='SlaveDns', description='Indicates whether secondary DNS is allowed.', example='true'),
  subDomain?: boolean(name='SubDomain'),
  versionCode?: string(name='VersionCode', description='The version of the Alibaba Cloud DNS instance.', example='version1'),
  versionName?: string(name='VersionName', description='The edition of the Alibaba Cloud DNS instance.'),
}

model DescribeDomainInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainInfoResponseBody(name='body'),
}

/**
  * In this example, the domain name is bound to an Alibaba Cloud DNS instance of Enterprise Ultimate Edition. For more information about valid lines, see the return values of the RecordLines parameter.
  *
  * @param request DescribeDomainInfoRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDomainInfoResponse
 */
async function describeDomainInfoWithOptions(request: DescribeDomainInfoRequest, runtime: Util.RuntimeOptions): DescribeDomainInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.needDetailAttributes)) {
    query['NeedDetailAttributes'] = request.needDetailAttributes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainInfo',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * In this example, the domain name is bound to an Alibaba Cloud DNS instance of Enterprise Ultimate Edition. For more information about valid lines, see the return values of the RecordLines parameter.
  *
  * @param request DescribeDomainInfoRequest
  * @return DescribeDomainInfoResponse
 */
async function describeDomainInfo(request: DescribeDomainInfoRequest): DescribeDomainInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainInfoWithOptions(request, runtime);
}

model DescribeDomainLogsRequest {
  groupId?: string(name='GroupId', description='The ID of the domain name group.', example='2223'),
  keyWord?: string(name='KeyWord', description='The keyword for the query in "%KeyWord%" mode. The keyword is not case-sensitive.', example='test'),
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.', example='en'),
  pageNumber?: long(name='PageNumber', description='The page number to return. The page number starts from **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries to return per page. Maximum value: **100**. Default value: **20**.', example='20'),
  startDate?: string(name='StartDate', description='The start time for the query. Format: **YYYY-MM-DD**', example='2019-07-04'),
  type?: string(name='Type', description='The type of object of which you want to query operation logs. Valid values:

*   domain: domain name
*   slavedns: secondary Domain Name System (DNS)', example='domain'),
  endDate?: string(name='endDate', description='The end time for the query. Format: **YYYY-MM-DD**', example='2019-07-04'),
}

model DescribeDomainLogsResponseBody = {
  domainLogs?: {
    domainLog?: [ 
    {
      action?: string(name='Action', description='The operation performed.', example='Add'),
      actionTime?: string(name='ActionTime', description='The time when the operation was performed.', example='2015-12-12T09:23Z'),
      actionTimestamp?: long(name='ActionTimestamp', description='The UNIX timestamp that indicates when the operation was performed.', example='143562300000'),
      clientIp?: string(name='ClientIp', description='The IP address from which the operation was performed.', example='182.92.253.20'),
      domainName?: string(name='DomainName', description='The domain name.', example='abc.com'),
      message?: string(name='Message', description='The message for the operation.', example='To the DNS record list'),
      zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cxfd345sd234'),
    }
  ](name='DomainLog')
  }(name='DomainLogs', description='The details about the operation logs that are queried.'),
  pageNumber?: long(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: long(name='PageSize', description='The number of operation logs returned per page.', example='2'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: long(name='TotalCount', description='The total number of operation logs returned.', example='2'),
}

model DescribeDomainLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainLogsResponseBody(name='body'),
}

async function describeDomainLogsWithOptions(request: DescribeDomainLogsRequest, runtime: Util.RuntimeOptions): DescribeDomainLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.endDate)) {
    query['endDate'] = request.endDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainLogs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainLogs(request: DescribeDomainLogsRequest): DescribeDomainLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainLogsWithOptions(request, runtime);
}

model DescribeDomainNsRequest {
  domainName?: string(name='DomainName', description='Indicates whether all the name servers were Alibaba Cloud DNS servers.', example='example.com'),
  lang?: string(name='Lang', description='The domain name that you want to resolve.', example='en'),
}

model DescribeDomainNsResponseBody = {
  allAliDns?: boolean(name='AllAliDns', description='Indicates whether all the name servers are Alibaba Cloud DNS servers.', example='true'),
  detectFailedReasonCode?: string(name='DetectFailedReasonCode', description='', example='DnsCheck.Failed'),
  dnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='DnsServers', description='The DNS server names configured for the domain name.'),
  expectDnsServers?: {
    expectDnsServer?: [ string ](name='ExpectDnsServer')
  }(name='ExpectDnsServers', description='The DNS server names assigned by Alibaba Cloud DNS.'),
  includeAliDns?: boolean(name='IncludeAliDns', description='Indicates whether the name servers include Alibaba Cloud DNS servers.', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='16C7DC7A-2FA7-4D14-8B12-88A2BB6373DB'),
}

model DescribeDomainNsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainNsResponseBody(name='body'),
}

/**
  * > This operation queries the authoritative servers of a domain name registry to obtain the name servers for a domain name. If the domain name is in an invalid state, such as serverHold or clientHold, an error may be returned.
  *
  * @param request DescribeDomainNsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDomainNsResponse
 */
async function describeDomainNsWithOptions(request: DescribeDomainNsRequest, runtime: Util.RuntimeOptions): DescribeDomainNsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainNs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > This operation queries the authoritative servers of a domain name registry to obtain the name servers for a domain name. If the domain name is in an invalid state, such as serverHold or clientHold, an error may be returned.
  *
  * @param request DescribeDomainNsRequest
  * @return DescribeDomainNsResponse
 */
async function describeDomainNs(request: DescribeDomainNsRequest): DescribeDomainNsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainNsWithOptions(request, runtime);
}

model DescribeDomainRecordInfoRequest {
  lang?: string(name='Lang', description='The language type.', example='en'),
  recordId?: string(name='RecordId', description='The ID of the DNS record.

This parameter is returned when you add a DNS record or when you query the list of DNS records.', example='9999985'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0'),
}

model DescribeDomainRecordInfoResponseBody = {
  domainId?: string(name='DomainId', description='The ID of the domain name.', example='00efd71a-770e-4255-b54e-6fe5659baffe'),
  domainName?: string(name='DomainName', description='The domain name.', example='dns-example.top'),
  groupId?: string(name='GroupId', description='The ID of the domain name group.', example='2223'),
  groupName?: string(name='GroupName', description='The name of the domain name group.', example='MyGroup'),
  line?: string(name='Line', description='The resolution line.', example='default'),
  locked?: boolean(name='Locked', description='The lock status of the DNS record. Valid values: true and false.', example='true'),
  priority?: long(name='Priority', description='The priority of the MX-type DNS record.', example='5'),
  punyCode?: string(name='PunyCode', description='The punycode is only returned for Chinese domain names.', example='xn--fsq270a.com'),
  RR?: string(name='RR', description='The host record.', example='@'),
  recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
  remark?: string(name='Remark', description='The remark of the DNS record.', example='test'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  status?: string(name='Status', description='The status of the DNS record. Valid values: Enable and Disable.', example='Enable'),
  TTL?: long(name='TTL', description='The TTL of the resolution.', example='600'),
  type?: string(name='Type', description='The type of the DNS record.', example='MX'),
  value?: string(name='Value', description='The value of the DNS record.', example='1.1.XX.XX'),
}

model DescribeDomainRecordInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainRecordInfoResponseBody(name='body'),
}

/**
  * ## Debugging
  * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=Alidns\\&api=DescribeDomainRecordInfo\\&type=RPC\\&version=2015-01-09)
  *
  * @param request DescribeDomainRecordInfoRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDomainRecordInfoResponse
 */
async function describeDomainRecordInfoWithOptions(request: DescribeDomainRecordInfoRequest, runtime: Util.RuntimeOptions): DescribeDomainRecordInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recordId)) {
    query['RecordId'] = request.recordId;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainRecordInfo',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ## Debugging
  * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=Alidns\\&api=DescribeDomainRecordInfo\\&type=RPC\\&version=2015-01-09)
  *
  * @param request DescribeDomainRecordInfoRequest
  * @return DescribeDomainRecordInfoResponse
 */
async function describeDomainRecordInfo(request: DescribeDomainRecordInfoRequest): DescribeDomainRecordInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainRecordInfoWithOptions(request, runtime);
}

model DescribeDomainRecordsRequest {
  direction?: string(name='Direction', description='The order in which the returned DNS records are sorted. Valid values: DESC and ASC. Default value: DESC.', example='DESC'),
  domainName?: string(name='DomainName', description='The domain name for which you want to query DNS records.', example='example.com'),
  groupId?: long(name='GroupId', description='The ID of the domain name group.', example='2223'),
  keyWord?: string(name='KeyWord', description='The keyword based on which the system queries DNS records.', example='test'),
  lang?: string(name='Lang', description='The language of the domain name.', example='en'),
  line?: string(name='Line', description='The line based on which the system queries DNS records. Default value: **default**.

For more information, see the following topic:

[DNS lines](https://www.alibabacloud.com/help/zh/doc-detail/29807.htm)', example='cn_mobile_anhui'),
  orderBy?: string(name='OrderBy', description='The method that is used to sort the returned DNS records. By default, the DNS records are sorted in reverse chronological order based on the time when they were added.', example='default'),
  pageNumber?: long(name='PageNumber', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page. Maximum value: **500**. Default value: **20**.', example='20'),
  RRKeyWord?: string(name='RRKeyWord', description='The resource record (RR) keyword based on which the system queries DNS records. The system queries DNS records based on the value of this parameter in fuzzy match mode. The value is not case-sensitive.', example='www'),
  searchMode?: string(name='SearchMode', description='The search mode. Valid values: **LIKE, EXACT, and ADVANCED**.

*   If you set this parameter to LIKE or EXACT, specify the KeyWord parameter.In this case, the RRKeyWord, TypeKeyWord, ValueKeyWord, Type, Line, and Status parameters are ignored.

*   If you set this parameter to ADVANCED, specify the RRKeyWord, TypeKeyWord, ValueKeyWord, Type, Line, and Status parameters.

*   If you do not specify this parameter, the system determines the search mode based on the following rules:

    *   If the KeyWord parameter is specified, the system uses the LIKE mode.
    *   If the KeyWord parameter is not specified, the system queries DNS records based on values of the RRKeyWord and ValueKeyWord parameters in fuzzy match mode, and based on the values of the TypeKeyWord, Type, Line, and Status parameters in exact match mode.', example='LIKE'),
  status?: string(name='Status', description='The status of the DNS records to query. Valid values: **Enable and Disable**.', example='Enable'),
  type?: string(name='Type', description='The type of the DNS records to query. For more information, see the following topic:

[DNS record types](https://www.alibabacloud.com/help/zh/doc-detail/29805.htm)', example='A'),
  typeKeyWord?: string(name='TypeKeyWord', description='The type keyword based on which the system queries DNS records. The system queries DNS records based on the value of this parameter in exact match mode. The value is not case-sensitive.', example='MX'),
  valueKeyWord?: string(name='ValueKeyWord', description='The record value keyword based on which the system queries DNS records. The system queries DNS records based on the value of this parameter in fuzzy match mode. The value is not case-sensitive.', example='com'),
}

model DescribeDomainRecordsResponseBody = {
  domainRecords?: {
    record?: [ 
    {
      createTimestamp?: long(name='CreateTimestamp'),
      domainName?: string(name='DomainName', description='The domain name to which the DNS record belongs.', example='example.com'),
      line?: string(name='Line', description='The line that is used by the DNS record.', example='default'),
      locked?: boolean(name='Locked', description='Indicates whether the DNS record is locked.', example='false'),
      priority?: long(name='Priority', description='The priority of the MX record.', example='5'),
      RR?: string(name='RR', description='The RR value.', example='www'),
      recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
      remark?: string(name='Remark', description='The description of the DNS record.'),
      status?: string(name='Status', description='The status of the DNS record.', example='Enable'),
      TTL?: long(name='TTL', description='The time-to-live (TTL) of the DNS record.', example='600'),
      type?: string(name='Type', description='The type of the DNS record.', example='MX'),
      updateTimestamp?: long(name='UpdateTimestamp'),
      value?: string(name='Value', description='The record value.', example='mail1.hichina.com'),
      weight?: int32(name='Weight', description='The weight of the DNS record.', example='2'),
    }
  ](name='Record')
  }(name='DomainRecords', description='The DNS records returned.'),
  pageNumber?: long(name='PageNumber', description='The number of the returned page.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: long(name='TotalCount', description='The total number of DNS records.', example='2'),
}

model DescribeDomainRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainRecordsResponseBody(name='body'),
}

/**
  * *   You can specify the DomainName, PageNumber, and PageSize parameters to query the DNS records of a domain name.
  * *   You can also specify the RRKeyWord, TypeKeyWord, or ValueKeyWord parameter to query the DNS records that contain the specified keyword.
  * *   By default, the DNS records are sorted in reverse chronological order based on the time when they were added.
  *
  * @param request DescribeDomainRecordsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDomainRecordsResponse
 */
async function describeDomainRecordsWithOptions(request: DescribeDomainRecordsRequest, runtime: Util.RuntimeOptions): DescribeDomainRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.line)) {
    query['Line'] = request.line;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.RRKeyWord)) {
    query['RRKeyWord'] = request.RRKeyWord;
  }
  if (!Util.isUnset(request.searchMode)) {
    query['SearchMode'] = request.searchMode;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.typeKeyWord)) {
    query['TypeKeyWord'] = request.typeKeyWord;
  }
  if (!Util.isUnset(request.valueKeyWord)) {
    query['ValueKeyWord'] = request.valueKeyWord;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainRecords',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   You can specify the DomainName, PageNumber, and PageSize parameters to query the DNS records of a domain name.
  * *   You can also specify the RRKeyWord, TypeKeyWord, or ValueKeyWord parameter to query the DNS records that contain the specified keyword.
  * *   By default, the DNS records are sorted in reverse chronological order based on the time when they were added.
  *
  * @param request DescribeDomainRecordsRequest
  * @return DescribeDomainRecordsResponse
 */
async function describeDomainRecords(request: DescribeDomainRecordsRequest): DescribeDomainRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainRecordsWithOptions(request, runtime);
}

model DescribeDomainResolveStatisticsSummaryRequest {
  direction?: string(name='Direction', description='The order in which you want to sort the query results. Valid values: DESC and ASC. DESC indicates that the query results are sorted in descending order. ASC indicates that the query results are sorted in ascending order.', example='DESC'),
  endDate?: string(name='EndDate', description='The end time in the yyyy-MM-dd format, for example, 2023-03-13.', example='2023-03-01'),
  keyword?: string(name='Keyword', description='The keyword. The Keyword parameter must be used together with the SearchMode parameter.', example='test'),
  lang?: string(name='Lang', description='The language used. Valid values: zh, en, and ja.', example='zh'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 1000.', example='10'),
  searchMode?: string(name='SearchMode', description='The search mode of the keyword. Valid values:

LIKE and EXACT. LIKE is the default value and indicates the fuzzy search mode. EXACT indicates the exact match mode.', example='EXACT'),
  startDate?: string(name='StartDate', description='The start time in the yyyy-MM-dd format, for example, 2023-03-01.', example='2023-03-01'),
  threshold?: long(name='Threshold', description='The threshold for the number of resolution requests. You can query the paid domain names at the specified quantity level of resolution requests and query the number of resolution requests. For example, if you set this parameter to 100, you can obtain data about the paid domain names with less than 100 resolution requests. If you do not specify this parameter, the data about the paid domain names that have resolution requests is obtained. If you set this parameter to a value less than 0, the data about all paid domain names is obtained. If you set this parameter to 0, the data about the paid domain names that do not have resolution requests is obtained. If you set this parameter to a value greater than 0, the data about the paid domain names whose number of resolution requests is less than or equal to the value of this parameter is obtained.', example='-1'),
}

model DescribeDomainResolveStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  statistics?: [ 
    {
      count?: string(name='Count', description='The number of resolution requests.', example='35509014'),
      domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
      domainType?: string(name='DomainType', description='The instance type. Valid values: PUBLIC and CACHE. PUBLIC indicates an authoritative domain name. CACHE indicates a cache-accelerated domain name.', example='CACHE'),
    }
  ](name='Statistics', description='The statistics.'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned.', example='1'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeDomainResolveStatisticsSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainResolveStatisticsSummaryResponseBody(name='body'),
}

async function describeDomainResolveStatisticsSummaryWithOptions(request: DescribeDomainResolveStatisticsSummaryRequest, runtime: Util.RuntimeOptions): DescribeDomainResolveStatisticsSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchMode)) {
    query['SearchMode'] = request.searchMode;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.threshold)) {
    query['Threshold'] = request.threshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainResolveStatisticsSummary',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainResolveStatisticsSummary(request: DescribeDomainResolveStatisticsSummaryRequest): DescribeDomainResolveStatisticsSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainResolveStatisticsSummaryWithOptions(request, runtime);
}

model DescribeDomainStatisticsRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  domainType?: string(name='DomainType', example='PUBLIC CACHE'),
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the **YYYY-MM-DD** format.

The default value is the day when you perform the operation.', example='2019-07-04'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the **YYYY-MM-DD** format.

You can only query the DNS records of the last 90 days.', example='2019-07-04'),
}

model DescribeDomainStatisticsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6AEC7A64-3CB1-4C49-8B35-0B901F1E26BF'),
  statistics?: {
    statistic?: [ 
    {
      count?: long(name='Count', description='The number of queries.', example='15292887'),
      timestamp?: long(name='Timestamp', description='The UNIX timestamp representing the collection time.', example='1556640000000'),
    }
  ](name='Statistic')
  }(name='Statistics', description='The list of query volume records.'),
}

model DescribeDomainStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainStatisticsResponseBody(name='body'),
}

/**
  * Real-time data is collected per hour.
  *
  * @param request DescribeDomainStatisticsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDomainStatisticsResponse
 */
async function describeDomainStatisticsWithOptions(request: DescribeDomainStatisticsRequest, runtime: Util.RuntimeOptions): DescribeDomainStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainType)) {
    query['DomainType'] = request.domainType;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainStatistics',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Real-time data is collected per hour.
  *
  * @param request DescribeDomainStatisticsRequest
  * @return DescribeDomainStatisticsResponse
 */
async function describeDomainStatistics(request: DescribeDomainStatisticsRequest): DescribeDomainStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainStatisticsWithOptions(request, runtime);
}

model DescribeDomainStatisticsSummaryRequest {
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the **YYYY-MM-DD** format.

The default value is the day when you perform the operation.', example='2019-07-04'),
  keyword?: string(name='Keyword', description='The keyword for searches in %KeyWord% mode. The value is not case-sensitive.', example='test'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  pageNumber?: long(name='PageNumber', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page. Maximum value: **100**. Minimum value: **1**. Default value: **20**.', example='20'),
  searchMode?: string(name='SearchMode', description='The search mode of the keyword. Valid values:

*   **LIKE**: fuzzy match (default).
*   **EXACT**: exact match.', example='LIKE'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the **YYYY-MM-DD** format.

You can only query DNS records of the last 90 days.', example='2019-07-04'),
  threshold?: long(name='Threshold', description='The threshold of query volume that can be obtained. You can also obtain data about a domain name with the query volume less than or equal to the threshold. For example, if you set this parameter to 100, you can query domain names with less than 100 queries.', example='12'),
}

model DescribeDomainStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='5'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CC625C21-8832-4683-BF10-C3CFB1A4FA13'),
  statistics?: {
    statistic?: [ 
    {
      count?: long(name='Count', description='The number of queries.', example='35509014'),
      domainName?: string(name='DomainName', description='The domain name.', example='ali-gslb.com'),
      domainType?: string(name='DomainType'),
    }
  ](name='Statistic')
  }(name='Statistics', description='The list of query volume records.'),
  totalItems?: int32(name='TotalItems', description='The total number of data records.', example='68'),
  totalPages?: int32(name='TotalPages', description='The total number of returned pages.', example='14'),
}

model DescribeDomainStatisticsSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainStatisticsSummaryResponseBody(name='body'),
}

async function describeDomainStatisticsSummaryWithOptions(request: DescribeDomainStatisticsSummaryRequest, runtime: Util.RuntimeOptions): DescribeDomainStatisticsSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchMode)) {
    query['SearchMode'] = request.searchMode;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.threshold)) {
    query['Threshold'] = request.threshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainStatisticsSummary',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainStatisticsSummary(request: DescribeDomainStatisticsSummaryRequest): DescribeDomainStatisticsSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainStatisticsSummaryWithOptions(request, runtime);
}

model DescribeDomainsRequest {
  groupId?: string(name='GroupId', description='The ID of the domain name group. If you do not specify this parameter, all domain names are queried by default.', example='2223'),
  keyWord?: string(name='KeyWord', description='The keyword for searches in "%KeyWord%" mode. The value is not case-sensitive.', example='com'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  pageNumber?: long(name='PageNumber', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page. Maximum value: **100**. Default value: **20**.', example='20'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-resourcegroupid01'),
  searchMode?: string(name='SearchMode', description='The search mode. Valid values:

*   **LIKE**: fuzzy match.
*   **EXACT**: exact match.', example='LIKE'),
  starmark?: boolean(name='Starmark', description='Specifies whether to query the starmark of the domain name.', example='true'),
}

model DescribeDomainsResponseBody = {
  domains?: {
    domain?: [ 
    {
      aliDomain?: boolean(name='AliDomain', description='Indicates whether the domain name is an Alibaba Cloud HiChina domain name.', example='true'),
      createTime?: string(name='CreateTime', example='2019-01-30T05:25Z'),
      createTimestamp?: long(name='CreateTimestamp', example='1660546144000'),
      dnsServers?: {
        dnsServer?: [ string ](name='DnsServer')
      }(name='DnsServers', description='The list of DNS servers of the domain name in the DNS system.'),
      domainId?: string(name='DomainId', description='The ID of the domain name.', example='00efd71a-770e-4255-b54e-6fe5659baffe'),
      domainName?: string(name='DomainName', description='The domain name.', example='abc.com'),
      groupId?: string(name='GroupId', description='The ID of the domain name group.', example='2223'),
      groupName?: string(name='GroupName', description='The name of the domain name group.', example='mygroup'),
      instanceEndTime?: string(name='InstanceEndTime', description='The expiration time of the instance.', example='2020-03-14T16:00Z'),
      instanceExpired?: boolean(name='InstanceExpired', description='Indicates whether the instance expired.', example='false'),
      instanceId?: string(name='InstanceId', description='The ID of the Alibaba Cloud DNS instance.', example='i-7bg'),
      punyCode?: string(name='PunyCode', description='The punycode is returned for Chinese domain names and is left blank for English domain names.', example='abc.com'),
      recordCount?: long(name='RecordCount', description='The number of DNS records of the domain name.', example='100'),
      registrantEmail?: string(name='RegistrantEmail', description='The email address of the registrant.', example='test@example.com'),
      remark?: string(name='Remark', description='The description.', example='remark'),
      resourceGroupId?: string(name='ResourceGroupId', example='rg-acf'),
      starmark?: boolean(name='Starmark', description='Indicates whether to query the starmark of the domain name.', example='true'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      versionCode?: string(name='VersionCode', description='The version code of the Alibaba Cloud DNS instance.', example='version_enterprise_basic'),
      versionName?: string(name='VersionName', description='The version name of the Alibaba Cloud DNS instance.'),
    }
  ](name='Domain')
  }(name='Domains', description='The list of domain names queried by this operation.'),
  pageNumber?: long(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries returned per page.', example='2'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='68386699-8B9E-4D5B-BC4C-75A28F6C2A00'),
  totalCount?: long(name='TotalCount', description='The total number of domain names.', example='2'),
}

model DescribeDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainsResponseBody(name='body'),
}

/**
  * *   You can specify the PageNumber and PageSize parameters to query domain names.
  * *   You can specify the KeyWord parameter to query domain names that contain the specified keyword.
  * *   By default, the domain names in a list are sorted in descending order of the time they were added.
  * *   You can specify the GroupId parameter. If you do not specify this parameter, all domain names are queried by default.
  *
  * @param request DescribeDomainsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDomainsResponse
 */
async function describeDomainsWithOptions(request: DescribeDomainsRequest, runtime: Util.RuntimeOptions): DescribeDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.searchMode)) {
    query['SearchMode'] = request.searchMode;
  }
  if (!Util.isUnset(request.starmark)) {
    query['Starmark'] = request.starmark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomains',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   You can specify the PageNumber and PageSize parameters to query domain names.
  * *   You can specify the KeyWord parameter to query domain names that contain the specified keyword.
  * *   By default, the domain names in a list are sorted in descending order of the time they were added.
  * *   You can specify the GroupId parameter. If you do not specify this parameter, all domain names are queried by default.
  *
  * @param request DescribeDomainsRequest
  * @return DescribeDomainsResponse
 */
async function describeDomains(request: DescribeDomainsRequest): DescribeDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainsWithOptions(request, runtime);
}

model DescribeGtmAccessStrategiesRequest {
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance whose access policies you want to query.', example='instance1'),
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return per page.', example='20'),
}

model DescribeGtmAccessStrategiesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The number of the page returned.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0CCC9971-CEC9-4132-824B-4AE611C07623'),
  strategies?: {
    strategy?: [ 
    {
      accessMode?: string(name='AccessMode', description='The access policy. Valid values:

*   **AUTO**: Automatic switch
*   **DEFAULT**: Default address pool
*   **FAILOVER**: Failover address pool', example='DEFAULT'),
      accessStatus?: string(name='AccessStatus', description='The access status. Valid values:

*   **DEFAULT**: The default address pool is currently accessed.
*   **FAILOVER**: The failover address pool is currently accessed.', example='DEFAULT'),
      createTime?: string(name='CreateTime', description='The time when the access policy was created.', example='2018-08-09T00:10Z'),
      createTimestamp?: long(name='CreateTimestamp', example='1533773400000'),
      defaultAddrPoolId?: string(name='DefaultAddrPoolId', description='The ID of the default address pool.', example='hra0i1'),
      defaultAddrPoolMonitorStatus?: string(name='DefaultAddrPoolMonitorStatus', description='Indicates whether health check was enabled for the default address pool. Valid values:

*   **OPEN**: Enabled
*   **CLOSE**: Disabled
*   **UNCONFIGURED**: Not configured', example='OPEN'),
      defaultAddrPoolName?: string(name='DefaultAddrPoolName', description='The name of the default address pool.'),
      defaultAddrPoolStatus?: string(name='DefaultAddrPoolStatus', description='The availability status of the default address pool. Valid values:

*   **AVAILABLE**: Available
*   **NOT_AVAILABLE**: Unavailable', example='AVAILABLE'),
      failoverAddrPoolId?: string(name='FailoverAddrPoolId', description='The ID of the failover address pool.', example='hra0i2'),
      failoverAddrPoolMonitorStatus?: string(name='FailoverAddrPoolMonitorStatus', description='Indicates whether health check was enabled for the failover address pool.', example='OPEN'),
      failoverAddrPoolName?: string(name='FailoverAddrPoolName', description='The name of the failover address pool.'),
      failoverAddrPoolStatus?: string(name='FailoverAddrPoolStatus', description='The availability status of the failover address pool.', example='AVAILABLE'),
      instanceId?: string(name='InstanceId', description='The ID of the GTM instance whose access policies you want to query.', example='instance1'),
      lines?: {
        line?: [ 
        {
          groupCode?: string(name='GroupCode', description='The code of the access region group.', example='DEFAULT'),
          groupName?: string(name='GroupName', description='The name of the access region group.'),
          lineCode?: string(name='LineCode', description='The code for the line of the access region.', example='default'),
          lineName?: string(name='LineName', description='The name for the line of the access region.'),
        }
      ](name='Line')
      }(name='Lines', description='The returned lines of access regions.'),
      strategyId?: string(name='StrategyId', description='The ID of the access policy.', example='hra0hs'),
      strategyMode?: string(name='StrategyMode', description='The mode of the access policy. **SELF_DEFINED** indicates that the access policy is user-defined.', example='SELF_DEFINED'),
      strategyName?: string(name='StrategyName', description='The name of the access policy.'),
    }
  ](name='Strategy')
  }(name='Strategies', description='The returned list of access policies of the GTM instance.'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned on all pages.', example='1'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeGtmAccessStrategiesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmAccessStrategiesResponseBody(name='body'),
}

async function describeGtmAccessStrategiesWithOptions(request: DescribeGtmAccessStrategiesRequest, runtime: Util.RuntimeOptions): DescribeGtmAccessStrategiesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmAccessStrategies',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmAccessStrategies(request: DescribeGtmAccessStrategiesRequest): DescribeGtmAccessStrategiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmAccessStrategiesWithOptions(request, runtime);
}

model DescribeGtmAccessStrategyRequest {
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy that you want to query.', example='hra0hs'),
}

model DescribeGtmAccessStrategyResponseBody = {
  accessMode?: string(name='AccessMode', description='The access policy.', example='AUTO'),
  accessStatus?: string(name='AccessStatus', description='The access status. Valid values:

*   **DEFAULT**: Indicates normal when the default address pool is accessed.
*   **FAILOVER**: Indicates an exception when a failover address pool is accessed.', example='DEFAULT'),
  defaultAddrPoolMonitorStatus?: string(name='DefaultAddrPoolMonitorStatus', description='Indicates whether health check is enabled for the default address pool.', example='OPEN'),
  defaultAddrPoolName?: string(name='DefaultAddrPoolName', description='The name of the default address pool.'),
  defaultAddrPoolStatus?: string(name='DefaultAddrPoolStatus', description='The availability status of the default address pool.', example='AVAILABLE'),
  defultAddrPoolId?: string(name='DefultAddrPoolId', description='The ID of the default address pool.', example='hra0i1'),
  failoverAddrPoolId?: string(name='FailoverAddrPoolId', description='The ID of the failover address pool.', example='hra0i2'),
  failoverAddrPoolMonitorStatus?: string(name='FailoverAddrPoolMonitorStatus', description='Indicates whether health check is enabled for the failover address pool.', example='OPEN'),
  failoverAddrPoolName?: string(name='FailoverAddrPoolName', description='The name of the failover address pool.'),
  failoverAddrPoolStatus?: string(name='FailoverAddrPoolStatus', description='The availability status of the failover address pool.', example='AVAILABLE'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance whose access policy details you want to query.', example='instance1'),
  lines?: {
    line?: [ 
    {
      groupCode?: string(name='GroupCode', description='The code of the access region group.', example='DEFAULT'),
      groupName?: string(name='GroupName', description='The name of the access region group.', example='Global'),
      lineCode?: string(name='LineCode', description='The code for the line of the access region.', example='default'),
      lineName?: string(name='LineName', description='The name for the line of the access region.', example='Global'),
    }
  ](name='Line')
  }(name='Lines', description='The returned lines of access regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BA1608CA-834C-4E63-8682-8AF0B11ED72D'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy queried.', example='hra0hs'),
  strategyMode?: string(name='StrategyMode', description='The mode of traffic scheduling.', example='SELF_DEFINED'),
  strategyName?: string(name='StrategyName', description='The name of the access policy queried.'),
}

model DescribeGtmAccessStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmAccessStrategyResponseBody(name='body'),
}

async function describeGtmAccessStrategyWithOptions(request: DescribeGtmAccessStrategyRequest, runtime: Util.RuntimeOptions): DescribeGtmAccessStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmAccessStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmAccessStrategy(request: DescribeGtmAccessStrategyRequest): DescribeGtmAccessStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmAccessStrategyWithOptions(request, runtime);
}

model DescribeGtmAccessStrategyAvailableConfigRequest {
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance for which you want to query the available configurations of the current access policy.', example='gtm-cn-xxxx'),
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
}

model DescribeGtmAccessStrategyAvailableConfigResponseBody = {
  addrPools?: {
    addrPool?: [ 
    {
      addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.', example='hra0ix'),
      addrPoolName?: string(name='AddrPoolName', description='The name of the address pool.'),
    }
  ](name='AddrPool')
  }(name='AddrPools', description='The returned list of address pools.'),
  lines?: {
    line?: [ 
    {
      fatherCode?: string(name='FatherCode', description='The code of the parent line for the access region. If no parent line exists, leave this parameter blank.', example='telecom'),
      groupCode?: string(name='GroupCode', description='The code of the access region group.', example='ISP'),
      groupName?: string(name='GroupName', description='The name of the access region group.'),
      lineCode?: string(name='LineCode', description='The code for the line of the access region.', example='cn_telecom_hubei'),
      lineName?: string(name='LineName', description='The name for the line of the access region.'),
      status?: string(name='Status', description='The current status of the line. Valid values:

- **FORBIDDEN**: Unavailable
- **OPTIONAL**: Availabe', example='FORBIDDEN'),
    }
  ](name='Line')
  }(name='Lines', description='The returned lines of access regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C2851BA9-CE56-49AF-8D12-4FC6A49EE688'),
  suggestSetDefaultLine?: boolean(name='SuggestSetDefaultLine'),
}

model DescribeGtmAccessStrategyAvailableConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmAccessStrategyAvailableConfigResponseBody(name='body'),
}

async function describeGtmAccessStrategyAvailableConfigWithOptions(request: DescribeGtmAccessStrategyAvailableConfigRequest, runtime: Util.RuntimeOptions): DescribeGtmAccessStrategyAvailableConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmAccessStrategyAvailableConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmAccessStrategyAvailableConfig(request: DescribeGtmAccessStrategyAvailableConfigRequest): DescribeGtmAccessStrategyAvailableConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmAccessStrategyAvailableConfigWithOptions(request, runtime);
}

model DescribeGtmAvailableAlertGroupRequest {
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
}

model DescribeGtmAvailableAlertGroupResponseBody = {
  availableAlertGroup?: string(name='AvailableAlertGroup', description='The available alert groups of the GTM instance.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
}

model DescribeGtmAvailableAlertGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmAvailableAlertGroupResponseBody(name='body'),
}

async function describeGtmAvailableAlertGroupWithOptions(request: DescribeGtmAvailableAlertGroupRequest, runtime: Util.RuntimeOptions): DescribeGtmAvailableAlertGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmAvailableAlertGroup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmAvailableAlertGroup(request: DescribeGtmAvailableAlertGroupRequest): DescribeGtmAvailableAlertGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmAvailableAlertGroupWithOptions(request, runtime);
}

model DescribeGtmInstanceRequest {
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance.', example='instance1'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters.', example='en'),
  needDetailAttributes?: boolean(name='NeedDetailAttributes', description='Specifies whether additional information is required. Default value: **false**. If the value is **true**, the AccessStrategyNum and AddressPoolNum parameters are returned.', example='false'),
}

model DescribeGtmInstanceResponseBody = {
  accessStrategyNum?: int32(name='AccessStrategyNum', description='The number of access policies of the GTM instance.', example='5'),
  addressPoolNum?: int32(name='AddressPoolNum', description='The number of address pools of the GTM instance.', example='5'),
  alertGroup?: string(name='AlertGroup', description='The alert group of the GTM instance.', example='\\[\\\\"Daily test - R\\&D group\\\\"]'),
  cname?: string(name='Cname', description='The domain name of the GTM instance to which the service domain name is mapped by using a CNAME record.', example='instance1.14.com'),
  cnameMode?: string(name='CnameMode', description='Indicates whether the CNAME is a custom domain name or is assigned by the system. Valid values:

*   **SYSTEM_ASSIGN**
*   **CUSTOM**', example='SYSTEM_ASSIGN'),
  createTime?: string(name='CreateTime', description='The time when the GTM instance was created.', example='2018-06-06T11:34Z'),
  createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates the time when the GTM instance was created.', example='1528284856000'),
  expireTime?: string(name='ExpireTime', description='The time when the GTM instance expires.', example='2018-06-06T11:34Z'),
  expireTimestamp?: long(name='ExpireTimestamp', description='The timestamp that indicates the time when the GTM instance expires.', example='1528284856000'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance.', example='instance1'),
  instanceName?: string(name='InstanceName', description='The name of the GTM instance.', example='test'),
  lbaStrategy?: string(name='LbaStrategy', description='The load balancing policy. Valid values:

*   **ALL_RR**: round robin
*   **RATIO**: weighted round-robin', example='RATIO'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E41AA251-F9BA-48C6-99B2-2B82B26A573A'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-testgroupid'),
  ttl?: int32(name='Ttl', description='The global time to live (TTL).', example='60'),
  userDomainName?: string(name='UserDomainName', description='The domain name of the application.', example='www.example.com'),
  versionCode?: string(name='VersionCode', description='The version code.', example='biaozhun'),
}

model DescribeGtmInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmInstanceResponseBody(name='body'),
}

async function describeGtmInstanceWithOptions(request: DescribeGtmInstanceRequest, runtime: Util.RuntimeOptions): DescribeGtmInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.needDetailAttributes)) {
    query['NeedDetailAttributes'] = request.needDetailAttributes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmInstance',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmInstance(request: DescribeGtmInstanceRequest): DescribeGtmInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmInstanceWithOptions(request, runtime);
}

model DescribeGtmInstanceAddressPoolRequest {
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool that you want to query.', example='1234'),
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
}

model DescribeGtmInstanceAddressPoolResponseBody = {
  addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool queried.', example='2'),
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.', example='1234abc'),
  addrs?: {
    addr?: [ 
    {
      addrId?: long(name='AddrId', description='The ID of the address.', example='123'),
      alertStatus?: string(name='AlertStatus', description='Indicates whether health check was enabled for the address. Valid values:

*   **OK**: Normal
*   **ALERT**: Alert', example='OK'),
      createTime?: string(name='CreateTime', description='The time when the address pool was created.', example='2017-12-28T13:08Z'),
      createTimestamp?: long(name='CreateTimestamp', example='1527690629357'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address.', example='1'),
      mode?: string(name='Mode', description='The mode of the address. Valid values:

*   **SMART**: Intelligent return
*   **ONLINE**: Always online
*   **OFFLINE**: Always offline', example='SMART'),
      updateTime?: string(name='UpdateTime', description='The last time when the address was updated.', example='2017-12-28T13:08Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='A timestamp that indicates the last time when the address was updated.', example='1527690629357'),
      value?: string(name='Value', description='The address.', example='1.1.1.1'),
    }
  ](name='Addr')
  }(name='Addrs', description='The addresses in the address pool.'),
  createTime?: string(name='CreateTime', description='The time when the address pool was created.', example='2017-12-28T13:08Z'),
  createTimestamp?: long(name='CreateTimestamp', example='1527690629357'),
  minAvailableAddrNum?: int32(name='MinAvailableAddrNum', description='The minimum number of available addresses in the address pool.', example='2'),
  monitorConfigId?: string(name='MonitorConfigId', description='The health check ID of the address pool.', example='100abc'),
  monitorStatus?: string(name='MonitorStatus', description='Indicates whether health check was enabled for the address pool. Valid values:

*   **OPEN**: Enabled
*   **CLOSE**: Disabled
*   **UNCONFIGURED**: Not configured', example='OPEN'),
  name?: string(name='Name', description='The name of the address pool.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  status?: string(name='Status', description='The availability status of the address pool. Valid values:

*   **AVAILABLE**: Available
*   **NOT_AVAILABLE**: Unavailable', example='AVAILABLE'),
  type?: string(name='Type', description='The type of the address pool. Valid values:

*   **IP**: IP address
*   **DOMAIN**: Domain name', example='IP'),
  updateTime?: string(name='UpdateTime', description='The last time when the address pool was updated.', example='2017-12-28T13:08Z'),
  updateTimestamp?: long(name='UpdateTimestamp', description='A timestamp that indicates the last time the address pool was updated.', example='1527690629357'),
}

model DescribeGtmInstanceAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmInstanceAddressPoolResponseBody(name='body'),
}

async function describeGtmInstanceAddressPoolWithOptions(request: DescribeGtmInstanceAddressPoolRequest, runtime: Util.RuntimeOptions): DescribeGtmInstanceAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addrPoolId)) {
    query['AddrPoolId'] = request.addrPoolId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmInstanceAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmInstanceAddressPool(request: DescribeGtmInstanceAddressPoolRequest): DescribeGtmInstanceAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmInstanceAddressPoolWithOptions(request, runtime);
}

model DescribeGtmInstanceAddressPoolsRequest {
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance that you want to query.', example='gtmtest'),
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return per page. Maximum value: **100**. Default value: **20**.', example='20'),
}

model DescribeGtmInstanceAddressPoolsResponseBody = {
  addrPools?: {
    addrPool?: [ 
    {
      addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='2'),
      addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.', example='1234abc'),
      createTime?: string(name='CreateTime', description='The time when this address pool was created.', example='2017-12-28T13:08Z'),
      createTimestamp?: long(name='CreateTimestamp', example='1527690629357'),
      minAvailableAddrNum?: int32(name='MinAvailableAddrNum', description='The minimum number of available addresses in the address pool.', example='2'),
      monitorConfigId?: string(name='MonitorConfigId', description='The health check ID of the address pool.', example='100abc'),
      monitorStatus?: string(name='MonitorStatus', description='Indicates whether health check was enabled for the address pool. Valid values:

*   **OPEN**: Enabled
*   **CLOSE**: Disabled
*   **UNCONFIGURED**: Not configured', example='OPEN'),
      name?: string(name='Name', description='The name of the address pool.'),
      status?: string(name='Status', description='The availability status of the address pool. Valid values:

*   **AVAILABLE**: Available
*   **NOT_AVAILABLE**: Unavailable', example='AVAILABLE'),
      type?: string(name='Type', description='The type of the address pool. Valid values:

*   **IP**: IP address
*   **DOMAIN**: Domain name', example='IP'),
      updateTime?: string(name='UpdateTime', description='The last time when the address pool was updated.', example='2017-12-28T13:08Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='A timestamp that indicates the last time the address pool was updated.', example='1527690629357'),
    }
  ](name='AddrPool')
  }(name='AddrPools', description='The returned list of address pools of the GTM instance.'),
  pageNumber?: int32(name='PageNumber', description='The number of the page returned.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned on all pages.', example='2'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeGtmInstanceAddressPoolsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmInstanceAddressPoolsResponseBody(name='body'),
}

async function describeGtmInstanceAddressPoolsWithOptions(request: DescribeGtmInstanceAddressPoolsRequest, runtime: Util.RuntimeOptions): DescribeGtmInstanceAddressPoolsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmInstanceAddressPools',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmInstanceAddressPools(request: DescribeGtmInstanceAddressPoolsRequest): DescribeGtmInstanceAddressPoolsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmInstanceAddressPoolsWithOptions(request, runtime);
}

model DescribeGtmInstanceStatusRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance to query.', example='instance1'),
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.', example='en'),
}

model DescribeGtmInstanceStatusResponseBody = {
  addrNotAvailableNum?: int32(name='AddrNotAvailableNum', description='The number of unavailable addresses.', example='10'),
  addrPoolNotAvailableNum?: int32(name='AddrPoolNotAvailableNum', description='The number of unavailable address pools.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='389DFFA3-77A5-4A9E-BF3D-147C6F98A5BA'),
  status?: string(name='Status', description='The status of the instance. Valid values:

*   ALLOW: Operations on the instance are allowed.
*   DENY: Operations on the instance are not allowed.', example='ALLOW'),
  statusReason?: string(name='StatusReason', description='List of reasons for an instance status. Valid values:

*   INSTANCE_OPERATE_BLACK_LIST: The instance is in the blacklist.
*   BETA_INSTANCE: The instance is in public preview.', example='["BETA_INSTANCE"]'),
  strategyNotAvailableNum?: int32(name='StrategyNotAvailableNum', description='The number of access policies that are unavailable in the active address pool.', example='10'),
  switchToFailoverStrategyNum?: int32(name='SwitchToFailoverStrategyNum', description='The number of access policies that fail over to the secondary address pool.', example='10'),
}

model DescribeGtmInstanceStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmInstanceStatusResponseBody(name='body'),
}

async function describeGtmInstanceStatusWithOptions(request: DescribeGtmInstanceStatusRequest, runtime: Util.RuntimeOptions): DescribeGtmInstanceStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmInstanceStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmInstanceStatus(request: DescribeGtmInstanceStatusRequest): DescribeGtmInstanceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmInstanceStatusWithOptions(request, runtime);
}

model DescribeGtmInstanceSystemCnameRequest {
  instanceId?: string(name='InstanceId', description='The ID of the Global Traffic Manager (GTM) instance.', example='instance1'),
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
}

model DescribeGtmInstanceSystemCnameResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  systemCname?: string(name='SystemCname', description='The CNAME record assigned by the system.', example='gtm-cn-mp91004xxxx.gtm-a2b4.com'),
}

model DescribeGtmInstanceSystemCnameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmInstanceSystemCnameResponseBody(name='body'),
}

async function describeGtmInstanceSystemCnameWithOptions(request: DescribeGtmInstanceSystemCnameRequest, runtime: Util.RuntimeOptions): DescribeGtmInstanceSystemCnameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmInstanceSystemCname',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmInstanceSystemCname(request: DescribeGtmInstanceSystemCnameRequest): DescribeGtmInstanceSystemCnameResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmInstanceSystemCnameWithOptions(request, runtime);
}

model DescribeGtmInstancesRequest {
  keyword?: string(name='Keyword', description='The keyword that you use for query. Exact match is supported by instance ID or instance name.', example='test'),
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.', example='en'),
  needDetailAttributes?: boolean(name='NeedDetailAttributes', description='Specifies whether additional information is required. Default value: **false**.', example='false'),
  pageNumber?: int32(name='PageNumber', description='The page number to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return per page.', example='20'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-xxxxx'),
}

model DescribeGtmInstancesResponseBody = {
  gtmInstances?: {
    gtmInstance?: [ 
    {
      accessStrategyNum?: int32(name='AccessStrategyNum', description='The number of access policies.', example='5'),
      addressPoolNum?: int32(name='AddressPoolNum', description='The number of address pools.', example='5'),
      alertGroup?: string(name='AlertGroup', description='The name of the alert group.', example='\\[\\\\"R\\&D group\\\\"]'),
      cname?: string(name='Cname', description='The CNAME domain name that is used to access the instance.', example='instance1.14.com'),
      cnameMode?: string(name='CnameMode', description='The CNAME domain name used to access the instance. Valid values:

*   **SYSTEM_ASSIGN**: A CNAME domain name assigned by the system is used.
*   **CUSTOM**: A custom CNAME domain name is used.', example='SYSTEM_ASSIGN'),
      createTime?: string(name='CreateTime', description='The time when the instance was created.', example='2018-06-06T11:34Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The UNIX timestamp that indicates when the instance was created.', example='1528284856000'),
      expireTime?: string(name='ExpireTime', description='The time when the instance expires.', example='2018-06-06T11:34Z'),
      expireTimestamp?: long(name='ExpireTimestamp', description='The UNIX timestamp that indicates when the instance expires.', example='1528284856000'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='instance1'),
      instanceName?: string(name='InstanceName', description='The name of the instance.', example='test'),
      lbaStrategy?: string(name='LbaStrategy', description='The load balancing policy that is used. Valid values:

*   **ALL_RR**: Load balancing
*   **RATIO**: Weighted round-robin', example='RATIO'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs.', example='rg-acfm2q2jqpjh***'),
      ttl?: int32(name='Ttl', description='The global time to live (TTL).', example='60'),
      userDomainName?: string(name='UserDomainName', description='The domain name of the user.', example='www.example.com'),
      versionCode?: string(name='VersionCode', description='The version code of the instance.', example='biaozhun'),
    }
  ](name='GtmInstance')
  }(name='GtmInstances', description='The list of queried instances.'),
  pageNumber?: int32(name='PageNumber', description='The returned page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='193B0163-7F93-42DF-AB05-ACEEB7D22707'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned.', example='1'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeGtmInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmInstancesResponseBody(name='body'),
}

async function describeGtmInstancesWithOptions(request: DescribeGtmInstancesRequest, runtime: Util.RuntimeOptions): DescribeGtmInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.needDetailAttributes)) {
    query['NeedDetailAttributes'] = request.needDetailAttributes;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmInstances',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmInstances(request: DescribeGtmInstancesRequest): DescribeGtmInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmInstancesWithOptions(request, runtime);
}

model DescribeGtmLogsRequest {
  endTimestamp?: long(name='EndTimestamp', example='1363453340000'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance whose logs you want to query.', example='gtm-cn-xxxxx'),
  keyword?: string(name='Keyword', description='The keyword for searching logs, in case-insensitive "%Keyword%" format.', example='test'),
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: **100**. Default value: **20**.', example='20'),
  startTimestamp?: long(name='StartTimestamp', description='The beginning of the time range to query.', example='1363453340000'),
}

model DescribeGtmLogsResponseBody = {
  logs?: {
    log?: [ 
    {
      content?: string(name='Content', description='The formatted message content.', example='addtest-pool-1'),
      entityId?: string(name='EntityId', description='The ID of the object that was operated on.', example='121212'),
      entityName?: string(name='EntityName', description='The name of the object that was operated on.', example='test-pool-1'),
      entityType?: string(name='EntityType', description='The type of the object that was operated on.', example='POOL'),
      id?: long(name='Id', description='The ID of the log record.', example='6726'),
      operAction?: string(name='OperAction', description='The operation performed.', example='add'),
      operIp?: string(name='OperIp', description='The IP address subject to the operation.', example='106.11.34.X'),
      operTime?: string(name='OperTime', description='The time when the operation was performed.', example='2018-01-24T07:35Z'),
      operTimestamp?: long(name='OperTimestamp', description='A timestamp that indicates the time when the operation was performed.', example='1516779348000'),
    }
  ](name='Log')
  }(name='Logs', description='The list of logs returned.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='50C60A29-2E93-425A-ABA8-068686E28873'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned on all pages.', example='224'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='224'),
}

model DescribeGtmLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmLogsResponseBody(name='body'),
}

async function describeGtmLogsWithOptions(request: DescribeGtmLogsRequest, runtime: Util.RuntimeOptions): DescribeGtmLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTimestamp)) {
    query['EndTimestamp'] = request.endTimestamp;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTimestamp)) {
    query['StartTimestamp'] = request.startTimestamp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmLogs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmLogs(request: DescribeGtmLogsRequest): DescribeGtmLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmLogsWithOptions(request, runtime);
}

model DescribeGtmMonitorAvailableConfigRequest {
  lang?: string(name='Lang', description='The language of the values of specific response parameters.', example='en'),
}

model DescribeGtmMonitorAvailableConfigResponseBody = {
  ispCityNodes?: {
    ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the city where the monitored node is deployed.', example='503'),
      cityName?: string(name='CityName', description='The display name of the city where the monitored node is deployed.', example='Zhangjiakou'),
      defaultSelected?: boolean(name='DefaultSelected', description='Indicates whether the monitored node is selected for the health check by default.', example='true'),
      groupName?: string(name='GroupName', description='The name of the group to which the monitored node belongs.

Valid values: Overseas Nodes, BGP Nodes, and ISP Nodes.', example='Overseas Nodes'),
      groupType?: string(name='GroupType', description='The type of the group to which the monitored node belongs.

Valid values: BGP, OVERSEAS, and ISP.', example='OVERSEAS'),
      ispCode?: string(name='IspCode', description='The code of the Internet service provider (ISP) to which the monitored node belongs.

*   If the value of the GroupType parameter is BGP or OVERSEAS, the value of IspCode is 465 by default.
*   If the value of the GroupType parameter is not BGP or OVERSEAS, valid values of IspCode are 232, 132, and 5. and is used together with CityCode.', example='465'),
      ispName?: string(name='IspName', description='The display name of the ISP to which the monitored node belongs.', example='Alibaba'),
      mainland?: boolean(name='Mainland', description='Indicates whether the monitored node is deployed in the Chinese mainland.', example='true'),
    }
  ](name='IspCityNode')
  }(name='IspCityNodes', description='The monitored nodes.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model DescribeGtmMonitorAvailableConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmMonitorAvailableConfigResponseBody(name='body'),
}

async function describeGtmMonitorAvailableConfigWithOptions(request: DescribeGtmMonitorAvailableConfigRequest, runtime: Util.RuntimeOptions): DescribeGtmMonitorAvailableConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmMonitorAvailableConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmMonitorAvailableConfig(request: DescribeGtmMonitorAvailableConfigRequest): DescribeGtmMonitorAvailableConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmMonitorAvailableConfigWithOptions(request, runtime);
}

model DescribeGtmMonitorConfigRequest {
  lang?: string(name='Lang', description='The language of the values of specific response parameters.', example='en'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.', example='100'),
}

model DescribeGtmMonitorConfigResponseBody = {
  createTime?: string(name='CreateTime', description='The time when the health check configuration was created.', example='2017-12-28T13:08Z'),
  createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates the time when the health check configuration was created.', example='1527690629357'),
  evaluationCount?: int32(name='EvaluationCount', description='The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.', example='3'),
  interval?: int32(name='Interval', description='The health check interval. Unit: seconds. The value is 60.', example='60'),
  ispCityNodes?: {
    ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the city where the monitored node is deployed.', example='503'),
      cityName?: string(name='CityName', description='The display name of the city where the monitored node is deployed.', example='Zhangjiakou'),
      countryCode?: string(name='CountryCode', description='The code of the country where the monitored node is deployed.', example='001'),
      countryName?: string(name='CountryName', description='The display name of the country where the monitored node is deployed.', example='China'),
      ispCode?: string(name='IspCode', description='The code of the Internet service provider (ISP) to which the monitored node belongs.', example='465'),
      ispName?: string(name='IspName', description='The display name of the ISP to which the monitored node belongs.', example='Alibaba'),
    }
  ](name='IspCityNode')
  }(name='IspCityNodes', description='The monitored nodes.'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.', example='1234abc'),
  monitorExtendInfo?: string(name='MonitorExtendInfo', description='The extended information, that is, the parameters required for the protocol. Different protocols require different parameters:

HTTP or HTTPS:

*   port: the port to check.
*   failureRate: the failure rate.
*   code: the status code threshold. If the returned status code is greater than the specified threshold, the application service is deemed abnormal. Valid values: 400 and 500.
*   host: the host configuration.
*   path: the health check URL.

PING:

*   packetNum: the number of ping packets.
*   packetLossRate: the loss rate of ping packets.
*   failureRate: the failure rate.

TCP:

*   port: the port to check.
*   failureRate: the failure rate.', example='{\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}'),
  protocolType?: string(name='ProtocolType', description='The protocol used for the health check.', example='HTTP'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  timeout?: int32(name='Timeout', description='The health check timeout period. Unit: milliseconds. Valid values: 2000, 3000, 5000, and 10000.', example='3000'),
  updateTime?: string(name='UpdateTime', description='The time when the health check configuration was last updated.', example='2017-12-28T13:08Z'),
  updateTimestamp?: long(name='UpdateTimestamp', description='The timestamp that indicates the time when the health check configuration was last updated.', example='1527690629357'),
}

model DescribeGtmMonitorConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmMonitorConfigResponseBody(name='body'),
}

async function describeGtmMonitorConfigWithOptions(request: DescribeGtmMonitorConfigRequest, runtime: Util.RuntimeOptions): DescribeGtmMonitorConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.monitorConfigId)) {
    query['MonitorConfigId'] = request.monitorConfigId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmMonitorConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmMonitorConfig(request: DescribeGtmMonitorConfigRequest): DescribeGtmMonitorConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmMonitorConfigWithOptions(request, runtime);
}

model DescribeGtmRecoveryPlanRequest {
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  recoveryPlanId?: long(name='RecoveryPlanId', description='The ID of the disaster recovery plan that you want to query.', example='100'),
}

model DescribeGtmRecoveryPlanResponseBody = {
  createTime?: string(name='CreateTime', description='The time when the disaster recovery plan was created.', example='2019-08-11T05:04Z'),
  createTimestamp?: long(name='CreateTimestamp', example='1565499867000'),
  faultAddrPoolNum?: int32(name='FaultAddrPoolNum', description='The number of faulty address pools.', example='2'),
  faultAddrPools?: {
    faultAddrPool?: [ 
    {
      addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.', example='hra0oq'),
      addrPoolName?: string(name='AddrPoolName', description='The name of the address pool.'),
      addrs?: {
        addr?: [ 
        {
          id?: long(name='Id', description='The ID of the address.', example='739'),
          mode?: string(name='Mode', description='The address work mode. It is the mode that was set for the IP address to work.', example='OFFLINE'),
          value?: string(name='Value', description='The address value.', example='1.1.1.1'),
        }
      ](name='Addr')
      }(name='Addrs', description='The list of addresses in the address pool.'),
      instanceId?: string(name='InstanceId', description='The ID of the GTM instance.', example='instance-zwy-38'),
    }
  ](name='FaultAddrPool')
  }(name='FaultAddrPools', description='The list of faulty address pools.'),
  lastExecuteTime?: string(name='LastExecuteTime', description='The last time when the recovery plan was executed.', example='2019-08-11T05:04Z'),
  lastExecuteTimestamp?: long(name='LastExecuteTimestamp', description='A timestamp that indicates the last time when the recovery plan was executed.', example='1565505898000'),
  lastRollbackTime?: string(name='LastRollbackTime', description='The last time when the disaster recovery plan was rolled back.', example='2019-08-11T06:45Z'),
  lastRollbackTimestamp?: long(name='LastRollbackTimestamp', description='A timestamp that indicates the last time when the disaster recovery plan was rolled back.', example='1565505919000'),
  name?: string(name='Name', description='The name of the disaster recovery plan queried.', example='name-example'),
  recoveryPlanId?: long(name='RecoveryPlanId', description='The ID of the disaster recovery plan queried.', example='55'),
  remark?: string(name='Remark', description='The remarks on the disaster recovery plan.', example='remark-example'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0A5F4315-D6E8-435E-82DF-24F4C97D6999'),
  status?: string(name='Status', description='The status of the disaster recovery plan queried.', example='UNEXECUTED'),
  updateTime?: string(name='UpdateTime', description='The last time when the disaster recovery plan was updated.', example='2019-08-11T06:45Z'),
  updateTimestamp?: long(name='UpdateTimestamp', description='A timestamp that indicates the last time when the disaster recovery plan was updated.', example='1565499867000'),
}

model DescribeGtmRecoveryPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmRecoveryPlanResponseBody(name='body'),
}

async function describeGtmRecoveryPlanWithOptions(request: DescribeGtmRecoveryPlanRequest, runtime: Util.RuntimeOptions): DescribeGtmRecoveryPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recoveryPlanId)) {
    query['RecoveryPlanId'] = request.recoveryPlanId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmRecoveryPlan',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmRecoveryPlan(request: DescribeGtmRecoveryPlanRequest): DescribeGtmRecoveryPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmRecoveryPlanWithOptions(request, runtime);
}

model DescribeGtmRecoveryPlanAvailableConfigRequest {
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
}

model DescribeGtmRecoveryPlanAvailableConfigResponseBody = {
  instances?: {
    instance?: [ 
    {
      addrPools?: {
        addrPool?: [ 
        {
          addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.'),
          name?: string(name='Name', description='The name of the address pool.', example='hra0i9'),
        }
      ](name='AddrPool')
      }(name='AddrPools', description='The list of address pools for the GTM instance.'),
      instanceId?: string(name='InstanceId', description='The ID of the GTM instance.', example='instance-example'),
      instanceName?: string(name='InstanceName', description='The name of the GTM instance.', example='instance-name-example'),
    }
  ](name='Instance')
  }(name='Instances', description='The list of GTM instances involved in the disaster recovery plan.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F8F8EF50-8B7F-4702-B294-97170A423403'),
}

model DescribeGtmRecoveryPlanAvailableConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmRecoveryPlanAvailableConfigResponseBody(name='body'),
}

async function describeGtmRecoveryPlanAvailableConfigWithOptions(request: DescribeGtmRecoveryPlanAvailableConfigRequest, runtime: Util.RuntimeOptions): DescribeGtmRecoveryPlanAvailableConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmRecoveryPlanAvailableConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmRecoveryPlanAvailableConfig(request: DescribeGtmRecoveryPlanAvailableConfigRequest): DescribeGtmRecoveryPlanAvailableConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmRecoveryPlanAvailableConfigWithOptions(request, runtime);
}

model DescribeGtmRecoveryPlansRequest {
  keyword?: string(name='Keyword', description='The keyword for the query. Fuzzy match is supported by disaster recovery plan name.', example='test'),
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.', example='en'),
  pageNumber?: int32(name='PageNumber', description='The page number to return. The page number starts from **1**. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return per page. Maximum value: **100**. Default value: **20**.', example='20'),
}

model DescribeGtmRecoveryPlansResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  recoveryPlans?: {
    recoveryPlan?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the disaster recovery plan was created.', example='2019-08-11T06:45Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The UNIX timestamp that indicates when the disaster recovery plan was created.', example='1565499867000'),
      faultAddrPoolNum?: int32(name='FaultAddrPoolNum', description='The number of faulty address pools.', example='0'),
      lastExecuteTime?: string(name='LastExecuteTime', description='The last time when the disaster recovery plan was executed.', example='2019-08-11T06:44Z'),
      lastExecuteTimestamp?: long(name='LastExecuteTimestamp', description='The UNIX timestamp that indicates the last time when the disaster recovery plan was executed.', example='1565505898000'),
      lastRollbackTime?: string(name='LastRollbackTime', description='The last time when the disaster recovery plan was rolled back.', example='2019-08-11T06:45Z'),
      lastRollbackTimestamp?: long(name='LastRollbackTimestamp', description='The UNIX timestamp that indicates the last time when the disaster recovery plan was rolled back.', example='1565505919000'),
      name?: string(name='Name', description='The name of the disaster recovery plan.', example='name-example'),
      recoveryPlanId?: long(name='RecoveryPlanId', description='The ID of the disaster recovery plan.', example='55'),
      remark?: string(name='Remark', description='The remarks about the disaster recovery plan.', example='remark-example'),
      status?: string(name='Status', description='The status of the disaster recovery plan. Valid values:

*   **UNEXECUTED**: The plan is not executed.
*   **EXECUTED**: The plan is executed.
*   **ROLLED_BACK**: The plan is rolled back.', example='UNEXECUTED'),
      updateTime?: string(name='UpdateTime', description='The last time when the disaster recovery plan was updated.', example='2019-08-11T06:45Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The UNIX timestamp that indicates the last time when the disaster recovery plan was updated.', example='1565505919000'),
    }
  ](name='RecoveryPlan')
  }(name='RecoveryPlans', description='The details about the queried disaster recovery plans.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2BA072CF-CA21-4A34-B6C2-227BE2C58079'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned.', example='10'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeGtmRecoveryPlansResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmRecoveryPlansResponseBody(name='body'),
}

async function describeGtmRecoveryPlansWithOptions(request: DescribeGtmRecoveryPlansRequest, runtime: Util.RuntimeOptions): DescribeGtmRecoveryPlansResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmRecoveryPlans',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmRecoveryPlans(request: DescribeGtmRecoveryPlansRequest): DescribeGtmRecoveryPlansResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmRecoveryPlansWithOptions(request, runtime);
}

model DescribeInstanceDomainsRequest {
  instanceId?: string(name='InstanceId', example='weriwieru'),
  lang?: string(name='Lang', example='en'),
  pageNumber?: long(name='PageNumber', example='1'),
  pageSize?: long(name='PageSize', example='2'),
}

model DescribeInstanceDomainsResponseBody = {
  instanceDomains?: [ 
    {
      createTime?: string(name='CreateTime', example='2020-03-09T02:15Z'),
      createTimestamp?: long(name='CreateTimestamp', example='1583720154000'),
      domainName?: string(name='DomainName', example='example.com'),
    }
  ](name='InstanceDomains'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='2'),
  requestId?: string(name='RequestId', example='68386699-8B9E-4D5B-BC4C-75A28F6C2A00'),
  totalItems?: int32(name='TotalItems', example='2'),
  totalPages?: int32(name='TotalPages', example='2'),
}

model DescribeInstanceDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceDomainsResponseBody(name='body'),
}

async function describeInstanceDomainsWithOptions(request: DescribeInstanceDomainsRequest, runtime: Util.RuntimeOptions): DescribeInstanceDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceDomains',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceDomains(request: DescribeInstanceDomainsRequest): DescribeInstanceDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceDomainsWithOptions(request, runtime);
}

model DescribeIspFlushCacheInstancesRequest {
  direction?: string(name='Direction'),
  isp?: string(name='Isp'),
  keyword?: string(name='Keyword'),
  lang?: string(name='Lang'),
  orderBy?: string(name='OrderBy'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  type?: string(name='Type'),
}

model DescribeIspFlushCacheInstancesResponseBody = {
  ispFlushCacheInstances?: [ 
    {
      expireTime?: string(name='ExpireTime'),
      expireTimestamp?: long(name='ExpireTimestamp'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      isp?: string(name='Isp'),
      quotaInfo?: {
        instanceQuota?: int32(name='InstanceQuota'),
        instanceQuotaUsed?: int32(name='InstanceQuotaUsed'),
      }(name='QuotaInfo'),
      status?: string(name='Status'),
      versionCode?: string(name='VersionCode'),
    }
  ](name='IspFlushCacheInstances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeIspFlushCacheInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIspFlushCacheInstancesResponseBody(name='body'),
}

async function describeIspFlushCacheInstancesWithOptions(request: DescribeIspFlushCacheInstancesRequest, runtime: Util.RuntimeOptions): DescribeIspFlushCacheInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.isp)) {
    query['Isp'] = request.isp;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIspFlushCacheInstances',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIspFlushCacheInstances(request: DescribeIspFlushCacheInstancesRequest): DescribeIspFlushCacheInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIspFlushCacheInstancesWithOptions(request, runtime);
}

model DescribeIspFlushCacheRemainQuotaRequest {
  lang?: string(name='Lang'),
}

model DescribeIspFlushCacheRemainQuotaResponseBody = {
  requestId?: string(name='RequestId'),
  telecomRemainQuota?: int32(name='TelecomRemainQuota'),
}

model DescribeIspFlushCacheRemainQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIspFlushCacheRemainQuotaResponseBody(name='body'),
}

async function describeIspFlushCacheRemainQuotaWithOptions(request: DescribeIspFlushCacheRemainQuotaRequest, runtime: Util.RuntimeOptions): DescribeIspFlushCacheRemainQuotaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIspFlushCacheRemainQuota',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIspFlushCacheRemainQuota(request: DescribeIspFlushCacheRemainQuotaRequest): DescribeIspFlushCacheRemainQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIspFlushCacheRemainQuotaWithOptions(request, runtime);
}

model DescribeIspFlushCacheTaskRequest {
  lang?: string(name='Lang'),
  taskId?: string(name='TaskId'),
}

model DescribeIspFlushCacheTaskResponseBody = {
  createTime?: string(name='CreateTime'),
  createTimestamp?: long(name='CreateTimestamp'),
  domainName?: string(name='DomainName'),
  flushCacheResults?: [ 
    {
      dnsNodes?: [ 
        {
          answers?: [ 
            {
              name?: string(name='Name'),
              record?: string(name='Record'),
              ttl?: long(name='Ttl'),
              type?: string(name='Type'),
            }
          ](name='Answers'),
          nodeIp?: string(name='NodeIp'),
          spName?: string(name='SpName'),
          status?: string(name='Status'),
        }
      ](name='DnsNodes'),
      province?: string(name='Province'),
    }
  ](name='FlushCacheResults'),
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  isp?: string(name='Isp'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
  taskStatus?: string(name='TaskStatus'),
}

model DescribeIspFlushCacheTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIspFlushCacheTaskResponseBody(name='body'),
}

async function describeIspFlushCacheTaskWithOptions(request: DescribeIspFlushCacheTaskRequest, runtime: Util.RuntimeOptions): DescribeIspFlushCacheTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIspFlushCacheTask',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIspFlushCacheTask(request: DescribeIspFlushCacheTaskRequest): DescribeIspFlushCacheTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIspFlushCacheTaskWithOptions(request, runtime);
}

model DescribeIspFlushCacheTasksRequest {
  direction?: string(name='Direction'),
  domainName?: string(name='DomainName'),
  instanceId?: string(name='InstanceId'),
  isp?: string(name='Isp'),
  lang?: string(name='Lang'),
  orderBy?: string(name='OrderBy'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeIspFlushCacheTasksResponseBody = {
  ispFlushCacheTasks?: [ 
    {
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      domainName?: string(name='DomainName'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      isp?: string(name='Isp'),
      taskId?: string(name='TaskId'),
      taskStatus?: string(name='TaskStatus'),
    }
  ](name='IspFlushCacheTasks'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeIspFlushCacheTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIspFlushCacheTasksResponseBody(name='body'),
}

async function describeIspFlushCacheTasksWithOptions(request: DescribeIspFlushCacheTasksRequest, runtime: Util.RuntimeOptions): DescribeIspFlushCacheTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.isp)) {
    query['Isp'] = request.isp;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIspFlushCacheTasks',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIspFlushCacheTasks(request: DescribeIspFlushCacheTasksRequest): DescribeIspFlushCacheTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIspFlushCacheTasksWithOptions(request, runtime);
}

model DescribePdnsAccountSummaryRequest {
  endDate?: string(name='EndDate'),
  lang?: string(name='Lang'),
  startDate?: string(name='StartDate'),
}

model DescribePdnsAccountSummaryResponseBody = {
  data?: {
    domainCount?: long(name='DomainCount'),
    httpCount?: long(name='HttpCount'),
    httpsCount?: long(name='HttpsCount'),
    subDomainCount?: long(name='SubDomainCount'),
    threatCount?: long(name='ThreatCount'),
    totalCount?: long(name='TotalCount'),
    userId?: long(name='UserId'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribePdnsAccountSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePdnsAccountSummaryResponseBody(name='body'),
}

async function describePdnsAccountSummaryWithOptions(request: DescribePdnsAccountSummaryRequest, runtime: Util.RuntimeOptions): DescribePdnsAccountSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsAccountSummary',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePdnsAccountSummary(request: DescribePdnsAccountSummaryRequest): DescribePdnsAccountSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsAccountSummaryWithOptions(request, runtime);
}

model DescribePdnsAppKeyRequest {
  appKeyId?: string(name='AppKeyId'),
  lang?: string(name='Lang'),
}

model DescribePdnsAppKeyResponseBody = {
  appKey?: {
    appKeyId?: string(name='AppKeyId'),
    appKeySecret?: string(name='AppKeySecret'),
    createDate?: string(name='CreateDate'),
    state?: string(name='State'),
  }(name='AppKey'),
  requestId?: string(name='RequestId'),
}

model DescribePdnsAppKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePdnsAppKeyResponseBody(name='body'),
}

async function describePdnsAppKeyWithOptions(request: DescribePdnsAppKeyRequest, runtime: Util.RuntimeOptions): DescribePdnsAppKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appKeyId)) {
    query['AppKeyId'] = request.appKeyId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsAppKey',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePdnsAppKey(request: DescribePdnsAppKeyRequest): DescribePdnsAppKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsAppKeyWithOptions(request, runtime);
}

model DescribePdnsAppKeysRequest {
  lang?: string(name='Lang'),
}

model DescribePdnsAppKeysResponseBody = {
  appKeys?: [ 
    {
      appKeyId?: string(name='AppKeyId'),
      createDate?: string(name='CreateDate'),
      state?: string(name='State'),
    }
  ](name='AppKeys'),
  requestId?: string(name='RequestId'),
}

model DescribePdnsAppKeysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePdnsAppKeysResponseBody(name='body'),
}

async function describePdnsAppKeysWithOptions(request: DescribePdnsAppKeysRequest, runtime: Util.RuntimeOptions): DescribePdnsAppKeysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsAppKeys',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePdnsAppKeys(request: DescribePdnsAppKeysRequest): DescribePdnsAppKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsAppKeysWithOptions(request, runtime);
}

model DescribePdnsOperateLogsRequest {
  actionType?: string(name='ActionType'),
  endDate?: string(name='EndDate'),
  keyword?: string(name='Keyword'),
  lang?: string(name='Lang'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  startDate?: string(name='StartDate'),
}

model DescribePdnsOperateLogsResponseBody = {
  logs?: [ 
    {
      action?: string(name='Action'),
      operateTime?: string(name='OperateTime'),
      type?: string(name='Type'),
      content?: string(name='content'),
    }
  ](name='Logs'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePdnsOperateLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePdnsOperateLogsResponseBody(name='body'),
}

async function describePdnsOperateLogsWithOptions(request: DescribePdnsOperateLogsRequest, runtime: Util.RuntimeOptions): DescribePdnsOperateLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actionType)) {
    query['ActionType'] = request.actionType;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsOperateLogs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePdnsOperateLogs(request: DescribePdnsOperateLogsRequest): DescribePdnsOperateLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsOperateLogsWithOptions(request, runtime);
}

model DescribePdnsRequestStatisticRequest {
  domainName?: string(name='DomainName'),
  endDate?: string(name='EndDate'),
  lang?: string(name='Lang'),
  startDate?: string(name='StartDate'),
  subDomain?: string(name='SubDomain'),
}

model DescribePdnsRequestStatisticResponseBody = {
  data?: [ 
    {
      dohTotalCount?: long(name='DohTotalCount'),
      httpCount?: long(name='HttpCount'),
      httpsCount?: long(name='HttpsCount'),
      ipCount?: long(name='IpCount'),
      timestamp?: long(name='Timestamp'),
      totalCount?: long(name='TotalCount'),
      udpTotalCount?: long(name='UdpTotalCount'),
      v4Count?: long(name='V4Count'),
      v4HttpCount?: long(name='V4HttpCount'),
      v4HttpsCount?: long(name='V4HttpsCount'),
      v6Count?: long(name='V6Count'),
      v6HttpCount?: long(name='V6HttpCount'),
      v6HttpsCount?: long(name='V6HttpsCount'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribePdnsRequestStatisticResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePdnsRequestStatisticResponseBody(name='body'),
}

async function describePdnsRequestStatisticWithOptions(request: DescribePdnsRequestStatisticRequest, runtime: Util.RuntimeOptions): DescribePdnsRequestStatisticResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.subDomain)) {
    query['SubDomain'] = request.subDomain;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsRequestStatistic',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePdnsRequestStatistic(request: DescribePdnsRequestStatisticRequest): DescribePdnsRequestStatisticResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsRequestStatisticWithOptions(request, runtime);
}

model DescribePdnsRequestStatisticsRequest {
  domainName?: string(name='DomainName'),
  endDate?: string(name='EndDate'),
  lang?: string(name='Lang'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  startDate?: string(name='StartDate'),
  subDomain?: string(name='SubDomain'),
  type?: string(name='Type'),
}

model DescribePdnsRequestStatisticsResponseBody = {
  data?: [ 
    {
      dohTotalCount?: long(name='DohTotalCount'),
      domainName?: string(name='DomainName'),
      httpCount?: long(name='HttpCount'),
      httpsCount?: long(name='HttpsCount'),
      ipCount?: long(name='IpCount'),
      maxThreatLevel?: string(name='MaxThreatLevel'),
      subDomain?: string(name='SubDomain'),
      threatCount?: long(name='ThreatCount'),
      threatInfo?: [ 
        {
          threatLevel?: string(name='ThreatLevel'),
          threatType?: string(name='ThreatType'),
        }
      ](name='ThreatInfo'),
      totalCount?: long(name='TotalCount'),
      udpTotalCount?: long(name='UdpTotalCount'),
      v4Count?: long(name='V4Count'),
      v4HttpCount?: long(name='V4HttpCount'),
      v4HttpsCount?: long(name='V4HttpsCount'),
      v6Count?: long(name='V6Count'),
      v6HttpCount?: long(name='V6HttpCount'),
      v6HttpsCount?: long(name='V6HttpsCount'),
    }
  ](name='Data'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePdnsRequestStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePdnsRequestStatisticsResponseBody(name='body'),
}

async function describePdnsRequestStatisticsWithOptions(request: DescribePdnsRequestStatisticsRequest, runtime: Util.RuntimeOptions): DescribePdnsRequestStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.subDomain)) {
    query['SubDomain'] = request.subDomain;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsRequestStatistics',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePdnsRequestStatistics(request: DescribePdnsRequestStatisticsRequest): DescribePdnsRequestStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsRequestStatisticsWithOptions(request, runtime);
}

model DescribePdnsThreatLogsRequest {
  endDate?: string(name='EndDate'),
  keyword?: string(name='Keyword'),
  lang?: string(name='Lang'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  startDate?: string(name='StartDate'),
  threatLevel?: string(name='ThreatLevel'),
  threatSourceIp?: string(name='ThreatSourceIp'),
  threatType?: string(name='ThreatType'),
}

model DescribePdnsThreatLogsResponseBody = {
  logs?: [ 
    {
      sourceIp?: string(name='SourceIp'),
      subDomain?: string(name='SubDomain'),
      threatLevel?: string(name='ThreatLevel'),
      threatTime?: string(name='ThreatTime'),
      threatType?: string(name='ThreatType'),
    }
  ](name='Logs'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePdnsThreatLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePdnsThreatLogsResponseBody(name='body'),
}

async function describePdnsThreatLogsWithOptions(request: DescribePdnsThreatLogsRequest, runtime: Util.RuntimeOptions): DescribePdnsThreatLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.threatLevel)) {
    query['ThreatLevel'] = request.threatLevel;
  }
  if (!Util.isUnset(request.threatSourceIp)) {
    query['ThreatSourceIp'] = request.threatSourceIp;
  }
  if (!Util.isUnset(request.threatType)) {
    query['ThreatType'] = request.threatType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsThreatLogs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePdnsThreatLogs(request: DescribePdnsThreatLogsRequest): DescribePdnsThreatLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsThreatLogsWithOptions(request, runtime);
}

model DescribePdnsThreatStatisticRequest {
  endDate?: string(name='EndDate'),
  lang?: string(name='Lang'),
  startDate?: string(name='StartDate'),
  threatSourceIp?: string(name='ThreatSourceIp'),
}

model DescribePdnsThreatStatisticResponseBody = {
  data?: [ 
    {
      dohTotalCount?: long(name='DohTotalCount'),
      threatLevel?: string(name='ThreatLevel'),
      threatType?: string(name='ThreatType'),
      timestamp?: long(name='Timestamp'),
      totalCount?: long(name='TotalCount'),
      udpTotalCount?: long(name='UdpTotalCount'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribePdnsThreatStatisticResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePdnsThreatStatisticResponseBody(name='body'),
}

async function describePdnsThreatStatisticWithOptions(request: DescribePdnsThreatStatisticRequest, runtime: Util.RuntimeOptions): DescribePdnsThreatStatisticResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.threatSourceIp)) {
    query['ThreatSourceIp'] = request.threatSourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsThreatStatistic',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePdnsThreatStatistic(request: DescribePdnsThreatStatisticRequest): DescribePdnsThreatStatisticResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsThreatStatisticWithOptions(request, runtime);
}

model DescribePdnsThreatStatisticsRequest {
  direction?: string(name='Direction'),
  domainName?: string(name='DomainName'),
  endDate?: string(name='EndDate'),
  lang?: string(name='Lang'),
  orderBy?: string(name='OrderBy'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  startDate?: string(name='StartDate'),
  subDomain?: string(name='SubDomain'),
  threatLevel?: string(name='ThreatLevel'),
  threatSourceIp?: string(name='ThreatSourceIp'),
  threatType?: string(name='ThreatType'),
  type?: string(name='Type'),
}

model DescribePdnsThreatStatisticsResponseBody = {
  data?: [ 
    {
      dohTotalCount?: long(name='DohTotalCount'),
      domainCount?: long(name='DomainCount'),
      domainName?: string(name='DomainName'),
      latestThreatTime?: long(name='LatestThreatTime'),
      maxThreatLevel?: string(name='MaxThreatLevel'),
      sourceIp?: string(name='SourceIp'),
      subDomain?: string(name='SubDomain'),
      threatLevel?: string(name='ThreatLevel'),
      threatType?: string(name='ThreatType'),
      totalCount?: long(name='TotalCount'),
      udpTotalCount?: long(name='UdpTotalCount'),
    }
  ](name='Data'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePdnsThreatStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePdnsThreatStatisticsResponseBody(name='body'),
}

async function describePdnsThreatStatisticsWithOptions(request: DescribePdnsThreatStatisticsRequest, runtime: Util.RuntimeOptions): DescribePdnsThreatStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.subDomain)) {
    query['SubDomain'] = request.subDomain;
  }
  if (!Util.isUnset(request.threatLevel)) {
    query['ThreatLevel'] = request.threatLevel;
  }
  if (!Util.isUnset(request.threatSourceIp)) {
    query['ThreatSourceIp'] = request.threatSourceIp;
  }
  if (!Util.isUnset(request.threatType)) {
    query['ThreatType'] = request.threatType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsThreatStatistics',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePdnsThreatStatistics(request: DescribePdnsThreatStatisticsRequest): DescribePdnsThreatStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsThreatStatisticsWithOptions(request, runtime);
}

model DescribePdnsUdpIpSegmentsRequest {
  lang?: string(name='Lang'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
}

model DescribePdnsUdpIpSegmentsResponseBody = {
  ipSegments?: [ 
    {
      createDate?: string(name='CreateDate'),
      ip?: string(name='Ip'),
      mask?: long(name='Mask'),
      name?: string(name='Name'),
      state?: string(name='State'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='IpSegments'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePdnsUdpIpSegmentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePdnsUdpIpSegmentsResponseBody(name='body'),
}

async function describePdnsUdpIpSegmentsWithOptions(request: DescribePdnsUdpIpSegmentsRequest, runtime: Util.RuntimeOptions): DescribePdnsUdpIpSegmentsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsUdpIpSegments',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePdnsUdpIpSegments(request: DescribePdnsUdpIpSegmentsRequest): DescribePdnsUdpIpSegmentsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsUdpIpSegmentsWithOptions(request, runtime);
}

model DescribePdnsUserInfoRequest {
  lang?: string(name='Lang'),
}

model DescribePdnsUserInfoResponseBody = {
  requestId?: string(name='RequestId'),
  userInfo?: {
    availableService?: string(name='AvailableService'),
    pdnsId?: long(name='PdnsId'),
    serviceType?: string(name='ServiceType'),
    state?: string(name='State'),
    stoppedService?: string(name='StoppedService'),
  }(name='UserInfo'),
}

model DescribePdnsUserInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePdnsUserInfoResponseBody(name='body'),
}

async function describePdnsUserInfoWithOptions(request: DescribePdnsUserInfoRequest, runtime: Util.RuntimeOptions): DescribePdnsUserInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsUserInfo',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePdnsUserInfo(request: DescribePdnsUserInfoRequest): DescribePdnsUserInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsUserInfoWithOptions(request, runtime);
}

model DescribeRecordLogsRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  keyWord?: string(name='KeyWord', description='The keyword for searches in %KeyWord% mode. The value is not case-sensitive.', example='test'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  pageNumber?: long(name='PageNumber', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page. Maximum value: **100**. Default value: **20**.', example='20'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the **yyyy-MM-ddTHH:mm:ssZ** format.', example='2015-12-12'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='1.1.1.1'),
  endDate?: string(name='endDate', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the **yyyy-MM-ddTHH:mm:ssZ** format.', example='2015-12-12'),
}

model DescribeRecordLogsResponseBody = {
  pageNumber?: long(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries returned per page.', example='2'),
  recordLogs?: {
    recordLog?: [ 
    {
      action?: string(name='Action', description='The operation that you performed.'),
      actionTime?: string(name='ActionTime', description='The time when the operation was performed.', example='2015-12-12T09:23Z'),
      actionTimestamp?: long(name='ActionTimestamp', description='The UNIX timestamp representing the time of the operation.', example='134514540000'),
      clientIp?: string(name='ClientIp', description='The IP address of the operator.', example='182.92.253.XX'),
      message?: string(name='Message', description='The returned operation message.'),
    }
  ](name='RecordLog')
  }(name='RecordLogs', description='The list of the operation logs of the domain name.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: long(name='TotalCount', description='The total number of operation logs.', example='2'),
}

model DescribeRecordLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRecordLogsResponseBody(name='body'),
}

async function describeRecordLogsWithOptions(request: DescribeRecordLogsRequest, runtime: Util.RuntimeOptions): DescribeRecordLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  if (!Util.isUnset(request.endDate)) {
    query['endDate'] = request.endDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRecordLogs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRecordLogs(request: DescribeRecordLogsRequest): DescribeRecordLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRecordLogsWithOptions(request, runtime);
}

model DescribeRecordResolveStatisticsSummaryRequest {
  direction?: string(name='Direction', description='The order in which you want to sort the query results. Valid values: DESC and ASC. DESC is the default value and indicates that the query results are sorted in descending order. ASC indicates that the query results are sorted in ascending order.', example='DESC'),
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  domainType?: string(name='DomainType', description='The type of the domain name. The parameter value is not case-sensitive. Valid values:

PUBLIC and CACHE. PUBLIC is the default value and indicates an authoritative domain name. CACHE indicates a cache-accelerated domain name.', example='PUBLIC'),
  endDate?: string(name='EndDate', description='The end time in the yyyy-MM-dd format, for example, 2023-03-13.', example='2023-03-29'),
  keyword?: string(name='Keyword', description='The keyword. The Keyword parameter is used together with the SearchMode parameter.', example='test'),
  lang?: string(name='Lang', description='The language used. Valid values: zh, en, and ja.', example='zh'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 1000.', example='10'),
  searchMode?: string(name='SearchMode', description='The search mode of the keyword. Valid values:

LIKE (default): fuzzy search. EXACT: exact match.', example='LIKE'),
  startDate?: string(name='StartDate', description='The start time in the yyyy-MM-dd format, for example, 2023-03-01.', example='2023-03-29'),
  threshold?: long(name='Threshold', description='The threshold for the number of resolution requests. You can query the subdomain names at the specified quantity level of resolution requests and query the number of resolution requests for each subdomain name. For example, if you set this parameter to 100, you can obtain data about the subdomain names with less than 100 resolution requests.

If you do not specify this parameter, the data about the subdomain names that have resolution requests is obtained.

If you set this parameter to a value less than 0, the data about all subdomain names is obtained.

If you set this parameter to 0, the data about the subdomain names that do not have resolution requests is obtained.

If you set this parameter to a value greater than 0, the data about the subdomain names whose number of resolution requests is less than or equal to the value of this parameter is obtained.', example='-1'),
}

model DescribeRecordResolveStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='389DFFA3-77A5-4A9E-BF3D-147C6F98A5BA'),
  statistics?: [ 
    {
      count?: string(name='Count', description='The number of resolution requests.', example='330'),
      domainName?: string(name='DomainName', description='The domain name.', example='tes.example.com'),
      domainType?: string(name='DomainType', description='The type of the domain name. Valid values: PUBLIC and CACHE. PUBLIC indicates an authoritative domain name. CACHE indicates a cache-accelerated domain name.', example='PUBLIC'),
      subDomain?: string(name='SubDomain', description='', example='test.example.com'),
    }
  ](name='Statistics', description='The statistics.'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned.', example='1'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeRecordResolveStatisticsSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRecordResolveStatisticsSummaryResponseBody(name='body'),
}

async function describeRecordResolveStatisticsSummaryWithOptions(request: DescribeRecordResolveStatisticsSummaryRequest, runtime: Util.RuntimeOptions): DescribeRecordResolveStatisticsSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainType)) {
    query['DomainType'] = request.domainType;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchMode)) {
    query['SearchMode'] = request.searchMode;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.threshold)) {
    query['Threshold'] = request.threshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRecordResolveStatisticsSummary',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRecordResolveStatisticsSummary(request: DescribeRecordResolveStatisticsSummaryRequest): DescribeRecordResolveStatisticsSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRecordResolveStatisticsSummaryWithOptions(request, runtime);
}

model DescribeRecordStatisticsRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='dns-example.com'),
  domainType?: string(name='DomainType'),
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the **YYYY-MM-DD** format.

The default value is the day when you perform the operation.', example='2019-07-04'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  rr?: string(name='Rr', description='The DNS record.

The host record. For example, to resolve `www.dns-exmaple.com`, you must set Rr to www.', example='www'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the **YYYY-MM-DD** format.

You can only query DNS records of the last 90 days.', example='2019-07-04'),
}

model DescribeRecordStatisticsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6AEC7A64-3CB1-4C49-8B35-0B901F1E26BF'),
  statistics?: {
    statistic?: [ 
    {
      count?: long(name='Count', description='The number of queries.', example='15292887'),
      timestamp?: long(name='Timestamp', description='The UNIX timestamp representing the collection time.', example='1556640000000'),
    }
  ](name='Statistic')
  }(name='Statistics', description='The list of query volume records.'),
}

model DescribeRecordStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRecordStatisticsResponseBody(name='body'),
}

/**
  * Real-time data is collected per hour.
  *
  * @param request DescribeRecordStatisticsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeRecordStatisticsResponse
 */
async function describeRecordStatisticsWithOptions(request: DescribeRecordStatisticsRequest, runtime: Util.RuntimeOptions): DescribeRecordStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainType)) {
    query['DomainType'] = request.domainType;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.rr)) {
    query['Rr'] = request.rr;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRecordStatistics',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Real-time data is collected per hour.
  *
  * @param request DescribeRecordStatisticsRequest
  * @return DescribeRecordStatisticsResponse
 */
async function describeRecordStatistics(request: DescribeRecordStatisticsRequest): DescribeRecordStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRecordStatisticsWithOptions(request, runtime);
}

model DescribeRecordStatisticsSummaryRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='dns-example.com'),
  domainType?: string(name='DomainType'),
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the **YYYY-MM-DD** format.

The default value is the day when you perform the operation.', example='2019-07-04'),
  keyword?: string(name='Keyword', description='The keyword for searches in %KeyWord% mode. The value is not case-sensitive.', example='test'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  pageNumber?: long(name='PageNumber', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page. Maximum value: **100**. Minimum value: **1**. Default value: **20**.', example='20'),
  searchMode?: string(name='SearchMode', description='The search mode of the keyword. Valid values:

*   **LIKE**: fuzzy match (default).
*   **EXACT**: exact match.', example='EXACT'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the **YYYY-MM-DD** format.

You can only query DNS records of the last 90 days.', example='2019-07-04'),
  threshold?: long(name='Threshold', description='The threshold of query volume that can be obtained. You can also obtain data about a domain name with the query volume less than or equal to the threshold. For example, if you set this parameter to 100, you can query domain names with less than 100 queries.', example='12'),
}

model DescribeRecordStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E49F0023-4A98-486F-8BA3-6003D5664105'),
  statistics?: {
    statistic?: [ 
    {
      count?: long(name='Count', description='The number of queries.', example='838711553'),
      subDomain?: string(name='SubDomain', description='The subdomain name.', example='t1.alitest2.com'),
    }
  ](name='Statistic')
  }(name='Statistics', description='The list of query volume records.'),
  totalItems?: int32(name='TotalItems', description='The total number of data records.The total number of data records.', example='3'),
  totalPages?: int32(name='TotalPages', description='The total number of returned pages.', example='1'),
}

model DescribeRecordStatisticsSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRecordStatisticsSummaryResponseBody(name='body'),
}

async function describeRecordStatisticsSummaryWithOptions(request: DescribeRecordStatisticsSummaryRequest, runtime: Util.RuntimeOptions): DescribeRecordStatisticsSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainType)) {
    query['DomainType'] = request.domainType;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchMode)) {
    query['SearchMode'] = request.searchMode;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.threshold)) {
    query['Threshold'] = request.threshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRecordStatisticsSummary',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRecordStatisticsSummary(request: DescribeRecordStatisticsSummaryRequest): DescribeRecordStatisticsSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRecordStatisticsSummaryWithOptions(request, runtime);
}

model DescribeSubDomainRecordsRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  lang?: string(name='Lang', description='The language.', example='en'),
  line?: string(name='Line', description='The resolution line.', example='default'),
  pageNumber?: long(name='PageNumber', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page. Maximum value: **500**. Default value: **20**.', example='20'),
  subDomain?: string(name='SubDomain', description='The subdomain. For example, assume that the SubDomain parameter is set to a.www.example.com.

If the DomainName parameter is empty, the DNS records of the subdomain whose domain name is example.com and hostname is "a.www" are queried.

If the DomainName parameter is set to www.example.com, the DNS records of the subdomain whose domain name is www.example.com and hostname is "a" are queried.

If the DomainName parameter is set to a.www.example.com, the DNS records of the subdomain whose domain name is a.www.example.com and hostname is "@" are queried.', example='a.www.example.com'),
  type?: string(name='Type', description='The type of DNS records to query. If you do not specify this parameter, all types of DNS records corresponding to the subdomain are returned.

DNS record types include **A, MX, CNAME, TXT, REDIRECT_URL, FORWORD_URL, NS, AAAA, and SRV**. The value is not case-sensitive.', example='MX'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0'),
}

model DescribeSubDomainRecordsResponseBody = {
  domainRecords?: {
    record?: [ 
    {
      domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
      line?: string(name='Line', description='The resolution line.', example='default'),
      locked?: boolean(name='Locked', description='Indicates whether the DNS record is locked.', example='false'),
      priority?: long(name='Priority', description='The priority of the MX record.', example='2'),
      RR?: string(name='RR', description='The hostname.', example='www'),
      recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
      remark?: string(name='Remark', description='The description of the DNS record.'),
      status?: string(name='Status', description='The status of the DNS record.', example='Enable'),
      TTL?: long(name='TTL', description='The Time-to-Live (TTL) of the DNS record.', example='600'),
      type?: string(name='Type', description='The type of the DNS record.', example='CNAME'),
      value?: string(name='Value', description='The record value.', example='example.net'),
      weight?: int32(name='Weight', description='The weight of the DNS record.', example='10'),
    }
  ](name='Record')
  }(name='DomainRecords', description='The list of DNS records returned.'),
  pageNumber?: long(name='PageNumber', description='The number of the returned page.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries returned per page.', example='2'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: long(name='TotalCount', description='The total number of DNS records returned.', example='2'),
}

model DescribeSubDomainRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSubDomainRecordsResponseBody(name='body'),
}

async function describeSubDomainRecordsWithOptions(request: DescribeSubDomainRecordsRequest, runtime: Util.RuntimeOptions): DescribeSubDomainRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.line)) {
    query['Line'] = request.line;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.subDomain)) {
    query['SubDomain'] = request.subDomain;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSubDomainRecords',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSubDomainRecords(request: DescribeSubDomainRecordsRequest): DescribeSubDomainRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSubDomainRecordsWithOptions(request, runtime);
}

model DescribeSupportLinesRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='1.1.*.*'),
}

model DescribeSupportLinesResponseBody = {
  recordLines?: {
    recordLine?: [ 
    {
      fatherCode?: string(name='FatherCode', description='The code of the parent line. Leave it blank if there is no parent line.', example='unicom'),
      lineCode?: string(name='LineCode', description='The code of the child line.', example='cn_unicom_shanxi'),
      lineDisplayName?: string(name='LineDisplayName', description='The name of the parent line.'),
      lineName?: string(name='LineName', description='The name of the child line.'),
    }
  ](name='RecordLine')
  }(name='RecordLines', description='The list of Alibaba Cloud DNS lines.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CFDA0830-7D6E-4C13-8632-B57C7EDCF079'),
}

model DescribeSupportLinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSupportLinesResponseBody(name='body'),
}

async function describeSupportLinesWithOptions(request: DescribeSupportLinesRequest, runtime: Util.RuntimeOptions): DescribeSupportLinesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSupportLines',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSupportLines(request: DescribeSupportLinesRequest): DescribeSupportLinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSupportLinesWithOptions(request, runtime);
}

model DescribeTagsRequest {
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages. Default value: en. Valid values: en, zh, and ja.', example='en'),
  pageNumber?: long(name='PageNumber', description='The page number to return. Default value: 1.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries to return per page. Default value: 200.', example='200'),
  resourceType?: string(name='ResourceType', description='The type of the resources from which you want to query tags. Set the value to DOMAIN.', example='DOMAIN'),
}

model DescribeTagsResponseBody = {
  pageNumber?: long(name='PageNumber', description='The returned page number. Default value: 1.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries returned per page. Default value: 200.', example='200'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='89184F33-48A1-4401-9C0F-40E45DB091AB'),
  tags?: [ 
    {
      key?: string(name='Key', description='The key of the tag.', example='abc'),
      values?: [ string ](name='Values'),
    }
  ](name='Tags', description='The list of tags.'),
  totalCount?: long(name='TotalCount', description='The total number of tags returned.', example='5'),
}

model DescribeTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTagsResponseBody(name='body'),
}

async function describeTagsWithOptions(request: DescribeTagsRequest, runtime: Util.RuntimeOptions): DescribeTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTags',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTags(request: DescribeTagsRequest): DescribeTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTagsWithOptions(request, runtime);
}

model DescribeTransferDomainsRequest {
  domainName?: string(name='DomainName', example='alidns.com'),
  fromUserId?: long(name='FromUserId', example='123456'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  pageNumber?: long(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page. Maximum value: 100. Default value: 20.', example='20'),
  targetUserId?: long(name='TargetUserId', example='123456'),
  transferType?: string(name='TransferType', description='The transfer type. Valid values:

*   IN: transferred to this account.
*   OUT: transferred from this account.', example='IN'),
}

model DescribeTransferDomainsResponseBody = {
  domainTransfers?: {
    domainTransfer?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the task for transferring domain names was created.', example='2019-10-30T07:16Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The UNIX timestamp representing when the task for transferring domain names was created.', example='1572419764000'),
      domainName?: string(name='DomainName', description='The domain name.', example='test.com'),
      fromUserId?: long(name='FromUserId', description='The ID of the user from which the domain name was transferred.', example='2222'),
      id?: long(name='Id', description='The ID of the domain name that was transferred.', example='1'),
      targetUserId?: long(name='TargetUserId', description='The ID of the user to which the domain name was transferred.', example='111111'),
    }
  ](name='DomainTransfer')
  }(name='DomainTransfers', description='The list of domain names that were transferred between accounts.'),
  pageNumber?: long(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: long(name='TotalCount', description='The total number of domain names.', example='1'),
}

model DescribeTransferDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTransferDomainsResponseBody(name='body'),
}

async function describeTransferDomainsWithOptions(request: DescribeTransferDomainsRequest, runtime: Util.RuntimeOptions): DescribeTransferDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.fromUserId)) {
    query['FromUserId'] = request.fromUserId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.targetUserId)) {
    query['TargetUserId'] = request.targetUserId;
  }
  if (!Util.isUnset(request.transferType)) {
    query['TransferType'] = request.transferType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTransferDomains',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTransferDomains(request: DescribeTransferDomainsRequest): DescribeTransferDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTransferDomainsWithOptions(request, runtime);
}

model ExecuteGtmRecoveryPlanRequest {
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  recoveryPlanId?: long(name='RecoveryPlanId', description='The ID of the disaster recovery plan that you want to executed.', example='100'),
}

model ExecuteGtmRecoveryPlanResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model ExecuteGtmRecoveryPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExecuteGtmRecoveryPlanResponseBody(name='body'),
}

async function executeGtmRecoveryPlanWithOptions(request: ExecuteGtmRecoveryPlanRequest, runtime: Util.RuntimeOptions): ExecuteGtmRecoveryPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recoveryPlanId)) {
    query['RecoveryPlanId'] = request.recoveryPlanId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExecuteGtmRecoveryPlan',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function executeGtmRecoveryPlan(request: ExecuteGtmRecoveryPlanRequest): ExecuteGtmRecoveryPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return executeGtmRecoveryPlanWithOptions(request, runtime);
}

model GetMainDomainNameRequest {
  inputString?: string(name='InputString', description='The input string. The string can be up to 128 characters in length.', example='www.example.com'),
  lang?: string(name='Lang', description='The language type.', example='en'),
}

model GetMainDomainNameResponseBody = {
  domainLevel?: long(name='DomainLevel', description='The level of the entered domain name.', example='2'),
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  RR?: string(name='RR', description='The host record.', example='www'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model GetMainDomainNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMainDomainNameResponseBody(name='body'),
}

async function getMainDomainNameWithOptions(request: GetMainDomainNameRequest, runtime: Util.RuntimeOptions): GetMainDomainNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.inputString)) {
    query['InputString'] = request.inputString;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMainDomainName',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMainDomainName(request: GetMainDomainNameRequest): GetMainDomainNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMainDomainNameWithOptions(request, runtime);
}

model GetTxtRecordForVerifyRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  type?: string(name='Type', description='The function verified by using the TXT record. Valid values:

*   ADD_SUBDOMAIN
*   RETRIEVAL', example='ADD_SUB_DOMAIN'),
}

model GetTxtRecordForVerifyResponseBody = {
  domainName?: string(name='DomainName', description='The domain name.

>  If you do not specify this parameter, it is not returned.', example='example.com'),
  RR?: string(name='RR', description='The host record.', example='aliyunRetrieval'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9CC0D642-49D4-48DE-A1A5-9F218652E4A7'),
  value?: string(name='Value', description='The value of the DNS record.

>  The validity period is three days.', example='c99419e6997f41daaa3e*****'),
}

model GetTxtRecordForVerifyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTxtRecordForVerifyResponseBody(name='body'),
}

async function getTxtRecordForVerifyWithOptions(request: GetTxtRecordForVerifyRequest, runtime: Util.RuntimeOptions): GetTxtRecordForVerifyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTxtRecordForVerify',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTxtRecordForVerify(request: GetTxtRecordForVerifyRequest): GetTxtRecordForVerifyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTxtRecordForVerifyWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  lang?: string(name='Lang', description='The language in which you want some response parameters to be returned.', example='en'),
  nextToken?: string(name='NextToken', description='The token that determines the start point of the query.', example='4698691'),
  resourceId?: [ string ](name='ResourceId', description='The ID of the resource.'),
  resourceType?: string(name='ResourceType', description='The resource type.', example='DOMAIN'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag.', example='abcd'),
      value?: string(name='Value', description='The value of the tag.', example='abcd'),
    }
  ](name='Tag', description='An array of tag key-value pairs.'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', description='The token used to start the next query. If no value is returned for NextToken, no next queries are sent.', example='4698691'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='61092C8D-6AEB-4310-B74D-C632F89BF4FB'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId', description='The ID of the resource.', example='dns-example.com'),
      resourceType?: string(name='ResourceType', description='The type of the resource. Only DOMAIN is returned.', example='DOMAIN'),
      tagKey?: string(name='TagKey', description='The key of the tag.', example='abcd'),
      tagValue?: string(name='TagValue', description='The tag value.', example='abcd'),
    }
  ](name='TagResources', description='Details of the resource and tags, including the resource ID, the resource type, tag keys, and tag values.'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

/**
  * *   Set ResourceId.N or Tag.N that consists of Tag.N.Key and Tag.N.Value in the request to specify the object to be queried.
  * *   Tag.N is a resource tag that consists of a key-value pair. If you set only Tag.N.Key, all tag values that are assigned to the specified key are returned. If you set only Tag.N.Value, an error message is returned.
  * *   If you set both Tag.N and ResourceId.N to filter tags, ResourceId.N must match all specified key-value pairs.
  * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
  *
  * @param request ListTagResourcesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListTagResourcesResponse
 */
async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   Set ResourceId.N or Tag.N that consists of Tag.N.Key and Tag.N.Value in the request to specify the object to be queried.
  * *   Tag.N is a resource tag that consists of a key-value pair. If you set only Tag.N.Key, all tag values that are assigned to the specified key are returned. If you set only Tag.N.Value, an error message is returned.
  * *   If you set both Tag.N and ResourceId.N to filter tags, ResourceId.N must match all specified key-value pairs.
  * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
  *
  * @param request ListTagResourcesRequest
  * @return ListTagResourcesResponse
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ModifyHichinaDomainDNSRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0'),
}

model ModifyHichinaDomainDNSResponseBody = {
  newDnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='NewDnsServers', description='The list of DNS servers after the domain name is changed.'),
  originalDnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='OriginalDnsServers', description='The list of DNS servers before the domain name is changed.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model ModifyHichinaDomainDNSResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyHichinaDomainDNSResponseBody(name='body'),
}

/**
  * If the operation succeeds, the name of the DNS server changes to that of an Alibaba Cloud DNS server (ending with hichina.com).
  * >  Before you call this operation, make sure that your domain name has been registered with Alibaba Cloud and the DNS server in use is not an Alibaba Cloud DNS server.
  *
  * @param request ModifyHichinaDomainDNSRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyHichinaDomainDNSResponse
 */
async function modifyHichinaDomainDNSWithOptions(request: ModifyHichinaDomainDNSRequest, runtime: Util.RuntimeOptions): ModifyHichinaDomainDNSResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyHichinaDomainDNS',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If the operation succeeds, the name of the DNS server changes to that of an Alibaba Cloud DNS server (ending with hichina.com).
  * >  Before you call this operation, make sure that your domain name has been registered with Alibaba Cloud and the DNS server in use is not an Alibaba Cloud DNS server.
  *
  * @param request ModifyHichinaDomainDNSRequest
  * @return ModifyHichinaDomainDNSResponse
 */
async function modifyHichinaDomainDNS(request: ModifyHichinaDomainDNSRequest): ModifyHichinaDomainDNSResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHichinaDomainDNSWithOptions(request, runtime);
}

model MoveDomainResourceGroupRequest {
  lang?: string(name='Lang', description='The language of some returned parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  newResourceGroupId?: string(name='NewResourceGroupId', description='The ID of the resource group.', example='rg-aekzzk7hx3glaoq'),
  resourceId?: string(name='ResourceId', description='The domain name.', example='example.com'),
}

model MoveDomainResourceGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C6F1D541-E7A6-447A-A2B5-9F7A20B2A8FB'),
}

model MoveDomainResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MoveDomainResourceGroupResponseBody(name='body'),
}

async function moveDomainResourceGroupWithOptions(request: MoveDomainResourceGroupRequest, runtime: Util.RuntimeOptions): MoveDomainResourceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.newResourceGroupId)) {
    query['NewResourceGroupId'] = request.newResourceGroupId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MoveDomainResourceGroup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function moveDomainResourceGroup(request: MoveDomainResourceGroupRequest): MoveDomainResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return moveDomainResourceGroupWithOptions(request, runtime);
}

model MoveGtmResourceGroupRequest {
  lang?: string(name='Lang', example='en'),
  newResourceGroupId?: string(name='NewResourceGroupId', example='AgIDE1MA_XXX'),
  resourceId?: string(name='ResourceId', example='rg-aekzzk7hx3*****'),
}

model MoveGtmResourceGroupResponseBody = {
  requestId?: string(name='RequestId', example='C6F1D541-E7A6-447A-A2B5-9F7A20B2A8FB'),
}

model MoveGtmResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MoveGtmResourceGroupResponseBody(name='body'),
}

async function moveGtmResourceGroupWithOptions(request: MoveGtmResourceGroupRequest, runtime: Util.RuntimeOptions): MoveGtmResourceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.newResourceGroupId)) {
    query['NewResourceGroupId'] = request.newResourceGroupId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MoveGtmResourceGroup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function moveGtmResourceGroup(request: MoveGtmResourceGroupRequest): MoveGtmResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return moveGtmResourceGroupWithOptions(request, runtime);
}

model OperateBatchDomainRequest {
  domainRecordInfo?: [ 
    {
      domain?: string(name='Domain', description='The resolution line of DNS record N. Default value: default.

For more information, see [Resolution line enumeration](https://www.alibabacloud.com/help/zh/doc-detail/29807.htm).', example='example.com'),
      line?: string(name='Line', description='The host record corresponding to DNS record N.

>  If you set the Type parameter to **RR_ADD**, you must also specify this parameter.', example='default'),
      newRr?: string(name='NewRr'),
      newType?: string(name='NewType'),
      newValue?: string(name='NewValue'),
      priority?: int32(name='Priority', description='The ID of the task.', example='5'),
      rr?: string(name='Rr', description='The priority of MX-type DNS record N.

This parameter must be specified if the type of the DNS record is MX. Default value: 10.', example='zhaohui'),
      ttl?: int32(name='Ttl', description='The domain name corresponding to DNS record N.

>  N is specified by users. **N** starts from **1**. The maximum value of N is **1000**. Extra data entries are ignored.', example='600'),
      type?: string(name='Type', description='The value of DNS record N.

>  If you set the Type parameter to **RR_ADD**, you must also specify this parameter.', example='MX'),
      value?: string(name='Value', description='The TTL of DNS record N. Unit: seconds. Default value: **600**.', example='fd87da3c4528844d45af39200155a905'),
    }
  ](name='DomainRecordInfo'),
  lang?: string(name='Lang', description='The type of the batch operation. Valid values:

*   **DOMAIN_ADD**: adds domain names in batches.
*   **DOMAIN_DEL**: deletes domain names in batches.
*   **RR_ADD**: adds DNS records in batches.
*   **RR_DEL**: deletes DNS records in batches. (If RR or VALUE exists, DNS records corresponding to the specified RR or VALUE are deleted. If both of them exist, DNS records corresponding to the specified RR and VALUE are deleted. If no RR or VALUE is specified, the DNS records corresponding to the DomainName parameter are deleted.)', example='en'),
  type?: string(name='Type', description='The type of DNS record N. For the DNS record types supported by Alibaba Cloud DNS, see [Resolution record type formats](https://www.alibabacloud.com/help/zh/doc-detail/29805.htm).

>  If you set the Type parameter to **RR_ADD**, you must also specify this parameter.', example='RR_ADD'),
}

model OperateBatchDomainResponseBody = {
  requestId?: string(name='RequestId', example='75446CC1-FC9A-4595-8D96-089D73D7A63D'),
  taskId?: long(name='TaskId', description='The ID of the request.', example='345345'),
}

model OperateBatchDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OperateBatchDomainResponseBody(name='body'),
}

async function operateBatchDomainWithOptions(request: OperateBatchDomainRequest, runtime: Util.RuntimeOptions): OperateBatchDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainRecordInfo)) {
    query['DomainRecordInfo'] = request.domainRecordInfo;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateBatchDomain',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function operateBatchDomain(request: OperateBatchDomainRequest): OperateBatchDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateBatchDomainWithOptions(request, runtime);
}

model PausePdnsServiceRequest {
  lang?: string(name='Lang'),
  serviceType?: string(name='ServiceType'),
}

model PausePdnsServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model PausePdnsServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PausePdnsServiceResponseBody(name='body'),
}

async function pausePdnsServiceWithOptions(request: PausePdnsServiceRequest, runtime: Util.RuntimeOptions): PausePdnsServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.serviceType)) {
    query['ServiceType'] = request.serviceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PausePdnsService',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pausePdnsService(request: PausePdnsServiceRequest): PausePdnsServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return pausePdnsServiceWithOptions(request, runtime);
}

model PreviewGtmRecoveryPlanRequest {
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on per page. Maximum value: **20**. Default value: **5**.', example='5'),
  recoveryPlanId?: long(name='RecoveryPlanId', description='The ID of the disaster recovery plan that you want to preview.', example='100'),
}

model PreviewGtmRecoveryPlanResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='5'),
  previews?: {
    preview?: [ 
    {
      instanceId?: string(name='InstanceId', description='The ID of the GTM instance to which the previewed disaster recovery plan belongs.', example='instance-example'),
      name?: string(name='Name', description='The name of the GTM instance to which the previewed disaster recovery plan belongs.', example='name-example'),
      switchInfos?: {
        switchInfo?: [ 
        {
          content?: string(name='Content', description='The formatted message content.'),
          strategyName?: string(name='StrategyName', description='The name of the switching policy for address pools.', example='strategy-name-example-1'),
        }
      ](name='SwitchInfo')
      }(name='SwitchInfos', description='The returned information of the switching policies for address pools.'),
      userDomainName?: string(name='UserDomainName', description='The user\\"s domain name or domain name list.', example='30.yyy.com'),
    }
  ](name='Preview')
  }(name='Previews', description='The returned preview information of the disaster recovery plan.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='853805EA-3D47-47D5-9A1A-A45C24313ABD'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned on all pages.', example='15'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='3'),
}

model PreviewGtmRecoveryPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PreviewGtmRecoveryPlanResponseBody(name='body'),
}

async function previewGtmRecoveryPlanWithOptions(request: PreviewGtmRecoveryPlanRequest, runtime: Util.RuntimeOptions): PreviewGtmRecoveryPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.recoveryPlanId)) {
    query['RecoveryPlanId'] = request.recoveryPlanId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PreviewGtmRecoveryPlan',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function previewGtmRecoveryPlan(request: PreviewGtmRecoveryPlanRequest): PreviewGtmRecoveryPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return previewGtmRecoveryPlanWithOptions(request, runtime);
}

model RemovePdnsAppKeyRequest {
  appKeyId?: string(name='AppKeyId'),
  lang?: string(name='Lang'),
}

model RemovePdnsAppKeyResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemovePdnsAppKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemovePdnsAppKeyResponseBody(name='body'),
}

async function removePdnsAppKeyWithOptions(request: RemovePdnsAppKeyRequest, runtime: Util.RuntimeOptions): RemovePdnsAppKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appKeyId)) {
    query['AppKeyId'] = request.appKeyId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemovePdnsAppKey',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removePdnsAppKey(request: RemovePdnsAppKeyRequest): RemovePdnsAppKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return removePdnsAppKeyWithOptions(request, runtime);
}

model RemovePdnsUdpIpSegmentRequest {
  ip?: string(name='Ip'),
  lang?: string(name='Lang'),
}

model RemovePdnsUdpIpSegmentResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemovePdnsUdpIpSegmentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemovePdnsUdpIpSegmentResponseBody(name='body'),
}

async function removePdnsUdpIpSegmentWithOptions(request: RemovePdnsUdpIpSegmentRequest, runtime: Util.RuntimeOptions): RemovePdnsUdpIpSegmentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemovePdnsUdpIpSegment',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removePdnsUdpIpSegment(request: RemovePdnsUdpIpSegmentRequest): RemovePdnsUdpIpSegmentResponse {
  var runtime = new Util.RuntimeOptions{};
  return removePdnsUdpIpSegmentWithOptions(request, runtime);
}

model ResumePdnsServiceRequest {
  lang?: string(name='Lang'),
  serviceType?: string(name='ServiceType'),
}

model ResumePdnsServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResumePdnsServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResumePdnsServiceResponseBody(name='body'),
}

async function resumePdnsServiceWithOptions(request: ResumePdnsServiceRequest, runtime: Util.RuntimeOptions): ResumePdnsServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.serviceType)) {
    query['ServiceType'] = request.serviceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResumePdnsService',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resumePdnsService(request: ResumePdnsServiceRequest): ResumePdnsServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return resumePdnsServiceWithOptions(request, runtime);
}

model RetrieveDomainRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  lang?: string(name='Lang', description='The language type.', example='en'),
}

model RetrieveDomainResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='9CC0D642-49D4-48DE-A1A5-9F218652E4A7'),
}

model RetrieveDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RetrieveDomainResponseBody(name='body'),
}

async function retrieveDomainWithOptions(request: RetrieveDomainRequest, runtime: Util.RuntimeOptions): RetrieveDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RetrieveDomain',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function retrieveDomain(request: RetrieveDomainRequest): RetrieveDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return retrieveDomainWithOptions(request, runtime);
}

model RollbackGtmRecoveryPlanRequest {
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  recoveryPlanId?: long(name='RecoveryPlanId', description='The ID of the disaster recovery plan that you want to roll back.', example='100'),
}

model RollbackGtmRecoveryPlanResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='853805EA-3D47-47D5-9A1A-A45C24313ABD'),
}

model RollbackGtmRecoveryPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RollbackGtmRecoveryPlanResponseBody(name='body'),
}

async function rollbackGtmRecoveryPlanWithOptions(request: RollbackGtmRecoveryPlanRequest, runtime: Util.RuntimeOptions): RollbackGtmRecoveryPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recoveryPlanId)) {
    query['RecoveryPlanId'] = request.recoveryPlanId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RollbackGtmRecoveryPlan',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rollbackGtmRecoveryPlan(request: RollbackGtmRecoveryPlanRequest): RollbackGtmRecoveryPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return rollbackGtmRecoveryPlanWithOptions(request, runtime);
}

model SetDNSSLBStatusRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  lang?: string(name='Lang', description='The language of the subdomain.', example='en'),
  line?: string(name='Line', example='telecom'),
  open?: boolean(name='Open', description='Specifies whether to enable or disable weighted round-robin. Valid values:

*   **true**: enables weighted round-robin. This is the default value.
*   **false**: disables weighted round-robin.', example='true'),
  subDomain?: string(name='SubDomain', description='The subdomain for which you want to configure weighted round-robin. Do not set the value to a string such as aliyun.com. Instead, set the value to @.aliyun.com.', example='www.example.com'),
  type?: string(name='Type', description='The type of the DNS record. Valid values: A and AAAA. Default value: A.', example='A'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client that you use to configure weighted round-robin.', example='192.0.2.0'),
}

model SetDNSSLBStatusResponseBody = {
  open?: boolean(name='Open', description='Indicates whether weighted round-robin is enabled for the subdomain.', example='true'),
  recordCount?: long(name='RecordCount', description='The number of A records that are matched.', example='8'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model SetDNSSLBStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDNSSLBStatusResponseBody(name='body'),
}

async function setDNSSLBStatusWithOptions(request: SetDNSSLBStatusRequest, runtime: Util.RuntimeOptions): SetDNSSLBStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.line)) {
    query['Line'] = request.line;
  }
  if (!Util.isUnset(request.open)) {
    query['Open'] = request.open;
  }
  if (!Util.isUnset(request.subDomain)) {
    query['SubDomain'] = request.subDomain;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDNSSLBStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDNSSLBStatus(request: SetDNSSLBStatusRequest): SetDNSSLBStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDNSSLBStatusWithOptions(request, runtime);
}

model SetDnsGtmAccessModeRequest {
  accessMode?: string(name='AccessMode', description='The primary/secondary switchover policy for address pool groups. Valid values:

*   AUTO: performs automatic switchover between the primary and secondary address pool groups upon failures.
*   DEFAULT: uses the primary address pool group.
*   FAILOVER: uses the secondary address pool group.', example='auto'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  strategyId?: string(name='StrategyId', description='The ID of the policy.', example='strategyId'),
}

model SetDnsGtmAccessModeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
}

model SetDnsGtmAccessModeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDnsGtmAccessModeResponseBody(name='body'),
}

/**
  * ****
  *
  * @param request SetDnsGtmAccessModeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return SetDnsGtmAccessModeResponse
 */
async function setDnsGtmAccessModeWithOptions(request: SetDnsGtmAccessModeRequest, runtime: Util.RuntimeOptions): SetDnsGtmAccessModeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessMode)) {
    query['AccessMode'] = request.accessMode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDnsGtmAccessMode',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ****
  *
  * @param request SetDnsGtmAccessModeRequest
  * @return SetDnsGtmAccessModeResponse
 */
async function setDnsGtmAccessMode(request: SetDnsGtmAccessModeRequest): SetDnsGtmAccessModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDnsGtmAccessModeWithOptions(request, runtime);
}

model SetDnsGtmMonitorStatusRequest {
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check task.', example='MonitorConfigId1'),
  status?: string(name='Status', description='Specifies whether to enable the health check feature. Valid values:

*   OPEN: enable
*   CLOSE: disable', example='open'),
}

model SetDnsGtmMonitorStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model SetDnsGtmMonitorStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDnsGtmMonitorStatusResponseBody(name='body'),
}

async function setDnsGtmMonitorStatusWithOptions(request: SetDnsGtmMonitorStatusRequest, runtime: Util.RuntimeOptions): SetDnsGtmMonitorStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.monitorConfigId)) {
    query['MonitorConfigId'] = request.monitorConfigId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDnsGtmMonitorStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDnsGtmMonitorStatus(request: SetDnsGtmMonitorStatusRequest): SetDnsGtmMonitorStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDnsGtmMonitorStatusWithOptions(request, runtime);
}

model SetDomainDnssecStatusRequest {
  domainName?: string(name='DomainName', description='The domain name for which you want to set the DNSSEC status.', example='example.com'),
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages. Default value: en. Valid values: en, zh, and ja.', example='en'),
  status?: string(name='Status', description='The DNSSEC status. Valid values:

*   ON: enables DNSSEC for the domain name.
*   OFF: disables DNSSEC for the domain name.', example='ON'),
}

model SetDomainDnssecStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model SetDomainDnssecStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDomainDnssecStatusResponseBody(name='body'),
}

async function setDomainDnssecStatusWithOptions(request: SetDomainDnssecStatusRequest, runtime: Util.RuntimeOptions): SetDomainDnssecStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDomainDnssecStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDomainDnssecStatus(request: SetDomainDnssecStatusRequest): SetDomainDnssecStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDomainDnssecStatusWithOptions(request, runtime);
}

model SetDomainRecordStatusRequest {
  lang?: string(name='Lang', description='The language type.', example='en'),
  recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
  status?: string(name='Status', description='The status of the DNS record. Valid values:

*   **Enable**: enables resolution.
*   **Disable**: suspends resolution.', example='Disable'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0'),
}

model SetDomainRecordStatusResponseBody = {
  recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  status?: string(name='Status', description='The status of the DNS record.', example='Disable'),
}

model SetDomainRecordStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDomainRecordStatusResponseBody(name='body'),
}

async function setDomainRecordStatusWithOptions(request: SetDomainRecordStatusRequest, runtime: Util.RuntimeOptions): SetDomainRecordStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recordId)) {
    query['RecordId'] = request.recordId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDomainRecordStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDomainRecordStatus(request: SetDomainRecordStatusRequest): SetDomainRecordStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDomainRecordStatusWithOptions(request, runtime);
}

model SetGtmAccessModeRequest {
  accessMode?: string(name='AccessMode', description='The target access policy of the GTM instance. Valid values:

*   **AUTO**: Automatic switch
*   **DEFAULT**: Default address pool
*   **FAILOVER**: Failover address pool', example='AUTO'),
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy.', example='hra0hx'),
}

model SetGtmAccessModeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
}

model SetGtmAccessModeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetGtmAccessModeResponseBody(name='body'),
}

async function setGtmAccessModeWithOptions(request: SetGtmAccessModeRequest, runtime: Util.RuntimeOptions): SetGtmAccessModeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessMode)) {
    query['AccessMode'] = request.accessMode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetGtmAccessMode',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setGtmAccessMode(request: SetGtmAccessModeRequest): SetGtmAccessModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setGtmAccessModeWithOptions(request, runtime);
}

model SetGtmMonitorStatusRequest {
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  monitorConfigId?: string(name='MonitorConfigId', description='The health check ID.', example='abc1234'),
  status?: string(name='Status', description='Specifies whether health check is enabled for the address pool. Valid values:

*   **OPEN**: Enabled
*   **CLOSE**: Disabled', example='OPEN'),
}

model SetGtmMonitorStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model SetGtmMonitorStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetGtmMonitorStatusResponseBody(name='body'),
}

async function setGtmMonitorStatusWithOptions(request: SetGtmMonitorStatusRequest, runtime: Util.RuntimeOptions): SetGtmMonitorStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.monitorConfigId)) {
    query['MonitorConfigId'] = request.monitorConfigId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetGtmMonitorStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setGtmMonitorStatus(request: SetGtmMonitorStatusRequest): SetGtmMonitorStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setGtmMonitorStatusWithOptions(request, runtime);
}

model SubmitIspFlushCacheTaskRequest {
  clientToken?: string(name='ClientToken'),
  domainName?: string(name='DomainName'),
  isp?: [ string ](name='Isp'),
  lang?: string(name='Lang'),
}

model SubmitIspFlushCacheTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model SubmitIspFlushCacheTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitIspFlushCacheTaskResponseBody(name='body'),
}

async function submitIspFlushCacheTaskWithOptions(request: SubmitIspFlushCacheTaskRequest, runtime: Util.RuntimeOptions): SubmitIspFlushCacheTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.isp)) {
    query['Isp'] = request.isp;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitIspFlushCacheTask',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitIspFlushCacheTask(request: SubmitIspFlushCacheTaskRequest): SubmitIspFlushCacheTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitIspFlushCacheTaskWithOptions(request, runtime);
}

model SwitchDnsGtmInstanceStrategyModeRequest {
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance.', example='instance1'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  strategyMode?: string(name='StrategyMode', description='The access policy type. Valid values:

*   GEO: geographical location-based
*   LATENCY: latency-based', example='GEO'),
}

model SwitchDnsGtmInstanceStrategyModeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model SwitchDnsGtmInstanceStrategyModeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SwitchDnsGtmInstanceStrategyModeResponseBody(name='body'),
}

async function switchDnsGtmInstanceStrategyModeWithOptions(request: SwitchDnsGtmInstanceStrategyModeRequest, runtime: Util.RuntimeOptions): SwitchDnsGtmInstanceStrategyModeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyMode)) {
    query['StrategyMode'] = request.strategyMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SwitchDnsGtmInstanceStrategyMode',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function switchDnsGtmInstanceStrategyMode(request: SwitchDnsGtmInstanceStrategyModeRequest): SwitchDnsGtmInstanceStrategyModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return switchDnsGtmInstanceStrategyModeWithOptions(request, runtime);
}

model TagResourcesRequest {
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.', example='en'),
  resourceId?: [ string ](name='ResourceId', description='The domain name.', example='dns-example.com'),
  resourceType?: string(name='ResourceType', description='The type of the resource.', example='DOMAIN'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag.', example='abcd'),
      value?: string(name='Value', description='The value of the tag.', example='abcd'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='635B0CCD-15A7-48C9-B4D6-628FF57FF4B8'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model TransferDomainRequest {
  domainNames?: string(name='DomainNames', description='The list of domain names. Separate multiple domain names with commas (,). Only domain names registered with Alibaba Cloud are supported.', example='test1.com,test2.com'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  remark?: string(name='Remark', description='The detailed information.', example='test domain transfer'),
  targetUserId?: long(name='TargetUserId', description='The ID of the user to which domain names were transferred.', example='12345678'),
}

model TransferDomainResponseBody = {
  requestId?: string(name='RequestId', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  taskId?: long(name='TaskId', example='112233'),
}

model TransferDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TransferDomainResponseBody(name='body'),
}

async function transferDomainWithOptions(request: TransferDomainRequest, runtime: Util.RuntimeOptions): TransferDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainNames)) {
    query['DomainNames'] = request.domainNames;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.targetUserId)) {
    query['TargetUserId'] = request.targetUserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TransferDomain',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function transferDomain(request: TransferDomainRequest): TransferDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return transferDomainWithOptions(request, runtime);
}

model UnbindInstanceDomainsRequest {
  domainNames?: string(name='DomainNames', description='The list of domain names.

Separate multiple domain names with commas (,). A maximum of 100 domain names can be entered.', example='example.com,example.net'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='123'),
  lang?: string(name='Lang', description='The language type.', example='en'),
}

model UnbindInstanceDomainsResponseBody = {
  failedCount?: int32(name='FailedCount', description='The number of domain names that failed to be unbound.', example='0'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='123'),
  successCount?: int32(name='SuccessCount', description='The number of domain names that have been unbound.', example='2'),
}

model UnbindInstanceDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnbindInstanceDomainsResponseBody(name='body'),
}

async function unbindInstanceDomainsWithOptions(request: UnbindInstanceDomainsRequest, runtime: Util.RuntimeOptions): UnbindInstanceDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainNames)) {
    query['DomainNames'] = request.domainNames;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnbindInstanceDomains',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unbindInstanceDomains(request: UnbindInstanceDomainsRequest): UnbindInstanceDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindInstanceDomainsWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All', example='false'),
  lang?: string(name='Lang', example='en'),
  resourceId?: [ string ](name='ResourceId', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.', example='The type of the resource.'),
  resourceType?: string(name='ResourceType', description='Resource Type', example='DOMAIN'),
  tagKey?: [ string ](name='TagKey', description='Specifies whether to remove all tags from the specified resource. Default value: false. This parameter takes effect only when the TagKey.N parameter is not specified. Valid values:

*   true
*   false', example='The domain name.'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='"dns-example.com","dns-test.com"', example='F152A869-DF77-4DF1-9A00-4E06978FE6A1'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateAppKeyStateRequest {
  appKeyId?: string(name='AppKeyId'),
  lang?: string(name='Lang'),
  state?: string(name='State'),
}

model UpdateAppKeyStateResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAppKeyStateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAppKeyStateResponseBody(name='body'),
}

async function updateAppKeyStateWithOptions(request: UpdateAppKeyStateRequest, runtime: Util.RuntimeOptions): UpdateAppKeyStateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appKeyId)) {
    query['AppKeyId'] = request.appKeyId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAppKeyState',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAppKeyState(request: UpdateAppKeyStateRequest): UpdateAppKeyStateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAppKeyStateWithOptions(request, runtime);
}

model UpdateCustomLineRequest {
  ipSegment?: [ 
    {
      endIp?: string(name='EndIp', description='The end IP address of the CIDR block.', example='2.2.2.2'),
      startIp?: string(name='StartIp', description='The start IP address of the CIDR block.', example='1.1.1.1'),
    }
  ](name='IpSegment'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  lineId?: long(name='LineId', description='The unique ID of the custom line.', example='1234'),
  lineName?: string(name='LineName', description='The new name of the custom line.'),
}

model UpdateCustomLineResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
}

model UpdateCustomLineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateCustomLineResponseBody(name='body'),
}

/**
  * In each CIDR block, the end IP address must be greater than or equal to the start IP address.
  * The CIDR blocks that are specified for all custom lines of a domain name cannot intersect.
  *
  * @param request UpdateCustomLineRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateCustomLineResponse
 */
async function updateCustomLineWithOptions(request: UpdateCustomLineRequest, runtime: Util.RuntimeOptions): UpdateCustomLineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ipSegment)) {
    query['IpSegment'] = request.ipSegment;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lineId)) {
    query['LineId'] = request.lineId;
  }
  if (!Util.isUnset(request.lineName)) {
    query['LineName'] = request.lineName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCustomLine',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * In each CIDR block, the end IP address must be greater than or equal to the start IP address.
  * The CIDR blocks that are specified for all custom lines of a domain name cannot intersect.
  *
  * @param request UpdateCustomLineRequest
  * @return UpdateCustomLineResponse
 */
async function updateCustomLine(request: UpdateCustomLineRequest): UpdateCustomLineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCustomLineWithOptions(request, runtime);
}

model UpdateDNSSLBWeightRequest {
  lang?: string(name='Lang', description='The language of the domain name.', example='en'),
  recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client that you use to change the weight.', example='1.1.1.1'),
  weight?: int32(name='Weight', description='The updated weight of the DNS record. Valid values: `1 to 100`.', example='2'),
}

model UpdateDNSSLBWeightResponseBody = {
  recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  weight?: int32(name='Weight', description='The updated weight.', example='2'),
}

model UpdateDNSSLBWeightResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDNSSLBWeightResponseBody(name='body'),
}

async function updateDNSSLBWeightWithOptions(request: UpdateDNSSLBWeightRequest, runtime: Util.RuntimeOptions): UpdateDNSSLBWeightResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recordId)) {
    query['RecordId'] = request.recordId;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  if (!Util.isUnset(request.weight)) {
    query['Weight'] = request.weight;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDNSSLBWeight',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDNSSLBWeight(request: UpdateDNSSLBWeightRequest): UpdateDNSSLBWeightResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDNSSLBWeightWithOptions(request, runtime);
}

model UpdateDnsCacheDomainRequest {
  cacheTtlMax?: int32(name='CacheTtlMax', description='The maximum TTL period of the cached data retrieved from the origin DNS server. Unit: seconds. Valid values: 30 to 86400.', example='86400'),
  cacheTtlMin?: int32(name='CacheTtlMin', description='The minimum time-to-live (TTL) period of the cached data retrieved from the origin Domain Name System (DNS) server. Unit: seconds. Valid values: 30 to 86400.', example='30'),
  domainName?: string(name='DomainName', description='The domain name.', example='dns.example.com'),
  instanceId?: string(name='InstanceId', description='The instance ID of the cache-accelerated domain name.', example='dns-sg-l9u2ux1fw01'),
  lang?: string(name='Lang', description='The language.', example='en'),
  sourceDnsServer?: [ 
    {
      host?: string(name='Host', description='The domain name or IP address of the origin DNS server.', example='223.5.5.5'),
      port?: string(name='Port', description='The port of the origin DNS server.', example='53'),
    }
  ](name='SourceDnsServer', description='The origin DNS servers. A maximum of 10 origin DNS servers are supported.'),
  sourceEdns?: string(name='SourceEdns', description='Specifies whether the origin DNS server supports Extension Mechanisms for DNS (EDNS). Valid values: NOT_SUPPORT and SUPPORT.', example='SUPPORT'),
  sourceProtocol?: string(name='SourceProtocol', description='The origin protocol policy. Valid values: TCP and UDP. Default value: UDP.', example='UDP'),
}

model UpdateDnsCacheDomainResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model UpdateDnsCacheDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDnsCacheDomainResponseBody(name='body'),
}

async function updateDnsCacheDomainWithOptions(request: UpdateDnsCacheDomainRequest, runtime: Util.RuntimeOptions): UpdateDnsCacheDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cacheTtlMax)) {
    query['CacheTtlMax'] = request.cacheTtlMax;
  }
  if (!Util.isUnset(request.cacheTtlMin)) {
    query['CacheTtlMin'] = request.cacheTtlMin;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceDnsServer)) {
    query['SourceDnsServer'] = request.sourceDnsServer;
  }
  if (!Util.isUnset(request.sourceEdns)) {
    query['SourceEdns'] = request.sourceEdns;
  }
  if (!Util.isUnset(request.sourceProtocol)) {
    query['SourceProtocol'] = request.sourceProtocol;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDnsCacheDomain',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDnsCacheDomain(request: UpdateDnsCacheDomainRequest): UpdateDnsCacheDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDnsCacheDomainWithOptions(request, runtime);
}

model UpdateDnsCacheDomainRemarkRequest {
  domainName?: string(name='DomainName', example='dns-example.com'),
  lang?: string(name='Lang', example='en'),
  remark?: string(name='Remark', example='test'),
}

model UpdateDnsCacheDomainRemarkResponseBody = {
  requestId?: string(name='RequestId', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model UpdateDnsCacheDomainRemarkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDnsCacheDomainRemarkResponseBody(name='body'),
}

async function updateDnsCacheDomainRemarkWithOptions(request: UpdateDnsCacheDomainRemarkRequest, runtime: Util.RuntimeOptions): UpdateDnsCacheDomainRemarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDnsCacheDomainRemark',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDnsCacheDomainRemark(request: UpdateDnsCacheDomainRemarkRequest): UpdateDnsCacheDomainRemarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDnsCacheDomainRemarkWithOptions(request, runtime);
}

model UpdateDnsGtmAccessStrategyRequest {
  accessMode?: string(name='AccessMode'),
  defaultAddrPool?: [ 
    {
      id?: string(name='Id', description='The ID of the address pool in the primary address pool group.', example='pool1'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool in the primary address pool group.', example='1'),
    }
  ](name='DefaultAddrPool'),
  defaultAddrPoolType?: string(name='DefaultAddrPoolType', description='The type of the primary address pool. Valid values:

*   IPV4
*   IPV6
*   DOMAIN', example='ipv4'),
  defaultLatencyOptimization?: string(name='DefaultLatencyOptimization', description='Specifies whether to enable scheduling optimization for latency resolution for the primary address pool group. Valid values:

*   OPEN: enable
*   CLOSE: disable', example='open'),
  defaultLbaStrategy?: string(name='DefaultLbaStrategy', description='The load balancing policy of the primary address pool group. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr'),
  defaultMaxReturnAddrNum?: int32(name='DefaultMaxReturnAddrNum', description='The maximum number of addresses returned from the primary address pool group.', example='1'),
  defaultMinAvailableAddrNum?: int32(name='DefaultMinAvailableAddrNum', description='The minimum number of available addresses in the primary address pool group.', example='1'),
  failoverAddrPool?: [ 
    {
      id?: string(name='Id', description='The ID of the address pool in the secondary address pool group.', example='pool1'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool in the secondary address pool group.', example='1'),
    }
  ](name='FailoverAddrPool'),
  failoverAddrPoolType?: string(name='FailoverAddrPoolType', description='The type of the secondary address pool. Valid values:

*   IPV4
*   IPV6
*   DOMAIN', example='ipv4'),
  failoverLatencyOptimization?: string(name='FailoverLatencyOptimization', description='Specifies whether to enable scheduling optimization for latency resolution for the secondary address pool group. Valid values:

*   OPEN: enable
*   CLOSE: disable', example='open'),
  failoverLbaStrategy?: string(name='FailoverLbaStrategy', description='The load balancing policy of the secondary address pool group. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr'),
  failoverMaxReturnAddrNum?: int32(name='FailoverMaxReturnAddrNum', description='The maximum number of addresses returned from the secondary address pool group.', example='1'),
  failoverMinAvailableAddrNum?: int32(name='FailoverMinAvailableAddrNum', description='The minimum number of available addresses in the secondary address pool group.', example='1'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  lines?: string(name='Lines', description='The line codes of source regions. For example: `["default", "drpeng"]` indicates Global and Dr. Peng Telecom & Media Group.', example='["default", "drpeng"]'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy.', example='StrategyId1'),
  strategyName?: string(name='StrategyName', description='The name of the access policy.', example='StrategyName1'),
}

model UpdateDnsGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy.', example='testStrategyId1'),
}

model UpdateDnsGtmAccessStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDnsGtmAccessStrategyResponseBody(name='body'),
}

async function updateDnsGtmAccessStrategyWithOptions(request: UpdateDnsGtmAccessStrategyRequest, runtime: Util.RuntimeOptions): UpdateDnsGtmAccessStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessMode)) {
    query['AccessMode'] = request.accessMode;
  }
  if (!Util.isUnset(request.defaultAddrPool)) {
    query['DefaultAddrPool'] = request.defaultAddrPool;
  }
  if (!Util.isUnset(request.defaultAddrPoolType)) {
    query['DefaultAddrPoolType'] = request.defaultAddrPoolType;
  }
  if (!Util.isUnset(request.defaultLatencyOptimization)) {
    query['DefaultLatencyOptimization'] = request.defaultLatencyOptimization;
  }
  if (!Util.isUnset(request.defaultLbaStrategy)) {
    query['DefaultLbaStrategy'] = request.defaultLbaStrategy;
  }
  if (!Util.isUnset(request.defaultMaxReturnAddrNum)) {
    query['DefaultMaxReturnAddrNum'] = request.defaultMaxReturnAddrNum;
  }
  if (!Util.isUnset(request.defaultMinAvailableAddrNum)) {
    query['DefaultMinAvailableAddrNum'] = request.defaultMinAvailableAddrNum;
  }
  if (!Util.isUnset(request.failoverAddrPool)) {
    query['FailoverAddrPool'] = request.failoverAddrPool;
  }
  if (!Util.isUnset(request.failoverAddrPoolType)) {
    query['FailoverAddrPoolType'] = request.failoverAddrPoolType;
  }
  if (!Util.isUnset(request.failoverLatencyOptimization)) {
    query['FailoverLatencyOptimization'] = request.failoverLatencyOptimization;
  }
  if (!Util.isUnset(request.failoverLbaStrategy)) {
    query['FailoverLbaStrategy'] = request.failoverLbaStrategy;
  }
  if (!Util.isUnset(request.failoverMaxReturnAddrNum)) {
    query['FailoverMaxReturnAddrNum'] = request.failoverMaxReturnAddrNum;
  }
  if (!Util.isUnset(request.failoverMinAvailableAddrNum)) {
    query['FailoverMinAvailableAddrNum'] = request.failoverMinAvailableAddrNum;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lines)) {
    query['Lines'] = request.lines;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  if (!Util.isUnset(request.strategyName)) {
    query['StrategyName'] = request.strategyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDnsGtmAccessStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDnsGtmAccessStrategy(request: UpdateDnsGtmAccessStrategyRequest): UpdateDnsGtmAccessStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDnsGtmAccessStrategyWithOptions(request, runtime);
}

model UpdateDnsGtmAddressPoolRequest {
  addr?: [ 
    {
      addr?: string(name='Addr', description='The address in the address pool.', example='1.1.1.1'),
      attributeInfo?: string(name='AttributeInfo', description='The source region of the address, in JSON-formatted string.

*   LineCode: the line code of the source region of the address. The LineCode field is deprecated, and the lineCodes field is used as a substitute.

*   LineCodes: the line code list of the source regions of addresses.

*   lineCodeRectifyType: the rectification type of the line codes. Default value: AUTO. Valid values:

    *   NO_NEED: no need for rectification.
    *   RECTIFIED: rectified.
    *   AUTO: automatic rectification.', example='Linecode:default,lineCodes:["default"],lineCodeRectifyType:"NO_NEED"'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address.', example='1'),
      mode?: string(name='Mode', description='The response mode: Valid values:

*   SMART: smart return.
*   ONLINE: always online.
*   OFFLINE: always offline.', example='online'),
      remark?: string(name='Remark', description='The additional information about the address.', example='test'),
    }
  ](name='Addr', description='The address pools.'),
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.', example='testpool1'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  lbaStrategy?: string(name='LbaStrategy', description='The load balancing policy of the address pool. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr'),
  name?: string(name='Name', description='The name of the address pool.', example='testpoolname'),
}

model UpdateDnsGtmAddressPoolResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model UpdateDnsGtmAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDnsGtmAddressPoolResponseBody(name='body'),
}

async function updateDnsGtmAddressPoolWithOptions(request: UpdateDnsGtmAddressPoolRequest, runtime: Util.RuntimeOptions): UpdateDnsGtmAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addr)) {
    query['Addr'] = request.addr;
  }
  if (!Util.isUnset(request.addrPoolId)) {
    query['AddrPoolId'] = request.addrPoolId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lbaStrategy)) {
    query['LbaStrategy'] = request.lbaStrategy;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDnsGtmAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDnsGtmAddressPool(request: UpdateDnsGtmAddressPoolRequest): UpdateDnsGtmAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDnsGtmAddressPoolWithOptions(request, runtime);
}

model UpdateDnsGtmInstanceGlobalConfigRequest {
  alertConfig?: [ 
    {
      dingtalkNotice?: boolean(name='DingtalkNotice'),
      emailNotice?: boolean(name='EmailNotice', example='true'),
      noticeType?: string(name='NoticeType', example='ADDR_ALERT'),
      smsNotice?: boolean(name='SmsNotice', example='true'),
    }
  ](name='AlertConfig'),
  alertGroup?: string(name='AlertGroup', description='The name of the alert group in the JSON format.', example='alertGroup1'),
  cnameType?: string(name='CnameType', description='The type of the CNAME domain name that is used to access the instance. Valid value:

*   PUBLIC: The CNAME domain name is used to access the instance over the Internet.', example='public'),
  forceUpdate?: boolean(name='ForceUpdate', description='Specifies whether to enable force updates. Valid values:

*   true: enables force update without a conflict alert.
*   false: disables force update. If a conflict occurs, the system displays an alert. null: This valid value of ForceUpdate provides the same information as the false value.', example='true'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='instance1'),
  instanceName?: string(name='InstanceName', description='The name of the instance. This parameter is required only for the first update.', example='test'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  publicCnameMode?: string(name='PublicCnameMode', description='Specifies whether to use a custom CNAME domain name or a CNAME domain name assigned by the system to access the instance over the Internet. Valid values:

*   SYSTEM_ASSIGN: a CNAME domain name assigned by the system
*   CUSTOM: a custom CNAME domain name', example='custom'),
  publicRr?: string(name='PublicRr', description='The hostname corresponding to the CNAME domain name that is used to access the instance over the Internet.', example='test.rr'),
  publicUserDomainName?: string(name='PublicUserDomainName', description='The service domain name that is used over the Internet.', example='example.com'),
  publicZoneName?: string(name='PublicZoneName', description='The CNAME domain name that is used to access the instance over the Internet, which is the primary domain name. This parameter is required when the PublicCnameMode parameter is set to CUSTOM.

>  You must use the primary domain name. Do not include the hostname specified by the PublicRr parameter.', example='gtm-003.com'),
  ttl?: int32(name='Ttl', description='The global time to live (TTL).', example='1'),
}

model UpdateDnsGtmInstanceGlobalConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
}

model UpdateDnsGtmInstanceGlobalConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDnsGtmInstanceGlobalConfigResponseBody(name='body'),
}

async function updateDnsGtmInstanceGlobalConfigWithOptions(request: UpdateDnsGtmInstanceGlobalConfigRequest, runtime: Util.RuntimeOptions): UpdateDnsGtmInstanceGlobalConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertConfig)) {
    query['AlertConfig'] = request.alertConfig;
  }
  if (!Util.isUnset(request.alertGroup)) {
    query['AlertGroup'] = request.alertGroup;
  }
  if (!Util.isUnset(request.cnameType)) {
    query['CnameType'] = request.cnameType;
  }
  if (!Util.isUnset(request.forceUpdate)) {
    query['ForceUpdate'] = request.forceUpdate;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.publicCnameMode)) {
    query['PublicCnameMode'] = request.publicCnameMode;
  }
  if (!Util.isUnset(request.publicRr)) {
    query['PublicRr'] = request.publicRr;
  }
  if (!Util.isUnset(request.publicUserDomainName)) {
    query['PublicUserDomainName'] = request.publicUserDomainName;
  }
  if (!Util.isUnset(request.publicZoneName)) {
    query['PublicZoneName'] = request.publicZoneName;
  }
  if (!Util.isUnset(request.ttl)) {
    query['Ttl'] = request.ttl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDnsGtmInstanceGlobalConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDnsGtmInstanceGlobalConfig(request: UpdateDnsGtmInstanceGlobalConfigRequest): UpdateDnsGtmInstanceGlobalConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDnsGtmInstanceGlobalConfigWithOptions(request, runtime);
}

model UpdateDnsGtmMonitorRequest {
  evaluationCount?: int32(name='EvaluationCount', description='The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.', example='2'),
  interval?: int32(name='Interval', description='The health check interval. Unit: seconds.', example='60'),
  ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the city where the monitored node is deployed.', example='123'),
      ispCode?: string(name='IspCode', description='The code of the Internet service provider (ISP) to which the monitored node belongs.', example='123'),
    }
  ](name='IspCityNode', description='The monitored nodes.'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.', example='MonitorConfigId1'),
  monitorExtendInfo?: string(name='MonitorExtendInfo', description='The extended information, that is, the parameters required for the protocol. Different protocols require different parameters:

*   HTTP or HTTPS:

    *   port: the port to check.

    *   host: the host configuration.

    *   path: the health check URL.

    *   code: the status code threshold. If the returned status code is greater than the specified threshold, the application service is deemed abnormal.

    *   failureRate: the failure rate.

    *   sni: specifies whether to enable Server Name Indication (SNI). This parameter is only required for the HTTPS protocol. Valid values:

        *   true: enables SNI.
        *   false: disables SNI.

    *   nodeType: the type of the monitored node when the address pool type is DOMAIN. Valid values:

        *   IPV4
        *   IPV6

*   PING:

    *   failureRate: the failure rate.

    *   packetNum: the number of ping packets.

    *   packetLossRate: the loss rate of ping packets.

    *   nodeType: the type of the monitored node when the address pool type is DOMAIN. Valid values:

        *   IPV4
        *   IPV6

*   TCP:

    *   port: the port to check.

    *   failureRate: the failure rate.

    *   nodeType: the type of the monitored node when the address pool type is DOMAIN. Valid values:

        *   IPV4
        *   IPV6', example='{\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}'),
  protocolType?: string(name='ProtocolType', description='The protocol used for the health check. Valid values:

*   HTTP
*   HTTPS
*   PING
*   TCP', example='http'),
  timeout?: int32(name='Timeout', description='The health check timeout period. Unit: milliseconds.', example='30000'),
}

model UpdateDnsGtmMonitorResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model UpdateDnsGtmMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDnsGtmMonitorResponseBody(name='body'),
}

async function updateDnsGtmMonitorWithOptions(request: UpdateDnsGtmMonitorRequest, runtime: Util.RuntimeOptions): UpdateDnsGtmMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispCityNode)) {
    query['IspCityNode'] = request.ispCityNode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.monitorConfigId)) {
    query['MonitorConfigId'] = request.monitorConfigId;
  }
  if (!Util.isUnset(request.monitorExtendInfo)) {
    query['MonitorExtendInfo'] = request.monitorExtendInfo;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDnsGtmMonitor',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDnsGtmMonitor(request: UpdateDnsGtmMonitorRequest): UpdateDnsGtmMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDnsGtmMonitorWithOptions(request, runtime);
}

model UpdateDomainGroupRequest {
  groupId?: string(name='GroupId', description='The ID of the domain name group.', example='2223'),
  groupName?: string(name='GroupName', description='The new name of the domain name group.', example='NewName'),
  lang?: string(name='Lang', description='The language type.', example='en'),
}

model UpdateDomainGroupResponseBody = {
  groupId?: string(name='GroupId', description='The ID of the domain name group.', example='2223'),
  groupName?: string(name='GroupName', description='The new name of the domain name group.', example='NewName'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model UpdateDomainGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDomainGroupResponseBody(name='body'),
}

async function updateDomainGroupWithOptions(request: UpdateDomainGroupRequest, runtime: Util.RuntimeOptions): UpdateDomainGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDomainGroup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDomainGroup(request: UpdateDomainGroupRequest): UpdateDomainGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDomainGroupWithOptions(request, runtime);
}

model UpdateDomainRecordRequest {
  lang?: string(name='Lang', description='The language type.', example='en'),
  line?: string(name='Line', description='The resolution line. Default value: **default**.', example='default'),
  priority?: long(name='Priority', description='The priority of an MX-type DNS record. Valid values: `[1,50]`.

This parameter must be specified if the type of the DNS record is MX.', example='1'),
  RR?: string(name='RR', description='The host record.

For example, to resolve @.example.com, you must set RR to an at sign (@) instead of leaving it blank.', example='www'),
  recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
  TTL?: long(name='TTL', description='The TTL of the resolution. Default value: 600. Unit: seconds.', example='600'),
  type?: string(name='Type', description='The type of the DNS record.', example='A'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0'),
  value?: string(name='Value', description='The value of the DNS record.', example='192.0.2.254'),
}

model UpdateDomainRecordResponseBody = {
  recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model UpdateDomainRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDomainRecordResponseBody(name='body'),
}

async function updateDomainRecordWithOptions(request: UpdateDomainRecordRequest, runtime: Util.RuntimeOptions): UpdateDomainRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.line)) {
    query['Line'] = request.line;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.RR)) {
    query['RR'] = request.RR;
  }
  if (!Util.isUnset(request.recordId)) {
    query['RecordId'] = request.recordId;
  }
  if (!Util.isUnset(request.TTL)) {
    query['TTL'] = request.TTL;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDomainRecord',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDomainRecord(request: UpdateDomainRecordRequest): UpdateDomainRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDomainRecordWithOptions(request, runtime);
}

model UpdateDomainRecordRemarkRequest {
  lang?: string(name='Lang', description='The language type.', example='cn'),
  recordId?: string(name='RecordId', description='The ID of the DNS record.', example='12345678'),
  remark?: string(name='Remark', description='The description of your DNS record.'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0'),
}

model UpdateDomainRecordRemarkResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model UpdateDomainRecordRemarkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDomainRecordRemarkResponseBody(name='body'),
}

async function updateDomainRecordRemarkWithOptions(request: UpdateDomainRecordRemarkRequest, runtime: Util.RuntimeOptions): UpdateDomainRecordRemarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recordId)) {
    query['RecordId'] = request.recordId;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDomainRecordRemark',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDomainRecordRemark(request: UpdateDomainRecordRemarkRequest): UpdateDomainRecordRemarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDomainRecordRemarkWithOptions(request, runtime);
}

model UpdateDomainRemarkRequest {
  domainName?: string(name='DomainName', description='The domain name in Alibaba Cloud DNS.', example='mydomain.com'),
  lang?: string(name='Lang', description='The language type.', example='cn'),
  remark?: string(name='Remark', description='The description of your domain name.'),
}

model UpdateDomainRemarkResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model UpdateDomainRemarkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDomainRemarkResponseBody(name='body'),
}

async function updateDomainRemarkWithOptions(request: UpdateDomainRemarkRequest, runtime: Util.RuntimeOptions): UpdateDomainRemarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDomainRemark',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDomainRemark(request: UpdateDomainRemarkRequest): UpdateDomainRemarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDomainRemarkWithOptions(request, runtime);
}

model UpdateGtmAccessStrategyRequest {
  accessLines?: string(name='AccessLines', description='The line codes of access regions.', example='["default", "mobile"]'),
  defaultAddrPoolId?: string(name='DefaultAddrPoolId', description='The ID of the default address pool.', example='hrsix'),
  failoverAddrPoolId?: string(name='FailoverAddrPoolId', description='The ID of the failover address pool.', example='hrsyw'),
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy that you want to query for the GTM instance.', example='hrmxc'),
  strategyName?: string(name='StrategyName', description='The name of the access policy.'),
}

model UpdateGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
}

model UpdateGtmAccessStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGtmAccessStrategyResponseBody(name='body'),
}

async function updateGtmAccessStrategyWithOptions(request: UpdateGtmAccessStrategyRequest, runtime: Util.RuntimeOptions): UpdateGtmAccessStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessLines)) {
    query['AccessLines'] = request.accessLines;
  }
  if (!Util.isUnset(request.defaultAddrPoolId)) {
    query['DefaultAddrPoolId'] = request.defaultAddrPoolId;
  }
  if (!Util.isUnset(request.failoverAddrPoolId)) {
    query['FailoverAddrPoolId'] = request.failoverAddrPoolId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  if (!Util.isUnset(request.strategyName)) {
    query['StrategyName'] = request.strategyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGtmAccessStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGtmAccessStrategy(request: UpdateGtmAccessStrategyRequest): UpdateGtmAccessStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGtmAccessStrategyWithOptions(request, runtime);
}

model UpdateGtmAddressPoolRequest {
  addr?: [ 
    {
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool that you want to modify.', example='1'),
      mode?: string(name='Mode', description='The mode of the address pool that you want to modify.

*   **SMART**: Intelligent return
*   **ONLINE**: Always online
*   **OFFLINE**: Always offline', example='SMART'),
      value?: string(name='Value', description='The addresses in the address pool.', example='1.1.1.1'),
    }
  ](name='Addr'),
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool that you want to modify.', example='1234abc'),
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  minAvailableAddrNum?: int32(name='MinAvailableAddrNum', description='The minimum number of available addresses in the address pool.', example='2'),
  name?: string(name='Name', description='The name of the address pool that you want to modify.'),
  type?: string(name='Type', description='The type of the address pool that you want to modify.', example='IP'),
}

model UpdateGtmAddressPoolResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model UpdateGtmAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGtmAddressPoolResponseBody(name='body'),
}

async function updateGtmAddressPoolWithOptions(request: UpdateGtmAddressPoolRequest, runtime: Util.RuntimeOptions): UpdateGtmAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addr)) {
    query['Addr'] = request.addr;
  }
  if (!Util.isUnset(request.addrPoolId)) {
    query['AddrPoolId'] = request.addrPoolId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.minAvailableAddrNum)) {
    query['MinAvailableAddrNum'] = request.minAvailableAddrNum;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGtmAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGtmAddressPool(request: UpdateGtmAddressPoolRequest): UpdateGtmAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGtmAddressPoolWithOptions(request, runtime);
}

model UpdateGtmInstanceGlobalConfigRequest {
  alertGroup?: string(name='AlertGroup', description='The alert group of the GTM instance. Currently, only one alert group is supported.

>  This parameter is required for the first update, but is optional for later updates.'),
  cnameCustomDomainName?: string(name='CnameCustomDomainName', description='The CNAME record of a domain name, which must be the primary domain name. When **CnameMode** is **CUSTOM**, this parameter is required for access.', example='www.example.com'),
  cnameMode?: string(name='CnameMode', description='Specifies whether the CNAME record is user-defined or automatically assigned by the system. Valid values:

*   **SYSTEM_ASSIGN**: Assigned by the system
*   **CUSTOM**: User-defined', example='SYSTEM_ASSIGN'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance whose configuration you want to modify.', example='instance1'),
  instanceName?: string(name='InstanceName', description='The name of the GTM instance.

>  This parameter is required for the first update, but is not required for later updates.'),
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  lbaStrategy?: string(name='LbaStrategy', description='The load balancing policy. Valid values:

*   **ALL_RR**: Load balancing

*   **RATIO**: Weighted round robin

> This parameter is required for the first update, but is optional for later updates.', example='RATIO'),
  ttl?: int32(name='Ttl', description='The time when the modification takes effect.', example='60'),
  userDomainName?: string(name='UserDomainName', description='The primary domain name.

>  This parameter is required for the first update, but is optional for later updates.', example='www.example.com'),
}

model UpdateGtmInstanceGlobalConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
}

model UpdateGtmInstanceGlobalConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGtmInstanceGlobalConfigResponseBody(name='body'),
}

async function updateGtmInstanceGlobalConfigWithOptions(request: UpdateGtmInstanceGlobalConfigRequest, runtime: Util.RuntimeOptions): UpdateGtmInstanceGlobalConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertGroup)) {
    query['AlertGroup'] = request.alertGroup;
  }
  if (!Util.isUnset(request.cnameCustomDomainName)) {
    query['CnameCustomDomainName'] = request.cnameCustomDomainName;
  }
  if (!Util.isUnset(request.cnameMode)) {
    query['CnameMode'] = request.cnameMode;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lbaStrategy)) {
    query['LbaStrategy'] = request.lbaStrategy;
  }
  if (!Util.isUnset(request.ttl)) {
    query['Ttl'] = request.ttl;
  }
  if (!Util.isUnset(request.userDomainName)) {
    query['UserDomainName'] = request.userDomainName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGtmInstanceGlobalConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGtmInstanceGlobalConfig(request: UpdateGtmInstanceGlobalConfigRequest): UpdateGtmInstanceGlobalConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGtmInstanceGlobalConfigWithOptions(request, runtime);
}

model UpdateGtmMonitorRequest {
  evaluationCount?: int32(name='EvaluationCount', description='The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.', example='3'),
  interval?: int32(name='Interval', description='The health check interval. Unit: seconds. Set the value to 60.', example='60'),
  ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the city where the monitored node is deployed.', example='572'),
      ispCode?: string(name='IspCode', description='*   The code of the Internet service provider (ISP) to which the monitored node belongs. For more information about specific values, see the response parameters of DescribeGtmMonitorAvailableConfig.
*   If the value of the GroupType parameter is BGP or OVERSEAS, IspCode is optional. The default value is 465.
*   If the value of the GroupType parameter is not BGP or OVERSEAS, IspCode is required and is used together with CityCode.', example='465'),
    }
  ](name='IspCityNode', description='The monitored nodes.'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters.', example='en'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.', example='1234abc'),
  monitorExtendInfo?: string(name='MonitorExtendInfo', description='The extended information, that is, the parameters required for the protocol. Different protocols require different parameters:

HTTP or HTTPS:

*   port: the port to check.
*   failureRate: the failure rate.
*   code: the status code threshold. If the returned status code is greater than the specified threshold, the application service is deemed abnormal. Valid values: 400 and 500.
*   host: the host configuration.
*   path: the health check URL.

PING:

*   packetNum: the number of ping packets.
*   packetLossRate: the loss rate of ping packets.
*   failureRate: the failure rate.

TCP:

*   port: the port to check.
*   failureRate: the failure rate.', example='{\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}'),
  protocolType?: string(name='ProtocolType', description='The protocol used for the health check.', example='HTTP'),
  timeout?: int32(name='Timeout', description='The health check timeout period. Unit: milliseconds. Valid values: 2000, 3000, 5000, and 10000.', example='3000'),
}

model UpdateGtmMonitorResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model UpdateGtmMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGtmMonitorResponseBody(name='body'),
}

async function updateGtmMonitorWithOptions(request: UpdateGtmMonitorRequest, runtime: Util.RuntimeOptions): UpdateGtmMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispCityNode)) {
    query['IspCityNode'] = request.ispCityNode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.monitorConfigId)) {
    query['MonitorConfigId'] = request.monitorConfigId;
  }
  if (!Util.isUnset(request.monitorExtendInfo)) {
    query['MonitorExtendInfo'] = request.monitorExtendInfo;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGtmMonitor',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGtmMonitor(request: UpdateGtmMonitorRequest): UpdateGtmMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGtmMonitorWithOptions(request, runtime);
}

model UpdateGtmRecoveryPlanRequest {
  faultAddrPool?: string(name='FaultAddrPool', description='The list of faulty address pools.', example='["hra0or"]'),
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.', example='en'),
  name?: string(name='Name', description='The name of the disaster recovery plan.', example='abc'),
  recoveryPlanId?: long(name='RecoveryPlanId', description='The ID of the disaster recovery plan.', example='100'),
  remark?: string(name='Remark', description='The remarks about the disaster recovery plan.', example='remark'),
}

model UpdateGtmRecoveryPlanResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model UpdateGtmRecoveryPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGtmRecoveryPlanResponseBody(name='body'),
}

async function updateGtmRecoveryPlanWithOptions(request: UpdateGtmRecoveryPlanRequest, runtime: Util.RuntimeOptions): UpdateGtmRecoveryPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.faultAddrPool)) {
    query['FaultAddrPool'] = request.faultAddrPool;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.recoveryPlanId)) {
    query['RecoveryPlanId'] = request.recoveryPlanId;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGtmRecoveryPlan',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGtmRecoveryPlan(request: UpdateGtmRecoveryPlanRequest): UpdateGtmRecoveryPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGtmRecoveryPlanWithOptions(request, runtime);
}

model UpdateIspFlushCacheInstanceConfigRequest {
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  lang?: string(name='Lang'),
}

model UpdateIspFlushCacheInstanceConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIspFlushCacheInstanceConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateIspFlushCacheInstanceConfigResponseBody(name='body'),
}

async function updateIspFlushCacheInstanceConfigWithOptions(request: UpdateIspFlushCacheInstanceConfigRequest, runtime: Util.RuntimeOptions): UpdateIspFlushCacheInstanceConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIspFlushCacheInstanceConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateIspFlushCacheInstanceConfig(request: UpdateIspFlushCacheInstanceConfigRequest): UpdateIspFlushCacheInstanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIspFlushCacheInstanceConfigWithOptions(request, runtime);
}

model ValidateDnsGtmCnameRrCanUseRequest {
  cnameMode?: string(name='CnameMode'),
  cnameRr?: string(name='CnameRr'),
  cnameType?: string(name='CnameType'),
  cnameZone?: string(name='CnameZone'),
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
}

model ValidateDnsGtmCnameRrCanUseResponseBody = {
  requestId?: string(name='RequestId'),
}

model ValidateDnsGtmCnameRrCanUseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ValidateDnsGtmCnameRrCanUseResponseBody(name='body'),
}

async function validateDnsGtmCnameRrCanUseWithOptions(request: ValidateDnsGtmCnameRrCanUseRequest, runtime: Util.RuntimeOptions): ValidateDnsGtmCnameRrCanUseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cnameMode)) {
    query['CnameMode'] = request.cnameMode;
  }
  if (!Util.isUnset(request.cnameRr)) {
    query['CnameRr'] = request.cnameRr;
  }
  if (!Util.isUnset(request.cnameType)) {
    query['CnameType'] = request.cnameType;
  }
  if (!Util.isUnset(request.cnameZone)) {
    query['CnameZone'] = request.cnameZone;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ValidateDnsGtmCnameRrCanUse',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function validateDnsGtmCnameRrCanUse(request: ValidateDnsGtmCnameRrCanUseRequest): ValidateDnsGtmCnameRrCanUseResponse {
  var runtime = new Util.RuntimeOptions{};
  return validateDnsGtmCnameRrCanUseWithOptions(request, runtime);
}

model ValidatePdnsUdpIpSegmentRequest {
  ip?: string(name='Ip'),
  lang?: string(name='Lang'),
}

model ValidatePdnsUdpIpSegmentResponseBody = {
  requestId?: string(name='RequestId'),
}

model ValidatePdnsUdpIpSegmentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ValidatePdnsUdpIpSegmentResponseBody(name='body'),
}

async function validatePdnsUdpIpSegmentWithOptions(request: ValidatePdnsUdpIpSegmentRequest, runtime: Util.RuntimeOptions): ValidatePdnsUdpIpSegmentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ValidatePdnsUdpIpSegment',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function validatePdnsUdpIpSegment(request: ValidatePdnsUdpIpSegmentRequest): ValidatePdnsUdpIpSegmentResponse {
  var runtime = new Util.RuntimeOptions{};
  return validatePdnsUdpIpSegmentWithOptions(request, runtime);
}

