/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('alidns', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddCustomLineRequest {
  domainName?: string(name='DomainName'),
  ipSegment?: [ 
    {
      endIp?: string(name='EndIp'),
      startIp?: string(name='StartIp'),
    }
  ](name='IpSegment'),
  lang?: string(name='Lang'),
  lineName?: string(name='LineName'),
}

model AddCustomLineResponseBody = {
  lineCode?: string(name='LineCode'),
  lineId?: long(name='LineId'),
  requestId?: string(name='RequestId'),
}

model AddCustomLineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddCustomLineResponseBody(name='body'),
}

async function addCustomLineWithOptions(request: AddCustomLineRequest, runtime: Util.RuntimeOptions): AddCustomLineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ipSegment)) {
    query['IpSegment'] = request.ipSegment;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lineName)) {
    query['LineName'] = request.lineName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddCustomLine',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addCustomLine(request: AddCustomLineRequest): AddCustomLineResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCustomLineWithOptions(request, runtime);
}

model AddDnsCacheDomainRequest {
  cacheTtlMax?: int32(name='CacheTtlMax'),
  cacheTtlMin?: int32(name='CacheTtlMin'),
  domainName?: string(name='DomainName'),
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  remark?: string(name='Remark'),
  sourceDnsServer?: [ 
    {
      host?: string(name='Host'),
      port?: string(name='Port'),
    }
  ](name='SourceDnsServer'),
  sourceEdns?: string(name='SourceEdns'),
  sourceProtocol?: string(name='SourceProtocol'),
}

model AddDnsCacheDomainResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddDnsCacheDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddDnsCacheDomainResponseBody(name='body'),
}

async function addDnsCacheDomainWithOptions(request: AddDnsCacheDomainRequest, runtime: Util.RuntimeOptions): AddDnsCacheDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cacheTtlMax)) {
    query['CacheTtlMax'] = request.cacheTtlMax;
  }
  if (!Util.isUnset(request.cacheTtlMin)) {
    query['CacheTtlMin'] = request.cacheTtlMin;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.sourceDnsServer)) {
    query['SourceDnsServer'] = request.sourceDnsServer;
  }
  if (!Util.isUnset(request.sourceEdns)) {
    query['SourceEdns'] = request.sourceEdns;
  }
  if (!Util.isUnset(request.sourceProtocol)) {
    query['SourceProtocol'] = request.sourceProtocol;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDnsCacheDomain',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDnsCacheDomain(request: AddDnsCacheDomainRequest): AddDnsCacheDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDnsCacheDomainWithOptions(request, runtime);
}

model AddDnsGtmAccessStrategyRequest {
  defaultAddrPool?: [ 
    {
      id?: string(name='Id'),
      lbaWeight?: int32(name='LbaWeight'),
    }
  ](name='DefaultAddrPool'),
  defaultAddrPoolType?: string(name='DefaultAddrPoolType'),
  defaultLatencyOptimization?: string(name='DefaultLatencyOptimization'),
  defaultLbaStrategy?: string(name='DefaultLbaStrategy'),
  defaultMaxReturnAddrNum?: int32(name='DefaultMaxReturnAddrNum'),
  defaultMinAvailableAddrNum?: int32(name='DefaultMinAvailableAddrNum'),
  failoverAddrPool?: [ 
    {
      id?: string(name='Id'),
      lbaWeight?: int32(name='LbaWeight'),
    }
  ](name='FailoverAddrPool'),
  failoverAddrPoolType?: string(name='FailoverAddrPoolType'),
  failoverLatencyOptimization?: string(name='FailoverLatencyOptimization'),
  failoverLbaStrategy?: string(name='FailoverLbaStrategy'),
  failoverMaxReturnAddrNum?: int32(name='FailoverMaxReturnAddrNum'),
  failoverMinAvailableAddrNum?: int32(name='FailoverMinAvailableAddrNum'),
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  lines?: string(name='Lines'),
  strategyMode?: string(name='StrategyMode'),
  strategyName?: string(name='StrategyName'),
}

model AddDnsGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId'),
  strategyId?: string(name='StrategyId'),
}

model AddDnsGtmAccessStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddDnsGtmAccessStrategyResponseBody(name='body'),
}

async function addDnsGtmAccessStrategyWithOptions(request: AddDnsGtmAccessStrategyRequest, runtime: Util.RuntimeOptions): AddDnsGtmAccessStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.defaultAddrPool)) {
    query['DefaultAddrPool'] = request.defaultAddrPool;
  }
  if (!Util.isUnset(request.defaultAddrPoolType)) {
    query['DefaultAddrPoolType'] = request.defaultAddrPoolType;
  }
  if (!Util.isUnset(request.defaultLatencyOptimization)) {
    query['DefaultLatencyOptimization'] = request.defaultLatencyOptimization;
  }
  if (!Util.isUnset(request.defaultLbaStrategy)) {
    query['DefaultLbaStrategy'] = request.defaultLbaStrategy;
  }
  if (!Util.isUnset(request.defaultMaxReturnAddrNum)) {
    query['DefaultMaxReturnAddrNum'] = request.defaultMaxReturnAddrNum;
  }
  if (!Util.isUnset(request.defaultMinAvailableAddrNum)) {
    query['DefaultMinAvailableAddrNum'] = request.defaultMinAvailableAddrNum;
  }
  if (!Util.isUnset(request.failoverAddrPool)) {
    query['FailoverAddrPool'] = request.failoverAddrPool;
  }
  if (!Util.isUnset(request.failoverAddrPoolType)) {
    query['FailoverAddrPoolType'] = request.failoverAddrPoolType;
  }
  if (!Util.isUnset(request.failoverLatencyOptimization)) {
    query['FailoverLatencyOptimization'] = request.failoverLatencyOptimization;
  }
  if (!Util.isUnset(request.failoverLbaStrategy)) {
    query['FailoverLbaStrategy'] = request.failoverLbaStrategy;
  }
  if (!Util.isUnset(request.failoverMaxReturnAddrNum)) {
    query['FailoverMaxReturnAddrNum'] = request.failoverMaxReturnAddrNum;
  }
  if (!Util.isUnset(request.failoverMinAvailableAddrNum)) {
    query['FailoverMinAvailableAddrNum'] = request.failoverMinAvailableAddrNum;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lines)) {
    query['Lines'] = request.lines;
  }
  if (!Util.isUnset(request.strategyMode)) {
    query['StrategyMode'] = request.strategyMode;
  }
  if (!Util.isUnset(request.strategyName)) {
    query['StrategyName'] = request.strategyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDnsGtmAccessStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDnsGtmAccessStrategy(request: AddDnsGtmAccessStrategyRequest): AddDnsGtmAccessStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDnsGtmAccessStrategyWithOptions(request, runtime);
}

model AddDnsGtmAddressPoolRequest {
  addr?: [ 
    {
      addr?: string(name='Addr'),
      attributeInfo?: string(name='AttributeInfo'),
      lbaWeight?: int32(name='LbaWeight'),
      mode?: string(name='Mode'),
      remark?: string(name='Remark'),
    }
  ](name='Addr'),
  evaluationCount?: int32(name='EvaluationCount'),
  instanceId?: string(name='InstanceId'),
  interval?: int32(name='Interval'),
  ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode'),
      ispCode?: string(name='IspCode'),
    }
  ](name='IspCityNode'),
  lang?: string(name='Lang'),
  lbaStrategy?: string(name='LbaStrategy'),
  monitorExtendInfo?: string(name='MonitorExtendInfo'),
  monitorStatus?: string(name='MonitorStatus'),
  name?: string(name='Name'),
  protocolType?: string(name='ProtocolType'),
  timeout?: int32(name='Timeout'),
  type?: string(name='Type'),
}

model AddDnsGtmAddressPoolResponseBody = {
  addrPoolId?: string(name='AddrPoolId'),
  monitorConfigId?: string(name='MonitorConfigId'),
  requestId?: string(name='RequestId'),
}

model AddDnsGtmAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddDnsGtmAddressPoolResponseBody(name='body'),
}

async function addDnsGtmAddressPoolWithOptions(request: AddDnsGtmAddressPoolRequest, runtime: Util.RuntimeOptions): AddDnsGtmAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addr)) {
    query['Addr'] = request.addr;
  }
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispCityNode)) {
    query['IspCityNode'] = request.ispCityNode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lbaStrategy)) {
    query['LbaStrategy'] = request.lbaStrategy;
  }
  if (!Util.isUnset(request.monitorExtendInfo)) {
    query['MonitorExtendInfo'] = request.monitorExtendInfo;
  }
  if (!Util.isUnset(request.monitorStatus)) {
    query['MonitorStatus'] = request.monitorStatus;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDnsGtmAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDnsGtmAddressPool(request: AddDnsGtmAddressPoolRequest): AddDnsGtmAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDnsGtmAddressPoolWithOptions(request, runtime);
}

model AddDnsGtmMonitorRequest {
  addrPoolId?: string(name='AddrPoolId'),
  evaluationCount?: int32(name='EvaluationCount'),
  interval?: int32(name='Interval'),
  ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode'),
      ispCode?: string(name='IspCode'),
    }
  ](name='IspCityNode'),
  lang?: string(name='Lang'),
  monitorExtendInfo?: string(name='MonitorExtendInfo'),
  protocolType?: string(name='ProtocolType'),
  timeout?: int32(name='Timeout'),
}

model AddDnsGtmMonitorResponseBody = {
  monitorConfigId?: string(name='MonitorConfigId'),
  requestId?: string(name='RequestId'),
}

model AddDnsGtmMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddDnsGtmMonitorResponseBody(name='body'),
}

async function addDnsGtmMonitorWithOptions(request: AddDnsGtmMonitorRequest, runtime: Util.RuntimeOptions): AddDnsGtmMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addrPoolId)) {
    query['AddrPoolId'] = request.addrPoolId;
  }
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispCityNode)) {
    query['IspCityNode'] = request.ispCityNode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.monitorExtendInfo)) {
    query['MonitorExtendInfo'] = request.monitorExtendInfo;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDnsGtmMonitor',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDnsGtmMonitor(request: AddDnsGtmMonitorRequest): AddDnsGtmMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDnsGtmMonitorWithOptions(request, runtime);
}

model AddDomainRequest {
  domainName?: string(name='DomainName'),
  groupId?: string(name='GroupId'),
  lang?: string(name='Lang'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model AddDomainResponseBody = {
  dnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='DnsServers'),
  domainId?: string(name='DomainId'),
  domainName?: string(name='DomainName'),
  groupId?: string(name='GroupId'),
  groupName?: string(name='GroupName'),
  punyCode?: string(name='PunyCode'),
  requestId?: string(name='RequestId'),
}

model AddDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddDomainResponseBody(name='body'),
}

async function addDomainWithOptions(request: AddDomainRequest, runtime: Util.RuntimeOptions): AddDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDomain',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDomain(request: AddDomainRequest): AddDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDomainWithOptions(request, runtime);
}

model AddDomainBackupRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  periodType?: string(name='PeriodType'),
}

model AddDomainBackupResponseBody = {
  domainName?: string(name='DomainName'),
  periodType?: string(name='PeriodType'),
  requestId?: string(name='RequestId'),
}

model AddDomainBackupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddDomainBackupResponseBody(name='body'),
}

async function addDomainBackupWithOptions(request: AddDomainBackupRequest, runtime: Util.RuntimeOptions): AddDomainBackupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.periodType)) {
    query['PeriodType'] = request.periodType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDomainBackup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDomainBackup(request: AddDomainBackupRequest): AddDomainBackupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDomainBackupWithOptions(request, runtime);
}

model AddDomainGroupRequest {
  groupName?: string(name='GroupName'),
  lang?: string(name='Lang'),
}

model AddDomainGroupResponseBody = {
  groupId?: string(name='GroupId'),
  groupName?: string(name='GroupName'),
  requestId?: string(name='RequestId'),
}

model AddDomainGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddDomainGroupResponseBody(name='body'),
}

async function addDomainGroupWithOptions(request: AddDomainGroupRequest, runtime: Util.RuntimeOptions): AddDomainGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDomainGroup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDomainGroup(request: AddDomainGroupRequest): AddDomainGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDomainGroupWithOptions(request, runtime);
}

model AddDomainRecordRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  line?: string(name='Line'),
  priority?: long(name='Priority'),
  RR?: string(name='RR'),
  TTL?: long(name='TTL'),
  type?: string(name='Type'),
  userClientIp?: string(name='UserClientIp'),
  value?: string(name='Value'),
}

model AddDomainRecordResponseBody = {
  recordId?: string(name='RecordId'),
  requestId?: string(name='RequestId'),
}

model AddDomainRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddDomainRecordResponseBody(name='body'),
}

async function addDomainRecordWithOptions(request: AddDomainRecordRequest, runtime: Util.RuntimeOptions): AddDomainRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.line)) {
    query['Line'] = request.line;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.RR)) {
    query['RR'] = request.RR;
  }
  if (!Util.isUnset(request.TTL)) {
    query['TTL'] = request.TTL;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDomainRecord',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDomainRecord(request: AddDomainRecordRequest): AddDomainRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDomainRecordWithOptions(request, runtime);
}

model AddGtmAccessStrategyRequest {
  accessLines?: string(name='AccessLines'),
  defaultAddrPoolId?: string(name='DefaultAddrPoolId'),
  failoverAddrPoolId?: string(name='FailoverAddrPoolId'),
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  strategyName?: string(name='StrategyName'),
}

model AddGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId'),
  strategyId?: string(name='StrategyId'),
}

model AddGtmAccessStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddGtmAccessStrategyResponseBody(name='body'),
}

async function addGtmAccessStrategyWithOptions(request: AddGtmAccessStrategyRequest, runtime: Util.RuntimeOptions): AddGtmAccessStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessLines)) {
    query['AccessLines'] = request.accessLines;
  }
  if (!Util.isUnset(request.defaultAddrPoolId)) {
    query['DefaultAddrPoolId'] = request.defaultAddrPoolId;
  }
  if (!Util.isUnset(request.failoverAddrPoolId)) {
    query['FailoverAddrPoolId'] = request.failoverAddrPoolId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyName)) {
    query['StrategyName'] = request.strategyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGtmAccessStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addGtmAccessStrategy(request: AddGtmAccessStrategyRequest): AddGtmAccessStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGtmAccessStrategyWithOptions(request, runtime);
}

model AddGtmAddressPoolRequest {
  addr?: [ 
    {
      lbaWeight?: int32(name='LbaWeight'),
      mode?: string(name='Mode'),
      value?: string(name='Value'),
    }
  ](name='Addr'),
  evaluationCount?: int32(name='EvaluationCount'),
  instanceId?: string(name='InstanceId'),
  interval?: int32(name='Interval'),
  ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode'),
      ispCode?: string(name='IspCode'),
    }
  ](name='IspCityNode'),
  lang?: string(name='Lang'),
  minAvailableAddrNum?: int32(name='MinAvailableAddrNum'),
  monitorExtendInfo?: string(name='MonitorExtendInfo'),
  monitorStatus?: string(name='MonitorStatus'),
  name?: string(name='Name'),
  protocolType?: string(name='ProtocolType'),
  timeout?: int32(name='Timeout'),
  type?: string(name='Type'),
}

model AddGtmAddressPoolResponseBody = {
  addrPoolId?: string(name='AddrPoolId'),
  monitorConfigId?: string(name='MonitorConfigId'),
  requestId?: string(name='RequestId'),
}

model AddGtmAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddGtmAddressPoolResponseBody(name='body'),
}

async function addGtmAddressPoolWithOptions(request: AddGtmAddressPoolRequest, runtime: Util.RuntimeOptions): AddGtmAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addr)) {
    query['Addr'] = request.addr;
  }
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispCityNode)) {
    query['IspCityNode'] = request.ispCityNode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.minAvailableAddrNum)) {
    query['MinAvailableAddrNum'] = request.minAvailableAddrNum;
  }
  if (!Util.isUnset(request.monitorExtendInfo)) {
    query['MonitorExtendInfo'] = request.monitorExtendInfo;
  }
  if (!Util.isUnset(request.monitorStatus)) {
    query['MonitorStatus'] = request.monitorStatus;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGtmAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addGtmAddressPool(request: AddGtmAddressPoolRequest): AddGtmAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGtmAddressPoolWithOptions(request, runtime);
}

model AddGtmMonitorRequest {
  addrPoolId?: string(name='AddrPoolId'),
  evaluationCount?: int32(name='EvaluationCount'),
  interval?: int32(name='Interval'),
  ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode'),
      ispCode?: string(name='IspCode'),
    }
  ](name='IspCityNode'),
  lang?: string(name='Lang'),
  monitorExtendInfo?: string(name='MonitorExtendInfo'),
  protocolType?: string(name='ProtocolType'),
  timeout?: int32(name='Timeout'),
}

model AddGtmMonitorResponseBody = {
  monitorConfigId?: string(name='MonitorConfigId'),
  requestId?: string(name='RequestId'),
}

model AddGtmMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddGtmMonitorResponseBody(name='body'),
}

async function addGtmMonitorWithOptions(request: AddGtmMonitorRequest, runtime: Util.RuntimeOptions): AddGtmMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addrPoolId)) {
    query['AddrPoolId'] = request.addrPoolId;
  }
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispCityNode)) {
    query['IspCityNode'] = request.ispCityNode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.monitorExtendInfo)) {
    query['MonitorExtendInfo'] = request.monitorExtendInfo;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGtmMonitor',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addGtmMonitor(request: AddGtmMonitorRequest): AddGtmMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGtmMonitorWithOptions(request, runtime);
}

model AddGtmRecoveryPlanRequest {
  faultAddrPool?: string(name='FaultAddrPool'),
  lang?: string(name='Lang'),
  name?: string(name='Name'),
  remark?: string(name='Remark'),
}

model AddGtmRecoveryPlanResponseBody = {
  recoveryPlanId?: string(name='RecoveryPlanId'),
  requestId?: string(name='RequestId'),
}

model AddGtmRecoveryPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddGtmRecoveryPlanResponseBody(name='body'),
}

async function addGtmRecoveryPlanWithOptions(request: AddGtmRecoveryPlanRequest, runtime: Util.RuntimeOptions): AddGtmRecoveryPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.faultAddrPool)) {
    query['FaultAddrPool'] = request.faultAddrPool;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGtmRecoveryPlan',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addGtmRecoveryPlan(request: AddGtmRecoveryPlanRequest): AddGtmRecoveryPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGtmRecoveryPlanWithOptions(request, runtime);
}

model BindInstanceDomainsRequest {
  domainNames?: string(name='DomainNames'),
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
}

model BindInstanceDomainsResponseBody = {
  failedCount?: int32(name='FailedCount'),
  requestId?: string(name='RequestId'),
  successCount?: int32(name='SuccessCount'),
}

model BindInstanceDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BindInstanceDomainsResponseBody(name='body'),
}

async function bindInstanceDomainsWithOptions(request: BindInstanceDomainsRequest, runtime: Util.RuntimeOptions): BindInstanceDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainNames)) {
    query['DomainNames'] = request.domainNames;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BindInstanceDomains',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function bindInstanceDomains(request: BindInstanceDomainsRequest): BindInstanceDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindInstanceDomainsWithOptions(request, runtime);
}

model ChangeDomainGroupRequest {
  domainName?: string(name='DomainName'),
  groupId?: string(name='GroupId'),
  lang?: string(name='Lang'),
}

model ChangeDomainGroupResponseBody = {
  groupId?: string(name='GroupId'),
  groupName?: string(name='GroupName'),
  requestId?: string(name='RequestId'),
}

model ChangeDomainGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangeDomainGroupResponseBody(name='body'),
}

async function changeDomainGroupWithOptions(request: ChangeDomainGroupRequest, runtime: Util.RuntimeOptions): ChangeDomainGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeDomainGroup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function changeDomainGroup(request: ChangeDomainGroupRequest): ChangeDomainGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeDomainGroupWithOptions(request, runtime);
}

model ChangeDomainOfDnsProductRequest {
  force?: boolean(name='Force'),
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  newDomain?: string(name='NewDomain'),
  userClientIp?: string(name='UserClientIp'),
}

model ChangeDomainOfDnsProductResponseBody = {
  originalDomain?: string(name='OriginalDomain'),
  requestId?: string(name='RequestId'),
}

model ChangeDomainOfDnsProductResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangeDomainOfDnsProductResponseBody(name='body'),
}

async function changeDomainOfDnsProductWithOptions(request: ChangeDomainOfDnsProductRequest, runtime: Util.RuntimeOptions): ChangeDomainOfDnsProductResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.newDomain)) {
    query['NewDomain'] = request.newDomain;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeDomainOfDnsProduct',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function changeDomainOfDnsProduct(request: ChangeDomainOfDnsProductRequest): ChangeDomainOfDnsProductResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeDomainOfDnsProductWithOptions(request, runtime);
}

model CopyGtmConfigRequest {
  copyType?: string(name='CopyType'),
  lang?: string(name='Lang'),
  sourceId?: string(name='SourceId'),
  targetId?: string(name='TargetId'),
}

model CopyGtmConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model CopyGtmConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CopyGtmConfigResponseBody(name='body'),
}

async function copyGtmConfigWithOptions(request: CopyGtmConfigRequest, runtime: Util.RuntimeOptions): CopyGtmConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.copyType)) {
    query['CopyType'] = request.copyType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceId)) {
    query['SourceId'] = request.sourceId;
  }
  if (!Util.isUnset(request.targetId)) {
    query['TargetId'] = request.targetId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CopyGtmConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function copyGtmConfig(request: CopyGtmConfigRequest): CopyGtmConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return copyGtmConfigWithOptions(request, runtime);
}

model CreatePdnsAppKeyRequest {
  lang?: string(name='Lang'),
}

model CreatePdnsAppKeyResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreatePdnsAppKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePdnsAppKeyResponseBody(name='body'),
}

async function createPdnsAppKeyWithOptions(request: CreatePdnsAppKeyRequest, runtime: Util.RuntimeOptions): CreatePdnsAppKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePdnsAppKey',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPdnsAppKey(request: CreatePdnsAppKeyRequest): CreatePdnsAppKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPdnsAppKeyWithOptions(request, runtime);
}

model CreatePdnsUdpIpSegmentRequest {
  ip?: string(name='Ip'),
  lang?: string(name='Lang'),
  name?: string(name='Name'),
}

model CreatePdnsUdpIpSegmentResponseBody = {
  requestId?: string(name='RequestId'),
  validMessage?: string(name='ValidMessage'),
}

model CreatePdnsUdpIpSegmentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePdnsUdpIpSegmentResponseBody(name='body'),
}

async function createPdnsUdpIpSegmentWithOptions(request: CreatePdnsUdpIpSegmentRequest, runtime: Util.RuntimeOptions): CreatePdnsUdpIpSegmentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePdnsUdpIpSegment',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPdnsUdpIpSegment(request: CreatePdnsUdpIpSegmentRequest): CreatePdnsUdpIpSegmentResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPdnsUdpIpSegmentWithOptions(request, runtime);
}

model DeleteCustomLinesRequest {
  lang?: string(name='Lang'),
  lineIds?: string(name='LineIds'),
}

model DeleteCustomLinesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCustomLinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCustomLinesResponseBody(name='body'),
}

async function deleteCustomLinesWithOptions(request: DeleteCustomLinesRequest, runtime: Util.RuntimeOptions): DeleteCustomLinesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lineIds)) {
    query['LineIds'] = request.lineIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCustomLines',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCustomLines(request: DeleteCustomLinesRequest): DeleteCustomLinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCustomLinesWithOptions(request, runtime);
}

model DeleteDnsCacheDomainRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
}

model DeleteDnsCacheDomainResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDnsCacheDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDnsCacheDomainResponseBody(name='body'),
}

async function deleteDnsCacheDomainWithOptions(request: DeleteDnsCacheDomainRequest, runtime: Util.RuntimeOptions): DeleteDnsCacheDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDnsCacheDomain',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDnsCacheDomain(request: DeleteDnsCacheDomainRequest): DeleteDnsCacheDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDnsCacheDomainWithOptions(request, runtime);
}

model DeleteDnsGtmAccessStrategyRequest {
  lang?: string(name='Lang'),
  strategyId?: string(name='StrategyId'),
}

model DeleteDnsGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDnsGtmAccessStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDnsGtmAccessStrategyResponseBody(name='body'),
}

async function deleteDnsGtmAccessStrategyWithOptions(request: DeleteDnsGtmAccessStrategyRequest, runtime: Util.RuntimeOptions): DeleteDnsGtmAccessStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDnsGtmAccessStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDnsGtmAccessStrategy(request: DeleteDnsGtmAccessStrategyRequest): DeleteDnsGtmAccessStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDnsGtmAccessStrategyWithOptions(request, runtime);
}

model DeleteDnsGtmAddressPoolRequest {
  addrPoolId?: string(name='AddrPoolId'),
  lang?: string(name='Lang'),
}

model DeleteDnsGtmAddressPoolResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDnsGtmAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDnsGtmAddressPoolResponseBody(name='body'),
}

async function deleteDnsGtmAddressPoolWithOptions(request: DeleteDnsGtmAddressPoolRequest, runtime: Util.RuntimeOptions): DeleteDnsGtmAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addrPoolId)) {
    query['AddrPoolId'] = request.addrPoolId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDnsGtmAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDnsGtmAddressPool(request: DeleteDnsGtmAddressPoolRequest): DeleteDnsGtmAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDnsGtmAddressPoolWithOptions(request, runtime);
}

model DeleteDomainRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
}

model DeleteDomainResponseBody = {
  domainName?: string(name='DomainName'),
  requestId?: string(name='RequestId'),
}

model DeleteDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDomainResponseBody(name='body'),
}

async function deleteDomainWithOptions(request: DeleteDomainRequest, runtime: Util.RuntimeOptions): DeleteDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDomain',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDomain(request: DeleteDomainRequest): DeleteDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDomainWithOptions(request, runtime);
}

model DeleteDomainGroupRequest {
  groupId?: string(name='GroupId'),
  lang?: string(name='Lang'),
}

model DeleteDomainGroupResponseBody = {
  groupName?: string(name='GroupName'),
  requestId?: string(name='RequestId'),
}

model DeleteDomainGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDomainGroupResponseBody(name='body'),
}

async function deleteDomainGroupWithOptions(request: DeleteDomainGroupRequest, runtime: Util.RuntimeOptions): DeleteDomainGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDomainGroup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDomainGroup(request: DeleteDomainGroupRequest): DeleteDomainGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDomainGroupWithOptions(request, runtime);
}

model DeleteDomainRecordRequest {
  lang?: string(name='Lang'),
  recordId?: string(name='RecordId'),
  userClientIp?: string(name='UserClientIp'),
}

model DeleteDomainRecordResponseBody = {
  recordId?: string(name='RecordId'),
  requestId?: string(name='RequestId'),
}

model DeleteDomainRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDomainRecordResponseBody(name='body'),
}

async function deleteDomainRecordWithOptions(request: DeleteDomainRecordRequest, runtime: Util.RuntimeOptions): DeleteDomainRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recordId)) {
    query['RecordId'] = request.recordId;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDomainRecord',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDomainRecord(request: DeleteDomainRecordRequest): DeleteDomainRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDomainRecordWithOptions(request, runtime);
}

model DeleteGtmAccessStrategyRequest {
  lang?: string(name='Lang'),
  strategyId?: string(name='StrategyId'),
}

model DeleteGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGtmAccessStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGtmAccessStrategyResponseBody(name='body'),
}

async function deleteGtmAccessStrategyWithOptions(request: DeleteGtmAccessStrategyRequest, runtime: Util.RuntimeOptions): DeleteGtmAccessStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGtmAccessStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGtmAccessStrategy(request: DeleteGtmAccessStrategyRequest): DeleteGtmAccessStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGtmAccessStrategyWithOptions(request, runtime);
}

model DeleteGtmAddressPoolRequest {
  addrPoolId?: string(name='AddrPoolId'),
  lang?: string(name='Lang'),
}

model DeleteGtmAddressPoolResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGtmAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGtmAddressPoolResponseBody(name='body'),
}

async function deleteGtmAddressPoolWithOptions(request: DeleteGtmAddressPoolRequest, runtime: Util.RuntimeOptions): DeleteGtmAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addrPoolId)) {
    query['AddrPoolId'] = request.addrPoolId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGtmAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGtmAddressPool(request: DeleteGtmAddressPoolRequest): DeleteGtmAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGtmAddressPoolWithOptions(request, runtime);
}

model DeleteGtmRecoveryPlanRequest {
  lang?: string(name='Lang'),
  recoveryPlanId?: long(name='RecoveryPlanId'),
}

model DeleteGtmRecoveryPlanResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGtmRecoveryPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGtmRecoveryPlanResponseBody(name='body'),
}

async function deleteGtmRecoveryPlanWithOptions(request: DeleteGtmRecoveryPlanRequest, runtime: Util.RuntimeOptions): DeleteGtmRecoveryPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recoveryPlanId)) {
    query['RecoveryPlanId'] = request.recoveryPlanId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGtmRecoveryPlan',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGtmRecoveryPlan(request: DeleteGtmRecoveryPlanRequest): DeleteGtmRecoveryPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGtmRecoveryPlanWithOptions(request, runtime);
}

model DeleteSubDomainRecordsRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  RR?: string(name='RR'),
  type?: string(name='Type'),
  userClientIp?: string(name='UserClientIp'),
}

model DeleteSubDomainRecordsResponseBody = {
  RR?: string(name='RR'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model DeleteSubDomainRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSubDomainRecordsResponseBody(name='body'),
}

async function deleteSubDomainRecordsWithOptions(request: DeleteSubDomainRecordsRequest, runtime: Util.RuntimeOptions): DeleteSubDomainRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.RR)) {
    query['RR'] = request.RR;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSubDomainRecords',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSubDomainRecords(request: DeleteSubDomainRecordsRequest): DeleteSubDomainRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSubDomainRecordsWithOptions(request, runtime);
}

model DescribeBatchResultCountRequest {
  batchType?: string(name='BatchType'),
  lang?: string(name='Lang'),
  taskId?: long(name='TaskId'),
}

model DescribeBatchResultCountResponseBody = {
  batchType?: string(name='BatchType'),
  failedCount?: int32(name='FailedCount'),
  reason?: string(name='Reason'),
  requestId?: string(name='RequestId'),
  status?: int32(name='Status'),
  successCount?: int32(name='SuccessCount'),
  taskId?: long(name='TaskId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeBatchResultCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBatchResultCountResponseBody(name='body'),
}

async function describeBatchResultCountWithOptions(request: DescribeBatchResultCountRequest, runtime: Util.RuntimeOptions): DescribeBatchResultCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.batchType)) {
    query['BatchType'] = request.batchType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBatchResultCount',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBatchResultCount(request: DescribeBatchResultCountRequest): DescribeBatchResultCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBatchResultCountWithOptions(request, runtime);
}

model DescribeBatchResultDetailRequest {
  batchType?: string(name='BatchType'),
  lang?: string(name='Lang'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
  taskId?: long(name='TaskId'),
}

model DescribeBatchResultDetailResponseBody = {
  batchResultDetails?: {
    batchResultDetail?: [ 
    {
      batchType?: string(name='BatchType'),
      domain?: string(name='Domain'),
      line?: string(name='Line'),
      newRr?: string(name='NewRr'),
      newValue?: string(name='NewValue'),
      operateDateStr?: string(name='OperateDateStr'),
      priority?: string(name='Priority'),
      reason?: string(name='Reason'),
      recordId?: string(name='RecordId'),
      remark?: string(name='Remark'),
      rr?: string(name='Rr'),
      rrStatus?: string(name='RrStatus'),
      status?: boolean(name='Status'),
      ttl?: string(name='Ttl'),
      type?: string(name='Type'),
      value?: string(name='Value'),
    }
  ](name='BatchResultDetail')
  }(name='BatchResultDetails'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeBatchResultDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBatchResultDetailResponseBody(name='body'),
}

async function describeBatchResultDetailWithOptions(request: DescribeBatchResultDetailRequest, runtime: Util.RuntimeOptions): DescribeBatchResultDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.batchType)) {
    query['BatchType'] = request.batchType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBatchResultDetail',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBatchResultDetail(request: DescribeBatchResultDetailRequest): DescribeBatchResultDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBatchResultDetailWithOptions(request, runtime);
}

model DescribeCustomLineRequest {
  lang?: string(name='Lang'),
  lineId?: long(name='LineId'),
}

model DescribeCustomLineResponseBody = {
  code?: string(name='Code'),
  domainName?: string(name='DomainName'),
  id?: long(name='Id'),
  ipSegmentList?: [ 
    {
      endIp?: string(name='EndIp'),
      startIp?: string(name='StartIp'),
    }
  ](name='IpSegmentList'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
}

model DescribeCustomLineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCustomLineResponseBody(name='body'),
}

async function describeCustomLineWithOptions(request: DescribeCustomLineRequest, runtime: Util.RuntimeOptions): DescribeCustomLineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lineId)) {
    query['LineId'] = request.lineId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCustomLine',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCustomLine(request: DescribeCustomLineRequest): DescribeCustomLineResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomLineWithOptions(request, runtime);
}

model DescribeCustomLinesRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
}

model DescribeCustomLinesResponseBody = {
  customLines?: [ 
    {
      code?: string(name='Code'),
      id?: long(name='Id'),
      name?: string(name='Name'),
    }
  ](name='CustomLines'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeCustomLinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCustomLinesResponseBody(name='body'),
}

async function describeCustomLinesWithOptions(request: DescribeCustomLinesRequest, runtime: Util.RuntimeOptions): DescribeCustomLinesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCustomLines',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCustomLines(request: DescribeCustomLinesRequest): DescribeCustomLinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomLinesWithOptions(request, runtime);
}

model DescribeDNSSLBSubDomainsRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  rr?: string(name='Rr'),
  userClientIp?: string(name='UserClientIp'),
}

model DescribeDNSSLBSubDomainsResponseBody = {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  slbSubDomains?: {
    slbSubDomain?: [ 
    {
      lineAlgorithms?: {
        lineAlgorithm?: [ 
        {
          line?: string(name='Line'),
          open?: boolean(name='Open'),
        }
      ](name='LineAlgorithm')
      }(name='LineAlgorithms'),
      open?: boolean(name='Open'),
      recordCount?: long(name='RecordCount'),
      subDomain?: string(name='SubDomain'),
      type?: string(name='Type'),
    }
  ](name='SlbSubDomain')
  }(name='SlbSubDomains'),
  totalCount?: long(name='TotalCount'),
}

model DescribeDNSSLBSubDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDNSSLBSubDomainsResponseBody(name='body'),
}

async function describeDNSSLBSubDomainsWithOptions(request: DescribeDNSSLBSubDomainsRequest, runtime: Util.RuntimeOptions): DescribeDNSSLBSubDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.rr)) {
    query['Rr'] = request.rr;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDNSSLBSubDomains',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDNSSLBSubDomains(request: DescribeDNSSLBSubDomainsRequest): DescribeDNSSLBSubDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDNSSLBSubDomainsWithOptions(request, runtime);
}

model DescribeDnsCacheDomainsRequest {
  keyword?: string(name='Keyword'),
  lang?: string(name='Lang'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
}

model DescribeDnsCacheDomainsResponseBody = {
  domains?: [ 
    {
      cacheTtlMax?: int32(name='CacheTtlMax'),
      cacheTtlMin?: int32(name='CacheTtlMin'),
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      domainId?: string(name='DomainId'),
      domainName?: string(name='DomainName'),
      expireTime?: string(name='ExpireTime'),
      expireTimestamp?: long(name='ExpireTimestamp'),
      instanceId?: string(name='InstanceId'),
      remark?: string(name='Remark'),
      sourceDnsServers?: [ 
        {
          host?: string(name='Host'),
          port?: string(name='Port'),
        }
      ](name='SourceDnsServers'),
      sourceEdns?: string(name='SourceEdns'),
      sourceProtocol?: string(name='SourceProtocol'),
      updateTime?: string(name='UpdateTime'),
      updateTimestamp?: long(name='UpdateTimestamp'),
      versionCode?: string(name='VersionCode'),
    }
  ](name='Domains'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeDnsCacheDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsCacheDomainsResponseBody(name='body'),
}

async function describeDnsCacheDomainsWithOptions(request: DescribeDnsCacheDomainsRequest, runtime: Util.RuntimeOptions): DescribeDnsCacheDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsCacheDomains',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsCacheDomains(request: DescribeDnsCacheDomainsRequest): DescribeDnsCacheDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsCacheDomainsWithOptions(request, runtime);
}

model DescribeDnsGtmAccessStrategiesRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  strategyMode?: string(name='StrategyMode'),
}

model DescribeDnsGtmAccessStrategiesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  strategies?: {
    strategy?: [ 
    {
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      effectiveAddrPoolGroupType?: string(name='EffectiveAddrPoolGroupType'),
      effectiveAddrPoolType?: string(name='EffectiveAddrPoolType'),
      effectiveAddrPools?: {
        effectiveAddrPool?: [ 
        {
          addrCount?: int32(name='AddrCount'),
          id?: string(name='Id'),
          lbaWeight?: int32(name='LbaWeight'),
          name?: string(name='Name'),
        }
      ](name='EffectiveAddrPool')
      }(name='EffectiveAddrPools'),
      effectiveLbaStrategy?: string(name='EffectiveLbaStrategy'),
      lines?: {
        line?: [ 
        {
          groupCode?: string(name='GroupCode'),
          groupName?: string(name='GroupName'),
          lineCode?: string(name='LineCode'),
          lineName?: string(name='LineName'),
        }
      ](name='Line')
      }(name='Lines'),
      strategyId?: string(name='StrategyId'),
      strategyName?: string(name='StrategyName'),
    }
  ](name='Strategy')
  }(name='Strategies'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeDnsGtmAccessStrategiesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmAccessStrategiesResponseBody(name='body'),
}

async function describeDnsGtmAccessStrategiesWithOptions(request: DescribeDnsGtmAccessStrategiesRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmAccessStrategiesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.strategyMode)) {
    query['StrategyMode'] = request.strategyMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmAccessStrategies',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmAccessStrategies(request: DescribeDnsGtmAccessStrategiesRequest): DescribeDnsGtmAccessStrategiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmAccessStrategiesWithOptions(request, runtime);
}

model DescribeDnsGtmAccessStrategyRequest {
  lang?: string(name='Lang'),
  strategyId?: string(name='StrategyId'),
}

model DescribeDnsGtmAccessStrategyResponseBody = {
  accessMode?: string(name='AccessMode'),
  createTime?: string(name='CreateTime'),
  createTimestamp?: long(name='CreateTimestamp'),
  defaultAddrPoolGroupStatus?: string(name='DefaultAddrPoolGroupStatus'),
  defaultAddrPoolType?: string(name='DefaultAddrPoolType'),
  defaultAddrPools?: {
    defaultAddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount'),
      id?: string(name='Id'),
      lbaWeight?: int32(name='LbaWeight'),
      name?: string(name='Name'),
    }
  ](name='DefaultAddrPool')
  }(name='DefaultAddrPools'),
  defaultAvailableAddrNum?: int32(name='DefaultAvailableAddrNum'),
  defaultLatencyOptimization?: string(name='DefaultLatencyOptimization'),
  defaultLbaStrategy?: string(name='DefaultLbaStrategy'),
  defaultMaxReturnAddrNum?: int32(name='DefaultMaxReturnAddrNum'),
  defaultMinAvailableAddrNum?: int32(name='DefaultMinAvailableAddrNum'),
  effectiveAddrPoolGroupType?: string(name='EffectiveAddrPoolGroupType'),
  failoverAddrPoolGroupStatus?: string(name='FailoverAddrPoolGroupStatus'),
  failoverAddrPoolType?: string(name='FailoverAddrPoolType'),
  failoverAddrPools?: {
    failoverAddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount'),
      id?: string(name='Id'),
      lbaWeight?: int32(name='LbaWeight'),
      name?: string(name='Name'),
    }
  ](name='FailoverAddrPool')
  }(name='FailoverAddrPools'),
  failoverAvailableAddrNum?: int32(name='FailoverAvailableAddrNum'),
  failoverLatencyOptimization?: string(name='FailoverLatencyOptimization'),
  failoverLbaStrategy?: string(name='FailoverLbaStrategy'),
  failoverMaxReturnAddrNum?: int32(name='FailoverMaxReturnAddrNum'),
  failoverMinAvailableAddrNum?: int32(name='FailoverMinAvailableAddrNum'),
  instanceId?: string(name='InstanceId'),
  lines?: {
    line?: [ 
    {
      groupCode?: string(name='GroupCode'),
      groupName?: string(name='GroupName'),
      lineCode?: string(name='LineCode'),
      lineName?: string(name='LineName'),
    }
  ](name='Line')
  }(name='Lines'),
  requestId?: string(name='RequestId'),
  strategyId?: string(name='StrategyId'),
  strategyMode?: string(name='StrategyMode'),
  strategyName?: string(name='StrategyName'),
}

model DescribeDnsGtmAccessStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmAccessStrategyResponseBody(name='body'),
}

async function describeDnsGtmAccessStrategyWithOptions(request: DescribeDnsGtmAccessStrategyRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmAccessStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmAccessStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmAccessStrategy(request: DescribeDnsGtmAccessStrategyRequest): DescribeDnsGtmAccessStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmAccessStrategyWithOptions(request, runtime);
}

model DescribeDnsGtmAccessStrategyAvailableConfigRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  strategyMode?: string(name='StrategyMode'),
}

model DescribeDnsGtmAccessStrategyAvailableConfigResponseBody = {
  domainAddrPools?: {
    domainAddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount'),
      id?: string(name='Id'),
      name?: string(name='Name'),
    }
  ](name='DomainAddrPool')
  }(name='DomainAddrPools'),
  ipv4AddrPools?: {
    ipv4AddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount'),
      id?: string(name='Id'),
      name?: string(name='Name'),
    }
  ](name='Ipv4AddrPool')
  }(name='Ipv4AddrPools'),
  ipv6AddrPools?: {
    ipv6AddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount'),
      id?: string(name='Id'),
      name?: string(name='Name'),
    }
  ](name='Ipv6AddrPool')
  }(name='Ipv6AddrPools'),
  lines?: {
    line?: [ 
    {
      fatherCode?: string(name='FatherCode'),
      groupCode?: string(name='GroupCode'),
      groupName?: string(name='GroupName'),
      lineCode?: string(name='LineCode'),
      lineName?: string(name='LineName'),
    }
  ](name='Line')
  }(name='Lines'),
  requestId?: string(name='RequestId'),
  selectedDomainLines?: {
    selectedDomainLine?: [ string ](name='SelectedDomainLine')
  }(name='SelectedDomainLines'),
  selectedIpv4Lines?: {
    selectedIpv4Line?: [ string ](name='SelectedIpv4Line')
  }(name='SelectedIpv4Lines'),
  selectedIpv6Lines?: {
    selectedIpv6Line?: [ string ](name='SelectedIpv6Line')
  }(name='SelectedIpv6Lines'),
  suggestSetDefaultLine?: boolean(name='SuggestSetDefaultLine'),
}

model DescribeDnsGtmAccessStrategyAvailableConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody(name='body'),
}

async function describeDnsGtmAccessStrategyAvailableConfigWithOptions(request: DescribeDnsGtmAccessStrategyAvailableConfigRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmAccessStrategyAvailableConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyMode)) {
    query['StrategyMode'] = request.strategyMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmAccessStrategyAvailableConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmAccessStrategyAvailableConfig(request: DescribeDnsGtmAccessStrategyAvailableConfigRequest): DescribeDnsGtmAccessStrategyAvailableConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmAccessStrategyAvailableConfigWithOptions(request, runtime);
}

model DescribeDnsGtmAddrAttributeInfoRequest {
  addrs?: string(name='Addrs'),
  lang?: string(name='Lang'),
  type?: string(name='Type'),
}

model DescribeDnsGtmAddrAttributeInfoResponseBody = {
  addr?: {
    addr?: [ 
    {
      addr?: string(name='Addr'),
      attributeInfo?: {
        fatherCode?: string(name='FatherCode'),
        groupCode?: string(name='GroupCode'),
        groupName?: string(name='GroupName'),
        lineCode?: string(name='LineCode'),
        lineName?: string(name='LineName'),
      }(name='AttributeInfo'),
    }
  ](name='Addr')
  }(name='Addr'),
  requestId?: string(name='RequestId'),
}

model DescribeDnsGtmAddrAttributeInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmAddrAttributeInfoResponseBody(name='body'),
}

async function describeDnsGtmAddrAttributeInfoWithOptions(request: DescribeDnsGtmAddrAttributeInfoRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmAddrAttributeInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addrs)) {
    query['Addrs'] = request.addrs;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmAddrAttributeInfo',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmAddrAttributeInfo(request: DescribeDnsGtmAddrAttributeInfoRequest): DescribeDnsGtmAddrAttributeInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmAddrAttributeInfoWithOptions(request, runtime);
}

model DescribeDnsGtmAddressPoolAvailableConfigRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
}

model DescribeDnsGtmAddressPoolAvailableConfigResponseBody = {
  attributeInfos?: {
    attributeInfo?: [ 
    {
      fatherCode?: string(name='FatherCode'),
      groupCode?: string(name='GroupCode'),
      groupName?: string(name='GroupName'),
      lineCode?: string(name='LineCode'),
      lineName?: string(name='LineName'),
    }
  ](name='AttributeInfo')
  }(name='AttributeInfos'),
  requestId?: string(name='RequestId'),
}

model DescribeDnsGtmAddressPoolAvailableConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmAddressPoolAvailableConfigResponseBody(name='body'),
}

async function describeDnsGtmAddressPoolAvailableConfigWithOptions(request: DescribeDnsGtmAddressPoolAvailableConfigRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmAddressPoolAvailableConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmAddressPoolAvailableConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmAddressPoolAvailableConfig(request: DescribeDnsGtmAddressPoolAvailableConfigRequest): DescribeDnsGtmAddressPoolAvailableConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmAddressPoolAvailableConfigWithOptions(request, runtime);
}

model DescribeDnsGtmAvailableAlertGroupRequest {
  lang?: string(name='Lang'),
}

model DescribeDnsGtmAvailableAlertGroupResponseBody = {
  availableAlertGroup?: string(name='AvailableAlertGroup'),
  requestId?: string(name='RequestId'),
}

model DescribeDnsGtmAvailableAlertGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmAvailableAlertGroupResponseBody(name='body'),
}

async function describeDnsGtmAvailableAlertGroupWithOptions(request: DescribeDnsGtmAvailableAlertGroupRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmAvailableAlertGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmAvailableAlertGroup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmAvailableAlertGroup(request: DescribeDnsGtmAvailableAlertGroupRequest): DescribeDnsGtmAvailableAlertGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmAvailableAlertGroupWithOptions(request, runtime);
}

model DescribeDnsGtmInstanceRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
}

model DescribeDnsGtmInstanceResponseBody = {
  config?: {
    alertConfig?: {
      alertConfig?: [ 
      {
        dingtalkNotice?: boolean(name='DingtalkNotice'),
        emailNotice?: boolean(name='EmailNotice'),
        noticeType?: string(name='NoticeType'),
        smsNotice?: boolean(name='SmsNotice'),
      }
    ](name='AlertConfig')
    }(name='AlertConfig'),
    alertGroup?: string(name='AlertGroup'),
    cnameType?: string(name='CnameType'),
    instanceName?: string(name='InstanceName'),
    pubicZoneName?: string(name='PubicZoneName'),
    publicCnameMode?: string(name='PublicCnameMode'),
    publicRr?: string(name='PublicRr'),
    publicUserDomainName?: string(name='PublicUserDomainName'),
    strategyMode?: string(name='StrategyMode'),
    ttl?: int32(name='Ttl'),
  }(name='Config'),
  createTime?: string(name='CreateTime'),
  createTimestamp?: long(name='CreateTimestamp'),
  expireTime?: string(name='ExpireTime'),
  expireTimestamp?: long(name='ExpireTimestamp'),
  instanceId?: string(name='InstanceId'),
  paymentType?: string(name='PaymentType'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  smsQuota?: int32(name='SmsQuota'),
  taskQuota?: int32(name='TaskQuota'),
  usedQuota?: {
    dingtalkUsedCount?: int32(name='DingtalkUsedCount'),
    emailUsedCount?: int32(name='EmailUsedCount'),
    smsUsedCount?: int32(name='SmsUsedCount'),
    taskUsedCount?: int32(name='TaskUsedCount'),
  }(name='UsedQuota'),
  versionCode?: string(name='VersionCode'),
}

model DescribeDnsGtmInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmInstanceResponseBody(name='body'),
}

async function describeDnsGtmInstanceWithOptions(request: DescribeDnsGtmInstanceRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmInstance',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmInstance(request: DescribeDnsGtmInstanceRequest): DescribeDnsGtmInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmInstanceWithOptions(request, runtime);
}

model DescribeDnsGtmInstanceAddressPoolRequest {
  addrPoolId?: string(name='AddrPoolId'),
  lang?: string(name='Lang'),
}

model DescribeDnsGtmInstanceAddressPoolResponseBody = {
  addrCount?: int32(name='AddrCount'),
  addrPoolId?: string(name='AddrPoolId'),
  addrs?: {
    addr?: [ 
    {
      addr?: string(name='Addr'),
      alertStatus?: string(name='AlertStatus'),
      attributeInfo?: string(name='AttributeInfo'),
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      lbaWeight?: int32(name='LbaWeight'),
      mode?: string(name='Mode'),
      remark?: string(name='Remark'),
      updateTime?: string(name='UpdateTime'),
      updateTimestamp?: long(name='UpdateTimestamp'),
    }
  ](name='Addr')
  }(name='Addrs'),
  createTime?: string(name='CreateTime'),
  createTimestamp?: long(name='CreateTimestamp'),
  lbaStrategy?: string(name='LbaStrategy'),
  monitorConfigId?: string(name='MonitorConfigId'),
  monitorStatus?: string(name='MonitorStatus'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  type?: string(name='Type'),
  updateTime?: string(name='UpdateTime'),
  updateTimestamp?: long(name='UpdateTimestamp'),
}

model DescribeDnsGtmInstanceAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmInstanceAddressPoolResponseBody(name='body'),
}

async function describeDnsGtmInstanceAddressPoolWithOptions(request: DescribeDnsGtmInstanceAddressPoolRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmInstanceAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addrPoolId)) {
    query['AddrPoolId'] = request.addrPoolId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmInstanceAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmInstanceAddressPool(request: DescribeDnsGtmInstanceAddressPoolRequest): DescribeDnsGtmInstanceAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmInstanceAddressPoolWithOptions(request, runtime);
}

model DescribeDnsGtmInstanceAddressPoolsRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeDnsGtmInstanceAddressPoolsResponseBody = {
  addrPools?: {
    addrPool?: [ 
    {
      addrCount?: int32(name='AddrCount'),
      addrPoolId?: string(name='AddrPoolId'),
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      lbaStrategy?: string(name='LbaStrategy'),
      monitorConfigId?: string(name='MonitorConfigId'),
      monitorStatus?: string(name='MonitorStatus'),
      name?: string(name='Name'),
      type?: string(name='Type'),
      updateTime?: string(name='UpdateTime'),
      updateTimestamp?: long(name='UpdateTimestamp'),
    }
  ](name='AddrPool')
  }(name='AddrPools'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeDnsGtmInstanceAddressPoolsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmInstanceAddressPoolsResponseBody(name='body'),
}

async function describeDnsGtmInstanceAddressPoolsWithOptions(request: DescribeDnsGtmInstanceAddressPoolsRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmInstanceAddressPoolsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmInstanceAddressPools',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmInstanceAddressPools(request: DescribeDnsGtmInstanceAddressPoolsRequest): DescribeDnsGtmInstanceAddressPoolsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmInstanceAddressPoolsWithOptions(request, runtime);
}

model DescribeDnsGtmInstanceStatusRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
}

model DescribeDnsGtmInstanceStatusResponseBody = {
  addrAvailableNum?: int32(name='AddrAvailableNum'),
  addrNotAvailableNum?: int32(name='AddrNotAvailableNum'),
  addrPoolGroupNotAvailableNum?: int32(name='AddrPoolGroupNotAvailableNum'),
  requestId?: string(name='RequestId'),
  strategyNotAvailableNum?: int32(name='StrategyNotAvailableNum'),
  switchToFailoverStrategyNum?: int32(name='SwitchToFailoverStrategyNum'),
}

model DescribeDnsGtmInstanceStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmInstanceStatusResponseBody(name='body'),
}

async function describeDnsGtmInstanceStatusWithOptions(request: DescribeDnsGtmInstanceStatusRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmInstanceStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmInstanceStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmInstanceStatus(request: DescribeDnsGtmInstanceStatusRequest): DescribeDnsGtmInstanceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmInstanceStatusWithOptions(request, runtime);
}

model DescribeDnsGtmInstanceSystemCnameRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
}

model DescribeDnsGtmInstanceSystemCnameResponseBody = {
  requestId?: string(name='RequestId'),
  systemCname?: string(name='SystemCname'),
}

model DescribeDnsGtmInstanceSystemCnameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmInstanceSystemCnameResponseBody(name='body'),
}

async function describeDnsGtmInstanceSystemCnameWithOptions(request: DescribeDnsGtmInstanceSystemCnameRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmInstanceSystemCnameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmInstanceSystemCname',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmInstanceSystemCname(request: DescribeDnsGtmInstanceSystemCnameRequest): DescribeDnsGtmInstanceSystemCnameResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmInstanceSystemCnameWithOptions(request, runtime);
}

model DescribeDnsGtmInstancesRequest {
  keyword?: string(name='Keyword'),
  lang?: string(name='Lang'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeDnsGtmInstancesResponseBody = {
  gtmInstances?: [ 
    {
      config?: {
        alertConfig?: [ 
          {
            dingtalkNotice?: string(name='DingtalkNotice'),
            emailNotice?: string(name='EmailNotice'),
            noticeType?: string(name='NoticeType'),
            smsNotice?: string(name='SmsNotice'),
          }
        ](name='AlertConfig'),
        alertGroup?: string(name='AlertGroup'),
        cnameType?: string(name='CnameType'),
        instanceName?: string(name='InstanceName'),
        publicCnameMode?: string(name='PublicCnameMode'),
        publicRr?: string(name='PublicRr'),
        publicUserDomainName?: string(name='PublicUserDomainName'),
        publicZoneName?: string(name='PublicZoneName'),
        strategyMode?: string(name='StrategyMode'),
        ttl?: int32(name='Ttl'),
      }(name='Config'),
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      expireTime?: string(name='ExpireTime'),
      expireTimestamp?: long(name='ExpireTimestamp'),
      instanceId?: string(name='InstanceId'),
      paymentType?: string(name='PaymentType'),
      resourceGroupId?: string(name='ResourceGroupId'),
      smsQuota?: int32(name='SmsQuota'),
      taskQuota?: int32(name='TaskQuota'),
      usedQuota?: {
        dingtalkUsedCount?: int32(name='DingtalkUsedCount'),
        emailUsedCount?: int32(name='EmailUsedCount'),
        smsUsedCount?: int32(name='SmsUsedCount'),
        taskUsedCount?: int32(name='TaskUsedCount'),
      }(name='UsedQuota'),
      versionCode?: string(name='VersionCode'),
    }
  ](name='GtmInstances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeDnsGtmInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmInstancesResponseBody(name='body'),
}

async function describeDnsGtmInstancesWithOptions(request: DescribeDnsGtmInstancesRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmInstances',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmInstances(request: DescribeDnsGtmInstancesRequest): DescribeDnsGtmInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmInstancesWithOptions(request, runtime);
}

model DescribeDnsGtmLogsRequest {
  endTimestamp?: long(name='EndTimestamp'),
  instanceId?: string(name='InstanceId'),
  keyword?: string(name='Keyword'),
  lang?: string(name='Lang'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startTimestamp?: long(name='StartTimestamp'),
}

model DescribeDnsGtmLogsResponseBody = {
  logs?: {
    log?: [ 
    {
      content?: string(name='Content'),
      entityId?: string(name='EntityId'),
      entityName?: string(name='EntityName'),
      entityType?: string(name='EntityType'),
      id?: long(name='Id'),
      operAction?: string(name='OperAction'),
      operTime?: string(name='OperTime'),
      operTimestamp?: long(name='OperTimestamp'),
    }
  ](name='Log')
  }(name='Logs'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeDnsGtmLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmLogsResponseBody(name='body'),
}

async function describeDnsGtmLogsWithOptions(request: DescribeDnsGtmLogsRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTimestamp)) {
    query['EndTimestamp'] = request.endTimestamp;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTimestamp)) {
    query['StartTimestamp'] = request.startTimestamp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmLogs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmLogs(request: DescribeDnsGtmLogsRequest): DescribeDnsGtmLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmLogsWithOptions(request, runtime);
}

model DescribeDnsGtmMonitorAvailableConfigRequest {
  lang?: string(name='Lang'),
}

model DescribeDnsGtmMonitorAvailableConfigResponseBody = {
  domainIpv4IspCityNodes?: {
    domainIpv4IspCityNode?: [ 
    {
      cityCode?: string(name='CityCode'),
      cityName?: string(name='CityName'),
      defaultSelected?: boolean(name='DefaultSelected'),
      groupName?: string(name='GroupName'),
      groupType?: string(name='GroupType'),
      ips?: {
        ip?: [ string ](name='Ip')
      }(name='Ips'),
      ispCode?: string(name='IspCode'),
      ispName?: string(name='IspName'),
    }
  ](name='DomainIpv4IspCityNode')
  }(name='DomainIpv4IspCityNodes'),
  domainIpv6IspCityNodes?: {
    domainIpv6IspCityNode?: [ 
    {
      cityCode?: string(name='CityCode'),
      cityName?: string(name='CityName'),
      defaultSelected?: boolean(name='DefaultSelected'),
      groupName?: string(name='GroupName'),
      groupType?: string(name='GroupType'),
      ips?: {
        ip?: [ string ](name='ip')
      }(name='Ips'),
      ispCode?: string(name='IspCode'),
      ispName?: string(name='IspName'),
    }
  ](name='DomainIpv6IspCityNode')
  }(name='DomainIpv6IspCityNodes'),
  ipv4IspCityNodes?: {
    ipv4IspCityNode?: [ 
    {
      cityCode?: string(name='CityCode'),
      cityName?: string(name='CityName'),
      defaultSelected?: boolean(name='DefaultSelected'),
      groupName?: string(name='GroupName'),
      groupType?: string(name='GroupType'),
      ips?: {
        ip?: [ string ](name='Ip')
      }(name='Ips'),
      ispCode?: string(name='IspCode'),
      ispName?: string(name='IspName'),
    }
  ](name='Ipv4IspCityNode')
  }(name='Ipv4IspCityNodes'),
  ipv6IspCityNodes?: {
    ipv6IspCityNode?: [ 
    {
      cityCode?: string(name='CityCode'),
      cityName?: string(name='CityName'),
      defaultSelected?: boolean(name='DefaultSelected'),
      groupName?: string(name='GroupName'),
      groupType?: string(name='GroupType'),
      ips?: {
        ip?: [ string ](name='Ip')
      }(name='Ips'),
      ispCode?: string(name='IspCode'),
      ispName?: string(name='IspName'),
    }
  ](name='Ipv6IspCityNode')
  }(name='Ipv6IspCityNodes'),
  requestId?: string(name='RequestId'),
}

model DescribeDnsGtmMonitorAvailableConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmMonitorAvailableConfigResponseBody(name='body'),
}

async function describeDnsGtmMonitorAvailableConfigWithOptions(request: DescribeDnsGtmMonitorAvailableConfigRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmMonitorAvailableConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmMonitorAvailableConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmMonitorAvailableConfig(request: DescribeDnsGtmMonitorAvailableConfigRequest): DescribeDnsGtmMonitorAvailableConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmMonitorAvailableConfigWithOptions(request, runtime);
}

model DescribeDnsGtmMonitorConfigRequest {
  lang?: string(name='Lang'),
  monitorConfigId?: string(name='MonitorConfigId'),
}

model DescribeDnsGtmMonitorConfigResponseBody = {
  createTime?: string(name='CreateTime'),
  createTimestamp?: long(name='CreateTimestamp'),
  evaluationCount?: int32(name='EvaluationCount'),
  interval?: int32(name='Interval'),
  ispCityNodes?: {
    ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode'),
      cityName?: string(name='CityName'),
      countryCode?: string(name='CountryCode'),
      countryName?: string(name='CountryName'),
      ispCode?: string(name='IspCode'),
      ispName?: string(name='IspName'),
    }
  ](name='IspCityNode')
  }(name='IspCityNodes'),
  monitorConfigId?: string(name='MonitorConfigId'),
  monitorExtendInfo?: string(name='MonitorExtendInfo'),
  protocolType?: string(name='ProtocolType'),
  requestId?: string(name='RequestId'),
  timeout?: int32(name='Timeout'),
  updateTime?: string(name='UpdateTime'),
  updateTimestamp?: long(name='UpdateTimestamp'),
}

model DescribeDnsGtmMonitorConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsGtmMonitorConfigResponseBody(name='body'),
}

async function describeDnsGtmMonitorConfigWithOptions(request: DescribeDnsGtmMonitorConfigRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmMonitorConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.monitorConfigId)) {
    query['MonitorConfigId'] = request.monitorConfigId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmMonitorConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsGtmMonitorConfig(request: DescribeDnsGtmMonitorConfigRequest): DescribeDnsGtmMonitorConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmMonitorConfigWithOptions(request, runtime);
}

model DescribeDnsProductInstanceRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model DescribeDnsProductInstanceResponseBody = {
  bindCount?: long(name='BindCount'),
  bindDomainCount?: long(name='BindDomainCount'),
  bindDomainUsedCount?: long(name='BindDomainUsedCount'),
  bindUsedCount?: long(name='BindUsedCount'),
  DDosDefendFlow?: long(name='DDosDefendFlow'),
  DDosDefendQuery?: long(name='DDosDefendQuery'),
  dnsSLBCount?: long(name='DnsSLBCount'),
  dnsSecurity?: string(name='DnsSecurity'),
  dnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='DnsServers'),
  domain?: string(name='Domain'),
  domainType?: string(name='DomainType'),
  endTime?: string(name='EndTime'),
  endTimestamp?: long(name='EndTimestamp'),
  gslb?: boolean(name='Gslb'),
  ISPLines?: string(name='ISPLines'),
  ISPRegionLines?: string(name='ISPRegionLines'),
  inBlackHole?: boolean(name='InBlackHole'),
  inClean?: boolean(name='InClean'),
  instanceId?: string(name='InstanceId'),
  monitorFrequency?: long(name='MonitorFrequency'),
  monitorNodeCount?: long(name='MonitorNodeCount'),
  monitorTaskCount?: long(name='MonitorTaskCount'),
  overseaDDosDefendFlow?: long(name='OverseaDDosDefendFlow'),
  overseaLine?: string(name='OverseaLine'),
  paymentType?: string(name='PaymentType'),
  regionLines?: boolean(name='RegionLines'),
  requestId?: string(name='RequestId'),
  searchEngineLines?: string(name='SearchEngineLines'),
  startTime?: string(name='StartTime'),
  startTimestamp?: long(name='StartTimestamp'),
  subDomainLevel?: long(name='SubDomainLevel'),
  TTLMinValue?: long(name='TTLMinValue'),
  URLForwardCount?: long(name='URLForwardCount'),
  versionCode?: string(name='VersionCode'),
  versionName?: string(name='VersionName'),
}

model DescribeDnsProductInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsProductInstanceResponseBody(name='body'),
}

async function describeDnsProductInstanceWithOptions(request: DescribeDnsProductInstanceRequest, runtime: Util.RuntimeOptions): DescribeDnsProductInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsProductInstance',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsProductInstance(request: DescribeDnsProductInstanceRequest): DescribeDnsProductInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsProductInstanceWithOptions(request, runtime);
}

model DescribeDnsProductInstancesRequest {
  domainType?: string(name='DomainType'),
  lang?: string(name='Lang'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  userClientIp?: string(name='UserClientIp'),
  versionCode?: string(name='VersionCode'),
}

model DescribeDnsProductInstancesResponseBody = {
  dnsProducts?: {
    dnsProduct?: [ 
    {
      bindCount?: long(name='BindCount'),
      bindDomainCount?: long(name='BindDomainCount'),
      bindDomainUsedCount?: long(name='BindDomainUsedCount'),
      bindUsedCount?: long(name='BindUsedCount'),
      DDosDefendFlow?: long(name='DDosDefendFlow'),
      DDosDefendQuery?: long(name='DDosDefendQuery'),
      dnsSLBCount?: long(name='DnsSLBCount'),
      dnsSecurity?: string(name='DnsSecurity'),
      domain?: string(name='Domain'),
      endTime?: string(name='EndTime'),
      endTimestamp?: long(name='EndTimestamp'),
      gslb?: boolean(name='Gslb'),
      ISPLines?: string(name='ISPLines'),
      ISPRegionLines?: string(name='ISPRegionLines'),
      inBlackHole?: boolean(name='InBlackHole'),
      inClean?: boolean(name='InClean'),
      instanceId?: string(name='InstanceId'),
      monitorFrequency?: long(name='MonitorFrequency'),
      monitorNodeCount?: long(name='MonitorNodeCount'),
      monitorTaskCount?: long(name='MonitorTaskCount'),
      overseaDDosDefendFlow?: long(name='OverseaDDosDefendFlow'),
      overseaLine?: string(name='OverseaLine'),
      paymentType?: string(name='PaymentType'),
      regionLines?: boolean(name='RegionLines'),
      searchEngineLines?: string(name='SearchEngineLines'),
      startTime?: string(name='StartTime'),
      startTimestamp?: long(name='StartTimestamp'),
      subDomainLevel?: long(name='SubDomainLevel'),
      TTLMinValue?: long(name='TTLMinValue'),
      URLForwardCount?: long(name='URLForwardCount'),
      versionCode?: string(name='VersionCode'),
      versionName?: string(name='VersionName'),
    }
  ](name='DnsProduct')
  }(name='DnsProducts'),
  domainType?: string(name='DomainType'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeDnsProductInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDnsProductInstancesResponseBody(name='body'),
}

async function describeDnsProductInstancesWithOptions(request: DescribeDnsProductInstancesRequest, runtime: Util.RuntimeOptions): DescribeDnsProductInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainType)) {
    query['DomainType'] = request.domainType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  if (!Util.isUnset(request.versionCode)) {
    query['VersionCode'] = request.versionCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsProductInstances',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDnsProductInstances(request: DescribeDnsProductInstancesRequest): DescribeDnsProductInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsProductInstancesWithOptions(request, runtime);
}

model DescribeDohAccountStatisticsRequest {
  endDate?: string(name='EndDate'),
  lang?: string(name='Lang'),
  startDate?: string(name='StartDate'),
}

model DescribeDohAccountStatisticsResponseBody = {
  requestId?: string(name='RequestId'),
  statistics?: [ 
    {
      timestamp?: long(name='Timestamp'),
      totalCount?: long(name='TotalCount'),
      v4HttpCount?: long(name='V4HttpCount'),
      v4HttpsCount?: long(name='V4HttpsCount'),
      v6HttpCount?: long(name='V6HttpCount'),
      v6HttpsCount?: long(name='V6HttpsCount'),
    }
  ](name='Statistics'),
}

model DescribeDohAccountStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDohAccountStatisticsResponseBody(name='body'),
}

async function describeDohAccountStatisticsWithOptions(request: DescribeDohAccountStatisticsRequest, runtime: Util.RuntimeOptions): DescribeDohAccountStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDohAccountStatistics',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDohAccountStatistics(request: DescribeDohAccountStatisticsRequest): DescribeDohAccountStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDohAccountStatisticsWithOptions(request, runtime);
}

model DescribeDohDomainStatisticsRequest {
  domainName?: string(name='DomainName'),
  endDate?: string(name='EndDate'),
  lang?: string(name='Lang'),
  startDate?: string(name='StartDate'),
}

model DescribeDohDomainStatisticsResponseBody = {
  requestId?: string(name='RequestId'),
  statistics?: [ 
    {
      timestamp?: long(name='Timestamp'),
      totalCount?: long(name='TotalCount'),
      v4HttpCount?: long(name='V4HttpCount'),
      v4HttpsCount?: long(name='V4HttpsCount'),
      v6HttpCount?: long(name='V6HttpCount'),
      v6HttpsCount?: long(name='V6HttpsCount'),
    }
  ](name='Statistics'),
}

model DescribeDohDomainStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDohDomainStatisticsResponseBody(name='body'),
}

async function describeDohDomainStatisticsWithOptions(request: DescribeDohDomainStatisticsRequest, runtime: Util.RuntimeOptions): DescribeDohDomainStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDohDomainStatistics',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDohDomainStatistics(request: DescribeDohDomainStatisticsRequest): DescribeDohDomainStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDohDomainStatisticsWithOptions(request, runtime);
}

model DescribeDohDomainStatisticsSummaryRequest {
  domainName?: string(name='DomainName'),
  endDate?: string(name='EndDate'),
  lang?: string(name='Lang'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startDate?: string(name='StartDate'),
}

model DescribeDohDomainStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  statistics?: [ 
    {
      domainName?: string(name='DomainName'),
      httpCount?: long(name='HttpCount'),
      httpsCount?: long(name='HttpsCount'),
      ipCount?: long(name='IpCount'),
      totalCount?: long(name='TotalCount'),
      v4HttpCount?: long(name='V4HttpCount'),
      v4HttpsCount?: long(name='V4HttpsCount'),
      v6HttpCount?: long(name='V6HttpCount'),
      v6HttpsCount?: long(name='V6HttpsCount'),
    }
  ](name='Statistics'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeDohDomainStatisticsSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDohDomainStatisticsSummaryResponseBody(name='body'),
}

async function describeDohDomainStatisticsSummaryWithOptions(request: DescribeDohDomainStatisticsSummaryRequest, runtime: Util.RuntimeOptions): DescribeDohDomainStatisticsSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDohDomainStatisticsSummary',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDohDomainStatisticsSummary(request: DescribeDohDomainStatisticsSummaryRequest): DescribeDohDomainStatisticsSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDohDomainStatisticsSummaryWithOptions(request, runtime);
}

model DescribeDohSubDomainStatisticsRequest {
  endDate?: string(name='EndDate'),
  lang?: string(name='Lang'),
  startDate?: string(name='StartDate'),
  subDomain?: string(name='SubDomain'),
}

model DescribeDohSubDomainStatisticsResponseBody = {
  requestId?: string(name='RequestId'),
  statistics?: [ 
    {
      timestamp?: long(name='Timestamp'),
      totalCount?: long(name='TotalCount'),
      v4HttpCount?: long(name='V4HttpCount'),
      v4HttpsCount?: long(name='V4HttpsCount'),
      v6HttpCount?: long(name='V6HttpCount'),
      v6HttpsCount?: long(name='V6HttpsCount'),
    }
  ](name='Statistics'),
}

model DescribeDohSubDomainStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDohSubDomainStatisticsResponseBody(name='body'),
}

async function describeDohSubDomainStatisticsWithOptions(request: DescribeDohSubDomainStatisticsRequest, runtime: Util.RuntimeOptions): DescribeDohSubDomainStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.subDomain)) {
    query['SubDomain'] = request.subDomain;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDohSubDomainStatistics',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDohSubDomainStatistics(request: DescribeDohSubDomainStatisticsRequest): DescribeDohSubDomainStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDohSubDomainStatisticsWithOptions(request, runtime);
}

model DescribeDohSubDomainStatisticsSummaryRequest {
  domainName?: string(name='DomainName'),
  endDate?: string(name='EndDate'),
  lang?: string(name='Lang'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startDate?: string(name='StartDate'),
  subDomain?: string(name='SubDomain'),
}

model DescribeDohSubDomainStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  statistics?: [ 
    {
      httpCount?: long(name='HttpCount'),
      httpsCount?: long(name='HttpsCount'),
      ipCount?: long(name='IpCount'),
      subDomain?: string(name='SubDomain'),
      totalCount?: long(name='TotalCount'),
      v4HttpCount?: long(name='V4HttpCount'),
      v4HttpsCount?: long(name='V4HttpsCount'),
      v6HttpCount?: long(name='V6HttpCount'),
      v6HttpsCount?: long(name='V6HttpsCount'),
    }
  ](name='Statistics'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeDohSubDomainStatisticsSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDohSubDomainStatisticsSummaryResponseBody(name='body'),
}

async function describeDohSubDomainStatisticsSummaryWithOptions(request: DescribeDohSubDomainStatisticsSummaryRequest, runtime: Util.RuntimeOptions): DescribeDohSubDomainStatisticsSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.subDomain)) {
    query['SubDomain'] = request.subDomain;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDohSubDomainStatisticsSummary',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDohSubDomainStatisticsSummary(request: DescribeDohSubDomainStatisticsSummaryRequest): DescribeDohSubDomainStatisticsSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDohSubDomainStatisticsSummaryWithOptions(request, runtime);
}

model DescribeDohUserInfoRequest {
  endDate?: string(name='EndDate'),
  lang?: string(name='Lang'),
  startDate?: string(name='StartDate'),
}

model DescribeDohUserInfoResponseBody = {
  domainCount?: int32(name='DomainCount'),
  pdnsId?: long(name='PdnsId'),
  requestId?: string(name='RequestId'),
  subDomainCount?: int32(name='SubDomainCount'),
}

model DescribeDohUserInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDohUserInfoResponseBody(name='body'),
}

async function describeDohUserInfoWithOptions(request: DescribeDohUserInfoRequest, runtime: Util.RuntimeOptions): DescribeDohUserInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDohUserInfo',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDohUserInfo(request: DescribeDohUserInfoRequest): DescribeDohUserInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDohUserInfoWithOptions(request, runtime);
}

model DescribeDomainDnssecInfoRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
}

model DescribeDomainDnssecInfoResponseBody = {
  algorithm?: string(name='Algorithm'),
  digest?: string(name='Digest'),
  digestType?: string(name='DigestType'),
  domainName?: string(name='DomainName'),
  dsRecord?: string(name='DsRecord'),
  flags?: string(name='Flags'),
  keyTag?: string(name='KeyTag'),
  publicKey?: string(name='PublicKey'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model DescribeDomainDnssecInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainDnssecInfoResponseBody(name='body'),
}

async function describeDomainDnssecInfoWithOptions(request: DescribeDomainDnssecInfoRequest, runtime: Util.RuntimeOptions): DescribeDomainDnssecInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainDnssecInfo',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainDnssecInfo(request: DescribeDomainDnssecInfoRequest): DescribeDomainDnssecInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainDnssecInfoWithOptions(request, runtime);
}

model DescribeDomainGroupsRequest {
  keyWord?: string(name='KeyWord'),
  lang?: string(name='Lang'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
}

model DescribeDomainGroupsResponseBody = {
  domainGroups?: {
    domainGroup?: [ 
    {
      domainCount?: long(name='DomainCount'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
    }
  ](name='DomainGroup')
  }(name='DomainGroups'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeDomainGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainGroupsResponseBody(name='body'),
}

async function describeDomainGroupsWithOptions(request: DescribeDomainGroupsRequest, runtime: Util.RuntimeOptions): DescribeDomainGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainGroups',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainGroups(request: DescribeDomainGroupsRequest): DescribeDomainGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainGroupsWithOptions(request, runtime);
}

model DescribeDomainInfoRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  needDetailAttributes?: boolean(name='NeedDetailAttributes'),
}

model DescribeDomainInfoResponseBody = {
  aliDomain?: boolean(name='AliDomain'),
  availableTtls?: {
    availableTtl?: [ string ](name='AvailableTtl')
  }(name='AvailableTtls'),
  createTime?: string(name='CreateTime'),
  dnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='DnsServers'),
  domainId?: string(name='DomainId'),
  domainName?: string(name='DomainName'),
  groupId?: string(name='GroupId'),
  groupName?: string(name='GroupName'),
  inBlackHole?: boolean(name='InBlackHole'),
  inClean?: boolean(name='InClean'),
  instanceId?: string(name='InstanceId'),
  lineType?: string(name='LineType'),
  minTtl?: long(name='MinTtl'),
  punyCode?: string(name='PunyCode'),
  recordLineTreeJson?: string(name='RecordLineTreeJson'),
  recordLines?: {
    recordLine?: [ 
    {
      fatherCode?: string(name='FatherCode'),
      lineCode?: string(name='LineCode'),
      lineDisplayName?: string(name='LineDisplayName'),
      lineName?: string(name='LineName'),
    }
  ](name='RecordLine')
  }(name='RecordLines'),
  regionLines?: boolean(name='RegionLines'),
  remark?: string(name='Remark'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  slaveDns?: boolean(name='SlaveDns'),
  versionCode?: string(name='VersionCode'),
  versionName?: string(name='VersionName'),
}

model DescribeDomainInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainInfoResponseBody(name='body'),
}

async function describeDomainInfoWithOptions(request: DescribeDomainInfoRequest, runtime: Util.RuntimeOptions): DescribeDomainInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.needDetailAttributes)) {
    query['NeedDetailAttributes'] = request.needDetailAttributes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainInfo',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainInfo(request: DescribeDomainInfoRequest): DescribeDomainInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainInfoWithOptions(request, runtime);
}

model DescribeDomainLogsRequest {
  groupId?: string(name='GroupId'),
  keyWord?: string(name='KeyWord'),
  lang?: string(name='Lang'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  startDate?: string(name='StartDate'),
  type?: string(name='Type'),
  endDate?: string(name='endDate'),
}

model DescribeDomainLogsResponseBody = {
  domainLogs?: {
    domainLog?: [ 
    {
      action?: string(name='Action'),
      actionTime?: string(name='ActionTime'),
      actionTimestamp?: long(name='ActionTimestamp'),
      clientIp?: string(name='ClientIp'),
      domainName?: string(name='DomainName'),
      message?: string(name='Message'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='DomainLog')
  }(name='DomainLogs'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeDomainLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainLogsResponseBody(name='body'),
}

async function describeDomainLogsWithOptions(request: DescribeDomainLogsRequest, runtime: Util.RuntimeOptions): DescribeDomainLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.endDate)) {
    query['endDate'] = request.endDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainLogs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainLogs(request: DescribeDomainLogsRequest): DescribeDomainLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainLogsWithOptions(request, runtime);
}

model DescribeDomainNsRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
}

model DescribeDomainNsResponseBody = {
  allAliDns?: boolean(name='AllAliDns'),
  dnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='DnsServers'),
  expectDnsServers?: {
    expectDnsServer?: [ string ](name='ExpectDnsServer')
  }(name='ExpectDnsServers'),
  includeAliDns?: boolean(name='IncludeAliDns'),
  requestId?: string(name='RequestId'),
}

model DescribeDomainNsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainNsResponseBody(name='body'),
}

async function describeDomainNsWithOptions(request: DescribeDomainNsRequest, runtime: Util.RuntimeOptions): DescribeDomainNsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainNs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainNs(request: DescribeDomainNsRequest): DescribeDomainNsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainNsWithOptions(request, runtime);
}

model DescribeDomainRecordInfoRequest {
  lang?: string(name='Lang'),
  recordId?: string(name='RecordId'),
  userClientIp?: string(name='UserClientIp'),
}

model DescribeDomainRecordInfoResponseBody = {
  domainId?: string(name='DomainId'),
  domainName?: string(name='DomainName'),
  groupId?: string(name='GroupId'),
  groupName?: string(name='GroupName'),
  line?: string(name='Line'),
  locked?: boolean(name='Locked'),
  priority?: long(name='Priority'),
  punyCode?: string(name='PunyCode'),
  RR?: string(name='RR'),
  recordId?: string(name='RecordId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  TTL?: long(name='TTL'),
  type?: string(name='Type'),
  value?: string(name='Value'),
}

model DescribeDomainRecordInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainRecordInfoResponseBody(name='body'),
}

async function describeDomainRecordInfoWithOptions(request: DescribeDomainRecordInfoRequest, runtime: Util.RuntimeOptions): DescribeDomainRecordInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recordId)) {
    query['RecordId'] = request.recordId;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainRecordInfo',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainRecordInfo(request: DescribeDomainRecordInfoRequest): DescribeDomainRecordInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainRecordInfoWithOptions(request, runtime);
}

model DescribeDomainRecordsRequest {
  direction?: string(name='Direction'),
  domainName?: string(name='DomainName'),
  groupId?: long(name='GroupId'),
  keyWord?: string(name='KeyWord'),
  lang?: string(name='Lang'),
  line?: string(name='Line'),
  orderBy?: string(name='OrderBy'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  RRKeyWord?: string(name='RRKeyWord'),
  searchMode?: string(name='SearchMode'),
  status?: string(name='Status'),
  type?: string(name='Type'),
  typeKeyWord?: string(name='TypeKeyWord'),
  valueKeyWord?: string(name='ValueKeyWord'),
}

model DescribeDomainRecordsResponseBody = {
  domainRecords?: {
    record?: [ 
    {
      domainName?: string(name='DomainName'),
      line?: string(name='Line'),
      locked?: boolean(name='Locked'),
      priority?: long(name='Priority'),
      RR?: string(name='RR'),
      recordId?: string(name='RecordId'),
      remark?: string(name='Remark'),
      status?: string(name='Status'),
      TTL?: long(name='TTL'),
      type?: string(name='Type'),
      value?: string(name='Value'),
      weight?: int32(name='Weight'),
    }
  ](name='Record')
  }(name='DomainRecords'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeDomainRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainRecordsResponseBody(name='body'),
}

async function describeDomainRecordsWithOptions(request: DescribeDomainRecordsRequest, runtime: Util.RuntimeOptions): DescribeDomainRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.line)) {
    query['Line'] = request.line;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.RRKeyWord)) {
    query['RRKeyWord'] = request.RRKeyWord;
  }
  if (!Util.isUnset(request.searchMode)) {
    query['SearchMode'] = request.searchMode;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.typeKeyWord)) {
    query['TypeKeyWord'] = request.typeKeyWord;
  }
  if (!Util.isUnset(request.valueKeyWord)) {
    query['ValueKeyWord'] = request.valueKeyWord;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainRecords',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainRecords(request: DescribeDomainRecordsRequest): DescribeDomainRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainRecordsWithOptions(request, runtime);
}

model DescribeDomainStatisticsRequest {
  domainName?: string(name='DomainName'),
  domainType?: string(name='DomainType'),
  endDate?: string(name='EndDate'),
  lang?: string(name='Lang'),
  startDate?: string(name='StartDate'),
}

model DescribeDomainStatisticsResponseBody = {
  requestId?: string(name='RequestId'),
  statistics?: {
    statistic?: [ 
    {
      count?: long(name='Count'),
      timestamp?: long(name='Timestamp'),
    }
  ](name='Statistic')
  }(name='Statistics'),
}

model DescribeDomainStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainStatisticsResponseBody(name='body'),
}

async function describeDomainStatisticsWithOptions(request: DescribeDomainStatisticsRequest, runtime: Util.RuntimeOptions): DescribeDomainStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainType)) {
    query['DomainType'] = request.domainType;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainStatistics',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainStatistics(request: DescribeDomainStatisticsRequest): DescribeDomainStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainStatisticsWithOptions(request, runtime);
}

model DescribeDomainStatisticsSummaryRequest {
  endDate?: string(name='EndDate'),
  keyword?: string(name='Keyword'),
  lang?: string(name='Lang'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  searchMode?: string(name='SearchMode'),
  startDate?: string(name='StartDate'),
  threshold?: long(name='Threshold'),
}

model DescribeDomainStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  statistics?: {
    statistic?: [ 
    {
      count?: long(name='Count'),
      domainName?: string(name='DomainName'),
      domainType?: string(name='DomainType'),
    }
  ](name='Statistic')
  }(name='Statistics'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeDomainStatisticsSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainStatisticsSummaryResponseBody(name='body'),
}

async function describeDomainStatisticsSummaryWithOptions(request: DescribeDomainStatisticsSummaryRequest, runtime: Util.RuntimeOptions): DescribeDomainStatisticsSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchMode)) {
    query['SearchMode'] = request.searchMode;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.threshold)) {
    query['Threshold'] = request.threshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainStatisticsSummary',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainStatisticsSummary(request: DescribeDomainStatisticsSummaryRequest): DescribeDomainStatisticsSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainStatisticsSummaryWithOptions(request, runtime);
}

model DescribeDomainsRequest {
  groupId?: string(name='GroupId'),
  keyWord?: string(name='KeyWord'),
  lang?: string(name='Lang'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
  searchMode?: string(name='SearchMode'),
  starmark?: boolean(name='Starmark'),
}

model DescribeDomainsResponseBody = {
  domains?: {
    domain?: [ 
    {
      aliDomain?: boolean(name='AliDomain'),
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      dnsServers?: {
        dnsServer?: [ string ](name='DnsServer')
      }(name='DnsServers'),
      domainId?: string(name='DomainId'),
      domainName?: string(name='DomainName'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      instanceEndTime?: string(name='InstanceEndTime'),
      instanceExpired?: boolean(name='InstanceExpired'),
      instanceId?: string(name='InstanceId'),
      punyCode?: string(name='PunyCode'),
      recordCount?: long(name='RecordCount'),
      registrantEmail?: string(name='RegistrantEmail'),
      remark?: string(name='Remark'),
      resourceGroupId?: string(name='ResourceGroupId'),
      starmark?: boolean(name='Starmark'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      versionCode?: string(name='VersionCode'),
      versionName?: string(name='VersionName'),
    }
  ](name='Domain')
  }(name='Domains'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainsResponseBody(name='body'),
}

async function describeDomainsWithOptions(request: DescribeDomainsRequest, runtime: Util.RuntimeOptions): DescribeDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.searchMode)) {
    query['SearchMode'] = request.searchMode;
  }
  if (!Util.isUnset(request.starmark)) {
    query['Starmark'] = request.starmark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomains',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomains(request: DescribeDomainsRequest): DescribeDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainsWithOptions(request, runtime);
}

model DescribeGtmAccessStrategiesRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeGtmAccessStrategiesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  strategies?: {
    strategy?: [ 
    {
      accessMode?: string(name='AccessMode'),
      accessStatus?: string(name='AccessStatus'),
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      defaultAddrPoolId?: string(name='DefaultAddrPoolId'),
      defaultAddrPoolMonitorStatus?: string(name='DefaultAddrPoolMonitorStatus'),
      defaultAddrPoolName?: string(name='DefaultAddrPoolName'),
      defaultAddrPoolStatus?: string(name='DefaultAddrPoolStatus'),
      failoverAddrPoolId?: string(name='FailoverAddrPoolId'),
      failoverAddrPoolMonitorStatus?: string(name='FailoverAddrPoolMonitorStatus'),
      failoverAddrPoolName?: string(name='FailoverAddrPoolName'),
      failoverAddrPoolStatus?: string(name='FailoverAddrPoolStatus'),
      instanceId?: string(name='InstanceId'),
      lines?: {
        line?: [ 
        {
          groupCode?: string(name='GroupCode'),
          groupName?: string(name='GroupName'),
          lineCode?: string(name='LineCode'),
          lineName?: string(name='LineName'),
        }
      ](name='Line')
      }(name='Lines'),
      strategyId?: string(name='StrategyId'),
      strategyMode?: string(name='StrategyMode'),
      strategyName?: string(name='StrategyName'),
    }
  ](name='Strategy')
  }(name='Strategies'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeGtmAccessStrategiesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmAccessStrategiesResponseBody(name='body'),
}

async function describeGtmAccessStrategiesWithOptions(request: DescribeGtmAccessStrategiesRequest, runtime: Util.RuntimeOptions): DescribeGtmAccessStrategiesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmAccessStrategies',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmAccessStrategies(request: DescribeGtmAccessStrategiesRequest): DescribeGtmAccessStrategiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmAccessStrategiesWithOptions(request, runtime);
}

model DescribeGtmAccessStrategyRequest {
  lang?: string(name='Lang'),
  strategyId?: string(name='StrategyId'),
}

model DescribeGtmAccessStrategyResponseBody = {
  accessMode?: string(name='AccessMode'),
  accessStatus?: string(name='AccessStatus'),
  defaultAddrPoolMonitorStatus?: string(name='DefaultAddrPoolMonitorStatus'),
  defaultAddrPoolName?: string(name='DefaultAddrPoolName'),
  defaultAddrPoolStatus?: string(name='DefaultAddrPoolStatus'),
  defultAddrPoolId?: string(name='DefultAddrPoolId'),
  failoverAddrPoolId?: string(name='FailoverAddrPoolId'),
  failoverAddrPoolMonitorStatus?: string(name='FailoverAddrPoolMonitorStatus'),
  failoverAddrPoolName?: string(name='FailoverAddrPoolName'),
  failoverAddrPoolStatus?: string(name='FailoverAddrPoolStatus'),
  instanceId?: string(name='InstanceId'),
  lines?: {
    line?: [ 
    {
      groupCode?: string(name='GroupCode'),
      groupName?: string(name='GroupName'),
      lineCode?: string(name='LineCode'),
      lineName?: string(name='LineName'),
    }
  ](name='Line')
  }(name='Lines'),
  requestId?: string(name='RequestId'),
  strategyId?: string(name='StrategyId'),
  strategyMode?: string(name='StrategyMode'),
  strategyName?: string(name='StrategyName'),
}

model DescribeGtmAccessStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmAccessStrategyResponseBody(name='body'),
}

async function describeGtmAccessStrategyWithOptions(request: DescribeGtmAccessStrategyRequest, runtime: Util.RuntimeOptions): DescribeGtmAccessStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmAccessStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmAccessStrategy(request: DescribeGtmAccessStrategyRequest): DescribeGtmAccessStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmAccessStrategyWithOptions(request, runtime);
}

model DescribeGtmAccessStrategyAvailableConfigRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
}

model DescribeGtmAccessStrategyAvailableConfigResponseBody = {
  addrPools?: {
    addrPool?: [ 
    {
      addrPoolId?: string(name='AddrPoolId'),
      addrPoolName?: string(name='AddrPoolName'),
    }
  ](name='AddrPool')
  }(name='AddrPools'),
  lines?: {
    line?: [ 
    {
      fatherCode?: string(name='FatherCode'),
      groupCode?: string(name='GroupCode'),
      groupName?: string(name='GroupName'),
      lineCode?: string(name='LineCode'),
      lineName?: string(name='LineName'),
      status?: string(name='Status'),
    }
  ](name='Line')
  }(name='Lines'),
  requestId?: string(name='RequestId'),
}

model DescribeGtmAccessStrategyAvailableConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmAccessStrategyAvailableConfigResponseBody(name='body'),
}

async function describeGtmAccessStrategyAvailableConfigWithOptions(request: DescribeGtmAccessStrategyAvailableConfigRequest, runtime: Util.RuntimeOptions): DescribeGtmAccessStrategyAvailableConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmAccessStrategyAvailableConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmAccessStrategyAvailableConfig(request: DescribeGtmAccessStrategyAvailableConfigRequest): DescribeGtmAccessStrategyAvailableConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmAccessStrategyAvailableConfigWithOptions(request, runtime);
}

model DescribeGtmAvailableAlertGroupRequest {
  lang?: string(name='Lang'),
}

model DescribeGtmAvailableAlertGroupResponseBody = {
  availableAlertGroup?: string(name='AvailableAlertGroup'),
  requestId?: string(name='RequestId'),
}

model DescribeGtmAvailableAlertGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmAvailableAlertGroupResponseBody(name='body'),
}

async function describeGtmAvailableAlertGroupWithOptions(request: DescribeGtmAvailableAlertGroupRequest, runtime: Util.RuntimeOptions): DescribeGtmAvailableAlertGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmAvailableAlertGroup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmAvailableAlertGroup(request: DescribeGtmAvailableAlertGroupRequest): DescribeGtmAvailableAlertGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmAvailableAlertGroupWithOptions(request, runtime);
}

model DescribeGtmInstanceRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  needDetailAttributes?: boolean(name='NeedDetailAttributes'),
}

model DescribeGtmInstanceResponseBody = {
  accessStrategyNum?: int32(name='AccessStrategyNum'),
  addressPoolNum?: int32(name='AddressPoolNum'),
  alertGroup?: string(name='AlertGroup'),
  cname?: string(name='Cname'),
  cnameMode?: string(name='CnameMode'),
  createTime?: string(name='CreateTime'),
  createTimestamp?: long(name='CreateTimestamp'),
  expireTime?: string(name='ExpireTime'),
  expireTimestamp?: long(name='ExpireTimestamp'),
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  lbaStrategy?: string(name='LbaStrategy'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  ttl?: int32(name='Ttl'),
  userDomainName?: string(name='UserDomainName'),
  versionCode?: string(name='VersionCode'),
}

model DescribeGtmInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmInstanceResponseBody(name='body'),
}

async function describeGtmInstanceWithOptions(request: DescribeGtmInstanceRequest, runtime: Util.RuntimeOptions): DescribeGtmInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.needDetailAttributes)) {
    query['NeedDetailAttributes'] = request.needDetailAttributes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmInstance',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmInstance(request: DescribeGtmInstanceRequest): DescribeGtmInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmInstanceWithOptions(request, runtime);
}

model DescribeGtmInstanceAddressPoolRequest {
  addrPoolId?: string(name='AddrPoolId'),
  lang?: string(name='Lang'),
}

model DescribeGtmInstanceAddressPoolResponseBody = {
  addrCount?: int32(name='AddrCount'),
  addrPoolId?: string(name='AddrPoolId'),
  addrs?: {
    addr?: [ 
    {
      addrId?: long(name='AddrId'),
      alertStatus?: string(name='AlertStatus'),
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      lbaWeight?: int32(name='LbaWeight'),
      mode?: string(name='Mode'),
      updateTime?: string(name='UpdateTime'),
      updateTimestamp?: long(name='UpdateTimestamp'),
      value?: string(name='Value'),
    }
  ](name='Addr')
  }(name='Addrs'),
  createTime?: string(name='CreateTime'),
  createTimestamp?: long(name='CreateTimestamp'),
  minAvailableAddrNum?: int32(name='MinAvailableAddrNum'),
  monitorConfigId?: string(name='MonitorConfigId'),
  monitorStatus?: string(name='MonitorStatus'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  type?: string(name='Type'),
  updateTime?: string(name='UpdateTime'),
  updateTimestamp?: long(name='UpdateTimestamp'),
}

model DescribeGtmInstanceAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmInstanceAddressPoolResponseBody(name='body'),
}

async function describeGtmInstanceAddressPoolWithOptions(request: DescribeGtmInstanceAddressPoolRequest, runtime: Util.RuntimeOptions): DescribeGtmInstanceAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addrPoolId)) {
    query['AddrPoolId'] = request.addrPoolId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmInstanceAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmInstanceAddressPool(request: DescribeGtmInstanceAddressPoolRequest): DescribeGtmInstanceAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmInstanceAddressPoolWithOptions(request, runtime);
}

model DescribeGtmInstanceAddressPoolsRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeGtmInstanceAddressPoolsResponseBody = {
  addrPools?: {
    addrPool?: [ 
    {
      addrCount?: int32(name='AddrCount'),
      addrPoolId?: string(name='AddrPoolId'),
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      minAvailableAddrNum?: int32(name='MinAvailableAddrNum'),
      monitorConfigId?: string(name='MonitorConfigId'),
      monitorStatus?: string(name='MonitorStatus'),
      name?: string(name='Name'),
      status?: string(name='Status'),
      type?: string(name='Type'),
      updateTime?: string(name='UpdateTime'),
      updateTimestamp?: long(name='UpdateTimestamp'),
    }
  ](name='AddrPool')
  }(name='AddrPools'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeGtmInstanceAddressPoolsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmInstanceAddressPoolsResponseBody(name='body'),
}

async function describeGtmInstanceAddressPoolsWithOptions(request: DescribeGtmInstanceAddressPoolsRequest, runtime: Util.RuntimeOptions): DescribeGtmInstanceAddressPoolsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmInstanceAddressPools',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmInstanceAddressPools(request: DescribeGtmInstanceAddressPoolsRequest): DescribeGtmInstanceAddressPoolsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmInstanceAddressPoolsWithOptions(request, runtime);
}

model DescribeGtmInstanceStatusRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
}

model DescribeGtmInstanceStatusResponseBody = {
  addrNotAvailableNum?: int32(name='AddrNotAvailableNum'),
  addrPoolNotAvailableNum?: int32(name='AddrPoolNotAvailableNum'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  statusReason?: string(name='StatusReason'),
  strategyNotAvailableNum?: int32(name='StrategyNotAvailableNum'),
  switchToFailoverStrategyNum?: int32(name='SwitchToFailoverStrategyNum'),
}

model DescribeGtmInstanceStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmInstanceStatusResponseBody(name='body'),
}

async function describeGtmInstanceStatusWithOptions(request: DescribeGtmInstanceStatusRequest, runtime: Util.RuntimeOptions): DescribeGtmInstanceStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmInstanceStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmInstanceStatus(request: DescribeGtmInstanceStatusRequest): DescribeGtmInstanceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmInstanceStatusWithOptions(request, runtime);
}

model DescribeGtmInstanceSystemCnameRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
}

model DescribeGtmInstanceSystemCnameResponseBody = {
  requestId?: string(name='RequestId'),
  systemCname?: string(name='SystemCname'),
}

model DescribeGtmInstanceSystemCnameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmInstanceSystemCnameResponseBody(name='body'),
}

async function describeGtmInstanceSystemCnameWithOptions(request: DescribeGtmInstanceSystemCnameRequest, runtime: Util.RuntimeOptions): DescribeGtmInstanceSystemCnameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmInstanceSystemCname',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmInstanceSystemCname(request: DescribeGtmInstanceSystemCnameRequest): DescribeGtmInstanceSystemCnameResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmInstanceSystemCnameWithOptions(request, runtime);
}

model DescribeGtmInstancesRequest {
  keyword?: string(name='Keyword'),
  lang?: string(name='Lang'),
  needDetailAttributes?: boolean(name='NeedDetailAttributes'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeGtmInstancesResponseBody = {
  gtmInstances?: {
    gtmInstance?: [ 
    {
      accessStrategyNum?: int32(name='AccessStrategyNum'),
      addressPoolNum?: int32(name='AddressPoolNum'),
      alertGroup?: string(name='AlertGroup'),
      cname?: string(name='Cname'),
      cnameMode?: string(name='CnameMode'),
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      expireTime?: string(name='ExpireTime'),
      expireTimestamp?: long(name='ExpireTimestamp'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      lbaStrategy?: string(name='LbaStrategy'),
      resourceGroupId?: string(name='ResourceGroupId'),
      ttl?: int32(name='Ttl'),
      userDomainName?: string(name='UserDomainName'),
      versionCode?: string(name='VersionCode'),
    }
  ](name='GtmInstance')
  }(name='GtmInstances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeGtmInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmInstancesResponseBody(name='body'),
}

async function describeGtmInstancesWithOptions(request: DescribeGtmInstancesRequest, runtime: Util.RuntimeOptions): DescribeGtmInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.needDetailAttributes)) {
    query['NeedDetailAttributes'] = request.needDetailAttributes;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmInstances',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmInstances(request: DescribeGtmInstancesRequest): DescribeGtmInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmInstancesWithOptions(request, runtime);
}

model DescribeGtmLogsRequest {
  endTimestamp?: long(name='EndTimestamp'),
  instanceId?: string(name='InstanceId'),
  keyword?: string(name='Keyword'),
  lang?: string(name='Lang'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startTimestamp?: long(name='StartTimestamp'),
}

model DescribeGtmLogsResponseBody = {
  logs?: {
    log?: [ 
    {
      content?: string(name='Content'),
      entityId?: string(name='EntityId'),
      entityName?: string(name='EntityName'),
      entityType?: string(name='EntityType'),
      id?: long(name='Id'),
      operAction?: string(name='OperAction'),
      operIp?: string(name='OperIp'),
      operTime?: string(name='OperTime'),
      operTimestamp?: long(name='OperTimestamp'),
    }
  ](name='Log')
  }(name='Logs'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeGtmLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmLogsResponseBody(name='body'),
}

async function describeGtmLogsWithOptions(request: DescribeGtmLogsRequest, runtime: Util.RuntimeOptions): DescribeGtmLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTimestamp)) {
    query['EndTimestamp'] = request.endTimestamp;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTimestamp)) {
    query['StartTimestamp'] = request.startTimestamp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmLogs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmLogs(request: DescribeGtmLogsRequest): DescribeGtmLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmLogsWithOptions(request, runtime);
}

model DescribeGtmMonitorAvailableConfigRequest {
  lang?: string(name='Lang'),
}

model DescribeGtmMonitorAvailableConfigResponseBody = {
  ispCityNodes?: {
    ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode'),
      cityName?: string(name='CityName'),
      defaultSelected?: boolean(name='DefaultSelected'),
      groupName?: string(name='GroupName'),
      groupType?: string(name='GroupType'),
      ispCode?: string(name='IspCode'),
      ispName?: string(name='IspName'),
      mainland?: boolean(name='Mainland'),
    }
  ](name='IspCityNode')
  }(name='IspCityNodes'),
  requestId?: string(name='RequestId'),
}

model DescribeGtmMonitorAvailableConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmMonitorAvailableConfigResponseBody(name='body'),
}

async function describeGtmMonitorAvailableConfigWithOptions(request: DescribeGtmMonitorAvailableConfigRequest, runtime: Util.RuntimeOptions): DescribeGtmMonitorAvailableConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmMonitorAvailableConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmMonitorAvailableConfig(request: DescribeGtmMonitorAvailableConfigRequest): DescribeGtmMonitorAvailableConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmMonitorAvailableConfigWithOptions(request, runtime);
}

model DescribeGtmMonitorConfigRequest {
  lang?: string(name='Lang'),
  monitorConfigId?: string(name='MonitorConfigId'),
}

model DescribeGtmMonitorConfigResponseBody = {
  createTime?: string(name='CreateTime'),
  createTimestamp?: long(name='CreateTimestamp'),
  evaluationCount?: int32(name='EvaluationCount'),
  interval?: int32(name='Interval'),
  ispCityNodes?: {
    ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode'),
      cityName?: string(name='CityName'),
      countryCode?: string(name='CountryCode'),
      countryName?: string(name='CountryName'),
      ispCode?: string(name='IspCode'),
      ispName?: string(name='IspName'),
    }
  ](name='IspCityNode')
  }(name='IspCityNodes'),
  monitorConfigId?: string(name='MonitorConfigId'),
  monitorExtendInfo?: string(name='MonitorExtendInfo'),
  protocolType?: string(name='ProtocolType'),
  requestId?: string(name='RequestId'),
  timeout?: int32(name='Timeout'),
  updateTime?: string(name='UpdateTime'),
  updateTimestamp?: long(name='UpdateTimestamp'),
}

model DescribeGtmMonitorConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmMonitorConfigResponseBody(name='body'),
}

async function describeGtmMonitorConfigWithOptions(request: DescribeGtmMonitorConfigRequest, runtime: Util.RuntimeOptions): DescribeGtmMonitorConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.monitorConfigId)) {
    query['MonitorConfigId'] = request.monitorConfigId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmMonitorConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmMonitorConfig(request: DescribeGtmMonitorConfigRequest): DescribeGtmMonitorConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmMonitorConfigWithOptions(request, runtime);
}

model DescribeGtmRecoveryPlanRequest {
  lang?: string(name='Lang'),
  recoveryPlanId?: long(name='RecoveryPlanId'),
}

model DescribeGtmRecoveryPlanResponseBody = {
  createTime?: string(name='CreateTime'),
  createTimestamp?: long(name='CreateTimestamp'),
  faultAddrPoolNum?: int32(name='FaultAddrPoolNum'),
  faultAddrPools?: {
    faultAddrPool?: [ 
    {
      addrPoolId?: string(name='AddrPoolId'),
      addrPoolName?: string(name='AddrPoolName'),
      addrs?: {
        addr?: [ 
        {
          id?: long(name='Id'),
          mode?: string(name='Mode'),
          value?: string(name='Value'),
        }
      ](name='Addr')
      }(name='Addrs'),
      instanceId?: string(name='InstanceId'),
    }
  ](name='FaultAddrPool')
  }(name='FaultAddrPools'),
  lastExecuteTime?: string(name='LastExecuteTime'),
  lastExecuteTimestamp?: long(name='LastExecuteTimestamp'),
  lastRollbackTime?: string(name='LastRollbackTime'),
  lastRollbackTimestamp?: long(name='LastRollbackTimestamp'),
  name?: string(name='Name'),
  recoveryPlanId?: long(name='RecoveryPlanId'),
  remark?: string(name='Remark'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  updateTime?: string(name='UpdateTime'),
  updateTimestamp?: long(name='UpdateTimestamp'),
}

model DescribeGtmRecoveryPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmRecoveryPlanResponseBody(name='body'),
}

async function describeGtmRecoveryPlanWithOptions(request: DescribeGtmRecoveryPlanRequest, runtime: Util.RuntimeOptions): DescribeGtmRecoveryPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recoveryPlanId)) {
    query['RecoveryPlanId'] = request.recoveryPlanId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmRecoveryPlan',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmRecoveryPlan(request: DescribeGtmRecoveryPlanRequest): DescribeGtmRecoveryPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmRecoveryPlanWithOptions(request, runtime);
}

model DescribeGtmRecoveryPlanAvailableConfigRequest {
  lang?: string(name='Lang'),
}

model DescribeGtmRecoveryPlanAvailableConfigResponseBody = {
  instances?: {
    instance?: [ 
    {
      addrPools?: {
        addrPool?: [ 
        {
          addrPoolId?: string(name='AddrPoolId'),
          name?: string(name='Name'),
        }
      ](name='AddrPool')
      }(name='AddrPools'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
    }
  ](name='Instance')
  }(name='Instances'),
  requestId?: string(name='RequestId'),
}

model DescribeGtmRecoveryPlanAvailableConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmRecoveryPlanAvailableConfigResponseBody(name='body'),
}

async function describeGtmRecoveryPlanAvailableConfigWithOptions(request: DescribeGtmRecoveryPlanAvailableConfigRequest, runtime: Util.RuntimeOptions): DescribeGtmRecoveryPlanAvailableConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmRecoveryPlanAvailableConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmRecoveryPlanAvailableConfig(request: DescribeGtmRecoveryPlanAvailableConfigRequest): DescribeGtmRecoveryPlanAvailableConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmRecoveryPlanAvailableConfigWithOptions(request, runtime);
}

model DescribeGtmRecoveryPlansRequest {
  keyword?: string(name='Keyword'),
  lang?: string(name='Lang'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeGtmRecoveryPlansResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  recoveryPlans?: {
    recoveryPlan?: [ 
    {
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      faultAddrPoolNum?: int32(name='FaultAddrPoolNum'),
      lastExecuteTime?: string(name='LastExecuteTime'),
      lastExecuteTimestamp?: long(name='LastExecuteTimestamp'),
      lastRollbackTime?: string(name='LastRollbackTime'),
      lastRollbackTimestamp?: long(name='LastRollbackTimestamp'),
      name?: string(name='Name'),
      recoveryPlanId?: long(name='RecoveryPlanId'),
      remark?: string(name='Remark'),
      status?: string(name='Status'),
      updateTime?: string(name='UpdateTime'),
      updateTimestamp?: long(name='UpdateTimestamp'),
    }
  ](name='RecoveryPlan')
  }(name='RecoveryPlans'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeGtmRecoveryPlansResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGtmRecoveryPlansResponseBody(name='body'),
}

async function describeGtmRecoveryPlansWithOptions(request: DescribeGtmRecoveryPlansRequest, runtime: Util.RuntimeOptions): DescribeGtmRecoveryPlansResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmRecoveryPlans',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGtmRecoveryPlans(request: DescribeGtmRecoveryPlansRequest): DescribeGtmRecoveryPlansResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmRecoveryPlansWithOptions(request, runtime);
}

model DescribeInstanceDomainsRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
}

model DescribeInstanceDomainsResponseBody = {
  instanceDomains?: [ 
    {
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      domainName?: string(name='DomainName'),
    }
  ](name='InstanceDomains'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeInstanceDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceDomainsResponseBody(name='body'),
}

async function describeInstanceDomainsWithOptions(request: DescribeInstanceDomainsRequest, runtime: Util.RuntimeOptions): DescribeInstanceDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceDomains',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceDomains(request: DescribeInstanceDomainsRequest): DescribeInstanceDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceDomainsWithOptions(request, runtime);
}

model DescribeIspFlushCacheInstancesRequest {
  direction?: string(name='Direction'),
  isp?: string(name='Isp'),
  keyword?: string(name='Keyword'),
  lang?: string(name='Lang'),
  orderBy?: string(name='OrderBy'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  type?: string(name='Type'),
}

model DescribeIspFlushCacheInstancesResponseBody = {
  ispFlushCacheInstances?: [ 
    {
      expireTime?: string(name='ExpireTime'),
      expireTimestamp?: long(name='ExpireTimestamp'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      isp?: string(name='Isp'),
      quotaInfo?: {
        instanceQuota?: int32(name='InstanceQuota'),
        instanceQuotaUsed?: int32(name='InstanceQuotaUsed'),
      }(name='QuotaInfo'),
      status?: string(name='Status'),
      versionCode?: string(name='VersionCode'),
    }
  ](name='IspFlushCacheInstances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeIspFlushCacheInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIspFlushCacheInstancesResponseBody(name='body'),
}

async function describeIspFlushCacheInstancesWithOptions(request: DescribeIspFlushCacheInstancesRequest, runtime: Util.RuntimeOptions): DescribeIspFlushCacheInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.isp)) {
    query['Isp'] = request.isp;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIspFlushCacheInstances',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIspFlushCacheInstances(request: DescribeIspFlushCacheInstancesRequest): DescribeIspFlushCacheInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIspFlushCacheInstancesWithOptions(request, runtime);
}

model DescribeIspFlushCacheRemainQuotaRequest {
  lang?: string(name='Lang'),
}

model DescribeIspFlushCacheRemainQuotaResponseBody = {
  requestId?: string(name='RequestId'),
  telecomRemainQuota?: int32(name='TelecomRemainQuota'),
}

model DescribeIspFlushCacheRemainQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIspFlushCacheRemainQuotaResponseBody(name='body'),
}

async function describeIspFlushCacheRemainQuotaWithOptions(request: DescribeIspFlushCacheRemainQuotaRequest, runtime: Util.RuntimeOptions): DescribeIspFlushCacheRemainQuotaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIspFlushCacheRemainQuota',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIspFlushCacheRemainQuota(request: DescribeIspFlushCacheRemainQuotaRequest): DescribeIspFlushCacheRemainQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIspFlushCacheRemainQuotaWithOptions(request, runtime);
}

model DescribeIspFlushCacheTaskRequest {
  lang?: string(name='Lang'),
  taskId?: string(name='TaskId'),
}

model DescribeIspFlushCacheTaskResponseBody = {
  createTime?: string(name='CreateTime'),
  createTimestamp?: long(name='CreateTimestamp'),
  domainName?: string(name='DomainName'),
  flushCacheResults?: [ 
    {
      dnsNodes?: [ 
        {
          answers?: [ 
            {
              name?: string(name='Name'),
              record?: string(name='Record'),
              ttl?: long(name='Ttl'),
              type?: string(name='Type'),
            }
          ](name='Answers'),
          nodeIp?: string(name='NodeIp'),
          spName?: string(name='SpName'),
          status?: string(name='Status'),
        }
      ](name='DnsNodes'),
      province?: string(name='Province'),
    }
  ](name='FlushCacheResults'),
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  isp?: string(name='Isp'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
  taskStatus?: string(name='TaskStatus'),
}

model DescribeIspFlushCacheTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIspFlushCacheTaskResponseBody(name='body'),
}

async function describeIspFlushCacheTaskWithOptions(request: DescribeIspFlushCacheTaskRequest, runtime: Util.RuntimeOptions): DescribeIspFlushCacheTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIspFlushCacheTask',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIspFlushCacheTask(request: DescribeIspFlushCacheTaskRequest): DescribeIspFlushCacheTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIspFlushCacheTaskWithOptions(request, runtime);
}

model DescribeIspFlushCacheTasksRequest {
  direction?: string(name='Direction'),
  domainName?: string(name='DomainName'),
  instanceId?: string(name='InstanceId'),
  isp?: string(name='Isp'),
  lang?: string(name='Lang'),
  orderBy?: string(name='OrderBy'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeIspFlushCacheTasksResponseBody = {
  ispFlushCacheTasks?: [ 
    {
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      domainName?: string(name='DomainName'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      isp?: string(name='Isp'),
      taskId?: string(name='TaskId'),
      taskStatus?: string(name='TaskStatus'),
    }
  ](name='IspFlushCacheTasks'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeIspFlushCacheTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIspFlushCacheTasksResponseBody(name='body'),
}

async function describeIspFlushCacheTasksWithOptions(request: DescribeIspFlushCacheTasksRequest, runtime: Util.RuntimeOptions): DescribeIspFlushCacheTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.isp)) {
    query['Isp'] = request.isp;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIspFlushCacheTasks',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIspFlushCacheTasks(request: DescribeIspFlushCacheTasksRequest): DescribeIspFlushCacheTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIspFlushCacheTasksWithOptions(request, runtime);
}

model DescribePdnsAccountSummaryRequest {
  endDate?: string(name='EndDate'),
  lang?: string(name='Lang'),
  startDate?: string(name='StartDate'),
}

model DescribePdnsAccountSummaryResponseBody = {
  data?: {
    domainCount?: long(name='DomainCount'),
    httpCount?: long(name='HttpCount'),
    httpsCount?: long(name='HttpsCount'),
    subDomainCount?: long(name='SubDomainCount'),
    threatCount?: long(name='ThreatCount'),
    totalCount?: long(name='TotalCount'),
    userId?: long(name='UserId'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribePdnsAccountSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePdnsAccountSummaryResponseBody(name='body'),
}

async function describePdnsAccountSummaryWithOptions(request: DescribePdnsAccountSummaryRequest, runtime: Util.RuntimeOptions): DescribePdnsAccountSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsAccountSummary',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePdnsAccountSummary(request: DescribePdnsAccountSummaryRequest): DescribePdnsAccountSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsAccountSummaryWithOptions(request, runtime);
}

model DescribePdnsAppKeyRequest {
  appKeyId?: string(name='AppKeyId'),
  lang?: string(name='Lang'),
}

model DescribePdnsAppKeyResponseBody = {
  appKey?: {
    appKeyId?: string(name='AppKeyId'),
    appKeySecret?: string(name='AppKeySecret'),
    createDate?: string(name='CreateDate'),
    state?: string(name='State'),
  }(name='AppKey'),
  requestId?: string(name='RequestId'),
}

model DescribePdnsAppKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePdnsAppKeyResponseBody(name='body'),
}

async function describePdnsAppKeyWithOptions(request: DescribePdnsAppKeyRequest, runtime: Util.RuntimeOptions): DescribePdnsAppKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appKeyId)) {
    query['AppKeyId'] = request.appKeyId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsAppKey',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePdnsAppKey(request: DescribePdnsAppKeyRequest): DescribePdnsAppKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsAppKeyWithOptions(request, runtime);
}

model DescribePdnsAppKeysRequest {
  lang?: string(name='Lang'),
}

model DescribePdnsAppKeysResponseBody = {
  appKeys?: [ 
    {
      appKeyId?: string(name='AppKeyId'),
      createDate?: string(name='CreateDate'),
      state?: string(name='State'),
    }
  ](name='AppKeys'),
  requestId?: string(name='RequestId'),
}

model DescribePdnsAppKeysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePdnsAppKeysResponseBody(name='body'),
}

async function describePdnsAppKeysWithOptions(request: DescribePdnsAppKeysRequest, runtime: Util.RuntimeOptions): DescribePdnsAppKeysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsAppKeys',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePdnsAppKeys(request: DescribePdnsAppKeysRequest): DescribePdnsAppKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsAppKeysWithOptions(request, runtime);
}

model DescribePdnsOperateLogsRequest {
  actionType?: string(name='ActionType'),
  endDate?: string(name='EndDate'),
  keyword?: string(name='Keyword'),
  lang?: string(name='Lang'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  startDate?: string(name='StartDate'),
}

model DescribePdnsOperateLogsResponseBody = {
  logs?: [ 
    {
      action?: string(name='Action'),
      operateTime?: string(name='OperateTime'),
      type?: string(name='Type'),
      content?: string(name='content'),
    }
  ](name='Logs'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePdnsOperateLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePdnsOperateLogsResponseBody(name='body'),
}

async function describePdnsOperateLogsWithOptions(request: DescribePdnsOperateLogsRequest, runtime: Util.RuntimeOptions): DescribePdnsOperateLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actionType)) {
    query['ActionType'] = request.actionType;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsOperateLogs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePdnsOperateLogs(request: DescribePdnsOperateLogsRequest): DescribePdnsOperateLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsOperateLogsWithOptions(request, runtime);
}

model DescribePdnsRequestStatisticRequest {
  domainName?: string(name='DomainName'),
  endDate?: string(name='EndDate'),
  lang?: string(name='Lang'),
  startDate?: string(name='StartDate'),
  subDomain?: string(name='SubDomain'),
}

model DescribePdnsRequestStatisticResponseBody = {
  data?: [ 
    {
      dohTotalCount?: long(name='DohTotalCount'),
      httpCount?: long(name='HttpCount'),
      httpsCount?: long(name='HttpsCount'),
      ipCount?: long(name='IpCount'),
      timestamp?: long(name='Timestamp'),
      totalCount?: long(name='TotalCount'),
      udpTotalCount?: long(name='UdpTotalCount'),
      v4Count?: long(name='V4Count'),
      v4HttpCount?: long(name='V4HttpCount'),
      v4HttpsCount?: long(name='V4HttpsCount'),
      v6Count?: long(name='V6Count'),
      v6HttpCount?: long(name='V6HttpCount'),
      v6HttpsCount?: long(name='V6HttpsCount'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribePdnsRequestStatisticResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePdnsRequestStatisticResponseBody(name='body'),
}

async function describePdnsRequestStatisticWithOptions(request: DescribePdnsRequestStatisticRequest, runtime: Util.RuntimeOptions): DescribePdnsRequestStatisticResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.subDomain)) {
    query['SubDomain'] = request.subDomain;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsRequestStatistic',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePdnsRequestStatistic(request: DescribePdnsRequestStatisticRequest): DescribePdnsRequestStatisticResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsRequestStatisticWithOptions(request, runtime);
}

model DescribePdnsRequestStatisticsRequest {
  domainName?: string(name='DomainName'),
  endDate?: string(name='EndDate'),
  lang?: string(name='Lang'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  startDate?: string(name='StartDate'),
  subDomain?: string(name='SubDomain'),
  type?: string(name='Type'),
}

model DescribePdnsRequestStatisticsResponseBody = {
  data?: [ 
    {
      dohTotalCount?: long(name='DohTotalCount'),
      domainName?: string(name='DomainName'),
      httpCount?: long(name='HttpCount'),
      httpsCount?: long(name='HttpsCount'),
      ipCount?: long(name='IpCount'),
      maxThreatLevel?: string(name='MaxThreatLevel'),
      subDomain?: string(name='SubDomain'),
      threatCount?: long(name='ThreatCount'),
      threatInfo?: [ 
        {
          threatLevel?: string(name='ThreatLevel'),
          threatType?: string(name='ThreatType'),
        }
      ](name='ThreatInfo'),
      totalCount?: long(name='TotalCount'),
      udpTotalCount?: long(name='UdpTotalCount'),
      v4Count?: long(name='V4Count'),
      v4HttpCount?: long(name='V4HttpCount'),
      v4HttpsCount?: long(name='V4HttpsCount'),
      v6Count?: long(name='V6Count'),
      v6HttpCount?: long(name='V6HttpCount'),
      v6HttpsCount?: long(name='V6HttpsCount'),
    }
  ](name='Data'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePdnsRequestStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePdnsRequestStatisticsResponseBody(name='body'),
}

async function describePdnsRequestStatisticsWithOptions(request: DescribePdnsRequestStatisticsRequest, runtime: Util.RuntimeOptions): DescribePdnsRequestStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.subDomain)) {
    query['SubDomain'] = request.subDomain;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsRequestStatistics',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePdnsRequestStatistics(request: DescribePdnsRequestStatisticsRequest): DescribePdnsRequestStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsRequestStatisticsWithOptions(request, runtime);
}

model DescribePdnsThreatLogsRequest {
  endDate?: string(name='EndDate'),
  keyword?: string(name='Keyword'),
  lang?: string(name='Lang'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  startDate?: string(name='StartDate'),
  threatLevel?: string(name='ThreatLevel'),
  threatSourceIp?: string(name='ThreatSourceIp'),
  threatType?: string(name='ThreatType'),
}

model DescribePdnsThreatLogsResponseBody = {
  logs?: [ 
    {
      sourceIp?: string(name='SourceIp'),
      subDomain?: string(name='SubDomain'),
      threatLevel?: string(name='ThreatLevel'),
      threatTime?: string(name='ThreatTime'),
      threatType?: string(name='ThreatType'),
    }
  ](name='Logs'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePdnsThreatLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePdnsThreatLogsResponseBody(name='body'),
}

async function describePdnsThreatLogsWithOptions(request: DescribePdnsThreatLogsRequest, runtime: Util.RuntimeOptions): DescribePdnsThreatLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.threatLevel)) {
    query['ThreatLevel'] = request.threatLevel;
  }
  if (!Util.isUnset(request.threatSourceIp)) {
    query['ThreatSourceIp'] = request.threatSourceIp;
  }
  if (!Util.isUnset(request.threatType)) {
    query['ThreatType'] = request.threatType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsThreatLogs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePdnsThreatLogs(request: DescribePdnsThreatLogsRequest): DescribePdnsThreatLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsThreatLogsWithOptions(request, runtime);
}

model DescribePdnsThreatStatisticRequest {
  endDate?: string(name='EndDate'),
  lang?: string(name='Lang'),
  startDate?: string(name='StartDate'),
  threatSourceIp?: string(name='ThreatSourceIp'),
}

model DescribePdnsThreatStatisticResponseBody = {
  data?: [ 
    {
      dohTotalCount?: long(name='DohTotalCount'),
      threatLevel?: string(name='ThreatLevel'),
      threatType?: string(name='ThreatType'),
      timestamp?: long(name='Timestamp'),
      totalCount?: long(name='TotalCount'),
      udpTotalCount?: long(name='UdpTotalCount'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribePdnsThreatStatisticResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePdnsThreatStatisticResponseBody(name='body'),
}

async function describePdnsThreatStatisticWithOptions(request: DescribePdnsThreatStatisticRequest, runtime: Util.RuntimeOptions): DescribePdnsThreatStatisticResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.threatSourceIp)) {
    query['ThreatSourceIp'] = request.threatSourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsThreatStatistic',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePdnsThreatStatistic(request: DescribePdnsThreatStatisticRequest): DescribePdnsThreatStatisticResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsThreatStatisticWithOptions(request, runtime);
}

model DescribePdnsThreatStatisticsRequest {
  direction?: string(name='Direction'),
  domainName?: string(name='DomainName'),
  endDate?: string(name='EndDate'),
  lang?: string(name='Lang'),
  orderBy?: string(name='OrderBy'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  startDate?: string(name='StartDate'),
  subDomain?: string(name='SubDomain'),
  threatLevel?: string(name='ThreatLevel'),
  threatSourceIp?: string(name='ThreatSourceIp'),
  threatType?: string(name='ThreatType'),
  type?: string(name='Type'),
}

model DescribePdnsThreatStatisticsResponseBody = {
  data?: [ 
    {
      dohTotalCount?: long(name='DohTotalCount'),
      domainCount?: long(name='DomainCount'),
      domainName?: string(name='DomainName'),
      latestThreatTime?: long(name='LatestThreatTime'),
      maxThreatLevel?: string(name='MaxThreatLevel'),
      sourceIp?: string(name='SourceIp'),
      subDomain?: string(name='SubDomain'),
      threatLevel?: string(name='ThreatLevel'),
      threatType?: string(name='ThreatType'),
      totalCount?: long(name='TotalCount'),
      udpTotalCount?: long(name='UdpTotalCount'),
    }
  ](name='Data'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePdnsThreatStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePdnsThreatStatisticsResponseBody(name='body'),
}

async function describePdnsThreatStatisticsWithOptions(request: DescribePdnsThreatStatisticsRequest, runtime: Util.RuntimeOptions): DescribePdnsThreatStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.subDomain)) {
    query['SubDomain'] = request.subDomain;
  }
  if (!Util.isUnset(request.threatLevel)) {
    query['ThreatLevel'] = request.threatLevel;
  }
  if (!Util.isUnset(request.threatSourceIp)) {
    query['ThreatSourceIp'] = request.threatSourceIp;
  }
  if (!Util.isUnset(request.threatType)) {
    query['ThreatType'] = request.threatType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsThreatStatistics',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePdnsThreatStatistics(request: DescribePdnsThreatStatisticsRequest): DescribePdnsThreatStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsThreatStatisticsWithOptions(request, runtime);
}

model DescribePdnsUdpIpSegmentsRequest {
  lang?: string(name='Lang'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
}

model DescribePdnsUdpIpSegmentsResponseBody = {
  ipSegments?: [ 
    {
      createDate?: string(name='CreateDate'),
      ip?: string(name='Ip'),
      mask?: long(name='Mask'),
      name?: string(name='Name'),
      state?: string(name='State'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='IpSegments'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePdnsUdpIpSegmentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePdnsUdpIpSegmentsResponseBody(name='body'),
}

async function describePdnsUdpIpSegmentsWithOptions(request: DescribePdnsUdpIpSegmentsRequest, runtime: Util.RuntimeOptions): DescribePdnsUdpIpSegmentsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsUdpIpSegments',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePdnsUdpIpSegments(request: DescribePdnsUdpIpSegmentsRequest): DescribePdnsUdpIpSegmentsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsUdpIpSegmentsWithOptions(request, runtime);
}

model DescribePdnsUserInfoRequest {
  lang?: string(name='Lang'),
}

model DescribePdnsUserInfoResponseBody = {
  requestId?: string(name='RequestId'),
  userInfo?: {
    availableService?: string(name='AvailableService'),
    pdnsId?: long(name='PdnsId'),
    serviceType?: string(name='ServiceType'),
    state?: string(name='State'),
    stoppedService?: string(name='StoppedService'),
  }(name='UserInfo'),
}

model DescribePdnsUserInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePdnsUserInfoResponseBody(name='body'),
}

async function describePdnsUserInfoWithOptions(request: DescribePdnsUserInfoRequest, runtime: Util.RuntimeOptions): DescribePdnsUserInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsUserInfo',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePdnsUserInfo(request: DescribePdnsUserInfoRequest): DescribePdnsUserInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsUserInfoWithOptions(request, runtime);
}

model DescribeRecordLogsRequest {
  domainName?: string(name='DomainName'),
  keyWord?: string(name='KeyWord'),
  lang?: string(name='Lang'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  startDate?: string(name='StartDate'),
  userClientIp?: string(name='UserClientIp'),
  endDate?: string(name='endDate'),
}

model DescribeRecordLogsResponseBody = {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  recordLogs?: {
    recordLog?: [ 
    {
      action?: string(name='Action'),
      actionTime?: string(name='ActionTime'),
      actionTimestamp?: long(name='ActionTimestamp'),
      clientIp?: string(name='ClientIp'),
      message?: string(name='Message'),
    }
  ](name='RecordLog')
  }(name='RecordLogs'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeRecordLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRecordLogsResponseBody(name='body'),
}

async function describeRecordLogsWithOptions(request: DescribeRecordLogsRequest, runtime: Util.RuntimeOptions): DescribeRecordLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  if (!Util.isUnset(request.endDate)) {
    query['endDate'] = request.endDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRecordLogs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRecordLogs(request: DescribeRecordLogsRequest): DescribeRecordLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRecordLogsWithOptions(request, runtime);
}

model DescribeRecordStatisticsRequest {
  domainName?: string(name='DomainName'),
  domainType?: string(name='DomainType'),
  endDate?: string(name='EndDate'),
  lang?: string(name='Lang'),
  rr?: string(name='Rr'),
  startDate?: string(name='StartDate'),
}

model DescribeRecordStatisticsResponseBody = {
  requestId?: string(name='RequestId'),
  statistics?: {
    statistic?: [ 
    {
      count?: long(name='Count'),
      timestamp?: long(name='Timestamp'),
    }
  ](name='Statistic')
  }(name='Statistics'),
}

model DescribeRecordStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRecordStatisticsResponseBody(name='body'),
}

async function describeRecordStatisticsWithOptions(request: DescribeRecordStatisticsRequest, runtime: Util.RuntimeOptions): DescribeRecordStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainType)) {
    query['DomainType'] = request.domainType;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.rr)) {
    query['Rr'] = request.rr;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRecordStatistics',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRecordStatistics(request: DescribeRecordStatisticsRequest): DescribeRecordStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRecordStatisticsWithOptions(request, runtime);
}

model DescribeRecordStatisticsSummaryRequest {
  domainName?: string(name='DomainName'),
  domainType?: string(name='DomainType'),
  endDate?: string(name='EndDate'),
  keyword?: string(name='Keyword'),
  lang?: string(name='Lang'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  searchMode?: string(name='SearchMode'),
  startDate?: string(name='StartDate'),
  threshold?: long(name='Threshold'),
}

model DescribeRecordStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  statistics?: {
    statistic?: [ 
    {
      count?: long(name='Count'),
      subDomain?: string(name='SubDomain'),
    }
  ](name='Statistic')
  }(name='Statistics'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeRecordStatisticsSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRecordStatisticsSummaryResponseBody(name='body'),
}

async function describeRecordStatisticsSummaryWithOptions(request: DescribeRecordStatisticsSummaryRequest, runtime: Util.RuntimeOptions): DescribeRecordStatisticsSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainType)) {
    query['DomainType'] = request.domainType;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchMode)) {
    query['SearchMode'] = request.searchMode;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.threshold)) {
    query['Threshold'] = request.threshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRecordStatisticsSummary',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRecordStatisticsSummary(request: DescribeRecordStatisticsSummaryRequest): DescribeRecordStatisticsSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRecordStatisticsSummaryWithOptions(request, runtime);
}

model DescribeSubDomainRecordsRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  line?: string(name='Line'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  subDomain?: string(name='SubDomain'),
  type?: string(name='Type'),
  userClientIp?: string(name='UserClientIp'),
}

model DescribeSubDomainRecordsResponseBody = {
  domainRecords?: {
    record?: [ 
    {
      domainName?: string(name='DomainName'),
      line?: string(name='Line'),
      locked?: boolean(name='Locked'),
      priority?: long(name='Priority'),
      RR?: string(name='RR'),
      recordId?: string(name='RecordId'),
      remark?: string(name='Remark'),
      status?: string(name='Status'),
      TTL?: long(name='TTL'),
      type?: string(name='Type'),
      value?: string(name='Value'),
      weight?: int32(name='Weight'),
    }
  ](name='Record')
  }(name='DomainRecords'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeSubDomainRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSubDomainRecordsResponseBody(name='body'),
}

async function describeSubDomainRecordsWithOptions(request: DescribeSubDomainRecordsRequest, runtime: Util.RuntimeOptions): DescribeSubDomainRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.line)) {
    query['Line'] = request.line;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.subDomain)) {
    query['SubDomain'] = request.subDomain;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSubDomainRecords',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSubDomainRecords(request: DescribeSubDomainRecordsRequest): DescribeSubDomainRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSubDomainRecordsWithOptions(request, runtime);
}

model DescribeSupportLinesRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model DescribeSupportLinesResponseBody = {
  recordLines?: {
    recordLine?: [ 
    {
      fatherCode?: string(name='FatherCode'),
      lineCode?: string(name='LineCode'),
      lineDisplayName?: string(name='LineDisplayName'),
      lineName?: string(name='LineName'),
    }
  ](name='RecordLine')
  }(name='RecordLines'),
  requestId?: string(name='RequestId'),
}

model DescribeSupportLinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSupportLinesResponseBody(name='body'),
}

async function describeSupportLinesWithOptions(request: DescribeSupportLinesRequest, runtime: Util.RuntimeOptions): DescribeSupportLinesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSupportLines',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSupportLines(request: DescribeSupportLinesRequest): DescribeSupportLinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSupportLinesWithOptions(request, runtime);
}

model DescribeTagsRequest {
  lang?: string(name='Lang'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  resourceType?: string(name='ResourceType'),
}

model DescribeTagsResponseBody = {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  tags?: [ 
    {
      key?: string(name='Key'),
      values?: [ string ](name='Values'),
    }
  ](name='Tags'),
  totalCount?: long(name='TotalCount'),
}

model DescribeTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTagsResponseBody(name='body'),
}

async function describeTagsWithOptions(request: DescribeTagsRequest, runtime: Util.RuntimeOptions): DescribeTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTags',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTags(request: DescribeTagsRequest): DescribeTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTagsWithOptions(request, runtime);
}

model DescribeTransferDomainsRequest {
  domainName?: string(name='DomainName'),
  fromUserId?: long(name='FromUserId'),
  lang?: string(name='Lang'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  targetUserId?: long(name='TargetUserId'),
  transferType?: string(name='TransferType'),
}

model DescribeTransferDomainsResponseBody = {
  domainTransfers?: {
    domainTransfer?: [ 
    {
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      domainName?: string(name='DomainName'),
      fromUserId?: long(name='FromUserId'),
      id?: long(name='Id'),
      targetUserId?: long(name='TargetUserId'),
    }
  ](name='DomainTransfer')
  }(name='DomainTransfers'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeTransferDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTransferDomainsResponseBody(name='body'),
}

async function describeTransferDomainsWithOptions(request: DescribeTransferDomainsRequest, runtime: Util.RuntimeOptions): DescribeTransferDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.fromUserId)) {
    query['FromUserId'] = request.fromUserId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.targetUserId)) {
    query['TargetUserId'] = request.targetUserId;
  }
  if (!Util.isUnset(request.transferType)) {
    query['TransferType'] = request.transferType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTransferDomains',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTransferDomains(request: DescribeTransferDomainsRequest): DescribeTransferDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTransferDomainsWithOptions(request, runtime);
}

model ExecuteGtmRecoveryPlanRequest {
  lang?: string(name='Lang'),
  recoveryPlanId?: long(name='RecoveryPlanId'),
}

model ExecuteGtmRecoveryPlanResponseBody = {
  requestId?: string(name='RequestId'),
}

model ExecuteGtmRecoveryPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExecuteGtmRecoveryPlanResponseBody(name='body'),
}

async function executeGtmRecoveryPlanWithOptions(request: ExecuteGtmRecoveryPlanRequest, runtime: Util.RuntimeOptions): ExecuteGtmRecoveryPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recoveryPlanId)) {
    query['RecoveryPlanId'] = request.recoveryPlanId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExecuteGtmRecoveryPlan',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function executeGtmRecoveryPlan(request: ExecuteGtmRecoveryPlanRequest): ExecuteGtmRecoveryPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return executeGtmRecoveryPlanWithOptions(request, runtime);
}

model GetMainDomainNameRequest {
  inputString?: string(name='InputString'),
  lang?: string(name='Lang'),
}

model GetMainDomainNameResponseBody = {
  domainLevel?: long(name='DomainLevel'),
  domainName?: string(name='DomainName'),
  RR?: string(name='RR'),
  requestId?: string(name='RequestId'),
}

model GetMainDomainNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMainDomainNameResponseBody(name='body'),
}

async function getMainDomainNameWithOptions(request: GetMainDomainNameRequest, runtime: Util.RuntimeOptions): GetMainDomainNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.inputString)) {
    query['InputString'] = request.inputString;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMainDomainName',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMainDomainName(request: GetMainDomainNameRequest): GetMainDomainNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMainDomainNameWithOptions(request, runtime);
}

model GetTxtRecordForVerifyRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  type?: string(name='Type'),
}

model GetTxtRecordForVerifyResponseBody = {
  domainName?: string(name='DomainName'),
  RR?: string(name='RR'),
  requestId?: string(name='RequestId'),
  value?: string(name='Value'),
}

model GetTxtRecordForVerifyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTxtRecordForVerifyResponseBody(name='body'),
}

async function getTxtRecordForVerifyWithOptions(request: GetTxtRecordForVerifyRequest, runtime: Util.RuntimeOptions): GetTxtRecordForVerifyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTxtRecordForVerify',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTxtRecordForVerify(request: GetTxtRecordForVerifyRequest): GetTxtRecordForVerifyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTxtRecordForVerifyWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  lang?: string(name='Lang'),
  nextToken?: string(name='NextToken'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ModifyHichinaDomainDNSRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model ModifyHichinaDomainDNSResponseBody = {
  newDnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='NewDnsServers'),
  originalDnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='OriginalDnsServers'),
  requestId?: string(name='RequestId'),
}

model ModifyHichinaDomainDNSResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyHichinaDomainDNSResponseBody(name='body'),
}

async function modifyHichinaDomainDNSWithOptions(request: ModifyHichinaDomainDNSRequest, runtime: Util.RuntimeOptions): ModifyHichinaDomainDNSResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyHichinaDomainDNS',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyHichinaDomainDNS(request: ModifyHichinaDomainDNSRequest): ModifyHichinaDomainDNSResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHichinaDomainDNSWithOptions(request, runtime);
}

model MoveDomainResourceGroupRequest {
  lang?: string(name='Lang'),
  newResourceGroupId?: string(name='NewResourceGroupId'),
  resourceId?: string(name='ResourceId'),
}

model MoveDomainResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model MoveDomainResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MoveDomainResourceGroupResponseBody(name='body'),
}

async function moveDomainResourceGroupWithOptions(request: MoveDomainResourceGroupRequest, runtime: Util.RuntimeOptions): MoveDomainResourceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.newResourceGroupId)) {
    query['NewResourceGroupId'] = request.newResourceGroupId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MoveDomainResourceGroup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function moveDomainResourceGroup(request: MoveDomainResourceGroupRequest): MoveDomainResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return moveDomainResourceGroupWithOptions(request, runtime);
}

model MoveGtmResourceGroupRequest {
  lang?: string(name='Lang'),
  newResourceGroupId?: string(name='NewResourceGroupId'),
  resourceId?: string(name='ResourceId'),
}

model MoveGtmResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model MoveGtmResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MoveGtmResourceGroupResponseBody(name='body'),
}

async function moveGtmResourceGroupWithOptions(request: MoveGtmResourceGroupRequest, runtime: Util.RuntimeOptions): MoveGtmResourceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.newResourceGroupId)) {
    query['NewResourceGroupId'] = request.newResourceGroupId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MoveGtmResourceGroup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function moveGtmResourceGroup(request: MoveGtmResourceGroupRequest): MoveGtmResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return moveGtmResourceGroupWithOptions(request, runtime);
}

model OperateBatchDomainRequest {
  domainRecordInfo?: [ 
    {
      domain?: string(name='Domain'),
      line?: string(name='Line'),
      newRr?: string(name='NewRr'),
      newType?: string(name='NewType'),
      newValue?: string(name='NewValue'),
      priority?: int32(name='Priority'),
      rr?: string(name='Rr'),
      ttl?: int32(name='Ttl'),
      type?: string(name='Type'),
      value?: string(name='Value'),
    }
  ](name='DomainRecordInfo'),
  lang?: string(name='Lang'),
  type?: string(name='Type'),
}

model OperateBatchDomainResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: long(name='TaskId'),
}

model OperateBatchDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OperateBatchDomainResponseBody(name='body'),
}

async function operateBatchDomainWithOptions(request: OperateBatchDomainRequest, runtime: Util.RuntimeOptions): OperateBatchDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainRecordInfo)) {
    query['DomainRecordInfo'] = request.domainRecordInfo;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateBatchDomain',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function operateBatchDomain(request: OperateBatchDomainRequest): OperateBatchDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateBatchDomainWithOptions(request, runtime);
}

model PausePdnsServiceRequest {
  lang?: string(name='Lang'),
  serviceType?: string(name='ServiceType'),
}

model PausePdnsServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model PausePdnsServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PausePdnsServiceResponseBody(name='body'),
}

async function pausePdnsServiceWithOptions(request: PausePdnsServiceRequest, runtime: Util.RuntimeOptions): PausePdnsServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.serviceType)) {
    query['ServiceType'] = request.serviceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PausePdnsService',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pausePdnsService(request: PausePdnsServiceRequest): PausePdnsServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return pausePdnsServiceWithOptions(request, runtime);
}

model PreviewGtmRecoveryPlanRequest {
  lang?: string(name='Lang'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  recoveryPlanId?: long(name='RecoveryPlanId'),
}

model PreviewGtmRecoveryPlanResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  previews?: {
    preview?: [ 
    {
      instanceId?: string(name='InstanceId'),
      name?: string(name='Name'),
      switchInfos?: {
        switchInfo?: [ 
        {
          content?: string(name='Content'),
          strategyName?: string(name='StrategyName'),
        }
      ](name='SwitchInfo')
      }(name='SwitchInfos'),
      userDomainName?: string(name='UserDomainName'),
    }
  ](name='Preview')
  }(name='Previews'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model PreviewGtmRecoveryPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PreviewGtmRecoveryPlanResponseBody(name='body'),
}

async function previewGtmRecoveryPlanWithOptions(request: PreviewGtmRecoveryPlanRequest, runtime: Util.RuntimeOptions): PreviewGtmRecoveryPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.recoveryPlanId)) {
    query['RecoveryPlanId'] = request.recoveryPlanId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PreviewGtmRecoveryPlan',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function previewGtmRecoveryPlan(request: PreviewGtmRecoveryPlanRequest): PreviewGtmRecoveryPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return previewGtmRecoveryPlanWithOptions(request, runtime);
}

model RemovePdnsAppKeyRequest {
  appKeyId?: string(name='AppKeyId'),
  lang?: string(name='Lang'),
}

model RemovePdnsAppKeyResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemovePdnsAppKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemovePdnsAppKeyResponseBody(name='body'),
}

async function removePdnsAppKeyWithOptions(request: RemovePdnsAppKeyRequest, runtime: Util.RuntimeOptions): RemovePdnsAppKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appKeyId)) {
    query['AppKeyId'] = request.appKeyId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemovePdnsAppKey',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removePdnsAppKey(request: RemovePdnsAppKeyRequest): RemovePdnsAppKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return removePdnsAppKeyWithOptions(request, runtime);
}

model RemovePdnsUdpIpSegmentRequest {
  ip?: string(name='Ip'),
  lang?: string(name='Lang'),
}

model RemovePdnsUdpIpSegmentResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemovePdnsUdpIpSegmentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemovePdnsUdpIpSegmentResponseBody(name='body'),
}

async function removePdnsUdpIpSegmentWithOptions(request: RemovePdnsUdpIpSegmentRequest, runtime: Util.RuntimeOptions): RemovePdnsUdpIpSegmentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemovePdnsUdpIpSegment',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removePdnsUdpIpSegment(request: RemovePdnsUdpIpSegmentRequest): RemovePdnsUdpIpSegmentResponse {
  var runtime = new Util.RuntimeOptions{};
  return removePdnsUdpIpSegmentWithOptions(request, runtime);
}

model ResumePdnsServiceRequest {
  lang?: string(name='Lang'),
  serviceType?: string(name='ServiceType'),
}

model ResumePdnsServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResumePdnsServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResumePdnsServiceResponseBody(name='body'),
}

async function resumePdnsServiceWithOptions(request: ResumePdnsServiceRequest, runtime: Util.RuntimeOptions): ResumePdnsServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.serviceType)) {
    query['ServiceType'] = request.serviceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResumePdnsService',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resumePdnsService(request: ResumePdnsServiceRequest): ResumePdnsServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return resumePdnsServiceWithOptions(request, runtime);
}

model RetrieveDomainRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
}

model RetrieveDomainResponseBody = {
  requestId?: string(name='RequestId'),
}

model RetrieveDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RetrieveDomainResponseBody(name='body'),
}

async function retrieveDomainWithOptions(request: RetrieveDomainRequest, runtime: Util.RuntimeOptions): RetrieveDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RetrieveDomain',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function retrieveDomain(request: RetrieveDomainRequest): RetrieveDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return retrieveDomainWithOptions(request, runtime);
}

model RollbackGtmRecoveryPlanRequest {
  lang?: string(name='Lang'),
  recoveryPlanId?: long(name='RecoveryPlanId'),
}

model RollbackGtmRecoveryPlanResponseBody = {
  requestId?: string(name='RequestId'),
}

model RollbackGtmRecoveryPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RollbackGtmRecoveryPlanResponseBody(name='body'),
}

async function rollbackGtmRecoveryPlanWithOptions(request: RollbackGtmRecoveryPlanRequest, runtime: Util.RuntimeOptions): RollbackGtmRecoveryPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recoveryPlanId)) {
    query['RecoveryPlanId'] = request.recoveryPlanId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RollbackGtmRecoveryPlan',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rollbackGtmRecoveryPlan(request: RollbackGtmRecoveryPlanRequest): RollbackGtmRecoveryPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return rollbackGtmRecoveryPlanWithOptions(request, runtime);
}

model SetDNSSLBStatusRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  line?: string(name='Line'),
  open?: boolean(name='Open'),
  subDomain?: string(name='SubDomain'),
  type?: string(name='Type'),
  userClientIp?: string(name='UserClientIp'),
}

model SetDNSSLBStatusResponseBody = {
  open?: boolean(name='Open'),
  recordCount?: long(name='RecordCount'),
  requestId?: string(name='RequestId'),
}

model SetDNSSLBStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDNSSLBStatusResponseBody(name='body'),
}

async function setDNSSLBStatusWithOptions(request: SetDNSSLBStatusRequest, runtime: Util.RuntimeOptions): SetDNSSLBStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.line)) {
    query['Line'] = request.line;
  }
  if (!Util.isUnset(request.open)) {
    query['Open'] = request.open;
  }
  if (!Util.isUnset(request.subDomain)) {
    query['SubDomain'] = request.subDomain;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDNSSLBStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDNSSLBStatus(request: SetDNSSLBStatusRequest): SetDNSSLBStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDNSSLBStatusWithOptions(request, runtime);
}

model SetDnsGtmAccessModeRequest {
  accessMode?: string(name='AccessMode'),
  lang?: string(name='Lang'),
  strategyId?: string(name='StrategyId'),
}

model SetDnsGtmAccessModeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetDnsGtmAccessModeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDnsGtmAccessModeResponseBody(name='body'),
}

async function setDnsGtmAccessModeWithOptions(request: SetDnsGtmAccessModeRequest, runtime: Util.RuntimeOptions): SetDnsGtmAccessModeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessMode)) {
    query['AccessMode'] = request.accessMode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDnsGtmAccessMode',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDnsGtmAccessMode(request: SetDnsGtmAccessModeRequest): SetDnsGtmAccessModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDnsGtmAccessModeWithOptions(request, runtime);
}

model SetDnsGtmMonitorStatusRequest {
  lang?: string(name='Lang'),
  monitorConfigId?: string(name='MonitorConfigId'),
  status?: string(name='Status'),
}

model SetDnsGtmMonitorStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetDnsGtmMonitorStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDnsGtmMonitorStatusResponseBody(name='body'),
}

async function setDnsGtmMonitorStatusWithOptions(request: SetDnsGtmMonitorStatusRequest, runtime: Util.RuntimeOptions): SetDnsGtmMonitorStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.monitorConfigId)) {
    query['MonitorConfigId'] = request.monitorConfigId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDnsGtmMonitorStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDnsGtmMonitorStatus(request: SetDnsGtmMonitorStatusRequest): SetDnsGtmMonitorStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDnsGtmMonitorStatusWithOptions(request, runtime);
}

model SetDomainDnssecStatusRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  status?: string(name='Status'),
}

model SetDomainDnssecStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetDomainDnssecStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDomainDnssecStatusResponseBody(name='body'),
}

async function setDomainDnssecStatusWithOptions(request: SetDomainDnssecStatusRequest, runtime: Util.RuntimeOptions): SetDomainDnssecStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDomainDnssecStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDomainDnssecStatus(request: SetDomainDnssecStatusRequest): SetDomainDnssecStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDomainDnssecStatusWithOptions(request, runtime);
}

model SetDomainRecordStatusRequest {
  lang?: string(name='Lang'),
  recordId?: string(name='RecordId'),
  status?: string(name='Status'),
  userClientIp?: string(name='UserClientIp'),
}

model SetDomainRecordStatusResponseBody = {
  recordId?: string(name='RecordId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model SetDomainRecordStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDomainRecordStatusResponseBody(name='body'),
}

async function setDomainRecordStatusWithOptions(request: SetDomainRecordStatusRequest, runtime: Util.RuntimeOptions): SetDomainRecordStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recordId)) {
    query['RecordId'] = request.recordId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDomainRecordStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDomainRecordStatus(request: SetDomainRecordStatusRequest): SetDomainRecordStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDomainRecordStatusWithOptions(request, runtime);
}

model SetGtmAccessModeRequest {
  accessMode?: string(name='AccessMode'),
  lang?: string(name='Lang'),
  strategyId?: string(name='StrategyId'),
}

model SetGtmAccessModeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetGtmAccessModeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetGtmAccessModeResponseBody(name='body'),
}

async function setGtmAccessModeWithOptions(request: SetGtmAccessModeRequest, runtime: Util.RuntimeOptions): SetGtmAccessModeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessMode)) {
    query['AccessMode'] = request.accessMode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetGtmAccessMode',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setGtmAccessMode(request: SetGtmAccessModeRequest): SetGtmAccessModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setGtmAccessModeWithOptions(request, runtime);
}

model SetGtmMonitorStatusRequest {
  lang?: string(name='Lang'),
  monitorConfigId?: string(name='MonitorConfigId'),
  status?: string(name='Status'),
}

model SetGtmMonitorStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetGtmMonitorStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetGtmMonitorStatusResponseBody(name='body'),
}

async function setGtmMonitorStatusWithOptions(request: SetGtmMonitorStatusRequest, runtime: Util.RuntimeOptions): SetGtmMonitorStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.monitorConfigId)) {
    query['MonitorConfigId'] = request.monitorConfigId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetGtmMonitorStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setGtmMonitorStatus(request: SetGtmMonitorStatusRequest): SetGtmMonitorStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setGtmMonitorStatusWithOptions(request, runtime);
}

model SubmitIspFlushCacheTaskRequest {
  clientToken?: string(name='ClientToken'),
  domainName?: string(name='DomainName'),
  isp?: [ string ](name='Isp'),
  lang?: string(name='Lang'),
}

model SubmitIspFlushCacheTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model SubmitIspFlushCacheTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitIspFlushCacheTaskResponseBody(name='body'),
}

async function submitIspFlushCacheTaskWithOptions(request: SubmitIspFlushCacheTaskRequest, runtime: Util.RuntimeOptions): SubmitIspFlushCacheTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.isp)) {
    query['Isp'] = request.isp;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitIspFlushCacheTask',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitIspFlushCacheTask(request: SubmitIspFlushCacheTaskRequest): SubmitIspFlushCacheTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitIspFlushCacheTaskWithOptions(request, runtime);
}

model SwitchDnsGtmInstanceStrategyModeRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  strategyMode?: string(name='StrategyMode'),
}

model SwitchDnsGtmInstanceStrategyModeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SwitchDnsGtmInstanceStrategyModeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SwitchDnsGtmInstanceStrategyModeResponseBody(name='body'),
}

async function switchDnsGtmInstanceStrategyModeWithOptions(request: SwitchDnsGtmInstanceStrategyModeRequest, runtime: Util.RuntimeOptions): SwitchDnsGtmInstanceStrategyModeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyMode)) {
    query['StrategyMode'] = request.strategyMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SwitchDnsGtmInstanceStrategyMode',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function switchDnsGtmInstanceStrategyMode(request: SwitchDnsGtmInstanceStrategyModeRequest): SwitchDnsGtmInstanceStrategyModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return switchDnsGtmInstanceStrategyModeWithOptions(request, runtime);
}

model TagResourcesRequest {
  lang?: string(name='Lang'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model TransferDomainRequest {
  domainNames?: string(name='DomainNames'),
  lang?: string(name='Lang'),
  remark?: string(name='Remark'),
  targetUserId?: long(name='TargetUserId'),
}

model TransferDomainResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: long(name='TaskId'),
}

model TransferDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TransferDomainResponseBody(name='body'),
}

async function transferDomainWithOptions(request: TransferDomainRequest, runtime: Util.RuntimeOptions): TransferDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainNames)) {
    query['DomainNames'] = request.domainNames;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.targetUserId)) {
    query['TargetUserId'] = request.targetUserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TransferDomain',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function transferDomain(request: TransferDomainRequest): TransferDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return transferDomainWithOptions(request, runtime);
}

model UnbindInstanceDomainsRequest {
  domainNames?: string(name='DomainNames'),
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
}

model UnbindInstanceDomainsResponseBody = {
  failedCount?: int32(name='FailedCount'),
  requestId?: string(name='RequestId'),
  successCount?: int32(name='SuccessCount'),
}

model UnbindInstanceDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnbindInstanceDomainsResponseBody(name='body'),
}

async function unbindInstanceDomainsWithOptions(request: UnbindInstanceDomainsRequest, runtime: Util.RuntimeOptions): UnbindInstanceDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainNames)) {
    query['DomainNames'] = request.domainNames;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnbindInstanceDomains',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unbindInstanceDomains(request: UnbindInstanceDomainsRequest): UnbindInstanceDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindInstanceDomainsWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All'),
  lang?: string(name='Lang'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateAppKeyStateRequest {
  appKeyId?: string(name='AppKeyId'),
  lang?: string(name='Lang'),
  state?: string(name='State'),
}

model UpdateAppKeyStateResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAppKeyStateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAppKeyStateResponseBody(name='body'),
}

async function updateAppKeyStateWithOptions(request: UpdateAppKeyStateRequest, runtime: Util.RuntimeOptions): UpdateAppKeyStateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appKeyId)) {
    query['AppKeyId'] = request.appKeyId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAppKeyState',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAppKeyState(request: UpdateAppKeyStateRequest): UpdateAppKeyStateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAppKeyStateWithOptions(request, runtime);
}

model UpdateCustomLineRequest {
  ipSegment?: [ 
    {
      endIp?: string(name='EndIp'),
      startIp?: string(name='StartIp'),
    }
  ](name='IpSegment'),
  lang?: string(name='Lang'),
  lineId?: long(name='LineId'),
  lineName?: string(name='LineName'),
}

model UpdateCustomLineResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateCustomLineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateCustomLineResponseBody(name='body'),
}

async function updateCustomLineWithOptions(request: UpdateCustomLineRequest, runtime: Util.RuntimeOptions): UpdateCustomLineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ipSegment)) {
    query['IpSegment'] = request.ipSegment;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lineId)) {
    query['LineId'] = request.lineId;
  }
  if (!Util.isUnset(request.lineName)) {
    query['LineName'] = request.lineName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCustomLine',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateCustomLine(request: UpdateCustomLineRequest): UpdateCustomLineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCustomLineWithOptions(request, runtime);
}

model UpdateDNSSLBWeightRequest {
  lang?: string(name='Lang'),
  recordId?: string(name='RecordId'),
  userClientIp?: string(name='UserClientIp'),
  weight?: int32(name='Weight'),
}

model UpdateDNSSLBWeightResponseBody = {
  recordId?: string(name='RecordId'),
  requestId?: string(name='RequestId'),
  weight?: int32(name='Weight'),
}

model UpdateDNSSLBWeightResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDNSSLBWeightResponseBody(name='body'),
}

async function updateDNSSLBWeightWithOptions(request: UpdateDNSSLBWeightRequest, runtime: Util.RuntimeOptions): UpdateDNSSLBWeightResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recordId)) {
    query['RecordId'] = request.recordId;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  if (!Util.isUnset(request.weight)) {
    query['Weight'] = request.weight;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDNSSLBWeight',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDNSSLBWeight(request: UpdateDNSSLBWeightRequest): UpdateDNSSLBWeightResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDNSSLBWeightWithOptions(request, runtime);
}

model UpdateDnsCacheDomainRequest {
  cacheTtlMax?: int32(name='CacheTtlMax'),
  cacheTtlMin?: int32(name='CacheTtlMin'),
  domainName?: string(name='DomainName'),
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  sourceDnsServer?: [ 
    {
      host?: string(name='Host'),
      port?: string(name='Port'),
    }
  ](name='SourceDnsServer'),
  sourceEdns?: string(name='SourceEdns'),
  sourceProtocol?: string(name='SourceProtocol'),
}

model UpdateDnsCacheDomainResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDnsCacheDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDnsCacheDomainResponseBody(name='body'),
}

async function updateDnsCacheDomainWithOptions(request: UpdateDnsCacheDomainRequest, runtime: Util.RuntimeOptions): UpdateDnsCacheDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cacheTtlMax)) {
    query['CacheTtlMax'] = request.cacheTtlMax;
  }
  if (!Util.isUnset(request.cacheTtlMin)) {
    query['CacheTtlMin'] = request.cacheTtlMin;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceDnsServer)) {
    query['SourceDnsServer'] = request.sourceDnsServer;
  }
  if (!Util.isUnset(request.sourceEdns)) {
    query['SourceEdns'] = request.sourceEdns;
  }
  if (!Util.isUnset(request.sourceProtocol)) {
    query['SourceProtocol'] = request.sourceProtocol;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDnsCacheDomain',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDnsCacheDomain(request: UpdateDnsCacheDomainRequest): UpdateDnsCacheDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDnsCacheDomainWithOptions(request, runtime);
}

model UpdateDnsCacheDomainRemarkRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  remark?: string(name='Remark'),
}

model UpdateDnsCacheDomainRemarkResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDnsCacheDomainRemarkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDnsCacheDomainRemarkResponseBody(name='body'),
}

async function updateDnsCacheDomainRemarkWithOptions(request: UpdateDnsCacheDomainRemarkRequest, runtime: Util.RuntimeOptions): UpdateDnsCacheDomainRemarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDnsCacheDomainRemark',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDnsCacheDomainRemark(request: UpdateDnsCacheDomainRemarkRequest): UpdateDnsCacheDomainRemarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDnsCacheDomainRemarkWithOptions(request, runtime);
}

model UpdateDnsGtmAccessStrategyRequest {
  accessMode?: string(name='AccessMode'),
  defaultAddrPool?: [ 
    {
      id?: string(name='Id'),
      lbaWeight?: int32(name='LbaWeight'),
    }
  ](name='DefaultAddrPool'),
  defaultAddrPoolType?: string(name='DefaultAddrPoolType'),
  defaultLatencyOptimization?: string(name='DefaultLatencyOptimization'),
  defaultLbaStrategy?: string(name='DefaultLbaStrategy'),
  defaultMaxReturnAddrNum?: int32(name='DefaultMaxReturnAddrNum'),
  defaultMinAvailableAddrNum?: int32(name='DefaultMinAvailableAddrNum'),
  failoverAddrPool?: [ 
    {
      id?: string(name='Id'),
      lbaWeight?: int32(name='LbaWeight'),
    }
  ](name='FailoverAddrPool'),
  failoverAddrPoolType?: string(name='FailoverAddrPoolType'),
  failoverLatencyOptimization?: string(name='FailoverLatencyOptimization'),
  failoverLbaStrategy?: string(name='FailoverLbaStrategy'),
  failoverMaxReturnAddrNum?: int32(name='FailoverMaxReturnAddrNum'),
  failoverMinAvailableAddrNum?: int32(name='FailoverMinAvailableAddrNum'),
  lang?: string(name='Lang'),
  lines?: string(name='Lines'),
  strategyId?: string(name='StrategyId'),
  strategyName?: string(name='StrategyName'),
}

model UpdateDnsGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId'),
  strategyId?: string(name='StrategyId'),
}

model UpdateDnsGtmAccessStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDnsGtmAccessStrategyResponseBody(name='body'),
}

async function updateDnsGtmAccessStrategyWithOptions(request: UpdateDnsGtmAccessStrategyRequest, runtime: Util.RuntimeOptions): UpdateDnsGtmAccessStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessMode)) {
    query['AccessMode'] = request.accessMode;
  }
  if (!Util.isUnset(request.defaultAddrPool)) {
    query['DefaultAddrPool'] = request.defaultAddrPool;
  }
  if (!Util.isUnset(request.defaultAddrPoolType)) {
    query['DefaultAddrPoolType'] = request.defaultAddrPoolType;
  }
  if (!Util.isUnset(request.defaultLatencyOptimization)) {
    query['DefaultLatencyOptimization'] = request.defaultLatencyOptimization;
  }
  if (!Util.isUnset(request.defaultLbaStrategy)) {
    query['DefaultLbaStrategy'] = request.defaultLbaStrategy;
  }
  if (!Util.isUnset(request.defaultMaxReturnAddrNum)) {
    query['DefaultMaxReturnAddrNum'] = request.defaultMaxReturnAddrNum;
  }
  if (!Util.isUnset(request.defaultMinAvailableAddrNum)) {
    query['DefaultMinAvailableAddrNum'] = request.defaultMinAvailableAddrNum;
  }
  if (!Util.isUnset(request.failoverAddrPool)) {
    query['FailoverAddrPool'] = request.failoverAddrPool;
  }
  if (!Util.isUnset(request.failoverAddrPoolType)) {
    query['FailoverAddrPoolType'] = request.failoverAddrPoolType;
  }
  if (!Util.isUnset(request.failoverLatencyOptimization)) {
    query['FailoverLatencyOptimization'] = request.failoverLatencyOptimization;
  }
  if (!Util.isUnset(request.failoverLbaStrategy)) {
    query['FailoverLbaStrategy'] = request.failoverLbaStrategy;
  }
  if (!Util.isUnset(request.failoverMaxReturnAddrNum)) {
    query['FailoverMaxReturnAddrNum'] = request.failoverMaxReturnAddrNum;
  }
  if (!Util.isUnset(request.failoverMinAvailableAddrNum)) {
    query['FailoverMinAvailableAddrNum'] = request.failoverMinAvailableAddrNum;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lines)) {
    query['Lines'] = request.lines;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  if (!Util.isUnset(request.strategyName)) {
    query['StrategyName'] = request.strategyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDnsGtmAccessStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDnsGtmAccessStrategy(request: UpdateDnsGtmAccessStrategyRequest): UpdateDnsGtmAccessStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDnsGtmAccessStrategyWithOptions(request, runtime);
}

model UpdateDnsGtmAddressPoolRequest {
  addr?: [ 
    {
      addr?: string(name='Addr'),
      attributeInfo?: string(name='AttributeInfo'),
      lbaWeight?: int32(name='LbaWeight'),
      mode?: string(name='Mode'),
      remark?: string(name='Remark'),
    }
  ](name='Addr'),
  addrPoolId?: string(name='AddrPoolId'),
  lang?: string(name='Lang'),
  lbaStrategy?: string(name='LbaStrategy'),
  name?: string(name='Name'),
}

model UpdateDnsGtmAddressPoolResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDnsGtmAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDnsGtmAddressPoolResponseBody(name='body'),
}

async function updateDnsGtmAddressPoolWithOptions(request: UpdateDnsGtmAddressPoolRequest, runtime: Util.RuntimeOptions): UpdateDnsGtmAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addr)) {
    query['Addr'] = request.addr;
  }
  if (!Util.isUnset(request.addrPoolId)) {
    query['AddrPoolId'] = request.addrPoolId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lbaStrategy)) {
    query['LbaStrategy'] = request.lbaStrategy;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDnsGtmAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDnsGtmAddressPool(request: UpdateDnsGtmAddressPoolRequest): UpdateDnsGtmAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDnsGtmAddressPoolWithOptions(request, runtime);
}

model UpdateDnsGtmInstanceGlobalConfigRequest {
  alertConfig?: [ 
    {
      dingtalkNotice?: boolean(name='DingtalkNotice'),
      emailNotice?: boolean(name='EmailNotice'),
      noticeType?: string(name='NoticeType'),
      smsNotice?: boolean(name='SmsNotice'),
    }
  ](name='AlertConfig'),
  alertGroup?: string(name='AlertGroup'),
  cnameType?: string(name='CnameType'),
  forceUpdate?: boolean(name='ForceUpdate'),
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  lang?: string(name='Lang'),
  publicCnameMode?: string(name='PublicCnameMode'),
  publicRr?: string(name='PublicRr'),
  publicUserDomainName?: string(name='PublicUserDomainName'),
  publicZoneName?: string(name='PublicZoneName'),
  ttl?: int32(name='Ttl'),
}

model UpdateDnsGtmInstanceGlobalConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDnsGtmInstanceGlobalConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDnsGtmInstanceGlobalConfigResponseBody(name='body'),
}

async function updateDnsGtmInstanceGlobalConfigWithOptions(request: UpdateDnsGtmInstanceGlobalConfigRequest, runtime: Util.RuntimeOptions): UpdateDnsGtmInstanceGlobalConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertConfig)) {
    query['AlertConfig'] = request.alertConfig;
  }
  if (!Util.isUnset(request.alertGroup)) {
    query['AlertGroup'] = request.alertGroup;
  }
  if (!Util.isUnset(request.cnameType)) {
    query['CnameType'] = request.cnameType;
  }
  if (!Util.isUnset(request.forceUpdate)) {
    query['ForceUpdate'] = request.forceUpdate;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.publicCnameMode)) {
    query['PublicCnameMode'] = request.publicCnameMode;
  }
  if (!Util.isUnset(request.publicRr)) {
    query['PublicRr'] = request.publicRr;
  }
  if (!Util.isUnset(request.publicUserDomainName)) {
    query['PublicUserDomainName'] = request.publicUserDomainName;
  }
  if (!Util.isUnset(request.publicZoneName)) {
    query['PublicZoneName'] = request.publicZoneName;
  }
  if (!Util.isUnset(request.ttl)) {
    query['Ttl'] = request.ttl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDnsGtmInstanceGlobalConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDnsGtmInstanceGlobalConfig(request: UpdateDnsGtmInstanceGlobalConfigRequest): UpdateDnsGtmInstanceGlobalConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDnsGtmInstanceGlobalConfigWithOptions(request, runtime);
}

model UpdateDnsGtmMonitorRequest {
  evaluationCount?: int32(name='EvaluationCount'),
  interval?: int32(name='Interval'),
  ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode'),
      ispCode?: string(name='IspCode'),
    }
  ](name='IspCityNode'),
  lang?: string(name='Lang'),
  monitorConfigId?: string(name='MonitorConfigId'),
  monitorExtendInfo?: string(name='MonitorExtendInfo'),
  protocolType?: string(name='ProtocolType'),
  timeout?: int32(name='Timeout'),
}

model UpdateDnsGtmMonitorResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDnsGtmMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDnsGtmMonitorResponseBody(name='body'),
}

async function updateDnsGtmMonitorWithOptions(request: UpdateDnsGtmMonitorRequest, runtime: Util.RuntimeOptions): UpdateDnsGtmMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispCityNode)) {
    query['IspCityNode'] = request.ispCityNode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.monitorConfigId)) {
    query['MonitorConfigId'] = request.monitorConfigId;
  }
  if (!Util.isUnset(request.monitorExtendInfo)) {
    query['MonitorExtendInfo'] = request.monitorExtendInfo;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDnsGtmMonitor',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDnsGtmMonitor(request: UpdateDnsGtmMonitorRequest): UpdateDnsGtmMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDnsGtmMonitorWithOptions(request, runtime);
}

model UpdateDomainGroupRequest {
  groupId?: string(name='GroupId'),
  groupName?: string(name='GroupName'),
  lang?: string(name='Lang'),
}

model UpdateDomainGroupResponseBody = {
  groupId?: string(name='GroupId'),
  groupName?: string(name='GroupName'),
  requestId?: string(name='RequestId'),
}

model UpdateDomainGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDomainGroupResponseBody(name='body'),
}

async function updateDomainGroupWithOptions(request: UpdateDomainGroupRequest, runtime: Util.RuntimeOptions): UpdateDomainGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDomainGroup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDomainGroup(request: UpdateDomainGroupRequest): UpdateDomainGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDomainGroupWithOptions(request, runtime);
}

model UpdateDomainRecordRequest {
  lang?: string(name='Lang'),
  line?: string(name='Line'),
  priority?: long(name='Priority'),
  RR?: string(name='RR'),
  recordId?: string(name='RecordId'),
  TTL?: long(name='TTL'),
  type?: string(name='Type'),
  userClientIp?: string(name='UserClientIp'),
  value?: string(name='Value'),
}

model UpdateDomainRecordResponseBody = {
  recordId?: string(name='RecordId'),
  requestId?: string(name='RequestId'),
}

model UpdateDomainRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDomainRecordResponseBody(name='body'),
}

async function updateDomainRecordWithOptions(request: UpdateDomainRecordRequest, runtime: Util.RuntimeOptions): UpdateDomainRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.line)) {
    query['Line'] = request.line;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.RR)) {
    query['RR'] = request.RR;
  }
  if (!Util.isUnset(request.recordId)) {
    query['RecordId'] = request.recordId;
  }
  if (!Util.isUnset(request.TTL)) {
    query['TTL'] = request.TTL;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDomainRecord',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDomainRecord(request: UpdateDomainRecordRequest): UpdateDomainRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDomainRecordWithOptions(request, runtime);
}

model UpdateDomainRecordRemarkRequest {
  lang?: string(name='Lang'),
  recordId?: string(name='RecordId'),
  remark?: string(name='Remark'),
  userClientIp?: string(name='UserClientIp'),
}

model UpdateDomainRecordRemarkResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDomainRecordRemarkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDomainRecordRemarkResponseBody(name='body'),
}

async function updateDomainRecordRemarkWithOptions(request: UpdateDomainRecordRemarkRequest, runtime: Util.RuntimeOptions): UpdateDomainRecordRemarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recordId)) {
    query['RecordId'] = request.recordId;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDomainRecordRemark',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDomainRecordRemark(request: UpdateDomainRecordRemarkRequest): UpdateDomainRecordRemarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDomainRecordRemarkWithOptions(request, runtime);
}

model UpdateDomainRemarkRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  remark?: string(name='Remark'),
}

model UpdateDomainRemarkResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDomainRemarkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDomainRemarkResponseBody(name='body'),
}

async function updateDomainRemarkWithOptions(request: UpdateDomainRemarkRequest, runtime: Util.RuntimeOptions): UpdateDomainRemarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDomainRemark',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDomainRemark(request: UpdateDomainRemarkRequest): UpdateDomainRemarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDomainRemarkWithOptions(request, runtime);
}

model UpdateGtmAccessStrategyRequest {
  accessLines?: string(name='AccessLines'),
  defaultAddrPoolId?: string(name='DefaultAddrPoolId'),
  failoverAddrPoolId?: string(name='FailoverAddrPoolId'),
  lang?: string(name='Lang'),
  strategyId?: string(name='StrategyId'),
  strategyName?: string(name='StrategyName'),
}

model UpdateGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateGtmAccessStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGtmAccessStrategyResponseBody(name='body'),
}

async function updateGtmAccessStrategyWithOptions(request: UpdateGtmAccessStrategyRequest, runtime: Util.RuntimeOptions): UpdateGtmAccessStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessLines)) {
    query['AccessLines'] = request.accessLines;
  }
  if (!Util.isUnset(request.defaultAddrPoolId)) {
    query['DefaultAddrPoolId'] = request.defaultAddrPoolId;
  }
  if (!Util.isUnset(request.failoverAddrPoolId)) {
    query['FailoverAddrPoolId'] = request.failoverAddrPoolId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  if (!Util.isUnset(request.strategyName)) {
    query['StrategyName'] = request.strategyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGtmAccessStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGtmAccessStrategy(request: UpdateGtmAccessStrategyRequest): UpdateGtmAccessStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGtmAccessStrategyWithOptions(request, runtime);
}

model UpdateGtmAddressPoolRequest {
  addr?: [ 
    {
      lbaWeight?: int32(name='LbaWeight'),
      mode?: string(name='Mode'),
      value?: string(name='Value'),
    }
  ](name='Addr'),
  addrPoolId?: string(name='AddrPoolId'),
  lang?: string(name='Lang'),
  minAvailableAddrNum?: int32(name='MinAvailableAddrNum'),
  name?: string(name='Name'),
  type?: string(name='Type'),
}

model UpdateGtmAddressPoolResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateGtmAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGtmAddressPoolResponseBody(name='body'),
}

async function updateGtmAddressPoolWithOptions(request: UpdateGtmAddressPoolRequest, runtime: Util.RuntimeOptions): UpdateGtmAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addr)) {
    query['Addr'] = request.addr;
  }
  if (!Util.isUnset(request.addrPoolId)) {
    query['AddrPoolId'] = request.addrPoolId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.minAvailableAddrNum)) {
    query['MinAvailableAddrNum'] = request.minAvailableAddrNum;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGtmAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGtmAddressPool(request: UpdateGtmAddressPoolRequest): UpdateGtmAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGtmAddressPoolWithOptions(request, runtime);
}

model UpdateGtmInstanceGlobalConfigRequest {
  alertGroup?: string(name='AlertGroup'),
  cnameCustomDomainName?: string(name='CnameCustomDomainName'),
  cnameMode?: string(name='CnameMode'),
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  lang?: string(name='Lang'),
  lbaStrategy?: string(name='LbaStrategy'),
  ttl?: int32(name='Ttl'),
  userDomainName?: string(name='UserDomainName'),
}

model UpdateGtmInstanceGlobalConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateGtmInstanceGlobalConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGtmInstanceGlobalConfigResponseBody(name='body'),
}

async function updateGtmInstanceGlobalConfigWithOptions(request: UpdateGtmInstanceGlobalConfigRequest, runtime: Util.RuntimeOptions): UpdateGtmInstanceGlobalConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertGroup)) {
    query['AlertGroup'] = request.alertGroup;
  }
  if (!Util.isUnset(request.cnameCustomDomainName)) {
    query['CnameCustomDomainName'] = request.cnameCustomDomainName;
  }
  if (!Util.isUnset(request.cnameMode)) {
    query['CnameMode'] = request.cnameMode;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lbaStrategy)) {
    query['LbaStrategy'] = request.lbaStrategy;
  }
  if (!Util.isUnset(request.ttl)) {
    query['Ttl'] = request.ttl;
  }
  if (!Util.isUnset(request.userDomainName)) {
    query['UserDomainName'] = request.userDomainName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGtmInstanceGlobalConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGtmInstanceGlobalConfig(request: UpdateGtmInstanceGlobalConfigRequest): UpdateGtmInstanceGlobalConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGtmInstanceGlobalConfigWithOptions(request, runtime);
}

model UpdateGtmMonitorRequest {
  evaluationCount?: int32(name='EvaluationCount'),
  interval?: int32(name='Interval'),
  ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode'),
      ispCode?: string(name='IspCode'),
    }
  ](name='IspCityNode'),
  lang?: string(name='Lang'),
  monitorConfigId?: string(name='MonitorConfigId'),
  monitorExtendInfo?: string(name='MonitorExtendInfo'),
  protocolType?: string(name='ProtocolType'),
  timeout?: int32(name='Timeout'),
}

model UpdateGtmMonitorResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateGtmMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGtmMonitorResponseBody(name='body'),
}

async function updateGtmMonitorWithOptions(request: UpdateGtmMonitorRequest, runtime: Util.RuntimeOptions): UpdateGtmMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispCityNode)) {
    query['IspCityNode'] = request.ispCityNode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.monitorConfigId)) {
    query['MonitorConfigId'] = request.monitorConfigId;
  }
  if (!Util.isUnset(request.monitorExtendInfo)) {
    query['MonitorExtendInfo'] = request.monitorExtendInfo;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGtmMonitor',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGtmMonitor(request: UpdateGtmMonitorRequest): UpdateGtmMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGtmMonitorWithOptions(request, runtime);
}

model UpdateGtmRecoveryPlanRequest {
  faultAddrPool?: string(name='FaultAddrPool'),
  lang?: string(name='Lang'),
  name?: string(name='Name'),
  recoveryPlanId?: long(name='RecoveryPlanId'),
  remark?: string(name='Remark'),
}

model UpdateGtmRecoveryPlanResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateGtmRecoveryPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGtmRecoveryPlanResponseBody(name='body'),
}

async function updateGtmRecoveryPlanWithOptions(request: UpdateGtmRecoveryPlanRequest, runtime: Util.RuntimeOptions): UpdateGtmRecoveryPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.faultAddrPool)) {
    query['FaultAddrPool'] = request.faultAddrPool;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.recoveryPlanId)) {
    query['RecoveryPlanId'] = request.recoveryPlanId;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGtmRecoveryPlan',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGtmRecoveryPlan(request: UpdateGtmRecoveryPlanRequest): UpdateGtmRecoveryPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGtmRecoveryPlanWithOptions(request, runtime);
}

model UpdateIspFlushCacheInstanceConfigRequest {
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  lang?: string(name='Lang'),
}

model UpdateIspFlushCacheInstanceConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIspFlushCacheInstanceConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateIspFlushCacheInstanceConfigResponseBody(name='body'),
}

async function updateIspFlushCacheInstanceConfigWithOptions(request: UpdateIspFlushCacheInstanceConfigRequest, runtime: Util.RuntimeOptions): UpdateIspFlushCacheInstanceConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIspFlushCacheInstanceConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateIspFlushCacheInstanceConfig(request: UpdateIspFlushCacheInstanceConfigRequest): UpdateIspFlushCacheInstanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIspFlushCacheInstanceConfigWithOptions(request, runtime);
}

model ValidateDnsGtmCnameRrCanUseRequest {
  cnameMode?: string(name='CnameMode'),
  cnameRr?: string(name='CnameRr'),
  cnameType?: string(name='CnameType'),
  cnameZone?: string(name='CnameZone'),
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
}

model ValidateDnsGtmCnameRrCanUseResponseBody = {
  requestId?: string(name='RequestId'),
}

model ValidateDnsGtmCnameRrCanUseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ValidateDnsGtmCnameRrCanUseResponseBody(name='body'),
}

async function validateDnsGtmCnameRrCanUseWithOptions(request: ValidateDnsGtmCnameRrCanUseRequest, runtime: Util.RuntimeOptions): ValidateDnsGtmCnameRrCanUseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cnameMode)) {
    query['CnameMode'] = request.cnameMode;
  }
  if (!Util.isUnset(request.cnameRr)) {
    query['CnameRr'] = request.cnameRr;
  }
  if (!Util.isUnset(request.cnameType)) {
    query['CnameType'] = request.cnameType;
  }
  if (!Util.isUnset(request.cnameZone)) {
    query['CnameZone'] = request.cnameZone;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ValidateDnsGtmCnameRrCanUse',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function validateDnsGtmCnameRrCanUse(request: ValidateDnsGtmCnameRrCanUseRequest): ValidateDnsGtmCnameRrCanUseResponse {
  var runtime = new Util.RuntimeOptions{};
  return validateDnsGtmCnameRrCanUseWithOptions(request, runtime);
}

model ValidatePdnsUdpIpSegmentRequest {
  ip?: string(name='Ip'),
  lang?: string(name='Lang'),
}

model ValidatePdnsUdpIpSegmentResponseBody = {
  requestId?: string(name='RequestId'),
}

model ValidatePdnsUdpIpSegmentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ValidatePdnsUdpIpSegmentResponseBody(name='body'),
}

async function validatePdnsUdpIpSegmentWithOptions(request: ValidatePdnsUdpIpSegmentRequest, runtime: Util.RuntimeOptions): ValidatePdnsUdpIpSegmentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ValidatePdnsUdpIpSegment',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function validatePdnsUdpIpSegment(request: ValidatePdnsUdpIpSegmentRequest): ValidatePdnsUdpIpSegmentResponse {
  var runtime = new Util.RuntimeOptions{};
  return validatePdnsUdpIpSegmentWithOptions(request, runtime);
}

