/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('alidns', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddCustomLineRequest {
  domainName?: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.

This parameter is required.', example='example.com'),
  ipSegment?: [ 
    {
      endIp?: string(name='EndIp', description='The end IP address of the CIDR block.', example='192.0.2.254'),
      startIp?: string(name='StartIp', description='The start IP address of the CIDR block.', example='192.0.2.0'),
    }
  ](name='IpSegment', description='The CIDR blocks.

This parameter is required.'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  lineName?: string(name='LineName', description='The name of the custom line.

This parameter is required.'),
}

model AddCustomLineResponseBody = {
  lineCode?: string(name='LineCode', description='The code of the custom line.', example='hra0yc-597'),
  lineId?: long(name='LineId', description='The unique ID of the custom line.', example='597'),
  requestId?: string(name='RequestId', description='The request ID.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
}

model AddCustomLineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddCustomLineResponseBody(name='body'),
}

/**
 * @summary Adds a custom line to the domain name.
 *
 * @description In each CIDR block, the end IP address must be greater than or equal to the start IP address.\\
 * The CIDR blocks that are specified for all custom lines of a domain name cannot be overlapped.
 *
 * @param request AddCustomLineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddCustomLineResponse
 */
async function addCustomLineWithOptions(request: AddCustomLineRequest, runtime: Util.RuntimeOptions): AddCustomLineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ipSegment)) {
    query['IpSegment'] = request.ipSegment;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lineName)) {
    query['LineName'] = request.lineName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddCustomLine',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Adds a custom line to the domain name.
 *
 * @description In each CIDR block, the end IP address must be greater than or equal to the start IP address.\\
 * The CIDR blocks that are specified for all custom lines of a domain name cannot be overlapped.
 *
 * @param request AddCustomLineRequest
 * @return AddCustomLineResponse
 */
async function addCustomLine(request: AddCustomLineRequest): AddCustomLineResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCustomLineWithOptions(request, runtime);
}

model AddDnsCacheDomainRequest {
  cacheTtlMax?: int32(name='CacheTtlMax', description='The maximum TTL period of the cached data retrieved from the origin DNS server. Unit: seconds. Valid values: 30 to 86400.

This parameter is required.', example='86400'),
  cacheTtlMin?: int32(name='CacheTtlMin', description='The minimum time-to-live (TTL) period of the cached data retrieved from the origin Domain Name System (DNS) server. Unit: seconds. Valid values: 30 to 86400.

This parameter is required.', example='30'),
  domainName?: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.

This parameter is required.', example='dns.example.com'),
  instanceId?: string(name='InstanceId', description='The instance ID of the cache-accelerated domain name. You can call the [ListCloudGtmInstances](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-listcloudgtminstances?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the instance ID.

This parameter is required.', example='dns-cn-j6666'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English Default: **zh**', example='en'),
  remark?: string(name='Remark', description='The remarks.', example='test'),
  sourceDnsServer?: [ 
    {
      host?: string(name='Host', description='The domain name or IP address of the origin DNS server.

This parameter is required.', example='192.0.0.0'),
      port?: string(name='Port', description='The port of the origin DNS server.

This parameter is required.', example='53'),
    }
  ](name='SourceDnsServer', description='The origin DNS servers. A maximum of 10 origin DNS servers are supported.

This parameter is required.'),
  sourceEdns?: string(name='SourceEdns', description='Specifies whether the origin DNS server supports Extension Mechanisms for DNS (EDNS). Valid values: NOT_SUPPORT and SUPPORT.

This parameter is required.', example='SUPPORT'),
  sourceProtocol?: string(name='SourceProtocol', description='The origin protocol policy. Valid values: TCP and UDP. Default value: UDP.

This parameter is required.', example='UDP'),
}

model AddDnsCacheDomainResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='B57C121B-A45F-44D8-A9B2-XXXXXXX'),
}

model AddDnsCacheDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddDnsCacheDomainResponseBody(name='body'),
}

/**
 * @summary Adds a cache-accelerated domain name based on the specified parameters.
 *
 * @param request AddDnsCacheDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddDnsCacheDomainResponse
 */
async function addDnsCacheDomainWithOptions(request: AddDnsCacheDomainRequest, runtime: Util.RuntimeOptions): AddDnsCacheDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cacheTtlMax)) {
    query['CacheTtlMax'] = request.cacheTtlMax;
  }
  if (!Util.isUnset(request.cacheTtlMin)) {
    query['CacheTtlMin'] = request.cacheTtlMin;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.sourceDnsServer)) {
    query['SourceDnsServer'] = request.sourceDnsServer;
  }
  if (!Util.isUnset(request.sourceEdns)) {
    query['SourceEdns'] = request.sourceEdns;
  }
  if (!Util.isUnset(request.sourceProtocol)) {
    query['SourceProtocol'] = request.sourceProtocol;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDnsCacheDomain',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Adds a cache-accelerated domain name based on the specified parameters.
 *
 * @param request AddDnsCacheDomainRequest
 * @return AddDnsCacheDomainResponse
 */
async function addDnsCacheDomain(request: AddDnsCacheDomainRequest): AddDnsCacheDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDnsCacheDomainWithOptions(request, runtime);
}

model AddDnsGtmAccessStrategyRequest {
  defaultAddrPool?: [ 
    {
      id?: string(name='Id', description='The ID of the address pool in the primary address pool set.', example='pool1'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool in the primary address pool set.', example='1'),
    }
  ](name='DefaultAddrPool', description='The address pools in the primary address pool set.

This parameter is required.'),
  defaultAddrPoolType?: string(name='DefaultAddrPoolType', description='The type of the primary address pool. Valid values:

*   IPV4
*   IPV6
*   DOMAIN

This parameter is required.', example='ipv4'),
  defaultLatencyOptimization?: string(name='DefaultLatencyOptimization', description='Specifies whether to enable DNS resolution with optimal latency for the primary address pool set. Valid values:

*   OPEN
*   CLOSE', example='open'),
  defaultLbaStrategy?: string(name='DefaultLbaStrategy', description='The load balancing policy of the primary address pool set. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr'),
  defaultMaxReturnAddrNum?: int32(name='DefaultMaxReturnAddrNum', description='The maximum number of addresses returned from the primary address pool set.', example='3'),
  defaultMinAvailableAddrNum?: int32(name='DefaultMinAvailableAddrNum', description='The minimum number of available addresses in the primary address pool set.

This parameter is required.', example='1'),
  failoverAddrPool?: [ 
    {
      id?: string(name='Id', description='The ID of the address pool in the secondary address pool set.', example='pool1'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool in the secondary address pool set.', example='1'),
    }
  ](name='FailoverAddrPool', description='The address pools in the secondary address pool set. If no address pool exists in the secondary address pool set, set this parameter to EMPTY.'),
  failoverAddrPoolType?: string(name='FailoverAddrPoolType', description='The type of the secondary address pool. Valid values:

*   IPV4
*   IPV6
*   DOMAIN', example='ipv4'),
  failoverLatencyOptimization?: string(name='FailoverLatencyOptimization', description='Specifies whether to enable DNS resolution with optimal latency for the secondary address pool set. Valid values:

*   OPEN
*   CLOSE', example='open'),
  failoverLbaStrategy?: string(name='FailoverLbaStrategy', description='The load balancing policy of the secondary address pool set. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr'),
  failoverMaxReturnAddrNum?: int32(name='FailoverMaxReturnAddrNum', description='The maximum number of addresses returned from the secondary address pool set.', example='1'),
  failoverMinAvailableAddrNum?: int32(name='FailoverMinAvailableAddrNum', description='The minimum number of available addresses in the secondary address pool set.', example='1'),
  instanceId?: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='instance1'),
  lang?: string(name='Lang', description='The language of the values for specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  lines?: string(name='Lines', description='The Domain Name System (DNS) request source. For example: `["default", "drpeng"]` indicates Global and Dr. Peng Group.', example='["default", "drpeng"]'),
  strategyMode?: string(name='StrategyMode', description='The type of the access policy. Valid values:

*   GEO: geographical location-based access policy
*   LATENCY: latency-based access policy

This parameter is required.', example='geo'),
  strategyName?: string(name='StrategyName', description='The name of the access policy.

This parameter is required.', example='testStrategyName'),
}

model AddDnsGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy.', example='testStrategyId1'),
}

model AddDnsGtmAccessStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddDnsGtmAccessStrategyResponseBody(name='body'),
}

/**
 * @summary Creates an access policy.
 *
 * @param request AddDnsGtmAccessStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddDnsGtmAccessStrategyResponse
 */
async function addDnsGtmAccessStrategyWithOptions(request: AddDnsGtmAccessStrategyRequest, runtime: Util.RuntimeOptions): AddDnsGtmAccessStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.defaultAddrPool)) {
    query['DefaultAddrPool'] = request.defaultAddrPool;
  }
  if (!Util.isUnset(request.defaultAddrPoolType)) {
    query['DefaultAddrPoolType'] = request.defaultAddrPoolType;
  }
  if (!Util.isUnset(request.defaultLatencyOptimization)) {
    query['DefaultLatencyOptimization'] = request.defaultLatencyOptimization;
  }
  if (!Util.isUnset(request.defaultLbaStrategy)) {
    query['DefaultLbaStrategy'] = request.defaultLbaStrategy;
  }
  if (!Util.isUnset(request.defaultMaxReturnAddrNum)) {
    query['DefaultMaxReturnAddrNum'] = request.defaultMaxReturnAddrNum;
  }
  if (!Util.isUnset(request.defaultMinAvailableAddrNum)) {
    query['DefaultMinAvailableAddrNum'] = request.defaultMinAvailableAddrNum;
  }
  if (!Util.isUnset(request.failoverAddrPool)) {
    query['FailoverAddrPool'] = request.failoverAddrPool;
  }
  if (!Util.isUnset(request.failoverAddrPoolType)) {
    query['FailoverAddrPoolType'] = request.failoverAddrPoolType;
  }
  if (!Util.isUnset(request.failoverLatencyOptimization)) {
    query['FailoverLatencyOptimization'] = request.failoverLatencyOptimization;
  }
  if (!Util.isUnset(request.failoverLbaStrategy)) {
    query['FailoverLbaStrategy'] = request.failoverLbaStrategy;
  }
  if (!Util.isUnset(request.failoverMaxReturnAddrNum)) {
    query['FailoverMaxReturnAddrNum'] = request.failoverMaxReturnAddrNum;
  }
  if (!Util.isUnset(request.failoverMinAvailableAddrNum)) {
    query['FailoverMinAvailableAddrNum'] = request.failoverMinAvailableAddrNum;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lines)) {
    query['Lines'] = request.lines;
  }
  if (!Util.isUnset(request.strategyMode)) {
    query['StrategyMode'] = request.strategyMode;
  }
  if (!Util.isUnset(request.strategyName)) {
    query['StrategyName'] = request.strategyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDnsGtmAccessStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an access policy.
 *
 * @param request AddDnsGtmAccessStrategyRequest
 * @return AddDnsGtmAccessStrategyResponse
 */
async function addDnsGtmAccessStrategy(request: AddDnsGtmAccessStrategyRequest): AddDnsGtmAccessStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDnsGtmAccessStrategyWithOptions(request, runtime);
}

model AddDnsGtmAddressPoolRequest {
  addr?: [ 
    {
      addr?: string(name='Addr', description='The address in the address pool.

This parameter is required.', example='1.1.1.1'),
      attributeInfo?: string(name='AttributeInfo', description='The information about the source region of the address. The value of this parameter is a JSON string. Valid values:

*   lineCode: the line code of the source region for the address

*   lineCodeRectifyType: the rectification type of the line code. Default value: AUTO. Valid values:

    *   NO_NEED: no need for rectification
    *   RECTIFIED: rectified
    *   AUTO: automatic rectification

This parameter is required.', example='default'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address.', example='1'),
      mode?: string(name='Mode', description='The return mode of the addresses: Valid values:

*   SMART: smart return
*   ONLINE: always online
*   OFFLINE: always offline

This parameter is required.', example='online'),
      remark?: string(name='Remark', description='The description of the address pool.', example='test'),
    }
  ](name='Addr', description='The address pools.

This parameter is required.'),
  evaluationCount?: int32(name='EvaluationCount', description='The number of consecutive failures.', example='1'),
  instanceId?: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='instance1'),
  interval?: int32(name='Interval', description='The health check interval. Unit: seconds.', example='1'),
  ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The city code.

Specify the parameter according to the value of CityCode returned by the DescribeGtmMonitorAvailableConfig operation.', example='503'),
      ispCode?: string(name='IspCode', description='*   The Internet service provider (ISP) node. Specify the parameter according to the value of IspCode returned by the DescribeGtmMonitorAvailableConfig operation.
*   If the returned value of GroupType for the DescribeGtmMonitorAvailableConfig operation is BGP or Overseas, IspCode is not required and is set to 465 by default.
*   If the returned value of GroupType for the DescribeGtmMonitorAvailableConfig operation is not BGP or Overseas, IspCode is required. When IspCode is specified, CityCode is required.', example='465'),
    }
  ](name='IspCityNode', description='The nodes for monitoring.'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  lbaStrategy?: string(name='LbaStrategy', description='The load balancing policy of the address pool. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.

This parameter is required.', example='all_rr'),
  monitorExtendInfo?: string(name='MonitorExtendInfo', description='The extended information. The required parameters vary based on the health check protocol.

*   HTTP or HTTPS:

    *   port: the port that you want to check

    *   host: the host settings

    *   path: the URL

    *   code: the return code. The health check result is deemed abnormal if the returned value is greater than the specified value. Valid values: 400 and 500.

    *   failureRate: the failure rate

    *   sni: specifies whether to enable Server Name Indication (SNI). This parameter is available only when ProtocolType is set to HTTPS. Valid values:

        *   true: enables SNI.
        *   other: disables SNI.

    *   nodeType: the type of the node for monitoring when Type is set to DOMAIN. Valid values:

        *   IPV4
        *   IPV6

*   ping:

    *   failureRate: the failure rate

    *   packetNum: the number of ping packets

    *   packetLossRate: the loss rate of ping packets

    *   nodeType: the type of the node for monitoring when Type is set to DOMAIN. Valid values:

        *   IPV4
        *   IPV6

*   TCP:

    *   port: the port that you want to check

    *   failureRate: the failure rate

    *   nodeType: the type of the node for monitoring when Type is set to DOMAIN. Valid values:

        *   IPV4
        *   IPV6', example='{\\\\"code\\\\":200,\\\\"path\\\\":\\\\"\\\\\\\\index.htm\\\\",\\\\"host\\\\":\\\\"aliyun.com\\\\"}'),
  monitorStatus?: string(name='MonitorStatus', description='Specifies whether to enable the health check feature. If you set this parameter to OPEN, the system verifies the health check configurations. If you set this parameter to CLOSE, the system discards the health check configurations. Default value: CLOSE. Valid values:

*   OPEN: enables the health check feature.
*   CLOSE: disables the health check feature.', example='open'),
  name?: string(name='Name', description='The name of the address pool.

This parameter is required.', example='test'),
  protocolType?: string(name='ProtocolType', description='The health check protocol. Valid values:

*   HTTP
*   HTTPS
*   PING
*   TCP', example='http'),
  timeout?: int32(name='Timeout', description='The timeout period. Unit: milliseconds.', example='1'),
  type?: string(name='Type', description='The type of the address pool. Valid values:

*   IPV4: IPv4 address
*   IPV6: IPv6 address
*   DOMAIN: domain name

This parameter is required.', example='ipv4'),
}

model AddDnsGtmAddressPoolResponseBody = {
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.', example='testpool1'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.', example='test1'),
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model AddDnsGtmAddressPoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddDnsGtmAddressPoolResponseBody(name='body'),
}

/**
 * @summary Creates an address pool.
 *
 * @param request AddDnsGtmAddressPoolRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddDnsGtmAddressPoolResponse
 */
async function addDnsGtmAddressPoolWithOptions(request: AddDnsGtmAddressPoolRequest, runtime: Util.RuntimeOptions): AddDnsGtmAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addr)) {
    query['Addr'] = request.addr;
  }
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispCityNode)) {
    query['IspCityNode'] = request.ispCityNode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lbaStrategy)) {
    query['LbaStrategy'] = request.lbaStrategy;
  }
  if (!Util.isUnset(request.monitorExtendInfo)) {
    query['MonitorExtendInfo'] = request.monitorExtendInfo;
  }
  if (!Util.isUnset(request.monitorStatus)) {
    query['MonitorStatus'] = request.monitorStatus;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDnsGtmAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an address pool.
 *
 * @param request AddDnsGtmAddressPoolRequest
 * @return AddDnsGtmAddressPoolResponse
 */
async function addDnsGtmAddressPool(request: AddDnsGtmAddressPoolRequest): AddDnsGtmAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDnsGtmAddressPoolWithOptions(request, runtime);
}

model AddDnsGtmMonitorRequest {
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.

This parameter is required.', example='pool1'),
  evaluationCount?: int32(name='EvaluationCount', description='The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.

This parameter is required.', example='1'),
  interval?: int32(name='Interval', description='The health check interval. Unit: seconds.

This parameter is required.', example='60'),
  ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the city where the monitored node is deployed.', example='123'),
      ispCode?: string(name='IspCode', description='The code of the Internet service provider (ISP) to which the monitored node belongs.', example='123'),
    }
  ](name='IspCityNode', description='The monitored nodes.

This parameter is required.'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  monitorExtendInfo?: string(name='MonitorExtendInfo', description='The extended information. The required parameters vary based on the value of ProtocolType.

*   HTTP or HTTPS

    *   port: the port that you want to check

    *   host: the host settings

    *   path: the URL path

    *   code: the response code. The health check result is deemed abnormal if the returned value is greater than the specified value.

    *   failureRate: the failure rate

    *   sni: specifies whether to enable server name indication (SNI). This parameter is available only when ProtocolType is set to HTTPS. Valid values:

        *   true: enables SNI.
        *   false: disables SNI.

    *   nodeType: the type of the node for monitoring when Type is set to DOMAIN. Valid values:

        *   IPV4
        *   IPV6

*   PING

    *   failureRate: the failure rate

    *   packetNum: the number of ping packets

    *   packetLossRate: the loss rate of ping packets

    *   nodeType: the type of the node for monitoring when Type is set to DOMAIN. Valid values:

        *   IPV4
        *   IPV6

*   TCP

    *   port: the port that you want to check

    *   failureRate: the failure rate

    *   nodeType: the type of the node for monitoring when Type is set to DOMAIN. Valid values:

        *   IPV4
        *   IPV6

This parameter is required.', example='{\\\\"code\\\\":200,\\\\"path\\\\":\\\\"\\\\\\\\index.htm\\\\",\\\\"host\\\\":\\\\"aliyun.com\\\\"}'),
  protocolType?: string(name='ProtocolType', description='The health check protocol. Valid values:

*   HTTP
*   HTTPS
*   PING
*   TCP

This parameter is required.', example='http'),
  timeout?: int32(name='Timeout', description='The timeout period. Unit: milliseconds.

This parameter is required.', example='30000'),
}

model AddDnsGtmMonitorResponseBody = {
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.', example='MonitorConfigId1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model AddDnsGtmMonitorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddDnsGtmMonitorResponseBody(name='body'),
}

/**
 * @summary Creates a health check task.
 *
 * @description ***
 *
 * @param request AddDnsGtmMonitorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddDnsGtmMonitorResponse
 */
async function addDnsGtmMonitorWithOptions(request: AddDnsGtmMonitorRequest, runtime: Util.RuntimeOptions): AddDnsGtmMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addrPoolId)) {
    query['AddrPoolId'] = request.addrPoolId;
  }
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispCityNode)) {
    query['IspCityNode'] = request.ispCityNode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.monitorExtendInfo)) {
    query['MonitorExtendInfo'] = request.monitorExtendInfo;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDnsGtmMonitor',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a health check task.
 *
 * @description ***
 *
 * @param request AddDnsGtmMonitorRequest
 * @return AddDnsGtmMonitorResponse
 */
async function addDnsGtmMonitor(request: AddDnsGtmMonitorRequest): AddDnsGtmMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDnsGtmMonitorWithOptions(request, runtime);
}

model AddDomainRequest {
  domainName?: string(name='DomainName', description='The domain name.

This parameter is required.', example='dns-example.top'),
  groupId?: string(name='GroupId', description='The ID of the group to which the domain name will belong. The default value is the ID of the default group.', example='2223'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en.', example='en'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-resourcegroupid'),
}

model AddDomainResponseBody = {
  dnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='DnsServers', description='The Domain Name System (DNS) servers configured for the domain name.'),
  domainId?: string(name='DomainId', description='The ID of the domain name.', example='00efd71a-770e-4255-b54e-6fe5659baffe'),
  domainName?: string(name='DomainName', description='The domain name.', example='dns-example.top'),
  groupId?: string(name='GroupId', description='The ID of the domain name group.', example='2223'),
  groupName?: string(name='GroupName', description='The name of the domain name group.', example='MyGroup'),
  punyCode?: string(name='PunyCode', description='The Punycode for the domain name. This parameter is returned only for Chinese domain names.', example='xn--fsq270a.com'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model AddDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddDomainResponseBody(name='body'),
}

/**
 * @summary Adds a domain name based on the specified parameters.
 *
 * @description For more information about how to check whether a domain name is valid, see
 * [Domain name validity](https://www.alibabacloud.com/help/zh/doc-detail/67788.htm).
 *
 * @param request AddDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddDomainResponse
 */
async function addDomainWithOptions(request: AddDomainRequest, runtime: Util.RuntimeOptions): AddDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDomain',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Adds a domain name based on the specified parameters.
 *
 * @description For more information about how to check whether a domain name is valid, see
 * [Domain name validity](https://www.alibabacloud.com/help/zh/doc-detail/67788.htm).
 *
 * @param request AddDomainRequest
 * @return AddDomainResponse
 */
async function addDomain(request: AddDomainRequest): AddDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDomainWithOptions(request, runtime);
}

model AddDomainBackupRequest {
  domainName?: string(name='DomainName', description='The domain name.

This parameter is required.', example='test.aliyun.com'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en.', example='en'),
  periodType?: string(name='PeriodType', description='The backup cycle. Valid values:

*   DAY: backs up data on a daily basis.
*   HOUR: backs up data on an hourly basis.

This parameter is required.', example='HOUR'),
}

model AddDomainBackupResponseBody = {
  domainName?: string(name='DomainName', description='The domain name.', example='test.aliyun.com'),
  periodType?: string(name='PeriodType', description='The backup cycle.', example='DAY'),
  requestId?: string(name='RequestId', description='The request ID.', example='FD552816-FCC8-4832-B4A2-2DA0C2BA1688'),
}

model AddDomainBackupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddDomainBackupResponseBody(name='body'),
}

/**
 * @summary Creates a backup task for a domain name.
 *
 * @param request AddDomainBackupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddDomainBackupResponse
 */
async function addDomainBackupWithOptions(request: AddDomainBackupRequest, runtime: Util.RuntimeOptions): AddDomainBackupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.periodType)) {
    query['PeriodType'] = request.periodType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDomainBackup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a backup task for a domain name.
 *
 * @param request AddDomainBackupRequest
 * @return AddDomainBackupResponse
 */
async function addDomainBackup(request: AddDomainBackupRequest): AddDomainBackupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDomainBackupWithOptions(request, runtime);
}

model AddDomainGroupRequest {
  groupName?: string(name='GroupName', description='The name of the domain name group.

This parameter is required.', example='MyGroup'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en.', example='en'),
}

model AddDomainGroupResponseBody = {
  groupId?: string(name='GroupId', description='The ID of the domain name group.', example='2223'),
  groupName?: string(name='GroupName', description='The name of the domain name group.', example='NewName'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model AddDomainGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddDomainGroupResponseBody(name='body'),
}

/**
 * @summary Creates a domain name group based on the specified parameters.
 *
 * @param request AddDomainGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddDomainGroupResponse
 */
async function addDomainGroupWithOptions(request: AddDomainGroupRequest, runtime: Util.RuntimeOptions): AddDomainGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDomainGroup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a domain name group based on the specified parameters.
 *
 * @param request AddDomainGroupRequest
 * @return AddDomainGroupResponse
 */
async function addDomainGroup(request: AddDomainGroupRequest): AddDomainGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDomainGroupWithOptions(request, runtime);
}

model AddDomainRecordRequest {
  domainName?: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.

This parameter is required.', example='example.com'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English Default: **zh**', example='en'),
  line?: string(name='Line', description='The resolution line. Default value: **default**. For more information, see

[DNS resolution lines](https://www.alibabacloud.com/help/zh/doc-detail/29807.htm).', example='default'),
  priority?: long(name='Priority', description='The priority of the mail exchanger (MX) record. Valid values: `1 to 50`.

This parameter is required if the type of the DNS record is MX. A smaller value indicates a higher priority.', example='1'),
  RR?: string(name='RR', description='The hostname.

For example, to resolve @.example.com, you must set this parameter to an at sign (@). You cannot leave this parameter empty.

This parameter is required.', example='www'),
  TTL?: long(name='TTL', description='The time to live (TTL) period of the Alibaba Cloud DNS (DNS) record. Default value: 600. Unit: seconds. For more information, see

[TTL definition](https://www.alibabacloud.com/help/zh/doc-detail/29806.htm).', example='600'),
  type?: string(name='Type', description='The type of the DNS record. For more information, see

[DNS record types](https://www.alibabacloud.com/help/zh/doc-detail/29805.htm).

This parameter is required.', example='A'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0'),
  value?: string(name='Value', description='The value of the DNS record.

This parameter is required.', example='192.0.2.254'),
}

model AddDomainRecordResponseBody = {
  recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model AddDomainRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddDomainRecordResponseBody(name='body'),
}

/**
 * @summary Adds a Domain Name System (DNS) record based on the specified parameters.
 *
 * @param request AddDomainRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddDomainRecordResponse
 */
async function addDomainRecordWithOptions(request: AddDomainRecordRequest, runtime: Util.RuntimeOptions): AddDomainRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.line)) {
    query['Line'] = request.line;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.RR)) {
    query['RR'] = request.RR;
  }
  if (!Util.isUnset(request.TTL)) {
    query['TTL'] = request.TTL;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDomainRecord',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Adds a Domain Name System (DNS) record based on the specified parameters.
 *
 * @param request AddDomainRecordRequest
 * @return AddDomainRecordResponse
 */
async function addDomainRecord(request: AddDomainRecordRequest): AddDomainRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDomainRecordWithOptions(request, runtime);
}

model AddGtmAccessStrategyRequest {
  accessLines?: string(name='AccessLines', description='The line codes of access regions.

This parameter is required.', example='["default", "drpeng"]'),
  defaultAddrPoolId?: string(name='DefaultAddrPoolId', description='The ID of the default address pool.

This parameter is required.', example='hrsix'),
  failoverAddrPoolId?: string(name='FailoverAddrPoolId', description='The ID of the failover address pool.

If the failover address pool is not set, pass the **Empty** value.

This parameter is required.', example='hrsyw'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance for which you want to create an access policy.

This parameter is required.', example='instance1'),
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  strategyName?: string(name='StrategyName', description='The name of the access policy.

This parameter is required.'),
}

model AddGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy created.', example='strategyid'),
}

model AddGtmAccessStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddGtmAccessStrategyResponseBody(name='body'),
}

/**
 * @param request AddGtmAccessStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddGtmAccessStrategyResponse
 */
async function addGtmAccessStrategyWithOptions(request: AddGtmAccessStrategyRequest, runtime: Util.RuntimeOptions): AddGtmAccessStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessLines)) {
    query['AccessLines'] = request.accessLines;
  }
  if (!Util.isUnset(request.defaultAddrPoolId)) {
    query['DefaultAddrPoolId'] = request.defaultAddrPoolId;
  }
  if (!Util.isUnset(request.failoverAddrPoolId)) {
    query['FailoverAddrPoolId'] = request.failoverAddrPoolId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyName)) {
    query['StrategyName'] = request.strategyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGtmAccessStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddGtmAccessStrategyRequest
 * @return AddGtmAccessStrategyResponse
 */
async function addGtmAccessStrategy(request: AddGtmAccessStrategyRequest): AddGtmAccessStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGtmAccessStrategyWithOptions(request, runtime);
}

model AddGtmAddressPoolRequest {
  addr?: [ 
    {
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool.', example='1'),
      mode?: string(name='Mode', description='The mode of the address pool. Valid values:

*   **SMART**: smart return
*   **ONLINE**: always online
*   **OFFLINE**: always offline', example='SMART'),
      value?: string(name='Value', description='The address in the address pool.', example='1.1.1.1'),
    }
  ](name='Addr', description='The address pools.

This parameter is required.'),
  evaluationCount?: int32(name='EvaluationCount', description='The number of consecutive failures.', example='2'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance for which you want to create an address pool.

This parameter is required.', example='gtm-cn-xxxxxxx'),
  interval?: int32(name='Interval', description='The health check interval. Unit: seconds. Set the value to 60.', example='60'),
  ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the city where the monitored node is deployed. For more information about specific values, see the response parameters of DescribeGtmMonitorAvailableConfig.', example='546'),
      ispCode?: string(name='IspCode', description='*   The code of the Internet service provider (ISP) to which the monitored node belongs. For more information about specific values, see the response parameters of DescribeGtmMonitorAvailableConfig.
*   If the value of the GroupType parameter is BGP or OVERSEAS, IspCode is optional. The default value is 465.
*   If the value of the GroupType parameter is not BGP or OVERSEAS, IspCode is required and is used together with CityCode.', example='465'),
    }
  ](name='IspCityNode', description='The monitored nodes.'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters.', example='en'),
  minAvailableAddrNum?: int32(name='MinAvailableAddrNum', description='The minimum number of available addresses in the address pool.

This parameter is required.', example='2'),
  monitorExtendInfo?: string(name='MonitorExtendInfo', description='The extended information. The required parameters vary based on the value of ProtocolType.

When ProtocolType is set to HTTP or HTTPS:

*   port: the port that you want to check
*   failureRate: the failure rate
*   code: the return code. The health check result is deemed abnormal if the returned value is greater than the specified value. Valid values: 400 and 500.
*   host: the host settings
*   path: the URL path

When ProtocolType is set to PING:

*   packetNum: the number of ping packets
*   packetLossRate: the packet loss rate
*   failureRate: the failure rate

When ProtocolType is set to TCP:

*   port: the port that you want to check
*   failureRate: the failure rate', example='{"host":"aliyun.com","port":80}'),
  monitorStatus?: string(name='MonitorStatus', description='Specifies whether to enable the health check. Valid values:

*   **OPEN**: enables the health check.
*   **CLOSE**: disables the health check. This is the default value.', example='OPEN'),
  name?: string(name='Name', description='The name of the address pool.

This parameter is required.', example='Alibaba Cloud cluster'),
  protocolType?: string(name='ProtocolType', description='The health check protocol. Valid values:

*   HTTP
*   HTTPS
*   Ping
*   TCP', example='HTTPS'),
  timeout?: int32(name='Timeout', description='The timeout period. Unit: milliseconds. Valid values: 2000, 3000, 5000, and 10000.', example='60'),
  type?: string(name='Type', description='The type of the address pool. Valid values:

*   **IP**: IPv4 address
*   **DOMAIN**: domain name

This parameter is required.', example='IP'),
}

model AddGtmAddressPoolResponseBody = {
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool created.', example='hraf3x'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.', example='hraf14'),
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model AddGtmAddressPoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddGtmAddressPoolResponseBody(name='body'),
}

/**
 * @summary Creates an address pool.
 *
 * @param request AddGtmAddressPoolRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddGtmAddressPoolResponse
 */
async function addGtmAddressPoolWithOptions(request: AddGtmAddressPoolRequest, runtime: Util.RuntimeOptions): AddGtmAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addr)) {
    query['Addr'] = request.addr;
  }
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispCityNode)) {
    query['IspCityNode'] = request.ispCityNode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.minAvailableAddrNum)) {
    query['MinAvailableAddrNum'] = request.minAvailableAddrNum;
  }
  if (!Util.isUnset(request.monitorExtendInfo)) {
    query['MonitorExtendInfo'] = request.monitorExtendInfo;
  }
  if (!Util.isUnset(request.monitorStatus)) {
    query['MonitorStatus'] = request.monitorStatus;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGtmAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an address pool.
 *
 * @param request AddGtmAddressPoolRequest
 * @return AddGtmAddressPoolResponse
 */
async function addGtmAddressPool(request: AddGtmAddressPoolRequest): AddGtmAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGtmAddressPoolWithOptions(request, runtime);
}

model AddGtmMonitorRequest {
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.

This parameter is required.', example='xxxx'),
  evaluationCount?: int32(name='EvaluationCount', description='The number of consecutive failures.

This parameter is required.', example='3'),
  interval?: int32(name='Interval', description='The health check interval. Unit: seconds. Set the value to 60.

This parameter is required.', example='60'),
  ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The city code.

Specify the parameter according to the value of CityCode returned by the DescribeGtmMonitorAvailableConfig operation.', example='503'),
      ispCode?: string(name='IspCode', description='The Internet service provider (ISP) node. Specify the parameter according to the value of IspCode returned by the DescribeGtmMonitorAvailableConfig operation.

*   If the return value of GroupType for the DescribeGtmMonitorAvailableConfig operation is BGP or Overseas, IspCode is not required and is set to 465 by default.
*   If the return value of GroupType for the DescribeGtmMonitorAvailableConfig operation is not BGP or Overseas, IspCode is required. When IspCode is specified, CityCode is required.', example='465'),
    }
  ](name='IspCityNode', description='The nodes for monitoring.

This parameter is required.'),
  lang?: string(name='Lang', description='The language.', example='en'),
  monitorExtendInfo?: string(name='MonitorExtendInfo', description='The extended information. The required parameters vary based on the health check protocol.

HTTP or HTTPS

*   port: the port that you want to check
*   failureRate: the failure rate
*   code: the return code. The health check result is deemed abnormal if the returned value is greater than the specified value. Valid values: 400 and 500.
*   host: the host settings
*   path: the URL path

PING

*   packetNum: the number of ping packets
*   packetLossRate: the packet loss rate
*   failureRate: the failure rate

TCP

*   port: the port that you want to check
*   failureRate: the failure rate

This parameter is required.', example='{\\\\"code\\\\":200,\\\\"path\\\\":\\\\"/index.htm\\\\",\\\\"host\\\\":\\\\"aliyun.com\\\\"}'),
  protocolType?: string(name='ProtocolType', description='The protocol used for the health check. Valid values:

*   HTTP
*   HTTPS
*   PING
*   TCP

This parameter is required.', example='HTTP'),
  timeout?: int32(name='Timeout', description='The health check timeout period. Unit: milliseconds. Valid values: 2000, 3000, 5000, and 10000.

This parameter is required.', example='3000'),
}

model AddGtmMonitorResponseBody = {
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.', example='1234abc'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model AddGtmMonitorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddGtmMonitorResponseBody(name='body'),
}

/**
 * @summary Creates a health check task.
 *
 * @param request AddGtmMonitorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddGtmMonitorResponse
 */
async function addGtmMonitorWithOptions(request: AddGtmMonitorRequest, runtime: Util.RuntimeOptions): AddGtmMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addrPoolId)) {
    query['AddrPoolId'] = request.addrPoolId;
  }
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispCityNode)) {
    query['IspCityNode'] = request.ispCityNode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.monitorExtendInfo)) {
    query['MonitorExtendInfo'] = request.monitorExtendInfo;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGtmMonitor',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a health check task.
 *
 * @param request AddGtmMonitorRequest
 * @return AddGtmMonitorResponse
 */
async function addGtmMonitor(request: AddGtmMonitorRequest): AddGtmMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGtmMonitorWithOptions(request, runtime);
}

model AddGtmRecoveryPlanRequest {
  faultAddrPool?: string(name='FaultAddrPool', description='The IDs of faulty address pools.

This parameter is required.', example='["hra0or"]'),
  lang?: string(name='Lang', description='The language.', example='en'),
  name?: string(name='Name', description='The name of the disaster recovery plan.

This parameter is required.', example='name-example'),
  remark?: string(name='Remark', description='The description of the disaster recovery plan.', example='remark'),
}

model AddGtmRecoveryPlanResponseBody = {
  recoveryPlanId?: string(name='RecoveryPlanId', description='The ID of the disaster recovery plan.', example='100'),
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model AddGtmRecoveryPlanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddGtmRecoveryPlanResponseBody(name='body'),
}

/**
 * @summary Creates a disaster recovery plan.
 *
 * @param request AddGtmRecoveryPlanRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddGtmRecoveryPlanResponse
 */
async function addGtmRecoveryPlanWithOptions(request: AddGtmRecoveryPlanRequest, runtime: Util.RuntimeOptions): AddGtmRecoveryPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.faultAddrPool)) {
    query['FaultAddrPool'] = request.faultAddrPool;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGtmRecoveryPlan',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a disaster recovery plan.
 *
 * @param request AddGtmRecoveryPlanRequest
 * @return AddGtmRecoveryPlanResponse
 */
async function addGtmRecoveryPlan(request: AddGtmRecoveryPlanRequest): AddGtmRecoveryPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGtmRecoveryPlanWithOptions(request, runtime);
}

model BindInstanceDomainsRequest {
  domainNames?: string(name='DomainNames', description='The domain names.

>  Separate multiple domain names with commas (,). Up to 100 domain names can be entered.

This parameter is required.', example='example.com,example.net'),
  instanceId?: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='sdfasdf'),
  lang?: string(name='Lang', description='The language.', example='en'),
}

model BindInstanceDomainsResponseBody = {
  failedCount?: int32(name='FailedCount', description='The number of domain names that failed to be bound to the instance.', example='0'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  successCount?: int32(name='SuccessCount', description='The number of domain names that are bound to the instance.', example='2'),
}

model BindInstanceDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BindInstanceDomainsResponseBody(name='body'),
}

/**
 * @summary Binds one or more domain names to a paid Alibaba Cloud DNS instance.
 *
 * @description A paid Alibaba Cloud DNS instance whose ID starts with dns is an instance of the new version. You can call this API operation to bind multiple domain names to the instance. If the upper limit is exceeded, an error message is returned.\\
 * A paid Alibaba Cloud DNS instance whose ID does not start with dns is an instance of the old version. You can call this API operation to bind only one domain name to the instance. However, if the instance is already bound to a domain name, you must unbind the original domain name from the instance and bind the desired domain name to the instance.
 *
 * @param request BindInstanceDomainsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BindInstanceDomainsResponse
 */
async function bindInstanceDomainsWithOptions(request: BindInstanceDomainsRequest, runtime: Util.RuntimeOptions): BindInstanceDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainNames)) {
    query['DomainNames'] = request.domainNames;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BindInstanceDomains',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Binds one or more domain names to a paid Alibaba Cloud DNS instance.
 *
 * @description A paid Alibaba Cloud DNS instance whose ID starts with dns is an instance of the new version. You can call this API operation to bind multiple domain names to the instance. If the upper limit is exceeded, an error message is returned.\\
 * A paid Alibaba Cloud DNS instance whose ID does not start with dns is an instance of the old version. You can call this API operation to bind only one domain name to the instance. However, if the instance is already bound to a domain name, you must unbind the original domain name from the instance and bind the desired domain name to the instance.
 *
 * @param request BindInstanceDomainsRequest
 * @return BindInstanceDomainsResponse
 */
async function bindInstanceDomains(request: BindInstanceDomainsRequest): BindInstanceDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindInstanceDomainsWithOptions(request, runtime);
}

model ChangeDomainGroupRequest {
  domainName?: string(name='DomainName', description='The domain name. You can call the [DescribeDomains ](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0)operation to obtain the domain name.

This parameter is required.', example='example.com'),
  groupId?: string(name='GroupId', description='The ID of the target domain name group.

*   If you do not specify GroupId, the domain name belongs to the default group.
*   If you specify an empty string "" for GroupId, the domain name belongs to the default group.
*   If you set GroupId to defaultGroup, the domain name belongs to the default group.
*   If you specify GroupId to another value and the value is verified existent, the value of GroupId for the target domain name is updated. If the value is verified inexistent, the value of GroupId for the target domain name is not updated.', example='2223'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en', example='en'),
}

model ChangeDomainGroupResponseBody = {
  groupId?: string(name='GroupId', description='The ID of the target domain name group.', example='2223'),
  groupName?: string(name='GroupName', description='The name of the destination domain name group.', example='MyGroup'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model ChangeDomainGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeDomainGroupResponseBody(name='body'),
}

/**
 * @summary Moves a domain name from the original group to the new group based on the specified parameters.
 *
 * @description You can specify GroupId to move a domain name to a specific domain name group. You can move the domain name to the group that contains all domain names or the default group.
 *
 * @param request ChangeDomainGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeDomainGroupResponse
 */
async function changeDomainGroupWithOptions(request: ChangeDomainGroupRequest, runtime: Util.RuntimeOptions): ChangeDomainGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeDomainGroup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Moves a domain name from the original group to the new group based on the specified parameters.
 *
 * @description You can specify GroupId to move a domain name to a specific domain name group. You can move the domain name to the group that contains all domain names or the default group.
 *
 * @param request ChangeDomainGroupRequest
 * @return ChangeDomainGroupResponse
 */
async function changeDomainGroup(request: ChangeDomainGroupRequest): ChangeDomainGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeDomainGroupWithOptions(request, runtime);
}

model ChangeDomainOfDnsProductRequest {
  force?: boolean(name='Force', description='Specifies whether to forcibly bind a domain name to the instance. Valid values:

*   **false****: no**
*   **true**: **yes**

Default value: **false**.', example='false'),
  instanceId?: string(name='InstanceId', description='The ID of the Alibaba Cloud Domain Name System (DNS) instance.

You can call the [ListCloudGtmInstances ](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-listcloudgtminstances?spm=a2c63.p38356.help-menu-search-29697.d_0)operation to obtain the ID.

This parameter is required.', example='i-7sb'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English

Default value: **zh**.', example='en'),
  newDomain?: string(name='NewDomain', description='The domain name that you want to bind to the instance. If you leave this parameter empty, the domain name that is bound to the instance is unbound from the instance.', example='newdomain.com'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='1.1.1.1'),
}

model ChangeDomainOfDnsProductResponseBody = {
  originalDomain?: string(name='OriginalDomain', description='The domain name that is originally bound to the instance. If no value is returned for this parameter, the instance is bound to a domain name for the first time.', example='originaldomain.com'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model ChangeDomainOfDnsProductResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeDomainOfDnsProductResponseBody(name='body'),
}

/**
 * @summary Changes the domain name that is bound to an Alibaba Cloud DNS instance.
 *
 * @description *   **You can call this operation regardless of whether the Alibaba Cloud DNS instance is bound to a domain name. You can also call this operation to unbind the domain name from the Alibaba Cloud DNS instance by leaving the NewDomain parameter empty.**
 * *   **This operation applies to instances of the custom edition. To change the domain name that is bound to an Alibaba Cloud DNS instance of Personal Edition, Enterprise Standard Edition, or Enterprise Ultimate Edition, call the BindInstanceDomains operation.
 *
 * @param request ChangeDomainOfDnsProductRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeDomainOfDnsProductResponse
 */
async function changeDomainOfDnsProductWithOptions(request: ChangeDomainOfDnsProductRequest, runtime: Util.RuntimeOptions): ChangeDomainOfDnsProductResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.newDomain)) {
    query['NewDomain'] = request.newDomain;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeDomainOfDnsProduct',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Changes the domain name that is bound to an Alibaba Cloud DNS instance.
 *
 * @description *   **You can call this operation regardless of whether the Alibaba Cloud DNS instance is bound to a domain name. You can also call this operation to unbind the domain name from the Alibaba Cloud DNS instance by leaving the NewDomain parameter empty.**
 * *   **This operation applies to instances of the custom edition. To change the domain name that is bound to an Alibaba Cloud DNS instance of Personal Edition, Enterprise Standard Edition, or Enterprise Ultimate Edition, call the BindInstanceDomains operation.
 *
 * @param request ChangeDomainOfDnsProductRequest
 * @return ChangeDomainOfDnsProductResponse
 */
async function changeDomainOfDnsProduct(request: ChangeDomainOfDnsProductRequest): ChangeDomainOfDnsProductResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeDomainOfDnsProductWithOptions(request, runtime);
}

model CopyGtmConfigRequest {
  copyType?: string(name='CopyType', description='The type of the object that is copied. Only the INSTANCE type is supported.

This parameter is required.', example='INSTANCE'),
  lang?: string(name='Lang', description='The language.', example='en'),
  sourceId?: string(name='SourceId', description='The ID of the source object. Only instance IDs are supported.

This parameter is required.', example='gtm-cn-0pp1j84v60d'),
  targetId?: string(name='TargetId', description='The ID of the target object. Only instance IDs are supported.

This parameter is required.', example='gtm-cn-v0h1gaujg06'),
}

model CopyGtmConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='389DFFA3-77A5-4A9E-BF3D-147C6F98A5BA'),
}

model CopyGtmConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CopyGtmConfigResponseBody(name='body'),
}

/**
 * @summary Copies the configurations of a Global Traffic Manager (GTM) instance.
 *
 * @param request CopyGtmConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CopyGtmConfigResponse
 */
async function copyGtmConfigWithOptions(request: CopyGtmConfigRequest, runtime: Util.RuntimeOptions): CopyGtmConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.copyType)) {
    query['CopyType'] = request.copyType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceId)) {
    query['SourceId'] = request.sourceId;
  }
  if (!Util.isUnset(request.targetId)) {
    query['TargetId'] = request.targetId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CopyGtmConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Copies the configurations of a Global Traffic Manager (GTM) instance.
 *
 * @param request CopyGtmConfigRequest
 * @return CopyGtmConfigResponse
 */
async function copyGtmConfig(request: CopyGtmConfigRequest): CopyGtmConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return copyGtmConfigWithOptions(request, runtime);
}

model CreateCloudGtmAddressRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='zh-CN'),
  address?: string(name='Address', description='IP address or domain name.

This parameter is required.', example='223.5.XX.XX'),
  attributeInfo?: string(name='AttributeInfo', description='Address ownership information.', example=''),
  availableMode?: string(name='AvailableMode', description='The failover mode that is used when address exceptions are identified. Valid values:

*   auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
*   manual: the manual mode. If an address is in the unavailable state, the address is not returned for DNS requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.

This parameter is required.', example='auto'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  enableStatus?: string(name='EnableStatus', description='Indicates the current enabled status of the address:
- enable: Enabled status 
- disable: Disabled status

This parameter is required.', example='enable'),
  healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address. This parameter is required when HealthTasks is specified. Valid values:

*   any_ok: The health check results of at least one health check template are normal.
*   p30_ok: The health check results of at least 30% of health check templates are normal.
*   p50_ok: The health check results of at least 50% of health check templates are normal.
*   p70_ok: The health check results of at least 70% of health check templates are normal.
*   all_ok: The health check results of all health check templates are normal.

This parameter is required.', example='p50_ok'),
  healthTasks?: [ 
    {
      port?: int32(name='Port', description='The service port of the address on which health check tasks are performed. If the ping protocol is used for health checks, the configuration of the service port is not supported.', example='80'),
      templateId?: string(name='TemplateId', description='The ID of the health check template associated with the address.', example='mtp-89518052425100**80'),
    }
  ](name='HealthTasks', description='The health check tasks associated with the address.'),
  manualAvailableStatus?: string(name='ManualAvailableStatus', description='The availability state of the address. This parameter is required when AvailableMode is set to **manual**. Valid values:

*   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
*   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.', example='available'),
  name?: string(name='Name', description='Address name.

This parameter is required.', example='Address-1'),
  remark?: string(name='Remark', description='Remarks.', example='test'),
  type?: string(name='Type', description='Address type:
- IPv4
- IPv6
- domain

This parameter is required.', example='IPv4'),
}

model CreateCloudGtmAddressShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='zh-CN'),
  address?: string(name='Address', description='IP address or domain name.

This parameter is required.', example='223.5.XX.XX'),
  attributeInfo?: string(name='AttributeInfo', description='Address ownership information.', example=''),
  availableMode?: string(name='AvailableMode', description='The failover mode that is used when address exceptions are identified. Valid values:

*   auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
*   manual: the manual mode. If an address is in the unavailable state, the address is not returned for DNS requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.

This parameter is required.', example='auto'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  enableStatus?: string(name='EnableStatus', description='Indicates the current enabled status of the address:
- enable: Enabled status 
- disable: Disabled status

This parameter is required.', example='enable'),
  healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address. This parameter is required when HealthTasks is specified. Valid values:

*   any_ok: The health check results of at least one health check template are normal.
*   p30_ok: The health check results of at least 30% of health check templates are normal.
*   p50_ok: The health check results of at least 50% of health check templates are normal.
*   p70_ok: The health check results of at least 70% of health check templates are normal.
*   all_ok: The health check results of all health check templates are normal.

This parameter is required.', example='p50_ok'),
  healthTasksShrink?: string(name='HealthTasks', description='The health check tasks associated with the address.'),
  manualAvailableStatus?: string(name='ManualAvailableStatus', description='The availability state of the address. This parameter is required when AvailableMode is set to **manual**. Valid values:

*   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
*   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.', example='available'),
  name?: string(name='Name', description='Address name.

This parameter is required.', example='Address-1'),
  remark?: string(name='Remark', description='Remarks.', example='test'),
  type?: string(name='Type', description='Address type:
- IPv4
- IPv6
- domain

This parameter is required.', example='IPv4'),
}

model CreateCloudGtmAddressResponseBody = {
  addressId?: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.', example='addr-8951821811436**192'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='46973D4C-E3E4-4ABA-9190-9A9DE406C7E'),
  success?: boolean(name='Success', description='Indicates whether the address creation operation is successful:
- true: Operation was successful
- false: Operation was failed', example='true'),
}

model CreateCloudGtmAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCloudGtmAddressResponseBody(name='body'),
}

/**
 * @summary Creates an address.
 *
 * @param tmpReq CreateCloudGtmAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCloudGtmAddressResponse
 */
async function createCloudGtmAddressWithOptions(tmpReq: CreateCloudGtmAddressRequest, runtime: Util.RuntimeOptions): CreateCloudGtmAddressResponse {
  Util.validateModel(tmpReq);
  var request = new CreateCloudGtmAddressShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.healthTasks)) {
    request.healthTasksShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.healthTasks, 'HealthTasks', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.attributeInfo)) {
    query['AttributeInfo'] = request.attributeInfo;
  }
  if (!Util.isUnset(request.availableMode)) {
    query['AvailableMode'] = request.availableMode;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.enableStatus)) {
    query['EnableStatus'] = request.enableStatus;
  }
  if (!Util.isUnset(request.healthJudgement)) {
    query['HealthJudgement'] = request.healthJudgement;
  }
  if (!Util.isUnset(request.healthTasksShrink)) {
    query['HealthTasks'] = request.healthTasksShrink;
  }
  if (!Util.isUnset(request.manualAvailableStatus)) {
    query['ManualAvailableStatus'] = request.manualAvailableStatus;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCloudGtmAddress',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an address.
 *
 * @param request CreateCloudGtmAddressRequest
 * @return CreateCloudGtmAddressResponse
 */
async function createCloudGtmAddress(request: CreateCloudGtmAddressRequest): CreateCloudGtmAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCloudGtmAddressWithOptions(request, runtime);
}

model CreateCloudGtmAddressPoolRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  addressPoolName?: string(name='AddressPoolName', description='Address pool name, helping users distinguish the purpose of address pools.', example='Address pool-1'),
  addressPoolType?: string(name='AddressPoolType', description='The type of the address pool. Valid values:

*   IPv4: IPv4 addresses are returned for Domain Name System (DNS) resolution.
*   IPv6: IPv6 addresses are returned for DNS resolution.
*   domain: Domain names are returned for DNS resolution.', example='IPv4'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  enableStatus?: string(name='EnableStatus', description='The enabling state of the address pool. Valid values:

*   enable: The address pool is enabled, and the addresses in the address pool are returned for DNS resolution when the health check results are normal.
*   disable: The address pool is disabled, and the addresses in the address pool are not returned for DNS resolution regardless of whether the health check results are normal or not.', example='enable'),
  healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address pool. Valid values:

*   any_ok: At least one address in the address pool is available.
*   p30_ok: At least 30% of the addresses in the address pool are available.
*   p50_ok: At least 50% of the addresses in the address pool are available.
*   p70_ok: At least 70% of the addresses in the address pool are available.
*   all_ok: All addresses in the address pool are available.', example='any_ok'),
  remark?: string(name='Remark', description='Remarks for the address pool, helping users distinguish the usage scenarios of different address pools.', example='app'),
}

model CreateCloudGtmAddressPoolResponseBody = {
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='46973D4C-E3E4-4ABA-9190-9A9DE406C7E'),
  success?: boolean(name='Success', description='Indicates whether the address pool creation operation was successful:
- true: Operation was successful
- false: Operation was failed', example='true'),
}

model CreateCloudGtmAddressPoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCloudGtmAddressPoolResponseBody(name='body'),
}

/**
 * @summary Creates an address pool.
 *
 * @param request CreateCloudGtmAddressPoolRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCloudGtmAddressPoolResponse
 */
async function createCloudGtmAddressPoolWithOptions(request: CreateCloudGtmAddressPoolRequest, runtime: Util.RuntimeOptions): CreateCloudGtmAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.addressPoolName)) {
    query['AddressPoolName'] = request.addressPoolName;
  }
  if (!Util.isUnset(request.addressPoolType)) {
    query['AddressPoolType'] = request.addressPoolType;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.enableStatus)) {
    query['EnableStatus'] = request.enableStatus;
  }
  if (!Util.isUnset(request.healthJudgement)) {
    query['HealthJudgement'] = request.healthJudgement;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCloudGtmAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an address pool.
 *
 * @param request CreateCloudGtmAddressPoolRequest
 * @return CreateCloudGtmAddressPoolResponse
 */
async function createCloudGtmAddressPool(request: CreateCloudGtmAddressPoolRequest): CreateCloudGtmAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCloudGtmAddressPoolWithOptions(request, runtime);
}

model CreateCloudGtmInstanceConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US: English', example='en-US'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  enableStatus?: string(name='EnableStatus', description='The enabling state of the access domain name. Valid values:

*   enable: The access domain name is enabled and the intelligent scheduling policy of the corresponding GTM instance takes effect.
*   disable: The access domain name is disabled and the intelligent scheduling policy of the corresponding GTM instance is unavailable.', example='enable'),
  instanceId?: string(name='InstanceId', description='The ID of the Global Traffic Manager (GTM) 3.0 instance. This ID uniquely identifies a GTM 3.0 instance.', example='gtm-cn-jmp3qnw**03'),
  remark?: string(name='Remark', description='The description of the access domain name.', example='test'),
  scheduleHostname?: string(name='ScheduleHostname', description='The hostname of the access domain name.', example='www'),
  scheduleRrType?: string(name='ScheduleRrType', description='The type of the Domain Name System (DNS) record configured for the access domain name. Valid values:

*   A: IPv4 address
*   AAAA: IPv6 address
*   CNAME: domain name', example='A'),
  scheduleZoneMode?: string(name='ScheduleZoneMode', description='The configuration mode of the access domain name. Valid values:

*   sys_assign: system allocation. This mode is not supported.
*   custom: custom allocation. You must select a zone within the account to which the instance belongs and enter a hostname to generate an access domain name.', example='custom'),
  scheduleZoneName?: string(name='ScheduleZoneName', description='The name of the parent zone for the access domain name configured in GTM. In most cases, the value of this parameter is the name of a zone hosted by Alibaba Cloud DNS. This zone belongs to the account to which the GTM instance belongs. You can specify the name of a zone or subzone.', example='example.com'),
  ttl?: int32(name='Ttl', description='The global time to live (TTL) period. Unit: seconds. The global TTL period affects how long the DNS records that map the access domain name to the addresses in the address pools are cached in the local DNS servers of Internet service providers (ISPs). You can specify a custom value.', example='30'),
}

model CreateCloudGtmInstanceConfigResponseBody = {
  configId?: boolean(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.', example='config-000**1'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model CreateCloudGtmInstanceConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCloudGtmInstanceConfigResponseBody(name='body'),
}

/**
 * @param request CreateCloudGtmInstanceConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCloudGtmInstanceConfigResponse
 */
async function createCloudGtmInstanceConfigWithOptions(request: CreateCloudGtmInstanceConfigRequest, runtime: Util.RuntimeOptions): CreateCloudGtmInstanceConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.enableStatus)) {
    query['EnableStatus'] = request.enableStatus;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.scheduleHostname)) {
    query['ScheduleHostname'] = request.scheduleHostname;
  }
  if (!Util.isUnset(request.scheduleRrType)) {
    query['ScheduleRrType'] = request.scheduleRrType;
  }
  if (!Util.isUnset(request.scheduleZoneMode)) {
    query['ScheduleZoneMode'] = request.scheduleZoneMode;
  }
  if (!Util.isUnset(request.scheduleZoneName)) {
    query['ScheduleZoneName'] = request.scheduleZoneName;
  }
  if (!Util.isUnset(request.ttl)) {
    query['Ttl'] = request.ttl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCloudGtmInstanceConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateCloudGtmInstanceConfigRequest
 * @return CreateCloudGtmInstanceConfigResponse
 */
async function createCloudGtmInstanceConfig(request: CreateCloudGtmInstanceConfigRequest): CreateCloudGtmInstanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCloudGtmInstanceConfigWithOptions(request, runtime);
}

model CreateCloudGtmMonitorTemplateRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  evaluationCount?: int32(name='EvaluationCount', description='This parameter is required.', example='2'),
  extendInfo?: string(name='ExtendInfo', description='The extended information. The value of this parameter is a JSON string. The required parameters vary based on the health check protocol.

*   HTTP or HTTPS:

    **host**: the Host field of an HTTP or HTTPS request header during an HTTP or HTTPS health check. The parameter value indicates the HTTP website that you want to visit. By default, the value is the primary domain name. You can change the value based on your business requirements.

    **path**: the URL for HTTP or HTTPS health checks. Default value: /.

    **code**: the alert threshold. During an HTTP or HTTPS health check, the system checks whether a web server functions as expected based on the status code that is returned from the web server. If the returned status code is greater than the specified threshold, the corresponding application service address is deemed abnormal. Valid values:

    *   400: specifies an invalid request. If an HTTP or HTTPS request contains invalid request parameters, a web server returns a status code that is greater than 400. You must set path to an exact URL if you set code to 400.
    *   500: specifies a server error. If some exceptions occur on a web server, the web server returns a status code that is greater than 500. This value is used by default.

    **sni**: specifies whether to enable Server Name Indication (SNI). This parameter is used only when the health check protocol is HTTPS. SNI is an extension to the Transport Layer Security (TLS) protocol, which allows a client to specify the host to be connected when the client sends a TLS handshake request. TLS handshakes occur before any data of HTTP requests is sent. Therefore, SNI enables servers to identify the services that clients are attempting to access before certificates are sent. This allows the servers to present correct certificates to the clients. Valid values:

    *   true: enables SNI.
    *   false: disables SNI.

    **followRedirect**: specifies whether to follow 3XX redirects. Valid values:

    *   true: follows 3XX redirects. You are redirected to the destination address if a 3XX status code such as 301, 302, 303, 307, or 308 is returned.
    *   false: does not follow 3XX redirects.

*   ping:

    **packetNum**: the total number of Internet Control Message Protocol (ICMP) packets that are sent to the address for each ping-based health check. Valid values: 20, 50, and 100.

    **packetLossRate**: the ICMP packet loss rate for each ping-based health check. The packet loss rate in a health check can be calculated by using the following formula: Packet loss rate in a health check = (Number of lost packets/Total number of sent ICMP packets)  100%. If the packet loss rate reaches the threshold, an alert is triggered. Valid values: 10, 30, 40, 80, 90, and 100.', example='{\\\\"code\\\\":200,\\\\"path\\\\":\\\\"\\\\\\\\index.htm\\\\",\\\\"host\\\\":\\\\"aliyun.com\\\\"}'),
  failureRate?: int32(name='FailureRate', description='This parameter is required.', example='50'),
  interval?: int32(name='Interval', description='This parameter is required.', example='60'),
  ipVersion?: string(name='IpVersion', description='The IP address type of health check nodes. Valid values:

*   IPv4: You can set IpVersion to IPv4 to perform health checks on IPv4 addresses.
*   IPv6: You can set IpVersion to IPv6 to perform health checks on IPv6 addresses.

This parameter is required.', example='IPv4'),
  ispCityNodes?: [ 
    {
      cityCode?: string(name='CityCode', description='The city code of the health check node.', example='503'),
      ispCode?: string(name='IspCode', description='The Internet service provider (ISP) code of the health check node.', example='465'),
    }
  ](name='IspCityNodes', description='The health check nodes. You can call the [ListCloudGtmMonitorNodes](~~ListCloudGtmMonitorNodes~~) operation to obtain the health check nodes.

This parameter is required.'),
  name?: string(name='Name', description='The name of the health check template. We recommend that you use a name that distinguishes the type of health check protocol used.

This parameter is required.', example='Ping-IPv4'),
  protocol?: string(name='Protocol', description='This parameter is required.', example='ping'),
  timeout?: int32(name='Timeout', description='This parameter is required.', example='5000'),
}

model CreateCloudGtmMonitorTemplateShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  evaluationCount?: int32(name='EvaluationCount', description='This parameter is required.', example='2'),
  extendInfo?: string(name='ExtendInfo', description='The extended information. The value of this parameter is a JSON string. The required parameters vary based on the health check protocol.

*   HTTP or HTTPS:

    **host**: the Host field of an HTTP or HTTPS request header during an HTTP or HTTPS health check. The parameter value indicates the HTTP website that you want to visit. By default, the value is the primary domain name. You can change the value based on your business requirements.

    **path**: the URL for HTTP or HTTPS health checks. Default value: /.

    **code**: the alert threshold. During an HTTP or HTTPS health check, the system checks whether a web server functions as expected based on the status code that is returned from the web server. If the returned status code is greater than the specified threshold, the corresponding application service address is deemed abnormal. Valid values:

    *   400: specifies an invalid request. If an HTTP or HTTPS request contains invalid request parameters, a web server returns a status code that is greater than 400. You must set path to an exact URL if you set code to 400.
    *   500: specifies a server error. If some exceptions occur on a web server, the web server returns a status code that is greater than 500. This value is used by default.

    **sni**: specifies whether to enable Server Name Indication (SNI). This parameter is used only when the health check protocol is HTTPS. SNI is an extension to the Transport Layer Security (TLS) protocol, which allows a client to specify the host to be connected when the client sends a TLS handshake request. TLS handshakes occur before any data of HTTP requests is sent. Therefore, SNI enables servers to identify the services that clients are attempting to access before certificates are sent. This allows the servers to present correct certificates to the clients. Valid values:

    *   true: enables SNI.
    *   false: disables SNI.

    **followRedirect**: specifies whether to follow 3XX redirects. Valid values:

    *   true: follows 3XX redirects. You are redirected to the destination address if a 3XX status code such as 301, 302, 303, 307, or 308 is returned.
    *   false: does not follow 3XX redirects.

*   ping:

    **packetNum**: the total number of Internet Control Message Protocol (ICMP) packets that are sent to the address for each ping-based health check. Valid values: 20, 50, and 100.

    **packetLossRate**: the ICMP packet loss rate for each ping-based health check. The packet loss rate in a health check can be calculated by using the following formula: Packet loss rate in a health check = (Number of lost packets/Total number of sent ICMP packets)  100%. If the packet loss rate reaches the threshold, an alert is triggered. Valid values: 10, 30, 40, 80, 90, and 100.', example='{\\\\"code\\\\":200,\\\\"path\\\\":\\\\"\\\\\\\\index.htm\\\\",\\\\"host\\\\":\\\\"aliyun.com\\\\"}'),
  failureRate?: int32(name='FailureRate', description='This parameter is required.', example='50'),
  interval?: int32(name='Interval', description='This parameter is required.', example='60'),
  ipVersion?: string(name='IpVersion', description='The IP address type of health check nodes. Valid values:

*   IPv4: You can set IpVersion to IPv4 to perform health checks on IPv4 addresses.
*   IPv6: You can set IpVersion to IPv6 to perform health checks on IPv6 addresses.

This parameter is required.', example='IPv4'),
  ispCityNodesShrink?: string(name='IspCityNodes', description='The health check nodes. You can call the [ListCloudGtmMonitorNodes](~~ListCloudGtmMonitorNodes~~) operation to obtain the health check nodes.

This parameter is required.'),
  name?: string(name='Name', description='The name of the health check template. We recommend that you use a name that distinguishes the type of health check protocol used.

This parameter is required.', example='Ping-IPv4'),
  protocol?: string(name='Protocol', description='This parameter is required.', example='ping'),
  timeout?: int32(name='Timeout', description='This parameter is required.', example='5000'),
}

model CreateCloudGtmMonitorTemplateResponseBody = {
  requestId?: string(name='RequestId', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
  success?: boolean(name='Success', example='true'),
  templateId?: string(name='TemplateId', description='The ID of the health check template. This ID uniquely identifies the health check template.', example='mtp-89518052425100**80'),
}

model CreateCloudGtmMonitorTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCloudGtmMonitorTemplateResponseBody(name='body'),
}

/**
 * @summary Creates a health check template.
 *
 * @param tmpReq CreateCloudGtmMonitorTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCloudGtmMonitorTemplateResponse
 */
async function createCloudGtmMonitorTemplateWithOptions(tmpReq: CreateCloudGtmMonitorTemplateRequest, runtime: Util.RuntimeOptions): CreateCloudGtmMonitorTemplateResponse {
  Util.validateModel(tmpReq);
  var request = new CreateCloudGtmMonitorTemplateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.ispCityNodes)) {
    request.ispCityNodesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ispCityNodes, 'IspCityNodes', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.extendInfo)) {
    query['ExtendInfo'] = request.extendInfo;
  }
  if (!Util.isUnset(request.failureRate)) {
    query['FailureRate'] = request.failureRate;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ipVersion)) {
    query['IpVersion'] = request.ipVersion;
  }
  if (!Util.isUnset(request.ispCityNodesShrink)) {
    query['IspCityNodes'] = request.ispCityNodesShrink;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.protocol)) {
    query['Protocol'] = request.protocol;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCloudGtmMonitorTemplate',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a health check template.
 *
 * @param request CreateCloudGtmMonitorTemplateRequest
 * @return CreateCloudGtmMonitorTemplateResponse
 */
async function createCloudGtmMonitorTemplate(request: CreateCloudGtmMonitorTemplateRequest): CreateCloudGtmMonitorTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCloudGtmMonitorTemplateWithOptions(request, runtime);
}

model CreatePdnsAppKeyRequest {
  lang?: string(name='Lang'),
  remark?: string(name='Remark'),
}

model CreatePdnsAppKeyResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreatePdnsAppKeyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePdnsAppKeyResponseBody(name='body'),
}

/**
 * @summary DNS AppKey
 *
 * @param request CreatePdnsAppKeyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePdnsAppKeyResponse
 */
async function createPdnsAppKeyWithOptions(request: CreatePdnsAppKeyRequest, runtime: Util.RuntimeOptions): CreatePdnsAppKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePdnsAppKey',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DNS AppKey
 *
 * @param request CreatePdnsAppKeyRequest
 * @return CreatePdnsAppKeyResponse
 */
async function createPdnsAppKey(request: CreatePdnsAppKeyRequest): CreatePdnsAppKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPdnsAppKeyWithOptions(request, runtime);
}

model CreatePdnsUdpIpSegmentRequest {
  ip?: string(name='Ip'),
  ipToken?: string(name='IpToken'),
  lang?: string(name='Lang'),
  name?: string(name='Name'),
}

model CreatePdnsUdpIpSegmentResponseBody = {
  requestId?: string(name='RequestId'),
  validMessage?: string(name='ValidMessage'),
}

model CreatePdnsUdpIpSegmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePdnsUdpIpSegmentResponseBody(name='body'),
}

/**
 * @summary DNS Udp Ip
 *
 * @param request CreatePdnsUdpIpSegmentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePdnsUdpIpSegmentResponse
 */
async function createPdnsUdpIpSegmentWithOptions(request: CreatePdnsUdpIpSegmentRequest, runtime: Util.RuntimeOptions): CreatePdnsUdpIpSegmentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.ipToken)) {
    query['IpToken'] = request.ipToken;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePdnsUdpIpSegment',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DNS Udp Ip
 *
 * @param request CreatePdnsUdpIpSegmentRequest
 * @return CreatePdnsUdpIpSegmentResponse
 */
async function createPdnsUdpIpSegment(request: CreatePdnsUdpIpSegmentRequest): CreatePdnsUdpIpSegmentResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPdnsUdpIpSegmentWithOptions(request, runtime);
}

model DeleteCloudGtmAddressRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  addressId?: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.

This parameter is required.', example='addr-895182181143688192'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
}

model DeleteCloudGtmAddressResponseBody = {
  requestId?: string(name='RequestId', description='Unique request identification code.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  success?: boolean(name='Success', description='Indicates whether the address deletion operation was successful:
- true: Operation successful
- false: Operation failed', example='true'),
}

model DeleteCloudGtmAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCloudGtmAddressResponseBody(name='body'),
}

/**
 * @summary Deletes an address.
 *
 * @param request DeleteCloudGtmAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCloudGtmAddressResponse
 */
async function deleteCloudGtmAddressWithOptions(request: DeleteCloudGtmAddressRequest, runtime: Util.RuntimeOptions): DeleteCloudGtmAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.addressId)) {
    query['AddressId'] = request.addressId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCloudGtmAddress',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an address.
 *
 * @param request DeleteCloudGtmAddressRequest
 * @return DeleteCloudGtmAddressResponse
 */
async function deleteCloudGtmAddress(request: DeleteCloudGtmAddressRequest): DeleteCloudGtmAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCloudGtmAddressWithOptions(request, runtime);
}

model DeleteCloudGtmAddressPoolRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
}

model DeleteCloudGtmAddressPoolResponseBody = {
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
  requestId?: string(name='RequestId', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  success?: boolean(name='Success', example='true'),
}

model DeleteCloudGtmAddressPoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCloudGtmAddressPoolResponseBody(name='body'),
}

/**
 * @summary Deletes an address pool.
 *
 * @param request DeleteCloudGtmAddressPoolRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCloudGtmAddressPoolResponse
 */
async function deleteCloudGtmAddressPoolWithOptions(request: DeleteCloudGtmAddressPoolRequest, runtime: Util.RuntimeOptions): DeleteCloudGtmAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.addressPoolId)) {
    query['AddressPoolId'] = request.addressPoolId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCloudGtmAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an address pool.
 *
 * @param request DeleteCloudGtmAddressPoolRequest
 * @return DeleteCloudGtmAddressPoolResponse
 */
async function deleteCloudGtmAddressPool(request: DeleteCloudGtmAddressPoolRequest): DeleteCloudGtmAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCloudGtmAddressPoolWithOptions(request, runtime);
}

model DeleteCloudGtmInstanceConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration. You can call the [ListCloudGtmInstanceConfigs](~~ListCloudGtmInstanceConfigs~~) operation to query the configuration ID of the access domain name.', example='config-000**1'),
  instanceId?: string(name='InstanceId', description='The access domain name that is configured for the desired GTM 3.0 instance. You can delete only one access domain name.', example='gtm-cn-jmp3qnw**03'),
}

model DeleteCloudGtmInstanceConfigResponseBody = {
  requestId?: string(name='RequestId', description='Unique request identification code.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  success?: boolean(name='Success', description='Indicates whether the operation to delete domain instance configurations was successful:
- true: Operation successful - false: Operation failed', example='true'),
}

model DeleteCloudGtmInstanceConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCloudGtmInstanceConfigResponseBody(name='body'),
}

/**
 * @summary Deletes an access domain name that is configured for a Global Traffic Manager (GTM) 3.0 instance.
 *
 * @param request DeleteCloudGtmInstanceConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCloudGtmInstanceConfigResponse
 */
async function deleteCloudGtmInstanceConfigWithOptions(request: DeleteCloudGtmInstanceConfigRequest, runtime: Util.RuntimeOptions): DeleteCloudGtmInstanceConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCloudGtmInstanceConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an access domain name that is configured for a Global Traffic Manager (GTM) 3.0 instance.
 *
 * @param request DeleteCloudGtmInstanceConfigRequest
 * @return DeleteCloudGtmInstanceConfigResponse
 */
async function deleteCloudGtmInstanceConfig(request: DeleteCloudGtmInstanceConfigRequest): DeleteCloudGtmInstanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCloudGtmInstanceConfigWithOptions(request, runtime);
}

model DeleteCloudGtmMonitorTemplateRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language in which the returned results are displayed. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  templateId?: string(name='TemplateId', description='The ID of the health check template. This ID uniquely identifies a health check template.

This parameter is required.', example='mtp-89518052425100**80'),
}

model DeleteCloudGtmMonitorTemplateResponseBody = {
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  success?: boolean(name='Success', description='Indicates whether the operation to delete the health check template was successful:
- true: Operation successful
- false: Operation failed', example='true'),
}

model DeleteCloudGtmMonitorTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCloudGtmMonitorTemplateResponseBody(name='body'),
}

/**
 * @summary Deletes a health check template.
 *
 * @param request DeleteCloudGtmMonitorTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCloudGtmMonitorTemplateResponse
 */
async function deleteCloudGtmMonitorTemplateWithOptions(request: DeleteCloudGtmMonitorTemplateRequest, runtime: Util.RuntimeOptions): DeleteCloudGtmMonitorTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCloudGtmMonitorTemplate',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a health check template.
 *
 * @param request DeleteCloudGtmMonitorTemplateRequest
 * @return DeleteCloudGtmMonitorTemplateResponse
 */
async function deleteCloudGtmMonitorTemplate(request: DeleteCloudGtmMonitorTemplateRequest): DeleteCloudGtmMonitorTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCloudGtmMonitorTemplateWithOptions(request, runtime);
}

model DeleteCustomLinesRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  lineIds?: string(name='LineIds', description='The unique IDs of the custom lines that you want to delete. Separate the unique IDs with commas (,). You can call the [DescribeCustomLines](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describecustomlines?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.

This parameter is required.', example='1234,1235'),
}

model DeleteCustomLinesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
}

model DeleteCustomLinesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCustomLinesResponseBody(name='body'),
}

/**
 * @summary Deletes custom lines at a time by using the unique IDs.
 *
 * @param request DeleteCustomLinesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCustomLinesResponse
 */
async function deleteCustomLinesWithOptions(request: DeleteCustomLinesRequest, runtime: Util.RuntimeOptions): DeleteCustomLinesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lineIds)) {
    query['LineIds'] = request.lineIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCustomLines',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes custom lines at a time by using the unique IDs.
 *
 * @param request DeleteCustomLinesRequest
 * @return DeleteCustomLinesResponse
 */
async function deleteCustomLines(request: DeleteCustomLinesRequest): DeleteCustomLinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCustomLinesWithOptions(request, runtime);
}

model DeleteDnsCacheDomainRequest {
  domainName?: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the name.

This parameter is required.', example='dns-example.top'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English Default: **zh**', example='en'),
}

model DeleteDnsCacheDomainResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model DeleteDnsCacheDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDnsCacheDomainResponseBody(name='body'),
}

/**
 * @summary Deletes a specified cache-accelerated domain name.
 *
 * @param request DeleteDnsCacheDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDnsCacheDomainResponse
 */
async function deleteDnsCacheDomainWithOptions(request: DeleteDnsCacheDomainRequest, runtime: Util.RuntimeOptions): DeleteDnsCacheDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDnsCacheDomain',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a specified cache-accelerated domain name.
 *
 * @param request DeleteDnsCacheDomainRequest
 * @return DeleteDnsCacheDomainResponse
 */
async function deleteDnsCacheDomain(request: DeleteDnsCacheDomainRequest): DeleteDnsCacheDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDnsCacheDomainWithOptions(request, runtime);
}

model DeleteDnsGtmAccessStrategyRequest {
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy.

This parameter is required.', example='testStrategyId1'),
}

model DeleteDnsGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
}

model DeleteDnsGtmAccessStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDnsGtmAccessStrategyResponseBody(name='body'),
}

/**
 * @param request DeleteDnsGtmAccessStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDnsGtmAccessStrategyResponse
 */
async function deleteDnsGtmAccessStrategyWithOptions(request: DeleteDnsGtmAccessStrategyRequest, runtime: Util.RuntimeOptions): DeleteDnsGtmAccessStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDnsGtmAccessStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteDnsGtmAccessStrategyRequest
 * @return DeleteDnsGtmAccessStrategyResponse
 */
async function deleteDnsGtmAccessStrategy(request: DeleteDnsGtmAccessStrategyRequest): DeleteDnsGtmAccessStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDnsGtmAccessStrategyWithOptions(request, runtime);
}

model DeleteDnsGtmAddressPoolRequest {
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.

This parameter is required.', example='testpool1'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
}

model DeleteDnsGtmAddressPoolResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model DeleteDnsGtmAddressPoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDnsGtmAddressPoolResponseBody(name='body'),
}

/**
 * @param request DeleteDnsGtmAddressPoolRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDnsGtmAddressPoolResponse
 */
async function deleteDnsGtmAddressPoolWithOptions(request: DeleteDnsGtmAddressPoolRequest, runtime: Util.RuntimeOptions): DeleteDnsGtmAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addrPoolId)) {
    query['AddrPoolId'] = request.addrPoolId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDnsGtmAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteDnsGtmAddressPoolRequest
 * @return DeleteDnsGtmAddressPoolResponse
 */
async function deleteDnsGtmAddressPool(request: DeleteDnsGtmAddressPoolRequest): DeleteDnsGtmAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDnsGtmAddressPoolWithOptions(request, runtime);
}

model DeleteDomainRequest {
  domainName?: string(name='DomainName', description='The domain name that already exists in Alibaba Cloud DNS. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.

This parameter is required.', example='example.com'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en.', example='en'),
}

model DeleteDomainResponseBody = {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model DeleteDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDomainResponseBody(name='body'),
}

/**
 * @summary Deletes a domain name based on the specified parameters.
 *
 * @param request DeleteDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDomainResponse
 */
async function deleteDomainWithOptions(request: DeleteDomainRequest, runtime: Util.RuntimeOptions): DeleteDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDomain',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a domain name based on the specified parameters.
 *
 * @param request DeleteDomainRequest
 * @return DeleteDomainResponse
 */
async function deleteDomain(request: DeleteDomainRequest): DeleteDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDomainWithOptions(request, runtime);
}

model DeleteDomainGroupRequest {
  groupId?: string(name='GroupId', description='The ID of the domain name group. You can call the [DescribeDomainGroups](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomaingroups?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.

This parameter is required.', example='2223'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en.', example='en'),
}

model DeleteDomainGroupResponseBody = {
  groupName?: string(name='GroupName', description='The name of the domain name group.', example='MyGroup'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model DeleteDomainGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDomainGroupResponseBody(name='body'),
}

/**
 * @summary Deletes a domain name group. After you delete the domain name group, the domain names in the group are moved to the default group.
 *
 * @description >  The default group cannot be deleted.
 *
 * @param request DeleteDomainGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDomainGroupResponse
 */
async function deleteDomainGroupWithOptions(request: DeleteDomainGroupRequest, runtime: Util.RuntimeOptions): DeleteDomainGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDomainGroup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a domain name group. After you delete the domain name group, the domain names in the group are moved to the default group.
 *
 * @description >  The default group cannot be deleted.
 *
 * @param request DeleteDomainGroupRequest
 * @return DeleteDomainGroupResponse
 */
async function deleteDomainGroup(request: DeleteDomainGroupRequest): DeleteDomainGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDomainGroupWithOptions(request, runtime);
}

model DeleteDomainRecordRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  recordId?: string(name='RecordId', description='The ID of the DNS record. You can call the [DescribeDomainRecords](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomainrecords?spm=a2c63.p38356.help-menu-search-29697.d_0) to obtain the ID.

This parameter is required.', example='9999985'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0'),
}

model DeleteDomainRecordResponseBody = {
  recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model DeleteDomainRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDomainRecordResponseBody(name='body'),
}

/**
 * @summary Deletes an Alibaba Cloud DNS (DNS) record based on the specified parameters.
 *
 * @param request DeleteDomainRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDomainRecordResponse
 */
async function deleteDomainRecordWithOptions(request: DeleteDomainRecordRequest, runtime: Util.RuntimeOptions): DeleteDomainRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recordId)) {
    query['RecordId'] = request.recordId;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDomainRecord',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an Alibaba Cloud DNS (DNS) record based on the specified parameters.
 *
 * @param request DeleteDomainRecordRequest
 * @return DeleteDomainRecordResponse
 */
async function deleteDomainRecord(request: DeleteDomainRecordRequest): DeleteDomainRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDomainRecordWithOptions(request, runtime);
}

model DeleteGtmAccessStrategyRequest {
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy that you want to delete.', example='hrskc'),
}

model DeleteGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
}

model DeleteGtmAccessStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteGtmAccessStrategyResponseBody(name='body'),
}

/**
 * @param request DeleteGtmAccessStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteGtmAccessStrategyResponse
 */
async function deleteGtmAccessStrategyWithOptions(request: DeleteGtmAccessStrategyRequest, runtime: Util.RuntimeOptions): DeleteGtmAccessStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGtmAccessStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteGtmAccessStrategyRequest
 * @return DeleteGtmAccessStrategyResponse
 */
async function deleteGtmAccessStrategy(request: DeleteGtmAccessStrategyRequest): DeleteGtmAccessStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGtmAccessStrategyWithOptions(request, runtime);
}

model DeleteGtmAddressPoolRequest {
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool that you want to delete.

This parameter is required.', example='1234'),
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
}

model DeleteGtmAddressPoolResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model DeleteGtmAddressPoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteGtmAddressPoolResponseBody(name='body'),
}

/**
 * @param request DeleteGtmAddressPoolRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteGtmAddressPoolResponse
 */
async function deleteGtmAddressPoolWithOptions(request: DeleteGtmAddressPoolRequest, runtime: Util.RuntimeOptions): DeleteGtmAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addrPoolId)) {
    query['AddrPoolId'] = request.addrPoolId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGtmAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteGtmAddressPoolRequest
 * @return DeleteGtmAddressPoolResponse
 */
async function deleteGtmAddressPool(request: DeleteGtmAddressPoolRequest): DeleteGtmAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGtmAddressPoolWithOptions(request, runtime);
}

model DeleteGtmRecoveryPlanRequest {
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  recoveryPlanId?: long(name='RecoveryPlanId', description='The ID of the disaster recovery plan that you want to delete.

This parameter is required.', example='100'),
}

model DeleteGtmRecoveryPlanResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model DeleteGtmRecoveryPlanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteGtmRecoveryPlanResponseBody(name='body'),
}

/**
 * @param request DeleteGtmRecoveryPlanRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteGtmRecoveryPlanResponse
 */
async function deleteGtmRecoveryPlanWithOptions(request: DeleteGtmRecoveryPlanRequest, runtime: Util.RuntimeOptions): DeleteGtmRecoveryPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recoveryPlanId)) {
    query['RecoveryPlanId'] = request.recoveryPlanId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGtmRecoveryPlan',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteGtmRecoveryPlanRequest
 * @return DeleteGtmRecoveryPlanResponse
 */
async function deleteGtmRecoveryPlan(request: DeleteGtmRecoveryPlanRequest): DeleteGtmRecoveryPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGtmRecoveryPlanWithOptions(request, runtime);
}

model DeleteSubDomainRecordsRequest {
  domainName?: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.

This parameter is required.', example='example.com'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  RR?: string(name='RR', description='The hostname field in the DNS record.

For example, if you want to resolve @.example.com, you must set this parameter to an at sign (@) instead of leaving it empty.

This parameter is required.', example='www'),
  type?: string(name='Type', description='The type of DNS records. If you do not specify this parameter, all types of DNS records corresponding to the subdomain are returned.

Valid values: **A, MX, CNAME, TXT, REDIRECT_URL, FORWORD_URL, NS, AAAA, and SRV**. The value is not case-sensitive.', example='A'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0'),
}

model DeleteSubDomainRecordsResponseBody = {
  RR?: string(name='RR', description='The hostname.', example='www'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: string(name='TotalCount', description='The total number of the DNS records to be deleted.', example='1'),
}

model DeleteSubDomainRecordsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSubDomainRecordsResponseBody(name='body'),
}

/**
 * @summary Deletes the DNS records that are corresponding to a hostname based on the specified parameters.
 *
 * @description If the DNS records to be deleted contain locked DNS records, the locked DNS records will not be deleted.
 *
 * @param request DeleteSubDomainRecordsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSubDomainRecordsResponse
 */
async function deleteSubDomainRecordsWithOptions(request: DeleteSubDomainRecordsRequest, runtime: Util.RuntimeOptions): DeleteSubDomainRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.RR)) {
    query['RR'] = request.RR;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSubDomainRecords',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes the DNS records that are corresponding to a hostname based on the specified parameters.
 *
 * @description If the DNS records to be deleted contain locked DNS records, the locked DNS records will not be deleted.
 *
 * @param request DeleteSubDomainRecordsRequest
 * @return DeleteSubDomainRecordsResponse
 */
async function deleteSubDomainRecords(request: DeleteSubDomainRecordsRequest): DeleteSubDomainRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSubDomainRecordsWithOptions(request, runtime);
}

model DescribeBatchResultCountRequest {
  batchType?: string(name='BatchType', description='The type of the batch operation. Valid values:

*   **DOMAIN_ADD**: adds domain names in batches.
*   **DOMAIN_DEL**: deletes domain names in batches.
*   **RR_ADD**: adds Domain Name System (DNS) records in batches.
*   **RR_DEL**: deletes DNS records in batches.

>  If you do not specify this parameter, filtering is not required.', example='DOMAIN_ADD'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  taskId?: long(name='TaskId', description='The task ID.

>  If you specify TaskId, the execution result of the specified task is returned. If you do not specify TaskId, the execution result of the last task is returned.', example='123456'),
}

model DescribeBatchResultCountResponseBody = {
  batchType?: string(name='BatchType', description='The type of the batch operation.', example='DOMAIN_ADD'),
  failedCount?: int32(name='FailedCount', description='The total number of domain names or DNS records that failed to be processed.', example='2'),
  reason?: string(name='Reason', description='The cause of the execution failure.', example='failed_reason'),
  requestId?: string(name='RequestId', description='The request ID.', example='75446CC1-FC9A-4595-8D96-089D73D7A63D'),
  status?: int32(name='Status', description='The state of the task. Valid values:

*   **-1**: No task for importing domain names or DNS records is submitted.
*   **0**: The task is being processed.
*   **1**: The task is complete.
*   **2**: The task failed.', example='0'),
  successCount?: int32(name='SuccessCount', description='The total number of domain names or DNS records that were processed.', example='2'),
  taskId?: long(name='TaskId', description='The ID of the last task.', example='123456'),
  totalCount?: int32(name='TotalCount', description='The total number of DNS records that were processed in batches.', example='4'),
}

model DescribeBatchResultCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBatchResultCountResponseBody(name='body'),
}

/**
 * @summary Queries the execution result of a batch operation task based on the task ID. If you do not specify task ID, the execution result of the last batch operation task is returned.
 *
 * @param request DescribeBatchResultCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBatchResultCountResponse
 */
async function describeBatchResultCountWithOptions(request: DescribeBatchResultCountRequest, runtime: Util.RuntimeOptions): DescribeBatchResultCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.batchType)) {
    query['BatchType'] = request.batchType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBatchResultCount',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the execution result of a batch operation task based on the task ID. If you do not specify task ID, the execution result of the last batch operation task is returned.
 *
 * @param request DescribeBatchResultCountRequest
 * @return DescribeBatchResultCountResponse
 */
async function describeBatchResultCount(request: DescribeBatchResultCountRequest): DescribeBatchResultCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBatchResultCountWithOptions(request, runtime);
}

model DescribeBatchResultDetailRequest {
  batchType?: string(name='BatchType', description='The type of the batch operation. Valid values:

*   **DOMAIN_ADD**: adds domain names in batches.
*   **DOMAIN_DEL**: deletes domain names in batches.
*   **RR_ADD**: adds Domain Name System (DNS) records in batches.
*   **RR_DEL**: deletes DNS records in batches.

>  Do not perform filtering when this field is empty.', example='DOMAIN_ADD'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  status?: string(name='Status', description='The execution result. If you do not specify this parameter, all results are returned.', example='SUCCESS'),
  taskId?: long(name='TaskId', description='The task ID.', example='83618818'),
}

model DescribeBatchResultDetailResponseBody = {
  batchResultDetails?: {
    batchResultDetail?: [ 
    {
      batchType?: string(name='BatchType', description='The type of the batch operation.', example='DOMAIN_ADD'),
      domain?: string(name='Domain', description='The domain name.', example='example.com'),
      line?: string(name='Line', description='The line code.', example='default'),
      newRr?: string(name='NewRr', description='The new hostname.', example='demo-batch-7'),
      newValue?: string(name='NewValue', description='The new record value.', example='192.0.2.254'),
      operateDateStr?: string(name='OperateDateStr', description='The time when the operation was performed. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2019-08-22 18:02:58'),
      priority?: string(name='Priority', description='The priority of the mail exchanger (MX) record.', example='10'),
      reason?: string(name='Reason', description='The cause of the execution failure.', example='Task lock fail'),
      recordId?: string(name='RecordId', description='The ID of the DNS record.', example='123456789'),
      remark?: string(name='Remark', description='The description of the DNS record.', example='remark'),
      rr?: string(name='Rr', description='The hostname.', example='www'),
      rrStatus?: string(name='RrStatus', description='The status of the DNS record.', example='stop'),
      status?: boolean(name='Status', description='The execution result of the batch operation. Valid values: **true**: The operation succeeded. **false**: The operation failed.', example='true'),
      ttl?: string(name='Ttl', description='The time-to-live (TTL) of the DNS record.', example='600'),
      type?: string(name='Type', description='The type of the DNS record.', example='A'),
      value?: string(name='Value', description='The value of the DNS record.', example='192.0.2.0'),
    }
  ](name='BatchResultDetail')
  }(name='BatchResultDetails', description='The detailed results of the batch operation.'),
  pageNumber?: long(name='PageNumber', description='The page number.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='75446CC1-FC9A-4595-8D96-089D73D7A63D'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model DescribeBatchResultDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBatchResultDetailResponseBody(name='body'),
}

/**
 * @summary Queries the detailed results of a batch operation task.
 *
 * @description Before you call this operation, make sure that the batch operation task is complete.
 *
 * @param request DescribeBatchResultDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBatchResultDetailResponse
 */
async function describeBatchResultDetailWithOptions(request: DescribeBatchResultDetailRequest, runtime: Util.RuntimeOptions): DescribeBatchResultDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.batchType)) {
    query['BatchType'] = request.batchType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBatchResultDetail',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the detailed results of a batch operation task.
 *
 * @description Before you call this operation, make sure that the batch operation task is complete.
 *
 * @param request DescribeBatchResultDetailRequest
 * @return DescribeBatchResultDetailResponse
 */
async function describeBatchResultDetail(request: DescribeBatchResultDetailRequest): DescribeBatchResultDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBatchResultDetailWithOptions(request, runtime);
}

model DescribeCloudGtmAddressRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  addressId?: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.

This parameter is required.', example='addr-89518218114368**92'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
}

model DescribeCloudGtmAddressResponseBody = {
  address?: string(name='Address', description='IP address or domain name.', example='223.5.XX.XX'),
  addressId?: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.', example='addr-89518218114368**92'),
  attributeInfo?: string(name='AttributeInfo', description='Address ownership information.', example='The current version does not support passing this parameter, please do not input the parameter.'),
  availableMode?: string(name='AvailableMode', description='The failover method that is used if the address fails health checks. Valid values:

*   auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
*   manual: the manual mode. If an address is in the unavailable state, the address is not returned for Domain Name System (DNS) requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.', example='auto'),
  availableStatus?: string(name='AvailableStatus', description='Address availability status:
- available: Available
- unavailable: Unavailable', example='available'),
  createTime?: string(name='CreateTime', description='Address creation time.', example='2024-03-23T13:09Z'),
  createTimestamp?: long(name='CreateTimestamp', description='Creation time (timestamp).', example='1527690629357'),
  enableStatus?: string(name='EnableStatus', description='Indicates the current enabled status of the address:
enabled: enabled state
disabled: disabled state', example='enable'),
  healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address. Valid values:

*   any_ok: The health check results of at least one health check template are normal.
*   p30_ok: The health check results of at least 30% of health check templates are normal.
*   p50_ok: The health check results of at least 50% of health check templates are normal.
*   p70_ok: The health check results of at least 70% of health check templates are normal.
*   all_ok: The health check results of all health check templates are normal.', example='p50_ok'),
  healthStatus?: string(name='HealthStatus', description='The health check state of the address. Valid values:

*   ok: The address passes all health checks of the referenced health check templates.
*   ok_alert: The address fails some health checks of the referenced health check templates but the address is deemed normal.
*   ok_no_monitor: The address does not reference a health check template.
*   exceptional: The address fails some or all health checks of the referenced health check templates and the address is deemed abnormal.', example='ok'),
  healthTasks?: {
    healthTask?: [ 
    {
      monitorStatus?: string(name='MonitorStatus', description='The state of the health check task. Valid values:

*   ok: The task is normal.
*   alert: An alert is triggered.
*   no_data: No data is available. In most cases, the health check task is newly created and no data is collected.', example='ok'),
      port?: int32(name='Port', description='The target service port for health checks. When the Ping protocol is selected for health checks, configuration of the service port is not supported.', example='80'),
      templateId?: string(name='TemplateId', description='The ID of the health check template associated with the address.', example='mtp-89518052425100**80'),
      templateName?: string(name='TemplateName', description='The name of the health check template.', example='Ping-IPv4'),
    }
  ](name='HealthTask')
  }(name='HealthTasks', description='The health check tasks referenced by the address.'),
  manualAvailableStatus?: string(name='ManualAvailableStatus', description='The availability state of the address when AvailableMode is set to manual. Valid values:

*   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
*   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.', example='available'),
  name?: string(name='Name', description='Address name.', example='test'),
  remark?: string(name='Remark', description='Remarks.', example='test1'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
  type?: string(name='Type', description='Address type:
- IPv4
- IPv6
- domain', example='IPv4'),
  updateTime?: string(name='UpdateTime', description='The last modification time of the address configuration.', example='2024-03-29T13:20Z'),
  updateTimestamp?: long(name='UpdateTimestamp', description='Modified time (timestamp).', example='1527690629357'),
}

model DescribeCloudGtmAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudGtmAddressResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of an address.
 *
 * @param request DescribeCloudGtmAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCloudGtmAddressResponse
 */
async function describeCloudGtmAddressWithOptions(request: DescribeCloudGtmAddressRequest, runtime: Util.RuntimeOptions): DescribeCloudGtmAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.addressId)) {
    query['AddressId'] = request.addressId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCloudGtmAddress',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the configurations of an address.
 *
 * @param request DescribeCloudGtmAddressRequest
 * @return DescribeCloudGtmAddressResponse
 */
async function describeCloudGtmAddress(request: DescribeCloudGtmAddressRequest): DescribeCloudGtmAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudGtmAddressWithOptions(request, runtime);
}

model DescribeCloudGtmAddressPoolRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89564674533755**96'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
}

model DescribeCloudGtmAddressPoolResponseBody = {
  addressLbStrategy?: string(name='AddressLbStrategy', description='Load balancing policy among addresses in the address pool:
- round_robin: Round-robin, where for any source of DNS resolution requests, all addresses are returned, with a rotation of the order for every request.
- sequence: Sequential, where for any source of DNS resolution requests, the address with the lower sequence number (indicating a higher priority, the smaller the number, the higher the priority) is returned. If the address with the lower sequence number is unavailable, the next address with a lower sequence number is returned.
- weight: Weighted, supporting the setting of different weight values for each address to realize returning addresses according to the weight ratio of query resolutions.
- source_nearest: Source-nearest, also known as intelligent resolution, where GTM can return different addresses based on the source of different DNS resolution requests, achieving the effect of users accessing nearby servers.', example='round_robin'),
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89564674533755**96'),
  addressPoolName?: string(name='AddressPoolName', description='Address pool name.', example='AddressPool-1'),
  addressPoolType?: string(name='AddressPoolType', description='Address pool type:
- IPv4
- IPv6
- domain', example='IPv4'),
  addresses?: {
    address?: [ 
    {
      address?: string(name='Address', description='IP address or domain name.', example='223.5.XX.XX'),
      addressId?: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.', example='addr-89518218114368**92'),
      attributeInfo?: string(name='AttributeInfo', description='Address ownership information, not supported in the current version.', example='Not supported in the current version.'),
      availableMode?: string(name='AvailableMode', description='The failover method that is used if the address fails health checks. Valid values:

*   auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
*   manual: the manual mode. If an address is in the unavailable state, the address is not returned for DNS requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.', example='auto'),
      availableStatus?: string(name='AvailableStatus', description='Address availability status:
- available: Address available
- unavailable: Address unavailable', example='available'),
      createTime?: string(name='CreateTime', description='Address creation time.', example='2024-03-15T01:46Z'),
      createTimestamp?: long(name='CreateTimestamp', description='Address creation time (timestamp).', example='1527690629357'),
      enableStatus?: string(name='EnableStatus', description='Address enable status, indicating whether the address is currently available:
- enable: Enabled status
- disable: Disabled status', example='enable'),
      healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address. Valid values:

*   any_ok: The health check results of at least one health check template are normal.
*   p30_ok: The health check results of at least 30% of health check templates are normal.
*   p50_ok: The health check results of at least 50% of health check templates are normal.
*   p70_ok: The health check results of at least 70% of health check templates are normal.
*   all_ok: The health check results of all health check templates are normal.', example='any_ok'),
      healthStatus?: string(name='HealthStatus', description='The health check state of the address. Valid values:

*   ok: The address passes all health checks of the referenced health check templates.
*   ok_alert: The address fails some health checks of the referenced health check templates but the address is deemed normal.
*   ok_no_monitor: The address does not reference a health check template and is normal.
*   exceptional: The address fails some or all health checks of the referenced health check templates and the address is deemed abnormal.', example='ok'),
      healthTasks?: {
        healthTask?: [ 
        {
          port?: int32(name='Port', description='The target service port for health check probes. When the health check protocol is set to Ping, configuration of the service port is not supported.', example='80'),
          templateId?: string(name='TemplateId', description='ID of the health check template associated with the address.', example='mtp-89518052425100**80'),
          templateName?: string(name='TemplateName', description='Health check template name.', example='IPv4-Ping'),
        }
      ](name='HealthTask')
      }(name='HealthTasks', description='Health check task list.'),
      manualAvailableStatus?: string(name='ManualAvailableStatus', description='The availability state of the address when AvailableMode is set to manual. Valid values:

*   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
*   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.', example='available'),
      name?: string(name='Name', description='Address name.', example='Address-1'),
      remark?: string(name='Remark', description='Remarks for the address.', example='test'),
      requestSource?: {
        requestSource?: [ string ](name='RequestSource')
      }(name='RequestSource', description='The request source list.'),
      seqNonPreemptiveSchedule?: boolean(name='SeqNonPreemptiveSchedule', description='Indicates whether it is a sequential (non-preemptive) scheduling object for hybrid cloud management scenarios: - true: yes - false: no', example='false'),
      serialNumber?: int32(name='SerialNumber', description='Sequence number, indicating the priority of address return, where smaller numbers have higher priority.', example='1'),
      type?: string(name='Type', description='The address type. Valid values:

*   IPv4: IPv4 address
*   IPv6: IPv6 address
*   domain: domain name', example='IPv4'),
      updateTime?: string(name='UpdateTime', description='The last time the address was modified.', example='2024-03-15T01:46Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The last modification time of the address (timestamp).', example='1527690629357'),
      weightValue?: int32(name='WeightValue', description='Weight value (an integer between 1 and 100, inclusive), allowing different weight values to be set for each address, enabling resolution queries to return addresses according to the weighted ratio.', example='1'),
    }
  ](name='Address')
  }(name='Addresses', description='The addresses.'),
  availableStatus?: string(name='AvailableStatus', description='Address pool availability status:
- available: Available
- unavailable: Unavailable', example='available'),
  createTime?: string(name='CreateTime', description='Address pool creation time.', example='2024-03-15T01:46Z'),
  createTimestamp?: long(name='CreateTimestamp', description='Address pool creation time (timestamp).', example='1527690629357'),
  enableStatus?: string(name='EnableStatus', description='Address pool status:
- enable: Enabled status
- disable: Disabled status', example='enable'),
  healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address pool. Valid values:

*   any_ok: At least one address in the address pool is available.
*   p30_ok: At least 30% of the addresses in the address pool are available.
*   p50_ok: At least 50% of the addresses in the address pool are available.
*   p70_ok: At least 70% of the addresses in the address pool are available.
*   all_ok: All addresses in the address pool are available.', example='any_ok'),
  healthStatus?: string(name='HealthStatus', description='The health state of the address pool. Valid values:

*   ok: The health state of the address pool is normal and all addresses that are referenced by the address pool are available.
*   ok_alert: The health state of the address pool is warning and some of the addresses that are referenced by the address pool are unavailable. However, the address pool is deemed normal. In this case, only the available addresses are returned for Domain Name System (DNS) requests.
*   exceptional: The health state of the address pool is abnormal and some or all of the addresses that are referenced by the address pool are unavailable. In this case, the address pool is deemed abnormal.', example='ok'),
  remark?: string(name='Remark', description='Remarks for the address.', example='test'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address with the smallest sequence number is recovered. This parameter is returned only when the policy for load balancing between addresses is sequence. Valid values:

*   preemptive: The address with the smallest sequence number is preferentially used if this address is recovered.
*   non_preemptive: The current address is still used even if the address with the smallest sequence number is recovered.', example='preemptive'),
  updateTime?: string(name='UpdateTime', description='The last modification time of the address pool.', example='2024-03-15T01:46Z'),
  updateTimestamp?: long(name='UpdateTimestamp', description='Last modification time of the address pool (timestamp).', example='1527690629357'),
}

model DescribeCloudGtmAddressPoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudGtmAddressPoolResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of an address pool.
 *
 * @param request DescribeCloudGtmAddressPoolRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCloudGtmAddressPoolResponse
 */
async function describeCloudGtmAddressPoolWithOptions(request: DescribeCloudGtmAddressPoolRequest, runtime: Util.RuntimeOptions): DescribeCloudGtmAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.addressPoolId)) {
    query['AddressPoolId'] = request.addressPoolId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCloudGtmAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the configurations of an address pool.
 *
 * @param request DescribeCloudGtmAddressPoolRequest
 * @return DescribeCloudGtmAddressPoolResponse
 */
async function describeCloudGtmAddressPool(request: DescribeCloudGtmAddressPoolRequest): DescribeCloudGtmAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudGtmAddressPoolWithOptions(request, runtime);
}

model DescribeCloudGtmAddressPoolReferenceRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
}

model DescribeCloudGtmAddressPoolReferenceResponseBody = {
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
  addressPoolName?: string(name='AddressPoolName', description='Address pool name.', example='app'),
  instanceConfigs?: {
    instanceConfig?: [ 
    {
      addressPoolLbStrategy?: string(name='AddressPoolLbStrategy', description='The policy for load balancing between address pools. Valid values:

*   round_robin: All address pools are returned for Domain Name System (DNS) requests from any source. All address pools are sorted in round-robin mode each time they are returned.
*   sequence: The address pool with the smallest sequence number is preferentially returned for DNS requests from any source. The sequence number indicates the priority for returning the address pool. A smaller sequence number indicates a higher priority. If the address pool with the smallest sequence number is unavailable, the address pool with the second smallest sequence number is returned.
*   weight: You can set a different weight value for each address pool. This way, address pools are returned based on the weight values.
*   source_nearest: Different address pools are returned based on the sources of DNS requests. This way, users can access nearby address pools.', example='round_robin'),
      availableStatus?: string(name='AvailableStatus', description='The availability state of the access domain name. Valid values:

*   available: If the access domain name is **enabled** and the health state is **normal**, the access domain name is deemed **available**.
*   unavailable: If the access domain name is **disabled** or the health state is **abnormal**, the access domain name is deemed **unavailable**.', example='available'),
      configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.', example='config-000**1'),
      enableStatus?: string(name='EnableStatus', description='The enabling state of the access domain name. Valid values:

*   enable: The access domain name is enabled and the intelligent scheduling policy of the corresponding GTM instance takes effect.
*   disable: The access domain name is disabled and the intelligent scheduling policy of the corresponding GTM instance does not take effect.', example='enable'),
      healthStatus?: string(name='HealthStatus', description='The health state of the access domain name. Valid values:

*   ok: The health state of the access domain name is normal and all address pools that are referenced by the access domain name are available.
*   ok_alert: The health state of the access domain name is warning and some of the address pools that are referenced by the access domain name are unavailable. In this case, only the available address pools are returned for DNS requests.
*   exceptional: The health state of the access domain name is abnormal and all address pools that are referenced by the access domain name are unavailable. In this case, addresses in the non-empty address pool with the smallest sequence number are preferentially used for fallback resolution. This returns DNS results for clients as much as possible.', example='ok'),
      instanceId?: string(name='InstanceId', description='The ID of the Global Traffic Manager (GTM) 3.0 instance.', example='gtm-cn-jmp3qnw**03'),
      instanceName?: string(name='InstanceName', description='Instance name.', example='test'),
      remark?: string(name='Remark', description='Remarks.', example='test'),
      scheduleDomainName?: string(name='ScheduleDomainName', description='The access domain name. The value of this parameter is composed of the value of ScheduleHostname and the value of ScheduleZoneName.', example='www.example.com'),
      scheduleHostname?: string(name='ScheduleHostname', description='Host record of the domain accessed by GTM.', example='www'),
      scheduleRrType?: string(name='ScheduleRrType', description='DNS record types for scheduling domains:
- A: IPv4 address
- AAAA: IPv6 address
- CNAME: Domain name', example='A'),
      scheduleZoneName?: string(name='ScheduleZoneName', description='The zone such as example.com or subzone such as a.example.com of the access domain name. In most cases, the zone or subzone is hosted by the Public Authoritative DNS module of Alibaba Cloud DNS. This zone belongs to the account to which the GTM instance belongs.', example='example.com'),
      sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address pool with the smallest sequence number is recovered. This parameter is returned when AddressPoolLbStrategy is set to sequence. Valid values:

*   preemptive: The address pool with the smallest sequence number is preferentially used if this address pool is recovered.
*   non_preemptive: The current address pool is still used even if the address pool with the smallest sequence number is recovered.', example='preemptive'),
      ttl?: int32(name='Ttl', description='Global TTL, the TTL value for resolving the accessed domain name to addresses in the address pool, which affects the caching time of DNS records in the operator\\\\"s LocalDNS. Supports custom TTL values.', example='30'),
      versionCode?: string(name='VersionCode', description='Global Traffic Management version 3.0 instance types:
- standard: Standard Edition
- ultimate: Ultimate Edition', example='ultimate'),
    }
  ](name='InstanceConfig')
  }(name='InstanceConfigs', description='The access domain names that reference the address pool.'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='853805EA-3D47-47D5-9A1A-A45C24313ABD'),
}

model DescribeCloudGtmAddressPoolReferenceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudGtmAddressPoolReferenceResponseBody(name='body'),
}

/**
 * @summary Queries the information about the access domain names that reference an address pool.
 *
 * @param request DescribeCloudGtmAddressPoolReferenceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCloudGtmAddressPoolReferenceResponse
 */
async function describeCloudGtmAddressPoolReferenceWithOptions(request: DescribeCloudGtmAddressPoolReferenceRequest, runtime: Util.RuntimeOptions): DescribeCloudGtmAddressPoolReferenceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.addressPoolId)) {
    query['AddressPoolId'] = request.addressPoolId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCloudGtmAddressPoolReference',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about the access domain names that reference an address pool.
 *
 * @param request DescribeCloudGtmAddressPoolReferenceRequest
 * @return DescribeCloudGtmAddressPoolReferenceResponse
 */
async function describeCloudGtmAddressPoolReference(request: DescribeCloudGtmAddressPoolReferenceRequest): DescribeCloudGtmAddressPoolReferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudGtmAddressPoolReferenceWithOptions(request, runtime);
}

model DescribeCloudGtmAddressReferenceRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  addressId?: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.', example='addr-89518218114368**92'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
}

model DescribeCloudGtmAddressReferenceResponseBody = {
  address?: string(name='Address', description='IP address or domain name.', example='223.5.XX.XX'),
  addressId?: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.', example='addr-89564584963974**40'),
  addressPools?: {
    addressPool?: [ 
    {
      addressLbStrategy?: string(name='AddressLbStrategy', description='Load balancing policy among addresses in the address pool:
- round_robin: Round-robin, for any source of DNS resolution requests, all addresses are returned, with a rotation sort applied to all addresses each time.
- sequence: Sequential, for any source of DNS resolution requests, returns the address with the smaller sequence number (the sequence number indicates the priority of address return, with smaller numbers having higher priority). If the address with the smaller sequence number is unavailable, the next address with a smaller sequence number is returned.
- weight: Weighted, supports setting different weight values for each address, realizing the return of addresses according to the ratio of weight for DNS query resolutions.
- source_nearest: Source-nearest, i.e., intelligent resolution function, where GTM can return different addresses based on the source of different DNS resolution requests, achieving the effect of users accessing nearby.', example='round_robin'),
      addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool.', example='pool-895280232254422016'),
      addressPoolName?: string(name='AddressPoolName', description='Address pool name.', example='AddressPool-1'),
      addressPoolType?: string(name='AddressPoolType', description='Address pool type:
- IPv4
- IPv6
- domain', example='IPv4'),
      availableStatus?: string(name='AvailableStatus', description='Address pool availability status:
- available
- unavailable', example='available'),
      enableStatus?: string(name='EnableStatus', description='Address pool status:
- enable: Enabled status
- disable: Disabled status', example='enable'),
      healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address pool. Valid values:

*   any_ok: At least one address in the address pool is available.
*   p30_ok: At least 30% of the addresses in the address pool are available.
*   p50_ok: At least 50% of the addresses in the address pool are available.
*   p70_ok: At least 70% of the addresses in the address pool are available.
*   all_ok: All addresses in the address pool are available.', example='any_ok'),
      healthStatus?: string(name='HealthStatus', description='The health state of the address pool. Valid values:

*   ok: The health state of the address pool is normal and all addresses that are referenced by the address pool are available.
*   ok_alert: The health state of the address pool is warning and some of the addresses that are referenced by the address pool are unavailable. However, the address pool is deemed normal. In this case, only the available addresses are returned for DNS requests.
*   exceptional: The health state of the address pool is abnormal and some or all of the addresses that are referenced by the address pool are unavailable. In this case, the address pool is deemed abnormal.', example='ok'),
      instanceConfigs?: {
        instanceConfig?: [ 
        {
          addressPoolLbStrategy?: string(name='AddressPoolLbStrategy', description='The policy for load balancing between address pools. Valid values:

*   round_robin: All address pools are returned for Domain Name System (DNS) requests from any source. All address pools are sorted in round-robin mode each time they are returned.
*   sequence: The address pool with the smallest sequence number is preferentially returned for DNS requests from any source. The sequence number indicates the priority for returning the address pool. A smaller sequence number indicates a higher priority. If the address pool with the smallest sequence number is unavailable, the address pool with the second smallest sequence number is returned.
*   weight: You can set a different weight value for each address pool. This way, address pools are returned based on the weight values.
*   source_nearest: Different address pools are returned based on the sources of DNS requests. This way, users can access nearby address pools.', example='round_robin'),
          availableStatus?: string(name='AvailableStatus', description='The availability state of the access domain name. Valid values:

*   available: If the access domain name is **enabled** and the health state is normal, the access domain name is deemed **available**.
*   unavailable: If the access domain name is **disabled** or the health state is **abnormal**, the access domain name is deemed **unavailable**.', example='available'),
          configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.', example='config-00**01'),
          enableStatus?: string(name='EnableStatus', description='The enabling state of the access domain name. Valid values:

*   enable: The access domain name is enabled and the intelligent scheduling policy of the corresponding GTM instance takes effect.
*   disable: The access domain name is disabled and the intelligent scheduling policy of the corresponding GTM instance does not take effect.', example='enable'),
          healthStatus?: string(name='HealthStatus', description='The health state of the access domain name. Valid values:

*   ok: The health state of the access domain name is normal and all address pools that are referenced by the access domain name are available.
*   ok_alert: The health state of the access domain name is warning and some of the address pools that are referenced by the access domain name are unavailable. In this case, only the available address pools are returned for DNS requests.
*   exceptional: The health state of the access domain name is abnormal and all address pools that are referenced by the access domain name are unavailable. In this case, addresses in the non-empty address pool with the smallest sequence number are preferentially used for fallback resolution. This returns DNS results for clients as much as possible.', example='ok'),
          instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance.', example='gtm-cn-zz11t58**0k'),
          instanceName?: string(name='InstanceName', description='Instance name.', example='test'),
          remark?: string(name='Remark', description='Remarks.', example='test'),
          scheduleDomainName?: string(name='ScheduleDomainName', description='The access domain name. The value of this parameter is composed of the value of ScheduleHostname and the value of ScheduleZoneName.', example='www.example.com'),
          scheduleHostname?: string(name='ScheduleHostname', description='Host record of the domain accessed by GTM.', example='www'),
          scheduleRrType?: string(name='ScheduleRrType', description='DNS record types for the scheduling domain:
- A: IPv4 address
- AAAA: IPv6 address
- CNAME: Domain name', example='A'),
          scheduleZoneName?: string(name='ScheduleZoneName', description='The zone such as example.com or subzone such as a.example.com of the access domain name. In most cases, the zone or subzone is hosted by the Public Authoritative DNS module of Alibaba Cloud DNS. This zone belongs to the account to which the GTM instance belongs.', example='example.com'),
          sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address pool with the smallest sequence number is recovered. This parameter is returned when AddressPoolLbStrategy is set to sequence. Valid values:

*   preemptive: The address pool with the smallest sequence number is preferentially used if this address pool is recovered.
*   non_preemptive: The current address pool is still used even if the address pool with the smallest sequence number is recovered.', example='preemptive'),
          ttl?: int32(name='Ttl', description='Global TTL (in seconds), the TTL value for domain name resolution to addresses in the address pool, which affects the caching time of DNS records in the ISP\\\\"s LocalDNS. Custom TTL values are supported.', example='30'),
          versionCode?: string(name='VersionCode', description='Global Traffic Management version 3.0 instance types:
- standard: Standard Edition
- ultimate: Ultimate Edition', example='ultimate'),
        }
      ](name='InstanceConfig')
      }(name='InstanceConfigs', description='The instances that reference the address pool.'),
      remark?: string(name='Remark', description='Remarks for the address pool.', example='pool-1'),
      sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='Load balancing policy between addresses in sequential mode during the recovery of preceding resources service mode:
- preemptive: Preemption mode, where upon recovery of preceding resources, priority is given to using addresses with smaller sequence numbers;
- non_preemptive: Non-preemption mode, where upon recovery of preceding resources, the current address continues to be used;', example='preemptive'),
    }
  ](name='AddressPool')
  }(name='AddressPools', description='The address pools.'),
  name?: string(name='Name', description='Address name.', example='Address-1'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model DescribeCloudGtmAddressReferenceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudGtmAddressReferenceResponseBody(name='body'),
}

/**
 * @summary Queries the information about the address pools and Global Traffic Manager (GTM) 3.0 instances that reference an address.
 *
 * @param request DescribeCloudGtmAddressReferenceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCloudGtmAddressReferenceResponse
 */
async function describeCloudGtmAddressReferenceWithOptions(request: DescribeCloudGtmAddressReferenceRequest, runtime: Util.RuntimeOptions): DescribeCloudGtmAddressReferenceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.addressId)) {
    query['AddressId'] = request.addressId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCloudGtmAddressReference',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about the address pools and Global Traffic Manager (GTM) 3.0 instances that reference an address.
 *
 * @param request DescribeCloudGtmAddressReferenceRequest
 * @return DescribeCloudGtmAddressReferenceResponse
 */
async function describeCloudGtmAddressReference(request: DescribeCloudGtmAddressReferenceRequest): DescribeCloudGtmAddressReferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudGtmAddressReferenceWithOptions(request, runtime);
}

model DescribeCloudGtmGlobalAlertRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US: English', example='en-US'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
}

model DescribeCloudGtmGlobalAlertResponseBody = {
  alertConfig?: {
    alertConfig?: [ 
    {
      dingtalkNotice?: boolean(name='DingtalkNotice', description='Indicates whether DingTalk notifications are configured. Valid values:

*   true: DingTalk notifications are configured. DingTalk notifications are sent when alerts are triggered.
*   false: DingTalk notifications are not configured.', example='false'),
      emailNotice?: boolean(name='EmailNotice', description='Indicates whether email notifications are configured. Valid values:

*   true: Email notifications are configured. Emails are sent when alerts are triggered.
*   false: Email notifications are not configured.', example='true'),
      noticeType?: string(name='NoticeType', description='The type of the alert event. Valid values:

*   addr_alert: The address is unavailable.
*   addr_resume: The address becomes available.
*   addr_pool_unavailable: The address pool is unavailable.
*   addr_pool_available: The address pool becomes available.', example='addr_alert'),
      smsNotice?: boolean(name='SmsNotice', description='Indicates whether text message notifications are configured. Valid values:

*   true: Text message notifications are configured. Text messages are sent when alerts are triggered.
*   false: Text message notifications are not configured.

Only the China site (aliyun.com) supports text message notifications.', example='true'),
    }
  ](name='AlertConfig')
  }(name='AlertConfig', description='The alert configurations.'),
  alertGroup?: {
    alertGroup?: [ string ](name='AlertGroup')
  }(name='AlertGroup', description='The alert contact groups.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
}

model DescribeCloudGtmGlobalAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudGtmGlobalAlertResponseBody(name='body'),
}

/**
 * @param request DescribeCloudGtmGlobalAlertRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCloudGtmGlobalAlertResponse
 */
async function describeCloudGtmGlobalAlertWithOptions(request: DescribeCloudGtmGlobalAlertRequest, runtime: Util.RuntimeOptions): DescribeCloudGtmGlobalAlertResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCloudGtmGlobalAlert',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeCloudGtmGlobalAlertRequest
 * @return DescribeCloudGtmGlobalAlertResponse
 */
async function describeCloudGtmGlobalAlert(request: DescribeCloudGtmGlobalAlertRequest): DescribeCloudGtmGlobalAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudGtmGlobalAlertWithOptions(request, runtime);
}

model DescribeCloudGtmInstanceConfigAlertRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   **zh-CN**: Chinese
*   **en-US**: English', example='en-US'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.', example='Config-000**11'),
  instanceId?: string(name='InstanceId', description='The ID of the Global Traffic Manager (GTM) 3.0 instance.', example='gtm-cn-wwo3a3hbz**'),
}

model DescribeCloudGtmInstanceConfigAlertResponseBody = {
  alertConfig?: {
    alertConfig?: [ 
    {
      dingtalkNotice?: boolean(name='DingtalkNotice', description='Indicates whether DingTalk notifications are configured. Valid values:

*   true: DingTalk notifications are configured. DingTalk notifications are sent after alerts are triggered.
*   false: DingTalk notifications are not configured.', example='true'),
      emailNotice?: boolean(name='EmailNotice', description='Indicates whether email notifications are configured. Valid values:

*   true: Email notifications are configured. Emails are sent after alerts are triggered.
*   false: Email notifications are not configured.', example='true'),
      noticeType?: string(name='NoticeType', description='The type of the alert event. Valid values:

*   addr_alert: The address is unavailable.
*   addr_resume: The address becomes available.
*   addr_pool_unavailable: The address pool is unavailable.
*   addr_pool_available: The address pool becomes available.', example='addr_alert'),
      smsNotice?: boolean(name='SmsNotice', description='Indicates whether text message notifications are configured. Valid values:

*   true: Text message notifications are configured. Text messages are sent after alerts are triggered.
*   false: Text message notifications are not configured.

Only the China site (aliyun.com) supports text message notifications.', example='true'),
    }
  ](name='AlertConfig')
  }(name='AlertConfig', description='The alert configurations.'),
  alertGroup?: {
    alertGroup?: [ string ](name='AlertGroup')
  }(name='AlertGroup', description='The alert contact groups.'),
  alertMode?: string(name='AlertMode', description='The alert configuration mode of the instance. Valid values:

*   global: global alert configuration
*   instance_config: custom alert configuration', example='global'),
  configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.', example='Config-000**11'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance.', example='gtm-cn-wwo3a3hbz**'),
  requestId?: string(name='RequestId', description='The request ID.', example='0F32959D-417B-4D66-8463-68606605E3E2'),
}

model DescribeCloudGtmInstanceConfigAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudGtmInstanceConfigAlertResponseBody(name='body'),
}

/**
 * @param request DescribeCloudGtmInstanceConfigAlertRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCloudGtmInstanceConfigAlertResponse
 */
async function describeCloudGtmInstanceConfigAlertWithOptions(request: DescribeCloudGtmInstanceConfigAlertRequest, runtime: Util.RuntimeOptions): DescribeCloudGtmInstanceConfigAlertResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCloudGtmInstanceConfigAlert',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeCloudGtmInstanceConfigAlertRequest
 * @return DescribeCloudGtmInstanceConfigAlertResponse
 */
async function describeCloudGtmInstanceConfigAlert(request: DescribeCloudGtmInstanceConfigAlertRequest): DescribeCloudGtmInstanceConfigAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudGtmInstanceConfigAlertWithOptions(request, runtime);
}

model DescribeCloudGtmInstanceConfigFullInfoRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.

You can call the [ListCloudGtmInstanceConfigs](~~ListCloudGtmInstanceConfigs~~) operation to query the value of ConfigId for the access domain name.', example='Config-000**11'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance.', example='gtm-cn-wwo3a3hbz**'),
}

model DescribeCloudGtmInstanceConfigFullInfoResponseBody = {
  addressPoolLbStrategy?: string(name='AddressPoolLbStrategy', description='The policy for load balancing between address pools. Valid values:

*   round_robin: All address pools are returned for DNS requests from any source. All address pools are sorted in round-robin mode each time they are returned.
*   sequence: The address pool with the smallest sequence number is preferentially returned for DNS requests from any source. The sequence number indicates the priority for returning the address pool. A smaller sequence number indicates a higher priority. If the address pool with the smallest sequence number is unavailable, the address pool with the second smallest sequence number is returned.
*   weight: You can set a different weight value for each address pool. This way, address pools are returned based on the weight values.
*   source_nearest: GTM returns different addresses based on the sources of DNS requests. This way, users can access nearby addresses.', example='round_robin'),
  addressPools?: {
    addressPool?: [ 
    {
      addressLbStrategy?: string(name='AddressLbStrategy', description='Load balancing policy among addresses in the address pool:
- round_robin: Round-robin, for any source of DNS resolution requests, returns all addresses and rotates their order for each request.
- sequence: Sequential, for any source of DNS resolution requests, returns the address with the smaller sequence number (the sequence number indicates the priority of the address return, with smaller numbers having higher priority). If the address with the smaller sequence number is unavailable, the next address with a smaller sequence number is returned.
- weight: Weighted, supports setting different weight values for each address to realize returning addresses according to the weight ratio for resolution queries.
- source_nearest: Source-nearest, i.e., intelligent resolution function, where GTM can return different addresses based on the source of different DNS resolution requests, achieving the effect of users accessing nearby.', example='round_robin'),
      addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
      addressPoolName?: string(name='AddressPoolName', description='Address pool name.', example='AddressPool-1'),
      addressPoolType?: string(name='AddressPoolType', description='Address pool type:
- IPv4
- IPv6
- domain', example='IPv4'),
      addresses?: {
        address?: [ 
        {
          address?: string(name='Address', description='IP address or domain name.', example='223.5.XX.XX'),
          addressId?: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.', example='addr-89564712295703**96'),
          attributeInfo?: string(name='AttributeInfo', description='Address ownership information, not supported in the current version.', example='The current version does not support returning this parameter.'),
          availableMode?: string(name='AvailableMode', description='The failover mode that is used when address exceptions are identified. Valid values:

*   auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
*   manual: the manual mode. If an address is in the unavailable state, the address is not returned for DNS requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.', example='auto'),
          availableStatus?: string(name='AvailableStatus', description='The availability state of the address. Valid values:

*   available
*   unavailable', example='available'),
          createTime?: string(name='CreateTime', description='Address creation time.', example='2024-03-15T01:46Z'),
          createTimestamp?: long(name='CreateTimestamp', description='Address creation time (timestamp).', example='1527690629357'),
          enableStatus?: string(name='EnableStatus', description='The enabling state of the address. Valid values:

*   enable
*   disable', example='enable'),
          healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health state of the address. Valid values:

*   any_ok: The health check results of at least one health check template are normal.
*   p30_ok: The health check results of at least 30% of health check templates are normal.
*   p50_ok: The health check results of at least 50% of health check templates are normal.
*   p70_ok: The health check results of at least 70% of health check templates are normal.
*   all_ok: The health check results of all health check templates are normal.', example='any_ok'),
          healthStatus?: string(name='HealthStatus', description='The health check state of the address. Valid values:

*   ok: The address passes all health checks of the referenced health check templates.
*   ok_alert: The address fails some health checks of the referenced health check templates but the address is deemed normal.
*   ok_no_monitor: The address does not reference any health check template and is normal.
*   exceptional: The address fails some or all health checks of the referenced health check templates and the address is deemed abnormal.', example='ok'),
          manualAvailableStatus?: string(name='ManualAvailableStatus', description='The availability state of the address when AvailableMode is set to manual. Valid values:

*   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
*   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.', example='available'),
          name?: string(name='Name', description='Address name.', example='Address-1'),
          remark?: string(name='Remark', description='The remark of the address.', example='test'),
          requestSource?: {
            requestSource?: [ string ](name='RequestSource')
          }(name='RequestSource', description='Request source list.'),
          seqNonPreemptiveSchedule?: boolean(name='SeqNonPreemptiveSchedule', description='Indicates whether it is a sequential (non-preemptive) mode scheduling object, applicable to hybrid cloud management scenarios: 

- true: yes
- false: no', example='false'),
          serialNumber?: int32(name='SerialNumber', description='Sequence number, indicating the priority of address return, where smaller numbers have higher priority.', example='1'),
          type?: string(name='Type', description='The type of the address. Valid values:

*   IPV4: the IPv4 address
*   IPv6: the IPv6 address
*   domain: the domain name', example='IPv4'),
          updateTime?: string(name='UpdateTime', description='Last modified time of the address.', example='2024-03-15T01:46Z'),
          updateTimestamp?: long(name='UpdateTimestamp', description='The last modification time of the address (timestamp).', example='1527690629357'),
          weightValue?: int32(name='WeightValue', description='Weight value (an integer between 1 and 100, inclusive), allowing different weight values to be set for each address, enabling resolution queries to return addresses in proportion to their weights.', example='1'),
        }
      ](name='Address')
      }(name='Addresses', description='The addresses.'),
      availableStatus?: string(name='AvailableStatus', description='The availability state of the address pool. Valid values:

*   Available
*   unavailable', example='available'),
      createTime?: string(name='CreateTime', description='Address pool creation time.', example='2024-03-15T01:46Z'),
      createTimestamp?: long(name='CreateTimestamp', description='Address pool creation time (timestamp).', example='1527690629357'),
      enableStatus?: string(name='EnableStatus', description='The enabling state of the address pool. Valid values:

*   enable
*   disable', example='enable'),
      healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health state of the address pool. Valid values:

*   any_ok: At least one address in the address pool is available.
*   p30_ok: At least 30% of the addresses in the address pool are available.
*   p50_ok: At least 50% of the addresses in the address pool are available.
*   p70_ok: At least 70% of the addresses in the address pool are available.
*   all_ok: All addresses in the address pool are available.', example='any_ok'),
      healthStatus?: string(name='HealthStatus', description='Address pool health status:
- ok: Normal, all addresses referenced by the address pool are available.
- ok_alert: Warning, some addresses referenced by the address pool are unavailable, but the address pool status is deemed normal. In the warning state, available address pools are resolved normally, while unavailable ones stop resolving.
- exceptional: Abnormal, some or all of the addresses referenced by the address pool are unavailable, and the address pool status is determined to be abnormal.', example='ok'),
      requestSource?: {
        requestSource?: [ string ](name='RequestSource')
      }(name='RequestSource', description='Parse the list of request sources.'),
      seqNonPreemptiveSchedule?: boolean(name='SeqNonPreemptiveSchedule', description='Indicates whether it is a sequential (non-preemptive) scheduling object for hybrid cloud management scenarios: 
- true: yes 
- false: no', example='false'),
      sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address with the smallest sequence number is recovered. This parameter is required only when AddressLbStrategy is set to sequence. Valid values:

*   preemptive: The address with the smallest sequence number is preferentially used if this address is recovered.
*   non_preemptive: The current address is still used even if the address with the smallest sequence number is recovered.', example='preemptive'),
      serialNumber?: int32(name='SerialNumber', description='Sequence number. For any parsing request from any source, the address pool with the smaller sequence number is returned (the sequence number indicates the priority of the address pool returned, with smaller numbers having higher priority).', example='1'),
      updateTime?: string(name='UpdateTime', description='Last modification time of the address pool.', example='2024-03-15T01:46Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='Last modification time of the address pool (timestamp).', example='1527690629357'),
      weightValue?: int32(name='WeightValue', description='Weight value (an integer between 1 and 100, inclusive), allowing different weight values to be set for each address pool, enabling resolution queries to return address pools according to the weighted ratio.', example='1'),
    }
  ](name='AddressPool')
  }(name='AddressPools', description='The address pools.'),
  alertConfig?: string(name='AlertConfig', description='Alert notification configuration.', example='[{\\\\"NoticeType\\\\":\\\\"addr_alert\\\\",\\\\"SmsNotice\\\\":true,\\\\"EmailNotice\\\\":true,\\\\"DingtalkNotice\\\\":true},{\\\\"NoticeType\\\\":\\\\"addr_resume\\\\",\\\\"SmsNotice\\\\":true,\\\\"EmailNotice\\\\":true,\\\\"DingtalkNotice\\\\":true},{\\\\"NoticeType\\\\":\\\\"addr_pool_unavailable\\\\",\\\\"SmsNotice\\\\":true,\\\\"EmailNotice\\\\":true,\\\\"DingtalkNotice\\\\":true},{\\\\"NoticeType\\\\":\\\\"addr_pool_available\\\\",\\\\"SmsNotice\\\\":true,\\\\"EmailNotice\\\\":true,\\\\"DingtalkNotice\\\\":true}]"'),
  alertGroup?: string(name='AlertGroup', description='Alert notification group.', example='[\\\\"Default Contact Group\\\\"]'),
  availableStatus?: string(name='AvailableStatus', description='The availability state of the access domain name. Valid values:

*   available: If the access domain name is **enabled** and the health state of the access domain name is **Normal**, the access domain name is deemed **available**.
*   unavailable: If the access domain name is **disabled** or the health state of the access domain name is **Abnormal**, the access domain name is deemed **unavailable**.', example='available'),
  commodityCode?: string(name='CommodityCode', description='The commodity code. Valid values:

*   dns_gtm_public_cn: the commodity code on the China site (aliyun.com)
*   dns_gtm_public_intl: the commodity code on the international site (alibabacloud.com)', example='dns_gtm_public_cn'),
  configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.', example='Config-000**11'),
  createTime?: string(name='CreateTime', description='Instance creation time.', example='2024-03-15T01:46Z'),
  createTimestamp?: long(name='CreateTimestamp', description='Instance creation time (timestamp).', example='1527690629357'),
  enableStatus?: string(name='EnableStatus', description='The enabling state of the access domain name. Valid values:

*   enable: The access domain name is enabled and the intelligent scheduling policy of the corresponding GTM instance takes effect.
*   disable: The access domain name is disabled and the intelligent scheduling policy of the corresponding GTM instance does not take effect.', example='enable'),
  healthStatus?: string(name='HealthStatus', description='The health state of the access domain name. Valid values:

*   ok: The health state of the access domain name is Normal and all address pools that are referenced by the access domain name are available.
*   ok_alert: The health state of the access domain name is Warning and some of the address pools that are referenced by the access domain name are unavailable. In this case, the available address pools are normally used for DNS resolution, but the unavailable address pools cannot be used for DNS resolution.
*   exceptional: The health state of the access domain name is Abnormal and all address pools that are referenced by the access domain name are unavailable. In this case, addresses in the non-empty address pool with the smallest sequence number are preferentially used for fallback resolution. This returns DNS results for clients as much as possible.', example='ok'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance.', example='gtm-cn-wwo3a3hbz**'),
  instanceName?: string(name='InstanceName', description='Schedule instance name.', example='test'),
  remark?: string(name='Remark', description='Remarks of the configuration of domain instance.', example='test'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
  scheduleDomainName?: string(name='ScheduleDomainName', description='The GTM access domain name. The value of this parameter is composed of the value of ScheduleHostname and the value of ScheduleZoneName.', example='www.example.com'),
  scheduleHostname?: string(name='ScheduleHostname', description='Host name of the domain accessed by GTM.', example='www'),
  scheduleRrType?: string(name='ScheduleRrType', description='DNS record types for the ScheduleDomainName:
- A: IPv4 address
- AAAA: IPv6 address
- CNAME: Domain name', example='A'),
  scheduleZoneMode?: string(name='ScheduleZoneMode', description='The allocation mode of the access domain name. Valid values:

*   custom: custom allocation. You must specify a custom hostname and associate the hostname with a zone or subzone within the account to which the GTM instance belongs to generate an access domain name.
*   sys_assign: The system assigns an access domain name by default. This mode is no longer supported. Do not choose this mode.', example='custom'),
  scheduleZoneName?: string(name='ScheduleZoneName', description='The zone (such as example.com) or subzone (such as a.example.com) associated with the GTM access domain name. In most cases, the zone or subzone is hosted in Authoritative DNS Resolution of the Alibaba Cloud DNS console within the account to which the GTM instance belongs.', example='example.com'),
  sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address pool with the smallest sequence number is recovered. This parameter is required when AddressPoolLbStrategy is set to sequence. Valid values:

*   preemptive: The address pool with the smallest sequence number is preferentially used if this address pool is recovered.
*   non_preemptive: The current address pool is still used even if the address pool with the smallest sequence number is recovered.', example='preemptive'),
  ttl?: int32(name='Ttl', description='Global TTL (in seconds), the TTL value for resolving the access domain to addresses in the address pool, which affects the caching time of DNS records in the ISP\\\\"s LocalDNS. Custom TTL values are supported.', example='60'),
  updateTime?: string(name='UpdateTime', description='Last modified time.', example='2024-03-15T01:46Z'),
  updateTimestamp?: long(name='UpdateTimestamp', description='Last modified time (timestamp).', example='1527690629357'),
  versionCode?: string(name='VersionCode', description='Global Traffic Management version 3.0 instances:
- standard: Standard Edition
- ultimate: Ultimate Edition', example='ultimate'),
}

model DescribeCloudGtmInstanceConfigFullInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudGtmInstanceConfigFullInfoResponseBody(name='body'),
}

/**
 * @summary Queries the complete configuration information about a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeCloudGtmInstanceConfigFullInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCloudGtmInstanceConfigFullInfoResponse
 */
async function describeCloudGtmInstanceConfigFullInfoWithOptions(request: DescribeCloudGtmInstanceConfigFullInfoRequest, runtime: Util.RuntimeOptions): DescribeCloudGtmInstanceConfigFullInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCloudGtmInstanceConfigFullInfo',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the complete configuration information about a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeCloudGtmInstanceConfigFullInfoRequest
 * @return DescribeCloudGtmInstanceConfigFullInfoResponse
 */
async function describeCloudGtmInstanceConfigFullInfo(request: DescribeCloudGtmInstanceConfigFullInfoRequest): DescribeCloudGtmInstanceConfigFullInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudGtmInstanceConfigFullInfoWithOptions(request, runtime);
}

model DescribeCloudGtmMonitorTemplateRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   **zh-CN**: Chinese
*   **en-US** (default): English', example='en-US'),
  templateId?: string(name='TemplateId', description='The ID of the health check template that you want to query. This ID uniquely identifies the health check template.

This parameter is required.', example='mtp-89518052425100**80'),
}

model DescribeCloudGtmMonitorTemplateResponseBody = {
  createTime?: string(name='CreateTime', description='Health check template creation time.', example='2024-03-23T13:09Z'),
  createTimestamp?: long(name='CreateTimestamp', description='Health check template creation time (timestamp).', example='1527690629357'),
  evaluationCount?: int32(name='EvaluationCount', description='Retries count. The system will only judge the application service as abnormal after consecutive monitoring failures to prevent inaccurate monitoring results due to momentary network fluctuations or other reasons. Available retry counts are:
- 1
- 2
- 3', example='2'),
  extendInfo?: string(name='ExtendInfo', description='The extended information. The value of this parameter is a JSON string. The required parameters vary based on the health check protocol.

*   HTTP or HTTPS:

    **host**: the Host field of an HTTP or HTTPS request header during an HTTP or HTTPS health check. The parameter value indicates the HTTP website that you want to visit. By default, the value is the primary domain name. You can change the value based on your business requirements.

    **path**: the URL for HTTP or HTTPS health checks. Default value: /.

    **code**: the alert threshold. During an HTTP or HTTPS health check, the system checks whether a web server functions as expected based on the status code that is returned from the web server. If the returned status code is greater than the specified threshold, the corresponding application service address is deemed abnormal. Valid values:

    *   400: indicates an invalid request. If an HTTP or HTTPS request contains invalid request parameters, a web server returns a status code that is greater than 400. You must specify an exact URL for path if you set code to 400.
    *   500: indicates a server error. If some exceptions occur on a web server, the web server returns a status code that is greater than 500. This value is used by default.

    **sni**: indicates whether Server Name Indication (SNI) is enabled. This parameter is used only when the health check protocol is HTTPS. SNI is an extension to the Transport Layer Security (TLS) protocol, which allows a client to specify the host to be connected when the client sends a TLS handshake request. TLS handshakes occur before any data of HTTP requests is sent. Therefore, SNI enables servers to identify the services that clients are attempting to access before certificates are sent. This allows the servers to present correct certificates to the clients. Valid values:

    *   true: SNI is enabled.
    *   false: SNI is disabled.

    **followRedirect**: indicates whether 3XX redirects are followed. Valid values:

    *   true: 3XX redirects are followed. You are redirected to the destination address if a 3XX status code such as 301, 302, 303, 307, or 308 is returned.
    *   false: 3XX redirects are not followed.

*   ping:

    **packetNum**: the total number of Internet Control Message Protocol (ICMP) packets that are sent to the address for each ping-based health check. Valid values: 20, 50, and 100.

    **packetLossRate**: the ICMP packet loss rate for each ping-based health check. The packet loss rate in a health check can be calculated by using the following formula: Packet loss rate in a health check = (Number of lost packets/Total number of sent ICMP packets)  100%. If the packet loss rate reaches the threshold, an alert is triggered. Valid values: 10, 30, 40, 80, 90, and 100.', example='{\\\\"code\\\\":200,\\\\"path\\\\":\\\\"\\\\\\\\index.htm\\\\",\\\\"host\\\\":\\\\"aliyun.com\\\\"}'),
  failureRate?: int32(name='FailureRate', description='Percentage of selected node probe failures (%), that is, the percentage of abnormal detection points among the total detection points. When the failure ratio exceeds the set threshold, the service address is judged as abnormal. The available failure ratio thresholds are:
- 20
- 50
- 80
- 100', example='50'),
  interval?: int32(name='Interval', description='The time interval (in seconds) between each check, with a default interval of 1 minute. The minimum supported health check interval is 15 seconds, available for flagship edition instances.', example='60'),
  ipVersion?: string(name='IpVersion', description='Detect the type of the node IP address:
- IPv4: Applicable when the target address type is IPv4;
- IPv6: Applicable when the target address type is IPv6.', example='IPv4'),
  ispCityNodes?: {
    ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='City code', example='357'),
      cityName?: string(name='CityName', description='City name', example='Shanghai'),
      countryCode?: string(name='CountryCode', description='Country Code', example='629'),
      countryName?: string(name='CountryName', description='Country Name', example='China'),
      groupName?: string(name='GroupName', description='Probe node group type name', example='BGP Nodes'),
      groupType?: string(name='GroupType', description='Probe node group types:
- BGP: BGP nodes
- OVERSEAS: International nodes
- ISP: Carrier nodes', example='BGP'),
      ispCode?: string(name='IspCode', description='Operator Code', example='465'),
      ispName?: string(name='IspName', description='Operator Name', example='Alibaba'),
    }
  ](name='IspCityNode')
  }(name='IspCityNodes', description='Probe node list, detailed information can be obtained by calling ListCloudGtmMonitorNodes.'),
  name?: string(name='Name', description='The name of the health check probe template, which is recommended to be distinguishable for configuration personnel to differentiate and remember, ideally indicating the health check protocol.', example='Ping-IPv4'),
  protocol?: string(name='Protocol', description='Protocol types to initiate probes to the target IP address:
- ping
- tcp
- http
- https', example='ping'),
  remark?: string(name='Remark', description='Remarks for the health check template.', example='test'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='6AEC7A64-3CB1-4C49-8B35-0B901F1E26BF'),
  templateId?: string(name='TemplateId', description='The ID of the health check template. This ID uniquely identifies the health check template.', example='mtp-89518052425100**80'),
  timeout?: int32(name='Timeout', description='Probe timeout (in milliseconds), data packets not returned within the timeout period are deemed as health check timeouts:
- 2000
- 3000
- 5000
- 10000', example='5000'),
  updateTime?: string(name='UpdateTime', description='Health check template configuration modification time.', example='2024-03-29T13:20Z'),
  updateTimestamp?: long(name='UpdateTimestamp', description='Health check template configuration modification time (timestamp).', example='1527690629357'),
}

model DescribeCloudGtmMonitorTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudGtmMonitorTemplateResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of a health check template.
 *
 * @param request DescribeCloudGtmMonitorTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCloudGtmMonitorTemplateResponse
 */
async function describeCloudGtmMonitorTemplateWithOptions(request: DescribeCloudGtmMonitorTemplateRequest, runtime: Util.RuntimeOptions): DescribeCloudGtmMonitorTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCloudGtmMonitorTemplate',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the configurations of a health check template.
 *
 * @param request DescribeCloudGtmMonitorTemplateRequest
 * @return DescribeCloudGtmMonitorTemplateResponse
 */
async function describeCloudGtmMonitorTemplate(request: DescribeCloudGtmMonitorTemplateRequest): DescribeCloudGtmMonitorTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudGtmMonitorTemplateWithOptions(request, runtime);
}

model DescribeCloudGtmSummaryRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US: English', example='en-US'),
}

model DescribeCloudGtmSummaryResponseBody = {
  instanceTotalCount?: int32(name='InstanceTotalCount', description='The total number of instances within the current account.', example='10'),
  monitorTaskTotalCount?: int32(name='MonitorTaskTotalCount', description='The total number of configured health check tasks.', example='20'),
  monitorTaskTotalQuota?: int32(name='MonitorTaskTotalQuota', description='The quota on the number of health check tasks.', example='101'),
  requestId?: string(name='RequestId', description='The request ID.', example='199C3699-9A7B-41A1-BB5A-F1E862D3CB38'),
}

model DescribeCloudGtmSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudGtmSummaryResponseBody(name='body'),
}

/**
 * @param request DescribeCloudGtmSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCloudGtmSummaryResponse
 */
async function describeCloudGtmSummaryWithOptions(request: DescribeCloudGtmSummaryRequest, runtime: Util.RuntimeOptions): DescribeCloudGtmSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCloudGtmSummary',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeCloudGtmSummaryRequest
 * @return DescribeCloudGtmSummaryResponse
 */
async function describeCloudGtmSummary(request: DescribeCloudGtmSummaryRequest): DescribeCloudGtmSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudGtmSummaryWithOptions(request, runtime);
}

model DescribeCloudGtmSystemLinesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='389DFFA3-77A5-4A9E-BF3D-147C6F98A5BA'),
  systemLines?: {
    systemLine?: [ 
    {
      code?: string(name='Code', description='The line code.', example='aliyun_r_ap-south-1'),
      displayName?: string(name='DisplayName', description='The display name of the line.', example='Default'),
      isAvailable?: boolean(name='IsAvailable', description='Indicates whether the line can be selected as the source of a Domain Name System (DNS) request. Valid values:

*   true
*   false', example='true'),
      name?: string(name='Name', description='The name of the line.', example='Default'),
      parentCode?: string(name='ParentCode', description='The code of the parent line.', example='String	aliyun'),
    }
  ](name='SystemLine')
  }(name='SystemLines', description='The system lines.'),
  systemLinesTree?: string(name='SystemLinesTree', description='The system lines, which are in a tree structure. Only a system line is listed in this example.', example='[{\\\\"displayName\\\\":\\\\"Default\\\\",\\\\"id\\\\":\\\\"default\\\\",\\\\"isAvailable\\\\":true,\\\\"name\\\\":\\\\"Default\\\\",\\\\"parentId\\\\":\\\\"\\\\"}]'),
}

model DescribeCloudGtmSystemLinesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudGtmSystemLinesResponseBody(name='body'),
}

/**
 * @param request DescribeCloudGtmSystemLinesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCloudGtmSystemLinesResponse
 */
async function describeCloudGtmSystemLinesWithOptions(runtime: Util.RuntimeOptions): DescribeCloudGtmSystemLinesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeCloudGtmSystemLines',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeCloudGtmSystemLinesResponse
 */
async function describeCloudGtmSystemLines(): DescribeCloudGtmSystemLinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudGtmSystemLinesWithOptions(runtime);
}

model DescribeCustomLineRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  lineId?: long(name='LineId', description='The unique ID of the custom line. You can call [DescribeCustomLines](https://www.alibabacloud.com/help/en/dns/api-alidns-2015-01-09-describecustomlines?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID', example='597'),
}

model DescribeCustomLineResponseBody = {
  code?: string(name='Code', description='The code of the custom line.', example='hra0yc-597'),
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  id?: long(name='Id', description='The ID/Name of the custom line.', example='597'),
  ipSegmentList?: [ 
    {
      endIp?: string(name='EndIp', description='The end IP address of the CIDR block.', example='11.1.1.3'),
      startIp?: string(name='StartIp', description='The start IP address of the CIDR block.', example='11.1.1.2'),
    }
  ](name='IpSegmentList', description='The CIDR blocks. Separate IP addresses with a hyphen (-). Enter a CIDR block in each row. You can enter 1 to 50 CIDR blocks at a time. If a CIDR block contains only one IP address, enter the IP address in the format of IP1-IP1. Different CIDR blocks cannot be overlapped.'),
  name?: string(name='Name', description='The name of the custom line.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
}

model DescribeCustomLineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCustomLineResponseBody(name='body'),
}

/**
 * @summary Queries the details of a custom line by its unique ID.
 *
 * @param request DescribeCustomLineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCustomLineResponse
 */
async function describeCustomLineWithOptions(request: DescribeCustomLineRequest, runtime: Util.RuntimeOptions): DescribeCustomLineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lineId)) {
    query['LineId'] = request.lineId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCustomLine',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of a custom line by its unique ID.
 *
 * @param request DescribeCustomLineRequest
 * @return DescribeCustomLineResponse
 */
async function describeCustomLine(request: DescribeCustomLineRequest): DescribeCustomLineResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomLineWithOptions(request, runtime);
}

model DescribeCustomLinesRequest {
  domainName?: string(name='DomainName', description='The domain name that already exists in Alibaba Cloud Domain Name System (DNS). You can call the [DescribeDomains ](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0)operation to obtain the domain name.

This parameter is required.', example='example.com'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en', example='en'),
  pageNumber?: long(name='PageNumber', description='The page number.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='10'),
}

model DescribeCustomLinesResponseBody = {
  customLines?: [ 
    {
      code?: string(name='Code', description='The code of the custom line.', example='hra0yc-597'),
      id?: long(name='Id', description='The unique ID of the custom line.', example='597'),
      ipSegmentList?: [ 
        {
          endIp?: string(name='EndIp'),
          startIp?: string(name='StartIp'),
        }
      ](name='IpSegmentList'),
      name?: string(name='Name', description='The name of the custom line.', example='hra0yd-597'),
    }
  ](name='CustomLines', description='The custom lines.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
  totalItems?: int32(name='TotalItems', description='The total number of custom lines.', example='1'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeCustomLinesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCustomLinesResponseBody(name='body'),
}

/**
 * @summary Queries custom lines by domain name.
 *
 * @param request DescribeCustomLinesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCustomLinesResponse
 */
async function describeCustomLinesWithOptions(request: DescribeCustomLinesRequest, runtime: Util.RuntimeOptions): DescribeCustomLinesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCustomLines',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries custom lines by domain name.
 *
 * @param request DescribeCustomLinesRequest
 * @return DescribeCustomLinesResponse
 */
async function describeCustomLines(request: DescribeCustomLinesRequest): DescribeCustomLinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomLinesWithOptions(request, runtime);
}

model DescribeDNSSLBSubDomainsRequest {
  domainName?: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.

This parameter is required.', example='example.com'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   **zh** (default): Chinese
*   **en**: English', example='en'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: **1 to 100**. Default value: **20**.', example='20'),
  rr?: string(name='Rr', description='The hostname.', example='test'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the user account.', example='1.1.1.1'),
}

model DescribeDNSSLBSubDomainsResponseBody = {
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: **1 to 100**. Default value: **20**.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  slbSubDomains?: {
    slbSubDomain?: [ 
    {
      lineAlgorithms?: {
        lineAlgorithm?: [ 
        {
          line?: string(name='Line', description='The DNS resolution line. The line can be China Telecom, China Mobile, and China Unicom.', example='default'),
          open?: boolean(name='Open', description='Indicates whether weighted round-robin is enabled for the line. Valid values:

*   **true** (default): Weighted round-robin is enabled.
*   **false**: Weighted round-robin is disabled.', example='true'),
        }
      ](name='LineAlgorithm')
      }(name='LineAlgorithms', description='The lines for which weighted round-robin is enabled.'),
      open?: boolean(name='Open', description='Indicates whether weighted round-robin is enabled for the subdomain.', example='true'),
      recordCount?: long(name='RecordCount', description='The number of DNS records added for the subdomain.', example='3'),
      subDomain?: string(name='SubDomain', description='The name of the subdomain.', example='www.example.com'),
      type?: string(name='Type', description='The type of the Domain Name System (DNS) record that supports weighted round-robin. Valid values: A, AAAA, and CNAME.', example='A'),
    }
  ](name='SlbSubDomain')
  }(name='SlbSubDomains', description='The subdomains for which weighted round-robin is enabled.'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model DescribeDNSSLBSubDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDNSSLBSubDomainsResponseBody(name='body'),
}

/**
 * @summary Queries the subdomains for which weighted round-robin is enabled based on the specified parameters.
 *
 * @param request DescribeDNSSLBSubDomainsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDNSSLBSubDomainsResponse
 */
async function describeDNSSLBSubDomainsWithOptions(request: DescribeDNSSLBSubDomainsRequest, runtime: Util.RuntimeOptions): DescribeDNSSLBSubDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.rr)) {
    query['Rr'] = request.rr;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDNSSLBSubDomains',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the subdomains for which weighted round-robin is enabled based on the specified parameters.
 *
 * @param request DescribeDNSSLBSubDomainsRequest
 * @return DescribeDNSSLBSubDomainsResponse
 */
async function describeDNSSLBSubDomains(request: DescribeDNSSLBSubDomainsRequest): DescribeDNSSLBSubDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDNSSLBSubDomainsWithOptions(request, runtime);
}

model DescribeDnsCacheDomainsRequest {
  keyword?: string(name='Keyword', description='The keyword for searches in "%KeyWord%" mode. The value is not case-sensitive.', example='a\\\\"\\\\"'),
  lang?: string(name='Lang', description='The language.', example='zh'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Maximum value: **100**. Default value: **20**.', example='20'),
}

model DescribeDnsCacheDomainsResponseBody = {
  domains?: [ 
    {
      cacheTtlMax?: int32(name='CacheTtlMax', description='The maximum time-to-live (TTL) period of the cached data retrieved from the origin DNS server. Unit: seconds. Valid values: 30 to 86400.', example='86400'),
      cacheTtlMin?: int32(name='CacheTtlMin', description='The minimum TTL period of the cached data retrieved from the origin DNS server. Unit: seconds. Valid values: 30 to 86400.', example='30'),
      createTime?: string(name='CreateTime', description='The time when the domain name was added. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2022-10-17T06:13Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The time when the domain name was added. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1660546144000'),
      domainId?: string(name='DomainId', description='The ID of the cache-accelerated domain name.', example='00efd71a-770e-4255-b54e-6fe5659baffe'),
      domainName?: string(name='DomainName', description='The cache-accelerated domain name.', example='dns-example.top'),
      expireTime?: string(name='ExpireTime', description='The time when the instance expires. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2022-12-02T16:00Z'),
      expireTimestamp?: long(name='ExpireTimestamp', description='The time when the instance expires. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1692374400000'),
      instanceId?: string(name='InstanceId', description='The instance ID of the cache-accelerated domain name.', example='i-7bg'),
      remark?: string(name='Remark', description='The description of the domain name.', example='remark'),
      sourceDnsServers?: [ 
        {
          host?: string(name='Host', description='The domain name or IP address of the origin DNS server.', example='ns8.alidns.com'),
          port?: string(name='Port', description='The port of the origin DNS server.', example='53'),
        }
      ](name='SourceDnsServers', description='The origin DNS servers.'),
      sourceEdns?: string(name='SourceEdns', description='Specifies whether the origin Domain Name System (DNS) server supports Extension Mechanisms for DNS (EDNS). Valid values: NOT_SUPPORT and SUPPORT.', example='SUPPORT'),
      sourceProtocol?: string(name='SourceProtocol', description='The origin protocol policy. Valid values: TCP and UDP. Default value: UDP.', example='UDP'),
      updateTime?: string(name='UpdateTime', description='The time when the configurations of the domain name were updated. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2023-05-22T03:40Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The time when the configurations of the domain name were updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1671690491000'),
      versionCode?: string(name='VersionCode', description='The edition code of Alibaba Cloud DNS.', example='ultimate'),
    }
  ](name='Domains', description='The domain names.'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: 1 to 100. Default value: 20.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='57121A9C-CDCF-541F-AD39-275D89099420'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='3'),
}

model DescribeDnsCacheDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsCacheDomainsResponseBody(name='body'),
}

/**
 * @param request DescribeDnsCacheDomainsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDnsCacheDomainsResponse
 */
async function describeDnsCacheDomainsWithOptions(request: DescribeDnsCacheDomainsRequest, runtime: Util.RuntimeOptions): DescribeDnsCacheDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsCacheDomains',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeDnsCacheDomainsRequest
 * @return DescribeDnsCacheDomainsResponse
 */
async function describeDnsCacheDomains(request: DescribeDnsCacheDomainsRequest): DescribeDnsCacheDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsCacheDomainsWithOptions(request, runtime);
}

model DescribeDnsGtmAccessStrategiesRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='instance1'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='1'),
  strategyMode?: string(name='StrategyMode', description='The type of the access policy. Valid values:

*   GEO: geographical location-based
*   LATENCY: latency-based

This parameter is required.', example='geo'),
}

model DescribeDnsGtmAccessStrategiesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0CCC9971-CEC9-4132-824B-4AE611C07623'),
  strategies?: {
    strategy?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the access policy was created.', example='2018-08-09T00:10Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates when the access policy was created.', example='1533773400000'),
      effectiveAddrPoolGroupType?: string(name='EffectiveAddrPoolGroupType', description='The type of the active address pool group. Valid values:

*   DEFAULT: the primary address pool group
*   FAILOVER: the secondary address pool group', example='default'),
      effectiveAddrPoolType?: string(name='EffectiveAddrPoolType', description='The type of the active address pools. Valid values:

*   IPV4
*   IPV6
*   DOMAIN', example='ipv4'),
      effectiveAddrPools?: {
        effectiveAddrPool?: [ 
        {
          addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='3'),
          id?: string(name='Id', description='The ID of the address pool.', example='pool1'),
          lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool.', example='1'),
          name?: string(name='Name', description='The name of the address pool.', example='test'),
        }
      ](name='EffectiveAddrPool')
      }(name='EffectiveAddrPools', description='The active address pool groups.'),
      effectiveLbaStrategy?: string(name='EffectiveLbaStrategy', description='The load balancing policy of the active address pool group. Data is returned when StrategyMode is set to GEO. Valid values: 

- ALL_RR: returns all addresses.
- RATIO: returns addresses by weight.', example='all_rr'),
      lines?: {
        line?: [ 
        {
          groupCode?: string(name='GroupCode', description='The code of the source region group.', example='default'),
          groupName?: string(name='GroupName', description='The name of the source region group.', example='global'),
          lineCode?: string(name='LineCode', description='The line code of the source region.', example='default'),
          lineName?: string(name='LineName', description='The line name of the source region.', example='global'),
        }
      ](name='Line')
      }(name='Lines', description='The source regions. Data is returned when StrategyMode is set to GEO. Valid values:'),
      strategyId?: string(name='StrategyId', description='The ID of the access policy.', example='strategyid1'),
      strategyName?: string(name='StrategyName', description='The name of the access policy.', example='strategname1'),
    }
  ](name='Strategy')
  }(name='Strategies', description='The access policies.'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned on all pages.', example='11'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='11'),
}

model DescribeDnsGtmAccessStrategiesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmAccessStrategiesResponseBody(name='body'),
}

/**
 * @summary Queries access policies of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeDnsGtmAccessStrategiesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDnsGtmAccessStrategiesResponse
 */
async function describeDnsGtmAccessStrategiesWithOptions(request: DescribeDnsGtmAccessStrategiesRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmAccessStrategiesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.strategyMode)) {
    query['StrategyMode'] = request.strategyMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmAccessStrategies',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries access policies of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeDnsGtmAccessStrategiesRequest
 * @return DescribeDnsGtmAccessStrategiesResponse
 */
async function describeDnsGtmAccessStrategies(request: DescribeDnsGtmAccessStrategiesRequest): DescribeDnsGtmAccessStrategiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmAccessStrategiesWithOptions(request, runtime);
}

model DescribeDnsGtmAccessStrategyRequest {
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy.

This parameter is required.', example='strategyId1'),
}

model DescribeDnsGtmAccessStrategyResponseBody = {
  accessMode?: string(name='AccessMode', description='The primary/secondary switchover policy for address pool groups. Valid values:

*   AUTO: performs automatic switchover between the primary and secondary address pool groups upon failures.
*   DEFAULT: uses the primary address pool group.
*   FAILOVER: uses the secondary address pool group.', example='auto'),
  createTime?: string(name='CreateTime', description='The time when the access policy was created.', example='2018-08-09T00:10Z'),
  createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates when the access policy was created.', example='1533773400000'),
  defaultAddrPoolGroupStatus?: string(name='DefaultAddrPoolGroupStatus', description='The status of the primary address pool group. Valid values:

*   AVAILABLE: available
*   NOT_AVAILABLE: unavailable', example='AVAILABLE'),
  defaultAddrPoolType?: string(name='DefaultAddrPoolType', description='The type of the primary address pool. Valid values:

*   IPV4
*   IPV6
*   DOMAIN', example='ipv4'),
  defaultAddrPools?: {
    defaultAddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='1'),
      id?: string(name='Id', description='The ID of the address pool.', example='pool1'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool.', example='1'),
      name?: string(name='Name', description='The name of the address pool.', example='test'),
    }
  ](name='DefaultAddrPool')
  }(name='DefaultAddrPools', description='The address pools in the primary address pool group.'),
  defaultAvailableAddrNum?: int32(name='DefaultAvailableAddrNum', description='The number of available addresses in the primary address pool.', example='1'),
  defaultLatencyOptimization?: string(name='DefaultLatencyOptimization', description='Indicates whether scheduling optimization for latency resolution was enabled for the primary address pool group. Valid values:

*   OPEN: enabled
*   CLOSE: disabled', example='open'),
  defaultLbaStrategy?: string(name='DefaultLbaStrategy', description='The load balancing policy of the primary address pool group. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr'),
  defaultMaxReturnAddrNum?: int32(name='DefaultMaxReturnAddrNum', description='The maximum number of addresses returned from the primary address pool group.', example='1'),
  defaultMinAvailableAddrNum?: int32(name='DefaultMinAvailableAddrNum', description='The minimum number of available addresses in the primary address pool group.', example='1'),
  effectiveAddrPoolGroupType?: string(name='EffectiveAddrPoolGroupType', description='The type of the active address pool group. Valid values:

*   DEFAULT: the primary address pool group
*   FAILOVER: the secondary address pool group', example='DEFAULT'),
  failoverAddrPoolGroupStatus?: string(name='FailoverAddrPoolGroupStatus', description='The status of the secondary address pool group. Valid values:

*   AVAILABLE: available
*   NOT_AVAILABLE: unavailable', example='AVAILABLE'),
  failoverAddrPoolType?: string(name='FailoverAddrPoolType', description='The type of the secondary address pool. Valid values:

*   IPV4
*   IPV6
*   DOMAIN', example='ipv4'),
  failoverAddrPools?: {
    failoverAddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='1'),
      id?: string(name='Id', description='The ID of the address pool.', example='pool1'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool.', example='1'),
      name?: string(name='Name', description='The name of the address pool.', example='test'),
    }
  ](name='FailoverAddrPool')
  }(name='FailoverAddrPools', description='The address pools in the secondary address pool group.'),
  failoverAvailableAddrNum?: int32(name='FailoverAvailableAddrNum', description='The number of available addresses in the secondary address pool.', example='1'),
  failoverLatencyOptimization?: string(name='FailoverLatencyOptimization', description='Indicates whether scheduling optimization for latency resolution was enabled for the secondary address pool group. Valid values:

*   OPEN: enabled
*   CLOSE: disabled', example='open'),
  failoverLbaStrategy?: string(name='FailoverLbaStrategy', description='The load balancing policy of the secondary address pool group. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr'),
  failoverMaxReturnAddrNum?: int32(name='FailoverMaxReturnAddrNum', description='The maximum number of addresses returned from the secondary address pool group.', example='1'),
  failoverMinAvailableAddrNum?: int32(name='FailoverMinAvailableAddrNum', description='The minimum number of available addresses in the secondary address pool group.', example='1'),
  instanceId?: string(name='InstanceId', description='The ID of the associated instance.', example='instance1'),
  lines?: {
    line?: [ 
    {
      groupCode?: string(name='GroupCode', description='The code of the source region group.', example='default'),
      groupName?: string(name='GroupName', description='The name of the source region group.', example='global'),
      lineCode?: string(name='LineCode', description='The line code of the source region.', example='default'),
      lineName?: string(name='LineName', description='The line name of the source region.', example='global'),
    }
  ](name='Line')
  }(name='Lines', description='The source regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BA1608CA-834C-4E63-8682-8AF0B11ED72D'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy.', example='strategyId1'),
  strategyMode?: string(name='StrategyMode', description='The type of the access policy. Valid values:

*   GEO: geographical location-based
*   LATENCY: latency-based', example='geo'),
  strategyName?: string(name='StrategyName', description='The name of the access policy.', example='strategyName1'),
}

model DescribeDnsGtmAccessStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmAccessStrategyResponseBody(name='body'),
}

/**
 * @summary Queries detailed information about an access policy of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeDnsGtmAccessStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDnsGtmAccessStrategyResponse
 */
async function describeDnsGtmAccessStrategyWithOptions(request: DescribeDnsGtmAccessStrategyRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmAccessStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmAccessStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries detailed information about an access policy of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeDnsGtmAccessStrategyRequest
 * @return DescribeDnsGtmAccessStrategyResponse
 */
async function describeDnsGtmAccessStrategy(request: DescribeDnsGtmAccessStrategyRequest): DescribeDnsGtmAccessStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmAccessStrategyWithOptions(request, runtime);
}

model DescribeDnsGtmAccessStrategyAvailableConfigRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='instance1'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  strategyMode?: string(name='StrategyMode', description='The type of the access policy. Valid values:

*   GEO: geographical location-based
*   LATENCY: latency-based

This parameter is required.', example='geo'),
}

model DescribeDnsGtmAccessStrategyAvailableConfigResponseBody = {
  domainAddrPools?: {
    domainAddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='1'),
      id?: string(name='Id', description='The ID of the address pool.', example='pool1'),
      name?: string(name='Name', description='The name of the address pool.', example='testpool'),
    }
  ](name='DomainAddrPool')
  }(name='DomainAddrPools', description='The available address pools of the domain name type.'),
  ipv4AddrPools?: {
    ipv4AddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='1'),
      id?: string(name='Id', description='The ID of the address pool.', example='pool1'),
      name?: string(name='Name', description='The name of the address pool.', example='testpool'),
    }
  ](name='Ipv4AddrPool')
  }(name='Ipv4AddrPools', description='The available address pools of the IPv4 type.'),
  ipv6AddrPools?: {
    ipv6AddrPool?: [ 
    {
      addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='1'),
      id?: string(name='Id', description='The ID of the address pool.', example='pool1'),
      name?: string(name='Name', description='The name of the address pool.', example='testpool'),
    }
  ](name='Ipv6AddrPool')
  }(name='Ipv6AddrPools', description='The available address pools of the IPv6 type.'),
  lines?: {
    line?: [ 
    {
      fatherCode?: string(name='FatherCode', description='The parent line code of the source region. Leave it blank if no parent line exists.', example='telecom'),
      groupCode?: string(name='GroupCode', description='The line name of the source region.', example='default'),
      groupName?: string(name='GroupName', description='The name of the source region group.', example='global'),
      lineCode?: string(name='LineCode', description='The line code of the source region.', example='default'),
      lineName?: string(name='LineName', description='The code of the source region group.', example='global'),
    }
  ](name='Line')
  }(name='Lines', description='The source regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C2851BA9-CE56-49AF-8D12-4FC6A49EE688'),
  selectedDomainLines?: {
    selectedDomainLine?: [ string ](name='SelectedDomainLine')
  }(name='SelectedDomainLines'),
  selectedIpv4Lines?: {
    selectedIpv4Line?: [ string ](name='SelectedIpv4Line')
  }(name='SelectedIpv4Lines'),
  selectedIpv6Lines?: {
    selectedIpv6Line?: [ string ](name='SelectedIpv6Line')
  }(name='SelectedIpv6Lines'),
  suggestSetDefaultLine?: boolean(name='SuggestSetDefaultLine', description='Indicates whether we recommend that you set the source region to global.', example='true'),
}

model DescribeDnsGtmAccessStrategyAvailableConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody(name='body'),
}

/**
 * @summary Queries the available configurations of an access policy of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeDnsGtmAccessStrategyAvailableConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDnsGtmAccessStrategyAvailableConfigResponse
 */
async function describeDnsGtmAccessStrategyAvailableConfigWithOptions(request: DescribeDnsGtmAccessStrategyAvailableConfigRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmAccessStrategyAvailableConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyMode)) {
    query['StrategyMode'] = request.strategyMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmAccessStrategyAvailableConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the available configurations of an access policy of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeDnsGtmAccessStrategyAvailableConfigRequest
 * @return DescribeDnsGtmAccessStrategyAvailableConfigResponse
 */
async function describeDnsGtmAccessStrategyAvailableConfig(request: DescribeDnsGtmAccessStrategyAvailableConfigRequest): DescribeDnsGtmAccessStrategyAvailableConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmAccessStrategyAvailableConfigWithOptions(request, runtime);
}

model DescribeDnsGtmAddrAttributeInfoRequest {
  addrs?: string(name='Addrs', description='The addresses.

This parameter is required.', example='["1.1.1.1"]'),
  lang?: string(name='Lang', description='The language of the values for specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  type?: string(name='Type', description='The type of addresses. Valid values:

*   IPV4: IPv4 address
*   IPv6: IPv6 address
*   DOMAIN: domain name

This parameter is required.', example='ipv4'),
}

model DescribeDnsGtmAddrAttributeInfoResponseBody = {
  addr?: {
    addr?: [ 
    {
      addr?: string(name='Addr', description='The address in the address pool.', example='1.1.1.1'),
      attributeInfo?: {
        fatherCode?: string(name='FatherCode', description='The parent line code of the source region.', example='telecom'),
        groupCode?: string(name='GroupCode', description='The code of the source region group.', example='DEFAULT'),
        groupName?: string(name='GroupName', description='The name of the source region group.', example='Global'),
        lineCode?: string(name='LineCode', description='The line code of the source region.', example='default'),
        lineName?: string(name='LineName', description='The line name of the source region.', example='Global'),
      }(name='AttributeInfo', description='The information about the source region of the address.'),
    }
  ](name='Addr')
  }(name='Addr', description='The address in the address pool.'),
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model DescribeDnsGtmAddrAttributeInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmAddrAttributeInfoResponseBody(name='body'),
}

/**
 * @summary Queries the source regions of addresses.
 *
 * @param request DescribeDnsGtmAddrAttributeInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDnsGtmAddrAttributeInfoResponse
 */
async function describeDnsGtmAddrAttributeInfoWithOptions(request: DescribeDnsGtmAddrAttributeInfoRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmAddrAttributeInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addrs)) {
    query['Addrs'] = request.addrs;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmAddrAttributeInfo',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the source regions of addresses.
 *
 * @param request DescribeDnsGtmAddrAttributeInfoRequest
 * @return DescribeDnsGtmAddrAttributeInfoResponse
 */
async function describeDnsGtmAddrAttributeInfo(request: DescribeDnsGtmAddrAttributeInfoRequest): DescribeDnsGtmAddrAttributeInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmAddrAttributeInfoWithOptions(request, runtime);
}

model DescribeDnsGtmAddressPoolAvailableConfigRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='instance1'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
}

model DescribeDnsGtmAddressPoolAvailableConfigResponseBody = {
  attributeInfos?: {
    attributeInfo?: [ 
    {
      fatherCode?: string(name='FatherCode', description='The parent line code of the source region.', example='telecom'),
      groupCode?: string(name='GroupCode', description='The code of the source region group.', example='default'),
      groupName?: string(name='GroupName', description='The name of the request source group.', example='global'),
      lineCode?: string(name='LineCode', description='The line code of the source region.', example='default'),
      lineName?: string(name='LineName', description='The line name of the source region.', example='global'),
    }
  ](name='AttributeInfo')
  }(name='AttributeInfos', description='The supported source regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='199C3699-9A7B-41A1-BB5A-F1E862D3CB38'),
}

model DescribeDnsGtmAddressPoolAvailableConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmAddressPoolAvailableConfigResponseBody(name='body'),
}

/**
 * @summary Queries the available configurations of an address pool of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeDnsGtmAddressPoolAvailableConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDnsGtmAddressPoolAvailableConfigResponse
 */
async function describeDnsGtmAddressPoolAvailableConfigWithOptions(request: DescribeDnsGtmAddressPoolAvailableConfigRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmAddressPoolAvailableConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmAddressPoolAvailableConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the available configurations of an address pool of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeDnsGtmAddressPoolAvailableConfigRequest
 * @return DescribeDnsGtmAddressPoolAvailableConfigResponse
 */
async function describeDnsGtmAddressPoolAvailableConfig(request: DescribeDnsGtmAddressPoolAvailableConfigRequest): DescribeDnsGtmAddressPoolAvailableConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmAddressPoolAvailableConfigWithOptions(request, runtime);
}

model DescribeDnsGtmAvailableAlertGroupRequest {
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
}

model DescribeDnsGtmAvailableAlertGroupResponseBody = {
  availableAlertGroup?: string(name='AvailableAlertGroup', description='The returned available alert groups.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model DescribeDnsGtmAvailableAlertGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmAvailableAlertGroupResponseBody(name='body'),
}

/**
 * @param request DescribeDnsGtmAvailableAlertGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDnsGtmAvailableAlertGroupResponse
 */
async function describeDnsGtmAvailableAlertGroupWithOptions(request: DescribeDnsGtmAvailableAlertGroupRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmAvailableAlertGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmAvailableAlertGroup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeDnsGtmAvailableAlertGroupRequest
 * @return DescribeDnsGtmAvailableAlertGroupResponse
 */
async function describeDnsGtmAvailableAlertGroup(request: DescribeDnsGtmAvailableAlertGroupRequest): DescribeDnsGtmAvailableAlertGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmAvailableAlertGroupWithOptions(request, runtime);
}

model DescribeDnsGtmInstanceRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance about which you want to query the information.

This parameter is required.', example='instance1'),
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages. Default value: en. Valid values: en, zh, and ja.', example='en'),
}

model DescribeDnsGtmInstanceResponseBody = {
  config?: {
    alertConfig?: {
      alertConfig?: [ 
      {
        dingtalkNotice?: boolean(name='DingtalkNotice'),
        emailNotice?: boolean(name='EmailNotice', description='Indicates whether email notification is configured. Valid values:

*   true: Email notification is configured.
*   false: Email notification is not configured. null: Email notification is not configured.', example='true'),
        noticeType?: string(name='NoticeType', description='The type of the alert event. Valid values:

*   ADDR_ALERT: The address is unavailable.
*   ADDR_RESUME: The address is restored and becomes available.
*   ADDR_POOL_GROUP_UNAVAILABLE: The address pool group is unavailable.
*   ADDR_POOL_GROUP_AVAILABLE: The address pool group is restored and becomes available.
*   ACCESS_STRATEGY_POOL_GROUP_SWITCH: Switchover is triggered between the primary and secondary address pools.
*   MONITOR_NODE_IP_CHANGE: The IP address of the monitoring node has changed.', example='ADDR_ALERT'),
        smsNotice?: boolean(name='SmsNotice', description='Indicates whether SMS notification is configured. Valid values:

*   true: SMS notification is configured.
*   false: SMS notification is not configured. null: SMS notification is not configured.', example='true'),
      }
    ](name='AlertConfig')
    }(name='AlertConfig', description='The alert notification method.'),
    alertGroup?: string(name='AlertGroup', description='The name of the alert group.', example='alertgroup1'),
    cnameType?: string(name='CnameType', description='The type of the CNAME domain name that is used to access the instance. Valid value:

*   PUBLIC: The CNAME domain name is used to access the instance over the Internet.', example='public'),
    instanceName?: string(name='InstanceName', description='The name of the instance.', example='instancetest1'),
    pubicZoneName?: string(name='PubicZoneName', description='The domain name that is used to access the instance over the Internet.', example='test.rr.gtm-003.com'),
    publicCnameMode?: string(name='PublicCnameMode', description='Indicates whether a custom CNAME domain name or a CNAME domain name assigned by the system is used to access the instance over the Internet. Valid values:

*   CUSTOM: A custom CNAME domain name is used.
*   SYSTEM_ASSIGN: A CNAME domain name assigned by the system is used.', example='custom'),
    publicRr?: string(name='PublicRr', description='The hostname corresponding to the CNAME domain name that is used to access the instance over the Internet.', example='test.rr'),
    publicUserDomainName?: string(name='PublicUserDomainName', description='The service domain name that is used over the Internet.', example='example.com'),
    strategyMode?: string(name='StrategyMode', description='The type of the access policy. Valid values:

*   LATENCY: Latency-based
*   GEO: Geographical location-based', example='GEO'),
    ttl?: int32(name='Ttl', description='The global time to live (TTL).', example='1'),
  }(name='Config', description='The configurations of the instance.'),
  createTime?: string(name='CreateTime', description='The time when the instance was created.', example='2020-10-14T06:58Z'),
  createTimestamp?: long(name='CreateTimestamp', description='The UNIX timestamp that indicates when the instance was created.', example='1602656937000'),
  expireTime?: string(name='ExpireTime', description='The time when the instance expires.', example='2020-10-14T06:58Z'),
  expireTimestamp?: long(name='ExpireTimestamp', description='The UNIX timestamp that indicates when the instance expires.', example='1602656937000'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='instanceid1'),
  paymentType?: string(name='PaymentType', description='The billing method. Valid value:

*   Subscription: You can pay in advance for the use of resources.', example='Subscription'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='84314904-D047-4176-A0EC-256D7F68C7F5'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs.', example='resourcegroupid1'),
  smsQuota?: int32(name='SmsQuota', description='The total number of SMS notifications.', example='100'),
  taskQuota?: int32(name='TaskQuota', description='The total number of detection tasks.', example='100'),
  usedQuota?: {
    dingtalkUsedCount?: int32(name='DingtalkUsedCount'),
    emailUsedCount?: int32(name='EmailUsedCount', description='The total number of emails that were sent.', example='123'),
    smsUsedCount?: int32(name='SmsUsedCount', description='The total number of short messages that were sent.', example='123'),
    taskUsedCount?: int32(name='TaskUsedCount', description='The number of detection tasks that were created.', example='123'),
  }(name='UsedQuota', description='The used quota.'),
  versionCode?: string(name='VersionCode', description='The version of the instance.', example='versioncode1'),
}

model DescribeDnsGtmInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmInstanceResponseBody(name='body'),
}

/**
 * @summary Queries detailed information about a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeDnsGtmInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDnsGtmInstanceResponse
 */
async function describeDnsGtmInstanceWithOptions(request: DescribeDnsGtmInstanceRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmInstance',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries detailed information about a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeDnsGtmInstanceRequest
 * @return DescribeDnsGtmInstanceResponse
 */
async function describeDnsGtmInstance(request: DescribeDnsGtmInstanceRequest): DescribeDnsGtmInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmInstanceWithOptions(request, runtime);
}

model DescribeDnsGtmInstanceAddressPoolRequest {
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.

This parameter is required.', example='testpool1'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
}

model DescribeDnsGtmInstanceAddressPoolResponseBody = {
  addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='1'),
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.', example='testpool1'),
  addrs?: {
    addr?: [ 
    {
      addr?: string(name='Addr', description='The address.', example='1.1.1.1'),
      alertStatus?: string(name='AlertStatus', description='The status of the last health check on the address. Valid values:

*   OK: No active alerts are triggered.
*   ALERT: Alerts are triggered based on the alert rules.', example='ok'),
      attributeInfo?: string(name='AttributeInfo', description='The source region of the address.

*   lineCode: the line code of the source region of the address. This parameter is deprecated, and lineCodes prevails.
*   lineName: the line name of the source region of the address. This parameter is deprecated.
*   lineCodes: the line codes of the source regions of the address.', example='"lineCode":"aliyun_r_cn-zhangjiakou", "lineName": "Alibaba Cloud_China (Zhangjiakou)", "lineCodes": ["aliyun_r_cn-zhangjiakou"]'),
      createTime?: string(name='CreateTime', description='The time when the address was added into the address pool.', example='2017-12-28T13:08Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates the time when the address was added into the address pool.', example='1527690629357'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address.', example='1'),
      mode?: string(name='Mode', description='The mode of the address. Valid values:

*   SMART: smart return
*   ONLINE: always online
*   OFFLINE: always offline', example='online'),
      remark?: string(name='Remark', description='The description of the address.', example='test'),
      updateTime?: string(name='UpdateTime', description='The time when the address was last updated.', example='2017-12-28T13:08Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The timestamp that indicates the time when the address was last updated.', example='1527690629357'),
    }
  ](name='Addr')
  }(name='Addrs', description='The addresses in the address pool.'),
  createTime?: string(name='CreateTime', description='The time when the address pool was created.', example='2017-12-28T13:08Z'),
  createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates the time when the address pool was created.', example='1527690629357'),
  lbaStrategy?: string(name='LbaStrategy', description='The load balancing policy for the address pool. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.', example='test1'),
  monitorStatus?: string(name='MonitorStatus', description='Indicates the status of the health check. Valid values:

*   OPEN: The health check is enabled.
*   CLOSE: The health check is disabled.
*   UNCONFIGURED: The health check is not configured.', example='open'),
  name?: string(name='Name', description='The name of the address pool.', example='test'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  type?: string(name='Type', description='The type of the address pool. Valid values:

*   IPV4: IPv4 address
*   IPV6: IPv6 address
*   DOMAIN: domain name', example='ipv4'),
  updateTime?: string(name='UpdateTime', description='The time when the address pool was last updated.', example='2017-12-28T13:08Z'),
  updateTimestamp?: long(name='UpdateTimestamp', description='The timestamp that indicates the time when the address pool was last updated.', example='1527690629357'),
}

model DescribeDnsGtmInstanceAddressPoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmInstanceAddressPoolResponseBody(name='body'),
}

/**
 * @summary Queries detailed information about an address pool of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeDnsGtmInstanceAddressPoolRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDnsGtmInstanceAddressPoolResponse
 */
async function describeDnsGtmInstanceAddressPoolWithOptions(request: DescribeDnsGtmInstanceAddressPoolRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmInstanceAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addrPoolId)) {
    query['AddrPoolId'] = request.addrPoolId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmInstanceAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries detailed information about an address pool of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeDnsGtmInstanceAddressPoolRequest
 * @return DescribeDnsGtmInstanceAddressPoolResponse
 */
async function describeDnsGtmInstanceAddressPool(request: DescribeDnsGtmInstanceAddressPoolRequest): DescribeDnsGtmInstanceAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmInstanceAddressPoolWithOptions(request, runtime);
}

model DescribeDnsGtmInstanceAddressPoolsRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='instance1'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 100. Default value: 20.', example='1'),
}

model DescribeDnsGtmInstanceAddressPoolsResponseBody = {
  addrPools?: {
    addrPool?: [ 
    {
      addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='1'),
      addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.', example='pool-1'),
      createTime?: string(name='CreateTime', description='The time when the address pool was created.', example='2017-12-28T13:08Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates when the address pool was created.', example='1527690629357'),
      lbaStrategy?: string(name='LbaStrategy', description='The load balancing policy of the address pool. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr'),
      monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check task.', example='abc123'),
      monitorStatus?: string(name='MonitorStatus', description='Indicates whether health checks are configured. Valid values:

*   OPEN: enabled
*   CLOSE: disabled
*   UNCONFIGURED: not configured', example='open'),
      name?: string(name='Name', description='The name of the address pool.', example='testpool'),
      type?: string(name='Type', description='The type of the address pool. Valid values:

*   IPV4: IPv4 address
*   IPV6: IPv6 address
*   DOMAIN: domain name', example='ipv4'),
      updateTime?: string(name='UpdateTime', description='The time when the address pool was updated.', example='2017-12-28T13:08Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The timestamp that indicates when the address pool was updated.', example='1527690629357'),
    }
  ](name='AddrPool')
  }(name='AddrPools', description='The returned address pools.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned on all pages.', example='1'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeDnsGtmInstanceAddressPoolsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmInstanceAddressPoolsResponseBody(name='body'),
}

/**
 * @summary Queries the address pools of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeDnsGtmInstanceAddressPoolsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDnsGtmInstanceAddressPoolsResponse
 */
async function describeDnsGtmInstanceAddressPoolsWithOptions(request: DescribeDnsGtmInstanceAddressPoolsRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmInstanceAddressPoolsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmInstanceAddressPools',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the address pools of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeDnsGtmInstanceAddressPoolsRequest
 * @return DescribeDnsGtmInstanceAddressPoolsResponse
 */
async function describeDnsGtmInstanceAddressPools(request: DescribeDnsGtmInstanceAddressPoolsRequest): DescribeDnsGtmInstanceAddressPoolsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmInstanceAddressPoolsWithOptions(request, runtime);
}

model DescribeDnsGtmInstanceStatusRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='instance1'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
}

model DescribeDnsGtmInstanceStatusResponseBody = {
  addrAvailableNum?: int32(name='AddrAvailableNum', description='The number of available addresses.', example='1'),
  addrNotAvailableNum?: int32(name='AddrNotAvailableNum', description='The number of unavailable addresses.', example='1'),
  addrPoolGroupNotAvailableNum?: int32(name='AddrPoolGroupNotAvailableNum', description='The number of unavailable address pool groups.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='389DFFA3-77A5-4A9E-BF3D-147C6F98A5BA'),
  strategyNotAvailableNum?: int32(name='StrategyNotAvailableNum', description='The number of access policies that are unavailable in the current active address pool group.', example='1'),
  switchToFailoverStrategyNum?: int32(name='SwitchToFailoverStrategyNum', description='The number of access policies switched to the secondary address pool group.', example='1'),
}

model DescribeDnsGtmInstanceStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmInstanceStatusResponseBody(name='body'),
}

/**
 * @summary Queries the status of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeDnsGtmInstanceStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDnsGtmInstanceStatusResponse
 */
async function describeDnsGtmInstanceStatusWithOptions(request: DescribeDnsGtmInstanceStatusRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmInstanceStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmInstanceStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the status of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeDnsGtmInstanceStatusRequest
 * @return DescribeDnsGtmInstanceStatusResponse
 */
async function describeDnsGtmInstanceStatus(request: DescribeDnsGtmInstanceStatusRequest): DescribeDnsGtmInstanceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmInstanceStatusWithOptions(request, runtime);
}

model DescribeDnsGtmInstanceSystemCnameRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='instance1'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
}

model DescribeDnsGtmInstanceSystemCnameResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  systemCname?: string(name='SystemCname', description='The CNAME domain name assigned by the system.', example='gtminstance.com'),
}

model DescribeDnsGtmInstanceSystemCnameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmInstanceSystemCnameResponseBody(name='body'),
}

/**
 * @summary Queries the CNAME domain name assigned by the system for a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeDnsGtmInstanceSystemCnameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDnsGtmInstanceSystemCnameResponse
 */
async function describeDnsGtmInstanceSystemCnameWithOptions(request: DescribeDnsGtmInstanceSystemCnameRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmInstanceSystemCnameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmInstanceSystemCname',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the CNAME domain name assigned by the system for a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeDnsGtmInstanceSystemCnameRequest
 * @return DescribeDnsGtmInstanceSystemCnameResponse
 */
async function describeDnsGtmInstanceSystemCname(request: DescribeDnsGtmInstanceSystemCnameRequest): DescribeDnsGtmInstanceSystemCnameResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmInstanceSystemCnameWithOptions(request, runtime);
}

model DescribeDnsGtmInstancesRequest {
  keyword?: string(name='Keyword', description='The keyword that you use for the query. Fuzzy search by instance ID or instance name is supported.', example='instance1'),
  lang?: string(name='Lang', description='The language of the values for specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Maximum value: **100**. Default value: **20**.', example='1'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-testgroupid'),
}

model DescribeDnsGtmInstancesResponseBody = {
  gtmInstances?: [ 
    {
      config?: {
        alertConfig?: [ 
          {
            dingtalkNotice?: string(name='DingtalkNotice', description='Indicates whether DingTalk alert notifications are configured. Valid values:

*   true
*   false | null', example='true'),
            emailNotice?: string(name='EmailNotice', description='Indicates whether email notifications are configured. Valid values:

*   true
*   false | null', example='true'),
            noticeType?: string(name='NoticeType', description='The type of the alert event. Valid values:

*   ADDR_ALERT: The address is unavailable.
*   ADDR_RESUME: The address becomes available.
*   ADDR_POOL_GROUP_UNAVAILABLE: The address pool set is unavailable.
*   ADDR_POOL_GROUP_AVAILABLE: The address pool set becomes available.
*   ACCESS_STRATEGY_POOL_GROUP_SWITCH: Switchover is triggered between the primary and secondary address pools.', example='ADDR_ALERT'),
            smsNotice?: string(name='SmsNotice', description='Indicates whether SMS notifications are configured. Valid values:

*   true
*   false | null', example='true'),
          }
        ](name='AlertConfig', description='The alert notification method.'),
        alertGroup?: string(name='AlertGroup', description='The alert contact groups. The value is in the JSON format.', example='testgroup'),
        cnameType?: string(name='CnameType', description='The type of the CNAME. Valid value:

*   PUBLIC', example='public'),
        instanceName?: string(name='InstanceName', description='The name of the instance.', example='instanceTest'),
        publicCnameMode?: string(name='PublicCnameMode', description='Specifies whether to use a custom CNAME or a system-assigned CNAME to access GTM over the Internet. Valid values:

*   CUSTOM: a custom CNAME
*   SYSTEM_ASSIGN: a system-assigned CNAME. You cannot set PublicCnameMode to this value.', example='custom'),
        publicRr?: string(name='PublicRr', description='The hostname of the domain name that is used to access GTM over the Internet.', example='test.rr'),
        publicUserDomainName?: string(name='PublicUserDomainName', description='The domain name that is used to access GTM over the Internet.', example='example.com'),
        publicZoneName?: string(name='PublicZoneName', description='The canonical name (CNAME) that is used to access GTM over the Internet.', example='test.rr.gtm-003.com'),
        strategyMode?: string(name='StrategyMode', description='The type of the access policy. Valid values:

*   LATENCY: latency-based access policy
*   GEO: geographical location-based access policy', example='geo'),
        ttl?: int32(name='Ttl', description='The global time to live (TTL).', example='1'),
      }(name='Config', description='The configurations of the instance.'),
      createTime?: string(name='CreateTime', description='The time when the instance was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2020-10-14T06:58Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The time when the instance was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1602658709000'),
      expireTime?: string(name='ExpireTime', description='The time when the instance expires. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2020-10-14T06:58Z'),
      expireTimestamp?: long(name='ExpireTimestamp', description='The time when the instance expires. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1602658709000'),
      instanceId?: string(name='InstanceId', description='The instance ID.', example='instance1'),
      paymentType?: string(name='PaymentType', description='The billing method of the GTM instance. Valid value:

*   Subscription.', example='Subscription'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='resourceGroupid123'),
      smsQuota?: int32(name='SmsQuota', description='The total number of Short Message Service (SMS) notifications.', example='1'),
      taskQuota?: int32(name='TaskQuota', description='The total number of detection tasks.', example='1'),
      usedQuota?: {
        dingtalkUsedCount?: int32(name='DingtalkUsedCount', description='The total number of sent DingTalk notifications.', example='100'),
        emailUsedCount?: int32(name='EmailUsedCount', description='The total number of sent email notifications.', example='100'),
        smsUsedCount?: int32(name='SmsUsedCount', description='The total number of sent SMS notifications.', example='100'),
        taskUsedCount?: int32(name='TaskUsedCount', description='The number of created detection tasks.', example='100'),
      }(name='UsedQuota', description='The used quota.'),
      versionCode?: string(name='VersionCode', description='The version of the instance.', example='testVersion1'),
    }
  ](name='GtmInstances', description='The Global Traffic Manager (GTM) instances.'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Maximum value: 100. Default value: 20.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='84314904-D047-4176-A0EC-256D7F68C7F5'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned.', example='100'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='123'),
}

model DescribeDnsGtmInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmInstancesResponseBody(name='body'),
}

/**
 * @summary Queries a list of instances.
 *
 * @param request DescribeDnsGtmInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDnsGtmInstancesResponse
 */
async function describeDnsGtmInstancesWithOptions(request: DescribeDnsGtmInstancesRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmInstances',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of instances.
 *
 * @param request DescribeDnsGtmInstancesRequest
 * @return DescribeDnsGtmInstancesResponse
 */
async function describeDnsGtmInstances(request: DescribeDnsGtmInstancesRequest): DescribeDnsGtmInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmInstancesWithOptions(request, runtime);
}

model DescribeDnsGtmLogsRequest {
  endTimestamp?: long(name='EndTimestamp', description='The timestamp that specifies the end of the time range to query.', example='1516779348000'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='instance1'),
  keyword?: string(name='Keyword', description='The keyword for searches in "%KeyWord%" mode. The value is not case-sensitive.', example='demo'),
  lang?: string(name='Lang', description='The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 100. Default value: 20.', example='1'),
  startTimestamp?: long(name='StartTimestamp', description='The timestamp that specifies the beginning of the time range to query.', example='1516779348000'),
}

model DescribeDnsGtmLogsResponseBody = {
  logs?: {
    log?: [ 
    {
      content?: string(name='Content', description='The formatted message content.', example='addtest-pool-1'),
      entityId?: string(name='EntityId', description='The ID of the object on which the operation was performed.', example='121212'),
      entityName?: string(name='EntityName', description='The name of the object on which the operation was performed.', example='test-pool-1'),
      entityType?: string(name='EntityType', description='The type of the object on which the operation was performed.'),
      id?: long(name='Id', description='The ID of the record.', example='6726'),
      operAction?: string(name='OperAction', description='The operation performed.'),
      operTime?: string(name='OperTime', description='The time when the operation was performed.', example='2018-01-24T07:35Z'),
      operTimestamp?: long(name='OperTimestamp', description='The timestamp of the operation.', example='1516779348000'),
    }
  ](name='Log')
  }(name='Logs', description='The returned logs.'),
  pageNumber?: int32(name='PageNumber', description='The number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='50C60A29-2E93-425A-ABA8-068686E28873'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned on all pages.', example='1'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeDnsGtmLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmLogsResponseBody(name='body'),
}

/**
 * @summary Queries operation logs of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeDnsGtmLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDnsGtmLogsResponse
 */
async function describeDnsGtmLogsWithOptions(request: DescribeDnsGtmLogsRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTimestamp)) {
    query['EndTimestamp'] = request.endTimestamp;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTimestamp)) {
    query['StartTimestamp'] = request.startTimestamp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmLogs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries operation logs of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeDnsGtmLogsRequest
 * @return DescribeDnsGtmLogsResponse
 */
async function describeDnsGtmLogs(request: DescribeDnsGtmLogsRequest): DescribeDnsGtmLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmLogsWithOptions(request, runtime);
}

model DescribeDnsGtmMonitorAvailableConfigRequest {
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
}

model DescribeDnsGtmMonitorAvailableConfigResponseBody = {
  domainIpv4IspCityNodes?: {
    domainIpv4IspCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The city code.', example='503'),
      cityName?: string(name='CityName', description='The display name of the city.', example='Zhangjiakou'),
      defaultSelected?: boolean(name='DefaultSelected', description='Indicates whether the health check node is selected by default.', example='true'),
      groupName?: string(name='GroupName', description='The name of the node group.', example='BGP Nodes'),
      groupType?: string(name='GroupType', description='The type of the node group. Valid values:

*   BGP: BGP node
*   OVERSEAS: node outside the Chinese mainland
*   ISP: ISP node', example='BGP'),
      ips?: {
        ip?: [ string ](name='Ip')
      }(name='Ips', description='The IP addresses of the health check nodes.'),
      ispCode?: string(name='IspCode', description='The ISP code.', example='465'),
      ispName?: string(name='IspName', description='The display name of the ISP.', example='Alibaba'),
    }
  ](name='DomainIpv4IspCityNode')
  }(name='DomainIpv4IspCityNodes', description='The nodes that perform health checks on domain names that use public IPv4 addresses.'),
  domainIpv6IspCityNodes?: {
    domainIpv6IspCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The city code.', example='503'),
      cityName?: string(name='CityName', description='The display name of the city.', example='Zhangjiakou'),
      defaultSelected?: boolean(name='DefaultSelected', description='Indicates whether the health check node is selected by default.', example='false'),
      groupName?: string(name='GroupName', description='The name of the node group.', example='BGP Nodes'),
      groupType?: string(name='GroupType', description='The type of the node group. Valid values:

*   BGP: BGP node
*   OVERSEAS: node outside the Chinese mainland
*   ISP: ISP node', example='BGP'),
      ips?: {
        ip?: [ string ](name='ip')
      }(name='Ips', description='This parameter is not returned.'),
      ispCode?: string(name='IspCode', description='The ISP code.', example='465'),
      ispName?: string(name='IspName', description='The display name of the ISP.', example='Alibaba'),
    }
  ](name='DomainIpv6IspCityNode')
  }(name='DomainIpv6IspCityNodes', description='The nodes that perform health checks on domain names that use public IPv6 addresses.'),
  ipv4IspCityNodes?: {
    ipv4IspCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The city code.', example='503'),
      cityName?: string(name='CityName', description='The display name of the city.', example='Zhangjiakou'),
      defaultSelected?: boolean(name='DefaultSelected', description='Indicates whether the health check node is selected by default.', example='true'),
      groupName?: string(name='GroupName', description='The name of the node group.', example='BGP Nodes'),
      groupType?: string(name='GroupType', description='The type of the node group. Valid values:

*   BGP: Border Gateway Protocol (BGP) node
*   OVERSEAS: node outside the Chinese mainland
*   ISP: ISP node', example='BGP'),
      ips?: {
        ip?: [ string ](name='Ip')
      }(name='Ips', description='The IP addresses of the health check nodes.'),
      ispCode?: string(name='IspCode', description='The Internet service provider (ISP) code.', example='465'),
      ispName?: string(name='IspName', description='The display name of the ISP.', example='Alibaba'),
    }
  ](name='Ipv4IspCityNode')
  }(name='Ipv4IspCityNodes', description='The nodes that perform health checks on public IPv4 addresses.'),
  ipv6IspCityNodes?: {
    ipv6IspCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The city code.', example='503'),
      cityName?: string(name='CityName', description='The display name of the city.', example='Zhangjiakou'),
      defaultSelected?: boolean(name='DefaultSelected', description='Indicates whether the health check node is selected by default.', example='true'),
      groupName?: string(name='GroupName', description='The name of the node group.', example='BGP Nodes'),
      groupType?: string(name='GroupType', description='The type of the node group. Valid values:

*   BGP: BGP node
*   OVERSEAS: node outside the Chinese mainland
*   ISP: ISP node', example='BGP'),
      ips?: {
        ip?: [ string ](name='Ip')
      }(name='Ips', description='This parameter is not returned.'),
      ispCode?: string(name='IspCode', description='The ISP code.', example='465'),
      ispName?: string(name='IspName', description='The display name of the ISP.', example='Alibaba'),
    }
  ](name='Ipv6IspCityNode')
  }(name='Ipv6IspCityNodes', description='The nodes that perform health checks on public IPv6 addresses.'),
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model DescribeDnsGtmMonitorAvailableConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmMonitorAvailableConfigResponseBody(name='body'),
}

/**
 * @summary Queries the configuration items that can be set for a health check task.
 *
 * @param request DescribeDnsGtmMonitorAvailableConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDnsGtmMonitorAvailableConfigResponse
 */
async function describeDnsGtmMonitorAvailableConfigWithOptions(request: DescribeDnsGtmMonitorAvailableConfigRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmMonitorAvailableConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmMonitorAvailableConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the configuration items that can be set for a health check task.
 *
 * @param request DescribeDnsGtmMonitorAvailableConfigRequest
 * @return DescribeDnsGtmMonitorAvailableConfigResponse
 */
async function describeDnsGtmMonitorAvailableConfig(request: DescribeDnsGtmMonitorAvailableConfigRequest): DescribeDnsGtmMonitorAvailableConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmMonitorAvailableConfigWithOptions(request, runtime);
}

model DescribeDnsGtmMonitorConfigRequest {
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check task.

This parameter is required.', example='MonitorConfigId1'),
}

model DescribeDnsGtmMonitorConfigResponseBody = {
  createTime?: string(name='CreateTime', description='The time when the health check configuration was created. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2017-12-28T13:08Z'),
  createTimestamp?: long(name='CreateTimestamp', description='The time when the health check configuration was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1527690629357'),
  evaluationCount?: int32(name='EvaluationCount', description='The number of consecutive failures.', example='1'),
  interval?: int32(name='Interval', description='The health check interval. Unit: seconds.', example='1'),
  ispCityNodes?: {
    ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The city code.', example='572'),
      cityName?: string(name='CityName', description='The display name of the city.', example='Qingdao'),
      countryCode?: string(name='CountryCode', description='The code of the country or region.', example='001'),
      countryName?: string(name='CountryName', description='The display name of the country or region.', example='China'),
      ispCode?: string(name='IspCode', description='The Internet service provider (ISP) code.', example='123'),
      ispName?: string(name='IspName', description='The display name of the ISP.', example='Alibaba'),
    }
  ](name='IspCityNode')
  }(name='IspCityNodes', description='The health check nodes.'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.', example='MonitorConfigId1'),
  monitorExtendInfo?: string(name='MonitorExtendInfo', description='The extended information. The required parameters vary based on the value of ProtocolType.

*   HTTP or HTTPS

    *   port: the port that you want to check

    *   host: the host settings

    *   path: the URL path

    *   code: the response code. The health check result is deemed abnormal if the returned value is greater than the specified value.

    *   failureRate: the failure rate

    *   sni: specifies whether to enable server name indication (SNI). This parameter is available only when ProtocolType is set to HTTPS. Valid values:

        *   true: enables SNI.
        *   false: disables SNI.

    *   nodeType: the type of the node for monitoring when the address pool type is domain name. Valid values:

        *   IPV4
        *   IPV6

*   PING:

    *   failureRate: the failure rate

    *   packetNum: the number of ping packets

    *   packetLossRate: the loss rate of ping packets

    *   nodeType: the type of the node for monitoring when the address pool type is domain name. Valid values:

        *   IPV4
        *   IPV6

*   TCP

    *   port: the port that you want to check

    *   failureRate: the failure rate

    *   nodeType: the type of the node for monitoring when the address pool type is domain name. Valid values:

        *   IPV4
        *   IPV6', example='{\\\\"code\\\\":200,\\\\"path\\\\":\\\\"\\\\\\\\index.htm\\\\",\\\\"host\\\\":\\\\"aliyun.com\\\\"}'),
  protocolType?: string(name='ProtocolType', description='The health check protocol. Valid values:

*   HTTP
*   HTTPS
*   PING
*   TCP', example='http'),
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  timeout?: int32(name='Timeout', description='The timeout period. Unit: milliseconds.', example='3000'),
  updateTime?: string(name='UpdateTime', description='The time when the health check configuration was updated. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2018-01-03T08:57Z'),
  updateTimestamp?: long(name='UpdateTimestamp', description='The time when the health check configuration was updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1527690629357'),
}

model DescribeDnsGtmMonitorConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsGtmMonitorConfigResponseBody(name='body'),
}

/**
 * @summary Queries the health check configuration of an address pool.
 *
 * @param request DescribeDnsGtmMonitorConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDnsGtmMonitorConfigResponse
 */
async function describeDnsGtmMonitorConfigWithOptions(request: DescribeDnsGtmMonitorConfigRequest, runtime: Util.RuntimeOptions): DescribeDnsGtmMonitorConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.monitorConfigId)) {
    query['MonitorConfigId'] = request.monitorConfigId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsGtmMonitorConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the health check configuration of an address pool.
 *
 * @param request DescribeDnsGtmMonitorConfigRequest
 * @return DescribeDnsGtmMonitorConfigResponse
 */
async function describeDnsGtmMonitorConfig(request: DescribeDnsGtmMonitorConfigRequest): DescribeDnsGtmMonitorConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsGtmMonitorConfigWithOptions(request, runtime);
}

model DescribeDnsProductInstanceRequest {
  instanceId?: string(name='InstanceId', description='The ID of the DNS instance. . You can call the [DescribeDomainInfo](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomaininfo?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.

This parameter is required.', example='i-8fxxxx'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en', example='en'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0'),
}

model DescribeDnsProductInstanceResponseBody = {
  autoRenewal?: boolean(name='AutoRenewal', description='Indicates whether auto-renewal was enabled. Valid values:

*   true: Auto-renewal was enabled.
*   false: Auto-renewal was not enabled.', example='true'),
  bindCount?: long(name='BindCount', description='The number of times that you can change the domain names that are bound to the paid Alibaba Cloud DNS instance. This parameter applies to Alibaba Cloud DNS instances of the custom edition.', example='3'),
  bindDomainCount?: long(name='BindDomainCount', description='The number of domain names that can be bound to the paid Alibaba Cloud DNS instance. This parameter applies to Alibaba Cloud DNS instances of Personal Edition, Enterprise Standard Edition, and Enterprise Ultimate Edition.', example='5'),
  bindDomainUsedCount?: long(name='BindDomainUsedCount', description='The number of domain names that are bound to the paid Alibaba Cloud DNS instance. This parameter applies to Alibaba Cloud DNS instances of Personal Edition, Enterprise Standard Edition, and Enterprise Ultimate Edition.', example='3'),
  bindUsedCount?: long(name='BindUsedCount', description='The number of times that you have changed the domain names that are bound to the paid Alibaba Cloud DNS instance. This parameter applies to Alibaba Cloud DNS instances of the custom edition.', example='1'),
  DDosDefendFlow?: long(name='DDosDefendFlow', description='The DDoS protection traffic. Unit: GB.', example='50'),
  DDosDefendQuery?: long(name='DDosDefendQuery', description='The DDoS protection frequency. Unit: 10,000 QPS. This parameter applies to Alibaba Cloud DNS instances of the custom edition.', example='50'),
  dnsSLBCount?: long(name='DnsSLBCount', description='The maximum number of IP addresses that are used for load balancing in a single line of a domain name.', example='15'),
  dnsSecurity?: string(name='DnsSecurity', description='The level of DNS protection. Valid values:

*   no: No DNS protection is provided.
*   basic: Basic DNS protection is provided.
*   advanced: Advanced DNS protection is provided.', example='advanced'),
  dnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='DnsServers', description='The DNS servers configured for the domain names.'),
  domain?: string(name='Domain', description='The domain name that is bound to the paid instance.

If no value is returned for this parameter, no domain name is bound to the paid instance.', example='example.com'),
  domainType?: string(name='DomainType', description='The type of the instance. Valid values:

*   PUBLIC: authoritative domain name
*   CACHE: cache-accelerated domain name', example='PUBLIC'),
  endTime?: string(name='EndTime', description='The time when the instance expired. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2015-12-12T09:23Z'),
  endTimestamp?: long(name='EndTimestamp', description='The time when the instance expired. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1474335170000'),
  gslb?: boolean(name='Gslb', description='Indicates whether global server load balancing (GSLB) is supported. Valid values:

*   true: GSLB is supported.
*   false: GSLB is not supported.', example='true'),
  ISPLines?: string(name='ISPLines', description='The ISP resolution lines. Valid values:

*   China Telecom
*   China Mobile
*   China Unicom
*   China Education and Research Network (CERNET)
*   China Broadcasting Network (CBN)
*   Dr Peng Telecom & Media Group'),
  ISPRegionLines?: string(name='ISPRegionLines', description='The regional ISP resolution lines. Valid values:

*   China Telecom (province)
*   China Mobile (province)
*   China Unicom (province)
*   CERNET (province)'),
  inBlackHole?: boolean(name='InBlackHole', description='Indicates whether the Domain Name System (DNS) servers stopped responding to all DNS requests. Valid values:

*   true: The DNS servers stopped responding to all DNS requests.
*   false: The DNS servers did not stop responding to all DNS requests.', example='false'),
  inClean?: boolean(name='InClean', description='Indicates whether the DNS servers stopped responding to abnormal requests sent to the domain names.

*   true: The DNS servers stopped responding to abnormal requests sent to the domain names.
*   false: The DNS servers did not stop responding to abnormal requests sent to the domain names.', example='false'),
  instanceId?: string(name='InstanceId', description='The ID of the Alibaba Cloud DNS instance.', example='i-8fxxx'),
  monitorFrequency?: long(name='MonitorFrequency', description='The interval at which the instance is monitored. Unit: minutes.', example='50'),
  monitorNodeCount?: long(name='MonitorNodeCount', description='The number of monitoring nodes.', example='5'),
  monitorTaskCount?: long(name='MonitorTaskCount', description='The number of monitoring tasks.', example='2'),
  overseaDDosDefendFlow?: long(name='OverseaDDosDefendFlow', description='The DDoS protection traffic outside the Chinese mainland. Unit: GB.', example='1'),
  overseaLine?: string(name='OverseaLine', description='The line outside the Chinese mainland.'),
  paymentType?: string(name='PaymentType', description='The billing method.', example='Subscription'),
  regionLines?: boolean(name='RegionLines', description='Indicates whether the DNS request lines are regional lines. Valid values:

*   true: The DNS request lines are regional lines.
*   false: The DNS request lines are not regional lines.', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  searchEngineLines?: string(name='SearchEngineLines', description='The search engine resolution lines. Valid values:

*   Google
*   Baidu
*   Bing
*   Youdao'),
  startTime?: string(name='StartTime', description='The time when the instance was purchased. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2015-12-12T09:23Z'),
  startTimestamp?: long(name='StartTimestamp', description='The time when the instance was purchased. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1474335170000'),
  subDomainLevel?: long(name='SubDomainLevel', description='The number of subdomain name levels.', example='6'),
  TTLMinValue?: long(name='TTLMinValue', description='The minimum time-to-live (TTL) period. Unit: seconds.', example='10'),
  URLForwardCount?: long(name='URLForwardCount', description='The number of the forwarded URLs.', example='20'),
  versionCode?: string(name='VersionCode', description='The version code of Alibaba Cloud DNS.', example='version1'),
  versionName?: string(name='VersionName', description='The edition of Alibaba Cloud DNS.'),
}

model DescribeDnsProductInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsProductInstanceResponseBody(name='body'),
}

/**
 * @summary Queries the details about a paid Alibaba Cloud DNS instance based on the instance ID.
 *
 * @param request DescribeDnsProductInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDnsProductInstanceResponse
 */
async function describeDnsProductInstanceWithOptions(request: DescribeDnsProductInstanceRequest, runtime: Util.RuntimeOptions): DescribeDnsProductInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsProductInstance',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details about a paid Alibaba Cloud DNS instance based on the instance ID.
 *
 * @param request DescribeDnsProductInstanceRequest
 * @return DescribeDnsProductInstanceResponse
 */
async function describeDnsProductInstance(request: DescribeDnsProductInstanceRequest): DescribeDnsProductInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsProductInstanceWithOptions(request, runtime);
}

model DescribeDnsProductInstancesRequest {
  direction?: string(name='Direction', description='The order in which you want to sort returned entries. Valid values:

*   DESC: Returned entries are sorted in descending order. If this parameter is left empty, returned entries are sorted in descending order by default.
*   ASC: Returned entries are sorted in ascending order.', example='DESC'),
  domainType?: string(name='DomainType', description='The type of the domain name. Valid values:

*   PUBLIC (default): hosted public domain name
*   CACHE: cached public domain name', example='PUBLIC'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en', example='en'),
  orderBy?: string(name='OrderBy', description='The method that is used to sort returned entries. Valid values:

*   createDate: sorts returned entries by creation time. If this parameter is left empty, returned entries are sorted by creation time by default.
*   expireDate: sorts returned entries by expiration time.', example='createDate'),
  pageNumber?: long(name='PageNumber', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page. Maximum value: **100**. Default value: **20**.', example='20'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0'),
  versionCode?: string(name='VersionCode', description='The version code of the Alibaba Cloud DNS instance.', example='version1'),
}

model DescribeDnsProductInstancesResponseBody = {
  dnsProducts?: {
    dnsProduct?: [ 
    {
      autoRenewal?: boolean(name='AutoRenewal', description='Indicates whether auto-renewal was enabled. Valid values:

*   true: Auto-renewal was enabled.
*   false: Auto-renewal was not enabled.', example='true'),
      bindCount?: long(name='BindCount', description='The number of times you can change domain names that are bound to the DNS instance. It can be specified by the user who uses Alibaba Cloud DNS of the custom version.', example='3'),
      bindDomainCount?: long(name='BindDomainCount', description='The number of domain names that can be bound to the DNS instance.', example='5'),
      bindDomainUsedCount?: long(name='BindDomainUsedCount', description='The number of domain names that have been bound to the DNS instance.', example='3'),
      bindUsedCount?: long(name='BindUsedCount', description='The number of times you have changed domain names that are bound to the DNS instance. It can be specified by the user who uses Alibaba Cloud DNS of the custom version.', example='1'),
      DDosDefendFlow?: long(name='DDosDefendFlow', description='The DDoS protection traffic. Unit: GB.', example='50'),
      DDosDefendQuery?: long(name='DDosDefendQuery', description='The DDoS protection frequency. Unit: 10,000 QPS.', example='50'),
      dnsSLBCount?: long(name='DnsSLBCount', description='The number of IP addresses supported by a domain name or line.', example='15'),
      dnsSecurity?: string(name='DnsSecurity', description='The level of DNS protection. Valid values:

*   no: No DNS protection is provided.
*   basic: Basic DNS protection is provided.
*   advanced: Advanced DNS protection is provided.', example='no'),
      domain?: string(name='Domain', description='The bound domain name.', example='example.com'),
      endTime?: string(name='EndTime', description='The time at which the instance expired.', example='2015-12-12T00:00Z'),
      endTimestamp?: long(name='EndTimestamp', description='The UNIX timestamp representing the expiration time of the instance.', example='1474335170000'),
      gslb?: boolean(name='Gslb', description='Indicates whether global server load balancing (GSLB) is supported.

*   true: GSLB is supported.
*   false: GSLB is not supported.', example='true'),
      ISPLines?: string(name='ISPLines', description='The ISP resolution lines.

*   China Telecom
*   China Mobile
*   China Unicom
*   CERNET
*   China Broadcasting Network (CBN)
*   Dr Peng Telecom & Media Group', example='China Mobile,China Unicom,China Telecom,China Edu'),
      ISPRegionLines?: string(name='ISPRegionLines', description='The regional ISP resolution lines. Valid values:

*   China Telecom (province)
*   China Mobile (province)
*   China Unicom (province)
*   China Education and Research Network (CERNET) (province)', example='Telecom (Province), Mobile (Province), Unicom (Province), Education Network (Province)'),
      inBlackHole?: boolean(name='InBlackHole', description='Indicates whether the Domain Name System (DNS) servers stopped responding to all requests. Valid values:

*   true: The DNS servers stopped responding to all requests.
*   false: The DNS servers did not stop responding to all requests.', example='false'),
      inClean?: boolean(name='InClean', description='Indicates whether the request for domain name resolution was being cleared.', example='false'),
      instanceId?: string(name='InstanceId', description='The ID of the Alibaba Cloud DNS instance.', example='i-8fj'),
      monitorFrequency?: long(name='MonitorFrequency', description='The monitoring frequency. Unit: minutes.', example='50'),
      monitorNodeCount?: long(name='MonitorNodeCount', description='The number of monitored nodes.', example='5'),
      monitorTaskCount?: long(name='MonitorTaskCount', description='The number of monitoring tasks.', example='2'),
      overseaDDosDefendFlow?: long(name='OverseaDDosDefendFlow', description='DDoS protection traffic outside China. Unit: GB.', example='1'),
      overseaLine?: string(name='OverseaLine', description='The type of the overseas line.', example='Countries'),
      paymentType?: string(name='PaymentType', description='The billing method.', example='Subscription'),
      regionLines?: boolean(name='RegionLines', description='Indicates whether the DNS request lines are regional lines.

*   true: The DNS request lines are regional lines.
*   false: The DNS request lines are not regional lines.', example='true'),
      searchEngineLines?: string(name='SearchEngineLines', description='The search engine resolution lines. Valid values:

*   Google
*   Baidu
*   Bing
*   Youdao', example='Search Engine Robots,Google Robots,Baidu Robots,Bing Robots'),
      startTime?: string(name='StartTime', description='The time when the DNS instance was purchased.', example='2015-11-12T09:23Z'),
      startTimestamp?: long(name='StartTimestamp', description='The UNIX timestamp representing when the DNS instance was purchased.', example='1474335170000'),
      subDomainLevel?: long(name='SubDomainLevel', description='The number of subdomain name levels.', example='6'),
      TTLMinValue?: long(name='TTLMinValue', description='The minimum TTL. Unit: seconds.', example='10'),
      URLForwardCount?: long(name='URLForwardCount', description='The URL forwarding quantity.', example='20'),
      versionCode?: string(name='VersionCode', description='The version code of the Alibaba Cloud DNS instance.', example='version1'),
      versionName?: string(name='VersionName', description='The version name of the Alibaba Cloud DNS instance.', example='Alibaba Cloud DNS'),
    }
  ](name='DnsProduct')
  }(name='DnsProducts', description='The paid Alibaba Cloud DNS instances.'),
  domainType?: string(name='DomainType', description='The type of the domain name. Valid values:

*   PUBLIC (default): hosted public domain name
*   CACHE: cached public domain name', example='PUBLIC'),
  pageNumber?: long(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries returned per page.', example='2'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: long(name='TotalCount', description='The total number of domain names.', example='2'),
}

model DescribeDnsProductInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDnsProductInstancesResponseBody(name='body'),
}

/**
 * @summary Calls the DescribeDnsProductInstances operation to query the list of paid Alibaba Cloud DNS instances based on input parameters.
 *
 * @description >  If the response parameters of an Alibaba Cloud DNS instance do not contain domain names, no domain names are bound to the instance.
 *
 * @param request DescribeDnsProductInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDnsProductInstancesResponse
 */
async function describeDnsProductInstancesWithOptions(request: DescribeDnsProductInstancesRequest, runtime: Util.RuntimeOptions): DescribeDnsProductInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.domainType)) {
    query['DomainType'] = request.domainType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  if (!Util.isUnset(request.versionCode)) {
    query['VersionCode'] = request.versionCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDnsProductInstances',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Calls the DescribeDnsProductInstances operation to query the list of paid Alibaba Cloud DNS instances based on input parameters.
 *
 * @description >  If the response parameters of an Alibaba Cloud DNS instance do not contain domain names, no domain names are bound to the instance.
 *
 * @param request DescribeDnsProductInstancesRequest
 * @return DescribeDnsProductInstancesResponse
 */
async function describeDnsProductInstances(request: DescribeDnsProductInstancesRequest): DescribeDnsProductInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDnsProductInstancesWithOptions(request, runtime);
}

model DescribeDohAccountStatisticsRequest {
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the YYYY-MM-DD format.

The default value is the day when you perform the operation.', example='2019-07-04'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.

You can query only the DNS records of the latest 90 days.`The value of StartDate must be greater than or equal to the difference between the current date and 90`.', example='2019-07-04'),
}

model DescribeDohAccountStatisticsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0F32959D-417B-4D66-8463-68606605E3E2'),
  statistics?: [ 
    {
      timestamp?: long(name='Timestamp', description='The timestamp.', example='1544976000000'),
      totalCount?: long(name='TotalCount', description='The total number of requests.', example='3141592653'),
      v4HttpCount?: long(name='V4HttpCount', description='The number of IPv4-based HTTP requests.', example='3141592653'),
      v4HttpsCount?: long(name='V4HttpsCount', description='The number of IPv4-based HTTPS requests.', example='3141592653'),
      v6HttpCount?: long(name='V6HttpCount', description='The number of IPv6-based HTTP requests.', example='3141592653'),
      v6HttpsCount?: long(name='V6HttpsCount', description='The number of IPv6-based HTTPS requests.', example='3141592653'),
    }
  ](name='Statistics', description='The statistics list.'),
}

model DescribeDohAccountStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDohAccountStatisticsResponseBody(name='body'),
}

/**
 * @param request DescribeDohAccountStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDohAccountStatisticsResponse
 */
async function describeDohAccountStatisticsWithOptions(request: DescribeDohAccountStatisticsRequest, runtime: Util.RuntimeOptions): DescribeDohAccountStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDohAccountStatistics',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeDohAccountStatisticsRequest
 * @return DescribeDohAccountStatisticsResponse
 */
async function describeDohAccountStatistics(request: DescribeDohAccountStatisticsRequest): DescribeDohAccountStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDohAccountStatisticsWithOptions(request, runtime);
}

model DescribeDohDomainStatisticsRequest {
  domainName?: string(name='DomainName', description='The domain name.

This parameter is required.', example='example.com'),
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the YYYY-MM-DD format.

The default value is the day when you perform the operation.', example='2019-07-04'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.

You can query only the DNS records of the latest 90 days. `The value of StartDate must be greater than or equal to the difference between the current date and 90`.', example='2019-07-04'),
}

model DescribeDohDomainStatisticsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0F32959D-417B-4D66-8463-68606605E3E2'),
  statistics?: [ 
    {
      timestamp?: long(name='Timestamp', description='The timestamp.', example='1544976000000'),
      totalCount?: long(name='TotalCount', description='The total number of requests.', example='3141592653'),
      v4HttpCount?: long(name='V4HttpCount', description='The number of IPv4-based HTTP requests.', example='3141592653'),
      v4HttpsCount?: long(name='V4HttpsCount', description='The number of IPv4-based HTTPS requests.', example='3141592653'),
      v6HttpCount?: long(name='V6HttpCount', description='The number of IPv6-based HTTP requests.', example='3141592653'),
      v6HttpsCount?: long(name='V6HttpsCount', description='The number of IPv6-based HTTPS requests.', example='3141592653'),
    }
  ](name='Statistics', description='The statistics list.'),
}

model DescribeDohDomainStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDohDomainStatisticsResponseBody(name='body'),
}

/**
 * @param request DescribeDohDomainStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDohDomainStatisticsResponse
 */
async function describeDohDomainStatisticsWithOptions(request: DescribeDohDomainStatisticsRequest, runtime: Util.RuntimeOptions): DescribeDohDomainStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDohDomainStatistics',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeDohDomainStatisticsRequest
 * @return DescribeDohDomainStatisticsResponse
 */
async function describeDohDomainStatistics(request: DescribeDohDomainStatisticsRequest): DescribeDohDomainStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDohDomainStatisticsWithOptions(request, runtime);
}

model DescribeDohDomainStatisticsSummaryRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the YYYY-MM-DD format.

The default value is the day when you perform the operation.', example='2019-07-04'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 100. Default value: 20.', example='20'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.

You can query only the DNS records of the last 90 days. `The value of StartDate must be greater than or equal to the difference between the current date and 90`.', example='2019-07-04'),
}

model DescribeDohDomainStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0F32959D-417B-4D66-8463-68606605E3E2'),
  statistics?: [ 
    {
      domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
      httpCount?: long(name='HttpCount', description='The number of HTTP requests.', example='3141592653'),
      httpsCount?: long(name='HttpsCount', description='The number of HTTPS requests.', example='3141592653'),
      ipCount?: long(name='IpCount', description='The number of IP addresses.', example='20'),
      totalCount?: long(name='TotalCount', description='The total number of requests.', example='14141592653'),
      v4HttpCount?: long(name='V4HttpCount', description='The number of IPv4-based HTTP requests.', example='3141592653'),
      v4HttpsCount?: long(name='V4HttpsCount', description='The number of IPv4-based HTTPS requests.', example='3141592653'),
      v6HttpCount?: long(name='V6HttpCount', description='The number of IPv6-based HTTP requests.', example='3141592653'),
      v6HttpsCount?: long(name='V6HttpsCount', description='The number of IPv6-based HTTPS requests.', example='3141592653'),
    }
  ](name='Statistics', description='The statistics list.'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned.', example='300'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='50'),
}

model DescribeDohDomainStatisticsSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDohDomainStatisticsSummaryResponseBody(name='body'),
}

/**
 * @param request DescribeDohDomainStatisticsSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDohDomainStatisticsSummaryResponse
 */
async function describeDohDomainStatisticsSummaryWithOptions(request: DescribeDohDomainStatisticsSummaryRequest, runtime: Util.RuntimeOptions): DescribeDohDomainStatisticsSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDohDomainStatisticsSummary',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeDohDomainStatisticsSummaryRequest
 * @return DescribeDohDomainStatisticsSummaryResponse
 */
async function describeDohDomainStatisticsSummary(request: DescribeDohDomainStatisticsSummaryRequest): DescribeDohDomainStatisticsSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDohDomainStatisticsSummaryWithOptions(request, runtime);
}

model DescribeDohSubDomainStatisticsRequest {
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the YYYY-MM-DD format.

The default value is the day when you perform the operation.', example='2019-07-04'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.

You can query only the DNS records of the latest 90 days. `The value of StartDate must be greater than or equal to the difference between the current date and 90`.', example='2019-07-04'),
  subDomain?: string(name='SubDomain', description='The subdomain whose statistics you want to query.

This parameter is required.', example='www.example.com'),
}

model DescribeDohSubDomainStatisticsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0F32959D-417B-4D66-8463-68606605E3E2'),
  statistics?: [ 
    {
      timestamp?: long(name='Timestamp', description='The timestamp.', example='1544976000000'),
      totalCount?: long(name='TotalCount', description='The total number of requests.', example='3141592653'),
      v4HttpCount?: long(name='V4HttpCount', description='The number of IPv4-based HTTP requests.', example='3141592653'),
      v4HttpsCount?: long(name='V4HttpsCount', description='The number of IPv4-based HTTPS requests.', example='3141592653'),
      v6HttpCount?: long(name='V6HttpCount', description='The number of IPv6-based HTTP requests.', example='3141592653'),
      v6HttpsCount?: long(name='V6HttpsCount', description='The number of IPv6-based HTTPS requests.', example='3141592653'),
    }
  ](name='Statistics', description='The statistics list.'),
}

model DescribeDohSubDomainStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDohSubDomainStatisticsResponseBody(name='body'),
}

/**
 * @param request DescribeDohSubDomainStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDohSubDomainStatisticsResponse
 */
async function describeDohSubDomainStatisticsWithOptions(request: DescribeDohSubDomainStatisticsRequest, runtime: Util.RuntimeOptions): DescribeDohSubDomainStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.subDomain)) {
    query['SubDomain'] = request.subDomain;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDohSubDomainStatistics',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeDohSubDomainStatisticsRequest
 * @return DescribeDohSubDomainStatisticsResponse
 */
async function describeDohSubDomainStatistics(request: DescribeDohSubDomainStatisticsRequest): DescribeDohSubDomainStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDohSubDomainStatisticsWithOptions(request, runtime);
}

model DescribeDohSubDomainStatisticsSummaryRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the YYYY-MM-DD format.

The default value is the day when you query the required data.', example='2019-07-04'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 100. Default value: 20.', example='20'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.

You can query only the DNS records of the last 90 days. `The value of StartDate must be greater than or equal to the difference between the current date and 90`.', example='2019-07-04'),
  subDomain?: string(name='SubDomain', description='The subdomain.', example='www.example.com'),
}

model DescribeDohSubDomainStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0F32959D-417B-4D66-8463-68606605E3E2'),
  statistics?: [ 
    {
      httpCount?: long(name='HttpCount', description='The number of HTTP requests.', example='3141592653'),
      httpsCount?: long(name='HttpsCount', description='The number of HTTPS requests.', example='3141592653'),
      ipCount?: long(name='IpCount', description='The number of IP addresses.', example='20'),
      subDomain?: string(name='SubDomain', description='The subdomain.', example='www.example.com'),
      totalCount?: long(name='TotalCount', description='Total number of requests.', example='14141592653'),
      v4HttpCount?: long(name='V4HttpCount', description='The number of IPv4-based HTTP requests.', example='3141592653'),
      v4HttpsCount?: long(name='V4HttpsCount', description='The number of IPv4-based HTTPS requests.', example='3141592653'),
      v6HttpCount?: long(name='V6HttpCount', description='The number of IPv6-based HTTP requests.', example='3141592653'),
      v6HttpsCount?: long(name='V6HttpsCount', description='The number of IPv6-based HTTPS requests.', example='3141592653'),
    }
  ](name='Statistics', description='The statistics list.'),
  totalItems?: int32(name='TotalItems', description='Total number of entries returned.', example='100'),
  totalPages?: int32(name='TotalPages', description='Total number of pages returned.', example='50'),
}

model DescribeDohSubDomainStatisticsSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDohSubDomainStatisticsSummaryResponseBody(name='body'),
}

/**
 * @param request DescribeDohSubDomainStatisticsSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDohSubDomainStatisticsSummaryResponse
 */
async function describeDohSubDomainStatisticsSummaryWithOptions(request: DescribeDohSubDomainStatisticsSummaryRequest, runtime: Util.RuntimeOptions): DescribeDohSubDomainStatisticsSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.subDomain)) {
    query['SubDomain'] = request.subDomain;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDohSubDomainStatisticsSummary',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeDohSubDomainStatisticsSummaryRequest
 * @return DescribeDohSubDomainStatisticsSummaryResponse
 */
async function describeDohSubDomainStatisticsSummary(request: DescribeDohSubDomainStatisticsSummaryRequest): DescribeDohSubDomainStatisticsSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDohSubDomainStatisticsSummaryWithOptions(request, runtime);
}

model DescribeDohUserInfoRequest {
  endDate?: string(name='EndDate', description='The end time for the query. Format: YYYY-MM-DD

If you do not specify this parameter, the default value is the time when you perform the query.', example='2019-07-04'),
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.', example='en'),
  startDate?: string(name='StartDate', description='The start time for the query. Format: YYYY-MM-DD

You can query the user information of the last 90 days only. `Set the parameter to a value no earlier than 90 days from the current time`.', example='2019-07-04'),
}

model DescribeDohUserInfoResponseBody = {
  domainCount?: int32(name='DomainCount', description='The number of accessed domains.', example='123'),
  pdnsId?: long(name='PdnsId', description='The ID of the Alibaba Cloud public DNS user.', example='12345678'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0F32959D-417B-4D66-8463-68606605E3E2'),
  subDomainCount?: int32(name='SubDomainCount', description='The number of accessed subdomains.', example='123'),
}

model DescribeDohUserInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDohUserInfoResponseBody(name='body'),
}

/**
 * @summary Queries the numbers of accessed domains and subdomains by using DNS over HTTPS (DoH).
 *
 * @param request DescribeDohUserInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDohUserInfoResponse
 */
async function describeDohUserInfoWithOptions(request: DescribeDohUserInfoRequest, runtime: Util.RuntimeOptions): DescribeDohUserInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDohUserInfo',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the numbers of accessed domains and subdomains by using DNS over HTTPS (DoH).
 *
 * @param request DescribeDohUserInfoRequest
 * @return DescribeDohUserInfoResponse
 */
async function describeDohUserInfo(request: DescribeDohUserInfoRequest): DescribeDohUserInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDohUserInfoWithOptions(request, runtime);
}

model DescribeDomainDnssecInfoRequest {
  domainName?: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.

This parameter is required.', example='example.com'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English

Default value: **zh**', example='en'),
}

model DescribeDomainDnssecInfoResponseBody = {
  algorithm?: string(name='Algorithm', description='The algorithm type. This parameter is returned if DNSSEC is enabled.', example='13'),
  digest?: string(name='Digest', description='The digest. This parameter is returned if DNSSEC is enabled.', example='C1A0424B97A049F1F9B2EA139CC298533219668164E343BD21203ABC4608C02A'),
  digestType?: string(name='DigestType', description='The digest type. This parameter is returned if DNSSEC is enabled.', example='SHA256'),
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  dsRecord?: string(name='DsRecord', description='The delegation signer (DS) record. This parameter is returned if DNSSEC is enabled.', example='example.com. 3600 IN DS 2371 13 2 C1A0424B97A049F1F9B2EA139CC298533219668164E343BD21203ABC4608C02A'),
  flags?: string(name='Flags', description='The flag. This parameter is returned if DNSSEC is enabled.', example='257 (KSK)'),
  keyTag?: string(name='KeyTag', description='The key tag. This parameter is returned if DNSSEC is enabled.', example='54931'),
  publicKey?: string(name='PublicKey', description='The public key. This parameter is returned if DNSSEC is enabled.', example='mdsswUyr3DPW132mOi8V9xESWE8jTo0dxCjjnopKl+GqJxpVXckHAeF+KkxLbxILfDLUT0rAK9iUzy1L53eKGQ=='),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  status?: string(name='Status', description='The state of the DNSSEC. Valid values:

*   ON
*   OFF', example='ON'),
}

model DescribeDomainDnssecInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainDnssecInfoResponseBody(name='body'),
}

/**
 * @summary Queries the Domain Name System Security Extensions (DNSSEC) configurations of a domain name based on the specified parameters.
 *
 * @param request DescribeDomainDnssecInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainDnssecInfoResponse
 */
async function describeDomainDnssecInfoWithOptions(request: DescribeDomainDnssecInfoRequest, runtime: Util.RuntimeOptions): DescribeDomainDnssecInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainDnssecInfo',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the Domain Name System Security Extensions (DNSSEC) configurations of a domain name based on the specified parameters.
 *
 * @param request DescribeDomainDnssecInfoRequest
 * @return DescribeDomainDnssecInfoResponse
 */
async function describeDomainDnssecInfo(request: DescribeDomainDnssecInfoRequest): DescribeDomainDnssecInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainDnssecInfoWithOptions(request, runtime);
}

model DescribeDomainGroupsRequest {
  keyWord?: string(name='KeyWord', description='The keyword of the domain name group for searches in %KeyWord% mode. The value is not case-sensitive.', example='Group'),
  lang?: string(name='Lang', description='The language.', example='en'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: **1 to 100**. Default value: **20**.', example='20'),
}

model DescribeDomainGroupsResponseBody = {
  domainGroups?: {
    domainGroup?: [ 
    {
      domainCount?: long(name='DomainCount', description='The number of domain name groups.', example='2'),
      groupId?: string(name='GroupId', description='The ID of the domain name group. Valid values:

*   defaultGroup: the default group
*   If an empty string is returned, it indicates the group that contains all domain names.', example='2223'),
      groupName?: string(name='GroupName', description='The name of the domain name group.', example='MyGroup'),
    }
  ](name='DomainGroup')
  }(name='DomainGroups', description='The domain name groups.'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: **1 to 100**. Default value: **20**.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model DescribeDomainGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainGroupsResponseBody(name='body'),
}

/**
 * @summary Queries all domain name groups based on the specified parameters.
 *
 * @param request DescribeDomainGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainGroupsResponse
 */
async function describeDomainGroupsWithOptions(request: DescribeDomainGroupsRequest, runtime: Util.RuntimeOptions): DescribeDomainGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainGroups',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries all domain name groups based on the specified parameters.
 *
 * @param request DescribeDomainGroupsRequest
 * @return DescribeDomainGroupsResponse
 */
async function describeDomainGroups(request: DescribeDomainGroupsRequest): DescribeDomainGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainGroupsWithOptions(request, runtime);
}

model DescribeDomainInfoRequest {
  domainName?: string(name='DomainName', description='The domain name.

This parameter is required.', example='dns-example.com'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  needDetailAttributes?: boolean(name='NeedDetailAttributes', description='Specifies whether detailed attributes are required. Default value: **false**, which indicates that detailed attributes are not returned.

If you set this parameter to **true**, the values of the following parameters are returned: LineType, MinTtl, RecordLineTreeJson, RecordLines, LineCode, LineDisplayName, LineName, RegionLines, and SlaveDns.', example='true'),
}

model DescribeDomainInfoResponseBody = {
  aliDomain?: boolean(name='AliDomain', description='Indicates whether the domain name was registered in Alibaba Cloud.', example='true'),
  availableTtls?: {
    availableTtl?: [ string ](name='AvailableTtl')
  }(name='AvailableTtls', description='The available time to live (TTL) values that can be configured for the domain name. Available TTL values are not returned by default. If you want to query such information, set NeedDetailAttributes to true.'),
  createTime?: string(name='CreateTime', description='The time when the domain name was created.', example='2015-12-12T09:23Z'),
  dnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='DnsServers', description='The DNS servers that are used to resolve the domain name.'),
  domainId?: string(name='DomainId', description='The ID of the domain name.', example='00efd71a-770e-4255-b54e-6fe5659baffe'),
  domainLoggingSwitchStatus?: string(name='DomainLoggingSwitchStatus', description='Indicates whether the DNS traffic analysis feature is enabled. Valid values:'),
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  groupId?: string(name='GroupId', description='The ID of the domain name group.', example='2223'),
  groupName?: string(name='GroupName', description='The name of the domain name group.', example='mygroup'),
  inBlackHole?: boolean(name='InBlackHole', description='Indicates whether blackhole filtering was triggered.', example='false'),
  inClean?: boolean(name='InClean', description='Indicates whether traffic scrubbing was in progress.', example='false'),
  instanceId?: string(name='InstanceId', description='The ID of the Alibaba Cloud DNS instance.', example='i-7bg'),
  lineType?: string(name='LineType', description='The type of the DNS request line.', example='region_province'),
  minTtl?: long(name='MinTtl', description='The minimum TTL value.', example='1'),
  punyCode?: string(name='PunyCode', description='The Punycode for the domain name. This parameter is returned only for Chinese domain names.', example='example.com'),
  recordLineTreeJson?: string(name='RecordLineTreeJson', description='The tree-structure DNS request lines.', example='{"default":{},"unicom":{},"telecom":{},"mobile":{},"edu":{},"oversea":{},"baidu":{},"biying":{},"google":{}}'),
  recordLines?: {
    recordLine?: [ 
    {
      fatherCode?: string(name='FatherCode', description='The code of the parent line. This parameter is not returned if the line has no parent line.', example='internal'),
      lineCode?: string(name='LineCode', description='The code of the line.', example='cn_region_xibei'),
      lineDisplayName?: string(name='LineDisplayName', description='The name of the parent line.'),
      lineName?: string(name='LineName', description='The name of the line.'),
    }
  ](name='RecordLine')
  }(name='RecordLines', description='The DNS request lines.'),
  regionLines?: boolean(name='RegionLines', description='Indicates whether the DNS request lines are regional lines.', example='false'),
  remark?: string(name='Remark', description='The description.', example='remark'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-aek3dj3wvclgcxo'),
  slaveDns?: boolean(name='SlaveDns', description='Indicates whether secondary DNS is supported.', example='true'),
  subDomain?: boolean(name='SubDomain', description='Indicates whether the queried domain name is a hosted subdomain name. Valid values:

*   true
*   false', example='false'),
  versionCode?: string(name='VersionCode', description='The version ID of Alibaba Cloud DNS.', example='version1'),
  versionName?: string(name='VersionName', description='The edition of Alibaba Cloud DNS.'),
}

model DescribeDomainInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainInfoResponseBody(name='body'),
}

/**
 * @summary Queries the information about a domain name based on specified parameters.
 *
 * @description In this example, the domain name is bound to an instance of Alibaba Cloud DNS Enterprise Ultimate Edition. For more information about valid Domain Name System (DNS) request lines, see the return values of the RecordLines parameter.
 *
 * @param request DescribeDomainInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainInfoResponse
 */
async function describeDomainInfoWithOptions(request: DescribeDomainInfoRequest, runtime: Util.RuntimeOptions): DescribeDomainInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.needDetailAttributes)) {
    query['NeedDetailAttributes'] = request.needDetailAttributes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainInfo',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about a domain name based on specified parameters.
 *
 * @description In this example, the domain name is bound to an instance of Alibaba Cloud DNS Enterprise Ultimate Edition. For more information about valid Domain Name System (DNS) request lines, see the return values of the RecordLines parameter.
 *
 * @param request DescribeDomainInfoRequest
 * @return DescribeDomainInfoResponse
 */
async function describeDomainInfo(request: DescribeDomainInfoRequest): DescribeDomainInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainInfoWithOptions(request, runtime);
}

model DescribeDomainLogsRequest {
  groupId?: string(name='GroupId', description='The ID of the domain name group.', example='2223'),
  keyWord?: string(name='KeyWord', description='The keyword for the query in "%KeyWord%" mode. The keyword is not case-sensitive.', example='test'),
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.', example='en'),
  pageNumber?: long(name='PageNumber', description='The page number to return. The page number starts from **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries to return per page. Maximum value: **100**. Default value: **20**.', example='20'),
  startDate?: string(name='StartDate', description='The start time for the query. Format: **YYYY-MM-DD**', example='2019-07-04'),
  type?: string(name='Type', description='The type of object of which you want to query operation logs. Valid values:

*   domain: domain name
*   slavedns: secondary Domain Name System (DNS)', example='domain'),
  endDate?: string(name='endDate', description='The end time for the query. Format: **YYYY-MM-DD**', example='2019-07-04'),
}

model DescribeDomainLogsResponseBody = {
  domainLogs?: {
    domainLog?: [ 
    {
      action?: string(name='Action', description='The operation.', example='Add'),
      actionTime?: string(name='ActionTime', description='The time when the operation is performed. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2015-12-12T09:23Z'),
      actionTimestamp?: long(name='ActionTimestamp', description='The time when the operation was performed. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='143562300000'),
      clientIp?: string(name='ClientIp', description='The IP address of the operator.', example='182.92.253.20'),
      domainName?: string(name='DomainName', description='The domain name.', example='abc.com'),
      message?: string(name='Message', description='The message for the operation.', example='To the DNS record list'),
      zoneId?: string(name='ZoneId', description='The ID of the private zone.', example='cxfd345sd234'),
    }
  ](name='DomainLog')
  }(name='DomainLogs', description='The operation logs.'),
  pageNumber?: long(name='PageNumber', description='The page number.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='2'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model DescribeDomainLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainLogsResponseBody(name='body'),
}

/**
 * @summary Queries the operation logs of domain names based on the specified parameters.
 *
 * @param request DescribeDomainLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainLogsResponse
 */
async function describeDomainLogsWithOptions(request: DescribeDomainLogsRequest, runtime: Util.RuntimeOptions): DescribeDomainLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.endDate)) {
    query['endDate'] = request.endDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainLogs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the operation logs of domain names based on the specified parameters.
 *
 * @param request DescribeDomainLogsRequest
 * @return DescribeDomainLogsResponse
 */
async function describeDomainLogs(request: DescribeDomainLogsRequest): DescribeDomainLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainLogsWithOptions(request, runtime);
}

model DescribeDomainNsRequest {
  domainName?: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.

This parameter is required.', example='example.com'),
  lang?: string(name='Lang', description='The language of the content in the request and response.

Valid values:

zh: Chinese\\\\
en: English

Default value: **zh**', example='en'),
}

model DescribeDomainNsResponseBody = {
  allAliDns?: boolean(name='AllAliDns', description='Indicates whether all the name servers are Alibaba Cloud DNS servers.', example='true'),
  detectFailedReasonCode?: string(name='DetectFailedReasonCode', description='The cause code of the detection failure.', example='DnsCheck.Failed'),
  dnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='DnsServers', description='The DNS server names configured for the domain name.'),
  expectDnsServers?: {
    expectDnsServer?: [ string ](name='ExpectDnsServer')
  }(name='ExpectDnsServers', description='The Domain Name System (DNS) server names assigned by Alibaba Cloud DNS.'),
  includeAliDns?: boolean(name='IncludeAliDns', description='Indicates whether the name servers include Alibaba Cloud DNS servers.', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='16C7DC7A-2FA7-4D14-8B12-88A2BB6373DB'),
}

model DescribeDomainNsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainNsResponseBody(name='body'),
}

/**
 * @summary Queries the name servers configured for a specified domain name and checks whether all the name servers are Alibaba Cloud Domain Name System (DNS) servers.
 *
 * @description >  You can call this operation to query the authoritative servers of a domain name registry to obtain the name servers for a domain name. If the domain name is in an invalid state, such as serverHold or clientHold, an error may be returned.
 *
 * @param request DescribeDomainNsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainNsResponse
 */
async function describeDomainNsWithOptions(request: DescribeDomainNsRequest, runtime: Util.RuntimeOptions): DescribeDomainNsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainNs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the name servers configured for a specified domain name and checks whether all the name servers are Alibaba Cloud Domain Name System (DNS) servers.
 *
 * @description >  You can call this operation to query the authoritative servers of a domain name registry to obtain the name servers for a domain name. If the domain name is in an invalid state, such as serverHold or clientHold, an error may be returned.
 *
 * @param request DescribeDomainNsRequest
 * @return DescribeDomainNsResponse
 */
async function describeDomainNs(request: DescribeDomainNsRequest): DescribeDomainNsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainNsWithOptions(request, runtime);
}

model DescribeDomainRecordInfoRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  recordId?: string(name='RecordId', description='The ID of the DNS record. You can call the [DescribeDomainRecords](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomainrecords?spm=a2c63.p38356.help-menu-search-29697.d_0) to obtain the ID.

This parameter is required.', example='9999985'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0'),
}

model DescribeDomainRecordInfoResponseBody = {
  domainId?: string(name='DomainId', description='The ID of the domain name.', example='00efd71a-770e-4255-b54e-6fe5659baffe'),
  domainName?: string(name='DomainName', description='The domain name.', example='dns-example.top'),
  groupId?: string(name='GroupId', description='The ID of the domain name group.', example='2223'),
  groupName?: string(name='GroupName', description='The name of the domain name group.', example='MyGroup'),
  line?: string(name='Line', description='The DNS resolution line.', example='default'),
  locked?: boolean(name='Locked', description='The lock state of the DNS record. Valid values: **true and false**.', example='true'),
  priority?: long(name='Priority', description='The priority of the mail exchanger (MX) record.', example='5'),
  punyCode?: string(name='PunyCode', description='The Punycode for the domain name. This parameter is returned only for Chinese domain names.', example='xn--fsq270a.com'),
  RR?: string(name='RR', description='The hostname.', example='@'),
  recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
  remark?: string(name='Remark', description='The description of your DNS record.', example='test'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  status?: string(name='Status', description='The status of the DNS record. Valid values:

Enable: enabled

Disable: disabled', example='Enable'),
  TTL?: long(name='TTL', description='The time for which the DNS record is cached in a local DNS system.', example='600'),
  type?: string(name='Type', description='The type of the DNS record.', example='MX'),
  value?: string(name='Value', description='The record value.', example='1.1.XX.XX'),
}

model DescribeDomainRecordInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainRecordInfoResponseBody(name='body'),
}

/**
 * @summary Queries the information about a Domain Name System (DNS) record by the ID of the DNS record.
 *
 * @description ## Debugging
 * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=Alidns\\&api=DescribeDomainRecordInfo\\&type=RPC\\&version=2015-01-09)
 *
 * @param request DescribeDomainRecordInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainRecordInfoResponse
 */
async function describeDomainRecordInfoWithOptions(request: DescribeDomainRecordInfoRequest, runtime: Util.RuntimeOptions): DescribeDomainRecordInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recordId)) {
    query['RecordId'] = request.recordId;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainRecordInfo',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about a Domain Name System (DNS) record by the ID of the DNS record.
 *
 * @description ## Debugging
 * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=Alidns\\&api=DescribeDomainRecordInfo\\&type=RPC\\&version=2015-01-09)
 *
 * @param request DescribeDomainRecordInfoRequest
 * @return DescribeDomainRecordInfoResponse
 */
async function describeDomainRecordInfo(request: DescribeDomainRecordInfoRequest): DescribeDomainRecordInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainRecordInfoWithOptions(request, runtime);
}

model DescribeDomainRecordsRequest {
  direction?: string(name='Direction', description='The order in which you want to sort the returned DNS records. Valid values: DESC and ASC. Default value: DESC.', example='DESC'),
  domainName?: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.

This parameter is required.', example='example.com'),
  groupId?: long(name='GroupId', description='The ID of the domain name group.

*   If you do not specify GroupId, all domain names are queried.
*   If you set GroupId to 0, no value is returned.
*   If you set GroupId to 1, the domain names in the default group are queried.
*   If you set GroupId to -2, all domain names are queried.
*   You can also specify GroupId based on the actual group ID.

You can call the [DescribeDomainGroups ](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomaingroups?spm=a2c63.p38356.help-menu-search-29697.d_0)operation to obtain the ID of the domain name group.', example='2223'),
  keyWord?: string(name='KeyWord', description='The keyword.', example='test'),
  lang?: string(name='Lang', description='The language.', example='en'),
  line?: string(name='Line', description='The resolution line. Default value: **default**.

For more information, see

[DNS lines](https://www.alibabacloud.com/help/zh/doc-detail/29807.htm).', example='cn_mobile_anhui'),
  orderBy?: string(name='OrderBy', description='The method that is used to sort the returned DNS records. By default, the DNS records are sorted in reverse chronological order based on the time when they were added.', example='default'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: **1 to 500**. Default value: **20**.', example='20'),
  RRKeyWord?: string(name='RRKeyWord', description='The hostname keyword based on which the system queries DNS records. The system queries DNS records based on the value of this parameter in fuzzy match mode. The value is not case-sensitive.', example='www'),
  searchMode?: string(name='SearchMode', description='The search mode. Valid values: **LIKE, EXACT, and ADVANCED**.

*   If you set SearchMode to LIKE or EXACT, specify KeyWord. In this case, RRKeyWord, TypeKeyWord, ValueKeyWord, Type, Line, and Status are invalid.

*   If you set SearchMode to ADVANCED, specify RRKeyWord, TypeKeyWord, ValueKeyWord, Type, Line, and Status.

*   If you do not specify SearchMode, the system determines the search mode based on the following rules:

    *   If KeyWord is specified, the system uses the LIKE mode.
    *   If KeyWord is not specified, the system queries DNS records based on values of RRKeyWord and ValueKeyWord in fuzzy match mode, and based on the values of TypeKeyWord, Type, Line, and Status in exact match mode.', example='LIKE'),
  status?: string(name='Status', description='The status of the DNS records to query. Valid values: **Enable and Disable**.', example='Enable'),
  type?: string(name='Type', description='The type of the DNS records to query. For more information, see

[DNS record types](https://www.alibabacloud.com/help/zh/doc-detail/29805.htm).', example='A'),
  typeKeyWord?: string(name='TypeKeyWord', description='The type keyword based on which the system queries DNS records. The system queries DNS records based on the value of this parameter in exact match mode. The value is not case-sensitive.', example='MX'),
  valueKeyWord?: string(name='ValueKeyWord', description='The record value keyword based on which the system queries DNS records. The system queries DNS records based on the value of this parameter in fuzzy match mode. The value is not case-sensitive.', example='com'),
}

model DescribeDomainRecordsResponseBody = {
  domainRecords?: {
    record?: [ 
    {
      createTimestamp?: long(name='CreateTimestamp', description='The time when the DNS record was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since 00:00:00 UTC on January 1, 1970.', example='1666501957000'),
      domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
      line?: string(name='Line', description='The resolution line.', example='default'),
      locked?: boolean(name='Locked', description='Indicates whether the DNS record is locked.', example='false'),
      priority?: long(name='Priority', description='The priority of the mail exchanger (MX) record.', example='5'),
      RR?: string(name='RR', description='The hostname.', example='www'),
      recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
      remark?: string(name='Remark', description='The description of the DNS record.', example='test'),
      status?: string(name='Status', description='The status of the DNS record.', example='Enable'),
      TTL?: long(name='TTL', description='The time-to-live (TTL) of the cached DNS record. Unit: seconds.', example='600'),
      type?: string(name='Type', description='The type of the DNS record.', example='MX'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The time when the DNS record was updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since 00:00:00 UTC on January 1, 1970.', example='1676872961000'),
      value?: string(name='Value', description='The record value.', example='mail1.hichina.com'),
      weight?: int32(name='Weight', description='The weight of the DNS record.', example='2'),
    }
  ](name='Record')
  }(name='DomainRecords', description='The returned Domain Name System (DNS) records.'),
  pageNumber?: long(name='PageNumber', description='The page number.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model DescribeDomainRecordsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainRecordsResponseBody(name='body'),
}

/**
 * @summary Queries all Domain Name System (DNS) records of the specified primary domain names based on the specified parameters.
 *
 * @description *   You can specify DomainName, PageNumber, and PageSize to query the DNS records of the specified domain names.
 * *   You can also specify RRKeyWord, TypeKeyWord, or ValueKeyWord to query the DNS records that contain the specified keyword.
 * *   By default, the DNS records are sorted in reverse chronological order based on the time when they were added.
 * *   You can specify GroupId to query the DNS records of the specified domain names based on the group ID. You can query the DNS records of all domain names and the domain names in the default group.
 *
 * @param request DescribeDomainRecordsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainRecordsResponse
 */
async function describeDomainRecordsWithOptions(request: DescribeDomainRecordsRequest, runtime: Util.RuntimeOptions): DescribeDomainRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.line)) {
    query['Line'] = request.line;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.RRKeyWord)) {
    query['RRKeyWord'] = request.RRKeyWord;
  }
  if (!Util.isUnset(request.searchMode)) {
    query['SearchMode'] = request.searchMode;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.typeKeyWord)) {
    query['TypeKeyWord'] = request.typeKeyWord;
  }
  if (!Util.isUnset(request.valueKeyWord)) {
    query['ValueKeyWord'] = request.valueKeyWord;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainRecords',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries all Domain Name System (DNS) records of the specified primary domain names based on the specified parameters.
 *
 * @description *   You can specify DomainName, PageNumber, and PageSize to query the DNS records of the specified domain names.
 * *   You can also specify RRKeyWord, TypeKeyWord, or ValueKeyWord to query the DNS records that contain the specified keyword.
 * *   By default, the DNS records are sorted in reverse chronological order based on the time when they were added.
 * *   You can specify GroupId to query the DNS records of the specified domain names based on the group ID. You can query the DNS records of all domain names and the domain names in the default group.
 *
 * @param request DescribeDomainRecordsRequest
 * @return DescribeDomainRecordsResponse
 */
async function describeDomainRecords(request: DescribeDomainRecordsRequest): DescribeDomainRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainRecordsWithOptions(request, runtime);
}

model DescribeDomainResolveStatisticsSummaryRequest {
  direction?: string(name='Direction', description='The order in which you want to sort the returned entries. Valid values:

*   DESC: the descending order
*   ASC: the ascending order', example='DESC'),
  endDate?: string(name='EndDate', description='The end time in the yyyy-MM-dd format, for example, 2023-03-13.', example='2023-03-01'),
  keyword?: string(name='Keyword', description='The keyword. The Keyword parameter is used together with the SearchMode parameter.', example='test'),
  lang?: string(name='Lang', description='The language. Valid values: zh, en, and ja.', example='zh'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 1000.', example='10'),
  searchMode?: string(name='SearchMode', description='The search mode of the keyword. Valid values:

*   LIKE (default): fuzzy search
*   EXACT: exact search', example='EXACT'),
  startDate?: string(name='StartDate', description='The start time in the yyyy-MM-dd format, for example, 2023-03-01.

This parameter is required.', example='2023-03-01'),
  threshold?: long(name='Threshold', description='The threshold for the number of Domain Name System (DNS) requests. You can query the domain names at the specified quantity level of DNS requests and query the number of DNS requests for each domain name.

If you do not specify this parameter, the data about the domain names that have DNS requests is obtained.

If you set this parameter to a value less than 0, the data about all domain names is obtained.

If you set this parameter to 0, the data about the domain names that do not have DNS requests is obtained.

If you set this parameter to a value greater than 0, the data about the domain names whose number of DNS requests is less than or equal to the value of this parameter is obtained.', example='-1'),
}

model DescribeDomainResolveStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Maximum value: **100**. Default value: **20**.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  statistics?: [ 
    {
      count?: string(name='Count', description='The number of DNS requests.', example='35509014'),
      domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
      domainType?: string(name='DomainType', description='The type of the domain name. Valid values:

*   PUBLIC: hosted public domain name
*   CACHE: cache-accelerated domain name', example='CACHE'),
    }
  ](name='Statistics', description='The statistics.'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned.', example='1'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeDomainResolveStatisticsSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainResolveStatisticsSummaryResponseBody(name='body'),
}

/**
 * @summary Queries the resolution requests of all paid domain names within your account.
 *
 * @param request DescribeDomainResolveStatisticsSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainResolveStatisticsSummaryResponse
 */
async function describeDomainResolveStatisticsSummaryWithOptions(request: DescribeDomainResolveStatisticsSummaryRequest, runtime: Util.RuntimeOptions): DescribeDomainResolveStatisticsSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchMode)) {
    query['SearchMode'] = request.searchMode;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.threshold)) {
    query['Threshold'] = request.threshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainResolveStatisticsSummary',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the resolution requests of all paid domain names within your account.
 *
 * @param request DescribeDomainResolveStatisticsSummaryRequest
 * @return DescribeDomainResolveStatisticsSummaryResponse
 */
async function describeDomainResolveStatisticsSummary(request: DescribeDomainResolveStatisticsSummaryRequest): DescribeDomainResolveStatisticsSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainResolveStatisticsSummaryWithOptions(request, runtime);
}

model DescribeDomainStatisticsRequest {
  domainName?: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.', example='example.com'),
  domainType?: string(name='DomainType', description='The type of the domain name. Valid values:

*   PUBLIC (default): hosted public domain name
*   CACHE: cached public domain name', example='PUBLIC CACHE'),
  endDate?: string(name='EndDate', description='The end date of the query. Specify the end date in the **YYYY-MM-DD** format.

The default value is the day when you query the data.', example='2019-07-04'),
  lang?: string(name='Lang', description='The language of the content within the request and response.

*   **zh**: Chinese (default)
*   **en**: English', example='en'),
  startDate?: string(name='StartDate', description='The start date of the query. Specify the start date in the **YYYY-MM-DD** format.

You can only query the DNS records within the last 90 days.``

This parameter is required.', example='2019-07-04'),
}

model DescribeDomainStatisticsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='6AEC7A64-3CB1-4C49-8B35-0B901F1E26BF'),
  statistics?: {
    statistic?: [ 
    {
      count?: long(name='Count', description='The number of DNS requests.', example='15292887'),
      domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
      timestamp?: long(name='Timestamp', description='The statistical timestamp. Unit: milliseconds. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1556640000000'),
    }
  ](name='Statistic')
  }(name='Statistics', description='The statistics on the Domain Name System (DNS) requests.'),
}

model DescribeDomainStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the real-time statistics on the Domain Name System (DNS) requests for a primary domain name.
 *
 * @description Real-time data is collected per hour.
 *
 * @param request DescribeDomainStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainStatisticsResponse
 */
async function describeDomainStatisticsWithOptions(request: DescribeDomainStatisticsRequest, runtime: Util.RuntimeOptions): DescribeDomainStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainType)) {
    query['DomainType'] = request.domainType;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainStatistics',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the real-time statistics on the Domain Name System (DNS) requests for a primary domain name.
 *
 * @description Real-time data is collected per hour.
 *
 * @param request DescribeDomainStatisticsRequest
 * @return DescribeDomainStatisticsResponse
 */
async function describeDomainStatistics(request: DescribeDomainStatisticsRequest): DescribeDomainStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainStatisticsWithOptions(request, runtime);
}

model DescribeDomainStatisticsSummaryRequest {
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the **YYYY-MM-DD** format.

The default value is the day when you perform the operation.', example='2019-07-04'),
  keyword?: string(name='Keyword', description='The keyword for searches in %KeyWord% mode. The value is not case-sensitive.', example='test'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  pageNumber?: long(name='PageNumber', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: **1 to 100**. Default value: **20**.', example='20'),
  searchMode?: string(name='SearchMode', description='The search mode of the keyword. Valid values:

*   **LIKE**: fuzzy match (default).
*   **EXACT**: exact match.', example='LIKE'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the **YYYY-MM-DD** format.

You can only query DNS records of the last 90 days.

This parameter is required.', example='2019-07-04'),
  threshold?: long(name='Threshold', description='The threshold of query volume that can be obtained. You can also obtain data about a domain name with the query volume less than or equal to the threshold. For example, if you set this parameter to 100, you can query domain names with less than 100 queries.', example='12'),
}

model DescribeDomainStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='5'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CC625C21-8832-4683-BF10-C3CFB1A4FA13'),
  statistics?: {
    statistic?: [ 
    {
      count?: long(name='Count', description='The number of DNS requests.', example='35509014'),
      domainName?: string(name='DomainName', description='The domain name.', example='ali-gslb.com'),
      domainType?: string(name='DomainType', description='The type of the domain name. The parameter value is not case-sensitive. Valid values:

PUBLIC (default): hosted public domain name

CACHE: cache-accelerated domain name', example='PUBLIC'),
      resolveAnalysisStatus?: string(name='resolveAnalysisStatus', description='Indicates whether the DNS traffic analysis feature is enabled for the domain name. Valid values:

*   OPEN
*   CLOSE', example='OPEN'),
    }
  ](name='Statistic')
  }(name='Statistics', description='The statistics on the Domain Name System (DNS) requests.'),
  totalItems?: int32(name='TotalItems', description='The total number of data records.', example='68'),
  totalPages?: int32(name='TotalPages', description='The total number of returned pages.', example='14'),
}

model DescribeDomainStatisticsSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainStatisticsSummaryResponseBody(name='body'),
}

/**
 * @summary Calls the DescribeDomainStatisticsSummary operation to obtain the query volume of all paid domain names under your account.
 *
 * @param request DescribeDomainStatisticsSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainStatisticsSummaryResponse
 */
async function describeDomainStatisticsSummaryWithOptions(request: DescribeDomainStatisticsSummaryRequest, runtime: Util.RuntimeOptions): DescribeDomainStatisticsSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchMode)) {
    query['SearchMode'] = request.searchMode;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.threshold)) {
    query['Threshold'] = request.threshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainStatisticsSummary',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Calls the DescribeDomainStatisticsSummary operation to obtain the query volume of all paid domain names under your account.
 *
 * @param request DescribeDomainStatisticsSummaryRequest
 * @return DescribeDomainStatisticsSummaryResponse
 */
async function describeDomainStatisticsSummary(request: DescribeDomainStatisticsSummaryRequest): DescribeDomainStatisticsSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainStatisticsSummaryWithOptions(request, runtime);
}

model DescribeDomainsRequest {
  groupId?: string(name='GroupId', description='The ID of the domain name group. If you do not specify this parameter, all domain names are queried by default.', example='2223'),
  keyWord?: string(name='KeyWord', description='The keyword for searches in "%KeyWord%" mode. The value is not case-sensitive.', example='com'),
  lang?: string(name='Lang', description='The language type.', example='en'),
  pageNumber?: long(name='PageNumber', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page. Maximum value: **100**. Default value: **20**.', example='20'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-resourcegroupid01'),
  searchMode?: string(name='SearchMode', description='The search mode. Valid values:

*   **LIKE**: fuzzy match.
*   **EXACT**: exact match.', example='LIKE'),
  starmark?: boolean(name='Starmark', description='Specifies whether to query the starmark of the domain name.', example='true'),
}

model DescribeDomainsResponseBody = {
  domains?: {
    domain?: [ 
    {
      aliDomain?: boolean(name='AliDomain', description='Indicates whether the domain name was registered with Alibaba Cloud.', example='true'),
      createTime?: string(name='CreateTime', description='The time when the domain name was added. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2019-01-30T05:25Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The time when the domain name was added. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1660546144000'),
      dnsServers?: {
        dnsServer?: [ string ](name='DnsServer')
      }(name='DnsServers', description='The names of the DNS servers configured for the domain name assigned by Alibaba Cloud DNS.'),
      domainId?: string(name='DomainId', description='The ID of the domain name.', example='00efd71a-770e-4255-b54e-6fe5659baffe'),
      domainLoggingSwitchStatus?: string(name='DomainLoggingSwitchStatus', description='Indicates whether the DNS traffic analysis feature is enabled for the domain name. Valid values:

*   OPEN
*   CLOSE', example='OPEN'),
      domainName?: string(name='DomainName', description='The domain name.', example='abc.com'),
      groupId?: string(name='GroupId', description='The ID of the domain name group.', example='2223'),
      groupName?: string(name='GroupName', description='The name of the domain name group.', example='mygroup'),
      instanceEndTime?: string(name='InstanceEndTime', description='The time when the Alibaba Cloud DNS instance expires. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2020-03-14T16:00Z'),
      instanceExpired?: boolean(name='InstanceExpired', description='Indicates whether the Alibaba Cloud DNS instance expires.', example='false'),
      instanceId?: string(name='InstanceId', description='The ID of the Alibaba Cloud DNS instance.', example='i-7bg'),
      punyCode?: string(name='PunyCode', description='The Punycode for the domain name. This parameter is returned only for Chinese domain names.', example='abc.com'),
      recordCount?: long(name='RecordCount', description='The number of Domain Name System (DNS) records added for the domain name.', example='100'),
      registrantEmail?: string(name='RegistrantEmail', description='The email address of the registrant.', example='test@example.com'),
      remark?: string(name='Remark', description='The description of the domain name.', example='remark'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the domain name belongs.', example='rg-acf'),
      starmark?: boolean(name='Starmark', description='Indicates whether the domain name was added to favorites.', example='true'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key', description='The key of tag N added to the resource.'),
          value?: string(name='Value', description='The value of tag N added to the resource.'),
        }
      ](name='Tag')
      }(name='Tags', description='The tags added to the resource.'),
      versionCode?: string(name='VersionCode', description='The edition code of Alibaba Cloud DNS.', example='version_enterprise_basic'),
      versionName?: string(name='VersionName', description='The edition of Alibaba Cloud DNS.'),
    }
  ](name='Domain')
  }(name='Domains', description='The domain names.'),
  pageNumber?: long(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries returned per page.', example='2'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='68386699-8B9E-4D5B-BC4C-75A28F6C2A00'),
  totalCount?: long(name='TotalCount', description='The total number of domain names.', example='2'),
}

model DescribeDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainsResponseBody(name='body'),
}

/**
 * @summary Calls the DescribeDomains operation to query domain names of a user based on input parameters.
 *
 * @description *   You can specify the PageNumber and PageSize parameters to query domain names.
 * *   You can specify the KeyWord parameter to query domain names that contain the specified keyword.
 * *   By default, the domain names in a list are sorted in descending order of the time they were added.
 * *   You can specify the GroupId parameter. If you do not specify this parameter, all domain names are queried by default.
 *
 * @param request DescribeDomainsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainsResponse
 */
async function describeDomainsWithOptions(request: DescribeDomainsRequest, runtime: Util.RuntimeOptions): DescribeDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.searchMode)) {
    query['SearchMode'] = request.searchMode;
  }
  if (!Util.isUnset(request.starmark)) {
    query['Starmark'] = request.starmark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomains',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Calls the DescribeDomains operation to query domain names of a user based on input parameters.
 *
 * @description *   You can specify the PageNumber and PageSize parameters to query domain names.
 * *   You can specify the KeyWord parameter to query domain names that contain the specified keyword.
 * *   By default, the domain names in a list are sorted in descending order of the time they were added.
 * *   You can specify the GroupId parameter. If you do not specify this parameter, all domain names are queried by default.
 *
 * @param request DescribeDomainsRequest
 * @return DescribeDomainsResponse
 */
async function describeDomains(request: DescribeDomainsRequest): DescribeDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainsWithOptions(request, runtime);
}

model DescribeGtmAccessStrategiesRequest {
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance whose access policies you want to query.', example='instance1'),
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return per page.', example='20'),
}

model DescribeGtmAccessStrategiesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The number of the page returned.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0CCC9971-CEC9-4132-824B-4AE611C07623'),
  strategies?: {
    strategy?: [ 
    {
      accessMode?: string(name='AccessMode', description='The access policy. Valid values:

*   **AUTO**: Automatic switch
*   **DEFAULT**: Default address pool
*   **FAILOVER**: Failover address pool', example='DEFAULT'),
      accessStatus?: string(name='AccessStatus', description='The access status. Valid values:

*   **DEFAULT**: The default address pool is currently accessed.
*   **FAILOVER**: The failover address pool is currently accessed.', example='DEFAULT'),
      createTime?: string(name='CreateTime', description='The time when the access policy was created.', example='2018-08-09T00:10Z'),
      createTimestamp?: long(name='CreateTimestamp', example='1533773400000'),
      defaultAddrPoolId?: string(name='DefaultAddrPoolId', description='The ID of the default address pool.', example='hra0i1'),
      defaultAddrPoolMonitorStatus?: string(name='DefaultAddrPoolMonitorStatus', description='Indicates whether health check was enabled for the default address pool. Valid values:

*   **OPEN**: Enabled
*   **CLOSE**: Disabled
*   **UNCONFIGURED**: Not configured', example='OPEN'),
      defaultAddrPoolName?: string(name='DefaultAddrPoolName', description='The name of the default address pool.'),
      defaultAddrPoolStatus?: string(name='DefaultAddrPoolStatus', description='The availability status of the default address pool. Valid values:

*   **AVAILABLE**: Available
*   **NOT_AVAILABLE**: Unavailable', example='AVAILABLE'),
      failoverAddrPoolId?: string(name='FailoverAddrPoolId', description='The ID of the failover address pool.', example='hra0i2'),
      failoverAddrPoolMonitorStatus?: string(name='FailoverAddrPoolMonitorStatus', description='Indicates whether health check was enabled for the failover address pool.', example='OPEN'),
      failoverAddrPoolName?: string(name='FailoverAddrPoolName', description='The name of the failover address pool.'),
      failoverAddrPoolStatus?: string(name='FailoverAddrPoolStatus', description='The availability status of the failover address pool.', example='AVAILABLE'),
      instanceId?: string(name='InstanceId', description='The ID of the GTM instance whose access policies you want to query.', example='instance1'),
      lines?: {
        line?: [ 
        {
          groupCode?: string(name='GroupCode', description='The code of the access region group.', example='DEFAULT'),
          groupName?: string(name='GroupName', description='The name of the access region group.'),
          lineCode?: string(name='LineCode', description='The code for the line of the access region.', example='default'),
          lineName?: string(name='LineName', description='The name for the line of the access region.'),
        }
      ](name='Line')
      }(name='Lines', description='The returned lines of access regions.'),
      strategyId?: string(name='StrategyId', description='The ID of the access policy.', example='hra0hs'),
      strategyMode?: string(name='StrategyMode', description='The mode of the access policy. **SELF_DEFINED** indicates that the access policy is user-defined.', example='SELF_DEFINED'),
      strategyName?: string(name='StrategyName', description='The name of the access policy.'),
    }
  ](name='Strategy')
  }(name='Strategies', description='The returned list of access policies of the GTM instance.'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned on all pages.', example='1'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeGtmAccessStrategiesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmAccessStrategiesResponseBody(name='body'),
}

/**
 * @summary You can call this operation to query the access policies of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeGtmAccessStrategiesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGtmAccessStrategiesResponse
 */
async function describeGtmAccessStrategiesWithOptions(request: DescribeGtmAccessStrategiesRequest, runtime: Util.RuntimeOptions): DescribeGtmAccessStrategiesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmAccessStrategies',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary You can call this operation to query the access policies of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeGtmAccessStrategiesRequest
 * @return DescribeGtmAccessStrategiesResponse
 */
async function describeGtmAccessStrategies(request: DescribeGtmAccessStrategiesRequest): DescribeGtmAccessStrategiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmAccessStrategiesWithOptions(request, runtime);
}

model DescribeGtmAccessStrategyRequest {
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy that you want to query.

This parameter is required.', example='hra0hs'),
}

model DescribeGtmAccessStrategyResponseBody = {
  accessMode?: string(name='AccessMode', description='The access policy.', example='AUTO'),
  accessStatus?: string(name='AccessStatus', description='The access status. Valid values:

*   **DEFAULT**: Indicates normal when the default address pool is accessed.
*   **FAILOVER**: Indicates an exception when a failover address pool is accessed.', example='DEFAULT'),
  defaultAddrPoolMonitorStatus?: string(name='DefaultAddrPoolMonitorStatus', description='Indicates whether health check is enabled for the default address pool.', example='OPEN'),
  defaultAddrPoolName?: string(name='DefaultAddrPoolName', description='The name of the default address pool.'),
  defaultAddrPoolStatus?: string(name='DefaultAddrPoolStatus', description='The availability status of the default address pool.', example='AVAILABLE'),
  defultAddrPoolId?: string(name='DefultAddrPoolId', description='The ID of the default address pool.', example='hra0i1'),
  failoverAddrPoolId?: string(name='FailoverAddrPoolId', description='The ID of the failover address pool.', example='hra0i2'),
  failoverAddrPoolMonitorStatus?: string(name='FailoverAddrPoolMonitorStatus', description='Indicates whether health check is enabled for the failover address pool.', example='OPEN'),
  failoverAddrPoolName?: string(name='FailoverAddrPoolName', description='The name of the failover address pool.'),
  failoverAddrPoolStatus?: string(name='FailoverAddrPoolStatus', description='The availability status of the failover address pool.', example='AVAILABLE'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance whose access policy details you want to query.', example='instance1'),
  lines?: {
    line?: [ 
    {
      groupCode?: string(name='GroupCode', description='The code of the access region group.', example='DEFAULT'),
      groupName?: string(name='GroupName', description='The name of the access region group.', example='Global'),
      lineCode?: string(name='LineCode', description='The code for the line of the access region.', example='default'),
      lineName?: string(name='LineName', description='The name for the line of the access region.', example='Global'),
    }
  ](name='Line')
  }(name='Lines', description='The returned lines of access regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BA1608CA-834C-4E63-8682-8AF0B11ED72D'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy queried.', example='hra0hs'),
  strategyMode?: string(name='StrategyMode', description='The mode of traffic scheduling.', example='SELF_DEFINED'),
  strategyName?: string(name='StrategyName', description='The name of the access policy queried.'),
}

model DescribeGtmAccessStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmAccessStrategyResponseBody(name='body'),
}

/**
 * @summary You can call this operation to query the details about an access policy of a Global Traffic Manager (GTM) instance based on the policy ID.
 *
 * @param request DescribeGtmAccessStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGtmAccessStrategyResponse
 */
async function describeGtmAccessStrategyWithOptions(request: DescribeGtmAccessStrategyRequest, runtime: Util.RuntimeOptions): DescribeGtmAccessStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmAccessStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary You can call this operation to query the details about an access policy of a Global Traffic Manager (GTM) instance based on the policy ID.
 *
 * @param request DescribeGtmAccessStrategyRequest
 * @return DescribeGtmAccessStrategyResponse
 */
async function describeGtmAccessStrategy(request: DescribeGtmAccessStrategyRequest): DescribeGtmAccessStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmAccessStrategyWithOptions(request, runtime);
}

model DescribeGtmAccessStrategyAvailableConfigRequest {
  instanceId?: string(name='InstanceId', description='The ID of the Global Traffic Manager (GTM) instance.

This parameter is required.', example='gtm-cn-xxxx'),
  lang?: string(name='Lang', description='The language.', example='en'),
}

model DescribeGtmAccessStrategyAvailableConfigResponseBody = {
  addrPools?: {
    addrPool?: [ 
    {
      addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.', example='hra0ix'),
      addrPoolName?: string(name='AddrPoolName', description='The name of the address pool.', example='test'),
    }
  ](name='AddrPool')
  }(name='AddrPools', description='The address pools.'),
  lines?: {
    line?: [ 
    {
      fatherCode?: string(name='FatherCode', description='The code of the parent line. No value is returned if no parent line exists.', example='telecom'),
      groupCode?: string(name='GroupCode', description='The group number of the DNS request source.', example='ISP'),
      groupName?: string(name='GroupName', description='The group name of the DNS request source.', example='Mainland China'),
      lineCode?: string(name='LineCode', description='The code of the DNS request source.', example='cn_telecom_hubei'),
      lineName?: string(name='LineName', description='The name of the DNS request source.', example='South China'),
      status?: string(name='Status', description='The state of the line. Valid values:

*   **FORBIDDEN**: The line is unavailable.
*   **OPTIONAL**: The line is available.', example='FORBIDDEN'),
    }
  ](name='Line')
  }(name='Lines', description='The Domain Name System (DNS) request sources.'),
  requestId?: string(name='RequestId', description='The request ID.', example='C2851BA9-CE56-49AF-8D12-4FC6A49EE688'),
  suggestSetDefaultLine?: boolean(name='SuggestSetDefaultLine', description='Indicates whether the global line is recommended.', example='True'),
}

model DescribeGtmAccessStrategyAvailableConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmAccessStrategyAvailableConfigResponseBody(name='body'),
}

/**
 * @summary Queries the configuration items that can be set for an access policy.
 *
 * @param request DescribeGtmAccessStrategyAvailableConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGtmAccessStrategyAvailableConfigResponse
 */
async function describeGtmAccessStrategyAvailableConfigWithOptions(request: DescribeGtmAccessStrategyAvailableConfigRequest, runtime: Util.RuntimeOptions): DescribeGtmAccessStrategyAvailableConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmAccessStrategyAvailableConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the configuration items that can be set for an access policy.
 *
 * @param request DescribeGtmAccessStrategyAvailableConfigRequest
 * @return DescribeGtmAccessStrategyAvailableConfigResponse
 */
async function describeGtmAccessStrategyAvailableConfig(request: DescribeGtmAccessStrategyAvailableConfigRequest): DescribeGtmAccessStrategyAvailableConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmAccessStrategyAvailableConfigWithOptions(request, runtime);
}

model DescribeGtmAvailableAlertGroupRequest {
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
}

model DescribeGtmAvailableAlertGroupResponseBody = {
  availableAlertGroup?: string(name='AvailableAlertGroup', description='The available alert groups of the GTM instance.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
}

model DescribeGtmAvailableAlertGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmAvailableAlertGroupResponseBody(name='body'),
}

/**
 * @param request DescribeGtmAvailableAlertGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGtmAvailableAlertGroupResponse
 */
async function describeGtmAvailableAlertGroupWithOptions(request: DescribeGtmAvailableAlertGroupRequest, runtime: Util.RuntimeOptions): DescribeGtmAvailableAlertGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmAvailableAlertGroup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeGtmAvailableAlertGroupRequest
 * @return DescribeGtmAvailableAlertGroupResponse
 */
async function describeGtmAvailableAlertGroup(request: DescribeGtmAvailableAlertGroupRequest): DescribeGtmAvailableAlertGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmAvailableAlertGroupWithOptions(request, runtime);
}

model DescribeGtmInstanceRequest {
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance.

This parameter is required.', example='instance1'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters.', example='en'),
  needDetailAttributes?: boolean(name='NeedDetailAttributes', description='Specifies whether additional information is required. Default value: **false**. If the value is **true**, the AccessStrategyNum and AddressPoolNum parameters are returned.', example='false'),
}

model DescribeGtmInstanceResponseBody = {
  accessStrategyNum?: int32(name='AccessStrategyNum', description='The number of access policies of the GTM instance.', example='5'),
  addressPoolNum?: int32(name='AddressPoolNum', description='The number of address pools of the GTM instance.', example='5'),
  alertGroup?: string(name='AlertGroup', description='The alert group of the GTM instance.', example='[\\\\\\\\"Daily test - R\\\\&D group\\\\\\\\"]'),
  cname?: string(name='Cname', description='The domain name of the GTM instance to which the service domain name is mapped by using a CNAME record.', example='instance1.14.com'),
  cnameMode?: string(name='CnameMode', description='Indicates whether the CNAME is a custom domain name or is assigned by the system. Valid values:

*   **SYSTEM_ASSIGN**
*   **CUSTOM**', example='SYSTEM_ASSIGN'),
  createTime?: string(name='CreateTime', description='The time when the GTM instance was created.', example='2018-06-06T11:34Z'),
  createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates the time when the GTM instance was created.', example='1528284856000'),
  expireTime?: string(name='ExpireTime', description='The time when the GTM instance expires.', example='2018-06-06T11:34Z'),
  expireTimestamp?: long(name='ExpireTimestamp', description='The timestamp that indicates the time when the GTM instance expires.', example='1528284856000'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance.', example='instance1'),
  instanceName?: string(name='InstanceName', description='The name of the GTM instance.', example='test'),
  lbaStrategy?: string(name='LbaStrategy', description='The load balancing policy. Valid values:

*   **ALL_RR**: round robin
*   **RATIO**: weighted round-robin', example='RATIO'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E41AA251-F9BA-48C6-99B2-2B82B26A573A'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-testgroupid'),
  ttl?: int32(name='Ttl', description='The global time to live (TTL).', example='60'),
  userDomainName?: string(name='UserDomainName', description='The domain name of the application.', example='www.example.com'),
  versionCode?: string(name='VersionCode', description='The version code.', example='biaozhun'),
}

model DescribeGtmInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmInstanceResponseBody(name='body'),
}

/**
 * @summary Queries the details about a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeGtmInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGtmInstanceResponse
 */
async function describeGtmInstanceWithOptions(request: DescribeGtmInstanceRequest, runtime: Util.RuntimeOptions): DescribeGtmInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.needDetailAttributes)) {
    query['NeedDetailAttributes'] = request.needDetailAttributes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmInstance',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details about a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeGtmInstanceRequest
 * @return DescribeGtmInstanceResponse
 */
async function describeGtmInstance(request: DescribeGtmInstanceRequest): DescribeGtmInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmInstanceWithOptions(request, runtime);
}

model DescribeGtmInstanceAddressPoolRequest {
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool that you want to query.

This parameter is required.', example='1234'),
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
}

model DescribeGtmInstanceAddressPoolResponseBody = {
  addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool queried.', example='2'),
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.', example='1234abc'),
  addrs?: {
    addr?: [ 
    {
      addrId?: long(name='AddrId', description='The ID of the address.', example='123'),
      alertStatus?: string(name='AlertStatus', description='Indicates whether health check was enabled for the address. Valid values:

*   **OK**: Normal
*   **ALERT**: Alert', example='OK'),
      createTime?: string(name='CreateTime', description='The time when the address pool was created.', example='2017-12-28T13:08Z'),
      createTimestamp?: long(name='CreateTimestamp', example='1527690629357'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address.', example='1'),
      mode?: string(name='Mode', description='The mode of the address. Valid values:

*   **SMART**: Intelligent return
*   **ONLINE**: Always online
*   **OFFLINE**: Always offline', example='SMART'),
      updateTime?: string(name='UpdateTime', description='The last time when the address was updated.', example='2017-12-28T13:08Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='A timestamp that indicates the last time when the address was updated.', example='1527690629357'),
      value?: string(name='Value', description='The address.', example='1.1.1.1'),
    }
  ](name='Addr')
  }(name='Addrs', description='The addresses in the address pool.'),
  createTime?: string(name='CreateTime', description='The time when the address pool was created.', example='2017-12-28T13:08Z'),
  createTimestamp?: long(name='CreateTimestamp', example='1527690629357'),
  minAvailableAddrNum?: int32(name='MinAvailableAddrNum', description='The minimum number of available addresses in the address pool.', example='2'),
  monitorConfigId?: string(name='MonitorConfigId', description='The health check ID of the address pool.', example='100abc'),
  monitorStatus?: string(name='MonitorStatus', description='Indicates whether health check was enabled for the address pool. Valid values:

*   **OPEN**: Enabled
*   **CLOSE**: Disabled
*   **UNCONFIGURED**: Not configured', example='OPEN'),
  name?: string(name='Name', description='The name of the address pool.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  status?: string(name='Status', description='The availability status of the address pool. Valid values:

*   **AVAILABLE**: Available
*   **NOT_AVAILABLE**: Unavailable', example='AVAILABLE'),
  type?: string(name='Type', description='The type of the address pool. Valid values:

*   **IP**: IP address
*   **DOMAIN**: Domain name', example='IP'),
  updateTime?: string(name='UpdateTime', description='The last time when the address pool was updated.', example='2017-12-28T13:08Z'),
  updateTimestamp?: long(name='UpdateTimestamp', description='A timestamp that indicates the last time the address pool was updated.', example='1527690629357'),
}

model DescribeGtmInstanceAddressPoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmInstanceAddressPoolResponseBody(name='body'),
}

/**
 * @summary You can call this operation to query the details about an address pool of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeGtmInstanceAddressPoolRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGtmInstanceAddressPoolResponse
 */
async function describeGtmInstanceAddressPoolWithOptions(request: DescribeGtmInstanceAddressPoolRequest, runtime: Util.RuntimeOptions): DescribeGtmInstanceAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addrPoolId)) {
    query['AddrPoolId'] = request.addrPoolId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmInstanceAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary You can call this operation to query the details about an address pool of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeGtmInstanceAddressPoolRequest
 * @return DescribeGtmInstanceAddressPoolResponse
 */
async function describeGtmInstanceAddressPool(request: DescribeGtmInstanceAddressPoolRequest): DescribeGtmInstanceAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmInstanceAddressPoolWithOptions(request, runtime);
}

model DescribeGtmInstanceAddressPoolsRequest {
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance that you want to query.

This parameter is required.', example='gtmtest'),
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return per page. Maximum value: **100**. Default value: **20**.', example='20'),
}

model DescribeGtmInstanceAddressPoolsResponseBody = {
  addrPools?: {
    addrPool?: [ 
    {
      addrCount?: int32(name='AddrCount', description='The number of addresses in the address pool.', example='2'),
      addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.', example='1234abc'),
      createTime?: string(name='CreateTime', description='The time when this address pool was created.', example='2017-12-28T13:08Z'),
      createTimestamp?: long(name='CreateTimestamp', example='1527690629357'),
      minAvailableAddrNum?: int32(name='MinAvailableAddrNum', description='The minimum number of available addresses in the address pool.', example='2'),
      monitorConfigId?: string(name='MonitorConfigId', description='The health check ID of the address pool.', example='100abc'),
      monitorStatus?: string(name='MonitorStatus', description='Indicates whether health check was enabled for the address pool. Valid values:

*   **OPEN**: Enabled
*   **CLOSE**: Disabled
*   **UNCONFIGURED**: Not configured', example='OPEN'),
      name?: string(name='Name', description='The name of the address pool.'),
      status?: string(name='Status', description='The availability status of the address pool. Valid values:

*   **AVAILABLE**: Available
*   **NOT_AVAILABLE**: Unavailable', example='AVAILABLE'),
      type?: string(name='Type', description='The type of the address pool. Valid values:

*   **IP**: IP address
*   **DOMAIN**: Domain name', example='IP'),
      updateTime?: string(name='UpdateTime', description='The last time when the address pool was updated.', example='2017-12-28T13:08Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='A timestamp that indicates the last time the address pool was updated.', example='1527690629357'),
    }
  ](name='AddrPool')
  }(name='AddrPools', description='The returned list of address pools of the GTM instance.'),
  pageNumber?: int32(name='PageNumber', description='The number of the page returned.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned on all pages.', example='2'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeGtmInstanceAddressPoolsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmInstanceAddressPoolsResponseBody(name='body'),
}

/**
 * @summary You can call this operation to query the address pools of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeGtmInstanceAddressPoolsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGtmInstanceAddressPoolsResponse
 */
async function describeGtmInstanceAddressPoolsWithOptions(request: DescribeGtmInstanceAddressPoolsRequest, runtime: Util.RuntimeOptions): DescribeGtmInstanceAddressPoolsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmInstanceAddressPools',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary You can call this operation to query the address pools of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeGtmInstanceAddressPoolsRequest
 * @return DescribeGtmInstanceAddressPoolsResponse
 */
async function describeGtmInstanceAddressPools(request: DescribeGtmInstanceAddressPoolsRequest): DescribeGtmInstanceAddressPoolsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmInstanceAddressPoolsWithOptions(request, runtime);
}

model DescribeGtmInstanceStatusRequest {
  instanceId?: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='instance1'),
  lang?: string(name='Lang', description='The language.', example='en'),
}

model DescribeGtmInstanceStatusResponseBody = {
  addrNotAvailableNum?: int32(name='AddrNotAvailableNum', description='The number of unavailable addresses.', example='10'),
  addrPoolNotAvailableNum?: int32(name='AddrPoolNotAvailableNum', description='The number of unavailable address pools.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='389DFFA3-77A5-4A9E-BF3D-147C6F98A5BA'),
  status?: string(name='Status', description='The state of the instance. Valid values:

*   ALLOW: The operation on the instance is allowed.
*   DENY: The operation on the instance is not allowed.', example='ALLOW'),
  statusReason?: string(name='StatusReason', description='The reasons why the instance is in the current state. Valid values:

*   INSTANCE_OPERATE_BLACK_LIST: The operation on the instance is not allowed.
*   BETA_INSTANCE: The instance is in public preview.', example='["BETA_INSTANCE"]'),
  strategyNotAvailableNum?: int32(name='StrategyNotAvailableNum', description='The number of unavailable access policies.', example='10'),
  switchToFailoverStrategyNum?: int32(name='SwitchToFailoverStrategyNum', description='The number of access policies switched to the secondary address pool.', example='10'),
}

model DescribeGtmInstanceStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmInstanceStatusResponseBody(name='body'),
}

/**
 * @summary Queries the status of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeGtmInstanceStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGtmInstanceStatusResponse
 */
async function describeGtmInstanceStatusWithOptions(request: DescribeGtmInstanceStatusRequest, runtime: Util.RuntimeOptions): DescribeGtmInstanceStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmInstanceStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the status of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeGtmInstanceStatusRequest
 * @return DescribeGtmInstanceStatusResponse
 */
async function describeGtmInstanceStatus(request: DescribeGtmInstanceStatusRequest): DescribeGtmInstanceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmInstanceStatusWithOptions(request, runtime);
}

model DescribeGtmInstanceSystemCnameRequest {
  instanceId?: string(name='InstanceId', description='The ID of the Global Traffic Manager (GTM) instance.

This parameter is required.', example='instance1'),
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
}

model DescribeGtmInstanceSystemCnameResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  systemCname?: string(name='SystemCname', description='The CNAME record assigned by the system.', example='gtm-cn-mp91004xxxx.gtm-a2b4.com'),
}

model DescribeGtmInstanceSystemCnameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmInstanceSystemCnameResponseBody(name='body'),
}

/**
 * @param request DescribeGtmInstanceSystemCnameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGtmInstanceSystemCnameResponse
 */
async function describeGtmInstanceSystemCnameWithOptions(request: DescribeGtmInstanceSystemCnameRequest, runtime: Util.RuntimeOptions): DescribeGtmInstanceSystemCnameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmInstanceSystemCname',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeGtmInstanceSystemCnameRequest
 * @return DescribeGtmInstanceSystemCnameResponse
 */
async function describeGtmInstanceSystemCname(request: DescribeGtmInstanceSystemCnameRequest): DescribeGtmInstanceSystemCnameResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmInstanceSystemCnameWithOptions(request, runtime);
}

model DescribeGtmInstancesRequest {
  keyword?: string(name='Keyword', description='The keyword that you use for query. Exact match is supported by instance ID or instance name.', example='test'),
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.', example='en'),
  needDetailAttributes?: boolean(name='NeedDetailAttributes', description='Specifies whether additional information is required. Default value: **false**.', example='false'),
  pageNumber?: int32(name='PageNumber', description='The page number to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return per page.', example='20'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-xxxxx'),
}

model DescribeGtmInstancesResponseBody = {
  gtmInstances?: {
    gtmInstance?: [ 
    {
      accessStrategyNum?: int32(name='AccessStrategyNum', description='The number of access policies.', example='5'),
      addressPoolNum?: int32(name='AddressPoolNum', description='The number of address pools.', example='5'),
      alertGroup?: string(name='AlertGroup', description='The name of the alert group.', example='[\\\\\\\\"R\\\\&D group\\\\\\\\"]'),
      cname?: string(name='Cname', description='The CNAME domain name that is used to access the instance.', example='instance1.14.com'),
      cnameMode?: string(name='CnameMode', description='The CNAME domain name used to access the instance. Valid values:

*   **SYSTEM_ASSIGN**: A CNAME domain name assigned by the system is used.
*   **CUSTOM**: A custom CNAME domain name is used.', example='SYSTEM_ASSIGN'),
      createTime?: string(name='CreateTime', description='The time when the instance was created.', example='2018-06-06T11:34Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The UNIX timestamp that indicates when the instance was created.', example='1528284856000'),
      expireTime?: string(name='ExpireTime', description='The time when the instance expires.', example='2018-06-06T11:34Z'),
      expireTimestamp?: long(name='ExpireTimestamp', description='The UNIX timestamp that indicates when the instance expires.', example='1528284856000'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='instance1'),
      instanceName?: string(name='InstanceName', description='The name of the instance.', example='test'),
      lbaStrategy?: string(name='LbaStrategy', description='The load balancing policy that is used. Valid values:

*   **ALL_RR**: Load balancing
*   **RATIO**: Weighted round-robin', example='RATIO'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs.', example='rg-acfm2q2jqpjh***'),
      ttl?: int32(name='Ttl', description='The global time to live (TTL).', example='60'),
      userDomainName?: string(name='UserDomainName', description='The domain name of the user.', example='www.example.com'),
      versionCode?: string(name='VersionCode', description='The version code of the instance.', example='biaozhun'),
    }
  ](name='GtmInstance')
  }(name='GtmInstances', description='The list of queried instances.'),
  pageNumber?: int32(name='PageNumber', description='The returned page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='193B0163-7F93-42DF-AB05-ACEEB7D22707'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned.', example='1'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeGtmInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmInstancesResponseBody(name='body'),
}

/**
 * @summary Queries the Global Traffic Manager (GTM) instances under your account.
 *
 * @param request DescribeGtmInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGtmInstancesResponse
 */
async function describeGtmInstancesWithOptions(request: DescribeGtmInstancesRequest, runtime: Util.RuntimeOptions): DescribeGtmInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.needDetailAttributes)) {
    query['NeedDetailAttributes'] = request.needDetailAttributes;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmInstances',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the Global Traffic Manager (GTM) instances under your account.
 *
 * @param request DescribeGtmInstancesRequest
 * @return DescribeGtmInstancesResponse
 */
async function describeGtmInstances(request: DescribeGtmInstancesRequest): DescribeGtmInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmInstancesWithOptions(request, runtime);
}

model DescribeGtmLogsRequest {
  endTimestamp?: long(name='EndTimestamp', description='The timestamp that specifies the end of the time range to query.', example='1363453350000'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance whose logs you want to query.', example='gtm-cn-xxxxx'),
  keyword?: string(name='Keyword', description='The keyword for searching logs, in case-insensitive "%Keyword%" format.', example='test'),
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: **100**. Default value: **20**.', example='20'),
  startTimestamp?: long(name='StartTimestamp', description='The beginning of the time range to query.', example='1363453340000'),
}

model DescribeGtmLogsResponseBody = {
  logs?: {
    log?: [ 
    {
      content?: string(name='Content', description='The formatted message content.', example='addtest-pool-1'),
      entityId?: string(name='EntityId', description='The ID of the object that was operated on.', example='121212'),
      entityName?: string(name='EntityName', description='The name of the object that was operated on.', example='test-pool-1'),
      entityType?: string(name='EntityType', description='The type of the object that was operated on.', example='POOL'),
      id?: long(name='Id', description='The ID of the log record.', example='6726'),
      operAction?: string(name='OperAction', description='The operation performed.', example='add'),
      operIp?: string(name='OperIp', description='The IP address subject to the operation.', example='106.11.34.X'),
      operTime?: string(name='OperTime', description='The time when the operation was performed.', example='2018-01-24T07:35Z'),
      operTimestamp?: long(name='OperTimestamp', description='A timestamp that indicates the time when the operation was performed.', example='1516779348000'),
    }
  ](name='Log')
  }(name='Logs', description='The list of logs returned.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='50C60A29-2E93-425A-ABA8-068686E28873'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned on all pages.', example='224'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='224'),
}

model DescribeGtmLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmLogsResponseBody(name='body'),
}

/**
 * @summary You can call this operation to query logs of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeGtmLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGtmLogsResponse
 */
async function describeGtmLogsWithOptions(request: DescribeGtmLogsRequest, runtime: Util.RuntimeOptions): DescribeGtmLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTimestamp)) {
    query['EndTimestamp'] = request.endTimestamp;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTimestamp)) {
    query['StartTimestamp'] = request.startTimestamp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmLogs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary You can call this operation to query logs of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeGtmLogsRequest
 * @return DescribeGtmLogsResponse
 */
async function describeGtmLogs(request: DescribeGtmLogsRequest): DescribeGtmLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmLogsWithOptions(request, runtime);
}

model DescribeGtmMonitorAvailableConfigRequest {
  lang?: string(name='Lang', description='The language of the values of specific response parameters.', example='en'),
}

model DescribeGtmMonitorAvailableConfigResponseBody = {
  ispCityNodes?: {
    ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the city where the monitored node is deployed.', example='503'),
      cityName?: string(name='CityName', description='The display name of the city where the monitored node is deployed.', example='Zhangjiakou'),
      defaultSelected?: boolean(name='DefaultSelected', description='Indicates whether the monitored node is selected for the health check by default.', example='true'),
      groupName?: string(name='GroupName', description='The name of the group to which the monitored node belongs.

Valid values: Overseas Nodes, BGP Nodes, and ISP Nodes.', example='Overseas Nodes'),
      groupType?: string(name='GroupType', description='The type of the group to which the monitored node belongs.

Valid values: BGP, OVERSEAS, and ISP.', example='OVERSEAS'),
      ispCode?: string(name='IspCode', description='The code of the Internet service provider (ISP) to which the monitored node belongs.

*   If the value of the GroupType parameter is BGP or OVERSEAS, the value of IspCode is 465 by default.
*   If the value of the GroupType parameter is not BGP or OVERSEAS, valid values of IspCode are 232, 132, and 5. and is used together with CityCode.', example='465'),
      ispName?: string(name='IspName', description='The display name of the ISP to which the monitored node belongs.', example='Alibaba'),
      mainland?: boolean(name='Mainland', description='Indicates whether the monitored node is deployed in the Chinese mainland.', example='true'),
    }
  ](name='IspCityNode')
  }(name='IspCityNodes', description='The monitored nodes.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model DescribeGtmMonitorAvailableConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmMonitorAvailableConfigResponseBody(name='body'),
}

/**
 * @summary Queries available monitored nodes.
 *
 * @param request DescribeGtmMonitorAvailableConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGtmMonitorAvailableConfigResponse
 */
async function describeGtmMonitorAvailableConfigWithOptions(request: DescribeGtmMonitorAvailableConfigRequest, runtime: Util.RuntimeOptions): DescribeGtmMonitorAvailableConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmMonitorAvailableConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries available monitored nodes.
 *
 * @param request DescribeGtmMonitorAvailableConfigRequest
 * @return DescribeGtmMonitorAvailableConfigResponse
 */
async function describeGtmMonitorAvailableConfig(request: DescribeGtmMonitorAvailableConfigRequest): DescribeGtmMonitorAvailableConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmMonitorAvailableConfigWithOptions(request, runtime);
}

model DescribeGtmMonitorConfigRequest {
  lang?: string(name='Lang', description='The language of the values of specific response parameters.', example='en'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.

This parameter is required.', example='100'),
}

model DescribeGtmMonitorConfigResponseBody = {
  createTime?: string(name='CreateTime', description='The time when the health check configuration was created.', example='2017-12-28T13:08Z'),
  createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates the time when the health check configuration was created.', example='1527690629357'),
  evaluationCount?: int32(name='EvaluationCount', description='The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.', example='3'),
  interval?: int32(name='Interval', description='The health check interval. Unit: seconds. The value is 60.', example='60'),
  ispCityNodes?: {
    ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the city where the monitored node is deployed.', example='503'),
      cityName?: string(name='CityName', description='The display name of the city where the monitored node is deployed.', example='Zhangjiakou'),
      countryCode?: string(name='CountryCode', description='The code of the country where the monitored node is deployed.', example='001'),
      countryName?: string(name='CountryName', description='The display name of the country where the monitored node is deployed.', example='China'),
      ispCode?: string(name='IspCode', description='The code of the Internet service provider (ISP) to which the monitored node belongs.', example='465'),
      ispName?: string(name='IspName', description='The display name of the ISP to which the monitored node belongs.', example='Alibaba'),
    }
  ](name='IspCityNode')
  }(name='IspCityNodes', description='The monitored nodes.'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.', example='1234abc'),
  monitorExtendInfo?: string(name='MonitorExtendInfo', description='The extended information, that is, the parameters required for the protocol. Different protocols require different parameters:

HTTP or HTTPS:

*   port: the port to check.
*   failureRate: the failure rate.
*   code: the status code threshold. If the returned status code is greater than the specified threshold, the application service is deemed abnormal. Valid values: 400 and 500.
*   host: the host configuration.
*   path: the health check URL.

PING:

*   packetNum: the number of ping packets.
*   packetLossRate: the loss rate of ping packets.
*   failureRate: the failure rate.

TCP:

*   port: the port to check.
*   failureRate: the failure rate.', example='{\\\\"code\\\\":200,\\\\"path\\\\":\\\\"\\\\\\\\index.htm\\\\",\\\\"host\\\\":\\\\"aliyun.com\\\\"}'),
  protocolType?: string(name='ProtocolType', description='The protocol used for the health check.', example='HTTP'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  timeout?: int32(name='Timeout', description='The health check timeout period. Unit: milliseconds. Valid values: 2000, 3000, 5000, and 10000.', example='3000'),
  updateTime?: string(name='UpdateTime', description='The time when the health check configuration was last updated.', example='2017-12-28T13:08Z'),
  updateTimestamp?: long(name='UpdateTimestamp', description='The timestamp that indicates the time when the health check configuration was last updated.', example='1527690629357'),
}

model DescribeGtmMonitorConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmMonitorConfigResponseBody(name='body'),
}

/**
 * @summary Queries the health check configuration of an address pool of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeGtmMonitorConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGtmMonitorConfigResponse
 */
async function describeGtmMonitorConfigWithOptions(request: DescribeGtmMonitorConfigRequest, runtime: Util.RuntimeOptions): DescribeGtmMonitorConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.monitorConfigId)) {
    query['MonitorConfigId'] = request.monitorConfigId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmMonitorConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the health check configuration of an address pool of a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeGtmMonitorConfigRequest
 * @return DescribeGtmMonitorConfigResponse
 */
async function describeGtmMonitorConfig(request: DescribeGtmMonitorConfigRequest): DescribeGtmMonitorConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmMonitorConfigWithOptions(request, runtime);
}

model DescribeGtmRecoveryPlanRequest {
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en.', example='en'),
  recoveryPlanId?: long(name='RecoveryPlanId', description='The ID of the disaster recovery plan.

This parameter is required.', example='100'),
}

model DescribeGtmRecoveryPlanResponseBody = {
  createTime?: string(name='CreateTime', description='The time when the disaster recovery plan was created. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.', example='2019-08-11T05:04Z'),
  createTimestamp?: long(name='CreateTimestamp', description='The time when the disaster recovery plan was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1565499867000'),
  faultAddrPoolNum?: int32(name='FaultAddrPoolNum', description='The number of faulty address pools.', example='2'),
  faultAddrPools?: {
    faultAddrPool?: [ 
    {
      addrPoolId?: string(name='AddrPoolId', description='The address pool ID.', example='hra0oq'),
      addrPoolName?: string(name='AddrPoolName', description='The address pool name.'),
      addrs?: {
        addr?: [ 
        {
          id?: long(name='Id', description='The address ID.', example='739'),
          mode?: string(name='Mode', description='The address mode.', example='OFFLINE'),
          value?: string(name='Value', description='The address.', example='1.1.1.1'),
        }
      ](name='Addr')
      }(name='Addrs'),
      instanceId?: string(name='InstanceId', description='The instance ID.', example='instance-zwy-38'),
    }
  ](name='FaultAddrPool')
  }(name='FaultAddrPools', description='The faulty address pools.'),
  lastExecuteTime?: string(name='LastExecuteTime', description='The time when the disaster recovery plan was last executed. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.', example='2019-08-11T05:04Z'),
  lastExecuteTimestamp?: long(name='LastExecuteTimestamp', description='The time when the disaster recovery plan was last executed. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1565505898000'),
  lastRollbackTime?: string(name='LastRollbackTime', description='The time when the disaster recovery plan was last rolled back. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='2019-08-11T06:45Z'),
  lastRollbackTimestamp?: long(name='LastRollbackTimestamp', description='The time when the disaster recovery plan was last rolled back. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1565505919000'),
  name?: string(name='Name', description='The name of the disaster recovery plan.', example='name-example'),
  recoveryPlanId?: long(name='RecoveryPlanId', description='The ID of the disaster recovery plan.', example='55'),
  remark?: string(name='Remark', description='The description of the disaster recovery plan.', example='remark-example'),
  requestId?: string(name='RequestId', description='The request ID.', example='0A5F4315-D6E8-435E-82DF-24F4C97D6999'),
  status?: string(name='Status', description='The status of the disaster recovery plan.', example='UNEXECUTED'),
  updateTime?: string(name='UpdateTime', description='The time when the disaster recovery plan was last modified. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.', example='2019-08-11T06:45Z'),
  updateTimestamp?: long(name='UpdateTimestamp', description='The time when the disaster recovery plan was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1565499867000'),
}

model DescribeGtmRecoveryPlanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmRecoveryPlanResponseBody(name='body'),
}

/**
 * @summary Queries the details of a disaster recovery plan.
 *
 * @param request DescribeGtmRecoveryPlanRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGtmRecoveryPlanResponse
 */
async function describeGtmRecoveryPlanWithOptions(request: DescribeGtmRecoveryPlanRequest, runtime: Util.RuntimeOptions): DescribeGtmRecoveryPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recoveryPlanId)) {
    query['RecoveryPlanId'] = request.recoveryPlanId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmRecoveryPlan',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of a disaster recovery plan.
 *
 * @param request DescribeGtmRecoveryPlanRequest
 * @return DescribeGtmRecoveryPlanResponse
 */
async function describeGtmRecoveryPlan(request: DescribeGtmRecoveryPlanRequest): DescribeGtmRecoveryPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmRecoveryPlanWithOptions(request, runtime);
}

model DescribeGtmRecoveryPlanAvailableConfigRequest {
  lang?: string(name='Lang', description='The language in which the returned results are displayed. Valid values:

*   zh: Chinese
*   en: English

Default value: en.', example='en'),
}

model DescribeGtmRecoveryPlanAvailableConfigResponseBody = {
  instances?: {
    instance?: [ 
    {
      addrPools?: {
        addrPool?: [ 
        {
          addrPoolId?: string(name='AddrPoolId', description='The address pool ID.'),
          name?: string(name='Name', description='The name of the address pool.', example='hra0i9'),
        }
      ](name='AddrPool')
      }(name='AddrPools', description='The address pools.'),
      instanceId?: string(name='InstanceId', description='The instance ID.', example='instance-example'),
      instanceName?: string(name='InstanceName', description='The instance name.', example='instance-name-example'),
    }
  ](name='Instance')
  }(name='Instances', description='The instances.'),
  requestId?: string(name='RequestId', description='The request ID.', example='F8F8EF50-8B7F-4702-B294-97170A423403'),
}

model DescribeGtmRecoveryPlanAvailableConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmRecoveryPlanAvailableConfigResponseBody(name='body'),
}

/**
 * @summary Queries the configuration items that can be set for a disaster recovery plan.
 *
 * @param request DescribeGtmRecoveryPlanAvailableConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGtmRecoveryPlanAvailableConfigResponse
 */
async function describeGtmRecoveryPlanAvailableConfigWithOptions(request: DescribeGtmRecoveryPlanAvailableConfigRequest, runtime: Util.RuntimeOptions): DescribeGtmRecoveryPlanAvailableConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmRecoveryPlanAvailableConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the configuration items that can be set for a disaster recovery plan.
 *
 * @param request DescribeGtmRecoveryPlanAvailableConfigRequest
 * @return DescribeGtmRecoveryPlanAvailableConfigResponse
 */
async function describeGtmRecoveryPlanAvailableConfig(request: DescribeGtmRecoveryPlanAvailableConfigRequest): DescribeGtmRecoveryPlanAvailableConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmRecoveryPlanAvailableConfigWithOptions(request, runtime);
}

model DescribeGtmRecoveryPlansRequest {
  keyword?: string(name='Keyword', description='The keyword for the query. Fuzzy match is supported by disaster recovery plan name.', example='test'),
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.', example='en'),
  pageNumber?: int32(name='PageNumber', description='The page number to return. The page number starts from **1**. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return per page. Maximum value: **100**. Default value: **20**.', example='20'),
}

model DescribeGtmRecoveryPlansResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  recoveryPlans?: {
    recoveryPlan?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the disaster recovery plan was created.', example='2019-08-11T06:45Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The UNIX timestamp that indicates when the disaster recovery plan was created.', example='1565499867000'),
      faultAddrPoolNum?: int32(name='FaultAddrPoolNum', description='The number of faulty address pools.', example='0'),
      lastExecuteTime?: string(name='LastExecuteTime', description='The last time when the disaster recovery plan was executed.', example='2019-08-11T06:44Z'),
      lastExecuteTimestamp?: long(name='LastExecuteTimestamp', description='The UNIX timestamp that indicates the last time when the disaster recovery plan was executed.', example='1565505898000'),
      lastRollbackTime?: string(name='LastRollbackTime', description='The last time when the disaster recovery plan was rolled back.', example='2019-08-11T06:45Z'),
      lastRollbackTimestamp?: long(name='LastRollbackTimestamp', description='The UNIX timestamp that indicates the last time when the disaster recovery plan was rolled back.', example='1565505919000'),
      name?: string(name='Name', description='The name of the disaster recovery plan.', example='name-example'),
      recoveryPlanId?: long(name='RecoveryPlanId', description='The ID of the disaster recovery plan.', example='55'),
      remark?: string(name='Remark', description='The remarks about the disaster recovery plan.', example='remark-example'),
      status?: string(name='Status', description='The status of the disaster recovery plan. Valid values:

*   **UNEXECUTED**: The plan is not executed.
*   **EXECUTED**: The plan is executed.
*   **ROLLED_BACK**: The plan is rolled back.', example='UNEXECUTED'),
      updateTime?: string(name='UpdateTime', description='The last time when the disaster recovery plan was updated.', example='2019-08-11T06:45Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The UNIX timestamp that indicates the last time when the disaster recovery plan was updated.', example='1565505919000'),
    }
  ](name='RecoveryPlan')
  }(name='RecoveryPlans', description='The details about the queried disaster recovery plans.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2BA072CF-CA21-4A34-B6C2-227BE2C58079'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned.', example='10'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeGtmRecoveryPlansResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGtmRecoveryPlansResponseBody(name='body'),
}

/**
 * @summary Queries the disaster recovery plans for a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeGtmRecoveryPlansRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGtmRecoveryPlansResponse
 */
async function describeGtmRecoveryPlansWithOptions(request: DescribeGtmRecoveryPlansRequest, runtime: Util.RuntimeOptions): DescribeGtmRecoveryPlansResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGtmRecoveryPlans',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the disaster recovery plans for a Global Traffic Manager (GTM) instance.
 *
 * @param request DescribeGtmRecoveryPlansRequest
 * @return DescribeGtmRecoveryPlansResponse
 */
async function describeGtmRecoveryPlans(request: DescribeGtmRecoveryPlansRequest): DescribeGtmRecoveryPlansResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGtmRecoveryPlansWithOptions(request, runtime);
}

model DescribeInstanceDomainsRequest {
  instanceId?: string(name='InstanceId', description='The ID of the Alibaba Cloud Domain Name System (DNS) instance. You can call the [DescribeDomainInfo](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomaininfo?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.

This parameter is required.', example='weriwieru'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: English.', example='en'),
  pageNumber?: long(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: 1 to 100. Default value: 20.', example='2'),
}

model DescribeInstanceDomainsResponseBody = {
  instanceDomains?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the instance was created. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2020-03-09T02:15Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The time when the instance was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1583720154000'),
      domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
    }
  ](name='InstanceDomains', description='The domain names that are bound to the DNS instance.'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: **1 to 100**. Default value: **20**.', example='2'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='68386699-8B9E-4D5B-BC4C-75A28F6C2A00'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned on all pages.', example='2'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='2'),
}

model DescribeInstanceDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInstanceDomainsResponseBody(name='body'),
}

/**
 * @summary Queries the domain names that are bound to an Alibaba Cloud DNS instance.
 *
 * @param request DescribeInstanceDomainsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstanceDomainsResponse
 */
async function describeInstanceDomainsWithOptions(request: DescribeInstanceDomainsRequest, runtime: Util.RuntimeOptions): DescribeInstanceDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceDomains',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the domain names that are bound to an Alibaba Cloud DNS instance.
 *
 * @param request DescribeInstanceDomainsRequest
 * @return DescribeInstanceDomainsResponse
 */
async function describeInstanceDomains(request: DescribeInstanceDomainsRequest): DescribeInstanceDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceDomainsWithOptions(request, runtime);
}

model DescribeInternetDnsLogsRequest {
  accountId?: long(name='AccountId', description='The account ID displayed on the Recursive Resolution (Public DNS) page after you activate Alibaba Cloud Public DNS.', example='51**4'),
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  endTimestamp?: long(name='EndTimestamp', description='The end time of the query (timestamp, unit: milliseconds). >Warning: If the query time span is too large and the amount of resolution logs for the queried domain is excessive, it may lead to a query timeout or inaccurate query results.', example='1709196299999'),
  lang?: string(name='Lang', description='Return value language, options: 
- zh: Chinese 
- en: English

Default: en', example='en'),
  module?: string(name='Module', description='Module type 
- AUTHORITY (default): Public Authoritative DNS 
- RECURSION: Public Recursive DNS', example='AUTHORITY'),
  pageNumber?: int32(name='PageNumber', description='Page number, default value is 1.', example='1'),
  pageSize?: int32(name='PageSize', description='Page size for query.', example='10'),
  queryCondition?: string(name='QueryCondition', description='Query parameters 
- sourceIp: Source IP address 
- queryNameFuzzy: Domain name (fuzzy value) 
- queryType: Record type 
- value: Resolution result 
- status: Status 
- serverIp: Resolution server IP', example='{"sourceIp":"59.82.XX.XX","queryType":"A"}'),
  startTimestamp?: long(name='StartTimestamp', description='The start time of the query (timestamp, unit: milliseconds).', example='1709192640000'),
}

model DescribeInternetDnsLogsResponseBody = {
  complete?: boolean(name='Complete', description='Indicates whether the log query is precise.', example='true'),
  curPage?: int32(name='CurPage', description='Current page number.', example='1'),
  logs?: {
    log?: [ 
    {
      dnsMsgId?: string(name='DnsMsgId', description='Parse log ID (can be duplicated).', example='3583'),
      logTime?: long(name='LogTime', description='Parse timestamp.', example='1709196249000'),
      protocol?: string(name='Protocol', description='The protocol type of the domain name resolution query request:
- UDP
- TCP
- HTTP
- HTTPS
- DOH', example='UDP'),
      queryName?: string(name='QueryName', description='The domain name for which you want to query Domain Name System (DNS) records.', example='example.com'),
      queryType?: string(name='QueryType', description='Record type.', example='A'),
      rt?: int32(name='Rt', description='Parse response time.', example='0'),
      serverIp?: string(name='ServerIp', description='Parse server IP.', example='140.205.XX.XX'),
      sourceIp?: string(name='SourceIp', description='Source IP address.', example='59.82.XX.XX'),
      status?: string(name='Status', description='Response status.', example='NOERROR'),
      subnetIp?: string(name='SubnetIp', description='The value set for the edns-client-subnet option.', example='170.33.XX.XX'),
      value?: {
        value?: [ string ](name='Value')
      }(name='Value', description='Array of parsing results.'),
      zoneName?: string(name='ZoneName', description='The zone name.', example='example.com'),
    }
  ](name='Log')
  }(name='Logs', description='The queried logs.'),
  pageSize?: int32(name='PageSize', description='Page size for query.', example='10'),
  requestId?: string(name='RequestId', description='Unique request identifier.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalPage?: int32(name='TotalPage', description='Total number of pages.', example='5'),
  totalSize?: int32(name='TotalSize', description='Total quantity.', example='48'),
}

model DescribeInternetDnsLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInternetDnsLogsResponseBody(name='body'),
}

/**
 * @param request DescribeInternetDnsLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInternetDnsLogsResponse
 */
async function describeInternetDnsLogsWithOptions(request: DescribeInternetDnsLogsRequest, runtime: Util.RuntimeOptions): DescribeInternetDnsLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountId)) {
    query['AccountId'] = request.accountId;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTimestamp)) {
    query['EndTimestamp'] = request.endTimestamp;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.module)) {
    query['Module'] = request.module;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queryCondition)) {
    query['QueryCondition'] = request.queryCondition;
  }
  if (!Util.isUnset(request.startTimestamp)) {
    query['StartTimestamp'] = request.startTimestamp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInternetDnsLogs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeInternetDnsLogsRequest
 * @return DescribeInternetDnsLogsResponse
 */
async function describeInternetDnsLogs(request: DescribeInternetDnsLogsRequest): DescribeInternetDnsLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInternetDnsLogsWithOptions(request, runtime);
}

model DescribeIspFlushCacheInstancesRequest {
  direction?: string(name='Direction'),
  isp?: string(name='Isp'),
  keyword?: string(name='Keyword'),
  lang?: string(name='Lang'),
  orderBy?: string(name='OrderBy'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  type?: string(name='Type'),
}

model DescribeIspFlushCacheInstancesResponseBody = {
  ispFlushCacheInstances?: [ 
    {
      expireTime?: string(name='ExpireTime'),
      expireTimestamp?: long(name='ExpireTimestamp'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      isp?: string(name='Isp'),
      quotaInfo?: {
        instanceQuota?: int32(name='InstanceQuota'),
        instanceQuotaUsed?: int32(name='InstanceQuotaUsed'),
      }(name='QuotaInfo'),
      status?: string(name='Status'),
      versionCode?: string(name='VersionCode'),
    }
  ](name='IspFlushCacheInstances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeIspFlushCacheInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeIspFlushCacheInstancesResponseBody(name='body'),
}

/**
 * @summary 
 *
 * @param request DescribeIspFlushCacheInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIspFlushCacheInstancesResponse
 */
async function describeIspFlushCacheInstancesWithOptions(request: DescribeIspFlushCacheInstancesRequest, runtime: Util.RuntimeOptions): DescribeIspFlushCacheInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.isp)) {
    query['Isp'] = request.isp;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIspFlushCacheInstances',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 
 *
 * @param request DescribeIspFlushCacheInstancesRequest
 * @return DescribeIspFlushCacheInstancesResponse
 */
async function describeIspFlushCacheInstances(request: DescribeIspFlushCacheInstancesRequest): DescribeIspFlushCacheInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIspFlushCacheInstancesWithOptions(request, runtime);
}

model DescribeIspFlushCacheRemainQuotaRequest {
  lang?: string(name='Lang'),
}

model DescribeIspFlushCacheRemainQuotaResponseBody = {
  requestId?: string(name='RequestId'),
  telecomRemainQuota?: int32(name='TelecomRemainQuota'),
}

model DescribeIspFlushCacheRemainQuotaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeIspFlushCacheRemainQuotaResponseBody(name='body'),
}

/**
 * @summary 
 *
 * @param request DescribeIspFlushCacheRemainQuotaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIspFlushCacheRemainQuotaResponse
 */
async function describeIspFlushCacheRemainQuotaWithOptions(request: DescribeIspFlushCacheRemainQuotaRequest, runtime: Util.RuntimeOptions): DescribeIspFlushCacheRemainQuotaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIspFlushCacheRemainQuota',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 
 *
 * @param request DescribeIspFlushCacheRemainQuotaRequest
 * @return DescribeIspFlushCacheRemainQuotaResponse
 */
async function describeIspFlushCacheRemainQuota(request: DescribeIspFlushCacheRemainQuotaRequest): DescribeIspFlushCacheRemainQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIspFlushCacheRemainQuotaWithOptions(request, runtime);
}

model DescribeIspFlushCacheTaskRequest {
  lang?: string(name='Lang'),
  taskId?: string(name='TaskId', description='This parameter is required.'),
}

model DescribeIspFlushCacheTaskResponseBody = {
  createTime?: string(name='CreateTime'),
  createTimestamp?: long(name='CreateTimestamp'),
  domainName?: string(name='DomainName'),
  flushCacheResults?: [ 
    {
      dnsNodes?: [ 
        {
          answers?: [ 
            {
              name?: string(name='Name'),
              record?: string(name='Record'),
              ttl?: long(name='Ttl'),
              type?: string(name='Type'),
            }
          ](name='Answers'),
          nodeIp?: string(name='NodeIp'),
          spName?: string(name='SpName'),
          status?: string(name='Status'),
        }
      ](name='DnsNodes'),
      province?: string(name='Province'),
    }
  ](name='FlushCacheResults'),
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  isp?: string(name='Isp'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
  taskStatus?: string(name='TaskStatus'),
}

model DescribeIspFlushCacheTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeIspFlushCacheTaskResponseBody(name='body'),
}

/**
 * @summary 
 *
 * @param request DescribeIspFlushCacheTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIspFlushCacheTaskResponse
 */
async function describeIspFlushCacheTaskWithOptions(request: DescribeIspFlushCacheTaskRequest, runtime: Util.RuntimeOptions): DescribeIspFlushCacheTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIspFlushCacheTask',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 
 *
 * @param request DescribeIspFlushCacheTaskRequest
 * @return DescribeIspFlushCacheTaskResponse
 */
async function describeIspFlushCacheTask(request: DescribeIspFlushCacheTaskRequest): DescribeIspFlushCacheTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIspFlushCacheTaskWithOptions(request, runtime);
}

model DescribeIspFlushCacheTasksRequest {
  direction?: string(name='Direction'),
  domainName?: string(name='DomainName'),
  instanceId?: string(name='InstanceId'),
  isp?: string(name='Isp'),
  lang?: string(name='Lang'),
  orderBy?: string(name='OrderBy'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeIspFlushCacheTasksResponseBody = {
  ispFlushCacheTasks?: [ 
    {
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      domainName?: string(name='DomainName'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      isp?: string(name='Isp'),
      taskId?: string(name='TaskId'),
      taskStatus?: string(name='TaskStatus'),
    }
  ](name='IspFlushCacheTasks'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItems?: int32(name='TotalItems'),
  totalPages?: int32(name='TotalPages'),
}

model DescribeIspFlushCacheTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeIspFlushCacheTasksResponseBody(name='body'),
}

/**
 * @summary 
 *
 * @param request DescribeIspFlushCacheTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIspFlushCacheTasksResponse
 */
async function describeIspFlushCacheTasksWithOptions(request: DescribeIspFlushCacheTasksRequest, runtime: Util.RuntimeOptions): DescribeIspFlushCacheTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.isp)) {
    query['Isp'] = request.isp;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIspFlushCacheTasks',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 
 *
 * @param request DescribeIspFlushCacheTasksRequest
 * @return DescribeIspFlushCacheTasksResponse
 */
async function describeIspFlushCacheTasks(request: DescribeIspFlushCacheTasksRequest): DescribeIspFlushCacheTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIspFlushCacheTasksWithOptions(request, runtime);
}

model DescribePdnsAccountSummaryRequest {
  endDate?: string(name='EndDate'),
  lang?: string(name='Lang'),
  startDate?: string(name='StartDate'),
}

model DescribePdnsAccountSummaryResponseBody = {
  data?: {
    domainCount?: long(name='DomainCount'),
    httpCount?: long(name='HttpCount'),
    httpsCount?: long(name='HttpsCount'),
    subDomainCount?: long(name='SubDomainCount'),
    threatCount?: long(name='ThreatCount'),
    totalCount?: long(name='TotalCount'),
    userId?: long(name='UserId'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribePdnsAccountSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePdnsAccountSummaryResponseBody(name='body'),
}

/**
 * @summary DNS
 *
 * @param request DescribePdnsAccountSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePdnsAccountSummaryResponse
 */
async function describePdnsAccountSummaryWithOptions(request: DescribePdnsAccountSummaryRequest, runtime: Util.RuntimeOptions): DescribePdnsAccountSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsAccountSummary',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DNS
 *
 * @param request DescribePdnsAccountSummaryRequest
 * @return DescribePdnsAccountSummaryResponse
 */
async function describePdnsAccountSummary(request: DescribePdnsAccountSummaryRequest): DescribePdnsAccountSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsAccountSummaryWithOptions(request, runtime);
}

model DescribePdnsAppKeyRequest {
  appKeyId?: string(name='AppKeyId'),
  authCode?: string(name='AuthCode'),
  lang?: string(name='Lang'),
}

model DescribePdnsAppKeyResponseBody = {
  appKey?: {
    appKeyId?: string(name='AppKeyId'),
    appKeySecret?: string(name='AppKeySecret'),
    createDate?: string(name='CreateDate'),
    createTimestamp?: long(name='CreateTimestamp'),
    remark?: string(name='Remark'),
    state?: string(name='State'),
  }(name='AppKey'),
  requestId?: string(name='RequestId'),
}

model DescribePdnsAppKeyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePdnsAppKeyResponseBody(name='body'),
}

/**
 * @summary DNS AppKey 
 *
 * @param request DescribePdnsAppKeyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePdnsAppKeyResponse
 */
async function describePdnsAppKeyWithOptions(request: DescribePdnsAppKeyRequest, runtime: Util.RuntimeOptions): DescribePdnsAppKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appKeyId)) {
    query['AppKeyId'] = request.appKeyId;
  }
  if (!Util.isUnset(request.authCode)) {
    query['AuthCode'] = request.authCode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsAppKey',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DNS AppKey 
 *
 * @param request DescribePdnsAppKeyRequest
 * @return DescribePdnsAppKeyResponse
 */
async function describePdnsAppKey(request: DescribePdnsAppKeyRequest): DescribePdnsAppKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsAppKeyWithOptions(request, runtime);
}

model DescribePdnsAppKeysRequest {
  lang?: string(name='Lang'),
}

model DescribePdnsAppKeysResponseBody = {
  appKeys?: [ 
    {
      appKeyId?: string(name='AppKeyId'),
      createDate?: string(name='CreateDate'),
      createTimestamp?: long(name='CreateTimestamp'),
      remark?: string(name='Remark'),
      state?: string(name='State'),
    }
  ](name='AppKeys'),
  requestId?: string(name='RequestId'),
}

model DescribePdnsAppKeysResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePdnsAppKeysResponseBody(name='body'),
}

/**
 * @summary DNS AppKey 
 *
 * @param request DescribePdnsAppKeysRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePdnsAppKeysResponse
 */
async function describePdnsAppKeysWithOptions(request: DescribePdnsAppKeysRequest, runtime: Util.RuntimeOptions): DescribePdnsAppKeysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsAppKeys',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DNS AppKey 
 *
 * @param request DescribePdnsAppKeysRequest
 * @return DescribePdnsAppKeysResponse
 */
async function describePdnsAppKeys(request: DescribePdnsAppKeysRequest): DescribePdnsAppKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsAppKeysWithOptions(request, runtime);
}

model DescribePdnsOperateLogsRequest {
  actionType?: string(name='ActionType'),
  endDate?: string(name='EndDate'),
  keyword?: string(name='Keyword'),
  lang?: string(name='Lang'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  startDate?: string(name='StartDate'),
}

model DescribePdnsOperateLogsResponseBody = {
  logs?: [ 
    {
      action?: string(name='Action'),
      operateTime?: string(name='OperateTime'),
      type?: string(name='Type'),
      content?: string(name='content'),
    }
  ](name='Logs'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePdnsOperateLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePdnsOperateLogsResponseBody(name='body'),
}

/**
 * @summary DNS 
 *
 * @param request DescribePdnsOperateLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePdnsOperateLogsResponse
 */
async function describePdnsOperateLogsWithOptions(request: DescribePdnsOperateLogsRequest, runtime: Util.RuntimeOptions): DescribePdnsOperateLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actionType)) {
    query['ActionType'] = request.actionType;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsOperateLogs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DNS 
 *
 * @param request DescribePdnsOperateLogsRequest
 * @return DescribePdnsOperateLogsResponse
 */
async function describePdnsOperateLogs(request: DescribePdnsOperateLogsRequest): DescribePdnsOperateLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsOperateLogsWithOptions(request, runtime);
}

model DescribePdnsRequestStatisticRequest {
  domainName?: string(name='DomainName', description='The primary domain name whose statistics you want to query.', example='example.com'),
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the **YYYY-MM-DD** format.

The default value is the day when you query the data.', example='2024-7-1 00:00:00'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the **YYYY-MM-DD** format.

You can query only records of the last 90 days.', example='2024-06-14 00:00:00'),
  subDomain?: string(name='SubDomain', description='The subdomain name whose statistics you want to query.', example='www.example.com'),
  type?: string(name='Type', description='The type of the request statistics that you want to query. Valid values:

*   **ACCOUNT**: queries the request statistics by account.
*   **DOMAIN**: queries the request statistics by domain name.
*   **SUB_DOMAIN**: queries the request statistics by subdomain name.', example='ACCOUNT'),
}

model DescribePdnsRequestStatisticResponseBody = {
  data?: [ 
    {
      dohTotalCount?: long(name='DohTotalCount', description='The total number of DoH requests, including HTTP and HTTPS requests.', example='0'),
      httpCount?: long(name='HttpCount', description='The number of HTTP requests.', example='0'),
      httpsCount?: long(name='HttpsCount', description='The number of HTTPS requests. On the Traffic Analysis tab of the Public DNS console, the value of this parameter includes the number of DNS over HTTPs (DoH) requests. Therefore, the number of DoH requests is not separately displayed in the console.', example='0'),
      ipCount?: long(name='IpCount', description='The number of source IP addresses.', example='10'),
      timestamp?: long(name='Timestamp', description='The statistical timestamp. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1706716800000'),
      totalCount?: long(name='TotalCount', description='The total number of requests.', example='0'),
      udpTotalCount?: long(name='UdpTotalCount', description='The total number of UDP requests.', example='5000'),
      v4Count?: long(name='V4Count', description='The number of IPv4-based requests.', example='0'),
      v4HttpCount?: long(name='V4HttpCount', description='The number of IPv4-based HTTP requests.', example='0'),
      v4HttpsCount?: long(name='V4HttpsCount', description='The number of IPv4-based HTTPS requests.', example='0'),
      v6Count?: long(name='V6Count', description='The number of IPv6-based requests.', example='0'),
      v6HttpCount?: long(name='V6HttpCount', description='The number of IPv6-based HTTP requests.', example='0'),
      v6HttpsCount?: long(name='V6HttpsCount', description='The number of IPv6-based HTTPS requests.', example='0'),
    }
  ](name='Data', description='The statistics on the DNS requests.'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model DescribePdnsRequestStatisticResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePdnsRequestStatisticResponseBody(name='body'),
}

/**
 * @summary Queries the statistics on requests for Alibaba Cloud Public DNS.
 *
 * @param request DescribePdnsRequestStatisticRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePdnsRequestStatisticResponse
 */
async function describePdnsRequestStatisticWithOptions(request: DescribePdnsRequestStatisticRequest, runtime: Util.RuntimeOptions): DescribePdnsRequestStatisticResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.subDomain)) {
    query['SubDomain'] = request.subDomain;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsRequestStatistic',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the statistics on requests for Alibaba Cloud Public DNS.
 *
 * @param request DescribePdnsRequestStatisticRequest
 * @return DescribePdnsRequestStatisticResponse
 */
async function describePdnsRequestStatistic(request: DescribePdnsRequestStatisticRequest): DescribePdnsRequestStatisticResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsRequestStatisticWithOptions(request, runtime);
}

model DescribePdnsRequestStatisticsRequest {
  domainName?: string(name='DomainName', description='The primary domain name whose statistics you want to query.', example='example.com'),
  endDate?: string(name='EndDate', description='The end of the time range to query. Specify the time in the YYYY-MM-DD format.

The default value is the day when you query the data.', example='2024-07-14 00:00:00'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Default value: 20. Valid values: 1 to 100.', example='20'),
  startDate?: string(name='StartDate', description='The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.

You can query only records of the last 90 days.', example='2024-06-14 00:00:00'),
  subDomain?: string(name='SubDomain', description='The subdomain name whose statistics you want to query.', example='www.example.com'),
  type?: string(name='Type', description='The type of the request statistics that you want to query. Valid values:

*   DOMAIN: queries the request statistics by domain name.
*   SUB_DOMAIN: queries the request statistics by subdomain name.', example='DOMAIN'),
}

model DescribePdnsRequestStatisticsResponseBody = {
  data?: [ 
    {
      dohTotalCount?: long(name='DohTotalCount', description='The total number of DoH requests, including the HTTP and HTTPS requests.', example='0'),
      domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
      httpCount?: long(name='HttpCount', description='The number of HTTP requests.', example='0'),
      httpsCount?: long(name='HttpsCount', description='The number of HTTPS requests. On the Traffic Analysis tab of the public DNS console, the value of this parameter includes the number of DNS over HTTPs (DoH) requests. Therefore, the number of DoH requests is not separately displayed in the console.', example='0'),
      ipCount?: long(name='IpCount', description='The number of source IP addresses.', example='10'),
      maxThreatLevel?: string(name='MaxThreatLevel', description='The current version does not support this parameter.', example='-'),
      subDomain?: string(name='SubDomain', description='The subdomain name.', example='www.example.com'),
      threatCount?: long(name='ThreatCount', description='The current version does not support this parameter.', example='-'),
      threatInfo?: [ 
        {
          threatLevel?: string(name='ThreatLevel', description='The current version does not support this parameter.', example='-'),
          threatType?: string(name='ThreatType', description='The current version does not support this parameter.', example='-'),
        }
      ](name='ThreatInfo', description='The current version does not support this parameter.'),
      totalCount?: long(name='TotalCount', description='The total number of requests.', example='500'),
      udpTotalCount?: long(name='UdpTotalCount', description='The total number of UDP requests.', example='500'),
      v4Count?: long(name='V4Count', description='The number of IPv4-based requests.', example='0'),
      v4HttpCount?: long(name='V4HttpCount', description='The number of IPv4-based HTTP requests.', example='0'),
      v4HttpsCount?: long(name='V4HttpsCount', description='The number of IPv4-based HTTPS requests.', example='0'),
      v6Count?: long(name='V6Count', description='The number of IPv6-based requests.', example='0'),
      v6HttpCount?: long(name='V6HttpCount', description='The number of IPv6-based HTTP requests.', example='0'),
      v6HttpsCount?: long(name='V6HttpsCount', description='The number of IPv6-based HTTPS requests.', example='0'),
    }
  ](name='Data', description='The statistics on the DNS requests.'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Default value: **20**. Valid values: **1 to 100**.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='49'),
}

model DescribePdnsRequestStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePdnsRequestStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries a list of statistics on requests for Alibaba Cloud Public DNS.
 *
 * @param request DescribePdnsRequestStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePdnsRequestStatisticsResponse
 */
async function describePdnsRequestStatisticsWithOptions(request: DescribePdnsRequestStatisticsRequest, runtime: Util.RuntimeOptions): DescribePdnsRequestStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.subDomain)) {
    query['SubDomain'] = request.subDomain;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsRequestStatistics',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of statistics on requests for Alibaba Cloud Public DNS.
 *
 * @param request DescribePdnsRequestStatisticsRequest
 * @return DescribePdnsRequestStatisticsResponse
 */
async function describePdnsRequestStatistics(request: DescribePdnsRequestStatisticsRequest): DescribePdnsRequestStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsRequestStatisticsWithOptions(request, runtime);
}

model DescribePdnsThreatLogsRequest {
  endDate?: string(name='EndDate'),
  keyword?: string(name='Keyword'),
  lang?: string(name='Lang'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  startDate?: string(name='StartDate'),
  threatLevel?: string(name='ThreatLevel'),
  threatSourceIp?: string(name='ThreatSourceIp'),
  threatType?: string(name='ThreatType'),
}

model DescribePdnsThreatLogsResponseBody = {
  logs?: [ 
    {
      sourceIp?: string(name='SourceIp'),
      subDomain?: string(name='SubDomain'),
      threatLevel?: string(name='ThreatLevel'),
      threatTime?: string(name='ThreatTime'),
      threatType?: string(name='ThreatType'),
    }
  ](name='Logs'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePdnsThreatLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePdnsThreatLogsResponseBody(name='body'),
}

/**
 * @summary DNS 
 *
 * @param request DescribePdnsThreatLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePdnsThreatLogsResponse
 */
async function describePdnsThreatLogsWithOptions(request: DescribePdnsThreatLogsRequest, runtime: Util.RuntimeOptions): DescribePdnsThreatLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.threatLevel)) {
    query['ThreatLevel'] = request.threatLevel;
  }
  if (!Util.isUnset(request.threatSourceIp)) {
    query['ThreatSourceIp'] = request.threatSourceIp;
  }
  if (!Util.isUnset(request.threatType)) {
    query['ThreatType'] = request.threatType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsThreatLogs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DNS 
 *
 * @param request DescribePdnsThreatLogsRequest
 * @return DescribePdnsThreatLogsResponse
 */
async function describePdnsThreatLogs(request: DescribePdnsThreatLogsRequest): DescribePdnsThreatLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsThreatLogsWithOptions(request, runtime);
}

model DescribePdnsThreatStatisticRequest {
  endDate?: string(name='EndDate'),
  lang?: string(name='Lang'),
  startDate?: string(name='StartDate'),
  threatSourceIp?: string(name='ThreatSourceIp'),
}

model DescribePdnsThreatStatisticResponseBody = {
  data?: [ 
    {
      dohTotalCount?: long(name='DohTotalCount'),
      threatLevel?: string(name='ThreatLevel'),
      threatType?: string(name='ThreatType'),
      timestamp?: long(name='Timestamp'),
      totalCount?: long(name='TotalCount'),
      udpTotalCount?: long(name='UdpTotalCount'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribePdnsThreatStatisticResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePdnsThreatStatisticResponseBody(name='body'),
}

/**
 * @summary DNS 
 *
 * @param request DescribePdnsThreatStatisticRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePdnsThreatStatisticResponse
 */
async function describePdnsThreatStatisticWithOptions(request: DescribePdnsThreatStatisticRequest, runtime: Util.RuntimeOptions): DescribePdnsThreatStatisticResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.threatSourceIp)) {
    query['ThreatSourceIp'] = request.threatSourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsThreatStatistic',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DNS 
 *
 * @param request DescribePdnsThreatStatisticRequest
 * @return DescribePdnsThreatStatisticResponse
 */
async function describePdnsThreatStatistic(request: DescribePdnsThreatStatisticRequest): DescribePdnsThreatStatisticResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsThreatStatisticWithOptions(request, runtime);
}

model DescribePdnsThreatStatisticsRequest {
  direction?: string(name='Direction'),
  domainName?: string(name='DomainName'),
  endDate?: string(name='EndDate'),
  lang?: string(name='Lang'),
  orderBy?: string(name='OrderBy'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  startDate?: string(name='StartDate'),
  subDomain?: string(name='SubDomain'),
  threatLevel?: string(name='ThreatLevel'),
  threatSourceIp?: string(name='ThreatSourceIp'),
  threatType?: string(name='ThreatType'),
  type?: string(name='Type'),
}

model DescribePdnsThreatStatisticsResponseBody = {
  data?: [ 
    {
      dohTotalCount?: long(name='DohTotalCount'),
      domainCount?: long(name='DomainCount'),
      domainName?: string(name='DomainName'),
      latestThreatTime?: long(name='LatestThreatTime'),
      maxThreatLevel?: string(name='MaxThreatLevel'),
      sourceIp?: string(name='SourceIp'),
      subDomain?: string(name='SubDomain'),
      threatLevel?: string(name='ThreatLevel'),
      threatType?: string(name='ThreatType'),
      totalCount?: long(name='TotalCount'),
      udpTotalCount?: long(name='UdpTotalCount'),
    }
  ](name='Data'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePdnsThreatStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePdnsThreatStatisticsResponseBody(name='body'),
}

/**
 * @summary DNS 
 *
 * @param request DescribePdnsThreatStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePdnsThreatStatisticsResponse
 */
async function describePdnsThreatStatisticsWithOptions(request: DescribePdnsThreatStatisticsRequest, runtime: Util.RuntimeOptions): DescribePdnsThreatStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.subDomain)) {
    query['SubDomain'] = request.subDomain;
  }
  if (!Util.isUnset(request.threatLevel)) {
    query['ThreatLevel'] = request.threatLevel;
  }
  if (!Util.isUnset(request.threatSourceIp)) {
    query['ThreatSourceIp'] = request.threatSourceIp;
  }
  if (!Util.isUnset(request.threatType)) {
    query['ThreatType'] = request.threatType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsThreatStatistics',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DNS 
 *
 * @param request DescribePdnsThreatStatisticsRequest
 * @return DescribePdnsThreatStatisticsResponse
 */
async function describePdnsThreatStatistics(request: DescribePdnsThreatStatisticsRequest): DescribePdnsThreatStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsThreatStatisticsWithOptions(request, runtime);
}

model DescribePdnsUdpIpSegmentsRequest {
  lang?: string(name='Lang'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
}

model DescribePdnsUdpIpSegmentsResponseBody = {
  ipSegments?: [ 
    {
      createDate?: string(name='CreateDate'),
      createTimestamp?: long(name='CreateTimestamp'),
      id?: string(name='Id'),
      ip?: string(name='Ip'),
      mask?: long(name='Mask'),
      name?: string(name='Name'),
      secretKey?: string(name='SecretKey'),
      state?: string(name='State'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='IpSegments'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
  totalPages?: string(name='TotalPages'),
}

model DescribePdnsUdpIpSegmentsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePdnsUdpIpSegmentsResponseBody(name='body'),
}

/**
 * @summary DNS Udp IP
 *
 * @param request DescribePdnsUdpIpSegmentsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePdnsUdpIpSegmentsResponse
 */
async function describePdnsUdpIpSegmentsWithOptions(request: DescribePdnsUdpIpSegmentsRequest, runtime: Util.RuntimeOptions): DescribePdnsUdpIpSegmentsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsUdpIpSegments',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DNS Udp IP
 *
 * @param request DescribePdnsUdpIpSegmentsRequest
 * @return DescribePdnsUdpIpSegmentsResponse
 */
async function describePdnsUdpIpSegments(request: DescribePdnsUdpIpSegmentsRequest): DescribePdnsUdpIpSegmentsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsUdpIpSegmentsWithOptions(request, runtime);
}

model DescribePdnsUserInfoRequest {
  lang?: string(name='Lang', example='en'),
}

model DescribePdnsUserInfoResponseBody = {
  requestId?: string(name='RequestId', example='FD552816-FCC8-4832-B4A2-2DA0C2BA1688'),
  userInfo?: {
    availableAccessSecurityType?: string(name='AvailableAccessSecurityType', example='SECURE'),
    availableService?: string(name='AvailableService', example='HTTP,HTTPS'),
    pdnsId?: long(name='PdnsId', example='10001'),
    secretKey?: string(name='SecretKey', example='1c092d715b7a48de'),
    serviceType?: string(name='ServiceType', example='normal'),
    state?: string(name='State', example='AVAILABLE'),
    statisticSwitchStatus?: string(name='StatisticSwitchStatus', example='CLOSED'),
    stoppedService?: string(name='StoppedService'),
  }(name='UserInfo'),
}

model DescribePdnsUserInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePdnsUserInfoResponseBody(name='body'),
}

/**
 * @summary DNS
 *
 * @param request DescribePdnsUserInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePdnsUserInfoResponse
 */
async function describePdnsUserInfoWithOptions(request: DescribePdnsUserInfoRequest, runtime: Util.RuntimeOptions): DescribePdnsUserInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePdnsUserInfo',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DNS
 *
 * @param request DescribePdnsUserInfoRequest
 * @return DescribePdnsUserInfoResponse
 */
async function describePdnsUserInfo(request: DescribePdnsUserInfoRequest): DescribePdnsUserInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePdnsUserInfoWithOptions(request, runtime);
}

model DescribeRecordLogsRequest {
  domainName?: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.

This parameter is required.', example='example.com'),
  keyWord?: string(name='KeyWord', description='The keyword for searches in "%KeyWord%" mode. The value is not case-sensitive.', example='test'),
  lang?: string(name='Lang', description='The language.', example='en'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: **1 to 100**. Default value: **20**.', example='20'),
  startDate?: string(name='StartDate', description='The start date of the query. Specify the start date in the **YYYY-MM-DD** format.', example='2015-12-12'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='1.1.1.1'),
  endDate?: string(name='endDate', description='The end date of the query. Specify the end date in the **YYYY-MM-DD** format.', example='2015-12-12'),
}

model DescribeRecordLogsResponseBody = {
  pageNumber?: long(name='PageNumber', description='The page number.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='2'),
  recordLogs?: {
    recordLog?: [ 
    {
      action?: string(name='Action', description='The operation that you performed.'),
      actionTime?: string(name='ActionTime', description='The time when you performed the operation.', example='2015-12-12T09:23Z'),
      actionTimestamp?: long(name='ActionTimestamp', description='The time when you performed the operation. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='134514540000'),
      clientIp?: string(name='ClientIp', description='The IP address of the operator.', example='182.92.253.XX'),
      message?: string(name='Message', description='The operation message.'),
    }
  ](name='RecordLog')
  }(name='RecordLogs', description='The operation logs.'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model DescribeRecordLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRecordLogsResponseBody(name='body'),
}

/**
 * @summary Queries the operation logs of a domain name based on the specified parameters.
 *
 * @param request DescribeRecordLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRecordLogsResponse
 */
async function describeRecordLogsWithOptions(request: DescribeRecordLogsRequest, runtime: Util.RuntimeOptions): DescribeRecordLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  if (!Util.isUnset(request.endDate)) {
    query['endDate'] = request.endDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRecordLogs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the operation logs of a domain name based on the specified parameters.
 *
 * @param request DescribeRecordLogsRequest
 * @return DescribeRecordLogsResponse
 */
async function describeRecordLogs(request: DescribeRecordLogsRequest): DescribeRecordLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRecordLogsWithOptions(request, runtime);
}

model DescribeRecordResolveStatisticsSummaryRequest {
  direction?: string(name='Direction', description='The order in which the returned entries are sorted. Valid values:

*   DESC (default): descending order
*   ASC: ascending order', example='DESC'),
  domainName?: string(name='DomainName', description='The domain name.

This parameter is required.', example='example.com'),
  domainType?: string(name='DomainType', description='The type of the domain name. The parameter value is not case-sensitive. Valid values:

*   PUBLIC (default): hosted public domain name
*   CACHE: cache-accelerated domain name', example='PUBLIC'),
  endDate?: string(name='EndDate', description='The end date of the time range to be queried. Specify the time in the yyyy-MM-dd format, such as 2023-03-13.', example='2023-03-29'),
  keyword?: string(name='Keyword', description='The keyword. Keyword is used together with SearchMode.', example='test'),
  lang?: string(name='Lang', description='The language. Valid values: zh, en, and ja.', example='zh'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 1000.', example='10'),
  searchMode?: string(name='SearchMode', description='The search mode of the keyword. Valid values:

*   LIKE (default): fuzzy search
*   EXACT: exact search', example='LIKE'),
  startDate?: string(name='StartDate', description='The start date of the time range to be queried. Specify the time in the yyyy-MM-dd format, such as 2023-03-01.

This parameter is required.', example='2023-03-29'),
  threshold?: long(name='Threshold', description='The threshold for the number of Domain Name System (DNS) requests. You can query the subdomain names at the specified quantity level of DNS requests and query the number of DNS requests for each subdomain name.

If you do not specify this parameter, the data about the subdomain names that have DNS requests is obtained.

If you set this parameter to a value less than 0, the data about all subdomain names is obtained.

If you set this parameter to 0, the data about the subdomain names that do not have DNS requests is obtained.

If you set this parameter to a value greater than 0, the data about the subdomain names whose number of DNS requests is less than or equal to the value of this parameter is obtained.', example='-1'),
}

model DescribeRecordResolveStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: **1 to 500**. Default value: **20**.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='389DFFA3-77A5-4A9E-BF3D-147C6F98A5BA'),
  statistics?: [ 
    {
      count?: string(name='Count', description='The number of DNS requests.', example='330'),
      domainName?: string(name='DomainName', description='The subdomain name.', example='tes.example.com'),
      domainType?: string(name='DomainType', description='The type of the domain name. The parameter value is not case-sensitive. Valid values:

*   PUBLIC (default): hosted public domain name
*   CACHE: cache-accelerated domain name', example='PUBLIC'),
      subDomain?: string(name='SubDomain', description='The subdomain.', example='test.example.com'),
    }
  ](name='Statistics', description='The statistics.'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned.', example='1'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeRecordResolveStatisticsSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRecordResolveStatisticsSummaryResponseBody(name='body'),
}

/**
 * @summary Queries the number of resolution requests for all subdomain names of a specified domain name.
 *
 * @param request DescribeRecordResolveStatisticsSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRecordResolveStatisticsSummaryResponse
 */
async function describeRecordResolveStatisticsSummaryWithOptions(request: DescribeRecordResolveStatisticsSummaryRequest, runtime: Util.RuntimeOptions): DescribeRecordResolveStatisticsSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainType)) {
    query['DomainType'] = request.domainType;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchMode)) {
    query['SearchMode'] = request.searchMode;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.threshold)) {
    query['Threshold'] = request.threshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRecordResolveStatisticsSummary',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the number of resolution requests for all subdomain names of a specified domain name.
 *
 * @param request DescribeRecordResolveStatisticsSummaryRequest
 * @return DescribeRecordResolveStatisticsSummaryResponse
 */
async function describeRecordResolveStatisticsSummary(request: DescribeRecordResolveStatisticsSummaryRequest): DescribeRecordResolveStatisticsSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRecordResolveStatisticsSummaryWithOptions(request, runtime);
}

model DescribeRecordStatisticsRequest {
  domainName?: string(name='DomainName', description='The primary domain name.

This parameter is required.', example='dns-example.com'),
  domainType?: string(name='DomainType', description='The type of the domain name. The parameter value is not case-sensitive. Valid values:

*   PUBLIC (default): hosted public domain name
*   CACHE: cache-accelerated domain name', example='PUBLIC'),
  endDate?: string(name='EndDate', description='The end date of the query. Specify the end date in the **YYYY-MM-DD** format.

The default value is the day when you query the data.', example='2019-07-04'),
  lang?: string(name='Lang', description='The language.', example='en'),
  rr?: string(name='Rr', description='The hostname. If you want to resolve www.dns-exmaple.top, set Rr to www.

This parameter is required.', example='www'),
  startDate?: string(name='StartDate', description='The start date of the query. Specify the start date in the **YYYY-MM-DD** format.

You can only query the DNS records within the last 90 days.``

If the time range is less than or equal to seven days, data is returned on an hourly basis.````

If the time range is greater than seven days, data is returned on a daily basis.````

This parameter is required.', example='2019-07-04'),
}

model DescribeRecordStatisticsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='6AEC7A64-3CB1-4C49-8B35-0B901F1E26BF'),
  statistics?: {
    statistic?: [ 
    {
      count?: long(name='Count', description='The number of DNS requests.', example='15292887'),
      timestamp?: long(name='Timestamp', description='The statistical timestamp. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1556640000000'),
    }
  ](name='Statistic')
  }(name='Statistics', description='The statistics on the DNS requests.'),
}

model DescribeRecordStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRecordStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the real-time statistics on the Domain Name System (DNS) requests for a subdomain name.
 *
 * @description Real-time data is collected per hour.
 *
 * @param request DescribeRecordStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRecordStatisticsResponse
 */
async function describeRecordStatisticsWithOptions(request: DescribeRecordStatisticsRequest, runtime: Util.RuntimeOptions): DescribeRecordStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainType)) {
    query['DomainType'] = request.domainType;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.rr)) {
    query['Rr'] = request.rr;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRecordStatistics',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the real-time statistics on the Domain Name System (DNS) requests for a subdomain name.
 *
 * @description Real-time data is collected per hour.
 *
 * @param request DescribeRecordStatisticsRequest
 * @return DescribeRecordStatisticsResponse
 */
async function describeRecordStatistics(request: DescribeRecordStatisticsRequest): DescribeRecordStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRecordStatisticsWithOptions(request, runtime);
}

model DescribeRecordStatisticsSummaryRequest {
  domainName?: string(name='DomainName', description='The domain name.

This parameter is required.', example='dns-example.com'),
  domainType?: string(name='DomainType', description='The type of the domain name. The parameter value is not case-sensitive. Valid values:

*   PUBLIC (default): hosted public domain name
*   CACHE: cache-accelerated domain name', example='PUBLIC'),
  endDate?: string(name='EndDate', description='The end date of the query. Specify the start date in the **YYYY-MM-DD** format.

The default value is the day when you query the data.', example='2019-07-04'),
  keyword?: string(name='Keyword', description='The keyword for searches in %KeyWord% mode. The value is not case-sensitive.', example='test'),
  lang?: string(name='Lang', description='The language.', example='en'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: **1 to 100**. Default value: **20**.', example='20'),
  searchMode?: string(name='SearchMode', description='The search mode of the keyword. Valid values:

*   **LIKE** (default): fuzzy search
*   **EXACT**: exact search', example='EXACT'),
  startDate?: string(name='StartDate', description='The start date of the query. Specify the start date in the **YYYY-MM-DD** format.

You can only query the DNS records within the last 90 days.``

This parameter is required.', example='2019-07-04'),
  threshold?: long(name='Threshold', description='The maximum number of DNS requests that you can obtain. You can obtain data about a domain name with DNS request volume less than or equal to the maximum number. For example, if you set this parameter to 100, you can query domain names with less than 100 DNS requests.', example='12'),
}

model DescribeRecordStatisticsSummaryResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: **1 to 100**. Default value: **20**.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='E49F0023-4A98-486F-8BA3-6003D5664105'),
  statistics?: {
    statistic?: [ 
    {
      count?: long(name='Count', description='The number of DNS requests.', example='838711553'),
      subDomain?: string(name='SubDomain', description='The subdomain.', example='t1.alitest2.com'),
    }
  ](name='Statistic')
  }(name='Statistics', description='The DNS requests.'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned.', example='3'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='1'),
}

model DescribeRecordStatisticsSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRecordStatisticsSummaryResponseBody(name='body'),
}

/**
 * @summary Queries the number of Domain Name System (DNS) requests for all subdomain names of a specified domain name.
 *
 * @param request DescribeRecordStatisticsSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRecordStatisticsSummaryResponse
 */
async function describeRecordStatisticsSummaryWithOptions(request: DescribeRecordStatisticsSummaryRequest, runtime: Util.RuntimeOptions): DescribeRecordStatisticsSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainType)) {
    query['DomainType'] = request.domainType;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchMode)) {
    query['SearchMode'] = request.searchMode;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.threshold)) {
    query['Threshold'] = request.threshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRecordStatisticsSummary',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the number of Domain Name System (DNS) requests for all subdomain names of a specified domain name.
 *
 * @param request DescribeRecordStatisticsSummaryRequest
 * @return DescribeRecordStatisticsSummaryResponse
 */
async function describeRecordStatisticsSummary(request: DescribeRecordStatisticsSummaryRequest): DescribeRecordStatisticsSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRecordStatisticsSummaryWithOptions(request, runtime);
}

model DescribeSubDomainRecordsRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  line?: string(name='Line', description='The DNS resolution line.', example='default'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: **1 to 100**. Default value: **20**.', example='20'),
  subDomain?: string(name='SubDomain', description='If you set SubDomain to `a.www.example.com` and leave

DomainName empty, the system returns the DNS records that contain the hostname `a.www` for the domain name example.com. If you set SubDomain to a.www.example.com and set DomainName to www.example.com, the system returns the DNS records that contain the hostname `a` for the domain name www.example.com. If you set SubDomain to a.www.example.com and set DomainName to a.www.example.com, the system returns the DNS records that contain the hostname `@` for the domain name a.www.example.com.

This parameter is required.', example='a.www.example.com'),
  type?: string(name='Type', description='The type of DNS records. If you do not specify this parameter, all types of DNS records for the subdomain name are returned.

Valid values: **A, MX, CNAME, TXT, REDIRECT_URL, FORWORD_URL, NS, AAAA, and SRV**.', example='MX'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0'),
}

model DescribeSubDomainRecordsResponseBody = {
  domainRecords?: {
    record?: [ 
    {
      domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
      line?: string(name='Line', description='The DNS resolution line.', example='default'),
      locked?: boolean(name='Locked', description='The lock status of the DNS record.', example='false'),
      priority?: long(name='Priority', description='The priority of the mail exchanger (MX) record.', example='2'),
      RR?: string(name='RR', description='The hostname.', example='www'),
      recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
      remark?: string(name='Remark', description='The description of the DNS record.', example='test'),
      status?: string(name='Status', description='The status of the DNS record.', example='Enable'),
      TTL?: long(name='TTL', description='The time-to-live (TTL) of the DNS record.', example='600'),
      type?: string(name='Type', description='The type of the DNS record.', example='CNAME'),
      value?: string(name='Value', description='The record value.', example='example.net'),
      weight?: int32(name='Weight', description='The weight of the DNS record.', example='10'),
    }
  ](name='Record')
  }(name='DomainRecords', description='The returned Domain Name System (DNS) records.'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='2'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model DescribeSubDomainRecordsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSubDomainRecordsResponseBody(name='body'),
}

/**
 * @summary Queries all Domain Name System (DNS) records of a subdomain name based on the specified parameters.
 *
 * @param request DescribeSubDomainRecordsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSubDomainRecordsResponse
 */
async function describeSubDomainRecordsWithOptions(request: DescribeSubDomainRecordsRequest, runtime: Util.RuntimeOptions): DescribeSubDomainRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.line)) {
    query['Line'] = request.line;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.subDomain)) {
    query['SubDomain'] = request.subDomain;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSubDomainRecords',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries all Domain Name System (DNS) records of a subdomain name based on the specified parameters.
 *
 * @param request DescribeSubDomainRecordsRequest
 * @return DescribeSubDomainRecordsResponse
 */
async function describeSubDomainRecords(request: DescribeSubDomainRecordsRequest): DescribeSubDomainRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSubDomainRecordsWithOptions(request, runtime);
}

model DescribeSupportLinesRequest {
  domainName?: string(name='DomainName', example='example.com'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  userClientIp?: string(name='UserClientIp', example='1.1.*.*'),
}

model DescribeSupportLinesResponseBody = {
  recordLines?: {
    recordLine?: [ 
    {
      fatherCode?: string(name='FatherCode', description='The code of the parent line. Currently, no data is returned.', example='unicom'),
      lineCode?: string(name='LineCode', description='The code of the child line.', example='cn_unicom_shanxi'),
      lineDisplayName?: string(name='LineDisplayName', description='The display name of the line.', example='China Unicom'),
      lineName?: string(name='LineName', description='The name of the child line.', example='China Unicom_Shanxi'),
    }
  ](name='RecordLine')
  }(name='RecordLines', description='The Alibaba Cloud DNS lines.'),
  requestId?: string(name='RequestId', example='CFDA0830-7D6E-4C13-8632-B57C7EDCF079'),
}

model DescribeSupportLinesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSupportLinesResponseBody(name='body'),
}

/**
 * @param request DescribeSupportLinesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSupportLinesResponse
 */
async function describeSupportLinesWithOptions(request: DescribeSupportLinesRequest, runtime: Util.RuntimeOptions): DescribeSupportLinesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSupportLines',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeSupportLinesRequest
 * @return DescribeSupportLinesResponse
 */
async function describeSupportLines(request: DescribeSupportLinesRequest): DescribeSupportLinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSupportLinesWithOptions(request, runtime);
}

model DescribeTagsRequest {
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages. Default value: en. Valid values: en, zh, and ja.', example='en'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries to return per page. Default value: 200.', example='200'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Valid values:

*   **DOMAIN**: domain name

This parameter is required.', example='DOMAIN'),
}

model DescribeTagsResponseBody = {
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Default value: 200.', example='200'),
  requestId?: string(name='RequestId', description='The request ID.', example='89184F33-48A1-4401-9C0F-40E45DB091AB'),
  tags?: [ 
    {
      key?: string(name='Key', description='The key of tag N added to the resource.', example='abc'),
      values?: [ string ](name='Values', description='The values of tags added to the resource.'),
    }
  ](name='Tags', description='The tags added to the resource.'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='5'),
}

model DescribeTagsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTagsResponseBody(name='body'),
}

/**
 * @summary Queries existing tags.
 *
 * @param request DescribeTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTagsResponse
 */
async function describeTagsWithOptions(request: DescribeTagsRequest, runtime: Util.RuntimeOptions): DescribeTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTags',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries existing tags.
 *
 * @param request DescribeTagsRequest
 * @return DescribeTagsResponse
 */
async function describeTags(request: DescribeTagsRequest): DescribeTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTagsWithOptions(request, runtime);
}

model DescribeTransferDomainsRequest {
  domainName?: string(name='DomainName', description='Specifies the domain name for which you want to view the transfer record.', example='alidns.com'),
  fromUserId?: long(name='FromUserId', description='The user ID from which the domain name was transferred to the current account.', example='123456'),
  lang?: string(name='Lang', description='The language.', example='en'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: 1 to 100. Default value: 20.', example='20'),
  targetUserId?: long(name='TargetUserId', description='The user ID to which the domain name was transferred from the current account.', example='123456'),
  transferType?: string(name='TransferType', description='The transfer type. Valid values:

*   IN: The domain name was transferred to the current account.
*   OUT: The domain name was transferred from the current account.

This parameter is required.', example='IN'),
}

model DescribeTransferDomainsResponseBody = {
  domainTransfers?: {
    domainTransfer?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the domain name was created. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2019-10-30T07:16Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The time when the domain name was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1572419764000'),
      domainName?: string(name='DomainName', description='The domain name.', example='test.com'),
      fromUserId?: long(name='FromUserId', description='The user ID from which the domain name was transferred.', example='2222'),
      id?: long(name='Id', description='The ID of the domain name that was transferred.', example='1'),
      targetUserId?: long(name='TargetUserId', description='The user ID to which the domain name was transferred.', example='111111'),
    }
  ](name='DomainTransfer')
  }(name='DomainTransfers', description='The domain names that were transferred between accounts.'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: 1 to 100. Default value: 20.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model DescribeTransferDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTransferDomainsResponseBody(name='body'),
}

/**
 * @summary Queries the domain names that were transferred between the current account and another account based on the specified parameters.
 *
 * @param request DescribeTransferDomainsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTransferDomainsResponse
 */
async function describeTransferDomainsWithOptions(request: DescribeTransferDomainsRequest, runtime: Util.RuntimeOptions): DescribeTransferDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.fromUserId)) {
    query['FromUserId'] = request.fromUserId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.targetUserId)) {
    query['TargetUserId'] = request.targetUserId;
  }
  if (!Util.isUnset(request.transferType)) {
    query['TransferType'] = request.transferType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTransferDomains',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the domain names that were transferred between the current account and another account based on the specified parameters.
 *
 * @param request DescribeTransferDomainsRequest
 * @return DescribeTransferDomainsResponse
 */
async function describeTransferDomains(request: DescribeTransferDomainsRequest): DescribeTransferDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTransferDomainsWithOptions(request, runtime);
}

model ExecuteGtmRecoveryPlanRequest {
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: English.', example='en'),
  recoveryPlanId?: long(name='RecoveryPlanId', description='The ID of the disaster recovery plan.

This parameter is required.', example='100'),
}

model ExecuteGtmRecoveryPlanResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model ExecuteGtmRecoveryPlanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExecuteGtmRecoveryPlanResponseBody(name='body'),
}

/**
 * @summary Executes a disaster recovery plan.
 *
 * @param request ExecuteGtmRecoveryPlanRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExecuteGtmRecoveryPlanResponse
 */
async function executeGtmRecoveryPlanWithOptions(request: ExecuteGtmRecoveryPlanRequest, runtime: Util.RuntimeOptions): ExecuteGtmRecoveryPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recoveryPlanId)) {
    query['RecoveryPlanId'] = request.recoveryPlanId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExecuteGtmRecoveryPlan',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Executes a disaster recovery plan.
 *
 * @param request ExecuteGtmRecoveryPlanRequest
 * @return ExecuteGtmRecoveryPlanResponse
 */
async function executeGtmRecoveryPlan(request: ExecuteGtmRecoveryPlanRequest): ExecuteGtmRecoveryPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return executeGtmRecoveryPlanWithOptions(request, runtime);
}

model GetMainDomainNameRequest {
  inputString?: string(name='InputString', description='The string. The string can be up to 128 characters in length.

This parameter is required.', example='www.example.com'),
  lang?: string(name='Lang', description='The language.', example='en'),
}

model GetMainDomainNameResponseBody = {
  domainLevel?: long(name='DomainLevel', description='The level of the entered domain name.', example='2'),
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  RR?: string(name='RR', description='The hostname.', example='www'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model GetMainDomainNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMainDomainNameResponseBody(name='body'),
}

/**
 * @summary Queries a primary domain name based on the specified parameters.
 *
 * @description For more information about the difference between primary domain names and subdomain names, see
 * [Subdomain levels](https://www.alibabacloud.com/help/zh/faq-detail/39803.htm). For example, if you enter `www.abc.com`, abc.com is obtained.
 *
 * @param request GetMainDomainNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMainDomainNameResponse
 */
async function getMainDomainNameWithOptions(request: GetMainDomainNameRequest, runtime: Util.RuntimeOptions): GetMainDomainNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.inputString)) {
    query['InputString'] = request.inputString;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMainDomainName',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a primary domain name based on the specified parameters.
 *
 * @description For more information about the difference between primary domain names and subdomain names, see
 * [Subdomain levels](https://www.alibabacloud.com/help/zh/faq-detail/39803.htm). For example, if you enter `www.abc.com`, abc.com is obtained.
 *
 * @param request GetMainDomainNameRequest
 * @return GetMainDomainNameResponse
 */
async function getMainDomainName(request: GetMainDomainNameRequest): GetMainDomainNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMainDomainNameWithOptions(request, runtime);
}

model GetTxtRecordForVerifyRequest {
  domainName?: string(name='DomainName', description='The ID of the Domain Name System (DNS) record. You can call the [DescribeDomainRecords](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomainrecords?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.', example='example.com'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  type?: string(name='Type', description='The feature verified by using the TXT record. Valid values:

*   ADD_SUB_DOMAIN: add a subdomain for verification.
*   RETRIEVAL: add other subdomains for verification

This parameter is required.', example='ADD_SUB_DOMAIN'),
}

model GetTxtRecordForVerifyResponseBody = {
  domainName?: string(name='DomainName', description='The domain name.

>  If you do not specify this parameter, it is not returned.', example='example.com'),
  parentDomainName?: string(name='ParentDomainName', description='The top-level domain name.', example='com'),
  RR?: string(name='RR', description='The hostname.', example='aliyunRetrieval'),
  requestId?: string(name='RequestId', description='The request ID.', example='9CC0D642-49D4-48DE-A1A5-9F218652E4A7'),
  value?: string(name='Value', description='The record value.

>  The validity period is three days.', example='c99419e6997f41daaa3e*****'),
}

model GetTxtRecordForVerifyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTxtRecordForVerifyResponseBody(name='body'),
}

/**
 * @summary Generates a text (TXT) record. TXT records are used to retrieve domain names and subdomain names, enable the subdomain name verification feature, and perform batch retrievals.
 *
 * @param request GetTxtRecordForVerifyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTxtRecordForVerifyResponse
 */
async function getTxtRecordForVerifyWithOptions(request: GetTxtRecordForVerifyRequest, runtime: Util.RuntimeOptions): GetTxtRecordForVerifyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTxtRecordForVerify',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Generates a text (TXT) record. TXT records are used to retrieve domain names and subdomain names, enable the subdomain name verification feature, and perform batch retrievals.
 *
 * @param request GetTxtRecordForVerifyRequest
 * @return GetTxtRecordForVerifyResponse
 */
async function getTxtRecordForVerify(request: GetTxtRecordForVerifyRequest): GetTxtRecordForVerifyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTxtRecordForVerifyWithOptions(request, runtime);
}

model ListCloudGtmAddressPoolsRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  addressPoolName?: string(name='AddressPoolName', description='Address pool name.', example='AddressPool-1'),
  addressPoolType?: string(name='AddressPoolType', description='The type of the address pool. Valid values:

*   IPv4: indicates that the service address to be resolved is an IPv4 address.
*   IPv6: indicates that the service address to be resolved is an IPv6 address.
*   domain: indicates that the service address to be resolved is a domain name.', example='IPv4'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  enableStatus?: string(name='EnableStatus', description='The enabling state of the address pool. Valid values:

*   enable: The address pool is enabled.
*   disable: The address pool is disabled.', example='enable'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting at **1**, default is **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of **100**, and a default of **20**.', example='20'),
  remark?: string(name='Remark', description='The additional description of the address pool.', example='test'),
}

model ListCloudGtmAddressPoolsResponseBody = {
  addressPools?: {
    addressPool?: [ 
    {
      addressLbStrategy?: string(name='AddressLbStrategy', description='Load balancing policy among addresses in the address pool:
- round_robin: Round-robin, for any source of DNS resolution requests, all addresses are returned. The order of all addresses is rotated each time.
- sequence: Sequential, for any source of DNS resolution requests, the address with the smaller sequence number (the sequence number indicates the priority of address returns, with smaller numbers having higher priority) is returned. If the address with the smaller sequence number is unavailable, the next address with a smaller sequence number is returned.
- weight: Weighted, supports setting different weight values for each address, realizing the return of addresses according to the ratio of weights in resolution queries.
- source_nearest: Source-nearest, i.e., intelligent resolution function, where GTM can return different addresses based on the source of different DNS resolution requests, achieving the effect of users accessing nearby.', example='round_robin'),
      addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
      addressPoolName?: string(name='AddressPoolName', description='Address pool name.', example='AddressPool-1'),
      addressPoolType?: string(name='AddressPoolType', description='Address pool type:
- IPv4
- IPv6
- domain', example='IPv4'),
      addresses?: {
        address?: [ 
        {
          address?: string(name='Address', description='IP address or domain name.', example='223.5.XX.XX'),
          addressId?: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.', example='addr-895182181143688192'),
          attributeInfo?: string(name='AttributeInfo', description='Address ownership information, not supported in the current version.', example='The current version does not support returning this parameter.'),
          availableMode?: string(name='AvailableMode', description='The failover mode that is used when address exceptions are identified. Valid values:

*   auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
*   manual: the manual mode. If an address is in the unavailable state, the address is not returned for DNS requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.', example='auto'),
          availableStatus?: string(name='AvailableStatus', description='The availability state of the address. Valid values:

*   available: The address is available.
*   unavailable: The address is unavailable.', example='available'),
          createTime?: string(name='CreateTime', description='Address creation time.', example='2024-03-15T01:46Z'),
          createTimestamp?: long(name='CreateTimestamp', description='Address creation time (timestamp).', example='1527690629357'),
          enableStatus?: string(name='EnableStatus', description='Address enable status:
- enable: Enabled status
- disable: Disabled status', example='enable'),
          healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address. Valid values:

*   any_ok: The health check results of at least one health check template are normal.
*   p30_ok: The health check results of at least 30% of health check templates are normal.
*   p50_ok: The health check results of at least 50% of health check templates are normal.
*   p70_ok: The health check results of at least 70% of health check templates are normal.
*   all_ok: The health check results of all health check templates are normal.', example='any_ok'),
          healthStatus?: string(name='HealthStatus', description='The health check state of the address. Valid values:

*   ok: The address passes all health checks of the referenced health check templates.
*   ok_alert: The address fails some health checks of the referenced health check templates but the address is deemed normal.
*   ok_no_monitor: The address does not reference any health check template and is normal.
*   exceptional: The address fails some or all health checks of the referenced health check templates and the address is deemed abnormal.', example='ok'),
          healthTasks?: {
            healthTask?: [ 
            {
              port?: int32(name='Port', description='The target service port for health checks. When the Ping protocol is selected for health checks, configuration of the service port is not supported.', example='80'),
              templateId?: string(name='TemplateId', description='The ID of the health check template.', example='mtp-895180524251002880'),
              templateName?: string(name='TemplateName', description='Health check template name.', example='IPv4-Ping'),
            }
          ](name='HealthTask')
          }(name='HealthTasks', description='The health check tasks.'),
          manualAvailableStatus?: string(name='ManualAvailableStatus', description='The availability state of the address when AvailableMode is set to manual for the address. Valid values:

*   available: The address is available. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
*   unavailable: The address is unavailable. In this state, the address is not returned for DNS requests even if the address passes health checks.', example='available'),
          name?: string(name='Name', description='Address name.', example='Address-1'),
          remark?: string(name='Remark', description='Address remarks.', example='test'),
          requestSource?: {
            requestSource?: [ string ](name='RequestSource')
          }(name='RequestSource', description='List of request sources.'),
          seqNonPreemptiveSchedule?: boolean(name='SeqNonPreemptiveSchedule', description='Indicates whether the mode of the sequence policy for load balancing between address pools is non-preemptive. This parameter is available only for the multicloud integration scenario. Valid values:

*   true
*   false', example='false'),
          serialNumber?: int32(name='SerialNumber', description='Sequence number, indicating the priority of address return, where smaller numbers have higher priority.', example='1'),
          type?: string(name='Type', description='Address type:
- IPv4: IPv4 address
- IPv6: IPv6 address
- domain: Domain name', example='IPv4'),
          updateTime?: string(name='UpdateTime', description='The last time the address was modified.', example='2024-03-15T01:46Z'),
          updateTimestamp?: long(name='UpdateTimestamp', description='The last modification time of the address (timestamp).', example='1527690629357'),
          weightValue?: int32(name='WeightValue', description='Weight value (integer between 1 and 100), supports setting different weight values for each address, enabling resolution queries to return addresses according to the weight ratio.', example='1'),
        }
      ](name='Address')
      }(name='Addresses', description='The addresses.'),
      availableStatus?: string(name='AvailableStatus', description='The availability state of the address pool. Valid values:

*   Available: The address pool is available.
*   unavailable: The address pool is unavailable.', example='available'),
      createTime?: string(name='CreateTime', description='Address pool creation time.', example='2024-03-15T01:46Z'),
      createTimestamp?: long(name='CreateTimestamp', description='Address pool creation time (timestamp).', example='1527690629357'),
      enableStatus?: string(name='EnableStatus', description='The enabling state of the address pool. Valid values:

*   enable: The address pool is enabled.
*   disable: The address pool is disabled.', example='enable'),
      healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health state of the address. Valid values:

*   any_ok: The health check results of at least one health check template are normal.
*   p30_ok: The health check results of at least 30% of health check templates are normal.
*   p50_ok: The health check results of at least 50% of health check templates are normal.
*   p70_ok: The health check results of at least 70% of health check templates are normal.
*   all_ok: The health check results of all health check templates are normal.', example='any_ok'),
      healthStatus?: string(name='HealthStatus', description='The health state of the address pool. Valid values:

*   ok: The health state of the address pool is Normal and all addresses that are referenced by the address pool are available.
*   ok_alert: The health state of the address pool is Warning and some of the addresses that are referenced by the address pool are unavailable. However, the address pool is deemed normal. In this state, available address pools are normally used for DNS resolution, but unavailable address pools cannot be used for DNS resolution.
*   exceptional: The health state of the address pool is Abnormal and some or all of the addresses that are referenced by the address pool are unavailable. In this case, the address pool is deemed abnormal.', example='ok'),
      remark?: string(name='Remark', description='Remark', example='test'),
      sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address with the smallest sequence number is recovered. This parameter is required only when AddressLbStrategy is set to sequence. Valid values:

*   preemptive: The address with the smallest sequence number is preferentially used if this address is recovered.
*   non_preemptive: The current address is still used even if the address with the smallest sequence number is recovered.', example='preemptive'),
      updateTime?: string(name='UpdateTime', description='Last modification time of the address pool.', example='2024-03-15T01:46Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='Last modification time of the address pool (timestamp).', example='1527690629357'),
    }
  ](name='AddressPool')
  }(name='AddressPools', description='The address pools.'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting at **1**, default is **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.', example='20'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalItems?: int32(name='TotalItems', description='Total number of entries in the address pool.', example='11'),
  totalPages?: int32(name='TotalPages', description='Total number of pages.', example='1'),
}

model ListCloudGtmAddressPoolsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCloudGtmAddressPoolsResponseBody(name='body'),
}

/**
 * @summary Queries a list of address pools.
 *
 * @param request ListCloudGtmAddressPoolsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCloudGtmAddressPoolsResponse
 */
async function listCloudGtmAddressPoolsWithOptions(request: ListCloudGtmAddressPoolsRequest, runtime: Util.RuntimeOptions): ListCloudGtmAddressPoolsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.addressPoolName)) {
    query['AddressPoolName'] = request.addressPoolName;
  }
  if (!Util.isUnset(request.addressPoolType)) {
    query['AddressPoolType'] = request.addressPoolType;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.enableStatus)) {
    query['EnableStatus'] = request.enableStatus;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCloudGtmAddressPools',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of address pools.
 *
 * @param request ListCloudGtmAddressPoolsRequest
 * @return ListCloudGtmAddressPoolsResponse
 */
async function listCloudGtmAddressPools(request: ListCloudGtmAddressPoolsRequest): ListCloudGtmAddressPoolsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCloudGtmAddressPoolsWithOptions(request, runtime);
}

model ListCloudGtmAddressesRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='Return language value, options:
- zh-CN: Chinese.
- en-US: English.', example='en-US'),
  address?: string(name='Address', description='IP address or domain name.', example='223.5.XX.XX'),
  addressId?: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.', example='addr-89518218114368**92'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  enableStatus?: string(name='EnableStatus', description='Indicates the current availability of the address:
- enable: Enabled status
- disable: Disabled status', example='enable'),
  healthStatus?: string(name='HealthStatus', description='The health check state of the address. Valid values:

*   ok: The address passes all health checks of the referenced health check templates.
*   ok_alert: The address fails some health checks of the referenced health check templates but the address is deemed normal.
*   ok_no_monitor: The address does not reference a health check template.
*   exceptional: The address fails some or all health checks of the referenced health check templates and the address is deemed abnormal.', example='ok'),
  monitorTemplateId?: string(name='MonitorTemplateId', description='The ID of the health check template. This ID uniquely identifies the health check template.', example='mtp-89518052425100**80'),
  name?: string(name='Name', description='Address name.', example='test'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from **1**, default is **1**.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.

This parameter is required.', example='20'),
  type?: string(name='Type', description='Address type:
- IPv4
- IPv6
- domain', example='IPv4'),
}

model ListCloudGtmAddressesResponseBody = {
  addresses?: {
    address?: [ 
    {
      address?: string(name='Address', description='IP address or domain name.', example='223.5.XX.XX'),
      addressId?: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.', example='addr-89518218114368**92'),
      attributeInfo?: string(name='AttributeInfo', description='Address ownership information.', example='Not supported in current version, this parameter should be none.'),
      availableMode?: string(name='AvailableMode', description='The failover method that is used if the address fails health checks. Valid values:

auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.

manual: the manual mode. If an address is in the unavailable state, the address is not returned for Domain Name System (DNS) requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.', example='auto'),
      availableStatus?: string(name='AvailableStatus', description='The availability state of the address. Valid values:

*   available: The address is available.
*   unavailable: The address is unavailable.', example='available'),
      createTime?: string(name='CreateTime', description='Address creation time.', example='2024-03-23T13:09Z'),
      createTimestamp?: long(name='CreateTimestamp', description='Creation time (timestamp).', example='1527690629357'),
      enableStatus?: string(name='EnableStatus', description='Indicates the current availability of the address:
- enable: Enabled status 
- disable: Disabled status', example='enable'),
      healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address. Valid values:

*   any_ok: The health check results of at least one health check template are normal.
*   p30_ok: The health check results of at least 30% of health check templates are normal.
*   p50_ok: The health check results of at least 50% of health check templates are normal.
*   p70_ok: The health check results of at least 70% of health check templates are normal.
*   all_ok: The health check results of all health check templates are normal.', example='p50_ok'),
      healthStatus?: string(name='HealthStatus', description='The health check state of the address. Valid values:

*   ok: The address passes all health checks of the referenced health check templates.
*   ok_alert: The address fails some health checks of the referenced health check templates but the address is deemed normal.
*   ok_no_monitor: The address does not reference a health check template.
*   exceptional: The address fails some or all health checks of the referenced health check templates and the address is deemed abnormal.', example='ok'),
      healthTasks?: {
        healthTask?: [ 
        {
          monitorStatus?: string(name='MonitorStatus', description='The state of the health check task. Valid values:

*   ok: The task is normal.
*   alert: An alert is triggered.
*   no_data: No data is available. In most cases, the health check task is newly created and no data is collected.', example='ok'),
          port?: int32(name='Port', description='The target service port for health check probes. When the health check protocol is set to Ping, configuration of the service port is not supported.', example='80'),
          templateId?: string(name='TemplateId', description='The ID of the health check template associated with the address.', example='mtp-89518052425100**80'),
          templateName?: string(name='TemplateName', description='Health check template name.', example='Ping-IPv4'),
        }
      ](name='HealthTask')
      }(name='HealthTasks', description='The health check tasks referenced by the address.'),
      manualAvailableStatus?: string(name='ManualAvailableStatus', description='The availability state of the address when AvailableMode is set to manual. Valid values:

available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.

unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.', example='available'),
      name?: string(name='Name', description='Address name.', example='Address-1'),
      remark?: string(name='Remark', description='Remarks.', example='app'),
      type?: string(name='Type', description='Address type:
- IPv4
- IPv6
- domain', example='IPv4'),
      updateTime?: string(name='UpdateTime', description='Address modification time.', example='2024-03-29T13:20Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='Update time (timestamp).', example='1527690824357'),
    }
  ](name='Address')
  }(name='Addresses', description='The addresses.'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from **1**, default is **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.', example='20'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalItems?: int32(name='TotalItems', description='Get the total number of addresses in the address list.', example='30'),
  totalPages?: int32(name='TotalPages', description='Total number of pages.', example='2'),
}

model ListCloudGtmAddressesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCloudGtmAddressesResponseBody(name='body'),
}

/**
 * @summary Queries a list of addresses.
 *
 * @param request ListCloudGtmAddressesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCloudGtmAddressesResponse
 */
async function listCloudGtmAddressesWithOptions(request: ListCloudGtmAddressesRequest, runtime: Util.RuntimeOptions): ListCloudGtmAddressesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.addressId)) {
    query['AddressId'] = request.addressId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.enableStatus)) {
    query['EnableStatus'] = request.enableStatus;
  }
  if (!Util.isUnset(request.healthStatus)) {
    query['HealthStatus'] = request.healthStatus;
  }
  if (!Util.isUnset(request.monitorTemplateId)) {
    query['MonitorTemplateId'] = request.monitorTemplateId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCloudGtmAddresses',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of addresses.
 *
 * @param request ListCloudGtmAddressesRequest
 * @return ListCloudGtmAddressesResponse
 */
async function listCloudGtmAddresses(request: ListCloudGtmAddressesRequest): ListCloudGtmAddressesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCloudGtmAddressesWithOptions(request, runtime);
}

model ListCloudGtmAlertLogsRequest {
  actionType?: string(name='ActionType', description='Alert type:
- ALERT
- RESUME', example='ALERT'),
  endTimestamp?: long(name='EndTimestamp', description='The end time of the query (timestamp).

This parameter is required.', example='1711328826977'),
  entityType?: string(name='EntityType', description='Alarm object types:
- GTM_ADDRESS: Address
- GTM_ADDRESS_POOL: Address Pool
- GTM_INSTANCE: Instance
- GTM_MONITOR_TEMPLATE: Health Check Template', example='GTM_ADDRESS'),
  keyword?: string(name='Keyword', description='Search keyword, usually an address ID, address pool ID, domain information, etc.', example='pool-895280232254422016'),
  lang?: string(name='Lang', description='Language type of the returned information:
- zh-CN: Chinese
- en-US: English', example='zh-CN'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from **1**, default is **1**.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.

This parameter is required.', example='20'),
  startTimestamp?: long(name='StartTimestamp', description='The start time of the query (timestamp).

This parameter is required.', example='1611328826977'),
}

model ListCloudGtmAlertLogsResponseBody = {
  logs?: {
    log?: [ 
    {
      actionType?: string(name='ActionType', description='Alert type:
- ALERT
- RESUME', example='ALERT'),
      content?: string(name='Content', description='The alert content.', example='The alert content.'),
      entityType?: string(name='EntityType', description='Alarm object types:
- GTM_ADDRESS: Address
- GTM_ADDRESS_POOL: Address Pool
- GTM_INSTANCE: Instance
- GTM_MONITOR_TEMPLATE: Health Check Template', example='GTM_ADDRESS'),
      timestamp?: long(name='Timestamp', description='Alert log time (timestamp).', example='1711328826977'),
    }
  ](name='Log')
  }(name='Logs', description='The alert logs.'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from 1, default is 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.', example='20'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalItems?: int32(name='TotalItems', description='Total number of alarm log entries.', example='15'),
  totalPages?: int32(name='TotalPages', description='Total number of pages.', example='1'),
}

model ListCloudGtmAlertLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCloudGtmAlertLogsResponseBody(name='body'),
}

/**
 * @param request ListCloudGtmAlertLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCloudGtmAlertLogsResponse
 */
async function listCloudGtmAlertLogsWithOptions(request: ListCloudGtmAlertLogsRequest, runtime: Util.RuntimeOptions): ListCloudGtmAlertLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actionType)) {
    query['ActionType'] = request.actionType;
  }
  if (!Util.isUnset(request.endTimestamp)) {
    query['EndTimestamp'] = request.endTimestamp;
  }
  if (!Util.isUnset(request.entityType)) {
    query['EntityType'] = request.entityType;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTimestamp)) {
    query['StartTimestamp'] = request.startTimestamp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCloudGtmAlertLogs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListCloudGtmAlertLogsRequest
 * @return ListCloudGtmAlertLogsResponse
 */
async function listCloudGtmAlertLogs(request: ListCloudGtmAlertLogsRequest): ListCloudGtmAlertLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCloudGtmAlertLogsWithOptions(request, runtime);
}

model ListCloudGtmAvailableAlertGroupsRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   **zh-CN**: Chinese
*   **en-US**: English', example='en-US'),
}

model ListCloudGtmAvailableAlertGroupsResponseBody = {
  alertGroups?: {
    alertGroup?: [ 
    {
      groupName?: string(name='GroupName', description='The name of the alert contact group.', example='[\\\\"Default\\\\"]'),
    }
  ](name='AlertGroup')
  }(name='AlertGroups', description='The alert contact groups.'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model ListCloudGtmAvailableAlertGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCloudGtmAvailableAlertGroupsResponseBody(name='body'),
}

/**
 * @param request ListCloudGtmAvailableAlertGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCloudGtmAvailableAlertGroupsResponse
 */
async function listCloudGtmAvailableAlertGroupsWithOptions(request: ListCloudGtmAvailableAlertGroupsRequest, runtime: Util.RuntimeOptions): ListCloudGtmAvailableAlertGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCloudGtmAvailableAlertGroups',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListCloudGtmAvailableAlertGroupsRequest
 * @return ListCloudGtmAvailableAlertGroupsResponse
 */
async function listCloudGtmAvailableAlertGroups(request: ListCloudGtmAvailableAlertGroupsRequest): ListCloudGtmAvailableAlertGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCloudGtmAvailableAlertGroupsWithOptions(request, runtime);
}

model ListCloudGtmInstanceConfigsRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  enableStatus?: string(name='EnableStatus', description='The enabling state of the access domain name. Valid values:

*   enable: The access domain name is enabled and the intelligent scheduling policy of the GTM instance takes effect.
*   disable: The access domain name is disabled and the intelligent scheduling policy of the GTM instance does not take effect.', example='enable'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance.', example='gtm-cn-wwo3a3hbz**'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting at **1**, default is **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of **100**, and a default of **20**.', example='20'),
  remark?: string(name='Remark', description='Remarks.', example='test'),
  scheduleDomainName?: string(name='ScheduleDomainName', description='The GTM access domain name. The value of this parameter is composed of the value of ScheduleHostname and the value of ScheduleZoneName.', example='www.example.com'),
  scheduleZoneName?: string(name='ScheduleZoneName', description='The zone (such as example.com) or subzone (such as a.example.com) of the GTM access domain name. In most cases, the zone or subzone is hosted in Authoritative DNS Resolution of the Alibaba Cloud DNS console within the account to which the GTM instance belongs.', example='example.com'),
}

model ListCloudGtmInstanceConfigsResponseBody = {
  instanceConfigs?: {
    instanceConfig?: [ 
    {
      addressPoolLbStrategy?: string(name='AddressPoolLbStrategy', description='The policy for load balancing between address pools. Valid values:

*   round_robin: All address pools are returned for DNS requests from any source. All address pools are sorted in round-robin mode each time they are returned.
*   sequence: The address pool with the smallest sequence number is preferentially returned for DNS requests from any source. The sequence number indicates the priority for returning the address pool. A smaller sequence number indicates a higher priority. If the address pool with the smallest sequence number is unavailable, the address pool with the second smallest sequence number is returned.
*   weight: You can set a different weight value for each address pool. This way, address pools are returned based on the weight values.
*   source_nearest: GTM returns different address pools based on the sources of DNS requests. This way, users can access nearby addresses.', example='round_robin'),
      addressPools?: {
        addressPool?: [ 
        {
          addressLbStrategy?: string(name='AddressLbStrategy', description='Load balancing policy among addresses in the address pool:
- round_robin: Round-robin, for any source of DNS resolution requests, returns all addresses and rotates the order of all addresses each time.
- sequence: Sequential, for any source of DNS resolution requests, returns the address with the smaller sequence number (the sequence number indicates the priority of the address return, the smaller the higher the priority). If the address with the smaller sequence number is unavailable, return the next address with a smaller sequence number.
- weight: Weighted, supports setting different weight values for each address to realize returning addresses according to the weight ratio for resolution queries.
- source_nearest: Source-nearest, i.e., intelligent resolution function, where GTM can return different addresses based on the source of different DNS resolution requests, achieving the effect of users accessing nearby.', example='round_robin'),
          addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
          addressPoolName?: string(name='AddressPoolName', description='Address pool name.', example='AddressPool-1'),
          addressPoolType?: string(name='AddressPoolType', description='Address pool type:
- IPv4
- IPv6
- domain', example='IPv4'),
          availableStatus?: string(name='AvailableStatus', description='Address pool availability status:
- available: Available
- unavailable: Unavailable', example='available'),
          createTime?: string(name='CreateTime', description='Address pool creation time.', example='2024-03-15T01:46Z'),
          createTimestamp?: long(name='CreateTimestamp', description='Address pool creation time (timestamp).', example='1527690629357'),
          enableStatus?: string(name='EnableStatus', description='Address pool status:
- enable: Enabled status
- disable: Disabled status', example='enable'),
          healthJudgement?: string(name='HealthJudgement', description='The health state of the address pool. Valid values:

*   ok: The health state of the address pool is Normal and all addresses that are referenced by the address pool are available.
*   ok_alert: The health state of the address pool is Warning and some of the addresses that are referenced by the address pool are unavailable. However, the address pool is deemed normal. In this case, available address pools are normally used for DNS resolution, but unavailable address pools cannot be used for DNS resolution.
*   exceptional: The health state of the address pool is Abnormal and some or all of the addresses that are referenced by the address pool are unavailable. In this case, the address pool is deemed abnormal.', example='ok'),
          healthStatus?: string(name='HealthStatus', description='The health state of the address pool. Valid values:

*   ok: The health state of the address pool is Normal and all addresses that are referenced by the address pool are available.
*   ok_alert: The health state of the address pool is Warning and some of the addresses that are referenced by the address pool are unavailable. However, the address pool is deemed normal. In this case, available address pools are normally used for DNS resolution, but unavailable address pools cannot be used for DNS resolution.
*   exceptional: The health state of the address pool is Abnormal and some or all of the addresses that are referenced by the address pool are unavailable. In this case, the address pool is deemed abnormal.', example='ok'),
          requestSource?: {
            requestSource?: [ string ](name='RequestSource')
          }(name='RequestSource', description='Parse the request source list.'),
          seqNonPreemptiveSchedule?: boolean(name='SeqNonPreemptiveSchedule', description='Indicates whether the mode of the sequence policy for load balancing between address pools is non-preemptive. This parameter is available only for the multicloud integration scenario. Valid values:

*   true
*   false', example='false'),
          sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address with the smallest sequence number is recovered. This parameter is required only when AddressLbStrategy is set to sequence. Valid values:

*   preemptive: The address with the smallest sequence number is preferentially used if this address is recovered.
*   non_preemptive: The current address is still used even if the address with the smallest sequence number is recovered.', example='preemptive'),
          serialNumber?: int32(name='SerialNumber', description='Sequence number. For any parsing request, the address pool with the smaller sequence number (indicating the priority of the address pool returned, with smaller numbers having higher priority) is returned.', example='1'),
          updateTime?: string(name='UpdateTime', description='Last modification time of the address pool.', example='2024-03-15T01:46Z'),
          updateTimestamp?: long(name='UpdateTimestamp', description='Last modification time of the address pool (timestamp).', example='1527690629357'),
          weightValue?: int32(name='WeightValue', description='Weight value (an integer between 1 and 100, including both 1 and 100), which supports setting different weight values for each address pool, enabling the resolution query to return address pools according to the weighted ratio.', example='1'),
        }
      ](name='AddressPool')
      }(name='AddressPools', description='The address pools.'),
      availableStatus?: string(name='AvailableStatus', description='The availability state of the access domain name. Valid values:

*   available: If the access domain name is **enabled** and the health state of the access domain name is **Normal**, the access domain name is deemed **Available**.
*   unavailable: If the access domain name is **disabled** or the health state of the access domain name is **Abnormal**, the access domain name is deemed **Unavailable**.', example='available'),
      commodityCode?: string(name='CommodityCode', description='The commodity code. Valid values:

*   dns_gtm_public_cn: the commodity code on the China site (aliyun.com)
*   dns_gtm_public_intl: the commodity code on the international site (alibabacloud.com)', example='dns_gtm_public_cn'),
      configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.', example='Config-000**11'),
      createTime?: string(name='CreateTime', description='Instance configuration creation time.', example='2024-03-15T01:46Z'),
      createTimestamp?: long(name='CreateTimestamp', description='Instance creation time (timestamp).', example='1527690629357'),
      enableStatus?: string(name='EnableStatus', description='The enabling state of the access domain name. Valid values:

*   enable: The access domain name is enabled and the intelligent scheduling policy of the GTM instance takes effect.
*   disable: The access domain name is disabled and the intelligent scheduling policy of the GTM instance does not take effect.', example='enable'),
      healthStatus?: string(name='HealthStatus', description='The health state of the access domain name. Valid values:

*   ok: The health state of the access domain name is Normal and all address pools that are referenced by the access domain name are available.
*   ok_alert: The health state of the access domain name is Warning and some of the address pools that are referenced by the access domain name are unavailable. In this case, available address pools are normally used for DNS resolution, but unavailable address pools cannot be used for DNS resolution.
*   exceptional: The health state of the access domain name is Abnormal and all address pools that are referenced by the access domain name are unavailable. In this case, addresses in the non-empty address pool with the smallest sequence number are preferentially used for fallback resolution. This returns DNS results for clients as much as possible.', example='ok'),
      instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance.', example='gtm-cn-wwo3a3hbz**'),
      remark?: string(name='Remark', description='Remarks on the configuration of domain instance.', example='test'),
      scheduleDomainName?: string(name='ScheduleDomainName', description='The GTM access domain name. The value of this parameter is composed of the value of ScheduleHostname and the value of ScheduleZoneName.', example='www.example.com'),
      scheduleHostname?: string(name='ScheduleHostname', description='Host record of the domain accessed by GTM.', example='www'),
      scheduleRrType?: string(name='ScheduleRrType', description='DNS record types for the scheduling domain:
- A: IPv4 address
- AAAA: IPv6 address
- CNAME: Domain name', example='A'),
      scheduleZoneMode?: string(name='ScheduleZoneMode', description='The allocation mode of the access domain name. Valid values:

*   custom: custom allocation. You must specify a custom hostname and associate the hostname with a zone within the account to which the GTM instance belongs to generate an access domain name.
*   sys_assign: system allocation. This mode is not supported. Do not set ScheduleZoneMode to sys_assign.', example='custom'),
      scheduleZoneName?: string(name='ScheduleZoneName', description='The zone (such as example.com) or subzone (such as a.example.com) of the GTM access domain name. In most cases, the zone or subzone is hosted in Authoritative DNS Resolution of the Alibaba Cloud DNS console within the account to which the GTM instance belongs.', example='example.com'),
      sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address pool with the smallest sequence number is recovered. This parameter is required when AddressPoolLbStrategy is set to sequence. Valid values:

*   preemptive: The address pool with the smallest sequence number is preferentially used if this address pool is recovered.
*   non_preemptive: The current address pool is still used even if the address pool with the smallest sequence number is recovered.', example='preemptive'),
      ttl?: int32(name='Ttl', description='Global TTL (in seconds), the TTL value for domain resolution to addresses in the address pool, affecting the caching time of DNS records in the ISP\\\\"s LocalDNS. Supports custom TTL values.', example='60'),
      updateTime?: string(name='UpdateTime', description='The last modified time of the instance configuration.', example='2024-03-15T01:46Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The last modification time of the instance configuration (timestamp).', example='1527690629357'),
      versionCode?: string(name='VersionCode', description='The edition of the GTM 3.0 instance. Valid values:

*   standard: Standard Edition
*   ultimate: Ultimate Edition', example='ultimate'),
    }
  ](name='InstanceConfig')
  }(name='InstanceConfigs', description='The configurations of the instance.'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from **1**, default is **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.', example='20'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalItems?: int32(name='TotalItems', description='Total number of entries for domain instance configurations.', example='10'),
  totalPages?: int32(name='TotalPages', description='Total number of pages.', example='1'),
}

model ListCloudGtmInstanceConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCloudGtmInstanceConfigsResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of a Global Traffic Manager (GTM) instance, including the information about access domain names and address pools.
 *
 * @param request ListCloudGtmInstanceConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCloudGtmInstanceConfigsResponse
 */
async function listCloudGtmInstanceConfigsWithOptions(request: ListCloudGtmInstanceConfigsRequest, runtime: Util.RuntimeOptions): ListCloudGtmInstanceConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.enableStatus)) {
    query['EnableStatus'] = request.enableStatus;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.scheduleDomainName)) {
    query['ScheduleDomainName'] = request.scheduleDomainName;
  }
  if (!Util.isUnset(request.scheduleZoneName)) {
    query['ScheduleZoneName'] = request.scheduleZoneName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCloudGtmInstanceConfigs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the configurations of a Global Traffic Manager (GTM) instance, including the information about access domain names and address pools.
 *
 * @param request ListCloudGtmInstanceConfigsRequest
 * @return ListCloudGtmInstanceConfigsResponse
 */
async function listCloudGtmInstanceConfigs(request: ListCloudGtmInstanceConfigsRequest): ListCloudGtmInstanceConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCloudGtmInstanceConfigsWithOptions(request, runtime);
}

model ListCloudGtmInstancesRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='Return language value. Options:
- zh-CN: Chinese.
- en-US: English.', example='en-US'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance.', example='gtm-cn-jmp3qnw**03'),
  instanceName?: string(name='InstanceName', description='Instance name, used to distinguish the business purpose of the instance.', example='test'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from **1**, default is **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of **100**, and a default of **20**.', example='20'),
}

model ListCloudGtmInstancesResponseBody = {
  instances?: {
    instance?: [ 
    {
      commodityCode?: string(name='CommodityCode', description='The commodity code. Valid values:

*   dns_gtm_public_cn: commodity code on the China site (aliyun.com)
*   dns_gtm_public_intl: commodity code on the international site (alibabacloud.com)', example='dns_gtm_public_cn'),
      createTime?: string(name='CreateTime', description='Instance creation time.', example='2024-03-15T01:46Z'),
      createTimestamp?: long(name='CreateTimestamp', description='Instance creation time (timestamp).', example='1231298343343'),
      expireTime?: string(name='ExpireTime', description='Instance expiration time.', example='2024-03-15T01:46Z'),
      expireTimestamp?: long(name='ExpireTimestamp', description='Instance expiration time (timestamp).', example='1231298343343'),
      instanceId?: string(name='InstanceId', description='The ID of the GTM instance.', example='gtm-cn-jmp3qnw**03'),
      instanceName?: string(name='InstanceName', description='Instance name.', example='test'),
      monitorTaskQuota?: int32(name='MonitorTaskQuota', description='Monitor probe task quota.', example='100'),
      monthlyEmailUsed?: int32(name='MonthlyEmailUsed', description='Monthly email sending volume.', example='50'),
      monthlySmsQuota?: int32(name='MonthlySmsQuota', description='SMS quota, only supported on the China site as international sites do not support SMS.', example='1000'),
      monthlySmsUsed?: int32(name='MonthlySmsUsed', description='Monthly SMS sending volume, only supported by the China site as international sites do not support SMS.', example='100'),
      monthlyWebhookUsed?: int32(name='MonthlyWebhookUsed', description='Monthly webhook send volume.', example='80'),
      scheduleDomainName?: string(name='ScheduleDomainName', description='The access domain name, which consists of a hostname and a zone or a subzone.', example='www.example.com'),
      updateTime?: string(name='UpdateTime', description='The last time the instance was modified.', example='2024-03-15T01:46Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The last modification time of the instance (timestamp).', example='1231298343343'),
      versionCode?: string(name='VersionCode', description='GTM instance version:
- standard: Standard Edition
- ultimate: Ultimate Edition', example='ultimate'),
    }
  ](name='Instance')
  }(name='Instances', description='The instances.'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting with **1**, default is **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.', example='20'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalItems?: int32(name='TotalItems', description='Total number of instance entries.', example='15'),
  totalPages?: int32(name='TotalPages', description='Total number of pages.', example='1'),
}

model ListCloudGtmInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCloudGtmInstancesResponseBody(name='body'),
}

/**
 * @summary Queries a list of Global Traffic Manager (GTM) 3.0 instances.
 *
 * @param request ListCloudGtmInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCloudGtmInstancesResponse
 */
async function listCloudGtmInstancesWithOptions(request: ListCloudGtmInstancesRequest, runtime: Util.RuntimeOptions): ListCloudGtmInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCloudGtmInstances',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of Global Traffic Manager (GTM) 3.0 instances.
 *
 * @param request ListCloudGtmInstancesRequest
 * @return ListCloudGtmInstancesResponse
 */
async function listCloudGtmInstances(request: ListCloudGtmInstancesRequest): ListCloudGtmInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCloudGtmInstancesWithOptions(request, runtime);
}

model ListCloudGtmMonitorNodesRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   **zh-CN**: Chinese
*   **en-US** (default): English', example='en-US'),
}

model ListCloudGtmMonitorNodesResponseBody = {
  ipv4IspCityNodes?: {
    ipv4IspCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='City code.', example='503'),
      cityName?: string(name='CityName', description='City name.', example='Beijing'),
      countryCode?: string(name='CountryCode', description='Country code.', example='629'),
      countryName?: string(name='CountryName', description='Country name.', example='China'),
      defaultSelected?: boolean(name='DefaultSelected', description='Monitor node default selection:
- true: Selected by default
- false: Not selected by default', example='true'),
      groupName?: string(name='GroupName', description='Monitor probe group name.', example='BGP Nodes'),
      groupType?: string(name='GroupType', description='Monitoring node group type, currently supported:
- BGP: BGP node
- OVERSEAS: International node
- ISP: Carrier node', example='BGP'),
      ips?: {
        ip?: [ string ](name='Ip')
      }(name='Ips', description='List of node IP addresses.'),
      ispCode?: string(name='IspCode', description='Operator code.', example='465'),
      ispName?: string(name='IspName', description='Operator name.', example='Alibaba'),
      nodeId?: string(name='NodeId', description='Unique identifier ID of the probe node.', example='node-ewze1bysndy4gf**j8'),
    }
  ](name='Ipv4IspCityNode')
  }(name='Ipv4IspCityNodes', description='Public IPv4 monitoring node list.'),
  ipv6IspCityNodes?: {
    ipv6IspCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='City code.', example='357'),
      cityName?: string(name='CityName', description='City name.', example='Shanghai'),
      countryCode?: string(name='CountryCode', description='Country code.', example='629'),
      countryName?: string(name='CountryName', description='Country name.', example='China'),
      defaultSelected?: boolean(name='DefaultSelected', description='Monitor node default selection:
- true: Selected by default
- false: Not selected by default', example='true'),
      groupName?: string(name='GroupName', description='Monitoring probe group name.', example='BGP'),
      groupType?: string(name='GroupType', description='Monitoring node group type, currently supported:
- BGP: BGP node
- OVERSEAS: International node
- ISP: Carrier node', example='BGP'),
      ips?: {
        ip?: [ string ](name='Ip')
      }(name='Ips', description='List of node IP addresses.'),
      ispCode?: string(name='IspCode', description='Operator code.', example='465'),
      ispName?: string(name='IspName', description='Operator name.', example='Alibaba'),
      nodeId?: string(name='NodeId', description='Unique identifier ID of the probe node.', example='node-ewze1bysndy4gf**j8'),
    }
  ](name='Ipv6IspCityNode')
  }(name='Ipv6IspCityNodes', description='List of public IPv6 monitoring nodes.'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model ListCloudGtmMonitorNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCloudGtmMonitorNodesResponseBody(name='body'),
}

/**
 * @summary Queries a list of health check nodes.
 *
 * @param request ListCloudGtmMonitorNodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCloudGtmMonitorNodesResponse
 */
async function listCloudGtmMonitorNodesWithOptions(request: ListCloudGtmMonitorNodesRequest, runtime: Util.RuntimeOptions): ListCloudGtmMonitorNodesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCloudGtmMonitorNodes',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of health check nodes.
 *
 * @param request ListCloudGtmMonitorNodesRequest
 * @return ListCloudGtmMonitorNodesResponse
 */
async function listCloudGtmMonitorNodes(request: ListCloudGtmMonitorNodesRequest): ListCloudGtmMonitorNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCloudGtmMonitorNodesWithOptions(request, runtime);
}

model ListCloudGtmMonitorTemplatesRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  ipVersion?: string(name='IpVersion', description='The IP address type of health check nodes. Valid values:

*   IPv4: applicable when health checks are performed on IPv4 addresses.
*   IPv6: applicable when health checks are performed on IPv6 addresses.', example='IPv4'),
  name?: string(name='Name', description='The name of the health check probe template, which is recommended to be distinguishable for configuration personnel to differentiate and remember, ideally indicating the health check protocol.', example='IPv4-Ping'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from **1**, default is **1**.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.

This parameter is required.', example='20'),
  protocol?: string(name='Protocol', description='Protocol types for initiating probes to the target IP address:
- ping
- tcp
- http
- https', example='ping'),
}

model ListCloudGtmMonitorTemplatesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from 1, default is 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.', example='20'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='75446CC1-FC9A-4595-8D96-089D73D7A63D'),
  templates?: {
    template?: [ 
    {
      createTime?: string(name='CreateTime', description='Health check template creation time.', example='2024-03-23T13:09Z'),
      createTimestamp?: long(name='CreateTimestamp', description='Health check template creation time (timestamp).', example='1527690629357'),
      evaluationCount?: int32(name='EvaluationCount', description='The number of retries. The system will only judge the application service as abnormal after consecutive monitoring failures to prevent inaccurate monitoring results due to momentary network fluctuations or other reasons. Available retry options are:
- 1 - 2 - 3', example='2'),
      extendInfo?: string(name='ExtendInfo', description='The extended information. The value of this parameter is a JSON string. The required parameters vary based on the health check protocol.

*   HTTP or HTTPS:

    **host**: the Host field of an HTTP or HTTPS request header during an HTTP or HTTPS health check. The parameter value indicates the HTTP website that you want to visit. By default, the value is the primary domain name. You can change the value based on your business requirements.

    **path**: the URL for HTTP or HTTPS health checks. Default value: /.

    **code**: the alert threshold. During an HTTP or HTTPS health check, the system checks whether a web server functions as expected based on the status code that is returned from the web server. If the returned status code is greater than the specified threshold, the corresponding application service address is deemed abnormal. Valid values:

    *   400: indicates an invalid request. If an HTTP or HTTPS request contains invalid request parameters, a web server returns a status code that is greater than 400. You must specify an exact URL for path if you set code to 400.
    *   500: indicates a server error. If some exceptions occur on a web server, the web server returns a status code that is greater than 500. This value is used by default.

    **sni**: indicates whether Server Name Indication (SNI) is enabled. This parameter is used only when the health check protocol is HTTPS. SNI is an extension to the Transport Layer Security (TLS) protocol, which allows a client to specify the host to be connected when the client sends a TLS handshake request. TLS handshakes occur before any data of HTTP requests is sent. Therefore, SNI enables servers to identify the services that clients are attempting to access before certificates are sent. This allows the servers to present correct certificates to the clients. Valid values:

    *   true: SNI is enabled.
    *   false: SNI is disabled.

    **followRedirect**: indicates whether 3XX redirects are followed. Valid values:

    *   true: 3XX redirects are followed. You are redirected to the destination address if a 3XX status code such as 301, 302, 303, 307, or 308 is returned.
    *   false: 3XX redirects are not followed.

*   ping:

    **packetNum**: the total number of Internet Control Message Protocol (ICMP) packets that are sent to the address for each ping-based health check. Valid values: 20, 50, and 100.

    **packetLossRate**: the ICMP packet loss rate for each ping-based health check. The packet loss rate in a health check can be calculated by using the following formula: Packet loss rate in a health check = (Number of lost packets/Total number of sent ICMP packets)  100%. If the packet loss rate reaches the threshold, an alert is triggered. Valid values: 10, 30, 40, 80, 90, and 100.', example='{\\\\"code\\\\":200,\\\\"path\\\\":\\\\"\\\\\\\\index.htm\\\\",\\\\"host\\\\":\\\\"aliyun.com\\\\"}'),
      failureRate?: int32(name='FailureRate', description='Percentage of selected node probe failures (%), that is, the percentage of unhealthy check points among total probe points. When the failure ratio exceeds the set threshold, the service address is judged as abnormal. The available failure ratio thresholds are:
- 20
- 50
- 80
- 100', example='50'),
      interval?: int32(name='Interval', description='The time interval between each check (in seconds), with a default of probing once every minute. The minimum supported health check interval is 15 seconds, available for flagship edition instances.', example='60'),
      ipVersion?: string(name='IpVersion', description='The IP address type of health check nodes. Valid values:

*   IPv4: applicable when health checks are performed on IPv4 addresses.
*   IPv6: applicable when health checks are performed on IPv6 addresses.', example='IPv4'),
      ispCityNodes?: {
        ispCityNode?: [ 
        {
          cityCode?: string(name='CityCode', description='City code.', example='738'),
          cityName?: string(name='CityName', description='City name.', example='Beijing'),
          countryCode?: string(name='CountryCode', description='Country code.', example='629'),
          countryName?: string(name='CountryName', description='Country name.', example='China'),
          groupName?: string(name='GroupName', description='Probe node group name.', example='BGP Nodes'),
          groupType?: string(name='GroupType', description='Probe node group types:
- BGP: BGP nodes
- OVERSEAS: International nodes
- ISP: Carrier nodes', example='BGP'),
          ispCode?: string(name='IspCode', description='Operator code.', example='465'),
          ispName?: string(name='IspName', description='Operator name.', example='Alibaba'),
        }
      ](name='IspCityNode')
      }(name='IspCityNodes', description='The health check nodes. You can call the [ListCloudGtmMonitorNodes](~~ListCloudGtmMonitorNodes~~) operation to obtain the health check nodes.'),
      name?: string(name='Name', description='The name of the health check probe template, generally for the convenience of configuration personnel to distinguish and remember.', example='IPv4-Ping'),
      protocol?: string(name='Protocol', description='Protocol types for initiating probes to the target IP address:
- ping
- tcp
- http
- https', example='ping'),
      remark?: string(name='Remark', description='Remarks for the health check template.', example='test'),
      templateId?: string(name='TemplateId', description='The ID of the health check template. This ID uniquely identifies the health check template.', example='mtp-89518052425100**80'),
      timeout?: int32(name='Timeout', description='Probe timeout (in milliseconds), data packets not returned within the timeout period are deemed as health check timeouts:
- 2000
- 3000
- 5000
- 10000', example='5000'),
      updateTime?: string(name='UpdateTime', description='Last modification time of the health check template.', example='2024-03-29T13:20Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='Health check template configuration modification time (timestamp).', example='1527690629357'),
    }
  ](name='Template')
  }(name='Templates', description='The health check templates.'),
  totalItems?: int32(name='TotalItems', description='Total number of health check template entries retrieved.', example='30'),
  totalPages?: int32(name='TotalPages', description='Total number of pages after data pagination.', example='2'),
}

model ListCloudGtmMonitorTemplatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCloudGtmMonitorTemplatesResponseBody(name='body'),
}

/**
 * @summary Queries a list of health check templates.
 *
 * @param request ListCloudGtmMonitorTemplatesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCloudGtmMonitorTemplatesResponse
 */
async function listCloudGtmMonitorTemplatesWithOptions(request: ListCloudGtmMonitorTemplatesRequest, runtime: Util.RuntimeOptions): ListCloudGtmMonitorTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.ipVersion)) {
    query['IpVersion'] = request.ipVersion;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.protocol)) {
    query['Protocol'] = request.protocol;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCloudGtmMonitorTemplates',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of health check templates.
 *
 * @param request ListCloudGtmMonitorTemplatesRequest
 * @return ListCloudGtmMonitorTemplatesResponse
 */
async function listCloudGtmMonitorTemplates(request: ListCloudGtmMonitorTemplatesRequest): ListCloudGtmMonitorTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCloudGtmMonitorTemplatesWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  nextToken?: string(name='NextToken', description='The pagination token. It can be used in the next request to retrieve a new page of results.', example='4698691'),
  resourceId?: [ string ](name='ResourceId', description='The ID of the resource.'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Valid values:

*   **DOMAIN**: domain name

This parameter is required.', example='DOMAIN'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='abcd'),
      value?: string(name='Value', description='The key value.', example='abcd'),
    }
  ](name='Tag', description='The tags.'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. If NextToken is empty, no next page exists.', example='4698691'),
  requestId?: string(name='RequestId', description='The request ID.', example='61092C8D-6AEB-4310-B74D-C632F89BF4FB'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId', description='The ID of the resource.', example='dns-example.com'),
      resourceType?: string(name='ResourceType', description='The type of the resource. Only DOMAIN is returned.', example='DOMAIN'),
      tagKey?: string(name='TagKey', description='The tag key.', example='abcd'),
      tagValue?: string(name='TagValue', description='The tag value.', example='abcd'),
    }
  ](name='TagResources', description='An array that consists of the resource and the tags that are added to the resource, including information such as the resource ID, resource type, tag keys, and tag values.'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesResponseBody(name='body'),
}

/**
 * @summary Queries resources by tag.
 *
 * @description *   Set ResourceId.N or Tag.N that consists of Tag.N.Key and Tag.N.Value in the request to specify the object to be queried.
 * *   Tag.N is a resource tag that consists of a key-value pair. If you set only Tag.N.Key, all tag values that are assigned to the specified key are returned. If you set only Tag.N.Value, an error message is returned.
 * *   If you set both Tag.N and ResourceId.N to filter tags, ResourceId.N must match all specified key-value pairs.
 * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
 *
 * @param request ListTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesResponse
 */
async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries resources by tag.
 *
 * @description *   Set ResourceId.N or Tag.N that consists of Tag.N.Key and Tag.N.Value in the request to specify the object to be queried.
 * *   Tag.N is a resource tag that consists of a key-value pair. If you set only Tag.N.Key, all tag values that are assigned to the specified key are returned. If you set only Tag.N.Value, an error message is returned.
 * *   If you set both Tag.N and ResourceId.N to filter tags, ResourceId.N must match all specified key-value pairs.
 * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
 *
 * @param request ListTagResourcesRequest
 * @return ListTagResourcesResponse
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ModifyHichinaDomainDNSRequest {
  domainName?: string(name='DomainName', description='The domain name.

This parameter is required.', example='example.com'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en', example='en'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0'),
}

model ModifyHichinaDomainDNSResponseBody = {
  newDnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='NewDnsServers', description='The DNS server names after modification.'),
  originalDnsServers?: {
    dnsServer?: [ string ](name='DnsServer')
  }(name='OriginalDnsServers', description='The DNS server names before modification.'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model ModifyHichinaDomainDNSResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyHichinaDomainDNSResponseBody(name='body'),
}

/**
 * @summary Changes the names of DNS servers bound to a domain name from DNS server names provided by a third-party service provider to DNS server names provided by Alibaba Cloud DNS.
 *
 * @description If the operation succeeds, the names of DNS servers change to those of Alibaba Cloud DNS servers (ending with hichina.com).
 * >  **Before you call this operation, make sure that your domain name has been registered with Alibaba Cloud and the DNS servers in use are not Alibaba Cloud DNS servers.
 *
 * @param request ModifyHichinaDomainDNSRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyHichinaDomainDNSResponse
 */
async function modifyHichinaDomainDNSWithOptions(request: ModifyHichinaDomainDNSRequest, runtime: Util.RuntimeOptions): ModifyHichinaDomainDNSResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyHichinaDomainDNS',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Changes the names of DNS servers bound to a domain name from DNS server names provided by a third-party service provider to DNS server names provided by Alibaba Cloud DNS.
 *
 * @description If the operation succeeds, the names of DNS servers change to those of Alibaba Cloud DNS servers (ending with hichina.com).
 * >  **Before you call this operation, make sure that your domain name has been registered with Alibaba Cloud and the DNS servers in use are not Alibaba Cloud DNS servers.
 *
 * @param request ModifyHichinaDomainDNSRequest
 * @return ModifyHichinaDomainDNSResponse
 */
async function modifyHichinaDomainDNS(request: ModifyHichinaDomainDNSRequest): ModifyHichinaDomainDNSResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHichinaDomainDNSWithOptions(request, runtime);
}

model MoveDomainResourceGroupRequest {
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  newResourceGroupId?: string(name='NewResourceGroupId', description='The ID of the new resource group.

You can view the resource group ID in the [Resource Management console](https://resourcemanager.console.aliyun.com/resource-groups?).

This parameter is required.', example='rg-aekzzk7hx3glaoq'),
  resourceId?: string(name='ResourceId', description='The domain name.

This parameter is required.', example='example.com'),
}

model MoveDomainResourceGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='C6F1D541-E7A6-447A-A2B5-9F7A20B2A8FB'),
}

model MoveDomainResourceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MoveDomainResourceGroupResponseBody(name='body'),
}

/**
 * @summary Moves a domain name to another resource group.
 *
 * @param request MoveDomainResourceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return MoveDomainResourceGroupResponse
 */
async function moveDomainResourceGroupWithOptions(request: MoveDomainResourceGroupRequest, runtime: Util.RuntimeOptions): MoveDomainResourceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.newResourceGroupId)) {
    query['NewResourceGroupId'] = request.newResourceGroupId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MoveDomainResourceGroup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Moves a domain name to another resource group.
 *
 * @param request MoveDomainResourceGroupRequest
 * @return MoveDomainResourceGroupResponse
 */
async function moveDomainResourceGroup(request: MoveDomainResourceGroupRequest): MoveDomainResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return moveDomainResourceGroupWithOptions(request, runtime);
}

model MoveGtmResourceGroupRequest {
  lang?: string(name='Lang', example='en'),
  newResourceGroupId?: string(name='NewResourceGroupId', description='This parameter is required.', example='AgIDE1MA_XXX'),
  resourceId?: string(name='ResourceId', description='This parameter is required.', example='rg-aekzzk7hx3*****'),
}

model MoveGtmResourceGroupResponseBody = {
  requestId?: string(name='RequestId', example='C6F1D541-E7A6-447A-A2B5-9F7A20B2A8FB'),
}

model MoveGtmResourceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MoveGtmResourceGroupResponseBody(name='body'),
}

/**
 * @param request MoveGtmResourceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return MoveGtmResourceGroupResponse
 */
async function moveGtmResourceGroupWithOptions(request: MoveGtmResourceGroupRequest, runtime: Util.RuntimeOptions): MoveGtmResourceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.newResourceGroupId)) {
    query['NewResourceGroupId'] = request.newResourceGroupId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MoveGtmResourceGroup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request MoveGtmResourceGroupRequest
 * @return MoveGtmResourceGroupResponse
 */
async function moveGtmResourceGroup(request: MoveGtmResourceGroupRequest): MoveGtmResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return moveGtmResourceGroupWithOptions(request, runtime);
}

model OperateBatchDomainRequest {
  domainRecordInfo?: [ 
    {
      domain?: string(name='Domain', description='The domain name.

>  You can submit 1 to 1,000 domain names. Due to the limit on the length of HTTP request headers, excessive domain names are ignored. Do not enter more than 1,000 domain names.

This parameter is required.', example='example.com'),
      line?: string(name='Line', description='The DNS request source. Default value: default.', example='default'),
      newRr?: string(name='NewRr', description='The new hostname (used only for modification operations, not for external users).', example='mail'),
      newType?: string(name='NewType', description='The new type of the DNS record (used only for modification operations, not for external users).', example='AAAA'),
      newValue?: string(name='NewValue', description='The new value of the DNS record (used only for modification operations, not for external users).', example='114.92.XX.XX'),
      priority?: int32(name='Priority', description='The priority of the mail exchanger (MX) record.

This parameter is required if the type of the DNS record is MX. Default value: 10.', example='5'),
      rr?: string(name='Rr', description='The hostname.

>  This parameter is required if you set Type to **RR_ADD** or **RR_DEL**.', example='zhaohui'),
      ttl?: int32(name='Ttl', description='The time-to-live (TTL) value of the cached DNS record. Unit: seconds. Default value: ***600***.', example='600'),
      type?: string(name='Type', description='The type of the DNS record. Valid values: A, AAAA, TXT, MX, and CNAME.

>  This parameter is required if you set Type to **RR_ADD** or **RR_DEL**.', example='MX'),
      value?: string(name='Value', description='The value of the DNS record.

>  This parameter is required if you set Type to **RR_ADD** or **RR_DEL**.', example='fd87da3c4528844d45af39200155a905'),
    }
  ](name='DomainRecordInfo', description='The DNS records. You can submit up to 1,000 DNS records.

This parameter is required.'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: zh', example='en'),
  type?: string(name='Type', description='The type of the batch operation. Valid values:

*   **DOMAIN_ADD**: adds domain names in batches.
*   **DOMAIN_DEL**: deletes domain names in batches.
*   **RR_ADD**: adds DNS records in batches.
*   **RR_DEL**: deletes DNS records in batches. This operation deletes the DNS records with the specified hostname or record value. If you do not specify the Rr and Value parameters, this operation deletes the DNS records that are added for the specified domain names.

This parameter is required.', example='RR_ADD'),
}

model OperateBatchDomainResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='75446CC1-FC9A-4595-8D96-089D73D7A63D'),
  taskId?: long(name='TaskId', description='The task ID.', example='345345'),
}

model OperateBatchDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OperateBatchDomainResponseBody(name='body'),
}

/**
 * @summary Adds or deletes domain names and Domain Name System (DNS) records in batches.
 *
 * @description Scenario: You need to execute a large number of tasks related to DNS resolution and you do not have high requirements for efficiency.
 *
 * @param request OperateBatchDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateBatchDomainResponse
 */
async function operateBatchDomainWithOptions(request: OperateBatchDomainRequest, runtime: Util.RuntimeOptions): OperateBatchDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainRecordInfo)) {
    query['DomainRecordInfo'] = request.domainRecordInfo;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateBatchDomain',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Adds or deletes domain names and Domain Name System (DNS) records in batches.
 *
 * @description Scenario: You need to execute a large number of tasks related to DNS resolution and you do not have high requirements for efficiency.
 *
 * @param request OperateBatchDomainRequest
 * @return OperateBatchDomainResponse
 */
async function operateBatchDomain(request: OperateBatchDomainRequest): OperateBatchDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateBatchDomainWithOptions(request, runtime);
}

model PausePdnsServiceRequest {
  lang?: string(name='Lang'),
  serviceType?: string(name='ServiceType'),
}

model PausePdnsServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model PausePdnsServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PausePdnsServiceResponseBody(name='body'),
}

/**
 * @summary DNS
 *
 * @param request PausePdnsServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PausePdnsServiceResponse
 */
async function pausePdnsServiceWithOptions(request: PausePdnsServiceRequest, runtime: Util.RuntimeOptions): PausePdnsServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.serviceType)) {
    query['ServiceType'] = request.serviceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PausePdnsService',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DNS
 *
 * @param request PausePdnsServiceRequest
 * @return PausePdnsServiceResponse
 */
async function pausePdnsService(request: PausePdnsServiceRequest): PausePdnsServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return pausePdnsServiceWithOptions(request, runtime);
}

model PreviewGtmRecoveryPlanRequest {
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on per page. Maximum value: **20**. Default value: **5**.', example='5'),
  recoveryPlanId?: long(name='RecoveryPlanId', description='The ID of the disaster recovery plan that you want to preview.

This parameter is required.', example='100'),
}

model PreviewGtmRecoveryPlanResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='5'),
  previews?: {
    preview?: [ 
    {
      instanceId?: string(name='InstanceId', description='The ID of the GTM instance to which the previewed disaster recovery plan belongs.', example='instance-example'),
      name?: string(name='Name', description='The name of the GTM instance to which the previewed disaster recovery plan belongs.', example='name-example'),
      switchInfos?: {
        switchInfo?: [ 
        {
          content?: string(name='Content', description='The formatted message content.'),
          strategyName?: string(name='StrategyName', description='The name of the switching policy for address pools.', example='strategy-name-example-1'),
        }
      ](name='SwitchInfo')
      }(name='SwitchInfos', description='The returned information of the switching policies for address pools.'),
      userDomainName?: string(name='UserDomainName', description='The user\\\\"s domain name or domain name list.', example='30.yyy.com'),
    }
  ](name='Preview')
  }(name='Previews', description='The returned preview information of the disaster recovery plan.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='853805EA-3D47-47D5-9A1A-A45C24313ABD'),
  totalItems?: int32(name='TotalItems', description='The total number of entries returned on all pages.', example='15'),
  totalPages?: int32(name='TotalPages', description='The total number of pages returned.', example='3'),
}

model PreviewGtmRecoveryPlanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PreviewGtmRecoveryPlanResponseBody(name='body'),
}

/**
 * @summary You can call this operation to preview a disaster recovery plan of a Global Traffic Manager (GTM) instance.
 *
 * @param request PreviewGtmRecoveryPlanRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PreviewGtmRecoveryPlanResponse
 */
async function previewGtmRecoveryPlanWithOptions(request: PreviewGtmRecoveryPlanRequest, runtime: Util.RuntimeOptions): PreviewGtmRecoveryPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.recoveryPlanId)) {
    query['RecoveryPlanId'] = request.recoveryPlanId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PreviewGtmRecoveryPlan',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary You can call this operation to preview a disaster recovery plan of a Global Traffic Manager (GTM) instance.
 *
 * @param request PreviewGtmRecoveryPlanRequest
 * @return PreviewGtmRecoveryPlanResponse
 */
async function previewGtmRecoveryPlan(request: PreviewGtmRecoveryPlanRequest): PreviewGtmRecoveryPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return previewGtmRecoveryPlanWithOptions(request, runtime);
}

model RemovePdnsAppKeyRequest {
  appKeyId?: string(name='AppKeyId'),
  lang?: string(name='Lang'),
}

model RemovePdnsAppKeyResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemovePdnsAppKeyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemovePdnsAppKeyResponseBody(name='body'),
}

/**
 * @summary DNS AppKey
 *
 * @param request RemovePdnsAppKeyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemovePdnsAppKeyResponse
 */
async function removePdnsAppKeyWithOptions(request: RemovePdnsAppKeyRequest, runtime: Util.RuntimeOptions): RemovePdnsAppKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appKeyId)) {
    query['AppKeyId'] = request.appKeyId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemovePdnsAppKey',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DNS AppKey
 *
 * @param request RemovePdnsAppKeyRequest
 * @return RemovePdnsAppKeyResponse
 */
async function removePdnsAppKey(request: RemovePdnsAppKeyRequest): RemovePdnsAppKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return removePdnsAppKeyWithOptions(request, runtime);
}

model RemovePdnsUdpIpSegmentRequest {
  ip?: string(name='Ip'),
  lang?: string(name='Lang'),
}

model RemovePdnsUdpIpSegmentResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemovePdnsUdpIpSegmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemovePdnsUdpIpSegmentResponseBody(name='body'),
}

/**
 * @summary DNS Udp Ip
 *
 * @param request RemovePdnsUdpIpSegmentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemovePdnsUdpIpSegmentResponse
 */
async function removePdnsUdpIpSegmentWithOptions(request: RemovePdnsUdpIpSegmentRequest, runtime: Util.RuntimeOptions): RemovePdnsUdpIpSegmentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemovePdnsUdpIpSegment',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DNS Udp Ip
 *
 * @param request RemovePdnsUdpIpSegmentRequest
 * @return RemovePdnsUdpIpSegmentResponse
 */
async function removePdnsUdpIpSegment(request: RemovePdnsUdpIpSegmentRequest): RemovePdnsUdpIpSegmentResponse {
  var runtime = new Util.RuntimeOptions{};
  return removePdnsUdpIpSegmentWithOptions(request, runtime);
}

model ReplaceCloudGtmAddressPoolAddressRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   **zh-CN**: Chinese
*   **en-US (default)**: English', example='en-US'),
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool for which you want to replace addresses. This ID uniquely identifies the address pool.', example='pool-89618921167339**24'),
  addresses?: [ 
    {
      addressId?: string(name='AddressId', description='The ID of the new address. This ID uniquely identifies the address.

*   If you specify this parameter, the original addresses in the address pool will be deleted and replaced with new addresses.
*   If you do not specify this parameter, all addresses in the address pool will be deleted and the address pool will be left empty.', example='addr-89636516932803**44'),
      requestSource?: [ string ](name='RequestSource', description='The DNS request sources.'),
      serialNumber?: int32(name='SerialNumber', description='The sequence number that specifies the priority for returning the new address. A smaller sequence number specifies a higher priority. This setting takes effect for new addresses.', example='1'),
      weightValue?: int32(name='WeightValue', description='The weight value of the new address. You can set a different weight value for each address. This way, addresses are returned based on the weight values for Domain Name System (DNS) requests. A weight value must be an integer that ranges from 1 to 100. This setting takes effect for new addresses.', example='1'),
    }
  ](name='Addresses', description='The addresses.'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
}

model ReplaceCloudGtmAddressPoolAddressShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   **zh-CN**: Chinese
*   **en-US (default)**: English', example='en-US'),
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool for which you want to replace addresses. This ID uniquely identifies the address pool.', example='pool-89618921167339**24'),
  addressesShrink?: string(name='Addresses', description='The addresses.'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
}

model ReplaceCloudGtmAddressPoolAddressResponseBody = {
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89618921167339**24'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
  success?: boolean(name='Success', description='Indicates whether the operation was successful:
- true: Successful. - false: Failed.', example='true'),
}

model ReplaceCloudGtmAddressPoolAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReplaceCloudGtmAddressPoolAddressResponseBody(name='body'),
}

/**
 * @summary Replaces the addresses referenced by an address pool.
 *
 * @param tmpReq ReplaceCloudGtmAddressPoolAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReplaceCloudGtmAddressPoolAddressResponse
 */
async function replaceCloudGtmAddressPoolAddressWithOptions(tmpReq: ReplaceCloudGtmAddressPoolAddressRequest, runtime: Util.RuntimeOptions): ReplaceCloudGtmAddressPoolAddressResponse {
  Util.validateModel(tmpReq);
  var request = new ReplaceCloudGtmAddressPoolAddressShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.addresses)) {
    request.addressesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.addresses, 'Addresses', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.addressPoolId)) {
    query['AddressPoolId'] = request.addressPoolId;
  }
  if (!Util.isUnset(request.addressesShrink)) {
    query['Addresses'] = request.addressesShrink;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReplaceCloudGtmAddressPoolAddress',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Replaces the addresses referenced by an address pool.
 *
 * @param request ReplaceCloudGtmAddressPoolAddressRequest
 * @return ReplaceCloudGtmAddressPoolAddressResponse
 */
async function replaceCloudGtmAddressPoolAddress(request: ReplaceCloudGtmAddressPoolAddressRequest): ReplaceCloudGtmAddressPoolAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return replaceCloudGtmAddressPoolAddressWithOptions(request, runtime);
}

model ReplaceCloudGtmInstanceConfigAddressPoolRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  addressPools?: [ 
    {
      addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.

*   If you specify this parameter, the address pools that are associated with the desired instance are removed and the instance is associated with new address pools.
*   If this parameter is left empty, the address pools that are associated with the desired instance are removed and no address pool is associated with the instance.', example='pool-89564542105737**12'),
      requestSource?: [ string ](name='RequestSource', description='The DNS request sources.'),
      serialNumber?: int32(name='SerialNumber', description='The sequence number of the new address pool. The address pool with the smallest sequence number is preferentially returned for DNS requests from any source. The sequence number specifies the priority for returning the address pool. A smaller sequence number specifies a higher priority.', example='1'),
      weightValue?: int32(name='WeightValue', description='The weight value of the new address pool. You can set a different weight value for each address pool. This way, address pools are returned based on the weight values for Domain Name System (DNS) requests. A weight value must be an integer that ranges from 1 to 100.', example='1'),
    }
  ](name='AddressPools', description='The address pools.'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.

You can call the [ListCloudGtmInstanceConfigs](~~ListCloudGtmInstanceConfigs~~) operation to query the configuration ID of the access domain name.', example='Config-000**11'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance for which you want to change address pools.', example='gtm-cn-wwo3a3hbz**'),
}

model ReplaceCloudGtmInstanceConfigAddressPoolShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  addressPoolsShrink?: string(name='AddressPools', description='The address pools.'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.

You can call the [ListCloudGtmInstanceConfigs](~~ListCloudGtmInstanceConfigs~~) operation to query the configuration ID of the access domain name.', example='Config-000**11'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance for which you want to change address pools.', example='gtm-cn-wwo3a3hbz**'),
}

model ReplaceCloudGtmInstanceConfigAddressPoolResponseBody = {
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  success?: boolean(name='Success', description='Indicates whether the operation was successful, with values: 
- true: Success. 
- false: Failure.', example='true'),
}

model ReplaceCloudGtmInstanceConfigAddressPoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReplaceCloudGtmInstanceConfigAddressPoolResponseBody(name='body'),
}

/**
 * @summary Replaces address pools that are associated with a Global Traffic Manager (GTM) 3.0 instance with new address pools.
 *
 * @param tmpReq ReplaceCloudGtmInstanceConfigAddressPoolRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReplaceCloudGtmInstanceConfigAddressPoolResponse
 */
async function replaceCloudGtmInstanceConfigAddressPoolWithOptions(tmpReq: ReplaceCloudGtmInstanceConfigAddressPoolRequest, runtime: Util.RuntimeOptions): ReplaceCloudGtmInstanceConfigAddressPoolResponse {
  Util.validateModel(tmpReq);
  var request = new ReplaceCloudGtmInstanceConfigAddressPoolShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.addressPools)) {
    request.addressPoolsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.addressPools, 'AddressPools', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.addressPoolsShrink)) {
    query['AddressPools'] = request.addressPoolsShrink;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReplaceCloudGtmInstanceConfigAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Replaces address pools that are associated with a Global Traffic Manager (GTM) 3.0 instance with new address pools.
 *
 * @param request ReplaceCloudGtmInstanceConfigAddressPoolRequest
 * @return ReplaceCloudGtmInstanceConfigAddressPoolResponse
 */
async function replaceCloudGtmInstanceConfigAddressPool(request: ReplaceCloudGtmInstanceConfigAddressPoolRequest): ReplaceCloudGtmInstanceConfigAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return replaceCloudGtmInstanceConfigAddressPoolWithOptions(request, runtime);
}

model ResumePdnsServiceRequest {
  lang?: string(name='Lang'),
  serviceType?: string(name='ServiceType'),
}

model ResumePdnsServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResumePdnsServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResumePdnsServiceResponseBody(name='body'),
}

/**
 * @summary DNS
 *
 * @param request ResumePdnsServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResumePdnsServiceResponse
 */
async function resumePdnsServiceWithOptions(request: ResumePdnsServiceRequest, runtime: Util.RuntimeOptions): ResumePdnsServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.serviceType)) {
    query['ServiceType'] = request.serviceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResumePdnsService',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DNS
 *
 * @param request ResumePdnsServiceRequest
 * @return ResumePdnsServiceResponse
 */
async function resumePdnsService(request: ResumePdnsServiceRequest): ResumePdnsServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return resumePdnsServiceWithOptions(request, runtime);
}

model RetrieveDomainRequest {
  domainName?: string(name='DomainName', description='The domain name.

This parameter is required.', example='example.com'),
  lang?: string(name='Lang', description='The language.', example='en'),
}

model RetrieveDomainResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9CC0D642-49D4-48DE-A1A5-9F218652E4A7'),
}

model RetrieveDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RetrieveDomainResponseBody(name='body'),
}

/**
 * @summary Retrieves a domain name.
 *
 * @description To retrieve a domain name, you must verify a text (TXT) record. Therefore, before you call this API operation to retrieve a domain name, call the [GetTxtRecordForVerify](https://www.alibabacloud.com/help/en/alibaba-cloud-dns/latest/generating-a-txt-record) operation to generate a TXT record.
 *
 * @param request RetrieveDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RetrieveDomainResponse
 */
async function retrieveDomainWithOptions(request: RetrieveDomainRequest, runtime: Util.RuntimeOptions): RetrieveDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RetrieveDomain',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Retrieves a domain name.
 *
 * @description To retrieve a domain name, you must verify a text (TXT) record. Therefore, before you call this API operation to retrieve a domain name, call the [GetTxtRecordForVerify](https://www.alibabacloud.com/help/en/alibaba-cloud-dns/latest/generating-a-txt-record) operation to generate a TXT record.
 *
 * @param request RetrieveDomainRequest
 * @return RetrieveDomainResponse
 */
async function retrieveDomain(request: RetrieveDomainRequest): RetrieveDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return retrieveDomainWithOptions(request, runtime);
}

model RollbackGtmRecoveryPlanRequest {
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en.', example='en'),
  recoveryPlanId?: long(name='RecoveryPlanId', description='The ID of the disaster recovery plan.

This parameter is required.', example='100'),
}

model RollbackGtmRecoveryPlanResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='853805EA-3D47-47D5-9A1A-A45C24313ABD'),
}

model RollbackGtmRecoveryPlanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RollbackGtmRecoveryPlanResponseBody(name='body'),
}

/**
 * @summary Rolls back a disaster recovery plan.
 *
 * @param request RollbackGtmRecoveryPlanRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RollbackGtmRecoveryPlanResponse
 */
async function rollbackGtmRecoveryPlanWithOptions(request: RollbackGtmRecoveryPlanRequest, runtime: Util.RuntimeOptions): RollbackGtmRecoveryPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recoveryPlanId)) {
    query['RecoveryPlanId'] = request.recoveryPlanId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RollbackGtmRecoveryPlan',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Rolls back a disaster recovery plan.
 *
 * @param request RollbackGtmRecoveryPlanRequest
 * @return RollbackGtmRecoveryPlanResponse
 */
async function rollbackGtmRecoveryPlan(request: RollbackGtmRecoveryPlanRequest): RollbackGtmRecoveryPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return rollbackGtmRecoveryPlanWithOptions(request, runtime);
}

model SearchCloudGtmAddressPoolsRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  addressPoolName?: string(name='AddressPoolName', description='Address pool name, supports fuzzy search for the entered address pool name.', example='AddressPool-1'),
  addressPoolType?: string(name='AddressPoolType', description='Address pool type, supports precise query for address pool types:
- IPv4
- IPv6
- domain', example='IPv4'),
  availableStatus?: string(name='AvailableStatus', description='Address pool availability status, supporting precise queries for address pool availability:
- available: Available
- unavailable: Unavailable', example='available'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  enableStatus?: string(name='EnableStatus', description='Address pool enable status, supports precise query of address pool enable status:
- enable: Enabled status
- disable: Disabled status', example='enable'),
  healthStatus?: string(name='HealthStatus', description='The health state of the address pool. You can enter a health state for exact search. Valid values:

ok: The health state of the address pool is normal and all addresses that are referenced by the address pool are available.

ok_alert: The health state of the address pool is warning and some of the addresses that are referenced by the address pool are unavailable. However, the address pool is deemed normal. In this case, only the available addresses are returned for Domain Name System (DNS) requests.

exceptional: The health state of the address pool is abnormal and some or all of the addresses that are referenced by the address pool are unavailable. In this case, the address pool is deemed abnormal.', example='ok'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from 1, default is 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.', example='20'),
  remark?: string(name='Remark', description='Address pool remarks, supporting fuzzy search for the input remarks.', example='test'),
}

model SearchCloudGtmAddressPoolsResponseBody = {
  addressPools?: {
    addressPool?: [ 
    {
      addressLbStrategy?: string(name='AddressLbStrategy', description='Load balancing policy among addresses in the address pool:
- round_robin: Round-robin, for any source of DNS resolution requests, returns all addresses and rotates the order of all addresses each time.
- sequence: Sequential, for any source of DNS resolution requests, returns the address with the smaller sequence number (the sequence number indicates the priority of the address return, the smaller the higher the priority). If the address with the smaller sequence number is unavailable, return the next address with a smaller sequence number.
- weight: Weighted, supports setting different weight values for each address to realize returning addresses according to the weight ratio for resolution queries.
- source_nearest: Source-nearest, i.e., intelligent resolution function, where GTM can return different addresses based on the source of different DNS resolution requests, achieving the effect of users accessing nearby.', example='round_robin'),
      addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-895280232254422016'),
      addressPoolName?: string(name='AddressPoolName', description='Address pool name.', example='AddressPool-1'),
      addressPoolType?: string(name='AddressPoolType', description='Address pool type:
- IPv4
- IPv6
- domain', example='IPv4'),
      addresses?: {
        address?: [ 
        {
          address?: string(name='Address', description='IP address or domain name.', example='223.5.XX.XX'),
          addressId?: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.', example='addr-895182181143688192'),
          attributeInfo?: string(name='AttributeInfo', description='Address ownership information, not supported in the current version.', example='Not supported in the current version.'),
          availableMode?: string(name='AvailableMode', description='The failover method that is used if the address fails health checks. Valid values:

*   auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
*   manual: the manual mode. If an address is in the unavailable state, the address is not returned for DNS requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.', example='auto'),
          availableStatus?: string(name='AvailableStatus', description='Address availability status:
- available: Address is available
- unavailable: Address is unavailable', example='available'),
          createTime?: string(name='CreateTime', description='Address creation time.', example='2024-03-15T01:46Z'),
          createTimestamp?: long(name='CreateTimestamp', description='Address creation time (timestamp).', example='1527690629357'),
          enableStatus?: string(name='EnableStatus', description='Address enable status, indicating whether the address is currently available:
- enable: Enabled status 
- disable: Disabled status', example='enable'),
          healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address. Valid values:

*   any_ok: The health check results of at least one health check template are normal.
*   p30_ok: The health check results of at least 30% of health check templates are normal.
*   p50_ok: The health check results of at least 50% of health check templates are normal.
*   p70_ok: The health check results of at least 70% of health check templates are normal.
*   all_ok: The health check results of all health check templates are normal.', example='any_ok'),
          healthStatus?: string(name='HealthStatus', description='The health check state of the address. Valid values:

*   ok: The address passes all health checks of the referenced health check templates.
*   ok_alert: The address fails some health checks of the referenced health check templates but the address is deemed normal.
*   ok_no_monitor: The address does not reference a health check template and is normal.
*   exceptional: The address fails some or all health checks of the referenced health check templates and the address is deemed abnormal.', example='ok'),
          healthTasks?: {
            healthTask?: [ 
            {
              port?: int32(name='Port', description='The target service port for health checks. When the Ping protocol is selected for health checks, configuration of the service port is not supported.', example='80'),
              templateId?: string(name='TemplateId', description='The ID of the health check template associated with the address.', example='mtp-89518052425100**80'),
              templateName?: string(name='TemplateName', description='Health check template name.', example='IPv4-Ping'),
            }
          ](name='HealthTask')
          }(name='HealthTasks', description='The health check tasks.'),
          manualAvailableStatus?: string(name='ManualAvailableStatus', description='The availability state of the address when AvailableMode is set to manual. Valid values:

*   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
*   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.', example='available'),
          name?: string(name='Name', description='Address name.', example='Address-1'),
          remark?: string(name='Remark', description='Remarks.', example='test'),
          requestSource?: string(name='RequestSource', description='Request source, referring to the source of the request. GTM schedules based on the exit IP of the LocalDNS used by the terminal. If the LocalDNS supports ECS (edns-client-subnet), intelligent scheduling can also be performed based on the IP of the visiting terminal.', example='default'),
          serialNumber?: int32(name='SerialNumber', description='Sequence number, indicating the priority of address return, where smaller numbers have higher priority.', example='1'),
          type?: string(name='Type', description='Address type:
- IPv4: ipv4 address - IPv6: ipv6 address - domain: domain name', example='IPv4'),
          updateTime?: string(name='UpdateTime', description='The last time the address was modified.', example='2024-03-15T01:46Z'),
          updateTimestamp?: long(name='UpdateTimestamp', description='The last modification time of the address (timestamp).', example='1527690629357'),
          weightValue?: int32(name='WeightValue', description='Weight value (an integer between 1 and 100), allowing different weight values to be set for each address, enabling resolution queries to return addresses according to the weighted ratio.', example='1'),
        }
      ](name='Address')
      }(name='Addresses', description='The IP addresses or domain names.'),
      availableStatus?: string(name='AvailableStatus', description='Address pool availability status:
- available: Available
- unavailable: Unavailable', example='available'),
      createTime?: string(name='CreateTime', description='Address pool creation time.', example='2024-03-15T01:46Z'),
      createTimestamp?: long(name='CreateTimestamp', description='Address pool creation time (timestamp).', example='1527690629357'),
      enableStatus?: string(name='EnableStatus', description='Address pool status:
- enable: Enabled status
- disable: Disabled status', example='enable'),
      healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address pool. Valid values:

*   any_ok: At least one address in the address pool is available.
*   p30_ok: At least 30% of the addresses in the address pool are available.
*   p50_ok: At least 50% of the addresses in the address pool are available.
*   p70_ok: At least 70% of the addresses in the address pool are available.
*   all_ok: All addresses in the address pool are available.', example='any_ok'),
      healthStatus?: string(name='HealthStatus', description='The health state of the address pool. Valid values:

*   ok: The health state of the address pool is normal and all addresses that are referenced by the address pool are available.
*   ok_alert: The health state of the address pool is warning and some of the addresses that are referenced by the address pool are unavailable. However, the address pool is deemed normal. In this case, only the available addresses are returned for DNS requests.
*   exceptional: The health state of the address pool is abnormal and some or all of the addresses that are referenced by the address pool are unavailable. In this case, the address pool is deemed abnormal.', example='ok'),
      remark?: string(name='Remark', description='Address remarks.', example='test'),
      sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address with the smallest sequence number is recovered. This parameter is returned only when the policy for load balancing between addresses is sequence. Valid values:

*   preemptive: The address with the smallest sequence number is preferentially used if this address is recovered.
*   non_preemptive: The current address is still used even if the address with the smallest sequence number is recovered.', example='preemptive'),
      updateTime?: string(name='UpdateTime', description='Last modification time of the address pool.', example='024-03-15T01:46Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='Last modification time of the address pool (timestamp).', example='1527690629357'),
    }
  ](name='AddressPool')
  }(name='AddressPools', description='The address pools.'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from 1, default is 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.', example='20'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalItems?: int32(name='TotalItems', description='Total number of address pools matching the query conditions.', example='11'),
  totalPages?: int32(name='TotalPages', description='Total number of pages.', example='1'),
}

model SearchCloudGtmAddressPoolsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchCloudGtmAddressPoolsResponseBody(name='body'),
}

/**
 * @summary Queries a list of address pools.
 *
 * @param request SearchCloudGtmAddressPoolsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchCloudGtmAddressPoolsResponse
 */
async function searchCloudGtmAddressPoolsWithOptions(request: SearchCloudGtmAddressPoolsRequest, runtime: Util.RuntimeOptions): SearchCloudGtmAddressPoolsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.addressPoolName)) {
    query['AddressPoolName'] = request.addressPoolName;
  }
  if (!Util.isUnset(request.addressPoolType)) {
    query['AddressPoolType'] = request.addressPoolType;
  }
  if (!Util.isUnset(request.availableStatus)) {
    query['AvailableStatus'] = request.availableStatus;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.enableStatus)) {
    query['EnableStatus'] = request.enableStatus;
  }
  if (!Util.isUnset(request.healthStatus)) {
    query['HealthStatus'] = request.healthStatus;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchCloudGtmAddressPools',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of address pools.
 *
 * @param request SearchCloudGtmAddressPoolsRequest
 * @return SearchCloudGtmAddressPoolsResponse
 */
async function searchCloudGtmAddressPools(request: SearchCloudGtmAddressPoolsRequest): SearchCloudGtmAddressPoolsResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchCloudGtmAddressPoolsWithOptions(request, runtime);
}

model SearchCloudGtmAddressesRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  address?: string(name='Address', description='Query by service address with precise conditions, supporting IP addresses or domain names.', example='223.5.XX.XX'),
  addressId?: string(name='AddressId', description='The address ID. This ID uniquely identifies the address.', example='addr-89518218114368**92'),
  availableStatus?: string(name='AvailableStatus', description='Search by address availability status with precise conditions:
- available
- unavailable', example='available'),
  enableStatus?: string(name='EnableStatus', description='Query by exact address enable status:
- enable: enabled status
- disable: disabled status', example='enable'),
  healthStatus?: string(name='HealthStatus', description='The health state of the addresses that you want to query. Valid values:

*   ok: The addresses pass all health checks of the referenced health check templates.
*   ok_alert: The addresses fail some health checks of the referenced health check templates, but the addresses are deemed available.
*   ok_no_monitor: The addresses do not reference any health check template.
*   exceptional: The addresses fail some or all health checks of the referenced health check templates, and the addresses are deemed unavailable.', example='ok'),
  monitorTemplateName?: string(name='MonitorTemplateName', description='Health check template name.', example='Ping-IPv4'),
  nameSearchCondition?: string(name='NameSearchCondition', description='The logical condition for querying addresses by name. This parameter is required if you want to query addresses by name. Valid values:

*   and: displays the results that match all search conditions.
*   or: displays the results that match some or all search conditions.', example='or'),
  names?: [ string ](name='Names', description='Address name, usually for users to distinguish between different addresses.'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from 1, default is 1.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.

This parameter is required.', example='20'),
  remarkSearchCondition?: string(name='RemarkSearchCondition', description='The logical condition for querying addresses by additional description. This parameter is required if you want to query addresses by additional description. Valid values:

and: displays the results that match all search conditions.

or: displays the results that match some or all search conditions.', example='or'),
  remarks?: [ string ](name='Remarks', description='Remarks for the address.'),
  type?: string(name='Type', description='Search precisely by address type conditions:
- IPv4
- IPv6
- domain', example='IPv4'),
}

model SearchCloudGtmAddressesResponseBody = {
  addresses?: {
    address?: [ 
    {
      address?: string(name='Address', description='IP address or domain name.', example='223.5.XX.XX'),
      addressId?: string(name='AddressId', description='ID of the address, unique identifier for the address.', example='addr-89518218114368**92'),
      attributeInfo?: string(name='AttributeInfo', description='Address ownership information, not supported in the current version.', example='The parameter should be none.'),
      availableMode?: string(name='AvailableMode', description='The failover method that is used if the address fails health checks. Valid values:

*   auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
*   manual: the manual mode. If an address is in the unavailable state, the address is not returned for Domain Name System (DNS) requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.', example='auto'),
      availableStatus?: string(name='AvailableStatus', description='The availability state of the address when AvailableMode is set to manual. Valid values:

*   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
*   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.', example='available'),
      createTime?: string(name='CreateTime', description='Creation time of the address.', example='2024-03-23T13:09Z'),
      createTimestamp?: long(name='CreateTimestamp', description='Creation time of the address (timestamp).', example='1527690629357'),
      enableStatus?: string(name='EnableStatus', description='Current activation status of the address:
- enable: Enabled status
- disable: Disabled status', example='enable'),
      healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address. Valid values:

*   any_ok: The health check results of at least one health check template are normal.
*   p30_ok: The health check results of at least 30% of health check templates are normal.
*   p50_ok: The health check results of at least 50% of health check templates are normal.
*   p70_ok: The health check results of at least 70% of health check templates are normal.
*   all_ok: The health check results of all health check templates are normal.', example='p50_ok'),
      healthStatus?: string(name='HealthStatus', description='The health check state of the address. Valid values:

*   ok: The address passes all health checks of the referenced health check templates.
*   ok_alert: The address fails some health checks of the referenced health check templates, but the address is deemed available.
*   ok_no_monitor: The address does not reference any health check template.
*   exceptional: The address fails some or all health checks of the referenced health check templates, and the address is deemed unavailable.', example='ok'),
      healthTasks?: {
        healthTask?: [ 
        {
          monitorStatus?: string(name='MonitorStatus', description='The state of the health check task. Valid values:

*   ok: The task is normal.
*   alert: The task has an alert.
*   no_data: No data is available. In most cases, the health check task is newly created and no data is collected.', example='ok'),
          port?: int32(name='Port', description='The target service port for health check probes. When the health check protocol is set to Ping, configuration of the service port is not supported.', example='80'),
          templateId?: string(name='TemplateId', description='The ID of the health check template associated with the address.', example='mtp-895180524251002880'),
          templateName?: string(name='TemplateName', description='Health check template name.', example='IPv4-Ping'),
        }
      ](name='HealthTask')
      }(name='HealthTasks', description='The health check tasks.'),
      manualAvailableStatus?: string(name='ManualAvailableStatus', description='The availability state of the address when AvailableMode is set to manual. Valid values:

*   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
*   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.', example='available'),
      name?: string(name='Name', description='Address name.', example='Address-1'),
      remark?: string(name='Remark', description='Remarks.', example='test'),
      type?: string(name='Type', description='Address type:
- IPv4: ipv4 address - IPv6: ipv6 address - domain: domain name', example='IPv4'),
      updateTime?: string(name='UpdateTime', description='The last modification time of the address.', example='2024-03-29T13:20Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The last modification time of the address (timestamp).', example='1527690629357'),
    }
  ](name='Address')
  }(name='Addresses', description='The addresses.'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from **1**, default is **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of **100** and a default of **20**.', example='20'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  totalItems?: int32(name='TotalItems', description='Total number of address entries that meet the query conditions.', example='15'),
  totalPages?: int32(name='TotalPages', description='Total number of pages.', example='1'),
}

model SearchCloudGtmAddressesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchCloudGtmAddressesResponseBody(name='body'),
}

/**
 * @summary Queries a list of addresses based on address names, descriptions, health check templates referenced by the addresses, or address IDs.
 *
 * @param request SearchCloudGtmAddressesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchCloudGtmAddressesResponse
 */
async function searchCloudGtmAddressesWithOptions(request: SearchCloudGtmAddressesRequest, runtime: Util.RuntimeOptions): SearchCloudGtmAddressesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.addressId)) {
    query['AddressId'] = request.addressId;
  }
  if (!Util.isUnset(request.availableStatus)) {
    query['AvailableStatus'] = request.availableStatus;
  }
  if (!Util.isUnset(request.enableStatus)) {
    query['EnableStatus'] = request.enableStatus;
  }
  if (!Util.isUnset(request.healthStatus)) {
    query['HealthStatus'] = request.healthStatus;
  }
  if (!Util.isUnset(request.monitorTemplateName)) {
    query['MonitorTemplateName'] = request.monitorTemplateName;
  }
  if (!Util.isUnset(request.nameSearchCondition)) {
    query['NameSearchCondition'] = request.nameSearchCondition;
  }
  if (!Util.isUnset(request.names)) {
    query['Names'] = request.names;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remarkSearchCondition)) {
    query['RemarkSearchCondition'] = request.remarkSearchCondition;
  }
  if (!Util.isUnset(request.remarks)) {
    query['Remarks'] = request.remarks;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchCloudGtmAddresses',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of addresses based on address names, descriptions, health check templates referenced by the addresses, or address IDs.
 *
 * @param request SearchCloudGtmAddressesRequest
 * @return SearchCloudGtmAddressesResponse
 */
async function searchCloudGtmAddresses(request: SearchCloudGtmAddressesRequest): SearchCloudGtmAddressesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchCloudGtmAddressesWithOptions(request, runtime);
}

model SearchCloudGtmInstanceConfigsRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='zh-CN'),
  availableStatus?: string(name='AvailableStatus', description='The availability state of the access domain name. Valid values:

*   available: If the access domain name is **enabled** and the health state is **normal**, the access domain name is deemed **available**.
*   unavailable: If the access domain name is **disabled** or the health state is **abnormal**, the access domain name is deemed **unavailable**.', example='available'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  enableStatus?: string(name='EnableStatus', description='The enabling state of the access domain name. Valid values:

*   enable: The access domain name is enabled and the intelligent scheduling policy of the corresponding GTM instance takes effect.
*   disable: The access domain name is disabled and the intelligent scheduling policy of the corresponding GTM instance does not take effect.', example='enable'),
  healthStatus?: string(name='HealthStatus', description='The health state of the access domain name. Valid values:

*   ok: The health state of the access domain name is normal and all address pools that are referenced by the access domain name are available.
*   ok_alert: The health state of the access domain name is warning and some of the address pools that are referenced by the access domain name are unavailable. In this case, only the available address pools are returned for Domain Name System (DNS) requests.
*   exceptional: The health state of the access domain name is abnormal and all address pools that are referenced by the access domain name are unavailable. In this case, addresses in the non-empty address pool with the smallest sequence number are preferentially used for fallback resolution. This returns DNS results for clients as much as possible.', example='ok'),
  instanceId?: string(name='InstanceId', description='The ID of the Global Traffic Manager (GTM) 3.0 instance.', example='gtm-cn-wwo3a3hbz**'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from 1, default is 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of **100**, and a default of **20**.', example='20'),
  remark?: string(name='Remark', description='Remarks for the domain instance.', example='test'),
  scheduleDomainName?: string(name='ScheduleDomainName', description='The access domain name. The value of this parameter is composed of the value of ScheduleHostname and the value of ScheduleZoneName.', example='www.example.com'),
  scheduleZoneName?: string(name='ScheduleZoneName', description='The zone such as example.com or subzone such as a.example.com of the access domain name. In most cases, the zone or subzone is hosted by the Public Authoritative DNS module of Alibaba Cloud DNS. This zone belongs to the account to which the GTM instance belongs.', example='example.com'),
}

model SearchCloudGtmInstanceConfigsResponseBody = {
  instanceConfigs?: {
    instanceConfig?: [ 
    {
      addressPoolLbStrategy?: string(name='AddressPoolLbStrategy', description='The policy for load balancing between address pools. Valid values:

*   round_robin: All address pools are returned for DNS requests from any source. All address pools are sorted in round-robin mode each time they are returned.
*   sequence: The address pool with the smallest sequence number is preferentially returned for DNS requests from any source. The sequence number indicates the priority for returning the address pool. A smaller sequence number indicates a higher priority. If the address pool with the smallest sequence number is unavailable, the address pool with the second smallest sequence number is returned.
*   weight: You can set a different weight value for each address pool. This way, address pools are returned based on the weight values.
*   source_nearest: Different address pools are returned based on the sources of DNS requests. This way, users can access nearby address pools.', example='round_robin'),
      addressPools?: {
        addressPool?: [ 
        {
          addressLbStrategy?: string(name='AddressLbStrategy', description='Load balancing policy among addresses in the address pool:
- round_robin: Round-robin, where for any source of DNS resolution requests, all addresses are returned, with a rotation of the order for every request.
- sequence: Sequential, where for any source of DNS resolution requests, the address with the lower sequence number (indicating a higher priority, the smaller the number, the higher the priority) is returned. If the address with the lower sequence number is unavailable, the next address with a lower sequence number is returned.
- weight: Weighted, supporting the setting of different weight values for each address to realize returning addresses according to the ratio of weights in DNS query resolutions.
- source_nearest: Source-nearest, referring to the intelligent resolution feature, where GTM can return different addresses based on the source of different DNS resolution requests, achieving the effect of users accessing the nearest server.', example='round_robin'),
          addressPoolId?: string(name='AddressPoolId', description='Address pool ID, uniquely identifying the address pool.', example='pool-89564504435014**60'),
          addressPoolName?: string(name='AddressPoolName', description='Address pool name.', example='AddressPool-1'),
          addressPoolType?: string(name='AddressPoolType', description='Address pool type:
- IPv4
- IPv6
- domain', example='IPv4'),
          availableStatus?: string(name='AvailableStatus', description='Address pool availability status:
- available: Available
- unavailable: Unavailable', example='available'),
          createTime?: string(name='CreateTime', description='Address pool creation time.', example='2024-03-15T01:46Z'),
          createTimestamp?: long(name='CreateTimestamp', description='Address pool creation time (timestamp).', example='1527690629357'),
          enableStatus?: string(name='EnableStatus', description='Address pool status:
- enable: Enabled status
- disable: Disabled status', example='enable'),
          healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address pool. Valid values:

*   any_ok: At least one address in the address pool is available.
*   p30_ok: At least 30% of the addresses in the address pool are available.
*   p50_ok: At least 50% of the addresses in the address pool are available.
*   p70_ok: At least 70% of the addresses in the address pool are available.
*   all_ok: All addresses in the address pool are available.', example='any_ok'),
          healthStatus?: string(name='HealthStatus', description='The health state of the address pool. Valid values:

*   ok: The health state of the address pool is normal and all addresses that are referenced by the address pool are available.
*   ok_alert: The health state of the address pool is warning and some of the addresses that are referenced by the address pool are unavailable. However, the address pool is deemed normal. In this case, only the available addresses are returned for DNS requests.
*   exceptional: The health state of the address pool is abnormal and some or all of the addresses that are referenced by the address pool are unavailable. In this case, the address pool is deemed abnormal.', example='ok'),
          requestSource?: {
            requestSource?: [ string ](name='RequestSource')
          }(name='RequestSource', description='Parse the request source list.'),
          seqNonPreemptiveSchedule?: boolean(name='SeqNonPreemptiveSchedule', description='Indicates whether it is a sequential (non-preemptive) scheduling object for hybrid cloud management scenarios: 
- true: yes 
- false: no', example='false'),
          sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address with the smallest sequence number is recovered. This parameter is required only when the policy for load balancing between addresses is sequence. Valid values:

*   preemptive: The address with the smallest sequence number is preferentially used if this address is recovered.
*   non_preemptive: The current address is still used even if the address with the smallest sequence number is recovered.', example='preemptive'),
          serialNumber?: int32(name='SerialNumber', description='Sequence number. For any parsing request, the address pool with the smaller sequence number (indicating the priority of the address pool returned, with smaller numbers having higher priority) will be returned.', example='1'),
          updateTime?: string(name='UpdateTime', description='Last modification time of the address pool.', example='2024-03-15T01:46Z'),
          updateTimestamp?: long(name='UpdateTimestamp', description='Update time (timestamp).', example='1527690629357'),
          weightValue?: int32(name='WeightValue', description='Weight value (an integer between 1 and 100, inclusive), allowing different weight values to be set for each address pool, implementing the return of address pools according to weight ratios in resolution queries.', example='1'),
        }
      ](name='AddressPool')
      }(name='AddressPools', description='The address pools.'),
      availableStatus?: string(name='AvailableStatus', description='The availability state of the access domain name. Valid values:

*   available: If the access domain name is **enabled** and the health state is **normal**, the access domain name is deemed **available**.
*   unavailable: If the access domain name is **disabled** or the health state is **abnormal**, the access domain name is deemed **unavailable**.', example='available'),
      commodityCode?: string(name='CommodityCode', description='The commodity code. Valid values:

*   dns_gtm_public_cn: the commodity code on the China site (aliyun.com)
*   dns_gtm_public_intl: the commodity code on the international site (alibabacloud.com)', example='dns_gtm_public_cn'),
      configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.', example='Config-000**11'),
      createTime?: string(name='CreateTime', description='Domain instance creation time.', example='2024-03-15T01:46Z'),
      createTimestamp?: long(name='CreateTimestamp', description='Domain instance creation time (timestamp).', example='1527690629357'),
      enableStatus?: string(name='EnableStatus', description='The enabling state of the access domain name. Valid values:

*   enable: The access domain name is enabled and the intelligent scheduling policy of the corresponding GTM instance takes effect.
*   disable: The access domain name is disabled and the intelligent scheduling policy of the corresponding GTM instance does not take effect.', example='enable'),
      healthStatus?: string(name='HealthStatus', description='The health state of the access domain name. Valid values:

*   ok: The health state of the access domain name is normal and all address pools that are referenced by the access domain name are available.
*   ok_alert: The health state of the access domain name is warning and some of the address pools that are referenced by the access domain name are unavailable. In this case, only the available address pools are returned for DNS requests.
*   exceptional: The health state of the access domain name is abnormal and all address pools that are referenced by the access domain name are unavailable. In this case, addresses in the non-empty address pool with the smallest sequence number are preferentially used for fallback resolution. This returns DNS results for clients as much as possible.', example='ok'),
      instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance.', example='gtm-cn-x0r38e0**03'),
      remark?: string(name='Remark', description='Remarks for the domain instance.', example='test'),
      scheduleDomainName?: string(name='ScheduleDomainName', description='The access domain name. The value of this parameter is composed of the value of ScheduleHostname and the value of ScheduleZoneName.', example='www.example.com'),
      scheduleHostname?: string(name='ScheduleHostname', description='Host record of the domain accessed by GTM.', example='www'),
      scheduleRrType?: string(name='ScheduleRrType', description='DNS record types for the scheduling domain:
- A: IPv4 address
- AAAA: IPv6 address
- CNAME: Domain name', example='A'),
      scheduleZoneMode?: string(name='ScheduleZoneMode', description='The allocation mode of the access domain name. Valid values:

*   custom: custom allocation. You must specify a custom hostname and associate the hostname with a zone that is hosted by the Public Authoritative DNS module within the account to which the GTM instance belongs to generate an access domain name.
*   sys_assign: system allocation. This mode is not supported. Do not set ScheduleZoneMode to sys_assign.', example='custom'),
      scheduleZoneName?: string(name='ScheduleZoneName', description='The zone such as example.com or subzone such as a.example.com of the access domain name. In most cases, the zone or subzone is hosted by the Public Authoritative DNS module of Alibaba Cloud DNS. This zone belongs to the account to which the GTM instance belongs.', example='example.com'),
      sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address pool with the smallest sequence number is recovered. This parameter is returned when AddressPoolLbStrategy is set to sequence. Valid values:

*   preemptive: The address pool with the smallest sequence number is preferentially used if this address pool is recovered.
*   non_preemptive: The current address pool is still used even if the address pool with the smallest sequence number is recovered.', example='preemptive'),
      ttl?: int32(name='Ttl', description='Global TTL (in seconds), the TTL value for resolving the access domain name to the address pool, which affects the caching time of DNS records in the operator\\\\"s LocalDNS. Supports custom TTL values.', example='60'),
      updateTime?: string(name='UpdateTime', description='The last modification time of the domain instance.', example='2024-03-15T01:46Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The last modification time of the domain instance (timestamp).', example='1527690629357'),
      versionCode?: string(name='VersionCode', description='Global Traffic Management version 3.0 instance types:
- standard: Standard Edition
- ultimate: Ultimate Edition', example='ultimate'),
    }
  ](name='InstanceConfig')
  }(name='InstanceConfigs', description='The instances list.'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from 1, default is 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of **100**, and a default of **20**.', example='20'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='6AEC7A64-3CB1-4C49-8B35-0B901F1E26BF'),
  totalItems?: int32(name='TotalItems', description='Total number of instance configuration entries.', example='15'),
  totalPages?: int32(name='TotalPages', description='Total number of pages.', example='1'),
}

model SearchCloudGtmInstanceConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchCloudGtmInstanceConfigsResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of an access domain name.
 *
 * @param request SearchCloudGtmInstanceConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchCloudGtmInstanceConfigsResponse
 */
async function searchCloudGtmInstanceConfigsWithOptions(request: SearchCloudGtmInstanceConfigsRequest, runtime: Util.RuntimeOptions): SearchCloudGtmInstanceConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.availableStatus)) {
    query['AvailableStatus'] = request.availableStatus;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.enableStatus)) {
    query['EnableStatus'] = request.enableStatus;
  }
  if (!Util.isUnset(request.healthStatus)) {
    query['HealthStatus'] = request.healthStatus;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.scheduleDomainName)) {
    query['ScheduleDomainName'] = request.scheduleDomainName;
  }
  if (!Util.isUnset(request.scheduleZoneName)) {
    query['ScheduleZoneName'] = request.scheduleZoneName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchCloudGtmInstanceConfigs',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the configurations of an access domain name.
 *
 * @param request SearchCloudGtmInstanceConfigsRequest
 * @return SearchCloudGtmInstanceConfigsResponse
 */
async function searchCloudGtmInstanceConfigs(request: SearchCloudGtmInstanceConfigsRequest): SearchCloudGtmInstanceConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchCloudGtmInstanceConfigsWithOptions(request, runtime);
}

model SearchCloudGtmInstancesRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the return value. Options are:
- **zh-CN**: Chinese. 
- **en-US**: English.', example='en-US'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see How to ensure idempotence.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  instanceId?: string(name='InstanceId', description='The ID of the Global Traffic Manager (GTM) 3.0 instance.', example='gtm-cn-wwo3a3hbz**'),
  instanceName?: string(name='InstanceName', description='Schedule instance name, supports fuzzy search.', example='test'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting from 1, default is 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of **100**, and a default of **20**.', example='20'),
}

model SearchCloudGtmInstancesResponseBody = {
  instances?: {
    instance?: [ 
    {
      commodityCode?: string(name='CommodityCode', description='The commodity code. Valid values:

*   dns_gtm_public_cn: commodity code on the China site (aliyun.com)
*   dns_gtm_public_intl: commodity code on the international site (alibabacloud.com)', example='dns_gtm_public_cn'),
      createTime?: string(name='CreateTime', description='Instance creation time.', example='2024-03-15T01:46Z'),
      createTimestamp?: long(name='CreateTimestamp', description='Instance creation time (timestamp).', example='1710467214858'),
      expireTime?: long(name='ExpireTime', description='Instance expiration time.', example='2024-09-05T16:00Z'),
      expireTimestamp?: string(name='ExpireTimestamp', description='Instance expiration time (timestamp).', example='1725552000000'),
      instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance.', example='gtm-cn-wwo3a3hbz**'),
      instanceName?: string(name='InstanceName', description='Schedule instance name.', example='test'),
      monitorTaskQuota?: int32(name='MonitorTaskQuota', description='Monitor probe task quota.', example='100'),
      monthlyEmailUsed?: int32(name='MonthlyEmailUsed', description='Monthly email sending volume.', example='200'),
      monthlySmsQuota?: int32(name='MonthlySmsQuota', description='SMS quota, only supported on the China site. International site does not support SMS.', example='2000'),
      monthlySmsUsed?: int32(name='MonthlySmsUsed', description='Monthly SMS sending volume, only supported by the China site as international sites do not support SMS.', example='200'),
      monthlyWebhookUsed?: int32(name='MonthlyWebhookUsed', description='Monthly webhook dispatch volume.', example='100'),
      scheduleDomainName?: string(name='ScheduleDomainName', description='The access domain name, which consists of a hostname and a zone or a subzone.', example='www.example.com'),
      updateTime?: string(name='UpdateTime', description='The last modified time of the instance.', example='2024-03-15T01:46Z'),
      updateTimestamp?: long(name='UpdateTimestamp', description='The last modified time of the instance (timestamp).', example='1710467214858'),
      versionCode?: string(name='VersionCode', description='Global Traffic Management version 3.0 instance types:
- standard: Standard Edition
- ultimate: Ultimate Edition', example='ultimate'),
    }
  ](name='Instance')
  }(name='Instances', description='The instances.'),
  pageNumber?: int32(name='PageNumber', description='Current page number, starting at **1**, default is **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.', example='20'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  totalItems?: int32(name='TotalItems', description='Total number of instances found from the search.', example='10'),
  totalPages?: int32(name='TotalPages', description='Total number of pages.', example='1'),
}

model SearchCloudGtmInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchCloudGtmInstancesResponseBody(name='body'),
}

/**
 * @summary Queries a list of instances.
 *
 * @param request SearchCloudGtmInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchCloudGtmInstancesResponse
 */
async function searchCloudGtmInstancesWithOptions(request: SearchCloudGtmInstancesRequest, runtime: Util.RuntimeOptions): SearchCloudGtmInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchCloudGtmInstances',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of instances.
 *
 * @param request SearchCloudGtmInstancesRequest
 * @return SearchCloudGtmInstancesResponse
 */
async function searchCloudGtmInstances(request: SearchCloudGtmInstancesRequest): SearchCloudGtmInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchCloudGtmInstancesWithOptions(request, runtime);
}

model SearchCloudGtmMonitorTemplatesRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  ipVersion?: string(name='IpVersion', description='The IP address type of health check nodes. An exact search is performed based on the IP address type. Valid values:

*   IPv4: applicable when the destination address of health checks is an IPv4 address
*   IPv6: applicable when the destination address of health checks is an IPv6 address', example='IPv4'),
  name?: string(name='Name', example='IPv4-Ping'),
  pageNumber?: int32(name='PageNumber', description='This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='This parameter is required.', example='20'),
  protocol?: string(name='Protocol', example='ping'),
}

model SearchCloudGtmMonitorTemplatesResponseBody = {
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='20'),
  requestId?: string(name='RequestId', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  templates?: {
    template?: [ 
    {
      createTime?: string(name='CreateTime', example='2024-03-23T13:09Z'),
      createTimestamp?: long(name='CreateTimestamp', example='1527690629357'),
      evaluationCount?: int32(name='EvaluationCount', example='2'),
      extendInfo?: string(name='ExtendInfo', description='The extended information. The value of this parameter is a JSON string. The required parameters vary based on the health check protocol. Valid values:

*   **http(s)**:

    **host**: indicates the Host field of an HTTP or HTTPS request header during an HTTP or HTTPS health check. The parameter value indicates the HTTP website that you want to visit. By default, the value is the primary domain name. You can change the value based on your business requirements.

    **path**: the URL for HTTP or HTTPS health checks. Default value: /.

    **code**: indicates the alert threshold. During an HTTP or HTTPS health check, the system checks whether a web server functions as expected based on the status code that is returned from the web server. If the returned status code is greater than the specified threshold, the corresponding application service address is deemed abnormal. Valid values:

    *   400: indicates an invalid request. If an HTTP or HTTPS request contains invalid request parameters, a web server returns a status code that is greater than 400. If Verification Content is set to "The error code is greater than 400", you must specify an exact URL for the path parameter.
    *   500: indicates a server error. If some exceptions occur on a web server, the web server returns a status code that is greater than 500. The error code that is greater than 500 is used as the alert threshold by default.

    **sni**: indicates whether Server Name Indication (SNI) is enabled for HTTPS. SNI is an extension to the Transport Layer Security (TLS) protocol, which allows a client to specify the host to be connected when the client sends a TLS handshake request. TLS handshakes occur before any data of HTTP requests is sent. Therefore, SNI enables servers to identify the services that clients are attempting to access before certificates are sent. This allows the servers to present correct certificates to the clients. Valid values:

    *   true: SNI is enabled.
    *   false: SNI is disabled.

    **followRedirect**: indicates whether 3XX redirection is followed. Valid values:

    *   true: You are redirected to the destination address if a status code 3XX, such as 301, 302, 303, 307, or 308, is returned.
    *   false: You are not redirected to the destination address.

*   **ping**:

    **packetNum**: The total number of Internet Control Message Protocol (ICMP) packets that are sent to the address for each ping-based health check. Valid values: 20, 50, and 100.

    **packetLossRate**: The packet loss rate for each ping-based health check. The packet loss rate in a check can be calculated by using the following formula: Packet loss rate = (Number of lost packets/Total number of sent ICMP packets)  100%. If the packet loss rate reaches the threshold, an alert is triggered. Valid values: 10, 30, 40, 80, 90, and 100.', example='{\\\\"code\\\\":200,\\\\"path\\\\":\\\\"\\\\\\\\index.htm\\\\",\\\\"host\\\\":\\\\"aliyun.com\\\\"}'),
      failureRate?: int32(name='FailureRate', example='50'),
      interval?: int32(name='Interval', example='60'),
      ipVersion?: string(name='IpVersion', description='The IP address type of health check nodes. Valid values:

*   IPv4: applicable when the destination address of health checks is an IPv4 address
*   IPv6: applicable when the destination address of health checks is an IPv6 address', example='IPv4'),
      ispCityNodes?: {
        ispCityNode?: [ 
        {
          cityCode?: string(name='CityCode', example='503'),
          cityName?: string(name='CityName'),
          countryCode?: string(name='CountryCode', example='001'),
          countryName?: string(name='CountryName'),
          groupName?: string(name='GroupName', example='BGP'),
          groupType?: string(name='GroupType', description='The group type of health check nodes. Valid values:

*   BGP: BGP node
*   OVERSEAS: node outside the Chinese mainland
*   ISP: Internet service provider (ISP) node', example='BGP'),
          ispCode?: string(name='IspCode', example='465'),
          ispName?: string(name='IspName'),
        }
      ](name='IspCityNode')
      }(name='IspCityNodes', description='The health check nodes.'),
      name?: string(name='Name', example='IPv4-Ping'),
      protocol?: string(name='Protocol', example='ping'),
      remark?: string(name='Remark', example='test'),
      templateId?: string(name='TemplateId', example='mtp-89518052425100**80'),
      timeout?: int32(name='Timeout', example='5000'),
      updateTime?: string(name='UpdateTime', example='2024-03-29T13:20Z'),
      updateTimestamp?: long(name='UpdateTimestamp', example='1527690629357'),
    }
  ](name='Template')
  }(name='Templates', description='The health check templates.'),
  totalItems?: int32(name='TotalItems', example='1'),
  totalPages?: int32(name='TotalPages', example='1'),
}

model SearchCloudGtmMonitorTemplatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchCloudGtmMonitorTemplatesResponseBody(name='body'),
}

/**
 * @summary Queries the list of health check templates.
 *
 * @param request SearchCloudGtmMonitorTemplatesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchCloudGtmMonitorTemplatesResponse
 */
async function searchCloudGtmMonitorTemplatesWithOptions(request: SearchCloudGtmMonitorTemplatesRequest, runtime: Util.RuntimeOptions): SearchCloudGtmMonitorTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.ipVersion)) {
    query['IpVersion'] = request.ipVersion;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.protocol)) {
    query['Protocol'] = request.protocol;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchCloudGtmMonitorTemplates',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the list of health check templates.
 *
 * @param request SearchCloudGtmMonitorTemplatesRequest
 * @return SearchCloudGtmMonitorTemplatesResponse
 */
async function searchCloudGtmMonitorTemplates(request: SearchCloudGtmMonitorTemplatesRequest): SearchCloudGtmMonitorTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchCloudGtmMonitorTemplatesWithOptions(request, runtime);
}

model SetDNSSLBStatusRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  line?: string(name='Line', description='The DNS resolution line. The line can be the default line, China Telecom, and China Mobile.', example='China Mobile.'),
  open?: boolean(name='Open', description='Specifies whether to enable or disable weighted round-robin. Valid values:

*   **true** (default): enables weighted round-robin.
*   **false**: disables weighted round-robin.', example='true'),
  subDomain?: string(name='SubDomain', description='The subdomain name for which you want to enable weighted round-robin. Set the parameter to @.example.com instead of example.com.

This parameter is required.', example='www.example.com'),
  type?: string(name='Type', description='The type of the Domain Name System (DNS) record. Valid values: A and AAAA. Default value: A.', example='A'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0'),
}

model SetDNSSLBStatusResponseBody = {
  open?: boolean(name='Open', description='Indicates whether weighted round-robin is enabled for the subdomain name.', example='true'),
  recordCount?: long(name='RecordCount', description='The number of A records that are matched.', example='8'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model SetDNSSLBStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetDNSSLBStatusResponseBody(name='body'),
}

/**
 * @summary Enables or disables weighted round-robin based on the specified parameters.
 *
 * @param request SetDNSSLBStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDNSSLBStatusResponse
 */
async function setDNSSLBStatusWithOptions(request: SetDNSSLBStatusRequest, runtime: Util.RuntimeOptions): SetDNSSLBStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.line)) {
    query['Line'] = request.line;
  }
  if (!Util.isUnset(request.open)) {
    query['Open'] = request.open;
  }
  if (!Util.isUnset(request.subDomain)) {
    query['SubDomain'] = request.subDomain;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDNSSLBStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Enables or disables weighted round-robin based on the specified parameters.
 *
 * @param request SetDNSSLBStatusRequest
 * @return SetDNSSLBStatusResponse
 */
async function setDNSSLBStatus(request: SetDNSSLBStatusRequest): SetDNSSLBStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDNSSLBStatusWithOptions(request, runtime);
}

model SetDnsGtmAccessModeRequest {
  accessMode?: string(name='AccessMode', description='The switchover policy for primary and secondary address pool sets. Valid values:

*   AUTO: performs automatic switchover between the primary and secondary address pool sets upon failures.
*   DEFAULT: the primary address pool set
*   FAILOVER: the secondary address pool set

This parameter is required.', example='auto'),
  lang?: string(name='Lang', description='The language of the values for specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  strategyId?: string(name='StrategyId', description='The policy ID.

This parameter is required.', example='strategyId'),
}

model SetDnsGtmAccessModeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
}

model SetDnsGtmAccessModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetDnsGtmAccessModeResponseBody(name='body'),
}

/**
 * @summary Modifies an access policy.
 *
 * @description ****
 *
 * @param request SetDnsGtmAccessModeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDnsGtmAccessModeResponse
 */
async function setDnsGtmAccessModeWithOptions(request: SetDnsGtmAccessModeRequest, runtime: Util.RuntimeOptions): SetDnsGtmAccessModeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessMode)) {
    query['AccessMode'] = request.accessMode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDnsGtmAccessMode',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies an access policy.
 *
 * @description ****
 *
 * @param request SetDnsGtmAccessModeRequest
 * @return SetDnsGtmAccessModeResponse
 */
async function setDnsGtmAccessMode(request: SetDnsGtmAccessModeRequest): SetDnsGtmAccessModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDnsGtmAccessModeWithOptions(request, runtime);
}

model SetDnsGtmMonitorStatusRequest {
  lang?: string(name='Lang', description='The language of the values for specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check task.

This parameter is required.', example='MonitorConfigId1'),
  status?: string(name='Status', description='Specifies whether to enable the health check feature. Valid values:

*   OPEN: enables the health check feature.
*   CLOSE: disables the health check feature.

This parameter is required.', example='open'),
}

model SetDnsGtmMonitorStatusResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model SetDnsGtmMonitorStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetDnsGtmMonitorStatusResponseBody(name='body'),
}

/**
 * @summary Specifies the health check status of an address pool.
 *
 * @param request SetDnsGtmMonitorStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDnsGtmMonitorStatusResponse
 */
async function setDnsGtmMonitorStatusWithOptions(request: SetDnsGtmMonitorStatusRequest, runtime: Util.RuntimeOptions): SetDnsGtmMonitorStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.monitorConfigId)) {
    query['MonitorConfigId'] = request.monitorConfigId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDnsGtmMonitorStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Specifies the health check status of an address pool.
 *
 * @param request SetDnsGtmMonitorStatusRequest
 * @return SetDnsGtmMonitorStatusResponse
 */
async function setDnsGtmMonitorStatus(request: SetDnsGtmMonitorStatusRequest): SetDnsGtmMonitorStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDnsGtmMonitorStatusWithOptions(request, runtime);
}

model SetDomainDnssecStatusRequest {
  domainName?: string(name='DomainName', description='The domain name for which you want to enable the DNSSEC. Only the users of the paid editions of Alibaba Cloud DNS can enable this feature.

This parameter is required.', example='example.com'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en.', example='en'),
  status?: string(name='Status', description='The DNSSEC status. Valid values:

*   ON: enables DNSSEC for the domain name.
*   OFF: disables DNSSEC for the domain name.

This parameter is required.', example='ON'),
}

model SetDomainDnssecStatusResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model SetDomainDnssecStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetDomainDnssecStatusResponseBody(name='body'),
}

/**
 * @summary Enables or disables the Domain Name System Security Extensions (DNSSEC) for a domain name. This feature is available only for the users of the paid editions of Alibaba Cloud DNS.
 *
 * @param request SetDomainDnssecStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDomainDnssecStatusResponse
 */
async function setDomainDnssecStatusWithOptions(request: SetDomainDnssecStatusRequest, runtime: Util.RuntimeOptions): SetDomainDnssecStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDomainDnssecStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Enables or disables the Domain Name System Security Extensions (DNSSEC) for a domain name. This feature is available only for the users of the paid editions of Alibaba Cloud DNS.
 *
 * @param request SetDomainDnssecStatusRequest
 * @return SetDomainDnssecStatusResponse
 */
async function setDomainDnssecStatus(request: SetDomainDnssecStatusRequest): SetDomainDnssecStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDomainDnssecStatusWithOptions(request, runtime);
}

model SetDomainRecordStatusRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  recordId?: string(name='RecordId', description='The ID of the DNS record. You can call the [DescribeDomainRecords](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomainrecords?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.

This parameter is required.', example='9999985'),
  status?: string(name='Status', description='The state of the DNS record. Valid values:

*   **Enable**: enables the DNS record.
*   **Disable**: disables the DNS record.

This parameter is required.', example='Disable'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0'),
}

model SetDomainRecordStatusResponseBody = {
  recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  status?: string(name='Status', description='The status of the DNS record.', example='Disable'),
}

model SetDomainRecordStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetDomainRecordStatusResponseBody(name='body'),
}

/**
 * @summary Specifies the status of an Alibaba Cloud DNS (DNS) record based on the specified parameters.
 *
 * @param request SetDomainRecordStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDomainRecordStatusResponse
 */
async function setDomainRecordStatusWithOptions(request: SetDomainRecordStatusRequest, runtime: Util.RuntimeOptions): SetDomainRecordStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recordId)) {
    query['RecordId'] = request.recordId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDomainRecordStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Specifies the status of an Alibaba Cloud DNS (DNS) record based on the specified parameters.
 *
 * @param request SetDomainRecordStatusRequest
 * @return SetDomainRecordStatusResponse
 */
async function setDomainRecordStatus(request: SetDomainRecordStatusRequest): SetDomainRecordStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDomainRecordStatusWithOptions(request, runtime);
}

model SetGtmAccessModeRequest {
  accessMode?: string(name='AccessMode', description='The desired access policy. Valid values:

*   **AUTO: performs automatic switchover between the primary and secondary address pool sets upon failures.**
*   **DEFAULT: specifies the primary address pool set.**
*   **FAILOVER: specifies the secondary address pool set.

This parameter is required.', example='AUTO'),
  lang?: string(name='Lang', description='The language.', example='en'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy.

This parameter is required.', example='hra0hx'),
}

model SetGtmAccessModeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
}

model SetGtmAccessModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetGtmAccessModeResponseBody(name='body'),
}

/**
 * @summary Modifies a policy for switchover between address pool sets.
 *
 * @param request SetGtmAccessModeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetGtmAccessModeResponse
 */
async function setGtmAccessModeWithOptions(request: SetGtmAccessModeRequest, runtime: Util.RuntimeOptions): SetGtmAccessModeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessMode)) {
    query['AccessMode'] = request.accessMode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetGtmAccessMode',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a policy for switchover between address pool sets.
 *
 * @param request SetGtmAccessModeRequest
 * @return SetGtmAccessModeResponse
 */
async function setGtmAccessMode(request: SetGtmAccessModeRequest): SetGtmAccessModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setGtmAccessModeWithOptions(request, runtime);
}

model SetGtmMonitorStatusRequest {
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  monitorConfigId?: string(name='MonitorConfigId', description='The health check ID.

This parameter is required.', example='abc1234'),
  status?: string(name='Status', description='Specifies whether health check is enabled for the address pool. Valid values:

*   **OPEN**: Enabled
*   **CLOSE**: Disabled

This parameter is required.', example='OPEN'),
}

model SetGtmMonitorStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model SetGtmMonitorStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetGtmMonitorStatusResponseBody(name='body'),
}

/**
 * @param request SetGtmMonitorStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetGtmMonitorStatusResponse
 */
async function setGtmMonitorStatusWithOptions(request: SetGtmMonitorStatusRequest, runtime: Util.RuntimeOptions): SetGtmMonitorStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.monitorConfigId)) {
    query['MonitorConfigId'] = request.monitorConfigId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetGtmMonitorStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SetGtmMonitorStatusRequest
 * @return SetGtmMonitorStatusResponse
 */
async function setGtmMonitorStatus(request: SetGtmMonitorStatusRequest): SetGtmMonitorStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setGtmMonitorStatusWithOptions(request, runtime);
}

model SubmitIspFlushCacheTaskRequest {
  clientToken?: string(name='ClientToken', description='This parameter is required.'),
  domainName?: string(name='DomainName', description='This parameter is required.'),
  isp?: [ string ](name='Isp', description='This parameter is required.'),
  lang?: string(name='Lang'),
}

model SubmitIspFlushCacheTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model SubmitIspFlushCacheTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SubmitIspFlushCacheTaskResponseBody(name='body'),
}

/**
 * @summary 
 *
 * @param request SubmitIspFlushCacheTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SubmitIspFlushCacheTaskResponse
 */
async function submitIspFlushCacheTaskWithOptions(request: SubmitIspFlushCacheTaskRequest, runtime: Util.RuntimeOptions): SubmitIspFlushCacheTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.isp)) {
    query['Isp'] = request.isp;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitIspFlushCacheTask',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 
 *
 * @param request SubmitIspFlushCacheTaskRequest
 * @return SubmitIspFlushCacheTaskResponse
 */
async function submitIspFlushCacheTask(request: SubmitIspFlushCacheTaskRequest): SubmitIspFlushCacheTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitIspFlushCacheTaskWithOptions(request, runtime);
}

model SwitchDnsGtmInstanceStrategyModeRequest {
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance.

This parameter is required.', example='instance1'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  strategyMode?: string(name='StrategyMode', description='The access policy type. Valid values:

*   GEO: geographical location-based
*   LATENCY: latency-based

This parameter is required.', example='GEO'),
}

model SwitchDnsGtmInstanceStrategyModeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model SwitchDnsGtmInstanceStrategyModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SwitchDnsGtmInstanceStrategyModeResponseBody(name='body'),
}

/**
 * @summary Changes the access policy type for a Global Traffic Manager (GTM) instance.
 *
 * @param request SwitchDnsGtmInstanceStrategyModeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SwitchDnsGtmInstanceStrategyModeResponse
 */
async function switchDnsGtmInstanceStrategyModeWithOptions(request: SwitchDnsGtmInstanceStrategyModeRequest, runtime: Util.RuntimeOptions): SwitchDnsGtmInstanceStrategyModeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyMode)) {
    query['StrategyMode'] = request.strategyMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SwitchDnsGtmInstanceStrategyMode',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Changes the access policy type for a Global Traffic Manager (GTM) instance.
 *
 * @param request SwitchDnsGtmInstanceStrategyModeRequest
 * @return SwitchDnsGtmInstanceStrategyModeResponse
 */
async function switchDnsGtmInstanceStrategyMode(request: SwitchDnsGtmInstanceStrategyModeRequest): SwitchDnsGtmInstanceStrategyModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return switchDnsGtmInstanceStrategyModeWithOptions(request, runtime);
}

model TagResourcesRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  resourceId?: [ string ](name='ResourceId', description='The ID of the resource.

This parameter is required.', example='dns-example.com'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Valid values:

*   **DOMAIN**: domain name

This parameter is required.', example='DOMAIN'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key. The tag key can be up to 20 characters in length and cannot start with `acs:` or`aliyun`.', example='abcd'),
      value?: string(name='Value', description='The tag value. The tag value can be up to 20 bytes in length.', example='abcd'),
    }
  ](name='Tag', description='The tags.

This parameter is required.'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='635B0CCD-15A7-48C9-B4D6-628FF57FF4B8'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TagResourcesResponseBody(name='body'),
}

/**
 * @summary Adds and modifies a tag for a resource.
 *
 * @param request TagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesResponse
 */
async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Adds and modifies a tag for a resource.
 *
 * @param request TagResourcesRequest
 * @return TagResourcesResponse
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model TransferDomainRequest {
  domainNames?: string(name='DomainNames', description='The domain names. Separate multiple domain names with commas (,). Only domain names registered with Alibaba Cloud are supported.

This parameter is required.', example='test1.com,test2.com'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  remark?: string(name='Remark', description='The description of the domain name.', example='test domain transfer'),
  targetUserId?: long(name='TargetUserId', description='The destination user ID. The domain names and their Domain Name System (DNS) records are transferred to the destination user ID.

This parameter is required.', example='12345678'),
}

model TransferDomainResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  taskId?: long(name='TaskId', description='The task ID.', example='112233'),
}

model TransferDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TransferDomainResponseBody(name='body'),
}

/**
 * @summary Transfers multiple domain names from the current account to another account at a time.
 *
 * @param request TransferDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TransferDomainResponse
 */
async function transferDomainWithOptions(request: TransferDomainRequest, runtime: Util.RuntimeOptions): TransferDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainNames)) {
    query['DomainNames'] = request.domainNames;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.targetUserId)) {
    query['TargetUserId'] = request.targetUserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TransferDomain',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Transfers multiple domain names from the current account to another account at a time.
 *
 * @param request TransferDomainRequest
 * @return TransferDomainResponse
 */
async function transferDomain(request: TransferDomainRequest): TransferDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return transferDomainWithOptions(request, runtime);
}

model UnbindInstanceDomainsRequest {
  domainNames?: string(name='DomainNames', description='The domain names.

Separate multiple domain names with commas (,). Up to 100 domain names can be entered.

This parameter is required.', example='example.com,example.net'),
  instanceId?: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='123'),
  lang?: string(name='Lang', description='The language.', example='en'),
}

model UnbindInstanceDomainsResponseBody = {
  failedCount?: int32(name='FailedCount', description='The number of domain names that failed to be unbound from the instance.', example='0'),
  requestId?: string(name='RequestId', description='The request ID.', example='123'),
  successCount?: int32(name='SuccessCount', description='The number of domain names that are unbound from the instance.', example='2'),
}

model UnbindInstanceDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnbindInstanceDomainsResponseBody(name='body'),
}

/**
 * @summary Unbinds one or more domain names from a paid Alibaba Cloud DNS instance based on the instance ID.
 *
 * @description A paid Alibaba Cloud DNS instance whose ID starts with dns is an instance of the new version. You can call an API operation to bind multiple domain names to the instance. If the upper limit is exceeded, an error message is returned.\\
 * A paid Alibaba Cloud DNS instance whose ID does not start with dns is an instance of the old version. You can call an API operation to bind only one domain name to the instance. However, if the instance that you want to bind to the desired domain name is already bound to a domain name, you can call this operation to unbind the original domain name from the instance and then bind the desired domain name to the instance.
 *
 * @param request UnbindInstanceDomainsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnbindInstanceDomainsResponse
 */
async function unbindInstanceDomainsWithOptions(request: UnbindInstanceDomainsRequest, runtime: Util.RuntimeOptions): UnbindInstanceDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainNames)) {
    query['DomainNames'] = request.domainNames;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnbindInstanceDomains',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Unbinds one or more domain names from a paid Alibaba Cloud DNS instance based on the instance ID.
 *
 * @description A paid Alibaba Cloud DNS instance whose ID starts with dns is an instance of the new version. You can call an API operation to bind multiple domain names to the instance. If the upper limit is exceeded, an error message is returned.\\
 * A paid Alibaba Cloud DNS instance whose ID does not start with dns is an instance of the old version. You can call an API operation to bind only one domain name to the instance. However, if the instance that you want to bind to the desired domain name is already bound to a domain name, you can call this operation to unbind the original domain name from the instance and then bind the desired domain name to the instance.
 *
 * @param request UnbindInstanceDomainsRequest
 * @return UnbindInstanceDomainsResponse
 */
async function unbindInstanceDomains(request: UnbindInstanceDomainsRequest): UnbindInstanceDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindInstanceDomainsWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to remove all tags. Default value: false. This parameter is valid only when TagKey is left empty. Valid values: true and false.', example='false'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  resourceId?: [ string ](name='ResourceId', description='The ID of the resource.

This parameter is required.', example='The type of the resource.'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Valid value: Valid values:

*   **DOMAIN**: domain name

This parameter is required.', example='DOMAIN'),
  tagKey?: [ string ](name='TagKey', description='The tags added to the resource.', example='The domain name.'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F152A869-DF77-4DF1-9A00-4E06978FE6A1'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UntagResourcesResponseBody(name='body'),
}

/**
 * @summary Removes tags from resources.
 *
 * @param request UntagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UntagResourcesResponse
 */
async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Removes tags from resources.
 *
 * @param request UntagResourcesRequest
 * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateAppKeyStateRequest {
  appKeyId?: string(name='AppKeyId'),
  lang?: string(name='Lang'),
  state?: string(name='State'),
}

model UpdateAppKeyStateResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAppKeyStateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAppKeyStateResponseBody(name='body'),
}

/**
 * @summary  AppKey 
 *
 * @param request UpdateAppKeyStateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAppKeyStateResponse
 */
async function updateAppKeyStateWithOptions(request: UpdateAppKeyStateRequest, runtime: Util.RuntimeOptions): UpdateAppKeyStateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appKeyId)) {
    query['AppKeyId'] = request.appKeyId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAppKeyState',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary  AppKey 
 *
 * @param request UpdateAppKeyStateRequest
 * @return UpdateAppKeyStateResponse
 */
async function updateAppKeyState(request: UpdateAppKeyStateRequest): UpdateAppKeyStateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAppKeyStateWithOptions(request, runtime);
}

model UpdateCloudGtmAddressRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  address?: string(name='Address', description='The IP address or domain name.', example='223.5.XX.XX'),
  addressId?: string(name='AddressId', description='The ID of the address. This ID uniquely identifies the address.

This parameter is required.', example='addr-89518218114368**92'),
  attributeInfo?: string(name='AttributeInfo', description='Address Attribution information.', example='This parameter is not supported in the current version and does not need to be input.'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  healthJudgement?: string(name='HealthJudgement', description='The new condition for determining the health state of the address. Valid values:

*   any_ok: The health check results of at least one health check template are normal.
*   p30_ok: The health check results of at least 30% of health check templates are normal.
*   p50_ok: The health check results of at least 50% of health check templates are normal.
*   p70_ok: The health check results of at least 70% of health check templates are normal.
*   all_ok: The health check results of all health check templates are normal.', example='p50_ok'),
  healthTasks?: [ 
    {
      port?: int32(name='Port', description='The service port of the address on which health check tasks are performed. If the ping protocol is used for health checks, the configuration of the service port is not supported.

*   If you leave this parameter empty, the existing service port is deleted.
*   If you specify this parameter, the existing service port is updated based on the value of this parameter.', example='80'),
      templateId?: string(name='TemplateId', description='The ID of the health check template that is associated with the address. This parameter is required if you specify a service port of the address for health check tasks.

*   If you leave this parameter empty, the associated health check template is disassociated from the address.
*   If you specify this parameter, the associated health check template is updated based on the value of this parameter.', example='mtp-89518052425100**80'),
    }
  ](name='HealthTasks', description='The health check tasks.'),
  name?: string(name='Name', description='The name of the address.', example='Address-1'),
}

model UpdateCloudGtmAddressShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  address?: string(name='Address', description='The IP address or domain name.', example='223.5.XX.XX'),
  addressId?: string(name='AddressId', description='The ID of the address. This ID uniquely identifies the address.

This parameter is required.', example='addr-89518218114368**92'),
  attributeInfo?: string(name='AttributeInfo', description='Address Attribution information.', example='This parameter is not supported in the current version and does not need to be input.'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  healthJudgement?: string(name='HealthJudgement', description='The new condition for determining the health state of the address. Valid values:

*   any_ok: The health check results of at least one health check template are normal.
*   p30_ok: The health check results of at least 30% of health check templates are normal.
*   p50_ok: The health check results of at least 50% of health check templates are normal.
*   p70_ok: The health check results of at least 70% of health check templates are normal.
*   all_ok: The health check results of all health check templates are normal.', example='p50_ok'),
  healthTasksShrink?: string(name='HealthTasks', description='The health check tasks.'),
  name?: string(name='Name', description='The name of the address.', example='Address-1'),
}

model UpdateCloudGtmAddressResponseBody = {
  requestId?: string(name='RequestId', description='Unique request identification code.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  success?: boolean(name='Success', description='Modify address base configuration operation status:
- true: Operation was successful
- false: Operation was failed', example='true'),
}

model UpdateCloudGtmAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmAddressResponseBody(name='body'),
}

/**
 * @summary Modifies the condition for determining the health status of a specified address.
 *
 * @param tmpReq UpdateCloudGtmAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCloudGtmAddressResponse
 */
async function updateCloudGtmAddressWithOptions(tmpReq: UpdateCloudGtmAddressRequest, runtime: Util.RuntimeOptions): UpdateCloudGtmAddressResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateCloudGtmAddressShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.healthTasks)) {
    request.healthTasksShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.healthTasks, 'HealthTasks', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.addressId)) {
    query['AddressId'] = request.addressId;
  }
  if (!Util.isUnset(request.attributeInfo)) {
    query['AttributeInfo'] = request.attributeInfo;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.healthJudgement)) {
    query['HealthJudgement'] = request.healthJudgement;
  }
  if (!Util.isUnset(request.healthTasksShrink)) {
    query['HealthTasks'] = request.healthTasksShrink;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCloudGtmAddress',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the condition for determining the health status of a specified address.
 *
 * @param request UpdateCloudGtmAddressRequest
 * @return UpdateCloudGtmAddressResponse
 */
async function updateCloudGtmAddress(request: UpdateCloudGtmAddressRequest): UpdateCloudGtmAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCloudGtmAddressWithOptions(request, runtime);
}

model UpdateCloudGtmAddressEnableStatusRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='

- zh-CN

- en-US', example='en-US'),
  addressId?: string(name='AddressId', description='The ID of the address. This ID uniquely identifies the address.

This parameter is required.', example='addr-89518218114368**92'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  enableStatus?: string(name='EnableStatus', description='The enabling state of the address. Valid values:

*   enable: The address is enabled and the address can be used for Domain Name System (DNS) resolution if the address passes health checks.
*   disable: The address is disabled and the address cannot be used for DNS resolution regardless of whether the address passes health checks or not.

This parameter is required.', example='enable'),
}

model UpdateCloudGtmAddressEnableStatusResponseBody = {
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  success?: boolean(name='Success', description='Indicates whether the operation was successful. Valid values:

*   true: The operation was successful.
*   false: The operation was failed.', example='true'),
}

model UpdateCloudGtmAddressEnableStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmAddressEnableStatusResponseBody(name='body'),
}

/**
 * @summary Modifies the enabling status of an address.
 *
 * @description *   If an address is **enabled** and the health status of the address is **Normal**, the availability status of the address is **Available**.
 * *   If an address is **disabled** or the health status of the address is **Abnormal**, the availability status of the address is **Unavailable**.
 *
 * @param request UpdateCloudGtmAddressEnableStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCloudGtmAddressEnableStatusResponse
 */
async function updateCloudGtmAddressEnableStatusWithOptions(request: UpdateCloudGtmAddressEnableStatusRequest, runtime: Util.RuntimeOptions): UpdateCloudGtmAddressEnableStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.addressId)) {
    query['AddressId'] = request.addressId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.enableStatus)) {
    query['EnableStatus'] = request.enableStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCloudGtmAddressEnableStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the enabling status of an address.
 *
 * @description *   If an address is **enabled** and the health status of the address is **Normal**, the availability status of the address is **Available**.
 * *   If an address is **disabled** or the health status of the address is **Abnormal**, the availability status of the address is **Unavailable**.
 *
 * @param request UpdateCloudGtmAddressEnableStatusRequest
 * @return UpdateCloudGtmAddressEnableStatusResponse
 */
async function updateCloudGtmAddressEnableStatus(request: UpdateCloudGtmAddressEnableStatusRequest): UpdateCloudGtmAddressEnableStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCloudGtmAddressEnableStatusWithOptions(request, runtime);
}

model UpdateCloudGtmAddressManualAvailableStatusRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  addressId?: string(name='AddressId', description='The ID of the address. This ID uniquely identifies the address.

This parameter is required.', example='addr-89518218114368**92'),
  availableMode?: string(name='AvailableMode', description='The failover mode that is used when address exceptions are identified. Valid values:

*   auto: the automatic mode. The system determines whether to return an address based on health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
*   manual: the manual mode. If an address is in the unavailable state, the address is not returned for DNS requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.', example='manual'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  manualAvailableStatus?: string(name='ManualAvailableStatus', description='The availability state of the address when AvailableMode is set to manual. Valid values:

*   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
*   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.', example='available'),
}

model UpdateCloudGtmAddressManualAvailableStatusResponseBody = {
  requestId?: string(name='RequestId', description='Unique request identification code.', example='0F32959D-417B-4D66-8463-68606605E3E2'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
}

model UpdateCloudGtmAddressManualAvailableStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmAddressManualAvailableStatusResponseBody(name='body'),
}

/**
 * @summary Modifies the failover mode that is used when address exceptions are identified.
 *
 * @param request UpdateCloudGtmAddressManualAvailableStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCloudGtmAddressManualAvailableStatusResponse
 */
async function updateCloudGtmAddressManualAvailableStatusWithOptions(request: UpdateCloudGtmAddressManualAvailableStatusRequest, runtime: Util.RuntimeOptions): UpdateCloudGtmAddressManualAvailableStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.addressId)) {
    query['AddressId'] = request.addressId;
  }
  if (!Util.isUnset(request.availableMode)) {
    query['AvailableMode'] = request.availableMode;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.manualAvailableStatus)) {
    query['ManualAvailableStatus'] = request.manualAvailableStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCloudGtmAddressManualAvailableStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the failover mode that is used when address exceptions are identified.
 *
 * @param request UpdateCloudGtmAddressManualAvailableStatusRequest
 * @return UpdateCloudGtmAddressManualAvailableStatusResponse
 */
async function updateCloudGtmAddressManualAvailableStatus(request: UpdateCloudGtmAddressManualAvailableStatusRequest): UpdateCloudGtmAddressManualAvailableStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCloudGtmAddressManualAvailableStatusWithOptions(request, runtime);
}

model UpdateCloudGtmAddressPoolBasicConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
  addressPoolName?: string(name='AddressPoolName', description='Address pool name, helping users distinguish the purpose of address pools.', example='app'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  healthJudgement?: string(name='HealthJudgement', description='The condition for determining the health status of the address pool. Valid values:

*   any_ok: At least one address in the address pool is available.
*   p30_ok: At least 30% of the addresses in the address pool are available.
*   p50_ok: At least 50% of the addresses in the address pool are available.
*   p70_ok: At least 70% of the addresses in the address pool are available.
*   all_ok: All addresses in the address pool are available.', example='any_ok'),
}

model UpdateCloudGtmAddressPoolBasicConfigResponseBody = {
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  success?: boolean(name='Success', description='Modify the basic configuration of the address pool operation success:
- true: Operation successful
- false: Operation failed', example='true'),
}

model UpdateCloudGtmAddressPoolBasicConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmAddressPoolBasicConfigResponseBody(name='body'),
}

/**
 * @summary Modifies the basic configurations of an address pool.
 *
 * @param request UpdateCloudGtmAddressPoolBasicConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCloudGtmAddressPoolBasicConfigResponse
 */
async function updateCloudGtmAddressPoolBasicConfigWithOptions(request: UpdateCloudGtmAddressPoolBasicConfigRequest, runtime: Util.RuntimeOptions): UpdateCloudGtmAddressPoolBasicConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.addressPoolId)) {
    query['AddressPoolId'] = request.addressPoolId;
  }
  if (!Util.isUnset(request.addressPoolName)) {
    query['AddressPoolName'] = request.addressPoolName;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.healthJudgement)) {
    query['HealthJudgement'] = request.healthJudgement;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCloudGtmAddressPoolBasicConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the basic configurations of an address pool.
 *
 * @param request UpdateCloudGtmAddressPoolBasicConfigRequest
 * @return UpdateCloudGtmAddressPoolBasicConfigResponse
 */
async function updateCloudGtmAddressPoolBasicConfig(request: UpdateCloudGtmAddressPoolBasicConfigRequest): UpdateCloudGtmAddressPoolBasicConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCloudGtmAddressPoolBasicConfigWithOptions(request, runtime);
}

model UpdateCloudGtmAddressPoolEnableStatusRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  enableStatus?: string(name='EnableStatus', description='The enabling state of the address pool. Valid values:

*   enable: The address pool is enabled, and the addresses in the address pool are returned for DNS resolution when the health check results are normal.
*   disable: The address pool is disabled, and the addresses in the address pool are not returned for DNS resolution regardless of whether the health check results are normal or not.', example='enable'),
}

model UpdateCloudGtmAddressPoolEnableStatusResponseBody = {
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='89184F33-48A1-4401-9C0F-40E45DB091AB'),
  success?: boolean(name='Success', description='Indicates whether the modification operation was successful:
- true: Operation was successful
- false: Operation failed', example='true'),
}

model UpdateCloudGtmAddressPoolEnableStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmAddressPoolEnableStatusResponseBody(name='body'),
}

/**
 * @summary Modifies the enabling status of an address pool.
 *
 * @description *   If an address pool is **enabled** and the health status of the address pool is **Normal**, the availability status of the address pool is **Available**.
 * *   If an address pool is **disabled** or the health status of the address pool is **Abnormal**, the availability status of the address pool is **unavailable**.
 *
 * @param request UpdateCloudGtmAddressPoolEnableStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCloudGtmAddressPoolEnableStatusResponse
 */
async function updateCloudGtmAddressPoolEnableStatusWithOptions(request: UpdateCloudGtmAddressPoolEnableStatusRequest, runtime: Util.RuntimeOptions): UpdateCloudGtmAddressPoolEnableStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.addressPoolId)) {
    query['AddressPoolId'] = request.addressPoolId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.enableStatus)) {
    query['EnableStatus'] = request.enableStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCloudGtmAddressPoolEnableStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the enabling status of an address pool.
 *
 * @description *   If an address pool is **enabled** and the health status of the address pool is **Normal**, the availability status of the address pool is **Available**.
 * *   If an address pool is **disabled** or the health status of the address pool is **Abnormal**, the availability status of the address pool is **unavailable**.
 *
 * @param request UpdateCloudGtmAddressPoolEnableStatusRequest
 * @return UpdateCloudGtmAddressPoolEnableStatusResponse
 */
async function updateCloudGtmAddressPoolEnableStatus(request: UpdateCloudGtmAddressPoolEnableStatusRequest): UpdateCloudGtmAddressPoolEnableStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCloudGtmAddressPoolEnableStatusWithOptions(request, runtime);
}

model UpdateCloudGtmAddressPoolLbStrategyRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  addressLbStrategy?: string(name='AddressLbStrategy', description='Load balancing policy among addresses in the address pool:
- round_robin: Round-robin, for any source of DNS resolution requests, all addresses are returned. The order of all addresses is rotated each time.
- sequence: Sequential, for any source of DNS resolution requests, the address with the smaller sequence number (the sequence number indicates the priority of address returns, with smaller numbers having higher priority) is returned. If the address with the smaller sequence number is unavailable, the next address with a smaller sequence number is returned.
- weight: Weighted, supports setting different weight values for each address, realizing the return of addresses according to the weight ratio for resolution queries.
- source_nearest: Source-nearest, i.e., intelligent resolution function, where GTM can return different addresses based on the source of different DNS resolution requests, achieving the effect of users accessing nearby.', example='sequence'),
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address with the smallest sequence number is recovered. This parameter is required only when AddressLbStrategy is set to sequence. Valid values:

*   preemptive: The address with the smallest sequence number is preferentially used if this address is recovered.
*   non_preemptive: The current address is still used even if the address with the smallest sequence number is recovered.', example='preemptive'),
}

model UpdateCloudGtmAddressPoolLbStrategyResponseBody = {
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
  success?: boolean(name='Success', description='Indicates whether the modification operation was successful:
- true: Operation successful
- false: Operation failed', example='true'),
}

model UpdateCloudGtmAddressPoolLbStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmAddressPoolLbStrategyResponseBody(name='body'),
}

/**
 * @summary Modifies the load balancing policy of an address pool.
 *
 * @param request UpdateCloudGtmAddressPoolLbStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCloudGtmAddressPoolLbStrategyResponse
 */
async function updateCloudGtmAddressPoolLbStrategyWithOptions(request: UpdateCloudGtmAddressPoolLbStrategyRequest, runtime: Util.RuntimeOptions): UpdateCloudGtmAddressPoolLbStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.addressLbStrategy)) {
    query['AddressLbStrategy'] = request.addressLbStrategy;
  }
  if (!Util.isUnset(request.addressPoolId)) {
    query['AddressPoolId'] = request.addressPoolId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.sequenceLbStrategyMode)) {
    query['SequenceLbStrategyMode'] = request.sequenceLbStrategyMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCloudGtmAddressPoolLbStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the load balancing policy of an address pool.
 *
 * @param request UpdateCloudGtmAddressPoolLbStrategyRequest
 * @return UpdateCloudGtmAddressPoolLbStrategyResponse
 */
async function updateCloudGtmAddressPoolLbStrategy(request: UpdateCloudGtmAddressPoolLbStrategyRequest): UpdateCloudGtmAddressPoolLbStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCloudGtmAddressPoolLbStrategyWithOptions(request, runtime);
}

model UpdateCloudGtmAddressPoolRemarkRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  remark?: string(name='Remark', description='The input parameter serves as the updated note; if an empty value is passed, the note will be deleted.', example='test'),
}

model UpdateCloudGtmAddressPoolRemarkResponseBody = {
  addressPoolId?: string(name='AddressPoolId', description='The ID of the address pool. This ID uniquely identifies the address pool.', example='pool-89528023225442**16'),
  requestId?: string(name='RequestId', description='Unique request identification code.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  success?: boolean(name='Success', description='Indicates whether the modification operation was successful:
- true: Operation successful
- false: Operation failed', example='true'),
}

model UpdateCloudGtmAddressPoolRemarkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmAddressPoolRemarkResponseBody(name='body'),
}

/**
 * @summary Modifies the remarks of an address pool.
 *
 * @param request UpdateCloudGtmAddressPoolRemarkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCloudGtmAddressPoolRemarkResponse
 */
async function updateCloudGtmAddressPoolRemarkWithOptions(request: UpdateCloudGtmAddressPoolRemarkRequest, runtime: Util.RuntimeOptions): UpdateCloudGtmAddressPoolRemarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.addressPoolId)) {
    query['AddressPoolId'] = request.addressPoolId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCloudGtmAddressPoolRemark',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the remarks of an address pool.
 *
 * @param request UpdateCloudGtmAddressPoolRemarkRequest
 * @return UpdateCloudGtmAddressPoolRemarkResponse
 */
async function updateCloudGtmAddressPoolRemark(request: UpdateCloudGtmAddressPoolRemarkRequest): UpdateCloudGtmAddressPoolRemarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCloudGtmAddressPoolRemarkWithOptions(request, runtime);
}

model UpdateCloudGtmAddressRemarkRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  addressId?: string(name='AddressId', description='The ID of the address. This ID uniquely identifies the address.

This parameter is required.', example='addr-89518218114368**92'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  remark?: string(name='Remark', description='The input parameter serves as the updated note; if an empty value is passed, the note will be deleted.', example='test'),
}

model UpdateCloudGtmAddressRemarkResponseBody = {
  requestId?: string(name='RequestId', description='Unique request identification code.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
  success?: boolean(name='Success', description='Indicates whether the modification operation was successful:
- true: Operation was successful
- false: Operation was failed', example='true'),
}

model UpdateCloudGtmAddressRemarkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmAddressRemarkResponseBody(name='body'),
}

/**
 * @summary Modifies the remarks of an address.
 *
 * @param request UpdateCloudGtmAddressRemarkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCloudGtmAddressRemarkResponse
 */
async function updateCloudGtmAddressRemarkWithOptions(request: UpdateCloudGtmAddressRemarkRequest, runtime: Util.RuntimeOptions): UpdateCloudGtmAddressRemarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.addressId)) {
    query['AddressId'] = request.addressId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCloudGtmAddressRemark',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the remarks of an address.
 *
 * @param request UpdateCloudGtmAddressRemarkRequest
 * @return UpdateCloudGtmAddressRemarkResponse
 */
async function updateCloudGtmAddressRemark(request: UpdateCloudGtmAddressRemarkRequest): UpdateCloudGtmAddressRemarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCloudGtmAddressRemarkWithOptions(request, runtime);
}

model UpdateCloudGtmGlobalAlertRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US: English', example='en-US'),
  alertConfig?: [ 
    {
      dingtalkNotice?: boolean(name='DingtalkNotice', description='Specifies whether to configure DingTalk notifications. Valid values:

*   true: configures DingTalk notifications. DingTalk notifications are sent when alerts are triggered.
*   false: does not configure DingTalk notifications.', example='false'),
      emailNotice?: boolean(name='EmailNotice', description='Specifies whether to configure email notifications. Valid values:

*   true: configures email notifications. Emails are sent when alerts are triggered.
*   falsenull: does not configure email notifications.', example='true'),
      noticeType?: string(name='NoticeType', description='The type of the alert event. Valid values:

*   addr_alert: The address is unavailable.
*   addr_resume: The address becomes available.
*   addr_pool_unavailable: The address pool is unavailable.
*   addr_pool_available: The address pool becomes available.', example='addr_alert'),
      smsNotice?: boolean(name='SmsNotice', description='Specifies whether to configure text message notifications. Valid values:

*   true: configures text message notifications. Text messages are sent when alerts are triggered.
*   falsenull: does not configure text message notifications.

Only the China site (aliyun.com) supports text message notifications.', example='true'),
    }
  ](name='AlertConfig', description='The alert configurations.'),
  alertGroup?: [ string ](name='AlertGroup', description='The alert contact groups.'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
}

model UpdateCloudGtmGlobalAlertShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US: English', example='en-US'),
  alertConfigShrink?: string(name='AlertConfig', description='The alert configurations.'),
  alertGroupShrink?: string(name='AlertGroup', description='The alert contact groups.'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
}

model UpdateCloudGtmGlobalAlertResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model UpdateCloudGtmGlobalAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmGlobalAlertResponseBody(name='body'),
}

/**
 * @param tmpReq UpdateCloudGtmGlobalAlertRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCloudGtmGlobalAlertResponse
 */
async function updateCloudGtmGlobalAlertWithOptions(tmpReq: UpdateCloudGtmGlobalAlertRequest, runtime: Util.RuntimeOptions): UpdateCloudGtmGlobalAlertResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateCloudGtmGlobalAlertShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.alertConfig)) {
    request.alertConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.alertConfig, 'AlertConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.alertGroup)) {
    request.alertGroupShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.alertGroup, 'AlertGroup', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.alertConfigShrink)) {
    query['AlertConfig'] = request.alertConfigShrink;
  }
  if (!Util.isUnset(request.alertGroupShrink)) {
    query['AlertGroup'] = request.alertGroupShrink;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCloudGtmGlobalAlert',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateCloudGtmGlobalAlertRequest
 * @return UpdateCloudGtmGlobalAlertResponse
 */
async function updateCloudGtmGlobalAlert(request: UpdateCloudGtmGlobalAlertRequest): UpdateCloudGtmGlobalAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCloudGtmGlobalAlertWithOptions(request, runtime);
}

model UpdateCloudGtmInstanceConfigAlertRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US: English', example='zh-CN'),
  alertConfig?: [ 
    {
      dingtalkNotice?: boolean(name='DingtalkNotice', description='Specifies whether to configure DingTalk notifications. Valid values:

*   true: configures DingTalk notifications. DingTalk notifications are sent when alerts are triggered.
*   false: does not configure DingTalk notifications.', example='true'),
      emailNotice?: boolean(name='EmailNotice', description='Specifies whether to configure email notifications. Valid values:

*   true: configures email notifications. Emails are sent when alerts are triggered.
*   false: does not configure email notifications.', example='true'),
      noticeType?: string(name='NoticeType', description='The type of the alert event. Valid values:

*   addr_alert: The address is unavailable.
*   addr_resume: The address becomes available.
*   addr_pool_unavailable: The address pool is unavailable.
*   addr_pool_available: The address pool becomes available.', example='addr_alert'),
      smsNotice?: boolean(name='SmsNotice', description='Specifies whether to configure text message notifications. Valid values:

*   true: configures text message notifications. Text messages are sent when alerts are triggered.
*   false: does not configure text message notifications.

Only the China site (aliyun.com) supports text message notifications.', example='true'),
    }
  ](name='AlertConfig', description='The alert configurations.'),
  alertGroup?: [ string ](name='AlertGroup', description='The alert contact groups.'),
  alertMode?: string(name='AlertMode', description='The alert configuration mode of the instance. Valid values:

*   global: global alert configuration
*   instance_config: custom alert configuration', example='global'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when an A record and an AAAA record are configured for the access domain name that is bound to the GTM instance. This ID uniquely identifies a configuration.', example='Config-000**11'),
  instanceId?: string(name='InstanceId', description='The ID of the Global Traffic Manager (GTM) 3.0 instance.', example='gtm-cn-zz11t58**0s'),
}

model UpdateCloudGtmInstanceConfigAlertShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US: English', example='zh-CN'),
  alertConfigShrink?: string(name='AlertConfig', description='The alert configurations.'),
  alertGroupShrink?: string(name='AlertGroup', description='The alert contact groups.'),
  alertMode?: string(name='AlertMode', description='The alert configuration mode of the instance. Valid values:

*   global: global alert configuration
*   instance_config: custom alert configuration', example='global'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when an A record and an AAAA record are configured for the access domain name that is bound to the GTM instance. This ID uniquely identifies a configuration.', example='Config-000**11'),
  instanceId?: string(name='InstanceId', description='The ID of the Global Traffic Manager (GTM) 3.0 instance.', example='gtm-cn-zz11t58**0s'),
}

model UpdateCloudGtmInstanceConfigAlertResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model UpdateCloudGtmInstanceConfigAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmInstanceConfigAlertResponseBody(name='body'),
}

/**
 * @param tmpReq UpdateCloudGtmInstanceConfigAlertRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCloudGtmInstanceConfigAlertResponse
 */
async function updateCloudGtmInstanceConfigAlertWithOptions(tmpReq: UpdateCloudGtmInstanceConfigAlertRequest, runtime: Util.RuntimeOptions): UpdateCloudGtmInstanceConfigAlertResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateCloudGtmInstanceConfigAlertShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.alertConfig)) {
    request.alertConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.alertConfig, 'AlertConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.alertGroup)) {
    request.alertGroupShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.alertGroup, 'AlertGroup', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.alertConfigShrink)) {
    query['AlertConfig'] = request.alertConfigShrink;
  }
  if (!Util.isUnset(request.alertGroupShrink)) {
    query['AlertGroup'] = request.alertGroupShrink;
  }
  if (!Util.isUnset(request.alertMode)) {
    query['AlertMode'] = request.alertMode;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCloudGtmInstanceConfigAlert',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateCloudGtmInstanceConfigAlertRequest
 * @return UpdateCloudGtmInstanceConfigAlertResponse
 */
async function updateCloudGtmInstanceConfigAlert(request: UpdateCloudGtmInstanceConfigAlertRequest): UpdateCloudGtmInstanceConfigAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCloudGtmInstanceConfigAlertWithOptions(request, runtime);
}

model UpdateCloudGtmInstanceConfigBasicRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   **zh-CN**: Chinese
*   **en-US** (default): English', example='en-US'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.

You can call the [ListCloudGtmInstanceConfigs](https://help.aliyun.com/document_detail/2797349.html) operation to query the value of ConfigId for the access domain name.', example='Config-000**11'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance for which you want to modify the TTL configuration.', example='gtm-cn-wwo3a3hbz**'),
  scheduleHostname?: string(name='ScheduleHostname', description='Host record of the domain accessed by GTM.', example='www'),
  scheduleZoneName?: string(name='ScheduleZoneName', description='The zone (such as example.com) or subzone (such as a.example.com) of the GTM access domain name. In most cases, the zone or subzone is hosted in Authoritative DNS Resolution of the Alibaba Cloud DNS console within the account to which the GTM instance belongs.', example='example.com'),
  ttl?: int32(name='Ttl', description='The global TTL value, in seconds. The global TTL value affects how long the DNS records that map the access domain name to the addresses in the address pools are cached in the local DNS servers of Internet service providers (ISPs).', example='60'),
}

model UpdateCloudGtmInstanceConfigBasicResponseBody = {
  requestId?: string(name='RequestId', description='Unique request identification code.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  success?: boolean(name='Success', description='Indicates whether the operation was successful: 
- **true**: The call succeeded. 
- **false**: The call failed.', example='true'),
}

model UpdateCloudGtmInstanceConfigBasicResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmInstanceConfigBasicResponseBody(name='body'),
}

/**
 * @summary Updates the global time-to-live (TTL) configuration of a GTM 3.0 instance.
 *
 * @param request UpdateCloudGtmInstanceConfigBasicRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCloudGtmInstanceConfigBasicResponse
 */
async function updateCloudGtmInstanceConfigBasicWithOptions(request: UpdateCloudGtmInstanceConfigBasicRequest, runtime: Util.RuntimeOptions): UpdateCloudGtmInstanceConfigBasicResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.scheduleHostname)) {
    query['ScheduleHostname'] = request.scheduleHostname;
  }
  if (!Util.isUnset(request.scheduleZoneName)) {
    query['ScheduleZoneName'] = request.scheduleZoneName;
  }
  if (!Util.isUnset(request.ttl)) {
    query['Ttl'] = request.ttl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCloudGtmInstanceConfigBasic',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the global time-to-live (TTL) configuration of a GTM 3.0 instance.
 *
 * @param request UpdateCloudGtmInstanceConfigBasicRequest
 * @return UpdateCloudGtmInstanceConfigBasicResponse
 */
async function updateCloudGtmInstanceConfigBasic(request: UpdateCloudGtmInstanceConfigBasicRequest): UpdateCloudGtmInstanceConfigBasicResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCloudGtmInstanceConfigBasicWithOptions(request, runtime);
}

model UpdateCloudGtmInstanceConfigEnableStatusRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   **zh-CN**: Chinese
*   **en-US** (default): English', example='zh-CN'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.

You can call the [ListCloudGtmInstanceConfigs](~~ListCloudGtmInstanceConfigs~~) operation to query the configuration ID of the access domain name.', example='Config-000**11'),
  enableStatus?: string(name='EnableStatus', description='The enabling state of the access domain name. Valid values:

*   enable
*   disable', example='enable'),
  instanceId?: string(name='InstanceId', description='The ID of the Global Traffic Manager (GTM) 3.0 instance.', example='gtm-cn-wwo3a3hbz**'),
}

model UpdateCloudGtmInstanceConfigEnableStatusResponseBody = {
  requestId?: string(name='RequestId', description='Unique request identification code.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
  success?: boolean(name='Success', description='Indicates whether the operation was successful: 
- **true**: The call succeeded. 
- **false**: The call failed.', example='true'),
}

model UpdateCloudGtmInstanceConfigEnableStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmInstanceConfigEnableStatusResponseBody(name='body'),
}

/**
 * @summary Modifies the enabling status of an access domain name.
 *
 * @description *   If an access domain name is **enabled** and the health state is **normal**, the access domain name is deemed **available**.
 * *   If an access domain name is **disabled** or the health state is **abnormal**, the access domain name is deemed **unavailable**.
 *
 * @param request UpdateCloudGtmInstanceConfigEnableStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCloudGtmInstanceConfigEnableStatusResponse
 */
async function updateCloudGtmInstanceConfigEnableStatusWithOptions(request: UpdateCloudGtmInstanceConfigEnableStatusRequest, runtime: Util.RuntimeOptions): UpdateCloudGtmInstanceConfigEnableStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  if (!Util.isUnset(request.enableStatus)) {
    query['EnableStatus'] = request.enableStatus;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCloudGtmInstanceConfigEnableStatus',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the enabling status of an access domain name.
 *
 * @description *   If an access domain name is **enabled** and the health state is **normal**, the access domain name is deemed **available**.
 * *   If an access domain name is **disabled** or the health state is **abnormal**, the access domain name is deemed **unavailable**.
 *
 * @param request UpdateCloudGtmInstanceConfigEnableStatusRequest
 * @return UpdateCloudGtmInstanceConfigEnableStatusResponse
 */
async function updateCloudGtmInstanceConfigEnableStatus(request: UpdateCloudGtmInstanceConfigEnableStatusRequest): UpdateCloudGtmInstanceConfigEnableStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCloudGtmInstanceConfigEnableStatusWithOptions(request, runtime);
}

model UpdateCloudGtmInstanceConfigLbStrategyRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language in which the returned results are displayed. Valid values:

*   **zh-CN**: Chinese
*   **en-US** (default): English', example='en-US'),
  addressPoolLbStrategy?: string(name='AddressPoolLbStrategy', description='The new policy for load balancing between address pools. Valid values:

*   round_robin: All address pools are returned for Domain Name System (DNS) requests from any source. All address pools are sorted in round-robin mode each time they are returned.
*   sequence: The address pool with the smallest sequence number is preferentially returned for DNS requests from any source. The sequence number indicates the priority for returning the address pool. A smaller sequence number indicates a higher priority. If the address pool with the smallest sequence number is unavailable, the address pool with the second smallest sequence number is returned.
*   weight: You can set a different weight value for each address pool. This way, address pools are returned based on the weight values.
*   source_nearest: GTM returns different address pools based on the sources of DNS requests. This way, users can access nearby address pools.', example='sequence'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.

You can call the [ListCloudGtmInstanceConfigs](~~ListCloudGtmInstanceConfigs~~) operation to query the configuration ID of the desired access domain name.', example='Config-000**11'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance for which you want to modify the load balancing policy.', example='gtm-cn-wwo3a3hbz**'),
  sequenceLbStrategyMode?: string(name='SequenceLbStrategyMode', description='The mode used if the address pool with the smallest sequence number is recovered. This parameter is required when AddressPoolLbStrategy is set to sequence. Valid values:

*   preemptive: The address pool with the smallest sequence number is preferentially used if this address pool is recovered.
*   non_preemptive: The current address pool is still used even if the address pool with the smallest sequence number is recovered.', example='preemptive'),
}

model UpdateCloudGtmInstanceConfigLbStrategyResponseBody = {
  requestId?: string(name='RequestId', example='0F32959D-417B-4D66-8463-68606605E3E2'),
  success?: boolean(name='Success', example='true'),
}

model UpdateCloudGtmInstanceConfigLbStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmInstanceConfigLbStrategyResponseBody(name='body'),
}

/**
 * @summary Modifies the load balancing policy of a Global Traffic Manager (GTM) 3.0 instance.
 *
 * @param request UpdateCloudGtmInstanceConfigLbStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCloudGtmInstanceConfigLbStrategyResponse
 */
async function updateCloudGtmInstanceConfigLbStrategyWithOptions(request: UpdateCloudGtmInstanceConfigLbStrategyRequest, runtime: Util.RuntimeOptions): UpdateCloudGtmInstanceConfigLbStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.addressPoolLbStrategy)) {
    query['AddressPoolLbStrategy'] = request.addressPoolLbStrategy;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.sequenceLbStrategyMode)) {
    query['SequenceLbStrategyMode'] = request.sequenceLbStrategyMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCloudGtmInstanceConfigLbStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the load balancing policy of a Global Traffic Manager (GTM) 3.0 instance.
 *
 * @param request UpdateCloudGtmInstanceConfigLbStrategyRequest
 * @return UpdateCloudGtmInstanceConfigLbStrategyResponse
 */
async function updateCloudGtmInstanceConfigLbStrategy(request: UpdateCloudGtmInstanceConfigLbStrategyRequest): UpdateCloudGtmInstanceConfigLbStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCloudGtmInstanceConfigLbStrategyWithOptions(request, runtime);
}

model UpdateCloudGtmInstanceConfigRemarkRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language in which the returned results are displayed. Valid values:

*   **zh-CN**: Chinese
*   **en-US** (default): English', example='en-US'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  configId?: string(name='ConfigId', description='The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.

You can call the [ListCloudGtmInstanceConfigs](~~ListCloudGtmInstanceConfigs~~) operation to query the configuration ID of the access domain name.', example='Config-000**11'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM 3.0 instance for which you want to modify the description.', example='gtm-cn-wwo3a3hbz**'),
  remark?: string(name='Remark', example='API'),
}

model UpdateCloudGtmInstanceConfigRemarkResponseBody = {
  requestId?: string(name='RequestId', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
  success?: boolean(name='Success', example='true'),
}

model UpdateCloudGtmInstanceConfigRemarkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmInstanceConfigRemarkResponseBody(name='body'),
}

/**
 * @summary Modifies the description of a Global Traffic Manager (GTM) 3.0 instance.
 *
 * @param request UpdateCloudGtmInstanceConfigRemarkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCloudGtmInstanceConfigRemarkResponse
 */
async function updateCloudGtmInstanceConfigRemarkWithOptions(request: UpdateCloudGtmInstanceConfigRemarkRequest, runtime: Util.RuntimeOptions): UpdateCloudGtmInstanceConfigRemarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCloudGtmInstanceConfigRemark',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the description of a Global Traffic Manager (GTM) 3.0 instance.
 *
 * @param request UpdateCloudGtmInstanceConfigRemarkRequest
 * @return UpdateCloudGtmInstanceConfigRemarkResponse
 */
async function updateCloudGtmInstanceConfigRemark(request: UpdateCloudGtmInstanceConfigRemarkRequest): UpdateCloudGtmInstanceConfigRemarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCloudGtmInstanceConfigRemarkWithOptions(request, runtime);
}

model UpdateCloudGtmInstanceNameRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US: English', example='en-US'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  instanceId?: string(name='InstanceId', description='The ID of the Global Traffic Manager (GTM) instance.', example='gtm-cn-jmp3qnw**03'),
  instanceName?: string(name='InstanceName', description='The name of the instance. You cannot leave this parameter empty.', example='test'),
}

model UpdateCloudGtmInstanceNameResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model UpdateCloudGtmInstanceNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmInstanceNameResponseBody(name='body'),
}

/**
 * @param request UpdateCloudGtmInstanceNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCloudGtmInstanceNameResponse
 */
async function updateCloudGtmInstanceNameWithOptions(request: UpdateCloudGtmInstanceNameRequest, runtime: Util.RuntimeOptions): UpdateCloudGtmInstanceNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCloudGtmInstanceName',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateCloudGtmInstanceNameRequest
 * @return UpdateCloudGtmInstanceNameResponse
 */
async function updateCloudGtmInstanceName(request: UpdateCloudGtmInstanceNameRequest): UpdateCloudGtmInstanceNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCloudGtmInstanceNameWithOptions(request, runtime);
}

model UpdateCloudGtmMonitorTemplateRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  evaluationCount?: int32(name='EvaluationCount', description='The number of retries. The system will only judge the application service as abnormal after consecutive monitoring failures to prevent inaccurate monitoring results due to momentary network fluctuations or other reasons. Available retry options are:
- 1 
- 2 
- 3', example='2'),
  extendInfo?: string(name='ExtendInfo', description='The extended information. The value of this parameter is a JSON string. The required parameters vary based on the health check protocol.

*   HTTP or HTTPS:

    host: the Host field of an HTTP or HTTPS request header during an HTTP or HTTPS health check. The parameter value indicates the HTTP website that you want to visit. By default, the value is the primary domain name. You can change the value based on your business requirements.

    path: the URL for HTTP or HTTPS health checks. Default value: /.

    code: the alert threshold. During an HTTP or HTTPS health check, the system checks whether a web server functions as expected based on the status code that is returned from the web server. If the returned status code is greater than the specified threshold, the corresponding application service address is deemed abnormal. Valid values:

    *   400: specifies an invalid request. If an HTTP or HTTPS request contains invalid request parameters, a web server returns a status code that is greater than 400. You must set path to an exact URL if you set code to 400.
    *   500: specifies a server error. If some exceptions occur on a web server, the web server returns a status code that is greater than 500. This value is used by default.

    sni: specifies whether to enable Server Name Indication (SNI). This parameter is used only when the health check protocol is HTTPS. SNI is an extension to the Transport Layer Security (TLS) protocol, which allows a client to specify the host to be connected when the client sends a TLS handshake request. TLS handshakes occur before any data of HTTP requests is sent. Therefore, SNI enables servers to identify the services that clients are attempting to access before certificates are sent. This allows the servers to present correct certificates to the clients. Valid values:

    *   true: enables SNI.
    *   false: disables SNI.

    followRedirect: specifies whether to follow 3XX redirects. Valid values:

    *   true: follows 3XX redirects. You are redirected to the destination address if a 3XX status code such as 301, 302, 303, 307, or 308 is returned.
    *   false: does not follow 3XX redirects.

*   ping:

    packetNum: the total number of Internet Control Message Protocol (ICMP) packets that are sent to the address for each ping-based health check. Valid values: 20, 50, and 100.

    packetLossRate: the ICMP packet loss rate for each ping-based health check. The packet loss rate in a health check can be calculated by using the following formula: Packet loss rate in a health check = (Number of lost packets/Total number of sent ICMP packets)  100%. If the packet loss rate reaches the threshold, an alert is triggered. Valid values: 10, 30, 40, 80, 90, and 100.', example='{\\\\"code\\\\":200,\\\\"path\\\\":\\\\"\\\\\\\\index.htm\\\\",\\\\"host\\\\":\\\\"aliyun.com\\\\"}'),
  failureRate?: int32(name='FailureRate', description='Percentage of selected node probe failures (%), that is, the percentage of abnormal detection points among the total detection points. When the failure ratio exceeds the set threshold, the service address is judged as abnormal. The available failure ratio thresholds are:
- 20
- 50
- 80
- 100', example='50'),
  interval?: int32(name='Interval', description='The time interval (in seconds) for each health check probe. By default, it probes every 60 seconds. The minimum supported interval for health checks is 15 seconds, available for flagship edition instances.', example='60'),
  ispCityNodes?: [ 
    {
      cityCode?: string(name='CityCode', description='The city code of the health check node.', example='503'),
      ispCode?: string(name='IspCode', description='The Internet service provider (ISP) code of the health check node.', example='465'),
    }
  ](name='IspCityNodes', description='The health check nodes. You can call the [ListCloudGtmMonitorNodes](https://help.aliyun.com/document_detail/2797327.html) operation to obtain the health check nodes.'),
  name?: string(name='Name', description='The name of the health check probe template, which is generally recommended to be distinguishable and memorable for configuration personnel, ideally indicating the health check protocol for easier identification.', example='Ping-IPv4'),
  templateId?: string(name='TemplateId', description='The ID of the health check template that you want to modify. This ID uniquely identifies the health check template.

This parameter is required.', example='mtp-89518052425100**80'),
  timeout?: int32(name='Timeout', description='Probe timeout (in milliseconds), data packets not returned within the timeout period are considered as health check timeouts:
- 2000
- 3000
- 5000
- 10000', example='5000'),
}

model UpdateCloudGtmMonitorTemplateShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US (default): English', example='en-US'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  evaluationCount?: int32(name='EvaluationCount', description='The number of retries. The system will only judge the application service as abnormal after consecutive monitoring failures to prevent inaccurate monitoring results due to momentary network fluctuations or other reasons. Available retry options are:
- 1 
- 2 
- 3', example='2'),
  extendInfo?: string(name='ExtendInfo', description='The extended information. The value of this parameter is a JSON string. The required parameters vary based on the health check protocol.

*   HTTP or HTTPS:

    host: the Host field of an HTTP or HTTPS request header during an HTTP or HTTPS health check. The parameter value indicates the HTTP website that you want to visit. By default, the value is the primary domain name. You can change the value based on your business requirements.

    path: the URL for HTTP or HTTPS health checks. Default value: /.

    code: the alert threshold. During an HTTP or HTTPS health check, the system checks whether a web server functions as expected based on the status code that is returned from the web server. If the returned status code is greater than the specified threshold, the corresponding application service address is deemed abnormal. Valid values:

    *   400: specifies an invalid request. If an HTTP or HTTPS request contains invalid request parameters, a web server returns a status code that is greater than 400. You must set path to an exact URL if you set code to 400.
    *   500: specifies a server error. If some exceptions occur on a web server, the web server returns a status code that is greater than 500. This value is used by default.

    sni: specifies whether to enable Server Name Indication (SNI). This parameter is used only when the health check protocol is HTTPS. SNI is an extension to the Transport Layer Security (TLS) protocol, which allows a client to specify the host to be connected when the client sends a TLS handshake request. TLS handshakes occur before any data of HTTP requests is sent. Therefore, SNI enables servers to identify the services that clients are attempting to access before certificates are sent. This allows the servers to present correct certificates to the clients. Valid values:

    *   true: enables SNI.
    *   false: disables SNI.

    followRedirect: specifies whether to follow 3XX redirects. Valid values:

    *   true: follows 3XX redirects. You are redirected to the destination address if a 3XX status code such as 301, 302, 303, 307, or 308 is returned.
    *   false: does not follow 3XX redirects.

*   ping:

    packetNum: the total number of Internet Control Message Protocol (ICMP) packets that are sent to the address for each ping-based health check. Valid values: 20, 50, and 100.

    packetLossRate: the ICMP packet loss rate for each ping-based health check. The packet loss rate in a health check can be calculated by using the following formula: Packet loss rate in a health check = (Number of lost packets/Total number of sent ICMP packets)  100%. If the packet loss rate reaches the threshold, an alert is triggered. Valid values: 10, 30, 40, 80, 90, and 100.', example='{\\\\"code\\\\":200,\\\\"path\\\\":\\\\"\\\\\\\\index.htm\\\\",\\\\"host\\\\":\\\\"aliyun.com\\\\"}'),
  failureRate?: int32(name='FailureRate', description='Percentage of selected node probe failures (%), that is, the percentage of abnormal detection points among the total detection points. When the failure ratio exceeds the set threshold, the service address is judged as abnormal. The available failure ratio thresholds are:
- 20
- 50
- 80
- 100', example='50'),
  interval?: int32(name='Interval', description='The time interval (in seconds) for each health check probe. By default, it probes every 60 seconds. The minimum supported interval for health checks is 15 seconds, available for flagship edition instances.', example='60'),
  ispCityNodesShrink?: string(name='IspCityNodes', description='The health check nodes. You can call the [ListCloudGtmMonitorNodes](https://help.aliyun.com/document_detail/2797327.html) operation to obtain the health check nodes.'),
  name?: string(name='Name', description='The name of the health check probe template, which is generally recommended to be distinguishable and memorable for configuration personnel, ideally indicating the health check protocol for easier identification.', example='Ping-IPv4'),
  templateId?: string(name='TemplateId', description='The ID of the health check template that you want to modify. This ID uniquely identifies the health check template.

This parameter is required.', example='mtp-89518052425100**80'),
  timeout?: int32(name='Timeout', description='Probe timeout (in milliseconds), data packets not returned within the timeout period are considered as health check timeouts:
- 2000
- 3000
- 5000
- 10000', example='5000'),
}

model UpdateCloudGtmMonitorTemplateResponseBody = {
  requestId?: string(name='RequestId', description='Unique request identification code.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  success?: boolean(name='Success', description='Modify the health check template operation status:
- true: Operation successful
- false: Operation failed', example='true'),
}

model UpdateCloudGtmMonitorTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmMonitorTemplateResponseBody(name='body'),
}

/**
 * @summary Modifies the information about a health check template.
 *
 * @param tmpReq UpdateCloudGtmMonitorTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCloudGtmMonitorTemplateResponse
 */
async function updateCloudGtmMonitorTemplateWithOptions(tmpReq: UpdateCloudGtmMonitorTemplateRequest, runtime: Util.RuntimeOptions): UpdateCloudGtmMonitorTemplateResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateCloudGtmMonitorTemplateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.ispCityNodes)) {
    request.ispCityNodesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ispCityNodes, 'IspCityNodes', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.extendInfo)) {
    query['ExtendInfo'] = request.extendInfo;
  }
  if (!Util.isUnset(request.failureRate)) {
    query['FailureRate'] = request.failureRate;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispCityNodesShrink)) {
    query['IspCityNodes'] = request.ispCityNodesShrink;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCloudGtmMonitorTemplate',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the information about a health check template.
 *
 * @param request UpdateCloudGtmMonitorTemplateRequest
 * @return UpdateCloudGtmMonitorTemplateResponse
 */
async function updateCloudGtmMonitorTemplate(request: UpdateCloudGtmMonitorTemplateRequest): UpdateCloudGtmMonitorTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCloudGtmMonitorTemplateWithOptions(request, runtime);
}

model UpdateCloudGtmMonitorTemplateRemarkRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The language of the response. Valid values:

*   zh-CN: Chinese
*   en-US: English', example='en-US'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='1ae05db4-10e7-11ef-b126-00163e24**22'),
  remark?: string(name='Remark', description='The new description of the template. If you do not specify this parameter, the original description is deleted.', example='test'),
  templateId?: string(name='TemplateId', description='The ID of the health check template. This ID uniquely identifies a health check template.

This parameter is required.', example='mtp-89518052455928**00'),
}

model UpdateCloudGtmMonitorTemplateRemarkResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
  success?: boolean(name='Success', description='Modify the health check template remark operation status:
- true: Operation successful
- false: Operation failed', example='true'),
}

model UpdateCloudGtmMonitorTemplateRemarkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCloudGtmMonitorTemplateRemarkResponseBody(name='body'),
}

/**
 * @param request UpdateCloudGtmMonitorTemplateRemarkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCloudGtmMonitorTemplateRemarkResponse
 */
async function updateCloudGtmMonitorTemplateRemarkWithOptions(request: UpdateCloudGtmMonitorTemplateRemarkRequest, runtime: Util.RuntimeOptions): UpdateCloudGtmMonitorTemplateRemarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCloudGtmMonitorTemplateRemark',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateCloudGtmMonitorTemplateRemarkRequest
 * @return UpdateCloudGtmMonitorTemplateRemarkResponse
 */
async function updateCloudGtmMonitorTemplateRemark(request: UpdateCloudGtmMonitorTemplateRemarkRequest): UpdateCloudGtmMonitorTemplateRemarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCloudGtmMonitorTemplateRemarkWithOptions(request, runtime);
}

model UpdateCustomLineRequest {
  ipSegment?: [ 
    {
      endIp?: string(name='EndIp', description='The end IP address of the CIDR block.', example='2.2.2.2'),
      startIp?: string(name='StartIp', description='The start IP address of the CIDR block.', example='1.1.1.1'),
    }
  ](name='IpSegment', description='The CIDR blocks. Separate IP addresses with a hyphen (-). Enter a CIDR block in each row. You can enter 1 to 50 CIDR blocks at a time. If a CIDR block contains only one IP address, enter the IP address in the format of IP1-IP1. Different CIDR blocks cannot be overlapped.'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  lineId?: long(name='LineId', description='The unique ID of the custom line. You can call the [DescribeCustomLines](https://www.alibabacloud.com/help/en/dns/api-alidns-2015-01-09-describecustomlines?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the unique ID.

This parameter is required.', example='1234'),
  lineName?: string(name='LineName', description='The name of the custom line. The name must be 1 to 20 characters in length and can contain letters, digits, hyphens (-), and underscores (_).'),
}

model UpdateCustomLineResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='B57C121B-A45F-44D8-A9B2-13E5A5044195'),
}

model UpdateCustomLineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCustomLineResponseBody(name='body'),
}

/**
 * @summary Modifies a custom line with its unique ID.
 *
 * @description In each CIDR block, the end IP address must be greater than or equal to the start IP address.\\
 * The CIDR blocks that are specified for all custom lines of a domain name cannot be overlapped.
 *
 * @param request UpdateCustomLineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCustomLineResponse
 */
async function updateCustomLineWithOptions(request: UpdateCustomLineRequest, runtime: Util.RuntimeOptions): UpdateCustomLineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ipSegment)) {
    query['IpSegment'] = request.ipSegment;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lineId)) {
    query['LineId'] = request.lineId;
  }
  if (!Util.isUnset(request.lineName)) {
    query['LineName'] = request.lineName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCustomLine',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a custom line with its unique ID.
 *
 * @description In each CIDR block, the end IP address must be greater than or equal to the start IP address.\\
 * The CIDR blocks that are specified for all custom lines of a domain name cannot be overlapped.
 *
 * @param request UpdateCustomLineRequest
 * @return UpdateCustomLineResponse
 */
async function updateCustomLine(request: UpdateCustomLineRequest): UpdateCustomLineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCustomLineWithOptions(request, runtime);
}

model UpdateDNSSLBWeightRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  recordId?: string(name='RecordId', description='The ID of the DNS record. You can call the [DescribeDomainRecords](https://www.alibabacloud.com/help/en/dns/api-alidns-2015-01-09-describedomainrecords?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.

This parameter is required.', example='9999985'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='1.1.1.1'),
  weight?: int32(name='Weight', description='The weight of the DNS record that you want to specify. Valid values: `1 to 100`.

This parameter is required.', example='2'),
}

model UpdateDNSSLBWeightResponseBody = {
  recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
  weight?: int32(name='Weight', description='The updated weight.', example='2'),
}

model UpdateDNSSLBWeightResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDNSSLBWeightResponseBody(name='body'),
}

/**
 * @summary Modifies the weight of a Domain Name System (DNS) record based on the specified parameters.
 *
 * @param request UpdateDNSSLBWeightRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDNSSLBWeightResponse
 */
async function updateDNSSLBWeightWithOptions(request: UpdateDNSSLBWeightRequest, runtime: Util.RuntimeOptions): UpdateDNSSLBWeightResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recordId)) {
    query['RecordId'] = request.recordId;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  if (!Util.isUnset(request.weight)) {
    query['Weight'] = request.weight;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDNSSLBWeight',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the weight of a Domain Name System (DNS) record based on the specified parameters.
 *
 * @param request UpdateDNSSLBWeightRequest
 * @return UpdateDNSSLBWeightResponse
 */
async function updateDNSSLBWeight(request: UpdateDNSSLBWeightRequest): UpdateDNSSLBWeightResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDNSSLBWeightWithOptions(request, runtime);
}

model UpdateDnsCacheDomainRequest {
  cacheTtlMax?: int32(name='CacheTtlMax', description='The maximum TTL period of the cached data retrieved from the origin DNS server. Unit: seconds. Valid values: 30 to 86400.', example='86400'),
  cacheTtlMin?: int32(name='CacheTtlMin', description='The minimum time-to-live (TTL) period of the cached data retrieved from the origin Domain Name System (DNS) server. Unit: seconds. Valid values: 30 to 86400.', example='30'),
  domainName?: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtian the domain name.

This parameter is required.', example='dns.example.com'),
  instanceId?: string(name='InstanceId', description='The instance ID of the cache-accelerated domain name. You can call the [ListCloudGtmInstances](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-listcloudgtminstances?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.', example='dns-sg-l9u2ux1fw01'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English Default: **zh**', example='en'),
  sourceDnsServer?: [ 
    {
      host?: string(name='Host', description='The domain name or IP address of the origin DNS server.', example='223.5.5.5'),
      port?: string(name='Port', description='The port of the origin DNS server.', example='53'),
    }
  ](name='SourceDnsServer', description='The origin DNS servers. A maximum of 10 origin DNS servers are supported.'),
  sourceEdns?: string(name='SourceEdns', description='Specifies whether the origin DNS server supports Extension Mechanisms for DNS (EDNS). Valid values: NOT_SUPPORT and SUPPORT.', example='SUPPORT'),
  sourceProtocol?: string(name='SourceProtocol', description='The origin protocol policy. Valid values: TCP and UDP. Default value: UDP.', example='UDP'),
}

model UpdateDnsCacheDomainResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model UpdateDnsCacheDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDnsCacheDomainResponseBody(name='body'),
}

/**
 * @summary Updates the cache-accelerated domain name based on the specified parameters.
 *
 * @param request UpdateDnsCacheDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDnsCacheDomainResponse
 */
async function updateDnsCacheDomainWithOptions(request: UpdateDnsCacheDomainRequest, runtime: Util.RuntimeOptions): UpdateDnsCacheDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cacheTtlMax)) {
    query['CacheTtlMax'] = request.cacheTtlMax;
  }
  if (!Util.isUnset(request.cacheTtlMin)) {
    query['CacheTtlMin'] = request.cacheTtlMin;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceDnsServer)) {
    query['SourceDnsServer'] = request.sourceDnsServer;
  }
  if (!Util.isUnset(request.sourceEdns)) {
    query['SourceEdns'] = request.sourceEdns;
  }
  if (!Util.isUnset(request.sourceProtocol)) {
    query['SourceProtocol'] = request.sourceProtocol;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDnsCacheDomain',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the cache-accelerated domain name based on the specified parameters.
 *
 * @param request UpdateDnsCacheDomainRequest
 * @return UpdateDnsCacheDomainResponse
 */
async function updateDnsCacheDomain(request: UpdateDnsCacheDomainRequest): UpdateDnsCacheDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDnsCacheDomainWithOptions(request, runtime);
}

model UpdateDnsCacheDomainRemarkRequest {
  domainName?: string(name='DomainName', description='The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.

This parameter is required.', example='dns-example.com'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English

Default: **zh**', example='en'),
  remark?: string(name='Remark', description='The remarks. The remarks can be up to 50 characters in length and can contain only letters, digits, periods (.), underscores (_), and hyphens (-).

Delete the original remarks when it is empty.', example='test'),
}

model UpdateDnsCacheDomainRemarkResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model UpdateDnsCacheDomainRemarkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDnsCacheDomainRemarkResponseBody(name='body'),
}

/**
 * @summary Updates the remarks for the cache-accelerated domain name of the destination domain name.
 *
 * @param request UpdateDnsCacheDomainRemarkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDnsCacheDomainRemarkResponse
 */
async function updateDnsCacheDomainRemarkWithOptions(request: UpdateDnsCacheDomainRemarkRequest, runtime: Util.RuntimeOptions): UpdateDnsCacheDomainRemarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDnsCacheDomainRemark',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the remarks for the cache-accelerated domain name of the destination domain name.
 *
 * @param request UpdateDnsCacheDomainRemarkRequest
 * @return UpdateDnsCacheDomainRemarkResponse
 */
async function updateDnsCacheDomainRemark(request: UpdateDnsCacheDomainRemarkRequest): UpdateDnsCacheDomainRemarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDnsCacheDomainRemarkWithOptions(request, runtime);
}

model UpdateDnsGtmAccessStrategyRequest {
  accessMode?: string(name='AccessMode', description='The primary/secondary switchover policy for address pool sets. Valid values:

*   AUTO: performs automatic switchover between the primary and secondary address pool sets upon failures.
*   DEFAULT: the primary address pool set
*   FAILOVER: the secondary address pool set', example='DEFAULT'),
  defaultAddrPool?: [ 
    {
      id?: string(name='Id', description='The ID of the address pool in the primary address pool set.', example='pool1'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool in the primary address pool set.', example='1'),
    }
  ](name='DefaultAddrPool', description='The address pools in the primary address pool set.

This parameter is required.'),
  defaultAddrPoolType?: string(name='DefaultAddrPoolType', description='The type of the primary address pool. Valid values:

*   IPV4
*   IPV6
*   DOMAIN

This parameter is required.', example='ipv4'),
  defaultLatencyOptimization?: string(name='DefaultLatencyOptimization', description='Specifies whether to enable Domain Name System (DNS) resolution with optimal latency for the primary address pool set. Valid values:

*   OPEN
*   CLOSE', example='open'),
  defaultLbaStrategy?: string(name='DefaultLbaStrategy', description='The load balancing policy of the primary address pool set. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr'),
  defaultMaxReturnAddrNum?: int32(name='DefaultMaxReturnAddrNum', description='The maximum number of addresses returned from the primary address pool set.', example='1'),
  defaultMinAvailableAddrNum?: int32(name='DefaultMinAvailableAddrNum', description='The minimum number of available addresses in the primary address pool set.

This parameter is required.', example='1'),
  failoverAddrPool?: [ 
    {
      id?: string(name='Id', description='The ID of the address pool in the secondary address pool set.', example='pool1'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool in the secondary address pool set.', example='1'),
    }
  ](name='FailoverAddrPool', description='The address pools in the secondary address pool set. If no address pool exists in the secondary address pool set, set this parameter to EMPTY.'),
  failoverAddrPoolType?: string(name='FailoverAddrPoolType', description='The type of the secondary address pool. Valid values:

*   IPV4
*   IPV6
*   DOMAIN', example='ipv4'),
  failoverLatencyOptimization?: string(name='FailoverLatencyOptimization', description='Specifies whether to enable DNS resolution with optimal latency for the secondary address pool set. Valid values:

*   OPEN
*   CLOSE', example='open'),
  failoverLbaStrategy?: string(name='FailoverLbaStrategy', description='The load balancing policy of the secondary address pool set. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.', example='all_rr'),
  failoverMaxReturnAddrNum?: int32(name='FailoverMaxReturnAddrNum', description='The maximum number of addresses returned from the secondary address pool set.', example='1'),
  failoverMinAvailableAddrNum?: int32(name='FailoverMinAvailableAddrNum', description='The minimum number of available addresses in the secondary address pool set.', example='1'),
  lang?: string(name='Lang', description='The language of the values for specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  lines?: string(name='Lines', description='The line codes of the source regions. Example: `["default", "drpeng"]`, which indicates the global line and Dr. Peng Group line.', example='["default", "drpeng"]'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy.

This parameter is required.', example='StrategyId1'),
  strategyName?: string(name='StrategyName', description='The name of the access policy.

This parameter is required.', example='StrategyName1'),
}

model UpdateDnsGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy.', example='testStrategyId1'),
}

model UpdateDnsGtmAccessStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDnsGtmAccessStrategyResponseBody(name='body'),
}

/**
 * @summary Modifies an access policy.
 *
 * @param request UpdateDnsGtmAccessStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDnsGtmAccessStrategyResponse
 */
async function updateDnsGtmAccessStrategyWithOptions(request: UpdateDnsGtmAccessStrategyRequest, runtime: Util.RuntimeOptions): UpdateDnsGtmAccessStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessMode)) {
    query['AccessMode'] = request.accessMode;
  }
  if (!Util.isUnset(request.defaultAddrPool)) {
    query['DefaultAddrPool'] = request.defaultAddrPool;
  }
  if (!Util.isUnset(request.defaultAddrPoolType)) {
    query['DefaultAddrPoolType'] = request.defaultAddrPoolType;
  }
  if (!Util.isUnset(request.defaultLatencyOptimization)) {
    query['DefaultLatencyOptimization'] = request.defaultLatencyOptimization;
  }
  if (!Util.isUnset(request.defaultLbaStrategy)) {
    query['DefaultLbaStrategy'] = request.defaultLbaStrategy;
  }
  if (!Util.isUnset(request.defaultMaxReturnAddrNum)) {
    query['DefaultMaxReturnAddrNum'] = request.defaultMaxReturnAddrNum;
  }
  if (!Util.isUnset(request.defaultMinAvailableAddrNum)) {
    query['DefaultMinAvailableAddrNum'] = request.defaultMinAvailableAddrNum;
  }
  if (!Util.isUnset(request.failoverAddrPool)) {
    query['FailoverAddrPool'] = request.failoverAddrPool;
  }
  if (!Util.isUnset(request.failoverAddrPoolType)) {
    query['FailoverAddrPoolType'] = request.failoverAddrPoolType;
  }
  if (!Util.isUnset(request.failoverLatencyOptimization)) {
    query['FailoverLatencyOptimization'] = request.failoverLatencyOptimization;
  }
  if (!Util.isUnset(request.failoverLbaStrategy)) {
    query['FailoverLbaStrategy'] = request.failoverLbaStrategy;
  }
  if (!Util.isUnset(request.failoverMaxReturnAddrNum)) {
    query['FailoverMaxReturnAddrNum'] = request.failoverMaxReturnAddrNum;
  }
  if (!Util.isUnset(request.failoverMinAvailableAddrNum)) {
    query['FailoverMinAvailableAddrNum'] = request.failoverMinAvailableAddrNum;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lines)) {
    query['Lines'] = request.lines;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  if (!Util.isUnset(request.strategyName)) {
    query['StrategyName'] = request.strategyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDnsGtmAccessStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies an access policy.
 *
 * @param request UpdateDnsGtmAccessStrategyRequest
 * @return UpdateDnsGtmAccessStrategyResponse
 */
async function updateDnsGtmAccessStrategy(request: UpdateDnsGtmAccessStrategyRequest): UpdateDnsGtmAccessStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDnsGtmAccessStrategyWithOptions(request, runtime);
}

model UpdateDnsGtmAddressPoolRequest {
  addr?: [ 
    {
      addr?: string(name='Addr', description='The address in the address pool.

This parameter is required.', example='1.1.1.1'),
      attributeInfo?: string(name='AttributeInfo', description='The information about the source region of the address. The value of the parameter is a string in the JSON format. Valid values:

*   LineCode: the line code of the source region. This parameter is deprecated. Use lineCodes instead.

*   lineCodes: the line codes of the source region

*   lineCodeRectifyType: the rectification type of the line code. Default value: AUTO. Valid values:

    *   NO_NEED: no need for rectification
    *   RECTIFIED: rectified
    *   AUTO: automatic rectification', example='Linecode:default,lineCodes:["default"],lineCodeRectifyType:"NO_NEED"'),
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address.', example='1'),
      mode?: string(name='Mode', description='The return mode of the addresses. Valid values:

*   SMART: smart return
*   ONLINE: always online
*   OFFLINE: always offline

This parameter is required.', example='online'),
      remark?: string(name='Remark', description='The description of the address pool.', example='test'),
    }
  ](name='Addr', description='The address pools.

This parameter is required.'),
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool.

This parameter is required.', example='testpool1'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  lbaStrategy?: string(name='LbaStrategy', description='The load balancing policy of the address pool. Valid values:

*   ALL_RR: returns all addresses.
*   RATIO: returns addresses by weight.

This parameter is required.', example='all_rr'),
  name?: string(name='Name', description='The name of the address pool.', example='testpoolname'),
}

model UpdateDnsGtmAddressPoolResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model UpdateDnsGtmAddressPoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDnsGtmAddressPoolResponseBody(name='body'),
}

/**
 * @summary Modifies an address pool.
 *
 * @param request UpdateDnsGtmAddressPoolRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDnsGtmAddressPoolResponse
 */
async function updateDnsGtmAddressPoolWithOptions(request: UpdateDnsGtmAddressPoolRequest, runtime: Util.RuntimeOptions): UpdateDnsGtmAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addr)) {
    query['Addr'] = request.addr;
  }
  if (!Util.isUnset(request.addrPoolId)) {
    query['AddrPoolId'] = request.addrPoolId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lbaStrategy)) {
    query['LbaStrategy'] = request.lbaStrategy;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDnsGtmAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies an address pool.
 *
 * @param request UpdateDnsGtmAddressPoolRequest
 * @return UpdateDnsGtmAddressPoolResponse
 */
async function updateDnsGtmAddressPool(request: UpdateDnsGtmAddressPoolRequest): UpdateDnsGtmAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDnsGtmAddressPoolWithOptions(request, runtime);
}

model UpdateDnsGtmInstanceGlobalConfigRequest {
  alertConfig?: [ 
    {
      dingtalkNotice?: boolean(name='DingtalkNotice', example='true'),
      emailNotice?: boolean(name='EmailNotice', example='true'),
      noticeType?: string(name='NoticeType', example='ADDR_ALERT'),
      smsNotice?: boolean(name='SmsNotice', example='true'),
    }
  ](name='AlertConfig'),
  alertGroup?: string(name='AlertGroup', description='The name of the alert group in the JSON format.', example='alertGroup1'),
  cnameType?: string(name='CnameType', description='The type of the canonical name (CNAME).

*   Set the value to PUBLIC.', example='public'),
  forceUpdate?: boolean(name='ForceUpdate', description='Specifies whether to enable force updates. Valid values:

*   true: enables force update without a conflict alert.
*   false: disables force update. If a conflict occurs, the system displays an alert. null: This valid value of ForceUpdate provides the same information as the false value.', example='true'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='instance1'),
  instanceName?: string(name='InstanceName', description='The name of the instance. This parameter is required only for the first update.', example='test'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  publicCnameMode?: string(name='PublicCnameMode', description='Specifies whether to use a custom CNAME domain name or a CNAME domain name assigned by the system to access the instance over the Internet. Valid values:

*   SYSTEM_ASSIGN: a CNAME domain name assigned by the system
*   CUSTOM: a custom CNAME domain name', example='custom'),
  publicRr?: string(name='PublicRr', description='The hostname corresponding to the CNAME domain name that is used to access the instance over the Internet.', example='test.rr'),
  publicUserDomainName?: string(name='PublicUserDomainName', description='The service domain name that is used over the Internet.', example='example.com'),
  publicZoneName?: string(name='PublicZoneName', description='The CNAME domain name that is used to access the instance over the Internet, which is the primary domain name. This parameter is required when the PublicCnameMode parameter is set to CUSTOM.

>  You must use the primary domain name. Do not include the hostname specified by the PublicRr parameter.', example='gtm-003.com'),
  ttl?: int32(name='Ttl', description='The global time to live (TTL).', example='1'),
}

model UpdateDnsGtmInstanceGlobalConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
}

model UpdateDnsGtmInstanceGlobalConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDnsGtmInstanceGlobalConfigResponseBody(name='body'),
}

/**
 * @summary Modifies the configurations of a Global Traffic Manager (GTM) instance.
 *
 * @param request UpdateDnsGtmInstanceGlobalConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDnsGtmInstanceGlobalConfigResponse
 */
async function updateDnsGtmInstanceGlobalConfigWithOptions(request: UpdateDnsGtmInstanceGlobalConfigRequest, runtime: Util.RuntimeOptions): UpdateDnsGtmInstanceGlobalConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertConfig)) {
    query['AlertConfig'] = request.alertConfig;
  }
  if (!Util.isUnset(request.alertGroup)) {
    query['AlertGroup'] = request.alertGroup;
  }
  if (!Util.isUnset(request.cnameType)) {
    query['CnameType'] = request.cnameType;
  }
  if (!Util.isUnset(request.forceUpdate)) {
    query['ForceUpdate'] = request.forceUpdate;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.publicCnameMode)) {
    query['PublicCnameMode'] = request.publicCnameMode;
  }
  if (!Util.isUnset(request.publicRr)) {
    query['PublicRr'] = request.publicRr;
  }
  if (!Util.isUnset(request.publicUserDomainName)) {
    query['PublicUserDomainName'] = request.publicUserDomainName;
  }
  if (!Util.isUnset(request.publicZoneName)) {
    query['PublicZoneName'] = request.publicZoneName;
  }
  if (!Util.isUnset(request.ttl)) {
    query['Ttl'] = request.ttl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDnsGtmInstanceGlobalConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the configurations of a Global Traffic Manager (GTM) instance.
 *
 * @param request UpdateDnsGtmInstanceGlobalConfigRequest
 * @return UpdateDnsGtmInstanceGlobalConfigResponse
 */
async function updateDnsGtmInstanceGlobalConfig(request: UpdateDnsGtmInstanceGlobalConfigRequest): UpdateDnsGtmInstanceGlobalConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDnsGtmInstanceGlobalConfigWithOptions(request, runtime);
}

model UpdateDnsGtmMonitorRequest {
  evaluationCount?: int32(name='EvaluationCount', description='The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.', example='2'),
  interval?: int32(name='Interval', description='The health check interval. Unit: seconds.', example='60'),
  ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the city where the monitored node is deployed.', example='123'),
      ispCode?: string(name='IspCode', description='The code of the Internet service provider (ISP) to which the monitored node belongs.', example='123'),
    }
  ](name='IspCityNode', description='The monitored nodes.

This parameter is required.'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.', example='en'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.

This parameter is required.', example='MonitorConfigId1'),
  monitorExtendInfo?: string(name='MonitorExtendInfo', description='The extended information. The required parameters vary based on the health check protocol.

*   HTTP or HTTPS

    *   port: the port that you want to check

    *   host: the host settings

    *   path: the URL path

    *   code: the return code. If the return value of code is greater than the specified value, the health check result is deemed abnormal. For example, if code is set to 400 and the code 404 is returned, the health check result is deemed abnormal.

    *   failureRate: the failure rate

    *   sni: specifies whether to enable server name indication (SNI). This parameter is available only when ProtocolType is set to HTTPS. Valid values:

        *   true: enables SNI.
        *   false: disables SNI.

    *   nodeType: the type of the monitoring node when the address pool type is domain name. Valid values:

        *   IPV4
        *   IPV6

*   PING

    *   failureRate: the failure rate

    *   packetNum: the number of ping packets

    *   packetLossRate: the loss rate of ping packets

    *   nodeType: the type of the monitoring node when the address pool type is domain name. Valid values:

        *   IPV4
        *   IPV6

*   TCP

    *   port: the port that you want to check

    *   failureRate: the failure rate

    *   nodeType: the type of the monitoring node when the address pool type is domain name. Valid values:

        *   IPV4
        *   IPV6

This parameter is required.', example='{\\\\"code\\\\":200,\\\\"path\\\\":\\\\"\\\\\\\\index.htm\\\\",\\\\"host\\\\":\\\\"aliyun.com\\\\"}'),
  protocolType?: string(name='ProtocolType', description='The protocol used for the health check. Valid values:

*   HTTP
*   HTTPS
*   PING
*   TCP

This parameter is required.', example='http'),
  timeout?: int32(name='Timeout', description='The timeout period. Unit: milliseconds.', example='3000'),
}

model UpdateDnsGtmMonitorResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model UpdateDnsGtmMonitorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDnsGtmMonitorResponseBody(name='body'),
}

/**
 * @summary Modifies a health check task.
 *
 * @param request UpdateDnsGtmMonitorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDnsGtmMonitorResponse
 */
async function updateDnsGtmMonitorWithOptions(request: UpdateDnsGtmMonitorRequest, runtime: Util.RuntimeOptions): UpdateDnsGtmMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispCityNode)) {
    query['IspCityNode'] = request.ispCityNode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.monitorConfigId)) {
    query['MonitorConfigId'] = request.monitorConfigId;
  }
  if (!Util.isUnset(request.monitorExtendInfo)) {
    query['MonitorExtendInfo'] = request.monitorExtendInfo;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDnsGtmMonitor',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a health check task.
 *
 * @param request UpdateDnsGtmMonitorRequest
 * @return UpdateDnsGtmMonitorResponse
 */
async function updateDnsGtmMonitor(request: UpdateDnsGtmMonitorRequest): UpdateDnsGtmMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDnsGtmMonitorWithOptions(request, runtime);
}

model UpdateDomainGroupRequest {
  groupId?: string(name='GroupId', description='The ID of the domain name group whose name you want to modify. You can call the [DescribeDomainGroups ](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomaingroups?spm=a2c63.p38356.help-menu-search-29697.d_0)operation to obtain the ID.

This parameter is required.', example='2223'),
  groupName?: string(name='GroupName', description='The new name of the domain name group.

This parameter is required.', example='NewName'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en.', example='en'),
}

model UpdateDomainGroupResponseBody = {
  groupId?: string(name='GroupId', description='The ID of the domain name group.', example='2223'),
  groupName?: string(name='GroupName', description='The new name of the domain name group.', example='NewName'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model UpdateDomainGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDomainGroupResponseBody(name='body'),
}

/**
 * @summary Modifies the name of a domain name group based on the specified parameters.
 *
 * @description Modifies the name of an existing domain name group.
 *
 * @param request UpdateDomainGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDomainGroupResponse
 */
async function updateDomainGroupWithOptions(request: UpdateDomainGroupRequest, runtime: Util.RuntimeOptions): UpdateDomainGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDomainGroup',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the name of a domain name group based on the specified parameters.
 *
 * @description Modifies the name of an existing domain name group.
 *
 * @param request UpdateDomainGroupRequest
 * @return UpdateDomainGroupResponse
 */
async function updateDomainGroup(request: UpdateDomainGroupRequest): UpdateDomainGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDomainGroupWithOptions(request, runtime);
}

model UpdateDomainRecordRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  line?: string(name='Line', description='The resolution line. Default value: **default**.

For more information, see

[DNS resolution lines](https://www.alibabacloud.com/help/zh/doc-detail/29807.htm).', example='default'),
  priority?: long(name='Priority', description='The priority of the mail exchanger (MX) record. Valid values: `1 to 50`.

This parameter is required if the type of the DNS record is MX.', example='1'),
  RR?: string(name='RR', description='The hostname.

For example, if you want to resolve @.example.com, you must set RR to an at sign (@) instead of leaving it empty.

This parameter is required.', example='www'),
  recordId?: string(name='RecordId', description='The ID of the Domain Name System (DNS) record.

You can call the [DescribeDomainRecords](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomainrecords?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.

This parameter is required.', example='9999985'),
  TTL?: long(name='TTL', description='The time to live (TTL) period of the Alibaba Cloud DNS (DNS) record. Default value: 600. Unit: seconds.

For more information, see

[TTL definition](https://www.alibabacloud.com/help/zh/doc-detail/29806.htm).', example='600'),
  type?: string(name='Type', description='The type of the DNS record. For more information, see

[DNS record types](https://www.alibabacloud.com/help/zh/doc-detail/29805.htm).

This parameter is required.', example='A'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0'),
  value?: string(name='Value', description='The value of the DNS record.

This parameter is required.', example='192.0.2.254'),
}

model UpdateDomainRecordResponseBody = {
  recordId?: string(name='RecordId', description='The ID of the DNS record.', example='9999985'),
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model UpdateDomainRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDomainRecordResponseBody(name='body'),
}

/**
 * @summary Modifies a Domain Name System (DNS) record based on the specified parameters.
 *
 * @param request UpdateDomainRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDomainRecordResponse
 */
async function updateDomainRecordWithOptions(request: UpdateDomainRecordRequest, runtime: Util.RuntimeOptions): UpdateDomainRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.line)) {
    query['Line'] = request.line;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.RR)) {
    query['RR'] = request.RR;
  }
  if (!Util.isUnset(request.recordId)) {
    query['RecordId'] = request.recordId;
  }
  if (!Util.isUnset(request.TTL)) {
    query['TTL'] = request.TTL;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDomainRecord',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a Domain Name System (DNS) record based on the specified parameters.
 *
 * @param request UpdateDomainRecordRequest
 * @return UpdateDomainRecordResponse
 */
async function updateDomainRecord(request: UpdateDomainRecordRequest): UpdateDomainRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDomainRecordWithOptions(request, runtime);
}

model UpdateDomainRecordRemarkRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='cn'),
  recordId?: string(name='RecordId', description='The ID of the DNS record. You can call the [DescribeDomainRecords](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomainrecords?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.

This parameter is required.', example='12345678'),
  remark?: string(name='Remark', description='The description of the DNS record. This parameter is empty by default. If this parameter is empty, the original remarks are deleted.'),
  userClientIp?: string(name='UserClientIp', description='The IP address of the client.', example='192.0.2.0'),
}

model UpdateDomainRecordRemarkResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model UpdateDomainRecordRemarkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDomainRecordRemarkResponseBody(name='body'),
}

/**
 * @summary Modifies the description of a Domain Name System (DNS) record based on the specified parameters.
 *
 * @param request UpdateDomainRecordRemarkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDomainRecordRemarkResponse
 */
async function updateDomainRecordRemarkWithOptions(request: UpdateDomainRecordRemarkRequest, runtime: Util.RuntimeOptions): UpdateDomainRecordRemarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recordId)) {
    query['RecordId'] = request.recordId;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDomainRecordRemark',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the description of a Domain Name System (DNS) record based on the specified parameters.
 *
 * @param request UpdateDomainRecordRemarkRequest
 * @return UpdateDomainRecordRemarkResponse
 */
async function updateDomainRecordRemark(request: UpdateDomainRecordRemarkRequest): UpdateDomainRecordRemarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDomainRecordRemarkWithOptions(request, runtime);
}

model UpdateDomainRemarkRequest {
  domainName?: string(name='DomainName', description='The domain name that already exists in Alibaba Cloud Domain Name System (DNS). You can call the [DescribeDomains ](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0)operation to obtain the domain name.

This parameter is required.', example='mydomain.com'),
  lang?: string(name='Lang', description='The language of the response. Valid values:

*   zh: Chinese
*   en: English

Default value: en', example='cn'),
  remark?: string(name='Remark', description='The description of the domain name.

It can be up to 50 characters in length and can contain digits, letters, and the following special characters: _ - , .'),
}

model UpdateDomainRemarkResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='536E9CAD-DB30-4647-AC87-AA5CC38C5382'),
}

model UpdateDomainRemarkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDomainRemarkResponseBody(name='body'),
}

/**
 * @summary Modifies the description of a domain name based on the specified parameters.
 *
 * @param request UpdateDomainRemarkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDomainRemarkResponse
 */
async function updateDomainRemarkWithOptions(request: UpdateDomainRemarkRequest, runtime: Util.RuntimeOptions): UpdateDomainRemarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDomainRemark',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the description of a domain name based on the specified parameters.
 *
 * @param request UpdateDomainRemarkRequest
 * @return UpdateDomainRemarkResponse
 */
async function updateDomainRemark(request: UpdateDomainRemarkRequest): UpdateDomainRemarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDomainRemarkWithOptions(request, runtime);
}

model UpdateGtmAccessStrategyRequest {
  accessLines?: string(name='AccessLines', description='The line codes of access regions.', example='["default", "mobile"]'),
  defaultAddrPoolId?: string(name='DefaultAddrPoolId', description='The ID of the default address pool.', example='hrsix'),
  failoverAddrPoolId?: string(name='FailoverAddrPoolId', description='The ID of the failover address pool.', example='hrsyw'),
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  strategyId?: string(name='StrategyId', description='The ID of the access policy that you want to query for the GTM instance.

This parameter is required.', example='hrmxc'),
  strategyName?: string(name='StrategyName', description='The name of the access policy.'),
}

model UpdateGtmAccessStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
}

model UpdateGtmAccessStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateGtmAccessStrategyResponseBody(name='body'),
}

/**
 * @param request UpdateGtmAccessStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateGtmAccessStrategyResponse
 */
async function updateGtmAccessStrategyWithOptions(request: UpdateGtmAccessStrategyRequest, runtime: Util.RuntimeOptions): UpdateGtmAccessStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessLines)) {
    query['AccessLines'] = request.accessLines;
  }
  if (!Util.isUnset(request.defaultAddrPoolId)) {
    query['DefaultAddrPoolId'] = request.defaultAddrPoolId;
  }
  if (!Util.isUnset(request.failoverAddrPoolId)) {
    query['FailoverAddrPoolId'] = request.failoverAddrPoolId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  if (!Util.isUnset(request.strategyName)) {
    query['StrategyName'] = request.strategyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGtmAccessStrategy',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateGtmAccessStrategyRequest
 * @return UpdateGtmAccessStrategyResponse
 */
async function updateGtmAccessStrategy(request: UpdateGtmAccessStrategyRequest): UpdateGtmAccessStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGtmAccessStrategyWithOptions(request, runtime);
}

model UpdateGtmAddressPoolRequest {
  addr?: [ 
    {
      lbaWeight?: int32(name='LbaWeight', description='The weight of the address pool that you want to modify.', example='1'),
      mode?: string(name='Mode', description='The mode of the address pool that you want to modify.

*   **SMART**: Intelligent return
*   **ONLINE**: Always online
*   **OFFLINE**: Always offline', example='SMART'),
      value?: string(name='Value', description='The addresses in the address pool.', example='1.1.1.1'),
    }
  ](name='Addr', description='This parameter is required.'),
  addrPoolId?: string(name='AddrPoolId', description='The ID of the address pool that you want to modify.

This parameter is required.', example='1234abc'),
  lang?: string(name='Lang', description='The language used by the user.', example='en'),
  minAvailableAddrNum?: int32(name='MinAvailableAddrNum', description='The minimum number of available addresses in the address pool.', example='2'),
  name?: string(name='Name', description='The name of the address pool that you want to modify.'),
  type?: string(name='Type', description='The type of the address pool that you want to modify.

This parameter is required.', example='IP'),
}

model UpdateGtmAddressPoolResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model UpdateGtmAddressPoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateGtmAddressPoolResponseBody(name='body'),
}

/**
 * @param request UpdateGtmAddressPoolRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateGtmAddressPoolResponse
 */
async function updateGtmAddressPoolWithOptions(request: UpdateGtmAddressPoolRequest, runtime: Util.RuntimeOptions): UpdateGtmAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addr)) {
    query['Addr'] = request.addr;
  }
  if (!Util.isUnset(request.addrPoolId)) {
    query['AddrPoolId'] = request.addrPoolId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.minAvailableAddrNum)) {
    query['MinAvailableAddrNum'] = request.minAvailableAddrNum;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGtmAddressPool',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateGtmAddressPoolRequest
 * @return UpdateGtmAddressPoolResponse
 */
async function updateGtmAddressPool(request: UpdateGtmAddressPoolRequest): UpdateGtmAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGtmAddressPoolWithOptions(request, runtime);
}

model UpdateGtmInstanceGlobalConfigRequest {
  alertGroup?: string(name='AlertGroup', description='The alert group. Only one alert group is supported.

>  This parameter is required only for the first modification.'),
  cnameCustomDomainName?: string(name='CnameCustomDomainName', description='If you set **CnameMode** to **CUSTOM**, you must specify the CnameCustomDomainName parameter, which must be set to a primary domain name.', example='www.example.com'),
  cnameMode?: string(name='CnameMode', description='Specifies whether to use a system-assigned canonical name (CNAME) or a custom CNAME to access GTM. Valid values:

*   **SYSTEM_ASSIGN**: system-assigned CNAME
*   **CUSTOM**: custom CNAME', example='SYSTEM_ASSIGN'),
  instanceId?: string(name='InstanceId', description='The ID of the GTM instance.

This parameter is required.', example='instance1'),
  instanceName?: string(name='InstanceName', description='The name of the GTM instance.

>  This parameter is required only for the first modification.'),
  lang?: string(name='Lang', description='The language.', example='en'),
  lbaStrategy?: string(name='LbaStrategy', description='The balancing policy. Valid values:

*   **ALL_RR**: load balancing
*   **RATIO**: weighted round-robin

>  This parameter is required only for the first modification.', example='RATIO'),
  ttl?: int32(name='Ttl', description='The global time-to-live (TTL).', example='60'),
  userDomainName?: string(name='UserDomainName', description='The primary domain name.

>  This parameter is required only for the first modification.', example='www.example.com'),
}

model UpdateGtmInstanceGlobalConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='29D0F8F8-5499-4F6C-9FDC-1EE13BF55925'),
}

model UpdateGtmInstanceGlobalConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateGtmInstanceGlobalConfigResponseBody(name='body'),
}

/**
 * @summary Modifies the configurations of a Global Traffic Manager (GTM) instance based on the specified parameters.
 *
 * @param request UpdateGtmInstanceGlobalConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateGtmInstanceGlobalConfigResponse
 */
async function updateGtmInstanceGlobalConfigWithOptions(request: UpdateGtmInstanceGlobalConfigRequest, runtime: Util.RuntimeOptions): UpdateGtmInstanceGlobalConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertGroup)) {
    query['AlertGroup'] = request.alertGroup;
  }
  if (!Util.isUnset(request.cnameCustomDomainName)) {
    query['CnameCustomDomainName'] = request.cnameCustomDomainName;
  }
  if (!Util.isUnset(request.cnameMode)) {
    query['CnameMode'] = request.cnameMode;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lbaStrategy)) {
    query['LbaStrategy'] = request.lbaStrategy;
  }
  if (!Util.isUnset(request.ttl)) {
    query['Ttl'] = request.ttl;
  }
  if (!Util.isUnset(request.userDomainName)) {
    query['UserDomainName'] = request.userDomainName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGtmInstanceGlobalConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the configurations of a Global Traffic Manager (GTM) instance based on the specified parameters.
 *
 * @param request UpdateGtmInstanceGlobalConfigRequest
 * @return UpdateGtmInstanceGlobalConfigResponse
 */
async function updateGtmInstanceGlobalConfig(request: UpdateGtmInstanceGlobalConfigRequest): UpdateGtmInstanceGlobalConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGtmInstanceGlobalConfigWithOptions(request, runtime);
}

model UpdateGtmMonitorRequest {
  evaluationCount?: int32(name='EvaluationCount', description='The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.', example='3'),
  interval?: int32(name='Interval', description='The health check interval. Unit: seconds. Set the value to 60.', example='60'),
  ispCityNode?: [ 
    {
      cityCode?: string(name='CityCode', description='The code of the city where the monitored node is deployed.', example='572'),
      ispCode?: string(name='IspCode', description='*   The code of the Internet service provider (ISP) to which the monitored node belongs. For more information about specific values, see the response parameters of DescribeGtmMonitorAvailableConfig.
*   If the value of the GroupType parameter is BGP or OVERSEAS, IspCode is optional. The default value is 465.
*   If the value of the GroupType parameter is not BGP or OVERSEAS, IspCode is required and is used together with CityCode.', example='465'),
    }
  ](name='IspCityNode', description='The monitored nodes.

This parameter is required.'),
  lang?: string(name='Lang', description='The language of the values of specific response parameters.', example='en'),
  monitorConfigId?: string(name='MonitorConfigId', description='The ID of the health check configuration.

This parameter is required.', example='1234abc'),
  monitorExtendInfo?: string(name='MonitorExtendInfo', description='The extended information, that is, the parameters required for the protocol. Different protocols require different parameters:

HTTP or HTTPS:

*   port: the port to check.
*   failureRate: the failure rate.
*   code: the status code threshold. If the returned status code is greater than the specified threshold, the application service is deemed abnormal. Valid values: 400 and 500.
*   host: the host configuration.
*   path: the health check URL.

PING:

*   packetNum: the number of ping packets.
*   packetLossRate: the loss rate of ping packets.
*   failureRate: the failure rate.

TCP:

*   port: the port to check.
*   failureRate: the failure rate.

This parameter is required.', example='{\\\\"code\\\\":200,\\\\"path\\\\":\\\\"\\\\\\\\index.htm\\\\",\\\\"host\\\\":\\\\"aliyun.com\\\\"}'),
  protocolType?: string(name='ProtocolType', description='The protocol used for the health check.

This parameter is required.', example='HTTP'),
  timeout?: int32(name='Timeout', description='The health check timeout period. Unit: milliseconds. Valid values: 2000, 3000, 5000, and 10000.', example='3000'),
}

model UpdateGtmMonitorResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model UpdateGtmMonitorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateGtmMonitorResponseBody(name='body'),
}

/**
 * @summary Modifies the health check configuration for an address pool of a Global Traffic Manager (GTM) instance.
 *
 * @param request UpdateGtmMonitorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateGtmMonitorResponse
 */
async function updateGtmMonitorWithOptions(request: UpdateGtmMonitorRequest, runtime: Util.RuntimeOptions): UpdateGtmMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispCityNode)) {
    query['IspCityNode'] = request.ispCityNode;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.monitorConfigId)) {
    query['MonitorConfigId'] = request.monitorConfigId;
  }
  if (!Util.isUnset(request.monitorExtendInfo)) {
    query['MonitorExtendInfo'] = request.monitorExtendInfo;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGtmMonitor',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the health check configuration for an address pool of a Global Traffic Manager (GTM) instance.
 *
 * @param request UpdateGtmMonitorRequest
 * @return UpdateGtmMonitorResponse
 */
async function updateGtmMonitor(request: UpdateGtmMonitorRequest): UpdateGtmMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGtmMonitorWithOptions(request, runtime);
}

model UpdateGtmRecoveryPlanRequest {
  faultAddrPool?: string(name='FaultAddrPool', description='The list of faulty address pools.', example='["hra0or"]'),
  lang?: string(name='Lang', description='The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.', example='en'),
  name?: string(name='Name', description='The name of the disaster recovery plan.', example='abc'),
  recoveryPlanId?: long(name='RecoveryPlanId', description='The ID of the disaster recovery plan.

This parameter is required.', example='100'),
  remark?: string(name='Remark', description='The remarks about the disaster recovery plan.', example='remark'),
}

model UpdateGtmRecoveryPlanResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6856BCF6-11D6-4D7E-AC53-FD579933522B'),
}

model UpdateGtmRecoveryPlanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateGtmRecoveryPlanResponseBody(name='body'),
}

/**
 * @summary Modifies a disaster recovery plan.
 *
 * @param request UpdateGtmRecoveryPlanRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateGtmRecoveryPlanResponse
 */
async function updateGtmRecoveryPlanWithOptions(request: UpdateGtmRecoveryPlanRequest, runtime: Util.RuntimeOptions): UpdateGtmRecoveryPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.faultAddrPool)) {
    query['FaultAddrPool'] = request.faultAddrPool;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.recoveryPlanId)) {
    query['RecoveryPlanId'] = request.recoveryPlanId;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGtmRecoveryPlan',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a disaster recovery plan.
 *
 * @param request UpdateGtmRecoveryPlanRequest
 * @return UpdateGtmRecoveryPlanResponse
 */
async function updateGtmRecoveryPlan(request: UpdateGtmRecoveryPlanRequest): UpdateGtmRecoveryPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGtmRecoveryPlanWithOptions(request, runtime);
}

model UpdateIspFlushCacheInstanceConfigRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  instanceName?: string(name='InstanceName', description='This parameter is required.'),
  lang?: string(name='Lang'),
}

model UpdateIspFlushCacheInstanceConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIspFlushCacheInstanceConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateIspFlushCacheInstanceConfigResponseBody(name='body'),
}

/**
 * @summary 
 *
 * @param request UpdateIspFlushCacheInstanceConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateIspFlushCacheInstanceConfigResponse
 */
async function updateIspFlushCacheInstanceConfigWithOptions(request: UpdateIspFlushCacheInstanceConfigRequest, runtime: Util.RuntimeOptions): UpdateIspFlushCacheInstanceConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIspFlushCacheInstanceConfig',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 
 *
 * @param request UpdateIspFlushCacheInstanceConfigRequest
 * @return UpdateIspFlushCacheInstanceConfigResponse
 */
async function updateIspFlushCacheInstanceConfig(request: UpdateIspFlushCacheInstanceConfigRequest): UpdateIspFlushCacheInstanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIspFlushCacheInstanceConfigWithOptions(request, runtime);
}

model ValidateDnsGtmCnameRrCanUseRequest {
  cnameMode?: string(name='CnameMode', description='This parameter is required.'),
  cnameRr?: string(name='CnameRr', description='This parameter is required.'),
  cnameType?: string(name='CnameType', description='This parameter is required.'),
  cnameZone?: string(name='CnameZone', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  lang?: string(name='Lang'),
}

model ValidateDnsGtmCnameRrCanUseResponseBody = {
  requestId?: string(name='RequestId'),
}

model ValidateDnsGtmCnameRrCanUseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ValidateDnsGtmCnameRrCanUseResponseBody(name='body'),
}

/**
 * @summary 
 *
 * @param request ValidateDnsGtmCnameRrCanUseRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ValidateDnsGtmCnameRrCanUseResponse
 */
async function validateDnsGtmCnameRrCanUseWithOptions(request: ValidateDnsGtmCnameRrCanUseRequest, runtime: Util.RuntimeOptions): ValidateDnsGtmCnameRrCanUseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cnameMode)) {
    query['CnameMode'] = request.cnameMode;
  }
  if (!Util.isUnset(request.cnameRr)) {
    query['CnameRr'] = request.cnameRr;
  }
  if (!Util.isUnset(request.cnameType)) {
    query['CnameType'] = request.cnameType;
  }
  if (!Util.isUnset(request.cnameZone)) {
    query['CnameZone'] = request.cnameZone;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ValidateDnsGtmCnameRrCanUse',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 
 *
 * @param request ValidateDnsGtmCnameRrCanUseRequest
 * @return ValidateDnsGtmCnameRrCanUseResponse
 */
async function validateDnsGtmCnameRrCanUse(request: ValidateDnsGtmCnameRrCanUseRequest): ValidateDnsGtmCnameRrCanUseResponse {
  var runtime = new Util.RuntimeOptions{};
  return validateDnsGtmCnameRrCanUseWithOptions(request, runtime);
}

model ValidatePdnsUdpIpSegmentRequest {
  ip?: string(name='Ip'),
  ipToken?: string(name='IpToken'),
  lang?: string(name='Lang'),
}

model ValidatePdnsUdpIpSegmentResponseBody = {
  requestId?: string(name='RequestId'),
}

model ValidatePdnsUdpIpSegmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ValidatePdnsUdpIpSegmentResponseBody(name='body'),
}

/**
 * @summary DNS Udp Ip
 *
 * @param request ValidatePdnsUdpIpSegmentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ValidatePdnsUdpIpSegmentResponse
 */
async function validatePdnsUdpIpSegmentWithOptions(request: ValidatePdnsUdpIpSegmentRequest, runtime: Util.RuntimeOptions): ValidatePdnsUdpIpSegmentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.ipToken)) {
    query['IpToken'] = request.ipToken;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ValidatePdnsUdpIpSegment',
    version = '2015-01-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DNS Udp Ip
 *
 * @param request ValidatePdnsUdpIpSegmentRequest
 * @return ValidatePdnsUdpIpSegmentResponse
 */
async function validatePdnsUdpIpSegment(request: ValidatePdnsUdpIpSegmentRequest): ValidatePdnsUdpIpSegmentResponse {
  var runtime = new Util.RuntimeOptions{};
  return validatePdnsUdpIpSegmentWithOptions(request, runtime);
}

